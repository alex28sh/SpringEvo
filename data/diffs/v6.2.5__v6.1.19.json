{
  "org.springframework.aop.aspectj.autoproxy.AspectJAwareAdvisorAutoProxyCreator#afterSingletonsInstantiated()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "void",
    "signature": "public void afterSingletonsInstantiated()",
    "source_code": "\tpublic void afterSingletonsInstantiated() {\n\t\tShadowMatchUtils.clearCache();\n\t}"
  },
  "org.springframework.aop.aspectj.autoproxy.AspectJAwareAdvisorAutoProxyCreator#destroy()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "void",
    "signature": "public void destroy()",
    "source_code": "\tpublic void destroy() {\n\t\tShadowMatchUtils.clearCache();\n\t}"
  },
  "org.springframework.aop.framework.SerializableNoOp#proceed()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 767
    },
    "return": "Object",
    "signature": "public Object proceed()",
    "source_code": "\t\tpublic Object proceed() throws Throwable {\n\t\t\ttry {\n\t\t\t\treturn super.proceed();\n\t\t\t}\n\t\t\tcatch (RuntimeException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tif (ReflectionUtils.declaresException(getMethod(), ex.getClass()) ||\n\t\t\t\t\t\tKotlinDetector.isKotlinType(getMethod().getDeclaringClass())) {\n\t\t\t\t\t// Propagate original exception if declared on the target method\n\t\t\t\t\t// (with callers expecting it). Always propagate it for Kotlin code\n\t\t\t\t\t// since checked exceptions do not have to be explicitly declared there.\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Checked exception thrown in the interceptor but not declared on the\n\t\t\t\t\t// target method signature -> apply an UndeclaredThrowableException,\n\t\t\t\t\t// aligned with standard JDK dynamic proxy behavior.\n\t\t\t\t\tthrow new UndeclaredThrowableException(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract BeanFactory-based PointcutAdvisor that allows for any Advice\n * to be configured as reference to an Advice bean in a BeanFactory.\n *\n * <p>Specifying the name of an advice bean instead of the advice object itself\n * (if running within a BeanFactory) increases loose coupling at initialization time,\n * in order to not initialize the advice object until the pointcut actually matches.\n *\n * @author Juergen Hoeller\n * @since 2.0.2\n * @see #setAdviceBeanName\n * @see DefaultBeanFactoryPointcutAdvisor\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "signature": "public class AbstractBeanFactoryPointcutAdvisor",
    "source_code": "public abstract class AbstractBeanFactoryPointcutAdvisor extends AbstractPointcutAdvisor implements BeanFactoryAware {\n\n\t@Nullable\n\tprivate String adviceBeanName;\n\n\t@Nullable\n\tprivate BeanFactory beanFactory;\n\n\t@Nullable\n\tprivate transient volatile Advice advice;\n\n\tprivate transient volatile Object adviceMonitor = new Object();\n\n\n\t/**\n\t * Specify the name of the advice bean that this advisor should refer to.\n\t * <p>An instance of the specified bean will be obtained on first access\n\t * of this advisor's advice. This advisor will only ever obtain at most one\n\t * single instance of the advice bean, caching the instance for the lifetime\n\t * of the advisor.\n\t * @see #getAdvice()\n\t */\n\tpublic void setAdviceBeanName(@Nullable String adviceBeanName) {\n\t\tthis.adviceBeanName = adviceBeanName;\n\t}\n\n\t/**\n\t * Return the name of the advice bean that this advisor refers to, if any.\n\t */\n\t@Nullable\n\tpublic String getAdviceBeanName() {\n\t\treturn this.adviceBeanName;\n\t}\n\n\t@Override\n\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t\tresetAdviceMonitor();\n\t}\n\n\tprivate void resetAdviceMonitor() {\n\t\tif (this.beanFactory instanceof ConfigurableBeanFactory cbf) {\n\t\t\tthis.adviceMonitor = cbf.getSingletonMutex();\n\t\t}\n\t\telse {\n\t\t\tthis.adviceMonitor = new Object();\n\t\t}\n\t}\n\n\t/**\n\t * Specify a particular instance of the target advice directly,\n\t * avoiding lazy resolution in {@link #getAdvice()}.\n\t * @since 3.1\n\t */\n\tpublic void setAdvice(Advice advice) {\n\t\tsynchronized (this.adviceMonitor) {\n\t\t\tthis.advice = advice;\n\t\t}\n\t}\n\n\t@Override\n\tpublic Advice getAdvice() {\n\t\tAdvice advice = this.advice;\n\t\tif (advice != null) {\n\t\t\treturn advice;\n\t\t}\n\n\t\tAssert.state(this.adviceBeanName != null, \"'adviceBeanName' must be specified\");\n\t\tAssert.state(this.beanFactory != null, \"BeanFactory must be set to resolve 'adviceBeanName'\");\n\n\t\tif (this.beanFactory.isSingleton(this.adviceBeanName)) {\n\t\t\t// Rely on singleton semantics provided by the factory.\n\t\t\tadvice = this.beanFactory.getBean(this.adviceBeanName, Advice.class);\n\t\t\tthis.advice = advice;\n\t\t\treturn advice;\n\t\t}\n\t\telse {\n\t\t\t// No singleton guarantees from the factory -> let's lock locally but\n\t\t\t// reuse the factory's singleton lock, just in case a lazy dependency\n\t\t\t// of our advice bean happens to trigger the singleton lock implicitly...\n\t\t\tsynchronized (this.adviceMonitor) {\n\t\t\t\tadvice = this.advice;\n\t\t\t\tif (advice == null) {\n\t\t\t\t\tadvice = this.beanFactory.getBean(this.adviceBeanName, Advice.class);\n\t\t\t\t\tthis.advice = advice;\n\t\t\t\t}\n\t\t\t\treturn advice;\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder(getClass().getName());\n\t\tsb.append(\": advice \");\n\t\tif (this.adviceBeanName != null) {\n\t\t\tsb.append(\"bean '\").append(this.adviceBeanName).append('\\'');\n\t\t}\n\t\telse {\n\t\t\tsb.append(this.advice);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Serialization support\n\t//---------------------------------------------------------------------\n\n\tprivate void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\n\t\t// Rely on default serialization, just initialize state after deserialization.\n\t\tois.defaultReadObject();\n\n\t\t// Initialize transient fields.\n\t\tresetAdviceMonitor();\n\t}\n\n}"
  },
  "org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor#getAdvice()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "Advice",
    "signature": "public Advice getAdvice()",
    "source_code": "\tpublic Advice getAdvice() {\n\t\tAdvice advice = this.advice;\n\t\tif (advice != null) {\n\t\t\treturn advice;\n\t\t}\n\n\t\tAssert.state(this.adviceBeanName != null, \"'adviceBeanName' must be specified\");\n\t\tAssert.state(this.beanFactory != null, \"BeanFactory must be set to resolve 'adviceBeanName'\");\n\n\t\tif (this.beanFactory.isSingleton(this.adviceBeanName)) {\n\t\t\t// Rely on singleton semantics provided by the factory.\n\t\t\tadvice = this.beanFactory.getBean(this.adviceBeanName, Advice.class);\n\t\t\tthis.advice = advice;\n\t\t\treturn advice;\n\t\t}\n\t\telse {\n\t\t\t// No singleton guarantees from the factory -> let's lock locally but\n\t\t\t// reuse the factory's singleton lock, just in case a lazy dependency\n\t\t\t// of our advice bean happens to trigger the singleton lock implicitly...\n\t\t\tsynchronized (this.adviceMonitor) {\n\t\t\t\tadvice = this.advice;\n\t\t\t\tif (advice == null) {\n\t\t\t\t\tadvice = this.beanFactory.getBean(this.adviceBeanName, Advice.class);\n\t\t\t\t\tthis.advice = advice;\n\t\t\t\t}\n\t\t\t\treturn advice;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor#getAdviceBeanName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the name of the advice bean that this advisor refers to, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "String",
    "signature": "public String getAdviceBeanName()",
    "source_code": "\tpublic String getAdviceBeanName() {\n\t\treturn this.adviceBeanName;\n\t}"
  },
  "org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor#setAdvice(advice)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify a particular instance of the target advice directly,\n\t * avoiding lazy resolution in {@link #getAdvice()}.\n\t * @since 3.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "advice"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void setAdvice(Advice advice)",
    "source_code": "\tpublic void setAdvice(Advice advice) {\n\t\tsynchronized (this.adviceMonitor) {\n\t\t\tthis.advice = advice;\n\t\t}\n\t}"
  },
  "org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor#setAdviceBeanName(adviceBeanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the name of the advice bean that this advisor should refer to.\n\t * <p>An instance of the specified bean will be obtained on first access\n\t * of this advisor's advice. This advisor will only ever obtain at most one\n\t * single instance of the advice bean, caching the instance for the lifetime\n\t * of the advisor.\n\t * @see #getAdvice()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "adviceBeanName"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "void",
    "signature": "public void setAdviceBeanName(@Nullable String adviceBeanName)",
    "source_code": "\tpublic void setAdviceBeanName(@Nullable String adviceBeanName) {\n\t\tthis.adviceBeanName = adviceBeanName;\n\t}"
  },
  "org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t\tresetAdviceMonitor();\n\t}"
  },
  "org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder(getClass().getName());\n\t\tsb.append(\": advice \");\n\t\tif (this.adviceBeanName != null) {\n\t\t\tsb.append(\"bean '\").append(this.adviceBeanName).append('\\'');\n\t\t}\n\t\telse {\n\t\t\tsb.append(this.advice);\n\t\t}\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.aot.generate.FileSystemGeneratedFiles#addFile(kind,path,content)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "kind",
      "path",
      "content"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void addFile(Kind kind, String path, InputStreamSource content)",
    "source_code": "\tpublic void addFile(Kind kind, String path, InputStreamSource content) {\n\t\tAssert.notNull(kind, \"'kind' must not be null\");\n\t\tAssert.hasLength(path, \"'path' must not be empty\");\n\t\tAssert.notNull(content, \"'content' must not be null\");\n\t\tPath root = this.roots.apply(kind).toAbsolutePath().normalize();\n\t\tPath relativePath = root.resolve(path).toAbsolutePath().normalize();\n\t\tAssert.isTrue(relativePath.startsWith(root), \"'path' must be relative\");\n\t\ttry {\n\t\t\ttry (InputStream inputStream = content.getInputStream()) {\n\t\t\t\tFiles.createDirectories(relativePath.getParent());\n\t\t\t\tFiles.copy(inputStream, relativePath);\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new IllegalStateException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.aot.generate.FileSystemGeneratedFiles#copy(content,override)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "content",
      "override"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "protected void copy(InputStreamSource content, boolean override)",
    "source_code": "\t\tprotected void copy(InputStreamSource content, boolean override) {\n\t\t\tif (override) {\n\t\t\t\tcopy(content, StandardCopyOption.REPLACE_EXISTING);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcopy(content);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.aot.generate.FileSystemGeneratedFiles#handleFile(kind,path,handler)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "kind",
      "path",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "void",
    "signature": "public void handleFile(Kind kind, String path, ThrowingConsumer<FileHandler> handler)",
    "source_code": "\tpublic void handleFile(Kind kind, String path, ThrowingConsumer<FileHandler> handler) {\n\t\tFileSystemFileHandler fileHandler = new FileSystemFileHandler(toPath(kind, path));\n\t\thandler.accept(fileHandler);\n\t}"
  },
  "org.springframework.aot.generate.FileSystemGeneratedFiles#toString()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn this.path.toString();\n\t\t}"
  },
  "org.springframework.aot.hint.annotation.ReflectionRegistration": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "record",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "signature": "protected record ReflectionRegistration",
    "source_code": "\tprotected record ReflectionRegistration(Class<?>[] classes, MemberCategory[] memberCategories) {\n\t}"
  },
  "org.springframework.aot.hint.annotation.ReflectionRegistration#<init>(classes,memberCategories)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "constructor",
    "modifiers": [
      "protected"
    ],
    "params": [
      "classes",
      "memberCategories"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "signature": "protected ReflectionRegistration(Class<?>[] classes, MemberCategory[] memberCategories)",
    "source_code": "\tprotected record ReflectionRegistration(Class<?>[] classes, MemberCategory[] memberCategories) {\n\t}"
  },
  "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessor": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * A {@link ReflectiveProcessor} implementation that pairs with\n * {@link RegisterReflection @RegisterReflection}. Can be used as a base\n * implementation for composed annotations that are meta-annotated with\n * {@link RegisterReflection}.\n *\n * @author Stephane Nicoll\n * @since 6.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "signature": "public class RegisterReflectionReflectiveProcessor",
    "source_code": "public class RegisterReflectionReflectiveProcessor implements ReflectiveProcessor {\n\n\tprivate static final Log logger = LogFactory.getLog(RegisterReflectionReflectiveProcessor.class);\n\n\n\t@Override\n\tpublic final void registerReflectionHints(ReflectionHints hints, AnnotatedElement element) {\n\t\tRegisterReflection annotation = AnnotatedElementUtils.getMergedAnnotation(element, RegisterReflection.class);\n\t\tAssert.notNull(annotation, () -> \"Element must be annotated with @RegisterReflection: \" + element);\n\t\tReflectionRegistration registration = parse(element, annotation);\n\t\tregisterReflectionHints(hints, registration);\n\t}\n\n\tprotected ReflectionRegistration parse(AnnotatedElement element, RegisterReflection annotation) {\n\t\tList<Class<?>> allClassNames = new ArrayList<>();\n\t\tallClassNames.addAll(Arrays.asList(annotation.classes()));\n\t\tallClassNames.addAll(Arrays.stream(annotation.classNames())\n\t\t\t\t.map(this::loadClass).filter(Objects::nonNull).toList());\n\t\tif (allClassNames.isEmpty()) {\n\t\t\tif (element instanceof Class<?> clazz) {\n\t\t\t\tallClassNames.add(clazz);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalStateException(\"At least one class must be specified: \" + element);\n\t\t\t}\n\t\t}\n\t\treturn new ReflectionRegistration(allClassNames.toArray(new Class<?>[0]), annotation.memberCategories());\n\t}\n\n\tprotected void registerReflectionHints(ReflectionHints hints, ReflectionRegistration registration) {\n\t\tfor (Class<?> target : registration.classes) {\n\t\t\tregisterReflectionHints(hints, target, registration.memberCategories);\n\t\t}\n\t}\n\n\tprotected void registerReflectionHints(ReflectionHints hints, Class<?> target, MemberCategory[] memberCategories) {\n\t\thints.registerType(target, type -> type.withMembers(memberCategories));\n\t}\n\n\t@Nullable\n\tprivate Class<?> loadClass(String className) {\n\t\ttry {\n\t\t\treturn ClassUtils.forName(className, getClass().getClassLoader());\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Ignoring '\" + className + \"': \" + ex);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\tprotected record ReflectionRegistration(Class<?>[] classes, MemberCategory[] memberCategories) {\n\t}\n\n}"
  },
  "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessor#parse(element,annotation)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "element",
      "annotation"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "ReflectionRegistration",
    "signature": "protected ReflectionRegistration parse(AnnotatedElement element, RegisterReflection annotation)",
    "source_code": "\tprotected ReflectionRegistration parse(AnnotatedElement element, RegisterReflection annotation) {\n\t\tList<Class<?>> allClassNames = new ArrayList<>();\n\t\tallClassNames.addAll(Arrays.asList(annotation.classes()));\n\t\tallClassNames.addAll(Arrays.stream(annotation.classNames())\n\t\t\t\t.map(this::loadClass).filter(Objects::nonNull).toList());\n\t\tif (allClassNames.isEmpty()) {\n\t\t\tif (element instanceof Class<?> clazz) {\n\t\t\t\tallClassNames.add(clazz);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalStateException(\"At least one class must be specified: \" + element);\n\t\t\t}\n\t\t}\n\t\treturn new ReflectionRegistration(allClassNames.toArray(new Class<?>[0]), annotation.memberCategories());\n\t}"
  },
  "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessor#registerReflectionHints(hints,element)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hints",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "return": "void",
    "signature": "public void registerReflectionHints(ReflectionHints hints, AnnotatedElement element)",
    "source_code": "\tpublic final void registerReflectionHints(ReflectionHints hints, AnnotatedElement element) {\n\t\tRegisterReflection annotation = AnnotatedElementUtils.getMergedAnnotation(element, RegisterReflection.class);\n\t\tAssert.notNull(annotation, () -> \"Element must be annotated with @RegisterReflection: \" + element);\n\t\tReflectionRegistration registration = parse(element, annotation);\n\t\tregisterReflectionHints(hints, registration);\n\t}"
  },
  "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessor#registerReflectionHints(hints,registration)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "registration"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "void",
    "signature": "protected void registerReflectionHints(ReflectionHints hints, ReflectionRegistration registration)",
    "source_code": "\tprotected void registerReflectionHints(ReflectionHints hints, ReflectionRegistration registration) {\n\t\tfor (Class<?> target : registration.classes) {\n\t\t\tregisterReflectionHints(hints, target, registration.memberCategories);\n\t\t}\n\t}"
  },
  "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessor#registerReflectionHints(hints,target,memberCategories)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "target",
      "memberCategories"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "protected void registerReflectionHints(ReflectionHints hints, Class<?> target, MemberCategory[] memberCategories)",
    "source_code": "\tprotected void registerReflectionHints(ReflectionHints hints, Class<?> target, MemberCategory[] memberCategories) {\n\t\thints.registerType(target, type -> type.withMembers(memberCategories));\n\t}"
  },
  "org.springframework.beans.factory.annotation.BeanFactoryAnnotationUtils#getQualifierValue(annotatedElement)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the {@link Qualifier#value() qualifier value} for the given\n\t * annotated element.\n\t * @param annotatedElement the class, method or parameter to introspect\n\t * @return the associated qualifier value, or {@code null} if none\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "String",
    "signature": "public String getQualifierValue(AnnotatedElement annotatedElement)",
    "source_code": "\tpublic static String getQualifierValue(AnnotatedElement annotatedElement) {\n\t\tQualifier qualifier = AnnotationUtils.getAnnotation(annotatedElement, Qualifier.class);\n\t\treturn (qualifier != null ? qualifier.value() : null);\n\t}"
  },
  "org.springframework.beans.factory.annotation.QualifierAnnotationAutowireCandidateResolver#checkQualifiers(bdHolder,annotationsToSearch)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Match the given qualifier annotations against the candidate bean definition.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bdHolder",
      "annotationsToSearch"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "boolean",
    "signature": "protected boolean checkQualifiers(BeanDefinitionHolder bdHolder, Annotation[] annotationsToSearch)",
    "source_code": "\tprotected boolean checkQualifiers(BeanDefinitionHolder bdHolder, Annotation[] annotationsToSearch) {\n\t\tif (ObjectUtils.isEmpty(annotationsToSearch)) {\n\t\t\treturn true;\n\t\t}\n\t\tSimpleTypeConverter typeConverter = new SimpleTypeConverter();\n\t\tfor (Annotation annotation : annotationsToSearch) {\n\t\t\tClass<? extends Annotation> type = annotation.annotationType();\n\t\t\tif (isPlainJavaAnnotation(type)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tboolean checkMeta = true;\n\t\t\tboolean fallbackToMeta = false;\n\t\t\tif (isQualifier(type)) {\n\t\t\t\tif (!checkQualifier(bdHolder, annotation, typeConverter)) {\n\t\t\t\t\tfallbackToMeta = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcheckMeta = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (checkMeta) {\n\t\t\t\tboolean foundMeta = false;\n\t\t\t\tfor (Annotation metaAnn : type.getAnnotations()) {\n\t\t\t\t\tClass<? extends Annotation> metaType = metaAnn.annotationType();\n\t\t\t\t\tif (isPlainJavaAnnotation(metaType)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (isQualifier(metaType)) {\n\t\t\t\t\t\tfoundMeta = true;\n\t\t\t\t\t\t// Only accept fallback match if @Qualifier annotation has a value...\n\t\t\t\t\t\t// Otherwise, it is just a marker for a custom qualifier annotation.\n\t\t\t\t\t\tif ((fallbackToMeta && ObjectUtils.isEmpty(AnnotationUtils.getValue(metaAnn))) ||\n\t\t\t\t\t\t\t\t!checkQualifier(bdHolder, metaAnn, typeConverter)) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (fallbackToMeta && !foundMeta) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.beans.factory.annotation.QualifierAnnotationAutowireCandidateResolver#getSuggestedName(descriptor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 383
    },
    "return": "String",
    "signature": "public String getSuggestedName(DependencyDescriptor descriptor)",
    "source_code": "\tpublic String getSuggestedName(DependencyDescriptor descriptor) {\n\t\tfor (Annotation annotation : descriptor.getAnnotations()) {\n\t\t\tif (isQualifier(annotation.annotationType())) {\n\t\t\t\tObject value = AnnotationUtils.getValue(annotation);\n\t\t\t\tif (value instanceof String str) {\n\t\t\t\t\treturn str;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#applyTo(generationContext,beanFactoryInitializationCode)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanFactoryInitializationCode"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "void",
    "signature": "public void applyTo(GenerationContext generationContext,\n\t\t\tBeanFactoryInitializationCode beanFactoryInitializationCode)",
    "source_code": "\tpublic void applyTo(GenerationContext generationContext,"
  },
  "org.springframework.beans.factory.aot.<unknown>#getClassName()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "ClassName",
    "signature": "public ClassName getClassName()",
    "source_code": "\t\tpublic ClassName getClassName() {\n\t\t\treturn this.generatedClass.getName();\n\t\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#getMethods()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "GeneratedMethods",
    "signature": "public GeneratedMethods getMethods()",
    "source_code": "\t\tpublic GeneratedMethods getMethods() {\n\t\t\treturn this.generatedClass.getMethods();\n\t\t}"
  },
  "org.springframework.beans.factory.aot.BeanInstanceSupplier#withShortcut(beanNames)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a new {@link BeanInstanceSupplier} instance that uses\n\t * direct bean name injection shortcuts for specific parameters.\n\t * @param beanNames the bean names to use as shortcut (aligned with the\n\t * constructor or factory method parameters)\n\t * @return a new {@link BeanInstanceSupplier} instance that uses the\n\t * given shortcut bean names\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanNames"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "BeanInstanceSupplier<T>",
    "signature": "public BeanInstanceSupplier<T> withShortcut(String... beanNames)",
    "source_code": "\tpublic BeanInstanceSupplier<T> withShortcut(String... beanNames) {\n\t\treturn new BeanInstanceSupplier<>(\n\t\t\t\tthis.lookup, this.generatorWithoutArguments, this.generatorWithArguments, beanNames);\n\t}"
  },
  "org.springframework.beans.factory.aot.InstanceSupplierCodeGenerator#registerRuntimeHints(runtimeHints,constructor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runtimeHints",
      "constructor"
    ],
    "position": {
      "column": 1,
      "line": 457
    },
    "return": "void",
    "signature": "public void registerRuntimeHints(RuntimeHints runtimeHints, Constructor<?> constructor)",
    "source_code": "\t\tpublic void registerRuntimeHints(RuntimeHints runtimeHints, Constructor<?> constructor) {\n\t\t\tClass<?>[] parameterTypes = constructor.getParameterTypes();\n\t\t\tfor (int i = 0; i < parameterTypes.length; i++) {\n\t\t\t\tMethodParameter methodParam = new MethodParameter(constructor, i);\n\t\t\t\tDependencyDescriptor dependencyDescriptor = new DependencyDescriptor(\n\t\t\t\t\t\tmethodParam, true);\n\t\t\t\tregisterProxyIfNecessary(runtimeHints, dependencyDescriptor);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.aot.InstanceSupplierCodeGenerator#registerRuntimeHints(runtimeHints,executable)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runtimeHints",
      "executable"
    ],
    "position": {
      "column": 1,
      "line": 427
    },
    "return": "void",
    "signature": "public void registerRuntimeHints(RuntimeHints runtimeHints, Executable executable)",
    "source_code": "\t\tpublic void registerRuntimeHints(RuntimeHints runtimeHints, Executable executable) {\n\t\t\tClass<?>[] parameterTypes = executable.getParameterTypes();\n\t\t\tfor (int i = 0; i < parameterTypes.length; i++) {\n\t\t\t\tMethodParameter methodParam = MethodParameter.forExecutable(executable, i);\n\t\t\t\tDependencyDescriptor dependencyDescriptor = new DependencyDescriptor(methodParam, true);\n\t\t\t\tregisterProxyIfNecessary(runtimeHints, dependencyDescriptor);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.aot.InstanceSupplierCodeGenerator#registerRuntimeHints(runtimeHints,method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runtimeHints",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 448
    },
    "return": "void",
    "signature": "public void registerRuntimeHints(RuntimeHints runtimeHints, Method method)",
    "source_code": "\t\tpublic void registerRuntimeHints(RuntimeHints runtimeHints, Method method) {\n\t\t\tClass<?>[] parameterTypes = method.getParameterTypes();\n\t\t\tfor (int i = 0; i < parameterTypes.length; i++) {\n\t\t\t\tMethodParameter methodParam = new MethodParameter(method, i);\n\t\t\t\tDependencyDescriptor dependencyDescriptor = new DependencyDescriptor(methodParam, true);\n\t\t\t\tregisterProxyIfNecessary(runtimeHints, dependencyDescriptor);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Descriptor for a specific dependency that is about to be injected.\n * Wraps a constructor parameter, a method parameter or a field,\n * allowing unified access to their metadata.\n *\n * @author Juergen Hoeller\n * @since 2.5\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "public class DependencyDescriptor",
    "source_code": "public class DependencyDescriptor extends InjectionPoint implements Serializable {\n\n\tprivate final Class<?> declaringClass;\n\n\t@Nullable\n\tprivate String methodName;\n\n\t@Nullable\n\tprivate Class<?>[] parameterTypes;\n\n\tprivate int parameterIndex;\n\n\t@Nullable\n\tprivate String fieldName;\n\n\tprivate final boolean required;\n\n\tprivate final boolean eager;\n\n\tprivate int nestingLevel = 1;\n\n\t@Nullable\n\tprivate Class<?> containingClass;\n\n\t@Nullable\n\tprivate transient volatile ResolvableType resolvableType;\n\n\t@Nullable\n\tprivate transient volatile TypeDescriptor typeDescriptor;\n\n\n\t/**\n\t * Create a new descriptor for a method or constructor parameter.\n\t * Considers the dependency as 'eager'.\n\t * @param methodParameter the MethodParameter to wrap\n\t * @param required whether the dependency is required\n\t */\n\tpublic DependencyDescriptor(MethodParameter methodParameter, boolean required) {\n\t\tthis(methodParameter, required, true);\n\t}\n\n\t/**\n\t * Create a new descriptor for a method or constructor parameter.\n\t * @param methodParameter the MethodParameter to wrap\n\t * @param required whether the dependency is required\n\t * @param eager whether this dependency is 'eager' in the sense of\n\t * eagerly resolving potential target beans for type matching\n\t */\n\tpublic DependencyDescriptor(MethodParameter methodParameter, boolean required, boolean eager) {\n\t\tsuper(methodParameter);\n\n\t\tthis.declaringClass = methodParameter.getDeclaringClass();\n\t\tif (methodParameter.getMethod() != null) {\n\t\t\tthis.methodName = methodParameter.getMethod().getName();\n\t\t}\n\t\tthis.parameterTypes = methodParameter.getExecutable().getParameterTypes();\n\t\tthis.parameterIndex = methodParameter.getParameterIndex();\n\t\tthis.containingClass = methodParameter.getContainingClass();\n\t\tthis.required = required;\n\t\tthis.eager = eager;\n\t}\n\n\t/**\n\t * Create a new descriptor for a field.\n\t * Considers the dependency as 'eager'.\n\t * @param field the field to wrap\n\t * @param required whether the dependency is required\n\t */\n\tpublic DependencyDescriptor(Field field, boolean required) {\n\t\tthis(field, required, true);\n\t}\n\n\t/**\n\t * Create a new descriptor for a field.\n\t * @param field the field to wrap\n\t * @param required whether the dependency is required\n\t * @param eager whether this dependency is 'eager' in the sense of\n\t * eagerly resolving potential target beans for type matching\n\t */\n\tpublic DependencyDescriptor(Field field, boolean required, boolean eager) {\n\t\tsuper(field);\n\n\t\tthis.declaringClass = field.getDeclaringClass();\n\t\tthis.fieldName = field.getName();\n\t\tthis.required = required;\n\t\tthis.eager = eager;\n\t}\n\n\t/**\n\t * Copy constructor.\n\t * @param original the original descriptor to create a copy from\n\t */\n\tpublic DependencyDescriptor(DependencyDescriptor original) {\n\t\tsuper(original);\n\n\t\tthis.declaringClass = original.declaringClass;\n\t\tthis.methodName = original.methodName;\n\t\tthis.parameterTypes = original.parameterTypes;\n\t\tthis.parameterIndex = original.parameterIndex;\n\t\tthis.fieldName = original.fieldName;\n\t\tthis.required = original.required;\n\t\tthis.eager = original.eager;\n\t\tthis.nestingLevel = original.nestingLevel;\n\t\tthis.containingClass = original.containingClass;\n\t}\n\n\n\t/**\n\t * Return whether this dependency is required.\n\t * <p>Optional semantics are derived from Java 8's {@link java.util.Optional},\n\t * any variant of a parameter-level {@code Nullable} annotation (such as from\n\t * JSR-305 or the FindBugs set of annotations), or a language-level nullable\n\t * type declaration in Kotlin.\n\t */\n\tpublic boolean isRequired() {\n\t\tif (!this.required) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.field != null) {\n\t\t\treturn !(this.field.getType() == Optional.class || hasNullableAnnotation() ||\n\t\t\t\t\t(KotlinDetector.isKotlinReflectPresent() &&\n\t\t\t\t\t\t\tKotlinDetector.isKotlinType(this.field.getDeclaringClass()) &&\n\t\t\t\t\t\t\tKotlinDelegate.isNullable(this.field)));\n\t\t}\n\t\telse {\n\t\t\treturn !obtainMethodParameter().isOptional();\n\t\t}\n\t}\n\n\t/**\n\t * Check whether the underlying field is annotated with any variant of a\n\t * {@code Nullable} annotation, for example, {@code jakarta.annotation.Nullable} or\n\t * {@code edu.umd.cs.findbugs.annotations.Nullable}.\n\t */\n\tprivate boolean hasNullableAnnotation() {\n\t\tfor (Annotation ann : getAnnotations()) {\n\t\t\tif (\"Nullable\".equals(ann.annotationType().getSimpleName())) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Return whether this dependency is 'eager' in the sense of\n\t * eagerly resolving potential target beans for type matching.\n\t */\n\tpublic boolean isEager() {\n\t\treturn this.eager;\n\t}\n\n\t/**\n\t * Resolve the specified not-unique scenario: by default,\n\t * throwing a {@link NoUniqueBeanDefinitionException}.\n\t * <p>Subclasses may override this to select one of the instances or\n\t * to opt out with no result at all through returning {@code null}.\n\t * @param type the requested bean type\n\t * @param matchingBeans a map of bean names and corresponding bean\n\t * instances which have been pre-selected for the given type\n\t * (qualifiers etc already applied)\n\t * @return a bean instance to proceed with, or {@code null} for none\n\t * @throws BeansException in case of the not-unique scenario being fatal\n\t * @since 5.1\n\t */\n\t@Nullable\n\tpublic Object resolveNotUnique(ResolvableType type, Map<String, Object> matchingBeans) throws BeansException {\n\t\tthrow new NoUniqueBeanDefinitionException(type, matchingBeans.keySet());\n\t}\n\n\t/**\n\t * Resolve a shortcut for this dependency against the given factory, for example\n\t * taking some pre-resolved information into account.\n\t * <p>The resolution algorithm will first attempt to resolve a shortcut through this\n\t * method before going into the regular type matching algorithm across all beans.\n\t * Subclasses may override this method to improve resolution performance based on\n\t * pre-cached information while still receiving {@link InjectionPoint} exposure etc.\n\t * @param beanFactory the associated factory\n\t * @return the shortcut result if any, or {@code null} if none\n\t * @throws BeansException if the shortcut could not be obtained\n\t * @since 4.3.1\n\t */\n\t@Nullable\n\tpublic Object resolveShortcut(BeanFactory beanFactory) throws BeansException {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Resolve the specified bean name, as a candidate result of the matching\n\t * algorithm for this dependency, to a bean instance from the given factory.\n\t * <p>The default implementation calls {@link BeanFactory#getBean(String)}.\n\t * Subclasses may provide additional arguments or other customizations.\n\t * @param beanName the bean name, as a candidate result for this dependency\n\t * @param requiredType the expected type of the bean (as an assertion)\n\t * @param beanFactory the associated factory\n\t * @return the bean instance (never {@code null})\n\t * @throws BeansException if the bean could not be obtained\n\t * @since 4.3.2\n\t * @see BeanFactory#getBean(String)\n\t */\n\tpublic Object resolveCandidate(String beanName, Class<?> requiredType, BeanFactory beanFactory)\n\t\t\tthrows BeansException {\n\n\t\treturn beanFactory.getBean(beanName);\n\t}\n\n\n\t/**\n\t * Increase this descriptor's nesting level.\n\t */\n\tpublic void increaseNestingLevel() {\n\t\tthis.nestingLevel++;\n\t\tthis.resolvableType = null;\n\t\tif (this.methodParameter != null) {\n\t\t\tthis.methodParameter = this.methodParameter.nested();\n\t\t}\n\t}\n\n\t/**\n\t * Optionally set the concrete class that contains this dependency.\n\t * This may differ from the class that declares the parameter/field in that\n\t * it may be a subclass thereof, potentially substituting type variables.\n\t * @since 4.0\n\t */\n\tpublic void setContainingClass(Class<?> containingClass) {\n\t\tthis.containingClass = containingClass;\n\t\tthis.resolvableType = null;\n\t\tif (this.methodParameter != null) {\n\t\t\tthis.methodParameter = this.methodParameter.withContainingClass(containingClass);\n\t\t}\n\t}\n\n\t/**\n\t * Build a {@link ResolvableType} object for the wrapped parameter/field.\n\t * @since 4.0\n\t */\n\tpublic ResolvableType getResolvableType() {\n\t\tResolvableType resolvableType = this.resolvableType;\n\t\tif (resolvableType == null) {\n\t\t\tresolvableType = (this.field != null ?\n\t\t\t\t\tResolvableType.forField(this.field, this.nestingLevel, this.containingClass) :\n\t\t\t\t\tResolvableType.forMethodParameter(obtainMethodParameter()));\n\t\t\tthis.resolvableType = resolvableType;\n\t\t}\n\t\treturn resolvableType;\n\t}\n\n\t/**\n\t * Build a {@link TypeDescriptor} object for the wrapped parameter/field.\n\t * @since 5.1.4\n\t */\n\tpublic TypeDescriptor getTypeDescriptor() {\n\t\tTypeDescriptor typeDescriptor = this.typeDescriptor;\n\t\tif (typeDescriptor == null) {\n\t\t\ttypeDescriptor = (this.field != null ?\n\t\t\t\t\tnew TypeDescriptor(getResolvableType(), getDependencyType(), getAnnotations()) :\n\t\t\t\t\tnew TypeDescriptor(obtainMethodParameter()));\n\t\t\tthis.typeDescriptor = typeDescriptor;\n\t\t}\n\t\treturn typeDescriptor;\n\t}\n\n\t/**\n\t * Return whether a fallback match is allowed.\n\t * <p>This is {@code false} by default but may be overridden to return {@code true} in order\n\t * to suggest to an {@link org.springframework.beans.factory.support.AutowireCandidateResolver}\n\t * that a fallback match is acceptable as well.\n\t * @since 4.0\n\t */\n\tpublic boolean fallbackMatchAllowed() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Return a variant of this descriptor that is intended for a fallback match.\n\t * @since 4.0\n\t * @see #fallbackMatchAllowed()\n\t */\n\tpublic DependencyDescriptor forFallbackMatch() {\n\t\treturn new DependencyDescriptor(this) {\n\t\t\t@Override\n\t\t\tpublic boolean fallbackMatchAllowed() {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic boolean usesStandardBeanLookup() {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Initialize parameter name discovery for the underlying method parameter, if any.\n\t * <p>This method does not actually try to retrieve the parameter name at\n\t * this point; it just allows discovery to happen when the application calls\n\t * {@link #getDependencyName()} (if ever).\n\t */\n\tpublic void initParameterNameDiscovery(@Nullable ParameterNameDiscoverer parameterNameDiscoverer) {\n\t\tif (this.methodParameter != null) {\n\t\t\tthis.methodParameter.initParameterNameDiscovery(parameterNameDiscoverer);\n\t\t}\n\t}\n\n\t/**\n\t * Determine the name of the wrapped parameter/field.\n\t * @return the declared name (may be {@code null} if unresolvable)\n\t */\n\t@Nullable\n\tpublic String getDependencyName() {\n\t\treturn (this.field != null ? this.field.getName() : obtainMethodParameter().getParameterName());\n\t}\n\n\t/**\n\t * Determine the declared (non-generic) type of the wrapped parameter/field.\n\t * @return the declared type (never {@code null})\n\t */\n\tpublic Class<?> getDependencyType() {\n\t\tif (this.field != null) {\n\t\t\tif (this.nestingLevel > 1) {\n\t\t\t\tClass<?> clazz = getResolvableType().getRawClass();\n\t\t\t\treturn (clazz != null ? clazz : Object.class);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn this.field.getType();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn obtainMethodParameter().getNestedParameterType();\n\t\t}\n\t}\n\n\t/**\n\t * Determine whether this dependency supports lazy resolution,\n\t * for example, through extra proxying. The default is {@code true}.\n\t * @since 6.1.2\n\t * @see org.springframework.beans.factory.support.AutowireCandidateResolver#getLazyResolutionProxyIfNecessary\n\t */\n\tpublic boolean supportsLazyResolution() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Determine whether this descriptor uses a standard bean lookup\n\t * in {@link #resolveCandidate(String, Class, BeanFactory)} and\n\t * therefore qualifies for factory-level shortcut resolution.\n\t * <p>By default, the {@code DependencyDescriptor} class itself\n\t * uses a standard bean lookup but subclasses may override this.\n\t * If a subclass overrides other methods but preserves a standard\n\t * bean lookup, it may override this method to return {@code true}.\n\t * @since 6.2\n\t * @see #resolveCandidate(String, Class, BeanFactory)\n\t */\n\tpublic boolean usesStandardBeanLookup() {\n\t\treturn (getClass() == DependencyDescriptor.class);\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!super.equals(other)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (other instanceof DependencyDescriptor otherDesc && this.required == otherDesc.required &&\n\t\t\t\tthis.eager == otherDesc.eager && this.nestingLevel == otherDesc.nestingLevel &&\n\t\t\t\tthis.containingClass == otherDesc.containingClass);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn (31 * super.hashCode() + ObjectUtils.nullSafeHashCode(this.containingClass));\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Serialization support\n\t//---------------------------------------------------------------------\n\n\tprivate void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\n\t\t// Rely on default serialization; just initialize state after deserialization.\n\t\tois.defaultReadObject();\n\n\t\t// Restore reflective handles (which are unfortunately not serializable)\n\t\ttry {\n\t\t\tif (this.fieldName != null) {\n\t\t\t\tthis.field = this.declaringClass.getDeclaredField(this.fieldName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (this.methodName != null) {\n\t\t\t\t\tthis.methodParameter = new MethodParameter(\n\t\t\t\t\t\t\tthis.declaringClass.getDeclaredMethod(this.methodName, this.parameterTypes), this.parameterIndex);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.methodParameter = new MethodParameter(\n\t\t\t\t\t\t\tthis.declaringClass.getDeclaredConstructor(this.parameterTypes), this.parameterIndex);\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i < this.nestingLevel; i++) {\n\t\t\t\t\tthis.methodParameter = this.methodParameter.nested();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new IllegalStateException(\"Could not find original class structure\", ex);\n\t\t}\n\t}\n\n\n\t/**\n\t * Inner class to avoid a hard dependency on Kotlin at runtime.\n\t */\n\tprivate static class KotlinDelegate {\n\n\t\t/**\n\t\t * Check whether the specified {@link Field} represents a nullable Kotlin type or not.\n\t\t */\n\t\tpublic static boolean isNullable(Field field) {\n\t\t\tKProperty<?> property = ReflectJvmMapping.getKotlinProperty(field);\n\t\t\treturn (property != null && property.getReturnType().isMarkedNullable());\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#equals(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 409
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!super.equals(other)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (other instanceof DependencyDescriptor otherDesc && this.required == otherDesc.required &&\n\t\t\t\tthis.eager == otherDesc.eager && this.nestingLevel == otherDesc.nestingLevel &&\n\t\t\t\tthis.containingClass == otherDesc.containingClass);\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#fallbackMatchAllowed()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 332
    },
    "return": "boolean",
    "signature": "public boolean fallbackMatchAllowed()",
    "source_code": "\t\t\tpublic boolean fallbackMatchAllowed() {\n\t\t\t\treturn true;\n\t\t\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#forFallbackMatch()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a variant of this descriptor that is intended for a fallback match.\n\t * @since 4.0\n\t * @see #fallbackMatchAllowed()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 329
    },
    "return": "DependencyDescriptor",
    "signature": "public DependencyDescriptor forFallbackMatch()",
    "source_code": "\tpublic DependencyDescriptor forFallbackMatch() {\n\t\treturn new DependencyDescriptor(this) {\n\t\t\t@Override\n\t\t\tpublic boolean fallbackMatchAllowed() {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic boolean usesStandardBeanLookup() {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#getDependencyName()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the name of the wrapped parameter/field.\n\t * @return the declared name (may be {@code null} if unresolvable)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 359
    },
    "return": "String",
    "signature": "public String getDependencyName()",
    "source_code": "\tpublic String getDependencyName() {\n\t\treturn (this.field != null ? this.field.getName() : obtainMethodParameter().getParameterName());\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#getResolvableType()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@link ResolvableType} object for the wrapped parameter/field.\n\t * @since 4.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType getResolvableType()",
    "source_code": "\tpublic ResolvableType getResolvableType() {\n\t\tResolvableType resolvableType = this.resolvableType;\n\t\tif (resolvableType == null) {\n\t\t\tresolvableType = (this.field != null ?\n\t\t\t\t\tResolvableType.forField(this.field, this.nestingLevel, this.containingClass) :\n\t\t\t\t\tResolvableType.forMethodParameter(obtainMethodParameter()));\n\t\t\tthis.resolvableType = resolvableType;\n\t\t}\n\t\treturn resolvableType;\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#getTypeDescriptor()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@link TypeDescriptor} object for the wrapped parameter/field.\n\t * @since 5.1.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getTypeDescriptor()",
    "source_code": "\tpublic TypeDescriptor getTypeDescriptor() {\n\t\tTypeDescriptor typeDescriptor = this.typeDescriptor;\n\t\tif (typeDescriptor == null) {\n\t\t\ttypeDescriptor = (this.field != null ?\n\t\t\t\t\tnew TypeDescriptor(getResolvableType(), getDependencyType(), getAnnotations()) :\n\t\t\t\t\tnew TypeDescriptor(obtainMethodParameter()));\n\t\t\tthis.typeDescriptor = typeDescriptor;\n\t\t}\n\t\treturn typeDescriptor;\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#hashCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 422
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn (31 * super.hashCode() + ObjectUtils.nullSafeHashCode(this.containingClass));\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#increaseNestingLevel()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Increase this descriptor's nesting level.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "void",
    "signature": "public void increaseNestingLevel()",
    "source_code": "\tpublic void increaseNestingLevel() {\n\t\tthis.nestingLevel++;\n\t\tthis.resolvableType = null;\n\t\tif (this.methodParameter != null) {\n\t\t\tthis.methodParameter = this.methodParameter.nested();\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#initParameterNameDiscovery(parameterNameDiscoverer)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize parameter name discovery for the underlying method parameter, if any.\n\t * <p>This method does not actually try to retrieve the parameter name at\n\t * this point; it just allows discovery to happen when the application calls\n\t * {@link #getDependencyName()} (if ever).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterNameDiscoverer"
    ],
    "position": {
      "column": 1,
      "line": 348
    },
    "return": "void",
    "signature": "public void initParameterNameDiscovery(@Nullable ParameterNameDiscoverer parameterNameDiscoverer)",
    "source_code": "\tpublic void initParameterNameDiscovery(@Nullable ParameterNameDiscoverer parameterNameDiscoverer) {\n\t\tif (this.methodParameter != null) {\n\t\t\tthis.methodParameter.initParameterNameDiscovery(parameterNameDiscoverer);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#isEager()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether this dependency is 'eager' in the sense of\n\t * eagerly resolving potential target beans for type matching.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "boolean",
    "signature": "public boolean isEager()",
    "source_code": "\tpublic boolean isEager() {\n\t\treturn this.eager;\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#isNullable(field)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Check whether the specified {@link Field} represents a nullable Kotlin type or not.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field"
    ],
    "position": {
      "column": 1,
      "line": 468
    },
    "return": "boolean",
    "signature": "public boolean isNullable(Field field)",
    "source_code": "\t\tpublic static boolean isNullable(Field field) {\n\t\t\tKProperty<?> property = ReflectJvmMapping.getKotlinProperty(field);\n\t\t\treturn (property != null && property.getReturnType().isMarkedNullable());\n\t\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#isRequired()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether this dependency is required.\n\t * <p>Optional semantics are derived from Java 8's {@link java.util.Optional},\n\t * any variant of a parameter-level {@code Nullable} annotation (such as from\n\t * JSR-305 or the FindBugs set of annotations), or a language-level nullable\n\t * type declaration in Kotlin.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "boolean",
    "signature": "public boolean isRequired()",
    "source_code": "\tpublic boolean isRequired() {\n\t\tif (!this.required) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.field != null) {\n\t\t\treturn !(this.field.getType() == Optional.class || hasNullableAnnotation() ||\n\t\t\t\t\t(KotlinDetector.isKotlinReflectPresent() &&\n\t\t\t\t\t\t\tKotlinDetector.isKotlinType(this.field.getDeclaringClass()) &&\n\t\t\t\t\t\t\tKotlinDelegate.isNullable(this.field)));\n\t\t}\n\t\telse {\n\t\t\treturn !obtainMethodParameter().isOptional();\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#resolveCandidate(beanName,requiredType,beanFactory)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the specified bean name, as a candidate result of the matching\n\t * algorithm for this dependency, to a bean instance from the given factory.\n\t * <p>The default implementation calls {@link BeanFactory#getBean(String)}.\n\t * Subclasses may provide additional arguments or other customizations.\n\t * @param beanName the bean name, as a candidate result for this dependency\n\t * @param requiredType the expected type of the bean (as an assertion)\n\t * @param beanFactory the associated factory\n\t * @return the bean instance (never {@code null})\n\t * @throws BeansException if the bean could not be obtained\n\t * @since 4.3.2\n\t * @see BeanFactory#getBean(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "requiredType",
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "Object",
    "signature": "public Object resolveCandidate(String beanName, Class<?> requiredType, BeanFactory beanFactory)",
    "source_code": "\tpublic Object resolveCandidate(String beanName, Class<?> requiredType, BeanFactory beanFactory)"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#resolveNotUnique(type,Map<String,matchingBeans)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the specified not-unique scenario: by default,\n\t * throwing a {@link NoUniqueBeanDefinitionException}.\n\t * <p>Subclasses may override this to select one of the instances or\n\t * to opt out with no result at all through returning {@code null}.\n\t * @param type the requested bean type\n\t * @param matchingBeans a map of bean names and corresponding bean\n\t * instances which have been pre-selected for the given type\n\t * (qualifiers etc already applied)\n\t * @return a bean instance to proceed with, or {@code null} for none\n\t * @throws BeansException in case of the not-unique scenario being fatal\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "Map<String",
      "matchingBeans"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "Object",
    "signature": "public Object resolveNotUnique(ResolvableType type, Map<String, Object> matchingBeans)",
    "source_code": "\tpublic Object resolveNotUnique(ResolvableType type, Map<String, Object> matchingBeans) throws BeansException {\n\t\tthrow new NoUniqueBeanDefinitionException(type, matchingBeans.keySet());\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#resolveShortcut(beanFactory)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve a shortcut for this dependency against the given factory, for example\n\t * taking some pre-resolved information into account.\n\t * <p>The resolution algorithm will first attempt to resolve a shortcut through this\n\t * method before going into the regular type matching algorithm across all beans.\n\t * Subclasses may override this method to improve resolution performance based on\n\t * pre-cached information while still receiving {@link InjectionPoint} exposure etc.\n\t * @param beanFactory the associated factory\n\t * @return the shortcut result if any, or {@code null} if none\n\t * @throws BeansException if the shortcut could not be obtained\n\t * @since 4.3.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 234
    },
    "return": "Object",
    "signature": "public Object resolveShortcut(BeanFactory beanFactory)",
    "source_code": "\tpublic Object resolveShortcut(BeanFactory beanFactory) throws BeansException {\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#setContainingClass(containingClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Optionally set the concrete class that contains this dependency.\n\t * This may differ from the class that declares the parameter/field in that\n\t * it may be a subclass thereof, potentially substituting type variables.\n\t * @since 4.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "containingClass"
    ],
    "position": {
      "column": 1,
      "line": 275
    },
    "return": "void",
    "signature": "public void setContainingClass(Class<?> containingClass)",
    "source_code": "\tpublic void setContainingClass(Class<?> containingClass) {\n\t\tthis.containingClass = containingClass;\n\t\tthis.resolvableType = null;\n\t\tif (this.methodParameter != null) {\n\t\t\tthis.methodParameter = this.methodParameter.withContainingClass(containingClass);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#supportsLazyResolution()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether this dependency supports lazy resolution,\n\t * for example, through extra proxying. The default is {@code true}.\n\t * @since 6.1.2\n\t * @see org.springframework.beans.factory.support.AutowireCandidateResolver#getLazyResolutionProxyIfNecessary\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 388
    },
    "return": "boolean",
    "signature": "public boolean supportsLazyResolution()",
    "source_code": "\tpublic boolean supportsLazyResolution() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#usesStandardBeanLookup()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether this descriptor uses a standard bean lookup\n\t * in {@link #resolveCandidate(String, Class, BeanFactory)} and\n\t * therefore qualifies for factory-level shortcut resolution.\n\t * <p>By default, the {@code DependencyDescriptor} class itself\n\t * uses a standard bean lookup but subclasses may override this.\n\t * If a subclass overrides other methods but preserves a standard\n\t * bean lookup, it may override this method to return {@code true}.\n\t * @since 6.2\n\t * @see #resolveCandidate(String, Class, BeanFactory)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 403
    },
    "return": "boolean",
    "signature": "public boolean usesStandardBeanLookup()",
    "source_code": "\tpublic boolean usesStandardBeanLookup() {\n\t\treturn (getClass() == DependencyDescriptor.class);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#isAutowireCandidate(beanFactory,beanName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Check the autowire-candidate status for the specified bean.\n\t * @param beanFactory the bean factory\n\t * @param beanName the name of the bean to check\n\t * @return whether the specified bean qualifies as an autowire candidate\n\t * @since 6.2.3\n\t * @see org.springframework.beans.factory.config.BeanDefinition#isAutowireCandidate()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "boolean",
    "signature": "public boolean isAutowireCandidate(ConfigurableBeanFactory beanFactory, String beanName)",
    "source_code": "\tpublic static boolean isAutowireCandidate(ConfigurableBeanFactory beanFactory, String beanName) {\n\t\ttry {\n\t\t\treturn beanFactory.getMergedBeanDefinition(beanName).isAutowireCandidate();\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// A manually registered singleton instance not backed by a BeanDefinition.\n\t\t\treturn true;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#isDefaultCandidate(beanFactory,beanName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Check the default-candidate status for the specified bean.\n\t * @param beanFactory the bean factory\n\t * @param beanName the name of the bean to check\n\t * @return whether the specified bean qualifies as a default candidate\n\t * @since 6.2.4\n\t * @see AbstractBeanDefinition#isDefaultCandidate()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "boolean",
    "signature": "public boolean isDefaultCandidate(ConfigurableBeanFactory beanFactory, String beanName)",
    "source_code": "\tpublic static boolean isDefaultCandidate(ConfigurableBeanFactory beanFactory, String beanName) {\n\t\ttry {\n\t\t\tBeanDefinition mbd = beanFactory.getMergedBeanDefinition(beanName);\n\t\t\treturn (!(mbd instanceof AbstractBeanDefinition abd) || abd.isDefaultCandidate());\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// A manually registered singleton instance not backed by a BeanDefinition.\n\t\t\treturn true;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#usesStandardBeanLookup()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1453
    },
    "return": "boolean",
    "signature": "public boolean usesStandardBeanLookup()",
    "source_code": "\t\tpublic boolean usesStandardBeanLookup() {\n\t\t\treturn true;\n\t\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinition#isBackgroundInit()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the bootstrap mode for this bean: default is {@code false} for using\n\t * the main pre-instantiation thread for non-lazy singleton beans and the caller\n\t * thread for prototype beans.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 606
    },
    "return": "boolean",
    "signature": "public boolean isBackgroundInit()",
    "source_code": "\tpublic boolean isBackgroundInit() {\n\t\treturn this.backgroundInit;\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinition#isDefaultCandidate()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether this bean is a candidate for getting autowired into some other\n\t * bean based on the plain type, without any further indications such as a\n\t * qualifier match?\n\t * <p>The default is {@code true}.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 768
    },
    "return": "boolean",
    "signature": "public boolean isDefaultCandidate()",
    "source_code": "\tpublic boolean isDefaultCandidate() {\n\t\treturn this.defaultCandidate;\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinition#isFallback()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p>The default is {@code false}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 804
    },
    "return": "boolean",
    "signature": "public boolean isFallback()",
    "source_code": "\tpublic boolean isFallback() {\n\t\treturn this.fallback;\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinition#setBackgroundInit(backgroundInit)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the bootstrap mode for this bean: default is {@code false} for using\n\t * the main pre-instantiation thread for non-lazy singleton beans and the caller\n\t * thread for prototype beans.\n\t * <p>Set this flag to {@code true} to allow for instantiating this bean on a\n\t * background thread. For a non-lazy singleton, a background pre-instantiation\n\t * thread can be used then, while still enforcing the completion at the end of\n\t * {@link DefaultListableBeanFactory#preInstantiateSingletons()}.\n\t * For a lazy singleton, a background pre-instantiation thread can be used as well\n\t * - with completion allowed at a later point, enforcing it when actually accessed.\n\t * <p>Note that this flag may be ignored by bean factories not set up for\n\t * background bootstrapping, always applying single-threaded bootstrapping\n\t * for non-lazy singleton beans.\n\t * @since 6.2\n\t * @see #setLazyInit\n\t * @see DefaultListableBeanFactory#setBootstrapExecutor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "backgroundInit"
    ],
    "position": {
      "column": 1,
      "line": 596
    },
    "return": "void",
    "signature": "public void setBackgroundInit(boolean backgroundInit)",
    "source_code": "\tpublic void setBackgroundInit(boolean backgroundInit) {\n\t\tthis.backgroundInit = backgroundInit;\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinition#setDefaultCandidate(defaultCandidate)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether this bean is a candidate for getting autowired into some other\n\t * bean based on the plain type, without any further indications such as a\n\t * qualifier match.\n\t * <p>The default is {@code true}, allowing injection by type at any injection point.\n\t * Switch this to {@code false} in order to restrict injection by default,\n\t * effectively enforcing an additional indication such as a qualifier match.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultCandidate"
    ],
    "position": {
      "column": 1,
      "line": 757
    },
    "return": "void",
    "signature": "public void setDefaultCandidate(boolean defaultCandidate)",
    "source_code": "\tpublic void setDefaultCandidate(boolean defaultCandidate) {\n\t\tthis.defaultCandidate = defaultCandidate;\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinition#setFallback(fallback)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p>The default is {@code false}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fallback"
    ],
    "position": {
      "column": 1,
      "line": 795
    },
    "return": "void",
    "signature": "public void setFallback(boolean fallback)",
    "source_code": "\tpublic void setFallback(boolean fallback) {\n\t\tthis.fallback = fallback;\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanFactory#registerCustomEditors(registry)": {
    "change": "modifier_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the given PropertyEditorRegistry with the custom editors\n\t * that have been registered with this BeanFactory.\n\t * <p>To be called for BeanWrappers that will create and populate bean\n\t * instances, and for SimpleTypeConverter used for constructor argument\n\t * and factory method type conversion.\n\t * @param registry the PropertyEditorRegistry to initialize\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 1314
    },
    "return": "void",
    "signature": "protected void registerCustomEditors(PropertyEditorRegistry registry)",
    "source_code": "\tprotected void registerCustomEditors(PropertyEditorRegistry registry) {\n\t\tif (registry instanceof PropertyEditorRegistrySupport registrySupport) {\n\t\t\tregistrySupport.useConfigValueEditors();\n\t\t}\n\t\tif (!this.propertyEditorRegistrars.isEmpty()) {\n\t\t\tfor (PropertyEditorRegistrar registrar : this.propertyEditorRegistrars) {\n\t\t\t\ttry {\n\t\t\t\t\tregistrar.registerCustomEditors(registry);\n\t\t\t\t}\n\t\t\t\tcatch (BeanCreationException ex) {\n\t\t\t\t\tThrowable rootCause = ex.getMostSpecificCause();\n\t\t\t\t\tif (rootCause instanceof BeanCurrentlyInCreationException bce) {\n\t\t\t\t\t\tString bceBeanName = bce.getBeanName();\n\t\t\t\t\t\tif (bceBeanName != null && isCurrentlyInCreation(bceBeanName)) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"PropertyEditorRegistrar [\" + registrar.getClass().getName() +\n\t\t\t\t\t\t\t\t\t\t\"] failed because it tried to obtain currently created bean '\" +\n\t\t\t\t\t\t\t\t\t\tex.getBeanName() + \"': \" + ex.getMessage());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tonSuppressedException(ex);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!this.customEditors.isEmpty()) {\n\t\t\tthis.customEditors.forEach((requiredType, editorClass) ->\n\t\t\t\t\tregistry.registerCustomEditor(requiredType, BeanUtils.instantiateClass(editorClass)));\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.DefaultListableBeanFactory#checkMergedBeanDefinition(mbd,beanName,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mbd",
      "beanName",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 1011
    },
    "return": "void",
    "signature": "protected void checkMergedBeanDefinition(RootBeanDefinition mbd, String beanName, @Nullable Object[] args)",
    "source_code": "\tprotected void checkMergedBeanDefinition(RootBeanDefinition mbd, String beanName, @Nullable Object[] args) {\n\t\tsuper.checkMergedBeanDefinition(mbd, beanName, args);\n\n\t\tif (mbd.isBackgroundInit()) {\n\t\t\tif (this.preInstantiationThread.get() == PreInstantiation.MAIN && getBootstrapExecutor() != null) {\n\t\t\t\tthrow new BeanCurrentlyInCreationException(beanName, \"Bean marked for background \" +\n\t\t\t\t\t\t\"initialization but requested in mainline thread - declare ObjectProvider \" +\n\t\t\t\t\t\t\"or lazy injection point in dependent mainline beans\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Bean intended to be initialized in main bootstrap thread\n\t\t\tif (this.preInstantiationThread.get() == PreInstantiation.BACKGROUND) {\n\t\t\t\tthrow new BeanCurrentlyInCreationException(beanName, \"Bean marked for mainline initialization \" +\n\t\t\t\t\t\t\"but requested in background thread - enforce early instantiation in mainline thread \" +\n\t\t\t\t\t\t\"through depends-on '\" + beanName + \"' declaration for dependent background beans\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.DefaultListableBeanFactory#getBootstrapExecutor()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 298
    },
    "return": "Executor",
    "signature": "public Executor getBootstrapExecutor()",
    "source_code": "\tpublic Executor getBootstrapExecutor() {\n\t\treturn this.bootstrapExecutor;\n\t}"
  },
  "org.springframework.beans.factory.support.DefaultListableBeanFactory#isCurrentThreadAllowedToHoldSingletonLock()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1033
    },
    "return": "Boolean",
    "signature": "protected Boolean isCurrentThreadAllowedToHoldSingletonLock()",
    "source_code": "\tprotected Boolean isCurrentThreadAllowedToHoldSingletonLock() {\n\t\treturn (this.preInstantiationPhase ? this.preInstantiationThread.get() != PreInstantiation.BACKGROUND : null);\n\t}"
  },
  "org.springframework.beans.factory.support.DefaultListableBeanFactory#orderedStream(customFilter,includeNonSingletons)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "customFilter",
      "includeNonSingletons"
    ],
    "position": {
      "column": 1,
      "line": 2556
    },
    "return": "Stream<Object>",
    "signature": "public Stream<Object> orderedStream(Predicate<Class<?>> customFilter, boolean includeNonSingletons)",
    "source_code": "\t\tpublic Stream<Object> orderedStream(Predicate<Class<?>> customFilter, boolean includeNonSingletons) {\n\t\t\tString[] beanNames = beanNamesForStream(this.descriptor.getResolvableType(), includeNonSingletons, true);\n\t\t\tif (beanNames.length == 0) {\n\t\t\t\treturn Stream.empty();\n\t\t\t}\n\t\t\tMap<String, Object> matchingBeans = CollectionUtils.newLinkedHashMap(beanNames.length);\n\t\t\tfor (String beanName : beanNames) {\n\t\t\t\tif (AutowireUtils.isAutowireCandidate(DefaultListableBeanFactory.this, beanName) &&\n\t\t\t\t\t\tcustomFilter.test(getType(beanName))) {\n\t\t\t\t\tObject beanInstance = getBean(beanName);\n\t\t\t\t\tif (!(beanInstance instanceof NullBean)) {\n\t\t\t\t\t\tmatchingBeans.put(beanName, beanInstance);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn matchingBeans.values().stream().sorted(adaptOrderComparator(matchingBeans));\n\t\t}"
  },
  "org.springframework.beans.factory.support.DefaultListableBeanFactory#setBootstrapExecutor(bootstrapExecutor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bootstrapExecutor"
    ],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "void",
    "signature": "public void setBootstrapExecutor(@Nullable Executor bootstrapExecutor)",
    "source_code": "\tpublic void setBootstrapExecutor(@Nullable Executor bootstrapExecutor) {\n\t\tthis.bootstrapExecutor = bootstrapExecutor;\n\t}"
  },
  "org.springframework.beans.factory.support.DefaultListableBeanFactory#stream(customFilter,includeNonSingletons)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "customFilter",
      "includeNonSingletons"
    ],
    "position": {
      "column": 1,
      "line": 2547
    },
    "return": "Stream<Object>",
    "signature": "public Stream<Object> stream(Predicate<Class<?>> customFilter, boolean includeNonSingletons)",
    "source_code": "\t\tpublic Stream<Object> stream(Predicate<Class<?>> customFilter, boolean includeNonSingletons) {\n\t\t\treturn Arrays.stream(beanNamesForStream(this.descriptor.getResolvableType(), includeNonSingletons, true))\n\t\t\t\t\t.filter(name -> AutowireUtils.isAutowireCandidate(DefaultListableBeanFactory.this, name))\n\t\t\t\t\t.filter(name -> customFilter.test(getType(name)))\n\t\t\t\t\t.map(name -> getBean(name))\n\t\t\t\t\t.filter(bean -> !(bean instanceof NullBean));\n\t\t}"
  },
  "org.springframework.beans.factory.support.DefaultListableBeanFactory#usesStandardBeanLookup()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 2483
    },
    "return": "boolean",
    "signature": "public boolean usesStandardBeanLookup()",
    "source_code": "\t\t\t\tpublic boolean usesStandardBeanLookup() {\n\t\t\t\t\treturn true;\n\t\t\t\t}"
  },
  "org.springframework.beans.factory.support.RootBeanDefinition#setInstanceSupplier(supplier)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "supplier"
    ],
    "position": {
      "column": 1,
      "line": 460
    },
    "return": "void",
    "signature": "public void setInstanceSupplier(@Nullable Supplier<?> supplier)",
    "source_code": "\tpublic void setInstanceSupplier(@Nullable Supplier<?> supplier) {\n\t\tsuper.setInstanceSupplier(supplier);\n\t\tMethod factoryMethod = (supplier instanceof InstanceSupplier<?> instanceSupplier ?\n\t\t\t\tinstanceSupplier.getFactoryMethod() : null);\n\t\tif (factoryMethod != null) {\n\t\t\tsetResolvedFactoryMethod(factoryMethod);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.SimpleInstantiationStrategy#instantiateWithFactoryMethod(method,instanceSupplier)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the given {@code instanceSupplier} with the factory method exposed\n\t * as being invoked.\n\t * @param method the factory method to expose\n\t * @param instanceSupplier the instance supplier\n\t * @param <T> the type of the instance\n\t * @return the result of the instance supplier\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "instanceSupplier"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "T",
    "signature": "public T instantiateWithFactoryMethod(Method method, Supplier<T> instanceSupplier)",
    "source_code": "\tpublic static <T> T instantiateWithFactoryMethod(Method method, Supplier<T> instanceSupplier) {\n\t\tMethod priorInvokedFactoryMethod = currentlyInvokedFactoryMethod.get();\n\t\ttry {\n\t\t\tcurrentlyInvokedFactoryMethod.set(method);\n\t\t\treturn instanceSupplier.get();\n\t\t}\n\t\tfinally {\n\t\t\tif (priorInvokedFactoryMethod != null) {\n\t\t\t\tcurrentlyInvokedFactoryMethod.set(priorInvokedFactoryMethod);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcurrentlyInvokedFactoryMethod.remove();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.StaticListableBeanFactory#orderedStream()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 348
    },
    "return": "Stream<T>",
    "signature": "public Stream<T> orderedStream()",
    "source_code": "\t\t\tpublic Stream<T> orderedStream() {\n\t\t\t\treturn stream().sorted(OrderComparator.INSTANCE);\n\t\t\t}"
  },
  "org.springframework.beans.support.ResourceEditorRegistrar#overridesDefaultEditors()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Indicate the use of {@link PropertyEditorRegistrySupport#overrideDefaultEditor} above.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "boolean",
    "signature": "public boolean overridesDefaultEditors()",
    "source_code": "\tpublic boolean overridesDefaultEditors() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.cache.annotation.AnnotationCacheOperationSource#setPublicMethodsOnly(publicMethodsOnly)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether cacheable methods are expected to be public.\n\t * <p>The default is {@code true}.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "publicMethodsOnly"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "void",
    "signature": "public void setPublicMethodsOnly(boolean publicMethodsOnly)",
    "source_code": "\tpublic void setPublicMethodsOnly(boolean publicMethodsOnly) {\n\t\tthis.publicMethodsOnly = publicMethodsOnly;\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.<unknown>#equals(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other || (other instanceof JCacheOperationSourceClassFilter that &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(getCacheOperationSource(), that.getCacheOperationSource())));\n\t\t}"
  },
  "org.springframework.cache.jcache.interceptor.<unknown>#hashCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\t\tpublic int hashCode() {\n\t\t\treturn JCacheOperationSourceClassFilter.class.hashCode();\n\t\t}"
  },
  "org.springframework.cache.jcache.interceptor.<unknown>#matches(clazz)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "boolean",
    "signature": "public boolean matches(Class<?> clazz)",
    "source_code": "\t\tpublic boolean matches(Class<?> clazz) {\n\t\t\tif (CacheManager.class.isAssignableFrom(clazz)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn (cacheOperationSource == null || cacheOperationSource.isCandidateClass(clazz));\n\t\t}"
  },
  "org.springframework.cache.jcache.interceptor.<unknown>#matches(method,targetClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\treturn (this.cacheOperationSource == null ||\n\t\t\t\tthis.cacheOperationSource.hasCacheOperation(method, targetClass));\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.<unknown>#setCacheOperationSource(cacheOperationSource)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cacheOperationSource"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "return": "void",
    "signature": "public void setCacheOperationSource(@Nullable JCacheOperationSource cacheOperationSource)",
    "source_code": "\tpublic void setCacheOperationSource(@Nullable JCacheOperationSource cacheOperationSource) {\n\t\tthis.cacheOperationSource = cacheOperationSource;\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.<unknown>#toString()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn JCacheOperationSourceClassFilter.class.getName() + \": \" + getCacheOperationSource();\n\t\t}"
  },
  "org.springframework.cache.jcache.interceptor.BeanFactoryJCacheOperationSourceAdvisor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Advisor driven by a {@link JCacheOperationSource}, used to include a\n * cache advice bean for methods that are cacheable.\n *\n * @author Stephane Nicoll\n * @author Juergen Hoeller\n * @since 4.1\n * @see #setAdviceBeanName\n * @see JCacheInterceptor\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 40
    },
    "signature": "public class BeanFactoryJCacheOperationSourceAdvisor",
    "source_code": "public class BeanFactoryJCacheOperationSourceAdvisor extends AbstractBeanFactoryPointcutAdvisor {\n\n\tprivate final JCacheOperationSourcePointcut pointcut = new JCacheOperationSourcePointcut();\n\n\n\t/**\n\t * Set the cache operation attribute source which is used to find cache\n\t * attributes. This should usually be identical to the source reference\n\t * set on the cache interceptor itself.\n\t * @see JCacheInterceptor#setCacheOperationSource\n\t */\n\tpublic void setCacheOperationSource(JCacheOperationSource cacheOperationSource) {\n\t\tthis.pointcut.setCacheOperationSource(cacheOperationSource);\n\t}\n\n\t/**\n\t * Set the {@link org.springframework.aop.ClassFilter} to use for this pointcut.\n\t * Default is {@link org.springframework.aop.ClassFilter#TRUE}.\n\t */\n\tpublic void setClassFilter(ClassFilter classFilter) {\n\t\tthis.pointcut.setClassFilter(classFilter);\n\t}\n\n\t@Override\n\tpublic Pointcut getPointcut() {\n\t\treturn this.pointcut;\n\t}\n\n\n\tprivate static class JCacheOperationSourcePointcut extends StaticMethodMatcherPointcut implements Serializable {\n\n\t\t@Nullable\n\t\tprivate JCacheOperationSource cacheOperationSource;\n\n\t\tpublic void setCacheOperationSource(@Nullable JCacheOperationSource cacheOperationSource) {\n\t\t\tthis.cacheOperationSource = cacheOperationSource;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\t\treturn (this.cacheOperationSource == null ||\n\t\t\t\t\tthis.cacheOperationSource.getCacheOperation(method, targetClass) != null);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other || (other instanceof JCacheOperationSourcePointcut that &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.cacheOperationSource, that.cacheOperationSource)));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn JCacheOperationSourcePointcut.class.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn getClass().getName() + \": \" + this.cacheOperationSource;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.cache.jcache.interceptor.BeanFactoryJCacheOperationSourceAdvisor#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other || (other instanceof JCacheOperationSourcePointcut that &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.cacheOperationSource, that.cacheOperationSource)));\n\t\t}"
  },
  "org.springframework.cache.jcache.interceptor.BeanFactoryJCacheOperationSourceAdvisor#getPointcut()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "Pointcut",
    "signature": "public Pointcut getPointcut()",
    "source_code": "\tpublic Pointcut getPointcut() {\n\t\treturn this.pointcut;\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.BeanFactoryJCacheOperationSourceAdvisor#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\t\tpublic int hashCode() {\n\t\t\treturn JCacheOperationSourcePointcut.class.hashCode();\n\t\t}"
  },
  "org.springframework.cache.jcache.interceptor.BeanFactoryJCacheOperationSourceAdvisor#matches(method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\t\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\t\treturn (this.cacheOperationSource == null ||\n\t\t\t\t\tthis.cacheOperationSource.getCacheOperation(method, targetClass) != null);\n\t\t}"
  },
  "org.springframework.cache.jcache.interceptor.BeanFactoryJCacheOperationSourceAdvisor#setCacheOperationSource(cacheOperationSource)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cacheOperationSource"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "public void setCacheOperationSource(@Nullable JCacheOperationSource cacheOperationSource)",
    "source_code": "\t\tpublic void setCacheOperationSource(@Nullable JCacheOperationSource cacheOperationSource) {\n\t\t\tthis.cacheOperationSource = cacheOperationSource;\n\t\t}"
  },
  "org.springframework.cache.jcache.interceptor.BeanFactoryJCacheOperationSourceAdvisor#setClassFilter(classFilter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link org.springframework.aop.ClassFilter} to use for this pointcut.\n\t * Default is {@link org.springframework.aop.ClassFilter#TRUE}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classFilter"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "void",
    "signature": "public void setClassFilter(ClassFilter classFilter)",
    "source_code": "\tpublic void setClassFilter(ClassFilter classFilter) {\n\t\tthis.pointcut.setClassFilter(classFilter);\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.BeanFactoryJCacheOperationSourceAdvisor#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn getClass().getName() + \": \" + this.cacheOperationSource;\n\t\t}"
  },
  "org.springframework.cache.jcache.interceptor.JCacheOperationSourcePointcut": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A {@code Pointcut} that matches if the underlying {@link JCacheOperationSource}\n * has an operation for a given method.\n *\n * @author Stephane Nicoll\n * @since 4.1\n * @deprecated since 6.0.10, as it is not used by the framework anymore\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 36
    },
    "signature": "public class JCacheOperationSourcePointcut",
    "source_code": "public abstract class JCacheOperationSourcePointcut extends StaticMethodMatcherPointcut implements Serializable {\n\n\t@Override\n\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\tJCacheOperationSource cas = getCacheOperationSource();\n\t\treturn (cas != null && cas.getCacheOperation(method, targetClass) != null);\n\t}\n\n\t/**\n\t * Obtain the underlying {@link JCacheOperationSource} (may be {@code null}).\n\t * To be implemented by subclasses.\n\t */\n\t@Nullable\n\tprotected abstract JCacheOperationSource getCacheOperationSource();\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof JCacheOperationSourcePointcut that &&\n\t\t\t\tObjectUtils.nullSafeEquals(getCacheOperationSource(), that.getCacheOperationSource())));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn JCacheOperationSourcePointcut.class.hashCode();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getClass().getName() + \": \" + getCacheOperationSource();\n\t}\n\n}"
  },
  "org.springframework.cache.jcache.interceptor.JCacheOperationSourcePointcut#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof JCacheOperationSourcePointcut that &&\n\t\t\t\tObjectUtils.nullSafeEquals(getCacheOperationSource(), that.getCacheOperationSource())));\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.JCacheOperationSourcePointcut#getCacheOperationSource()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain the underlying {@link JCacheOperationSource} (may be {@code null}).\n\t * To be implemented by subclasses.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 49
    },
    "return": "JCacheOperationSource",
    "signature": "protected JCacheOperationSource getCacheOperationSource()",
    "source_code": "\tprotected abstract JCacheOperationSource getCacheOperationSource();"
  },
  "org.springframework.cache.jcache.interceptor.JCacheOperationSourcePointcut#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn JCacheOperationSourcePointcut.class.hashCode();\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.JCacheOperationSourcePointcut#matches(method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\tJCacheOperationSource cas = getCacheOperationSource();\n\t\treturn (cas != null && cas.getCacheOperation(method, targetClass) != null);\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.JCacheOperationSourcePointcut#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn getClass().getName() + \": \" + getCacheOperationSource();\n\t}"
  },
  "org.springframework.context.annotation.ContextAnnotationAutowireCandidateResolver": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Complete implementation of the\n * {@link org.springframework.beans.factory.support.AutowireCandidateResolver} strategy\n * interface, providing support for qualifier annotations as well as for lazy resolution\n * driven by the {@link Lazy} annotation in the {@code context.annotation} package.\n *\n * @author Juergen Hoeller\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public class ContextAnnotationAutowireCandidateResolver",
    "source_code": "public class ContextAnnotationAutowireCandidateResolver extends QualifierAnnotationAutowireCandidateResolver {\n\n\t@Override\n\t@Nullable\n\tpublic Object getLazyResolutionProxyIfNecessary(DependencyDescriptor descriptor, @Nullable String beanName) {\n\t\treturn (isLazy(descriptor) ? buildLazyResolutionProxy(descriptor, beanName) : null);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Class<?> getLazyResolutionProxyClass(DependencyDescriptor descriptor, @Nullable String beanName) {\n\t\treturn (isLazy(descriptor) ? (Class<?>) buildLazyResolutionProxy(descriptor, beanName, true) : null);\n\t}\n\n\tprotected boolean isLazy(DependencyDescriptor descriptor) {\n\t\tfor (Annotation ann : descriptor.getAnnotations()) {\n\t\t\tLazy lazy = AnnotationUtils.getAnnotation(ann, Lazy.class);\n\t\t\tif (lazy != null && lazy.value()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tMethodParameter methodParam = descriptor.getMethodParameter();\n\t\tif (methodParam != null) {\n\t\t\tMethod method = methodParam.getMethod();\n\t\t\tif (method == null || void.class == method.getReturnType()) {\n\t\t\t\tLazy lazy = AnnotationUtils.getAnnotation(methodParam.getAnnotatedElement(), Lazy.class);\n\t\t\t\tif (lazy != null && lazy.value()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprotected Object buildLazyResolutionProxy(DependencyDescriptor descriptor, @Nullable String beanName) {\n\t\treturn buildLazyResolutionProxy(descriptor, beanName, false);\n\t}\n\n\tprivate Object buildLazyResolutionProxy(\n\t\t\tDependencyDescriptor descriptor, @Nullable String beanName, boolean classOnly) {\n\n\t\tif (!(getBeanFactory() instanceof DefaultListableBeanFactory dlbf)) {\n\t\t\tthrow new IllegalStateException(\"Lazy resolution only supported with DefaultListableBeanFactory\");\n\t\t}\n\n\t\tTargetSource ts = new LazyDependencyTargetSource(dlbf, descriptor, beanName);\n\n\t\tProxyFactory pf = new ProxyFactory();\n\t\tpf.setTargetSource(ts);\n\t\tClass<?> dependencyType = descriptor.getDependencyType();\n\t\tif (dependencyType.isInterface()) {\n\t\t\tpf.addInterface(dependencyType);\n\t\t}\n\t\tClassLoader classLoader = dlbf.getBeanClassLoader();\n\t\treturn (classOnly ? pf.getProxyClass(classLoader) : pf.getProxy(classLoader));\n\t}\n\n\n\t@SuppressWarnings(\"serial\")\n\tprivate static class LazyDependencyTargetSource implements TargetSource, Serializable {\n\n\t\tprivate final DefaultListableBeanFactory beanFactory;\n\n\t\tprivate final DependencyDescriptor descriptor;\n\n\t\t@Nullable\n\t\tprivate final String beanName;\n\n\t\t@Nullable\n\t\tprivate transient volatile Object cachedTarget;\n\n\t\tpublic LazyDependencyTargetSource(DefaultListableBeanFactory beanFactory,\n\t\t\t\tDependencyDescriptor descriptor, @Nullable String beanName) {\n\n\t\t\tthis.beanFactory = beanFactory;\n\t\t\tthis.descriptor = descriptor;\n\t\t\tthis.beanName = beanName;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<?> getTargetClass() {\n\t\t\treturn this.descriptor.getDependencyType();\n\t\t}\n\n\t\t@Override\n\t\t@SuppressWarnings(\"NullAway\")\n\t\tpublic Object getTarget() {\n\t\t\tObject cachedTarget = this.cachedTarget;\n\t\t\tif (cachedTarget != null) {\n\t\t\t\treturn cachedTarget;\n\t\t\t}\n\n\t\t\tSet<String> autowiredBeanNames = new LinkedHashSet<>(2);\n\t\t\tObject target = this.beanFactory.doResolveDependency(\n\t\t\t\t\tthis.descriptor, this.beanName, autowiredBeanNames, null);\n\n\t\t\tif (target == null) {\n\t\t\t\tClass<?> type = getTargetClass();\n\t\t\t\tif (Map.class == type) {\n\t\t\t\t\ttarget = Collections.emptyMap();\n\t\t\t\t}\n\t\t\t\telse if (List.class == type) {\n\t\t\t\t\ttarget = Collections.emptyList();\n\t\t\t\t}\n\t\t\t\telse if (Set.class == type || Collection.class == type) {\n\t\t\t\t\ttarget = Collections.emptySet();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NoSuchBeanDefinitionException(this.descriptor.getResolvableType(),\n\t\t\t\t\t\t\t\"Optional dependency not present for lazy injection point\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (target instanceof Map<?, ?> map && Map.class == getTargetClass()) {\n\t\t\t\t\ttarget = Collections.unmodifiableMap(map);\n\t\t\t\t}\n\t\t\t\telse if (target instanceof List<?> list && List.class == getTargetClass()) {\n\t\t\t\t\ttarget = Collections.unmodifiableList(list);\n\t\t\t\t}\n\t\t\t\telse if (target instanceof Set<?> set && Set.class == getTargetClass()) {\n\t\t\t\t\ttarget = Collections.unmodifiableSet(set);\n\t\t\t\t}\n\t\t\t\telse if (target instanceof Collection<?> coll && Collection.class == getTargetClass()) {\n\t\t\t\t\ttarget = Collections.unmodifiableCollection(coll);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean cacheable = true;\n\t\t\tfor (String autowiredBeanName : autowiredBeanNames) {\n\t\t\t\tif (!this.beanFactory.containsBean(autowiredBeanName)) {\n\t\t\t\t\tcacheable = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (this.beanName != null) {\n\t\t\t\t\t\tthis.beanFactory.registerDependentBean(autowiredBeanName, this.beanName);\n\t\t\t\t\t}\n\t\t\t\t\tif (!this.beanFactory.isSingleton(autowiredBeanName)) {\n\t\t\t\t\t\tcacheable = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cacheable) {\n\t\t\t\t\tthis.cachedTarget = target;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn target;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.context.annotation.ContextAnnotationAutowireCandidateResolver#buildLazyResolutionProxy(descriptor,beanName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "descriptor",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "Object",
    "signature": "protected Object buildLazyResolutionProxy(DependencyDescriptor descriptor, @Nullable String beanName)",
    "source_code": "\tprotected Object buildLazyResolutionProxy(DependencyDescriptor descriptor, @Nullable String beanName) {\n\t\treturn buildLazyResolutionProxy(descriptor, beanName, false);\n\t}"
  },
  "org.springframework.context.annotation.ContextAnnotationAutowireCandidateResolver#getLazyResolutionProxyIfNecessary(descriptor,beanName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "Object",
    "signature": "public Object getLazyResolutionProxyIfNecessary(DependencyDescriptor descriptor, @Nullable String beanName)",
    "source_code": "\tpublic Object getLazyResolutionProxyIfNecessary(DependencyDescriptor descriptor, @Nullable String beanName) {\n\t\treturn (isLazy(descriptor) ? buildLazyResolutionProxy(descriptor, beanName) : null);\n\t}"
  },
  "org.springframework.context.annotation.ContextAnnotationAutowireCandidateResolver#getTarget()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "Object",
    "signature": "public Object getTarget()",
    "source_code": "\t\tpublic Object getTarget() {\n\t\t\tObject cachedTarget = this.cachedTarget;\n\t\t\tif (cachedTarget != null) {\n\t\t\t\treturn cachedTarget;\n\t\t\t}\n\n\t\t\tSet<String> autowiredBeanNames = new LinkedHashSet<>(2);\n\t\t\tObject target = this.beanFactory.doResolveDependency(\n\t\t\t\t\tthis.descriptor, this.beanName, autowiredBeanNames, null);\n\n\t\t\tif (target == null) {\n\t\t\t\tClass<?> type = getTargetClass();\n\t\t\t\tif (Map.class == type) {\n\t\t\t\t\ttarget = Collections.emptyMap();\n\t\t\t\t}\n\t\t\t\telse if (List.class == type) {\n\t\t\t\t\ttarget = Collections.emptyList();\n\t\t\t\t}\n\t\t\t\telse if (Set.class == type || Collection.class == type) {\n\t\t\t\t\ttarget = Collections.emptySet();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NoSuchBeanDefinitionException(this.descriptor.getResolvableType(),\n\t\t\t\t\t\t\t\"Optional dependency not present for lazy injection point\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (target instanceof Map<?, ?> map && Map.class == getTargetClass()) {\n\t\t\t\t\ttarget = Collections.unmodifiableMap(map);\n\t\t\t\t}\n\t\t\t\telse if (target instanceof List<?> list && List.class == getTargetClass()) {\n\t\t\t\t\ttarget = Collections.unmodifiableList(list);\n\t\t\t\t}\n\t\t\t\telse if (target instanceof Set<?> set && Set.class == getTargetClass()) {\n\t\t\t\t\ttarget = Collections.unmodifiableSet(set);\n\t\t\t\t}\n\t\t\t\telse if (target instanceof Collection<?> coll && Collection.class == getTargetClass()) {\n\t\t\t\t\ttarget = Collections.unmodifiableCollection(coll);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean cacheable = true;\n\t\t\tfor (String autowiredBeanName : autowiredBeanNames) {\n\t\t\t\tif (!this.beanFactory.containsBean(autowiredBeanName)) {\n\t\t\t\t\tcacheable = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (this.beanName != null) {\n\t\t\t\t\t\tthis.beanFactory.registerDependentBean(autowiredBeanName, this.beanName);\n\t\t\t\t\t}\n\t\t\t\t\tif (!this.beanFactory.isSingleton(autowiredBeanName)) {\n\t\t\t\t\t\tcacheable = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cacheable) {\n\t\t\t\t\tthis.cachedTarget = target;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn target;\n\t\t}"
  },
  "org.springframework.context.annotation.ContextAnnotationAutowireCandidateResolver#isLazy(descriptor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "boolean",
    "signature": "protected boolean isLazy(DependencyDescriptor descriptor)",
    "source_code": "\tprotected boolean isLazy(DependencyDescriptor descriptor) {\n\t\tfor (Annotation ann : descriptor.getAnnotations()) {\n\t\t\tLazy lazy = AnnotationUtils.getAnnotation(ann, Lazy.class);\n\t\t\tif (lazy != null && lazy.value()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tMethodParameter methodParam = descriptor.getMethodParameter();\n\t\tif (methodParam != null) {\n\t\t\tMethod method = methodParam.getMethod();\n\t\t\tif (method == null || void.class == method.getReturnType()) {\n\t\t\t\tLazy lazy = AnnotationUtils.getAnnotation(methodParam.getAnnotatedElement(), Lazy.class);\n\t\t\t\tif (lazy != null && lazy.value()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.context.aot.<unknown>#applyTo(generationContext,beanFactoryInitializationCode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanFactoryInitializationCode"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "void",
    "signature": "public void applyTo(GenerationContext generationContext, BeanFactoryInitializationCode beanFactoryInitializationCode)",
    "source_code": "\t\tpublic void applyTo(GenerationContext generationContext, BeanFactoryInitializationCode beanFactoryInitializationCode) {\n\t\t\tRuntimeHints runtimeHints = generationContext.getRuntimeHints();\n\t\t\tregistrar.registerRuntimeHints(runtimeHints, this.types);\n\t\t}"
  },
  "org.springframework.context.aot.<unknown>#findBasePackagesToScan(beanClasses)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanClasses"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "String[]",
    "signature": "protected String[] findBasePackagesToScan(Class<?>[] beanClasses)",
    "source_code": "\tprotected String[] findBasePackagesToScan(Class<?>[] beanClasses) {\n\t\tSet<String> basePackages = new LinkedHashSet<>();\n\t\tfor (Class<?> beanClass : beanClasses) {\n\t\t\tReflectiveScan reflectiveScan = AnnotatedElementUtils.getMergedAnnotation(beanClass, ReflectiveScan.class);\n\t\t\tif (reflectiveScan != null) {\n\t\t\t\tbasePackages.addAll(extractBasePackages(reflectiveScan, beanClass));\n\t\t\t}\n\t\t}\n\t\treturn basePackages.toArray(new String[0]);\n\t}"
  },
  "org.springframework.context.aot.AOT_PROCESSING": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * The name of a system property that is made available when the processor runs.\n\t * @since 6.2\n\t * @see #doProcess()\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "signature": "public String AOT_PROCESSING",
    "source_code": "\tpublic static final String AOT_PROCESSING = \"spring.aot.processing\";",
    "type": "String"
  },
  "org.springframework.context.aot.ReflectiveProcessorAotContributionBuilder": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Builder for an {@linkplain BeanFactoryInitializationAotContribution AOT\n * contribution} that detects the presence of {@link Reflective @Reflective} on\n * annotated elements and invoke the underlying {@link ReflectiveProcessor}\n * implementations.\n *\n * <p>Candidates can be provided explicitly or by scanning the classpath.\n *\n * @author Stephane Nicoll\n * @since 6.2\n * @see Reflective\n * @see RegisterReflection\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "signature": "public class ReflectiveProcessorAotContributionBuilder",
    "source_code": "public class ReflectiveProcessorAotContributionBuilder {\n\n\tprivate static final ReflectiveRuntimeHintsRegistrar registrar = new ReflectiveRuntimeHintsRegistrar();\n\n\tprivate final Set<Class<?>> classes = new LinkedHashSet<>();\n\n\n\t/**\n\t * Process the given classes by checking the ones that use {@link Reflective}.\n\t * <p>A class is candidate if it uses {@link Reflective} directly or via a\n\t * meta-annotation. Type, fields, constructors, methods and enclosed types\n\t * are inspected.\n\t * @param classes the classes to inspect\n\t */\n\tpublic ReflectiveProcessorAotContributionBuilder withClasses(Iterable<Class<?>> classes) {\n\t\tthis.classes.addAll(StreamSupport.stream(classes.spliterator(), false)\n\t\t\t\t.filter(registrar::isCandidate).toList());\n\t\treturn this;\n\t}\n\n\t/**\n\t * Process the given classes by checking the ones that use {@link Reflective}.\n\t * <p>A class is candidate if it uses {@link Reflective} directly or via a\n\t * meta-annotation. Type, fields, constructors, methods and enclosed types\n\t * are inspected.\n\t * @param classes the classes to inspect\n\t */\n\tpublic ReflectiveProcessorAotContributionBuilder withClasses(Class<?>[] classes) {\n\t\treturn withClasses(Arrays.asList(classes));\n\t}\n\n\t/**\n\t * Scan the given {@code packageNames} and their sub-packages for classes\n\t * that uses {@link Reflective}.\n\t * <p>This performs a \"deep scan\" by loading every class in the specified\n\t * packages and search for {@link Reflective} on types, constructors, methods,\n\t * and fields. Enclosed classes are candidates as well. Classes that fail to\n\t * load are ignored.\n\t * @param classLoader the classloader to use\n\t * @param packageNames the package names to scan\n\t */\n\tpublic ReflectiveProcessorAotContributionBuilder scan(@Nullable ClassLoader classLoader, String... packageNames) {\n\t\tReflectiveClassPathScanner scanner = new ReflectiveClassPathScanner(classLoader);\n\t\treturn withClasses(scanner.scan(packageNames));\n\t}\n\n\t@Nullable\n\tpublic BeanFactoryInitializationAotContribution build() {\n\t\treturn (!this.classes.isEmpty() ? new AotContribution(this.classes) : null);\n\t}\n\n\tprivate static class AotContribution implements BeanFactoryInitializationAotContribution {\n\n\t\tprivate final Class<?>[] classes;\n\n\t\tpublic AotContribution(Set<Class<?>> classes) {\n\t\t\tthis.classes = classes.toArray(Class<?>[]::new);\n\t\t}\n\n\t\t@Override\n\t\tpublic void applyTo(GenerationContext generationContext, BeanFactoryInitializationCode beanFactoryInitializationCode) {\n\t\t\tRuntimeHints runtimeHints = generationContext.getRuntimeHints();\n\t\t\tregistrar.registerRuntimeHints(runtimeHints, this.classes);\n\t\t}\n\n\t}\n\n\tprivate static class ReflectiveClassPathScanner extends ClassPathScanningCandidateComponentProvider {\n\n\t\t@Nullable\n\t\tprivate final ClassLoader classLoader;\n\n\t\tReflectiveClassPathScanner(@Nullable ClassLoader classLoader) {\n\t\t\tsuper(false);\n\t\t\tthis.classLoader = classLoader;\n\t\t\taddIncludeFilter((metadataReader, metadataReaderFactory) -> true);\n\t\t}\n\n\t\tClass<?>[] scan(String... packageNames) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Scanning all types for reflective usage from \" + Arrays.toString(packageNames));\n\t\t\t}\n\t\t\tSet<BeanDefinition> candidates = new HashSet<>();\n\t\t\tfor (String packageName : packageNames) {\n\t\t\t\tcandidates.addAll(findCandidateComponents(packageName));\n\t\t\t}\n\t\t\treturn candidates.stream().map(c -> (Class<?>) c.getAttribute(\"type\")).toArray(Class<?>[]::new);\n\t\t}\n\n\t\t@Override\n\t\tprotected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) {\n\t\t\tString className = beanDefinition.getBeanClassName();\n\t\t\tif (className != null) {\n\t\t\t\ttry {\n\t\t\t\t\tClass<?> type = ClassUtils.forName(className, this.classLoader);\n\t\t\t\t\tbeanDefinition.setAttribute(\"type\", type);\n\t\t\t\t\treturn registrar.isCandidate(type);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Ignoring '%s' for reflective usage: %s\".formatted(className, ex.getMessage()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.context.aot.ReflectiveProcessorAotContributionBuilder#applyTo(generationContext,beanFactoryInitializationCode)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanFactoryInitializationCode"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "public void applyTo(GenerationContext generationContext, BeanFactoryInitializationCode beanFactoryInitializationCode)",
    "source_code": "\t\tpublic void applyTo(GenerationContext generationContext, BeanFactoryInitializationCode beanFactoryInitializationCode) {\n\t\t\tRuntimeHints runtimeHints = generationContext.getRuntimeHints();\n\t\t\tregistrar.registerRuntimeHints(runtimeHints, this.classes);\n\t\t}"
  },
  "org.springframework.context.aot.ReflectiveProcessorAotContributionBuilder#build()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "BeanFactoryInitializationAotContribution",
    "signature": "public BeanFactoryInitializationAotContribution build()",
    "source_code": "\tpublic BeanFactoryInitializationAotContribution build() {\n\t\treturn (!this.classes.isEmpty() ? new AotContribution(this.classes) : null);\n\t}"
  },
  "org.springframework.context.aot.ReflectiveProcessorAotContributionBuilder#isCandidateComponent(beanDefinition)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanDefinition"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "boolean",
    "signature": "protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition)",
    "source_code": "\t\tprotected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) {\n\t\t\tString className = beanDefinition.getBeanClassName();\n\t\t\tif (className != null) {\n\t\t\t\ttry {\n\t\t\t\t\tClass<?> type = ClassUtils.forName(className, this.classLoader);\n\t\t\t\t\tbeanDefinition.setAttribute(\"type\", type);\n\t\t\t\t\treturn registrar.isCandidate(type);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Ignoring '%s' for reflective usage: %s\".formatted(className, ex.getMessage()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.context.aot.ReflectiveProcessorAotContributionBuilder#scan(classLoader,packageNames)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Scan the given {@code packageNames} and their sub-packages for classes\n\t * that uses {@link Reflective}.\n\t * <p>This performs a \"deep scan\" by loading every class in the specified\n\t * packages and search for {@link Reflective} on types, constructors, methods,\n\t * and fields. Enclosed classes are candidates as well. Classes that fail to\n\t * load are ignored.\n\t * @param classLoader the classloader to use\n\t * @param packageNames the package names to scan\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classLoader",
      "packageNames"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "ReflectiveProcessorAotContributionBuilder",
    "signature": "public ReflectiveProcessorAotContributionBuilder scan(@Nullable ClassLoader classLoader, String... packageNames)",
    "source_code": "\tpublic ReflectiveProcessorAotContributionBuilder scan(@Nullable ClassLoader classLoader, String... packageNames) {\n\t\tReflectiveClassPathScanner scanner = new ReflectiveClassPathScanner(classLoader);\n\t\treturn withClasses(scanner.scan(packageNames));\n\t}"
  },
  "org.springframework.context.aot.ReflectiveProcessorAotContributionBuilder#withClasses(classes)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Process the given classes by checking the ones that use {@link Reflective}.\n\t * <p>A class is candidate if it uses {@link Reflective} directly or via a\n\t * meta-annotation. Type, fields, constructors, methods and enclosed types\n\t * are inspected.\n\t * @param classes the classes to inspect\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classes"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "ReflectiveProcessorAotContributionBuilder",
    "signature": "public ReflectiveProcessorAotContributionBuilder withClasses(Class<?>[] classes)",
    "source_code": "\tpublic ReflectiveProcessorAotContributionBuilder withClasses(Class<?>[] classes) {\n\t\treturn withClasses(Arrays.asList(classes));\n\t}"
  },
  "org.springframework.context.event.ApplicationListenerMethodAdapter#isDefaultExecution()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether default execution is applicable for the target listener.\n\t * @since 6.2\n\t * @see #onApplicationEvent\n\t * @see EventListener#defaultExecution()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "boolean",
    "signature": "protected boolean isDefaultExecution()",
    "source_code": "\tprotected boolean isDefaultExecution() {\n\t\treturn this.defaultExecution;\n\t}"
  },
  "org.springframework.context.support.AbstractApplicationContext#clearResourceCaches()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1042
    },
    "return": "void",
    "signature": "public void clearResourceCaches()",
    "source_code": "\tpublic void clearResourceCaches() {\n\t\tsuper.clearResourceCaches();\n\t\tif (this.resourcePatternResolver instanceof PathMatchingResourcePatternResolver pmrpr) {\n\t\t\tpmrpr.clearCache();\n\t\t}\n\t}"
  },
  "org.springframework.context.support.AbstractApplicationContext#isClosed()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1235
    },
    "return": "boolean",
    "signature": "public boolean isClosed()",
    "source_code": "\tpublic boolean isClosed() {\n\t\treturn this.closed.get();\n\t}"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#setTimeoutForShutdownPhase(phase,timeout)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the maximum time allotted for the shutdown of a specific phase\n\t * (group of {@link SmartLifecycle} beans with the same 'phase' value).\n\t * <p>In case of no specific timeout configured, the default timeout per\n\t * shutdown phase will apply: 10000 milliseconds (10 seconds) as of 6.2.\n\t * @param phase the phase value (matching {@link SmartLifecycle#getPhase()})\n\t * @param timeout the corresponding timeout value (in milliseconds)\n\t * @since 6.2\n\t * @see SmartLifecycle#getPhase()\n\t * @see #setTimeoutPerShutdownPhase\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "phase",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "void",
    "signature": "public void setTimeoutForShutdownPhase(int phase, long timeout)",
    "source_code": "\tpublic void setTimeoutForShutdownPhase(int phase, long timeout) {\n\t\tthis.timeoutsForShutdownPhases.put(phase, timeout);\n\t}"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#setTimeoutsForShutdownPhases(Map<Integer,timeoutsForShutdownPhases)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the maximum time allotted for the shutdown of each given phase\n\t * (group of {@link SmartLifecycle} beans with the same 'phase' value).\n\t * <p>In case of no specific timeout configured, the default timeout per\n\t * shutdown phase will apply: 10000 milliseconds (10 seconds) as of 6.2.\n\t * @param timeoutsForShutdownPhases a map of phase values (matching\n\t * {@link SmartLifecycle#getPhase()}) and corresponding timeout values\n\t * (in milliseconds)\n\t * @since 6.2\n\t * @see SmartLifecycle#getPhase()\n\t * @see #setTimeoutPerShutdownPhase\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Integer",
      "timeoutsForShutdownPhases"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "void",
    "signature": "public void setTimeoutsForShutdownPhases(Map<Integer, Long> timeoutsForShutdownPhases)",
    "source_code": "\tpublic void setTimeoutsForShutdownPhases(Map<Integer, Long> timeoutsForShutdownPhases) {\n\t\tthis.timeoutsForShutdownPhases.putAll(timeoutsForShutdownPhases);\n\t}"
  },
  "org.springframework.core.ResolvableType#equalsType(type,Map<Type,matchedBefore)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return {@code true} if these bounds are equal to the specified type.\n\t\t * @param type the type to test against\n\t\t * @return {@code true} if these bounds are equal to the type\n\t\t * @since 6.2.4\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "Map<Type",
      "matchedBefore"
    ],
    "position": {
      "column": 1,
      "line": 1799
    },
    "return": "boolean",
    "signature": "public boolean equalsType(ResolvableType type, @Nullable Map<Type, Type> matchedBefore)",
    "source_code": "\t\tpublic boolean equalsType(ResolvableType type, @Nullable Map<Type, Type> matchedBefore) {\n\t\t\tfor (ResolvableType bound : this.bounds) {\n\t\t\t\tif (this.kind == Kind.UPPER && bound.hasUnresolvableGenerics() ?\n\t\t\t\t\t\t!type.isAssignableFrom(bound, true, matchedBefore, false) :\n\t\t\t\t\t\t!type.equalsType(bound)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}"
  },
  "org.springframework.core.ResolvableType#hasResolvableGenerics()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return {@code true} if this type contains at least a generic type\n\t * that is resolved. In other words, this returns {@code false} if\n\t * the type contains unresolvable generics only, that is, no substitute\n\t * for any of its declared type variables.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 584
    },
    "return": "boolean",
    "signature": "public boolean hasResolvableGenerics()",
    "source_code": "\tpublic boolean hasResolvableGenerics() {\n\t\tif (this == NONE) {\n\t\t\treturn false;\n\t\t}\n\t\tResolvableType[] generics = getGenerics();\n\t\tfor (ResolvableType generic : generics) {\n\t\t\tif (!generic.isUnresolvableTypeVariable() && !generic.isWildcardWithoutBounds()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.core.ResolvableType#isAssignableFrom(type,Map<Type,matchedBefore)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return {@code true} if these bounds are assignable from the specified type.\n\t\t * @param type the type to test against\n\t\t * @return {@code true} if these bounds are assignable from the type\n\t\t * @since 6.2\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "Map<Type",
      "matchedBefore"
    ],
    "position": {
      "column": 1,
      "line": 1763
    },
    "return": "boolean",
    "signature": "public boolean isAssignableFrom(ResolvableType type, @Nullable Map<Type, Type> matchedBefore)",
    "source_code": "\t\tpublic boolean isAssignableFrom(ResolvableType type, @Nullable Map<Type, Type> matchedBefore) {\n\t\t\tfor (ResolvableType bound : this.bounds) {\n\t\t\t\tif (this.kind == Kind.UPPER ? !bound.isAssignableFrom(type, false, matchedBefore, false) :\n\t\t\t\t\t\t!type.isAssignableFrom(bound, false, matchedBefore, false)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}"
  },
  "org.springframework.core.ResolvableType#isAssignableFrom(types)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return {@code true} if this bounds is assignable to all the specified types.\n\t\t * @param types the types to test against\n\t\t * @return {@code true} if this bounds is assignable to all types\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "types"
    ],
    "position": {
      "column": 1,
      "line": 1659
    },
    "return": "boolean",
    "signature": "public boolean isAssignableFrom(ResolvableType... types)",
    "source_code": "\t\tpublic boolean isAssignableFrom(ResolvableType... types) {\n\t\t\tfor (ResolvableType bound : this.bounds) {\n\t\t\t\tfor (ResolvableType type : types) {\n\t\t\t\t\tif (!isAssignable(bound, type)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}"
  },
  "org.springframework.core.ResolvableType#isAssignableFrom(types,Map<Type,matchedBefore)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return {@code true} if these bounds are assignable from all the specified types.\n\t\t * @param types the types to test against\n\t\t * @return {@code true} if these bounds are assignable from all types\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "types",
      "Map<Type",
      "matchedBefore"
    ],
    "position": {
      "column": 1,
      "line": 1740
    },
    "return": "boolean",
    "signature": "public boolean isAssignableFrom(ResolvableType[] types, @Nullable Map<Type, Type> matchedBefore)",
    "source_code": "\t\tpublic boolean isAssignableFrom(ResolvableType[] types, @Nullable Map<Type, Type> matchedBefore) {\n\t\t\tfor (ResolvableType bound : this.bounds) {\n\t\t\t\tboolean matched = false;\n\t\t\t\tfor (ResolvableType type : types) {\n\t\t\t\t\tif (this.kind == Kind.UPPER ? bound.isAssignableFrom(type, false, matchedBefore, false) :\n\t\t\t\t\t\t\ttype.isAssignableFrom(bound, false, matchedBefore, false)) {\n\t\t\t\t\t\tmatched = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!matched) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}"
  },
  "org.springframework.core.ResolvableType#isAssignableFromResolvedPart(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether this {@code ResolvableType} is assignable from the\n\t * specified other type, as far as the other type is actually resolvable.\n\t * @param other the type to be checked against (as a {@code ResolvableType})\n\t * @return {@code true} if the specified other type can be assigned to this\n\t * {@code ResolvableType} as far as it is resolvable; {@code false} otherwise\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "boolean",
    "signature": "public boolean isAssignableFromResolvedPart(ResolvableType other)",
    "source_code": "\tpublic boolean isAssignableFromResolvedPart(ResolvableType other) {\n\t\treturn isAssignableFrom(other, false, null, true);\n\t}"
  },
  "org.springframework.core.ResolvableType#isAssignableTo(type,Map<Type,matchedBefore)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return {@code true} if these bounds are assignable to the specified type.\n\t\t * @param type the type to test against\n\t\t * @return {@code true} if these bounds are assignable to the type\n\t\t * @since 6.2\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "Map<Type",
      "matchedBefore"
    ],
    "position": {
      "column": 1,
      "line": 1779
    },
    "return": "boolean",
    "signature": "public boolean isAssignableTo(ResolvableType type, @Nullable Map<Type, Type> matchedBefore)",
    "source_code": "\t\tpublic boolean isAssignableTo(ResolvableType type, @Nullable Map<Type, Type> matchedBefore) {\n\t\t\tif (this.kind == Kind.UPPER) {\n\t\t\t\tfor (ResolvableType bound : this.bounds) {\n\t\t\t\t\tif (type.isAssignableFrom(bound, false, matchedBefore, false)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn (type.resolve() == Object.class);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.core.annotation.AnnotatedMethod": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * A convenient wrapper for a {@link Method} handle, providing deep annotation\n * introspection on methods and method parameters, including the exposure of\n * interface-declared parameter annotations from the concrete target method.\n *\n * @author Juergen Hoeller\n * @since 6.1\n * @see #getMethodAnnotation(Class)\n * @see #getMethodParameters()\n * @see AnnotatedElementUtils\n * @see SynthesizingMethodParameter\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "signature": "public class AnnotatedMethod",
    "source_code": "public class AnnotatedMethod {\n\n\tprivate final Method method;\n\n\tprivate final Method bridgedMethod;\n\n\tprivate final MethodParameter[] parameters;\n\n\t@Nullable\n\tprivate volatile List<Annotation[][]> inheritedParameterAnnotations;\n\n\n\t/**\n\t * Create an instance that wraps the given {@link Method}.\n\t * @param method the {@code Method} handle to wrap\n\t */\n\tpublic AnnotatedMethod(Method method) {\n\t\tAssert.notNull(method, \"Method is required\");\n\t\tthis.method = method;\n\t\tthis.bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);\n\t\tReflectionUtils.makeAccessible(this.bridgedMethod);\n\t\tthis.parameters = initMethodParameters();\n\t}\n\n\t/**\n\t * Copy constructor for use in subclasses.\n\t */\n\tprotected AnnotatedMethod(AnnotatedMethod annotatedMethod) {\n\t\tAssert.notNull(annotatedMethod, \"AnnotatedMethod is required\");\n\t\tthis.method = annotatedMethod.method;\n\t\tthis.bridgedMethod = annotatedMethod.bridgedMethod;\n\t\tthis.parameters = annotatedMethod.parameters;\n\t\tthis.inheritedParameterAnnotations = annotatedMethod.inheritedParameterAnnotations;\n\t}\n\n\n\t/**\n\t * Return the annotated method.\n\t */\n\tpublic final Method getMethod() {\n\t\treturn this.method;\n\t}\n\n\t/**\n\t * If the annotated method is a bridge method, this method returns the bridged\n\t * (user-defined) method. Otherwise, it returns the same method as {@link #getMethod()}.\n\t */\n\tprotected final Method getBridgedMethod() {\n\t\treturn this.bridgedMethod;\n\t}\n\n\t/**\n\t * Expose the containing class for method parameters.\n\t * @see MethodParameter#getContainingClass()\n\t */\n\tprotected Class<?> getContainingClass() {\n\t\treturn this.method.getDeclaringClass();\n\t}\n\n\t/**\n\t * Return the method parameters for this {@code AnnotatedMethod}.\n\t */\n\tpublic final MethodParameter[] getMethodParameters() {\n\t\treturn this.parameters;\n\t}\n\n\tprivate MethodParameter[] initMethodParameters() {\n\t\tint count = this.bridgedMethod.getParameterCount();\n\t\tMethodParameter[] result = new MethodParameter[count];\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tresult[i] = new AnnotatedMethodParameter(i);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Return a {@link MethodParameter} for the declared return type.\n\t */\n\tpublic MethodParameter getReturnType() {\n\t\treturn new AnnotatedMethodParameter(-1);\n\t}\n\n\t/**\n\t * Return a {@link MethodParameter} for the actual return value type.\n\t */\n\tpublic MethodParameter getReturnValueType(@Nullable Object returnValue) {\n\t\treturn new ReturnValueMethodParameter(returnValue);\n\t}\n\n\t/**\n\t * Return {@code true} if the method's return type is void, {@code false} otherwise.\n\t */\n\tpublic boolean isVoid() {\n\t\treturn (getReturnType().getParameterType() == void.class);\n\t}\n\n\t/**\n\t * Return a single annotation on the underlying method, traversing its super methods\n\t * if no annotation can be found on the given method itself.\n\t * <p>Supports <em>merged</em> composed annotations with attribute overrides.\n\t * @param annotationType the annotation type to look for\n\t * @return the annotation, or {@code null} if none found\n\t * @see AnnotatedElementUtils#findMergedAnnotation\n\t */\n\t@Nullable\n\tpublic <A extends Annotation> A getMethodAnnotation(Class<A> annotationType) {\n\t\treturn AnnotatedElementUtils.findMergedAnnotation(this.method, annotationType);\n\t}\n\n\t/**\n\t * Determine if an annotation of the given type is <em>present</em> or\n\t * <em>meta-present</em> on the method.\n\t * @param annotationType the annotation type to look for\n\t * @see AnnotatedElementUtils#hasAnnotation\n\t */\n\tpublic <A extends Annotation> boolean hasMethodAnnotation(Class<A> annotationType) {\n\t\treturn AnnotatedElementUtils.hasAnnotation(this.method, annotationType);\n\t}\n\n\tprivate List<Annotation[][]> getInheritedParameterAnnotations() {\n\t\tList<Annotation[][]> parameterAnnotations = this.inheritedParameterAnnotations;\n\t\tif (parameterAnnotations == null) {\n\t\t\tparameterAnnotations = new ArrayList<>();\n\t\t\tClass<?> clazz = this.method.getDeclaringClass();\n\t\t\twhile (clazz != null) {\n\t\t\t\tfor (Class<?> ifc : clazz.getInterfaces()) {\n\t\t\t\t\tfor (Method candidate : ifc.getMethods()) {\n\t\t\t\t\t\tif (isOverrideFor(candidate)) {\n\t\t\t\t\t\t\tparameterAnnotations.add(candidate.getParameterAnnotations());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tclazz = clazz.getSuperclass();\n\t\t\t\tif (clazz == Object.class) {\n\t\t\t\t\tclazz = null;\n\t\t\t\t}\n\t\t\t\tif (clazz != null) {\n\t\t\t\t\tfor (Method candidate : clazz.getMethods()) {\n\t\t\t\t\t\tif (isOverrideFor(candidate)) {\n\t\t\t\t\t\t\tparameterAnnotations.add(candidate.getParameterAnnotations());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.inheritedParameterAnnotations = parameterAnnotations;\n\t\t}\n\t\treturn parameterAnnotations;\n\t}\n\n\tprivate boolean isOverrideFor(Method candidate) {\n\t\tif (!candidate.getName().equals(this.method.getName()) ||\n\t\t\t\tcandidate.getParameterCount() != this.method.getParameterCount()) {\n\t\t\treturn false;\n\t\t}\n\t\tClass<?>[] paramTypes = this.method.getParameterTypes();\n\t\tif (Arrays.equals(candidate.getParameterTypes(), paramTypes)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (int i = 0; i < paramTypes.length; i++) {\n\t\t\tif (paramTypes[i] !=\n\t\t\t\t\tResolvableType.forMethodParameter(candidate, i, this.method.getDeclaringClass()).resolve()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof AnnotatedMethod otherHandlerMethod &&\n\t\t\t\tthis.method.equals(otherHandlerMethod.method)));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.method.hashCode();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn this.method.toGenericString();\n\t}\n\n\n\t// Support methods for use in subclass variants\n\n\t@Nullable\n\tprotected static Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs) {\n\t\tif (!ObjectUtils.isEmpty(providedArgs)) {\n\t\t\tfor (Object providedArg : providedArgs) {\n\t\t\t\tif (parameter.getParameterType().isInstance(providedArg)) {\n\t\t\t\t\treturn providedArg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected static String formatArgumentError(MethodParameter param, String message) {\n\t\treturn \"Could not resolve parameter [\" + param.getParameterIndex() + \"] in \" +\n\t\t\t\tparam.getExecutable().toGenericString() + (StringUtils.hasText(message) ? \": \" + message : \"\");\n\t}\n\n\n\t/**\n\t * A MethodParameter with AnnotatedMethod-specific behavior.\n\t */\n\tprotected class AnnotatedMethodParameter extends SynthesizingMethodParameter {\n\n\t\t@Nullable\n\t\tprivate volatile Annotation[] combinedAnnotations;\n\n\t\tpublic AnnotatedMethodParameter(int index) {\n\t\t\tsuper(AnnotatedMethod.this.getBridgedMethod(), index);\n\t\t}\n\n\t\tprotected AnnotatedMethodParameter(AnnotatedMethodParameter original) {\n\t\t\tsuper(original);\n\t\t\tthis.combinedAnnotations = original.combinedAnnotations;\n\t\t}\n\n\t\t@Override\n\t\t@NonNull\n\t\tpublic Method getMethod() {\n\t\t\treturn AnnotatedMethod.this.getBridgedMethod();\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<?> getContainingClass() {\n\t\t\treturn AnnotatedMethod.this.getContainingClass();\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic <T extends Annotation> T getMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn AnnotatedMethod.this.getMethodAnnotation(annotationType);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T extends Annotation> boolean hasMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn AnnotatedMethod.this.hasMethodAnnotation(annotationType);\n\t\t}\n\n\t\t@Override\n\t\tpublic Annotation[] getParameterAnnotations() {\n\t\t\tAnnotation[] anns = this.combinedAnnotations;\n\t\t\tif (anns == null) {\n\t\t\t\tanns = super.getParameterAnnotations();\n\t\t\t\tint index = getParameterIndex();\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tfor (Annotation[][] ifcAnns : getInheritedParameterAnnotations()) {\n\t\t\t\t\t\tif (index < ifcAnns.length) {\n\t\t\t\t\t\t\tAnnotation[] paramAnns = ifcAnns[index];\n\t\t\t\t\t\t\tif (paramAnns.length > 0) {\n\t\t\t\t\t\t\t\tList<Annotation> merged = new ArrayList<>(anns.length + paramAnns.length);\n\t\t\t\t\t\t\t\tmerged.addAll(Arrays.asList(anns));\n\t\t\t\t\t\t\t\tfor (Annotation paramAnn : paramAnns) {\n\t\t\t\t\t\t\t\t\tboolean existingType = false;\n\t\t\t\t\t\t\t\t\tfor (Annotation ann : anns) {\n\t\t\t\t\t\t\t\t\t\tif (ann.annotationType() == paramAnn.annotationType()) {\n\t\t\t\t\t\t\t\t\t\t\texistingType = true;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!existingType) {\n\t\t\t\t\t\t\t\t\t\tmerged.add(adaptAnnotation(paramAnn));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tanns = merged.toArray(new Annotation[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.combinedAnnotations = anns;\n\t\t\t}\n\t\t\treturn anns;\n\t\t}\n\n\t\t@Override\n\t\tpublic AnnotatedMethodParameter clone() {\n\t\t\treturn new AnnotatedMethodParameter(this);\n\t\t}\n\t}\n\n\n\t/**\n\t * A MethodParameter for an AnnotatedMethod return type based on an actual return value.\n\t */\n\tprivate class ReturnValueMethodParameter extends AnnotatedMethodParameter {\n\n\t\t@Nullable\n\t\tprivate final Class<?> returnValueType;\n\n\t\tpublic ReturnValueMethodParameter(@Nullable Object returnValue) {\n\t\t\tsuper(-1);\n\t\t\tthis.returnValueType = (returnValue != null ? returnValue.getClass() : null);\n\t\t}\n\n\t\tprotected ReturnValueMethodParameter(ReturnValueMethodParameter original) {\n\t\t\tsuper(original);\n\t\t\tthis.returnValueType = original.returnValueType;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<?> getParameterType() {\n\t\t\treturn (this.returnValueType != null ? this.returnValueType : super.getParameterType());\n\t\t}\n\n\t\t@Override\n\t\tpublic ReturnValueMethodParameter clone() {\n\t\t\treturn new ReturnValueMethodParameter(this);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.core.annotation.AnnotatedMethod#clone()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 357
    },
    "return": "ReturnValueMethodParameter",
    "signature": "public ReturnValueMethodParameter clone()",
    "source_code": "\t\tpublic ReturnValueMethodParameter clone() {\n\t\t\treturn new ReturnValueMethodParameter(this);\n\t\t}"
  },
  "org.springframework.core.annotation.AnnotatedMethod#equals(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof AnnotatedMethod otherHandlerMethod &&\n\t\t\t\tthis.method.equals(otherHandlerMethod.method)));\n\t}"
  },
  "org.springframework.core.annotation.AnnotatedMethod#findProvidedArgument(parameter,providedArgs)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "Object",
    "signature": "protected Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs)",
    "source_code": "\tprotected static Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs) {\n\t\tif (!ObjectUtils.isEmpty(providedArgs)) {\n\t\t\tfor (Object providedArg : providedArgs) {\n\t\t\t\tif (parameter.getParameterType().isInstance(providedArg)) {\n\t\t\t\t\treturn providedArg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.core.annotation.AnnotatedMethod#formatArgumentError(param,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "param",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "String",
    "signature": "protected String formatArgumentError(MethodParameter param, String message)",
    "source_code": "\tprotected static String formatArgumentError(MethodParameter param, String message) {\n\t\treturn \"Could not resolve parameter [\" + param.getParameterIndex() + \"] in \" +\n\t\t\t\tparam.getExecutable().toGenericString() + (StringUtils.hasText(message) ? \": \" + message : \"\");\n\t}"
  },
  "org.springframework.core.annotation.AnnotatedMethod#getBridgedMethod()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * If the annotated method is a bridge method, this method returns the bridged\n\t * (user-defined) method. Otherwise, it returns the same method as {@link #getMethod()}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "Method",
    "signature": "protected Method getBridgedMethod()",
    "source_code": "\tprotected final Method getBridgedMethod() {\n\t\treturn this.bridgedMethod;\n\t}"
  },
  "org.springframework.core.annotation.AnnotatedMethod#getMethod()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "Method",
    "signature": "public Method getMethod()",
    "source_code": "\t\tpublic Method getMethod() {\n\t\t\treturn AnnotatedMethod.this.getBridgedMethod();\n\t\t}"
  },
  "org.springframework.core.annotation.AnnotatedMethod#getMethodAnnotation(annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "T",
    "signature": "public T getMethodAnnotation(Class<T> annotationType)",
    "source_code": "\t\tpublic <T extends Annotation> T getMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn AnnotatedMethod.this.getMethodAnnotation(annotationType);\n\t\t}"
  },
  "org.springframework.core.annotation.AnnotatedMethod#getMethodParameters()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the method parameters for this {@code AnnotatedMethod}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "MethodParameter[]",
    "signature": "public MethodParameter[] getMethodParameters()",
    "source_code": "\tpublic final MethodParameter[] getMethodParameters() {\n\t\treturn this.parameters;\n\t}"
  },
  "org.springframework.core.annotation.AnnotatedMethod#getParameterAnnotations()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "Annotation[]",
    "signature": "public Annotation[] getParameterAnnotations()",
    "source_code": "\t\tpublic Annotation[] getParameterAnnotations() {\n\t\t\tAnnotation[] anns = this.combinedAnnotations;\n\t\t\tif (anns == null) {\n\t\t\t\tanns = super.getParameterAnnotations();\n\t\t\t\tint index = getParameterIndex();\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tfor (Annotation[][] ifcAnns : getInheritedParameterAnnotations()) {\n\t\t\t\t\t\tif (index < ifcAnns.length) {\n\t\t\t\t\t\t\tAnnotation[] paramAnns = ifcAnns[index];\n\t\t\t\t\t\t\tif (paramAnns.length > 0) {\n\t\t\t\t\t\t\t\tList<Annotation> merged = new ArrayList<>(anns.length + paramAnns.length);\n\t\t\t\t\t\t\t\tmerged.addAll(Arrays.asList(anns));\n\t\t\t\t\t\t\t\tfor (Annotation paramAnn : paramAnns) {\n\t\t\t\t\t\t\t\t\tboolean existingType = false;\n\t\t\t\t\t\t\t\t\tfor (Annotation ann : anns) {\n\t\t\t\t\t\t\t\t\t\tif (ann.annotationType() == paramAnn.annotationType()) {\n\t\t\t\t\t\t\t\t\t\t\texistingType = true;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!existingType) {\n\t\t\t\t\t\t\t\t\t\tmerged.add(adaptAnnotation(paramAnn));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tanns = merged.toArray(new Annotation[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.combinedAnnotations = anns;\n\t\t\t}\n\t\t\treturn anns;\n\t\t}"
  },
  "org.springframework.core.annotation.AnnotatedMethod#getReturnType()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link MethodParameter} for the declared return type.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter getReturnType()",
    "source_code": "\tpublic MethodParameter getReturnType() {\n\t\treturn new AnnotatedMethodParameter(-1);\n\t}"
  },
  "org.springframework.core.annotation.AnnotatedMethod#getReturnValueType(returnValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link MethodParameter} for the actual return value type.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter getReturnValueType(@Nullable Object returnValue)",
    "source_code": "\tpublic MethodParameter getReturnValueType(@Nullable Object returnValue) {\n\t\treturn new ReturnValueMethodParameter(returnValue);\n\t}"
  },
  "org.springframework.core.annotation.AnnotatedMethod#hasMethodAnnotation(annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "boolean",
    "signature": "public boolean hasMethodAnnotation(Class<T> annotationType)",
    "source_code": "\t\tpublic <T extends Annotation> boolean hasMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn AnnotatedMethod.this.hasMethodAnnotation(annotationType);\n\t\t}"
  },
  "org.springframework.core.annotation.AnnotatedMethod#hashCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.method.hashCode();\n\t}"
  },
  "org.springframework.core.annotation.AnnotatedMethod#isVoid()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return {@code true} if the method's return type is void, {@code false} otherwise.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "boolean",
    "signature": "public boolean isVoid()",
    "source_code": "\tpublic boolean isVoid() {\n\t\treturn (getReturnType().getParameterType() == void.class);\n\t}"
  },
  "org.springframework.core.annotation.AnnotatedMethod#toString()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn this.method.toGenericString();\n\t}"
  },
  "org.springframework.core.annotation.AnnotatedMethodParameter": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * A MethodParameter with AnnotatedMethod-specific behavior.\n\t */",
    "kind": "class",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 255
    },
    "signature": "protected class AnnotatedMethodParameter",
    "source_code": "\tprotected class AnnotatedMethodParameter extends SynthesizingMethodParameter {\n\n\t\t@Nullable\n\t\tprivate volatile Annotation[] combinedAnnotations;\n\n\t\tpublic AnnotatedMethodParameter(int index) {\n\t\t\tsuper(AnnotatedMethod.this.getBridgedMethod(), index);\n\t\t}\n\n\t\tprotected AnnotatedMethodParameter(AnnotatedMethodParameter original) {\n\t\t\tsuper(original);\n\t\t\tthis.combinedAnnotations = original.combinedAnnotations;\n\t\t}\n\n\t\t@Override\n\t\t@NonNull\n\t\tpublic Method getMethod() {\n\t\t\treturn AnnotatedMethod.this.getBridgedMethod();\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<?> getContainingClass() {\n\t\t\treturn AnnotatedMethod.this.getContainingClass();\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic <T extends Annotation> T getMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn AnnotatedMethod.this.getMethodAnnotation(annotationType);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T extends Annotation> boolean hasMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn AnnotatedMethod.this.hasMethodAnnotation(annotationType);\n\t\t}\n\n\t\t@Override\n\t\tpublic Annotation[] getParameterAnnotations() {\n\t\t\tAnnotation[] anns = this.combinedAnnotations;\n\t\t\tif (anns == null) {\n\t\t\t\tanns = super.getParameterAnnotations();\n\t\t\t\tint index = getParameterIndex();\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tfor (Annotation[][] ifcAnns : getInheritedParameterAnnotations()) {\n\t\t\t\t\t\tif (index < ifcAnns.length) {\n\t\t\t\t\t\t\tAnnotation[] paramAnns = ifcAnns[index];\n\t\t\t\t\t\t\tif (paramAnns.length > 0) {\n\t\t\t\t\t\t\t\tList<Annotation> merged = new ArrayList<>(anns.length + paramAnns.length);\n\t\t\t\t\t\t\t\tmerged.addAll(Arrays.asList(anns));\n\t\t\t\t\t\t\t\tfor (Annotation paramAnn : paramAnns) {\n\t\t\t\t\t\t\t\t\tboolean existingType = false;\n\t\t\t\t\t\t\t\t\tfor (Annotation ann : anns) {\n\t\t\t\t\t\t\t\t\t\tif (ann.annotationType() == paramAnn.annotationType()) {\n\t\t\t\t\t\t\t\t\t\t\texistingType = true;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!existingType) {\n\t\t\t\t\t\t\t\t\t\tmerged.add(adaptAnnotation(paramAnn));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tanns = merged.toArray(new Annotation[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.combinedAnnotations = anns;\n\t\t\t}\n\t\t\treturn anns;\n\t\t}\n\n\t\t@Override\n\t\tpublic AnnotatedMethodParameter clone() {\n\t\t\treturn new AnnotatedMethodParameter(this);\n\t\t}\n\t}"
  },
  "org.springframework.core.convert.support.GenericConversionService#matchesFallback(sourceType,targetType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 351
    },
    "return": "boolean",
    "signature": "public boolean matchesFallback(TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\t\tpublic boolean matchesFallback(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\treturn (this.typeInfo.getTargetType() == targetType.getObjectType() &&\n\t\t\t\t\tthis.targetType.hasUnresolvableGenerics() &&\n\t\t\t\t\t(!(this.converter instanceof ConditionalConverter conditionalConverter) ||\n\t\t\t\t\t\t\tconditionalConverter.matches(sourceType, targetType)));\n\t\t}"
  },
  "org.springframework.core.io.buffer.DataBufferUtils#map(b)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b"
    ],
    "position": {
      "column": 1,
      "line": 1296
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer map(int b)",
    "source_code": "\t\tpublic DataBuffer map(int b) {\n\t\t\tDataBuffer buffer = this.bufferFactory.allocateBuffer(1);\n\t\t\tbuffer.write((byte) b);\n\t\t\treturn buffer;\n\t\t}"
  },
  "org.springframework.core.io.buffer.DataBufferUtils#map(b,off,len)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b",
      "off",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 1303
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer map(byte[] b, int off, int len)",
    "source_code": "\t\tpublic DataBuffer map(byte[] b, int off, int len) {\n\t\t\tDataBuffer buffer = this.bufferFactory.allocateBuffer(len);\n\t\t\tbuffer.write(b, off, len);\n\t\t\treturn buffer;\n\t\t}"
  },
  "org.springframework.core.io.buffer.DataBufferUtils#outputStreamPublisher(consumer,bufferFactory,executor)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@code Publisher<DataBuffer>} based on bytes written to a\n\t * {@code OutputStream}.\n\t * <ul>\n\t * <li>The parameter {@code outputStreamConsumer} is invoked once per\n\t * subscription of the returned {@code Publisher}, when the first\n\t * item is\n\t * {@linkplain Subscription#request(long) requested}.</li>\n\t * <li>{@link OutputStream#write(byte[], int, int) OutputStream.write()}\n\t * invocations made by {@code outputStreamConsumer} are buffered until they\n\t * exceed the default chunk size of 1024, or when the stream is\n\t * {@linkplain OutputStream#flush() flushed} and then result in a\n\t * {@linkplain Subscriber#onNext(Object) published} item\n\t * if there is {@linkplain Subscription#request(long) demand}.</li>\n\t * <li>If there is <em>no demand</em>, {@code OutputStream.write()} will block\n\t * until there is.</li>\n\t * <li>If the subscription is {@linkplain Subscription#cancel() cancelled},\n\t * {@code OutputStream.write()} will throw a {@code IOException}.</li>\n\t * <li>The subscription is\n\t * {@linkplain Subscriber#onComplete() completed} when\n\t * {@code outputStreamHandler} completes.</li>\n\t * <li>Any exceptions thrown from {@code outputStreamHandler} will\n\t * be dispatched to the {@linkplain Subscriber#onError(Throwable) Subscriber}.\n\t * </ul>\n\t * @param consumer invoked when the first buffer is requested\n\t * @param executor used to invoke the {@code outputStreamHandler}\n\t * @return a {@code Publisher<DataBuffer>} based on bytes written by\n\t * {@code outputStreamHandler}\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "consumer",
      "bufferFactory",
      "executor"
    ],
    "position": {
      "column": 1,
      "line": 441
    },
    "return": "Publisher<DataBuffer>",
    "signature": "public Publisher<DataBuffer> outputStreamPublisher(Consumer<OutputStream> consumer, DataBufferFactory bufferFactory, Executor executor)",
    "source_code": "\tpublic static Publisher<DataBuffer> outputStreamPublisher("
  },
  "org.springframework.core.io.buffer.DataBufferUtils#outputStreamPublisher(consumer,bufferFactory,executor,chunkSize)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #outputStreamPublisher(Consumer, DataBufferFactory, Executor)}\n\t * providing control over the chunk sizes to be produced by the publisher.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "consumer",
      "bufferFactory",
      "executor",
      "chunkSize"
    ],
    "position": {
      "column": 1,
      "line": 453
    },
    "return": "Publisher<DataBuffer>",
    "signature": "public Publisher<DataBuffer> outputStreamPublisher(Consumer<OutputStream> consumer, DataBufferFactory bufferFactory, Executor executor, int chunkSize)",
    "source_code": "\tpublic static Publisher<DataBuffer> outputStreamPublisher("
  },
  "org.springframework.core.io.buffer.DataBufferUtils#outputStreamPublisher(outputStreamConsumer,bufferFactory,executor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@code Publisher<DataBuffer>} based on bytes written to a\n\t * {@code OutputStream}.\n\t * <ul>\n\t * <li>The parameter {@code outputStreamConsumer} is invoked once per\n\t * subscription of the returned {@code Publisher}, when the first\n\t * item is\n\t * {@linkplain Subscription#request(long) requested}.</li>\n\t * <li>{@link OutputStream#write(byte[], int, int) OutputStream.write()}\n\t * invocations made by {@code outputStreamConsumer} are buffered until they\n\t * exceed the default chunk size of 1024, or when the stream is\n\t * {@linkplain OutputStream#flush() flushed} and then result in a\n\t * {@linkplain Subscriber#onNext(Object) published} item\n\t * if there is {@linkplain Subscription#request(long) demand}.</li>\n\t * <li>If there is <em>no demand</em>, {@code OutputStream.write()} will block\n\t * until there is.</li>\n\t * <li>If the subscription is {@linkplain Subscription#cancel() cancelled},\n\t * {@code OutputStream.write()} will throw a {@code IOException}.</li>\n\t * <li>The subscription is\n\t * {@linkplain Subscriber#onComplete() completed} when\n\t * {@code outputStreamHandler} completes.</li>\n\t * <li>Any exceptions thrown from {@code outputStreamHandler} will\n\t * be dispatched to the {@linkplain Subscriber#onError(Throwable) Subscriber}.\n\t * </ul>\n\t * @param outputStreamConsumer invoked when the first buffer is requested\n\t * @param executor used to invoke the {@code outputStreamHandler}\n\t * @return a {@code Publisher<DataBuffer>} based on bytes written by\n\t * {@code outputStreamHandler}\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outputStreamConsumer",
      "bufferFactory",
      "executor"
    ],
    "position": {
      "column": 1,
      "line": 442
    },
    "return": "Publisher<DataBuffer>",
    "signature": "public Publisher<DataBuffer> outputStreamPublisher(Consumer<OutputStream> outputStreamConsumer,\n\t\t\tDataBufferFactory bufferFactory, Executor executor)",
    "source_code": "\tpublic static Publisher<DataBuffer> outputStreamPublisher(Consumer<OutputStream> outputStreamConsumer,"
  },
  "org.springframework.core.io.buffer.DataBufferUtils#outputStreamPublisher(outputStreamConsumer,bufferFactory,executor,chunkSize)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Creates a new {@code Publisher<DataBuffer>} based on bytes written to a\n\t * {@code OutputStream}.\n\t * <ul>\n\t * <li>The parameter {@code outputStreamConsumer} is invoked once per\n\t * subscription of the returned {@code Publisher}, when the first\n\t * item is\n\t * {@linkplain Subscription#request(long) requested}.</li>\n\t * <li>{@link OutputStream#write(byte[], int, int) OutputStream.write()}\n\t * invocations made by {@code outputStreamHandler} are buffered until they\n\t * reach or exceed {@code chunkSize}, or when the stream is\n\t * {@linkplain OutputStream#flush() flushed} and then result in a\n\t * {@linkplain Subscriber#onNext(Object) published} item\n\t * if there is {@linkplain Subscription#request(long) demand}.</li>\n\t * <li>If there is <em>no demand</em>, {@code OutputStream.write()} will block\n\t * until there is.</li>\n\t * <li>If the subscription is {@linkplain Subscription#cancel() cancelled},\n\t * {@code OutputStream.write()} will throw a {@code IOException}.</li>\n\t * <li>The subscription is\n\t * {@linkplain Subscriber#onComplete() completed} when\n\t * {@code outputStreamHandler} completes.</li>\n\t * <li>Any exceptions thrown from {@code outputStreamHandler} will\n\t * be dispatched to the {@linkplain Subscriber#onError(Throwable) Subscriber}.\n\t * </ul>\n\t * @param outputStreamConsumer invoked when the first buffer is requested\n\t * @param executor used to invoke the {@code outputStreamHandler}\n\t * @param chunkSize minimum size of the buffer produced by the publisher\n\t * @return a {@code Publisher<DataBuffer>} based on bytes written by\n\t * {@code outputStreamHandler}\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outputStreamConsumer",
      "bufferFactory",
      "executor",
      "chunkSize"
    ],
    "position": {
      "column": 1,
      "line": 479
    },
    "return": "Publisher<DataBuffer>",
    "signature": "public Publisher<DataBuffer> outputStreamPublisher(Consumer<OutputStream> outputStreamConsumer,\n\t\t\tDataBufferFactory bufferFactory, Executor executor, int chunkSize)",
    "source_code": "\tpublic static Publisher<DataBuffer> outputStreamPublisher(Consumer<OutputStream> outputStreamConsumer,"
  },
  "org.springframework.core.io.buffer.DataBufferUtils#subscriberInputStream(publisher,demand)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Subscribe to given {@link Publisher} of {@code DataBuffer}s, and return an\n\t * {@link InputStream} to consume the byte content with.\n\t * <p>Byte buffers are stored in a queue. The {@code demand} constructor value\n\t * determines the number of buffers requested initially. When storage falls\n\t * below a {@code (demand - (demand >> 2))} limit, a request is made to refill\n\t * the queue.\n\t * <p>The {@code InputStream} terminates after an onError or onComplete signal,\n\t * and stored buffers are read. If the {@code InputStream} is closed,\n\t * the {@link Flow.Subscription} is cancelled, and stored buffers released.\n\t * @param publisher the source of {@code DataBuffer}s\n\t * @param demand the number of buffers to request initially, and buffer\n\t * internally on an ongoing basis.\n\t * @return an {@link InputStream} backed by the {@link Publisher}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "publisher",
      "demand"
    ],
    "position": {
      "column": 1,
      "line": 475
    },
    "return": "InputStream",
    "signature": "public InputStream subscriberInputStream(Publisher<T> publisher, int demand)",
    "source_code": "\tpublic static <T extends DataBuffer> InputStream subscriberInputStream(Publisher<T> publisher, int demand) {\n\t\tAssert.notNull(publisher, \"Publisher must not be null\");\n\t\tAssert.isTrue(demand > 0, \"maxBufferCount must be > 0\");\n\n\t\tSubscriberInputStream subscriber = new SubscriberInputStream(demand);\n\t\tpublisher.subscribe(subscriber);\n\t\treturn subscriber;\n\t}"
  },
  "org.springframework.core.io.buffer.DefaultDataBuffer#split(index)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index"
    ],
    "position": {
      "column": 1,
      "line": 356
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer split(int index)",
    "source_code": "\tpublic DataBuffer split(int index) {\n\t\tcheckIndex(index);\n\n\t\tByteBuffer split = this.byteBuffer.duplicate().clear()\n\t\t\t.position(0)\n\t\t\t.limit(index)\n\t\t\t.slice();\n\n\t\tDefaultDataBuffer result = new DefaultDataBuffer(this.dataBufferFactory, split);\n\t\tresult.writePosition = Math.min(this.writePosition, index);\n\t\tresult.readPosition = Math.min(this.readPosition, index);\n\n\t\tthis.byteBuffer = this.byteBuffer.duplicate().clear()\n\t\t\t\t.position(index)\n\t\t\t\t.limit(this.byteBuffer.capacity())\n\t\t\t\t.slice();\n\t\tthis.writePosition = Math.max(this.writePosition, index) - index;\n\t\tthis.readPosition = Math.max(this.readPosition, index) - index;\n\t\tthis.capacity = this.byteBuffer.capacity();\n\n\t\treturn result;\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Implementation of the {@code DataBuffer} interface that can wrap a Jetty\n * {@link Content.Chunk}. Typically constructed with {@link JettyDataBufferFactory}.\n *\n * @author Greg Wilkins\n * @author Lachlan Roberts\n * @author Arjen Poutsma\n * @since 6.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "signature": "public class JettyDataBuffer",
    "source_code": "public final class JettyDataBuffer implements PooledDataBuffer {\n\n\tprivate final DefaultDataBuffer delegate;\n\n\t@Nullable\n\tprivate final Content.Chunk chunk;\n\n\tprivate final JettyDataBufferFactory bufferFactory;\n\n\tprivate final AtomicInteger refCount = new AtomicInteger(1);\n\n\n\tJettyDataBuffer(JettyDataBufferFactory bufferFactory, DefaultDataBuffer delegate, Content.Chunk chunk) {\n\t\tAssert.notNull(bufferFactory, \"BufferFactory must not be null\");\n\t\tAssert.notNull(delegate, \"Delegate must not be null\");\n\t\tAssert.notNull(chunk, \"Chunk must not be null\");\n\n\t\tthis.bufferFactory = bufferFactory;\n\t\tthis.delegate = delegate;\n\t\tthis.chunk = chunk;\n\t\tthis.chunk.retain();\n\t}\n\n\tJettyDataBuffer(JettyDataBufferFactory bufferFactory, DefaultDataBuffer delegate) {\n\t\tAssert.notNull(bufferFactory, \"BufferFactory must not be null\");\n\t\tAssert.notNull(delegate, \"Delegate must not be null\");\n\n\t\tthis.bufferFactory = bufferFactory;\n\t\tthis.delegate = delegate;\n\t\tthis.chunk = null;\n\t}\n\n\n\t@Override\n\tpublic boolean isAllocated() {\n\t\treturn this.refCount.get() > 0;\n\t}\n\n\t@Override\n\tpublic PooledDataBuffer retain() {\n\t\tint result = this.refCount.updateAndGet(c -> (c != 0 ? c + 1 : 0));\n\t\tif (result != 0 && this.chunk != null) {\n\t\t\tthis.chunk.retain();\n\t\t}\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic PooledDataBuffer touch(Object hint) {\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic boolean release() {\n\t\tint result = this.refCount.updateAndGet(c -> {\n\t\t\tif (c != 0) {\n\t\t\t\treturn c - 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalStateException(\"JettyDataBuffer already released: \" + this);\n\t\t\t}\n\t\t});\n\t\tif (this.chunk != null) {\n\t\t\treturn this.chunk.release();\n\t\t}\n\t\telse {\n\t\t\treturn (result == 0);\n\t\t}\n\t}\n\n\t@Override\n\tpublic DataBufferFactory factory() {\n\t\treturn this.bufferFactory;\n\t}\n\n\n\t// delegation\n\n\t@Override\n\tpublic int indexOf(IntPredicate predicate, int fromIndex) {\n\t\treturn this.delegate.indexOf(predicate, fromIndex);\n\t}\n\n\t@Override\n\tpublic int lastIndexOf(IntPredicate predicate, int fromIndex) {\n\t\treturn this.delegate.lastIndexOf(predicate, fromIndex);\n\t}\n\n\t@Override\n\tpublic int readableByteCount() {\n\t\treturn this.delegate.readableByteCount();\n\t}\n\n\t@Override\n\tpublic int writableByteCount() {\n\t\treturn this.delegate.writableByteCount();\n\t}\n\n\t@Override\n\tpublic int capacity() {\n\t\treturn this.delegate.capacity();\n\t}\n\n\t@Override\n\t@Deprecated\n\tpublic DataBuffer capacity(int capacity) {\n\t\tthis.delegate.capacity(capacity);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic DataBuffer ensureWritable(int capacity) {\n\t\tthis.delegate.ensureWritable(capacity);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic int readPosition() {\n\t\treturn this.delegate.readPosition();\n\t}\n\n\t@Override\n\tpublic DataBuffer readPosition(int readPosition) {\n\t\tthis.delegate.readPosition(readPosition);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic int writePosition() {\n\t\treturn this.delegate.writePosition();\n\t}\n\n\t@Override\n\tpublic DataBuffer writePosition(int writePosition) {\n\t\tthis.delegate.writePosition(writePosition);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic byte getByte(int index) {\n\t\treturn this.delegate.getByte(index);\n\t}\n\n\t@Override\n\tpublic byte read() {\n\t\treturn this.delegate.read();\n\t}\n\n\t@Override\n\tpublic DataBuffer read(byte[] destination) {\n\t\tthis.delegate.read(destination);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic DataBuffer read(byte[] destination, int offset, int length) {\n\t\tthis.delegate.read(destination, offset, length);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic DataBuffer write(byte b) {\n\t\tthis.delegate.write(b);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic DataBuffer write(byte[] source) {\n\t\tthis.delegate.write(source);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic DataBuffer write(byte[] source, int offset, int length) {\n\t\tthis.delegate.write(source, offset, length);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic DataBuffer write(DataBuffer... buffers) {\n\t\tthis.delegate.write(buffers);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic DataBuffer write(ByteBuffer... buffers) {\n\t\tthis.delegate.write(buffers);\n\t\treturn this;\n\t}\n\n\t@Override\n\t@Deprecated\n\tpublic DataBuffer slice(int index, int length) {\n\t\tDefaultDataBuffer delegateSlice = this.delegate.slice(index, length);\n\t\tif (this.chunk != null) {\n\t\t\tthis.chunk.retain();\n\t\t\treturn new JettyDataBuffer(this.bufferFactory, delegateSlice, this.chunk);\n\t\t}\n\t\telse {\n\t\t\treturn new JettyDataBuffer(this.bufferFactory, delegateSlice);\n\t\t}\n\t}\n\n\t@Override\n\tpublic DataBuffer split(int index) {\n\t\tDefaultDataBuffer delegateSplit = this.delegate.split(index);\n\t\tif (this.chunk != null) {\n\t\t\tthis.chunk.retain();\n\t\t\treturn new JettyDataBuffer(this.bufferFactory, delegateSplit, this.chunk);\n\t\t}\n\t\telse {\n\t\t\treturn new JettyDataBuffer(this.bufferFactory, delegateSplit);\n\t\t}\n\t}\n\n\t@Override\n\t@Deprecated\n\tpublic ByteBuffer asByteBuffer() {\n\t\treturn this.delegate.asByteBuffer();\n\t}\n\n\t@Override\n\t@Deprecated\n\tpublic ByteBuffer asByteBuffer(int index, int length) {\n\t\treturn this.delegate.asByteBuffer(index, length);\n\t}\n\n\t@Override\n\t@Deprecated\n\tpublic ByteBuffer toByteBuffer(int index, int length) {\n\t\treturn this.delegate.toByteBuffer(index, length);\n\t}\n\n\t@Override\n\tpublic void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length) {\n\t\tthis.delegate.toByteBuffer(srcPos, dest, destPos, length);\n\t}\n\n\t@Override\n\tpublic ByteBufferIterator readableByteBuffers() {\n\t\tByteBufferIterator delegateIterator = this.delegate.readableByteBuffers();\n\t\tif (this.chunk != null) {\n\t\t\treturn new JettyByteBufferIterator(delegateIterator, this.chunk);\n\t\t}\n\t\telse {\n\t\t\treturn delegateIterator;\n\t\t}\n\t}\n\n\t@Override\n\tpublic ByteBufferIterator writableByteBuffers() {\n\t\tByteBufferIterator delegateIterator = this.delegate.writableByteBuffers();\n\t\tif (this.chunk != null) {\n\t\t\treturn new JettyByteBufferIterator(delegateIterator, this.chunk);\n\t\t}\n\t\telse {\n\t\t\treturn delegateIterator;\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString(int index, int length, Charset charset) {\n\t\treturn this.delegate.toString(index, length, charset);\n\t}\n\n\n\t@Override\n\tpublic boolean equals(Object other) {\n\t\treturn (this == other || (other instanceof JettyDataBuffer otherBuffer &&\n\t\t\t\tthis.delegate.equals(otherBuffer.delegate)));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.delegate.hashCode();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn String.format(\"JettyDataBuffer (r: %d, w: %d, c: %d)\",\n\t\t\t\treadPosition(), writePosition(), capacity());\n\t}\n\n\n\tprivate static final class JettyByteBufferIterator implements ByteBufferIterator {\n\n\t\tprivate final ByteBufferIterator delegate;\n\n\t\tprivate final Content.Chunk chunk;\n\n\t\tpublic JettyByteBufferIterator(ByteBufferIterator delegate, Content.Chunk chunk) {\n\t\t\tAssert.notNull(delegate, \"Delegate must not be null\");\n\t\t\tAssert.notNull(chunk, \"Chunk must not be null\");\n\n\t\t\tthis.delegate = delegate;\n\t\t\tthis.chunk = chunk;\n\t\t\tthis.chunk.retain();\n\t\t}\n\n\t\t@Override\n\t\tpublic void close() {\n\t\t\tthis.delegate.close();\n\t\t\tthis.chunk.release();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn this.delegate.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic ByteBuffer next() {\n\t\t\treturn this.delegate.next();\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#asByteBuffer()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer asByteBuffer()",
    "source_code": "\tpublic ByteBuffer asByteBuffer() {\n\t\treturn this.delegate.asByteBuffer();\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#asByteBuffer(index,length)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer asByteBuffer(int index, int length)",
    "source_code": "\tpublic ByteBuffer asByteBuffer(int index, int length) {\n\t\treturn this.delegate.asByteBuffer(index, length);\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#capacity()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "int",
    "signature": "public int capacity()",
    "source_code": "\tpublic int capacity() {\n\t\treturn this.delegate.capacity();\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#capacity(capacity)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer capacity(int capacity)",
    "source_code": "\tpublic DataBuffer capacity(int capacity) {\n\t\tthis.delegate.capacity(capacity);\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#close()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 338
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\t\tpublic void close() {\n\t\t\tthis.delegate.close();\n\t\t\tthis.chunk.release();\n\t\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#ensureWritable(capacity)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer ensureWritable(int capacity)",
    "source_code": "\tpublic DataBuffer ensureWritable(int capacity) {\n\t\tthis.delegate.ensureWritable(capacity);\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#equals(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 305
    },
    "return": "boolean",
    "signature": "public boolean equals(Object other)",
    "source_code": "\tpublic boolean equals(Object other) {\n\t\treturn (this == other || (other instanceof JettyDataBuffer otherBuffer &&\n\t\t\t\tthis.delegate.equals(otherBuffer.delegate)));\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#factory()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "DataBufferFactory",
    "signature": "public DataBufferFactory factory()",
    "source_code": "\tpublic DataBufferFactory factory() {\n\t\treturn this.bufferFactory;\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#getByte(index)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "byte",
    "signature": "public byte getByte(int index)",
    "source_code": "\tpublic byte getByte(int index) {\n\t\treturn this.delegate.getByte(index);\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#hasNext()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 344
    },
    "return": "boolean",
    "signature": "public boolean hasNext()",
    "source_code": "\t\tpublic boolean hasNext() {\n\t\t\treturn this.delegate.hasNext();\n\t\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#hashCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 311
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.delegate.hashCode();\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#indexOf(predicate,fromIndex)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "fromIndex"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "int",
    "signature": "public int indexOf(IntPredicate predicate, int fromIndex)",
    "source_code": "\tpublic int indexOf(IntPredicate predicate, int fromIndex) {\n\t\treturn this.delegate.indexOf(predicate, fromIndex);\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#isAllocated()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "boolean",
    "signature": "public boolean isAllocated()",
    "source_code": "\tpublic boolean isAllocated() {\n\t\treturn this.refCount.get() > 0;\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#lastIndexOf(predicate,fromIndex)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "fromIndex"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "int",
    "signature": "public int lastIndexOf(IntPredicate predicate, int fromIndex)",
    "source_code": "\tpublic int lastIndexOf(IntPredicate predicate, int fromIndex) {\n\t\treturn this.delegate.lastIndexOf(predicate, fromIndex);\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#next()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 349
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer next()",
    "source_code": "\t\tpublic ByteBuffer next() {\n\t\t\treturn this.delegate.next();\n\t\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#read()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "byte",
    "signature": "public byte read()",
    "source_code": "\tpublic byte read() {\n\t\treturn this.delegate.read();\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#read(destination)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer read(byte[] destination)",
    "source_code": "\tpublic DataBuffer read(byte[] destination) {\n\t\tthis.delegate.read(destination);\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#read(destination,offset,length)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer read(byte[] destination, int offset, int length)",
    "source_code": "\tpublic DataBuffer read(byte[] destination, int offset, int length) {\n\t\tthis.delegate.read(destination, offset, length);\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#readPosition()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "int",
    "signature": "public int readPosition()",
    "source_code": "\tpublic int readPosition() {\n\t\treturn this.delegate.readPosition();\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#readPosition(readPosition)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "readPosition"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer readPosition(int readPosition)",
    "source_code": "\tpublic DataBuffer readPosition(int readPosition) {\n\t\tthis.delegate.readPosition(readPosition);\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#readableByteBuffers()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 277
    },
    "return": "ByteBufferIterator",
    "signature": "public ByteBufferIterator readableByteBuffers()",
    "source_code": "\tpublic ByteBufferIterator readableByteBuffers() {\n\t\tByteBufferIterator delegateIterator = this.delegate.readableByteBuffers();\n\t\tif (this.chunk != null) {\n\t\t\treturn new JettyByteBufferIterator(delegateIterator, this.chunk);\n\t\t}\n\t\telse {\n\t\t\treturn delegateIterator;\n\t\t}\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#readableByteCount()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "int",
    "signature": "public int readableByteCount()",
    "source_code": "\tpublic int readableByteCount() {\n\t\treturn this.delegate.readableByteCount();\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#release()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "boolean",
    "signature": "public boolean release()",
    "source_code": "\tpublic boolean release() {\n\t\tint result = this.refCount.updateAndGet(c -> {\n\t\t\tif (c != 0) {\n\t\t\t\treturn c - 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalStateException(\"JettyDataBuffer already released: \" + this);\n\t\t\t}\n\t\t});\n\t\tif (this.chunk != null) {\n\t\t\treturn this.chunk.release();\n\t\t}\n\t\telse {\n\t\t\treturn (result == 0);\n\t\t}\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#retain()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "PooledDataBuffer",
    "signature": "public PooledDataBuffer retain()",
    "source_code": "\tpublic PooledDataBuffer retain() {\n\t\tint result = this.refCount.updateAndGet(c -> (c != 0 ? c + 1 : 0));\n\t\tif (result != 0 && this.chunk != null) {\n\t\t\tthis.chunk.retain();\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#slice(index,length)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer slice(int index, int length)",
    "source_code": "\tpublic DataBuffer slice(int index, int length) {\n\t\tDefaultDataBuffer delegateSlice = this.delegate.slice(index, length);\n\t\tif (this.chunk != null) {\n\t\t\tthis.chunk.retain();\n\t\t\treturn new JettyDataBuffer(this.bufferFactory, delegateSlice, this.chunk);\n\t\t}\n\t\telse {\n\t\t\treturn new JettyDataBuffer(this.bufferFactory, delegateSlice);\n\t\t}\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#split(index)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer split(int index)",
    "source_code": "\tpublic DataBuffer split(int index) {\n\t\tDefaultDataBuffer delegateSplit = this.delegate.split(index);\n\t\tif (this.chunk != null) {\n\t\t\tthis.chunk.retain();\n\t\t\treturn new JettyDataBuffer(this.bufferFactory, delegateSplit, this.chunk);\n\t\t}\n\t\telse {\n\t\t\treturn new JettyDataBuffer(this.bufferFactory, delegateSplit);\n\t\t}\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#toByteBuffer(index,length)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer toByteBuffer(int index, int length)",
    "source_code": "\tpublic ByteBuffer toByteBuffer(int index, int length) {\n\t\treturn this.delegate.toByteBuffer(index, length);\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#toByteBuffer(srcPos,dest,destPos,length)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "srcPos",
      "dest",
      "destPos",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "void",
    "signature": "public void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length)",
    "source_code": "\tpublic void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length) {\n\t\tthis.delegate.toByteBuffer(srcPos, dest, destPos, length);\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#toString()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 316
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn String.format(\"JettyDataBuffer (r: %d, w: %d, c: %d)\",\n\t\t\t\treadPosition(), writePosition(), capacity());\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#toString(index,length,charset)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 299
    },
    "return": "String",
    "signature": "public String toString(int index, int length, Charset charset)",
    "source_code": "\tpublic String toString(int index, int length, Charset charset) {\n\t\treturn this.delegate.toString(index, length, charset);\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#touch(hint)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hint"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "PooledDataBuffer",
    "signature": "public PooledDataBuffer touch(Object hint)",
    "source_code": "\tpublic PooledDataBuffer touch(Object hint) {\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#writableByteBuffers()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "ByteBufferIterator",
    "signature": "public ByteBufferIterator writableByteBuffers()",
    "source_code": "\tpublic ByteBufferIterator writableByteBuffers() {\n\t\tByteBufferIterator delegateIterator = this.delegate.writableByteBuffers();\n\t\tif (this.chunk != null) {\n\t\t\treturn new JettyByteBufferIterator(delegateIterator, this.chunk);\n\t\t}\n\t\telse {\n\t\t\treturn delegateIterator;\n\t\t}\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#writableByteCount()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "int",
    "signature": "public int writableByteCount()",
    "source_code": "\tpublic int writableByteCount() {\n\t\treturn this.delegate.writableByteCount();\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#write(b)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer write(byte b)",
    "source_code": "\tpublic DataBuffer write(byte b) {\n\t\tthis.delegate.write(b);\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#write(buffers)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "buffers"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer write(ByteBuffer... buffers)",
    "source_code": "\tpublic DataBuffer write(ByteBuffer... buffers) {\n\t\tthis.delegate.write(buffers);\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#write(source)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer write(byte[] source)",
    "source_code": "\tpublic DataBuffer write(byte[] source) {\n\t\tthis.delegate.write(source);\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#write(source,offset,length)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer write(byte[] source, int offset, int length)",
    "source_code": "\tpublic DataBuffer write(byte[] source, int offset, int length) {\n\t\tthis.delegate.write(source, offset, length);\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#writePosition()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "int",
    "signature": "public int writePosition()",
    "source_code": "\tpublic int writePosition() {\n\t\treturn this.delegate.writePosition();\n\t}"
  },
  "org.springframework.core.io.buffer.JettyDataBuffer#writePosition(writePosition)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "writePosition"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer writePosition(int writePosition)",
    "source_code": "\tpublic DataBuffer writePosition(int writePosition) {\n\t\tthis.delegate.writePosition(writePosition);\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.support.PathMatchingResourcePatternResolver#clearCache()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Clear the local resource cache, removing all cached classpath/jar structures.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 379
    },
    "return": "void",
    "signature": "public void clearCache()",
    "source_code": "\tpublic void clearCache() {\n\t\tthis.rootDirCache.clear();\n\t\tthis.jarEntriesCache.clear();\n\t\tthis.manifestEntriesCache = null;\n\t}"
  },
  "org.springframework.core.io.support.PathMatchingResourcePatternResolver#setUseCaches(useCaches)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether this resolver should use jar caches. Default is {@code true}.\n\t * <p>Switch this flag to {@code false} in order to avoid jar caching at the\n\t * {@link JarURLConnection} level.\n\t * <p>Note that {@link JarURLConnection#setDefaultUseCaches} can be turned off\n\t * independently. This resolver-level setting is designed to only enforce\n\t * {@code JarURLConnection#setUseCaches(false)} if necessary but otherwise\n\t * leaves the JVM-level default in place.\n\t * @since 6.1.19\n\t * @see JarURLConnection#setUseCaches\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "useCaches"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "void",
    "signature": "public void setUseCaches(boolean useCaches)",
    "source_code": "\tpublic void setUseCaches(boolean useCaches) {\n\t\tthis.useCaches = useCaches;\n\t}"
  },
  "org.springframework.docs.core.aot.hints.registerreflection.<unknown>#process(order)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "order"
    ],
    "position": {
      "column": 1,
      "line": 27
    },
    "return": "void",
    "signature": "public void process(Order order)",
    "source_code": "\tpublic void process(Order order) {\n\t\t// ...\n\t}"
  },
  "org.springframework.docs.integration.jms.jmsreceivingasync.ExampleListener": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 25
    },
    "signature": "public class ExampleListener",
    "source_code": "public class ExampleListener implements MessageListener {\n\n\tpublic void onMessage(Message message) {\n\t\tif (message instanceof TextMessage textMessage) {\n\t\t\ttry {\n\t\t\t\tSystem.out.println(textMessage.getText());\n\t\t\t}\n\t\t\tcatch (JMSException ex) {\n\t\t\t\tthrow new RuntimeException(ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Message must be of type TextMessage\");\n\t\t}\n\t}\n}"
  },
  "org.springframework.docs.integration.jms.jmsreceivingasync.ExampleListener#onMessage(message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 27
    },
    "return": "void",
    "signature": "public void onMessage(Message message)",
    "source_code": "\tpublic void onMessage(Message message) {\n\t\tif (message instanceof TextMessage textMessage) {\n\t\t\ttry {\n\t\t\t\tSystem.out.println(textMessage.getText());\n\t\t\t}\n\t\t\tcatch (JMSException ex) {\n\t\t\t\tthrow new RuntimeException(ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Message must be of type TextMessage\");\n\t\t}\n\t}"
  },
  "org.springframework.docs.integration.resthttpinterface.customresolver.CustomHttpServiceArgumentResolver": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 29
    },
    "signature": "public class CustomHttpServiceArgumentResolver",
    "source_code": "public class CustomHttpServiceArgumentResolver {\n\n\t// tag::httpinterface[]\n\tpublic interface RepositoryService {\n\n\t\t@GetExchange(\"/repos/search\")\n\t\tList<Repository> searchRepository(Search search);\n\n\t}\n\t// end::httpinterface[]\n\n\tclass Sample {\n\n\t\tvoid sample() {\n\t\t\t// tag::usage[]\n\t\t\tRestClient restClient = RestClient.builder().baseUrl(\"https://api.github.com/\").build();\n\t\t\tRestClientAdapter adapter = RestClientAdapter.create(restClient);\n\t\t\tHttpServiceProxyFactory factory = HttpServiceProxyFactory\n\t\t\t\t\t.builderFor(adapter)\n\t\t\t\t\t.customArgumentResolver(new SearchQueryArgumentResolver())\n\t\t\t\t\t.build();\n\t\t\tRepositoryService repositoryService = factory.createClient(RepositoryService.class);\n\n\t\t\tSearch search = Search.create()\n\t\t\t\t\t.owner(\"spring-projects\")\n\t\t\t\t\t.language(\"java\")\n\t\t\t\t\t.query(\"rest\")\n\t\t\t\t\t.build();\n\t\t\tList<Repository> repositories = repositoryService.searchRepository(search);\n\t\t\t// end::usage[]\n\t\t}\n\n\t}\n\n\t// tag::argumentresolver[]\n\tstatic class SearchQueryArgumentResolver implements HttpServiceArgumentResolver {\n\t\t@Override\n\t\tpublic boolean resolve(Object argument, MethodParameter parameter, HttpRequestValues.Builder requestValues) {\n\t\t\tif (parameter.getParameterType().equals(Search.class)) {\n\t\t\t\tSearch search = (Search) argument;\n\t\t\t\trequestValues.addRequestParameter(\"owner\", search.owner());\n\t\t\t\trequestValues.addRequestParameter(\"language\", search.language());\n\t\t\t\trequestValues.addRequestParameter(\"query\", search.query());\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\t// end::argumentresolver[]\n\n\n\trecord Search (String query, String owner, String language) {\n\n\t\tstatic Builder create() {\n\t\t\treturn new Builder();\n\t\t}\n\n\t\tstatic class Builder {\n\n\t\t\tBuilder query(String query) { return this;}\n\n\t\t\tBuilder owner(String owner) { return this;}\n\n\t\t\tBuilder language(String language) { return this;}\n\n\t\t\tSearch build() {\n\t\t\t\treturn new Search(null, null, null);\n\t\t\t}\n\t\t}\n\n\t}\n\n\trecord Repository(String name) {\n\n\t}\n\n}"
  },
  "org.springframework.docs.integration.resthttpinterface.customresolver.CustomHttpServiceArgumentResolver#resolve(argument,parameter,requestValues)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argument",
      "parameter",
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "boolean",
    "signature": "public boolean resolve(Object argument, MethodParameter parameter, HttpRequestValues.Builder requestValues)",
    "source_code": "\t\tpublic boolean resolve(Object argument, MethodParameter parameter, HttpRequestValues.Builder requestValues) {\n\t\t\tif (parameter.getParameterType().equals(Search.class)) {\n\t\t\t\tSearch search = (Search) argument;\n\t\t\t\trequestValues.addRequestParameter(\"owner\", search.owner());\n\t\t\t\trequestValues.addRequestParameter(\"language\", search.language());\n\t\t\t\trequestValues.addRequestParameter(\"query\", search.query());\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.docs.integration.resthttpinterface.customresolver.RepositoryService": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 32
    },
    "signature": "public interface RepositoryService",
    "source_code": "\tpublic interface RepositoryService {\n\n\t\t@GetExchange(\"/repos/search\")\n\t\tList<Repository> searchRepository(Search search);\n\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#generateCodeForArgument(methodVisitor,argument,requiredType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate bytecode that loads the supplied argument onto the stack.\n\t * <p>Delegates to {@link #generateCodeForArgument(MethodVisitor, SpelNode, String)}\n\t * with the {@linkplain #toDescriptor(Class) descriptor} for\n\t * the supplied {@code requiredType}.\n\t * <p>This method also performs any boxing, unboxing, or check-casting\n\t * necessary to ensure that the type of the argument on the stack matches the\n\t * supplied {@code requiredType}.\n\t * <p>Use this method when a node in the AST will be used as an argument for\n\t * a constructor or method invocation. For example, if you wish to invoke a\n\t * method with an {@code indexNode} that must be of type {@code int} for the\n\t * actual method invocation within bytecode, you would call\n\t * {@code codeFlow.generateCodeForArgument(methodVisitor, indexNode, int.class)}.\n\t * @param methodVisitor the ASM {@link MethodVisitor} into which code should\n\t * be generated\n\t * @param argument a {@link SpelNode} that represents an argument to a method\n\t * or constructor\n\t * @param requiredType the required type for the argument when invoking the\n\t * corresponding constructor or method\n\t * @since 6.2\n\t * @see #generateCodeForArgument(MethodVisitor, SpelNode, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodVisitor",
      "argument",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "void",
    "signature": "public void generateCodeForArgument(MethodVisitor methodVisitor, SpelNode argument, Class<?> requiredType)",
    "source_code": "\tpublic void generateCodeForArgument(MethodVisitor methodVisitor, SpelNode argument, Class<?> requiredType) {\n\t\tgenerateCodeForArgument(methodVisitor, argument, toDescriptor(requiredType));\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#generateCodeForArgument(methodVisitor,argument,requiredTypeDesc)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate bytecode that loads the supplied argument onto the stack.\n\t * <p>This method also performs any boxing, unboxing, or check-casting\n\t * necessary to ensure that the type of the argument on the stack matches the\n\t * supplied {@code requiredTypeDesc}.\n\t * <p>Use this method when a node in the AST will be used as an argument for\n\t * a constructor or method invocation. For example, if you wish to invoke a\n\t * method with an {@code indexNode} that must be of type {@code int} for the\n\t * actual method invocation within bytecode, you would call\n\t * {@code codeFlow.generateCodeForArgument(methodVisitor, indexNode, \"I\")}.\n\t * @param methodVisitor the ASM {@link MethodVisitor} into which code should\n\t * be generated\n\t * @param argument a {@link SpelNode} that represents an argument to a method\n\t * or constructor\n\t * @param requiredTypeDesc a descriptor for the required type for the argument\n\t * when invoking the corresponding constructor or method\n\t * @since 6.2\n\t * @see #generateCodeForArgument(MethodVisitor, SpelNode, Class)\n\t * @see #toDescriptor(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodVisitor",
      "argument",
      "requiredTypeDesc"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "void",
    "signature": "public void generateCodeForArgument(MethodVisitor methodVisitor, SpelNode argument, String requiredTypeDesc)",
    "source_code": "\tpublic void generateCodeForArgument(MethodVisitor methodVisitor, SpelNode argument, String requiredTypeDesc) {\n\t\tenterCompilationScope();\n\t\targument.generateCode(methodVisitor, this);\n\t\tString lastDesc = lastDescriptor();\n\t\tAssert.state(lastDesc != null, \"No last descriptor\");\n\t\tboolean primitiveOnStack = isPrimitive(lastDesc);\n\t\t// Check if we need to box it.\n\t\tif (primitiveOnStack && requiredTypeDesc.charAt(0) == 'L') {\n\t\t\tinsertBoxIfNecessary(methodVisitor, lastDesc.charAt(0));\n\t\t}\n\t\t// Check if we need to unbox it.\n\t\telse if (requiredTypeDesc.length() == 1 && !primitiveOnStack) {\n\t\t\tinsertUnboxInsns(methodVisitor, requiredTypeDesc.charAt(0), lastDesc);\n\t\t}\n\t\t// Check if we need to check-cast\n\t\telse if (!requiredTypeDesc.equals(lastDesc)) {\n\t\t\t// This would be unnecessary in the case of subtyping (for example, method takes Number but Integer passed in)\n\t\t\tinsertCheckCast(methodVisitor, requiredTypeDesc);\n\t\t}\n\t\texitCompilationScope();\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#insertArrayStore(mv,arrayComponentType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Produce appropriate bytecode to store a stack item in an array.\n\t * <p>The instruction to use varies depending on whether the type is a\n\t * primitive or reference type.\n\t * @param mv where to insert the bytecode\n\t * @param arrayComponentType the component type of the array\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "arrayComponentType"
    ],
    "position": {
      "column": 1,
      "line": 908
    },
    "return": "void",
    "signature": "public void insertArrayStore(MethodVisitor mv, String arrayComponentType)",
    "source_code": "\tpublic static void insertArrayStore(MethodVisitor mv, String arrayComponentType) {\n\t\tif (arrayComponentType.length() == 1) {\n\t\t\tchar componentType = arrayComponentType.charAt(0);\n\t\t\tswitch (componentType) {\n\t\t\t\tcase 'B', 'Z' -> mv.visitInsn(BASTORE);\n\t\t\t\tcase 'I' -> mv.visitInsn(IASTORE);\n\t\t\t\tcase 'J' -> mv.visitInsn(LASTORE);\n\t\t\t\tcase 'F' -> mv.visitInsn(FASTORE);\n\t\t\t\tcase 'D' -> mv.visitInsn(DASTORE);\n\t\t\t\tcase 'C' -> mv.visitInsn(CASTORE);\n\t\t\t\tcase 'S' -> mv.visitInsn(SASTORE);\n\t\t\t\tdefault -> throw new IllegalArgumentException(\"Unexpected array component type \" + componentType);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tmv.visitInsn(AASTORE);\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#insertArrayStore(mv,arrayElementType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Produce appropriate bytecode to store a stack item in an array. The\n\t * instruction to use varies depending on whether the type\n\t * is a primitive or reference type.\n\t * @param mv where to insert the bytecode\n\t * @param arrayElementType the type of the array elements\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "arrayElementType"
    ],
    "position": {
      "column": 1,
      "line": 831
    },
    "return": "void",
    "signature": "public void insertArrayStore(MethodVisitor mv, String arrayElementType)",
    "source_code": "\tpublic static void insertArrayStore(MethodVisitor mv, String arrayElementType) {\n\t\tif (arrayElementType.length() == 1) {\n\t\t\tswitch (arrayElementType.charAt(0)) {\n\t\t\t\tcase 'B', 'Z' -> mv.visitInsn(BASTORE);\n\t\t\t\tcase 'I' -> mv.visitInsn(IASTORE);\n\t\t\t\tcase 'J' -> mv.visitInsn(LASTORE);\n\t\t\t\tcase 'F' -> mv.visitInsn(FASTORE);\n\t\t\t\tcase 'D' -> mv.visitInsn(DASTORE);\n\t\t\t\tcase 'C' -> mv.visitInsn(CASTORE);\n\t\t\t\tcase 'S' -> mv.visitInsn(SASTORE);\n\t\t\t\tdefault -> throw new IllegalArgumentException(\"Unexpected array type \" + arrayElementType.charAt(0));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tmv.visitInsn(AASTORE);\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.ast.Indexer#isNullSafe()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Does this node represent a null-safe index operation?\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "boolean",
    "signature": "public boolean isNullSafe()",
    "source_code": "\tpublic final boolean isNullSafe() {\n\t\treturn this.nullSafe;\n\t}"
  },
  "org.springframework.expression.spel.ast.SpelNodeImpl#generateCode(mv,cf)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate the bytecode for this node into the supplied visitor. Context info about\n\t * the current expression being compiled is available in the codeflow object, e.g.\n\t * including information about the type of the object currently on the stack.\n\t * @param mv the ASM MethodVisitor into which code should be generated\n\t * @param cf a context object with info about what is on the stack\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "cf"
    ],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "void",
    "signature": "public void generateCode(MethodVisitor mv, CodeFlow cf)",
    "source_code": "\tpublic void generateCode(MethodVisitor mv, CodeFlow cf) {\n\t\tthrow new IllegalStateException(getClass().getName() +\" has no generateCode(..) method\");\n\t}"
  },
  "org.springframework.expression.spel.ast.SpelNodeImpl#generateCodeForArguments(mv,cf,executable,arguments)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate code that handles building the argument values for the specified\n\t * {@link Executable} (method or constructor).\n\t * <p>This method takes into account whether the method or constructor was\n\t * declared to accept varargs, and if it was then the argument values will be\n\t * appropriately packaged into an array.\n\t * @param mv the method visitor where code should be generated\n\t * @param cf the current {@link CodeFlow}\n\t * @param executable the {@link Executable} (method or constructor) for which\n\t * arguments are being set up\n\t * @param arguments the expression nodes for the expression supplied argument\n\t * values\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mv",
      "cf",
      "executable",
      "arguments"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "void",
    "signature": "protected void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Executable executable, SpelNodeImpl[] arguments)",
    "source_code": "\tprotected static void generateCodeForArguments("
  },
  "org.springframework.expression.spel.ast.SpelNodeImpl#isCompilable()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether a node can be compiled to bytecode. The reasoning in each node may\n\t * be different but will typically involve checking whether the exit type descriptor\n\t * of the node is known and any relevant child nodes are compilable.\n\t * @return {@code true} if this node can be compiled to bytecode\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "boolean",
    "signature": "public boolean isCompilable()",
    "source_code": "\tpublic boolean isCompilable() {\n\t\treturn false;\n\t}"
  },
  "org.springframework.expression.spel.support.OptimalPropertyAccessor": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An optimized form of a PropertyAccessor that will use reflection but only knows\n\t * how to access a particular property on a particular class. This is unlike the\n\t * general ReflectivePropertyResolver which manages a cache of methods/fields that\n\t * may be invoked to access different properties on different classes. This optimal\n\t * accessor exists because looking up the appropriate reflective object by class/name\n\t * on each read is not cheap.\n\t */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 635
    },
    "signature": "public class OptimalPropertyAccessor",
    "source_code": "\tpublic static class OptimalPropertyAccessor implements CompilablePropertyAccessor {\n\n\t\t/**\n\t\t * The member being accessed.\n\t\t */\n\t\tpublic final Member member;\n\n\t\tprivate final TypeDescriptor typeDescriptor;\n\n\t\tOptimalPropertyAccessor(InvokerPair target) {\n\t\t\tthis.member = target.member;\n\t\t\tthis.typeDescriptor = target.typeDescriptor;\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Class<?>[] getSpecificTargetClasses() {\n\t\t\tthrow new UnsupportedOperationException(\"Should not be called on an OptimalPropertyAccessor\");\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean canRead(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\t\tif (target == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tClass<?> type = (target instanceof Class<?> clazz ? clazz : target.getClass());\n\t\t\tif (type.isArray()) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (this.member instanceof Method method) {\n\t\t\t\tString getterName = \"get\" + StringUtils.capitalize(name);\n\t\t\t\tif (getterName.equals(method.getName())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tgetterName = \"is\" + StringUtils.capitalize(name);\n\t\t\t\tif (getterName.equals(method.getName())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.member.getName().equals(name);\n\t\t}\n\n\t\t@Override\n\t\tpublic TypedValue read(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\t\tif (this.member instanceof Method method) {\n\t\t\t\ttry {\n\t\t\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\t\t\tObject value = method.invoke(target);\n\t\t\t\t\treturn new TypedValue(value, this.typeDescriptor.narrow(value));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new AccessException(\"Unable to access property '\" + name + \"' through getter method\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tField field = (Field) this.member;\n\t\t\t\ttry {\n\t\t\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\t\t\tObject value = field.get(target);\n\t\t\t\t\treturn new TypedValue(value, this.typeDescriptor.narrow(value));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new AccessException(\"Unable to access field '\" + name + \"'\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean canWrite(EvaluationContext context, @Nullable Object target, String name) {\n\t\t\tthrow new UnsupportedOperationException(\"Should not be called on an OptimalPropertyAccessor\");\n\t\t}\n\n\t\t@Override\n\t\tpublic void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object newValue) {\n\t\t\tthrow new UnsupportedOperationException(\"Should not be called on an OptimalPropertyAccessor\");\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isCompilable() {\n\t\t\treturn (Modifier.isPublic(this.member.getModifiers()) &&\n\t\t\t\t\tModifier.isPublic(this.member.getDeclaringClass().getModifiers()));\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<?> getPropertyType() {\n\t\t\tif (this.member instanceof Method method) {\n\t\t\t\treturn method.getReturnType();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn ((Field) this.member).getType();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void generateCode(String propertyName, MethodVisitor mv, CodeFlow cf) {\n\t\t\tboolean isStatic = Modifier.isStatic(this.member.getModifiers());\n\t\t\tString descriptor = cf.lastDescriptor();\n\t\t\tString classDesc = this.member.getDeclaringClass().getName().replace('.', '/');\n\n\t\t\tif (!isStatic) {\n\t\t\t\tif (descriptor == null) {\n\t\t\t\t\tcf.loadTarget(mv);\n\t\t\t\t}\n\t\t\t\tif (descriptor == null || !classDesc.equals(descriptor.substring(1))) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, classDesc);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (descriptor != null) {\n\t\t\t\t\t// A static field/method call will not consume what is on the stack,\n\t\t\t\t\t// it needs to be popped off.\n\t\t\t\t\tmv.visitInsn(POP);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.member instanceof Method method) {\n\t\t\t\tboolean isInterface = method.getDeclaringClass().isInterface();\n\t\t\t\tint opcode = (isStatic ? INVOKESTATIC : isInterface ? INVOKEINTERFACE : INVOKEVIRTUAL);\n\t\t\t\tmv.visitMethodInsn(opcode, classDesc, method.getName(),\n\t\t\t\t\t\tCodeFlow.createSignatureDescriptor(method), isInterface);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmv.visitFieldInsn((isStatic ? GETSTATIC : GETFIELD), classDesc, this.member.getName(),\n\t\t\t\t\t\tCodeFlow.toJvmDescriptor(((Field) this.member).getType()));\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.support.ReflectionHelper": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Utility methods used by the reflection resolver code to discover the appropriate\n * methods/constructors and fields that should be used in expressions.\n *\n * @author Andy Clement\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 3.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public class ReflectionHelper",
    "source_code": "public abstract class ReflectionHelper {\n\n\t/**\n\t * Compare argument arrays and return information about whether they match.\n\t * <p>The supplied type converter allows for matches to take into account that a type\n\t * may be transformed into a different type by the converter.\n\t * @param expectedArgTypes the types the method/constructor is expecting\n\t * @param suppliedArgTypes the types that are being supplied at the point of invocation\n\t * @param typeConverter a registered type converter\n\t * @return an {@code ArgumentsMatchInfo} object indicating what kind of match it was,\n\t * or {@code null} if it was not a match\n\t */\n\t@Nullable\n\tstatic ArgumentsMatchInfo compareArguments(\n\t\t\tList<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {\n\n\t\tAssert.isTrue(expectedArgTypes.size() == suppliedArgTypes.size(),\n\t\t\t\t\"Expected argument types and supplied argument types should be lists of the same size\");\n\n\t\tArgumentsMatchKind match = ArgumentsMatchKind.EXACT;\n\t\tfor (int i = 0; i < expectedArgTypes.size() && match != null; i++) {\n\t\t\tTypeDescriptor suppliedArg = suppliedArgTypes.get(i);\n\t\t\tTypeDescriptor expectedArg = expectedArgTypes.get(i);\n\t\t\t// The user may supply null - and that will be ok unless a primitive is expected\n\t\t\tif (suppliedArg == null) {\n\t\t\t\tif (expectedArg.isPrimitive()) {\n\t\t\t\t\tmatch = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!expectedArg.equals(suppliedArg)) {\n\t\t\t\tif (suppliedArg.isAssignableTo(expectedArg)) {\n\t\t\t\t\tif (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {\n\t\t\t\t\t\tmatch = ArgumentsMatchKind.CLOSE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (typeConverter.canConvert(suppliedArg, expectedArg)) {\n\t\t\t\t\tmatch = ArgumentsMatchKind.REQUIRES_CONVERSION;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmatch = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (match != null ? new ArgumentsMatchInfo(match) : null);\n\t}\n\n\t/**\n\t * Based on {@link MethodInvoker#getTypeDifferenceWeight(Class[], Object[])} but operates on TypeDescriptors.\n\t */\n\tpublic static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {\n\t\tint result = 0;\n\t\tfor (int i = 0; i < paramTypes.size(); i++) {\n\t\t\tTypeDescriptor paramType = paramTypes.get(i);\n\t\t\tTypeDescriptor argType = (i < argTypes.size() ? argTypes.get(i) : null);\n\t\t\tif (argType == null) {\n\t\t\t\tif (paramType.isPrimitive()) {\n\t\t\t\t\treturn Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tClass<?> paramTypeClazz = paramType.getType();\n\t\t\t\tif (!ClassUtils.isAssignable(paramTypeClazz, argType.getType())) {\n\t\t\t\t\treturn Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t\tif (paramTypeClazz.isPrimitive()) {\n\t\t\t\t\tparamTypeClazz = Object.class;\n\t\t\t\t}\n\t\t\t\tClass<?> superClass = argType.getType().getSuperclass();\n\t\t\t\twhile (superClass != null) {\n\t\t\t\t\tif (paramTypeClazz.equals(superClass)) {\n\t\t\t\t\t\tresult = result + 2;\n\t\t\t\t\t\tsuperClass = null;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {\n\t\t\t\t\t\tresult = result + 2;\n\t\t\t\t\t\tsuperClass = superClass.getSuperclass();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsuperClass = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (paramTypeClazz.isInterface()) {\n\t\t\t\t\tresult = result + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Compare argument arrays and return information about whether they match.\n\t * <p>The supplied type converter allows for matches to take into account that a type\n\t * may be transformed into a different type by the converter.\n\t * <p>This variant of {@link #compareArguments(List, List, TypeConverter)} also allows\n\t * for a varargs match.\n\t * @param expectedArgTypes the types the method/constructor is expecting\n\t * @param suppliedArgTypes the types that are being supplied at the point of invocation\n\t * @param typeConverter a registered type converter\n\t * @return an {@code ArgumentsMatchInfo} object indicating what kind of match it was,\n\t * or {@code null} if it was not a match\n\t */\n\t@Nullable\n\tstatic ArgumentsMatchInfo compareArgumentsVarargs(\n\t\t\tList<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {\n\n\t\tAssert.isTrue(!CollectionUtils.isEmpty(expectedArgTypes),\n\t\t\t\t\"Expected arguments must at least include one array (the varargs parameter)\");\n\t\tAssert.isTrue(expectedArgTypes.get(expectedArgTypes.size() - 1).isArray(),\n\t\t\t\t\"Final expected argument should be array type (the varargs parameter)\");\n\n\t\tArgumentsMatchKind match = ArgumentsMatchKind.EXACT;\n\n\t\t// Check up until the varargs argument:\n\n\t\t// Deal with the arguments up to 'expected number' - 1 (that is everything but the varargs argument)\n\t\tint argCountUpToVarargs = expectedArgTypes.size() - 1;\n\t\tfor (int i = 0; i < argCountUpToVarargs && match != null; i++) {\n\t\t\tTypeDescriptor suppliedArg = suppliedArgTypes.get(i);\n\t\t\tTypeDescriptor expectedArg = expectedArgTypes.get(i);\n\t\t\tif (suppliedArg == null) {\n\t\t\t\tif (expectedArg.isPrimitive()) {\n\t\t\t\t\tmatch = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!expectedArg.equals(suppliedArg)) {\n\t\t\t\t\tif (suppliedArg.isAssignableTo(expectedArg)) {\n\t\t\t\t\t\tif (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {\n\t\t\t\t\t\t\tmatch = ArgumentsMatchKind.CLOSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (typeConverter.canConvert(suppliedArg, expectedArg)) {\n\t\t\t\t\t\tmatch = ArgumentsMatchKind.REQUIRES_CONVERSION;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmatch = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If already confirmed it cannot be a match, then return\n\t\tif (match == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (suppliedArgTypes.size() == expectedArgTypes.size() &&\n\t\t\t\texpectedArgTypes.get(expectedArgTypes.size() - 1).equals(\n\t\t\t\t\t\tsuppliedArgTypes.get(suppliedArgTypes.size() - 1))) {\n\t\t\t// Special case: there is one parameter left and it is an array and it matches the varargs\n\t\t\t// expected argument - that is a match, the caller has already built the array. Proceed with it.\n\t\t}\n\t\telse {\n\t\t\t// Now... we have the final argument in the method we are checking as a match and we have 0\n\t\t\t// or more other arguments left to pass to it.\n\t\t\tTypeDescriptor varargsDesc = expectedArgTypes.get(expectedArgTypes.size() - 1);\n\t\t\tTypeDescriptor componentTypeDesc = varargsDesc.getElementTypeDescriptor();\n\t\t\tAssert.state(componentTypeDesc != null, \"Component type must not be null for a varargs array\");\n\t\t\tClass<?> varargsComponentType = componentTypeDesc.getType();\n\n\t\t\t// All remaining parameters must be of this type or convertible to this type\n\t\t\tfor (int i = expectedArgTypes.size() - 1; i < suppliedArgTypes.size(); i++) {\n\t\t\t\tTypeDescriptor suppliedArg = suppliedArgTypes.get(i);\n\t\t\t\tif (suppliedArg == null) {\n\t\t\t\t\tif (varargsComponentType.isPrimitive()) {\n\t\t\t\t\t\tmatch = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (varargsComponentType != suppliedArg.getType()) {\n\t\t\t\t\t\tif (ClassUtils.isAssignable(varargsComponentType, suppliedArg.getType())) {\n\t\t\t\t\t\t\tif (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {\n\t\t\t\t\t\t\t\tmatch = ArgumentsMatchKind.CLOSE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (typeConverter.canConvert(suppliedArg, TypeDescriptor.valueOf(varargsComponentType))) {\n\t\t\t\t\t\t\tmatch = ArgumentsMatchKind.REQUIRES_CONVERSION;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tmatch = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (match != null ? new ArgumentsMatchInfo(match) : null);\n\t}\n\n\n\t/**\n\t * Convert the supplied set of arguments into the parameter types of the supplied\n\t * {@link Method}.\n\t * <p>If the supplied method is a varargs method, the final parameter type must be an\n\t * array whose component type should be used as the conversion target for extraneous\n\t * arguments. For example, if the parameter types are <code>{Integer, String[]}</code>\n\t * and the input arguments are <code>{Integer, boolean, float}</code>, then both the\n\t * {@code boolean} and the {@code float} must be converted to strings.\n\t * <p>This method does <strong>not</strong> repackage the arguments into a form suitable\n\t * for the varargs invocation: a subsequent call to\n\t * {@link #setupArgumentsForVarargsInvocation(Class[], Object...)} is required for that.\n\t * @param converter the converter to use for type conversions\n\t * @param arguments the arguments to convert to the required parameter types\n\t * @param method the target {@code Method}\n\t * @return {@code true} if some kind of conversion occurred on an argument\n\t * @throws SpelEvaluationException if a problem occurs during conversion\n\t */\n\tpublic static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method)\n\t\t\tthrows SpelEvaluationException {\n\n\t\tInteger varargsPosition = (method.isVarArgs() ? method.getParameterCount() - 1 : null);\n\t\treturn convertArguments(converter, arguments, method, varargsPosition);\n\t}\n\n\t/**\n\t * Convert the supplied set of arguments into the parameter types of the supplied\n\t * {@link Executable}, taking the varargs position into account.\n\t * <p>The arguments are converted 'in-place' in the input array.\n\t * @param converter the converter to use for type conversions\n\t * @param arguments the arguments to convert to the required parameter types\n\t * @param executable the target {@code Method} or {@code Constructor}\n\t * @param varargsPosition the known position of the varargs argument, if any\n\t * ({@code null} if not varargs)\n\t * @return {@code true} if some kind of conversion occurred on an argument\n\t * @throws EvaluationException if a problem occurs during conversion\n\t */\n\tstatic boolean convertArguments(TypeConverter converter, Object[] arguments, Executable executable,\n\t\t\t@Nullable Integer varargsPosition) throws EvaluationException {\n\n\t\tboolean conversionOccurred = false;\n\t\tif (varargsPosition == null) {\n\t\t\tfor (int i = 0; i < arguments.length; i++) {\n\t\t\t\tTypeDescriptor targetType = new TypeDescriptor(MethodParameter.forExecutable(executable, i));\n\t\t\t\tObject argument = arguments[i];\n\t\t\t\tTypeDescriptor sourceType = TypeDescriptor.forObject(argument);\n\t\t\t\targuments[i] = converter.convertValue(argument, sourceType, targetType);\n\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Convert everything up to the varargs position\n\t\t\tfor (int i = 0; i < varargsPosition; i++) {\n\t\t\t\tTypeDescriptor targetType = new TypeDescriptor(MethodParameter.forExecutable(executable, i));\n\t\t\t\tObject argument = arguments[i];\n\t\t\t\tTypeDescriptor sourceType = TypeDescriptor.forObject(argument);\n\t\t\t\targuments[i] = converter.convertValue(argument, sourceType, targetType);\n\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t\t}\n\n\t\t\tMethodParameter methodParam = MethodParameter.forExecutable(executable, varargsPosition);\n\t\t\tTypeDescriptor targetType = new TypeDescriptor(methodParam);\n\t\t\tTypeDescriptor componentTypeDesc = targetType.getElementTypeDescriptor();\n\t\t\tAssert.state(componentTypeDesc != null, \"Component type must not be null for a varargs array\");\n\n\t\t\t// If the target is varargs and there is just one more argument, then convert it here.\n\t\t\tif (varargsPosition == arguments.length - 1) {\n\t\t\t\tObject argument = arguments[varargsPosition];\n\t\t\t\tTypeDescriptor sourceType = TypeDescriptor.forObject(argument);\n\t\t\t\tif (argument == null) {\n\t\t\t\t\t// Perform the equivalent of GenericConversionService.convertNullSource() for a single argument.\n\t\t\t\t\tif (componentTypeDesc.getObjectType() == Optional.class) {\n\t\t\t\t\t\targuments[varargsPosition] = Optional.empty();\n\t\t\t\t\t\tconversionOccurred = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// If the argument type is assignable to the varargs component type, there is no need to\n\t\t\t\t// convert it or wrap it in an array. For example, using StringToArrayConverter to convert\n\t\t\t\t// a String containing a comma would result in the String being split and repackaged in an\n\t\t\t\t// array when it should be used as-is. Similarly, if the argument is an array that is\n\t\t\t\t// assignable to the varargs array type, there is no need to convert it. However, if the\n\t\t\t\t// argument is a java.util.List, we let the TypeConverter convert the list to an array.\n\t\t\t\telse if (!sourceType.isAssignableTo(componentTypeDesc) ||\n\t\t\t\t\t\t(sourceType.isArray() && !sourceType.isAssignableTo(targetType)) ||\n\t\t\t\t\t\t(argument instanceof List)) {\n\n\t\t\t\t\tTypeDescriptor targetTypeToUse =\n\t\t\t\t\t\t\t(sourceType.isArray() || argument instanceof List ? targetType : componentTypeDesc);\n\t\t\t\t\targuments[varargsPosition] = converter.convertValue(argument, sourceType, targetTypeToUse);\n\t\t\t\t}\n\t\t\t\t// Possible outcomes of the above if-else block:\n\t\t\t\t// 1) the input argument was null, and nothing was done.\n\t\t\t\t// 2) the input argument was null; the varargs component type is Optional; and the argument was converted to Optional.empty().\n\t\t\t\t// 3) the input argument was the correct type but not wrapped in an array, and nothing was done.\n\t\t\t\t// 4) the input argument was already compatible (i.e., array of valid type), and nothing was done.\n\t\t\t\t// 5) the input argument was the wrong type and got converted and wrapped in an array.\n\t\t\t\tif (argument != arguments[varargsPosition] &&\n\t\t\t\t\t\t!isFirstEntryInArray(argument, arguments[varargsPosition])) {\n\t\t\t\t\tconversionOccurred = true; // case 5\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Otherwise, convert remaining arguments to the varargs component type.\n\t\t\telse {\n\t\t\t\tfor (int i = varargsPosition; i < arguments.length; i++) {\n\t\t\t\t\tObject argument = arguments[i];\n\t\t\t\t\tTypeDescriptor sourceType = TypeDescriptor.forObject(argument);\n\t\t\t\t\targuments[i] = converter.convertValue(argument, sourceType, componentTypeDesc);\n\t\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn conversionOccurred;\n\t}\n\n\t/**\n\t * Convert the supplied set of arguments into the parameter types of the supplied\n\t * {@link MethodHandle}, taking the varargs position into account.\n\t * <p>The arguments are converted 'in-place' in the input array.\n\t * @param converter the converter to use for type conversions\n\t * @param arguments the arguments to convert to the required parameter types\n\t * @param methodHandle the target {@code MethodHandle}\n\t * @param varargsPosition the known position of the varargs argument, if any\n\t * ({@code null} if not varargs)\n\t * @return {@code true} if some kind of conversion occurred on an argument\n\t * @throws EvaluationException if a problem occurs during conversion\n\t * @since 6.1\n\t */\n\tpublic static boolean convertAllMethodHandleArguments(TypeConverter converter, Object[] arguments,\n\t\t\tMethodHandle methodHandle, @Nullable Integer varargsPosition) throws EvaluationException {\n\n\t\tboolean conversionOccurred = false;\n\t\tMethodType methodHandleType = methodHandle.type();\n\t\tif (varargsPosition == null) {\n\t\t\tfor (int i = 0; i < arguments.length; i++) {\n\t\t\t\tClass<?> argumentClass = methodHandleType.parameterType(i);\n\t\t\t\tResolvableType resolvableType = ResolvableType.forClass(argumentClass);\n\t\t\t\tTypeDescriptor targetType = new TypeDescriptor(resolvableType, argumentClass, null);\n\n\t\t\t\tObject argument = arguments[i];\n\t\t\t\tTypeDescriptor sourceType = TypeDescriptor.forObject(argument);\n\t\t\t\targuments[i] = converter.convertValue(argument, sourceType, targetType);\n\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Convert everything up to the varargs position\n\t\t\tfor (int i = 0; i < varargsPosition; i++) {\n\t\t\t\tClass<?> argumentClass = methodHandleType.parameterType(i);\n\t\t\t\tResolvableType resolvableType = ResolvableType.forClass(argumentClass);\n\t\t\t\tTypeDescriptor targetType = new TypeDescriptor(resolvableType, argumentClass, null);\n\n\t\t\t\tObject argument = arguments[i];\n\t\t\t\tTypeDescriptor sourceType = TypeDescriptor.forObject(argument);\n\t\t\t\targuments[i] = converter.convertValue(argument, sourceType, targetType);\n\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t\t}\n\n\t\t\tClass<?> varargsArrayClass = methodHandleType.lastParameterType();\n\t\t\t// We use the wrapper type for a primitive varargs array, since we eventually\n\t\t\t// need an Object array in order to invoke the MethodHandle in\n\t\t\t// FunctionReference#executeFunctionViaMethodHandle().\n\t\t\tClass<?> varargsComponentClass = ClassUtils.resolvePrimitiveIfNecessary(varargsArrayClass.componentType());\n\t\t\tTypeDescriptor varargsArrayType = TypeDescriptor.array(TypeDescriptor.valueOf(varargsComponentClass));\n\t\t\tAssert.state(varargsArrayType != null, \"Array type must not be null for a varargs array\");\n\t\t\tTypeDescriptor varargsComponentType = varargsArrayType.getElementTypeDescriptor();\n\t\t\tAssert.state(varargsComponentType != null, \"Component type must not be null for a varargs array\");\n\n\t\t\t// If the target is varargs and there is just one more argument, then convert it here.\n\t\t\tif (varargsPosition == arguments.length - 1) {\n\t\t\t\tObject argument = arguments[varargsPosition];\n\t\t\t\tTypeDescriptor sourceType = TypeDescriptor.forObject(argument);\n\t\t\t\tif (argument == null) {\n\t\t\t\t\t// Perform the equivalent of GenericConversionService.convertNullSource() for a single argument.\n\t\t\t\t\tif (varargsComponentType.getObjectType() == Optional.class) {\n\t\t\t\t\t\targuments[varargsPosition] = Optional.empty();\n\t\t\t\t\t\tconversionOccurred = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// If the argument type is assignable to the varargs component type, there is no need to\n\t\t\t\t// convert it. For example, using StringToArrayConverter to convert a String containing a\n\t\t\t\t// comma would result in the String being split and repackaged in an array when it should\n\t\t\t\t// be used as-is. Similarly, if the argument is an array that is assignable to the varargs\n\t\t\t\t// array type, there is no need to convert it. However, if the argument is a java.util.List,\n\t\t\t\t// we let the TypeConverter convert the list to an array.\n\t\t\t\telse if (!sourceType.isAssignableTo(varargsComponentType) ||\n\t\t\t\t\t\t(sourceType.isArray() && !sourceType.isAssignableTo(varargsArrayType)) ||\n\t\t\t\t\t\t(argument instanceof List)) {\n\n\t\t\t\t\tTypeDescriptor targetTypeToUse =\n\t\t\t\t\t\t\t(sourceType.isArray() || argument instanceof List ? varargsArrayType : varargsComponentType);\n\t\t\t\t\targuments[varargsPosition] = converter.convertValue(argument, sourceType, targetTypeToUse);\n\t\t\t\t}\n\t\t\t\t// Possible outcomes of the above if-else block:\n\t\t\t\t// 1) the input argument was null, and nothing was done.\n\t\t\t\t// 2) the input argument was null; the varargs component type is Optional; and the argument was converted to Optional.empty().\n\t\t\t\t// 3) the input argument was the correct type but not wrapped in an array, and nothing was done.\n\t\t\t\t// 4) the input argument was already compatible (i.e., an Object array of valid type), and nothing was done.\n\t\t\t\t// 5) the input argument was the wrong type and got converted as explained in the comments above.\n\t\t\t\tif (argument != arguments[varargsPosition] &&\n\t\t\t\t\t\t!isFirstEntryInArray(argument, arguments[varargsPosition])) {\n\t\t\t\t\tconversionOccurred = true; // case 5\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Otherwise, convert remaining arguments to the varargs component type.\n\t\t\telse {\n\t\t\t\tfor (int i = varargsPosition; i < arguments.length; i++) {\n\t\t\t\t\tObject argument = arguments[i];\n\t\t\t\t\tTypeDescriptor sourceType = TypeDescriptor.forObject(argument);\n\t\t\t\t\targuments[i] = converter.convertValue(argument, sourceType, varargsComponentType);\n\t\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn conversionOccurred;\n\t}\n\n\t/**\n\t * Check if the supplied value is the first entry in the array represented by the possibleArray value.\n\t * @param value the value to check for in the array\n\t * @param possibleArray an array object that may have the supplied value as the first element\n\t * @return true if the supplied value is the first entry in the array\n\t */\n\tprivate static boolean isFirstEntryInArray(Object value, @Nullable Object possibleArray) {\n\t\tif (possibleArray == null) {\n\t\t\treturn false;\n\t\t}\n\t\tClass<?> type = possibleArray.getClass();\n\t\tif (!type.isArray() || Array.getLength(possibleArray) == 0 ||\n\t\t\t\t!ClassUtils.isAssignableValue(type.componentType(), value)) {\n\t\t\treturn false;\n\t\t}\n\t\tObject arrayValue = Array.get(possibleArray, 0);\n\t\treturn (type.componentType().isPrimitive() ? arrayValue.equals(value) : arrayValue == value);\n\t}\n\n\t/**\n\t * Package up the supplied {@code args} so that they correctly match what is\n\t * expected in {@code requiredParameterTypes}.\n\t * <p>For example, if {@code requiredParameterTypes} is {@code (int, String[])}\n\t * because the second parameter was declared as {@code String...}, then if\n\t * {@code args} is {@code [1, \"a\", \"b\"]} it must be repackaged as\n\t * {@code [1, new String[] {\"a\", \"b\"}]} in order to match the expected types.\n\t * @param requiredParameterTypes the types of the parameters for the invocation\n\t * @param args the arguments to be set up for the invocation\n\t * @return a repackaged array of arguments where any varargs setup has been performed\n\t */\n\tpublic static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args) {\n\t\tAssert.notEmpty(requiredParameterTypes, \"Required parameter types array must not be empty\");\n\n\t\tint parameterCount = requiredParameterTypes.length;\n\t\tClass<?> lastRequiredParameterType = requiredParameterTypes[parameterCount - 1];\n\t\tAssert.isTrue(lastRequiredParameterType.isArray(),\n\t\t\t\t\"The last required parameter type must be an array to support varargs invocation\");\n\n\t\tint argumentCount = args.length;\n\t\tObject lastArgument = (argumentCount > 0 ? args[argumentCount - 1] : null);\n\n\t\t// Check if repackaging is needed...\n\t\tif (parameterCount != argumentCount || !lastRequiredParameterType.isInstance(lastArgument)) {\n\t\t\t// Create an array for the leading arguments plus the varargs array argument.\n\t\t\tObject[] newArgs = new Object[parameterCount];\n\t\t\t// Copy all leading arguments to the new array, omitting the varargs array argument.\n\t\t\tSystem.arraycopy(args, 0, newArgs, 0, newArgs.length - 1);\n\n\t\t\t// Now sort out the final argument, which is the varargs one. Before entering this method,\n\t\t\t// the arguments should have been converted to the box form of the required type.\n\t\t\tint varargsArraySize = 0;  // zero size array if nothing to pass as the varargs parameter\n\t\t\tif (argumentCount >= parameterCount) {\n\t\t\t\tvarargsArraySize = argumentCount - (parameterCount - 1);\n\t\t\t}\n\t\t\tClass<?> componentType = lastRequiredParameterType.componentType();\n\t\t\tObject varargsArray = Array.newInstance(componentType, varargsArraySize);\n\t\t\tfor (int i = 0; i < varargsArraySize; i++) {\n\t\t\t\tArray.set(varargsArray, i, args[parameterCount - 1 + i]);\n\t\t\t}\n\t\t\t// Finally, add the varargs array to the new arguments array.\n\t\t\tnewArgs[newArgs.length - 1] = varargsArray;\n\t\t\treturn newArgs;\n\t\t}\n\n\t\treturn args;\n\t}\n\n\n\t/**\n\t * Arguments match kinds.\n\t */\n\tenum ArgumentsMatchKind {\n\n\t\t/** An exact match is where the parameter types exactly match what the method/constructor is expecting. */\n\t\tEXACT,\n\n\t\t/** A close match is where the parameter types either exactly match or are assignment-compatible. */\n\t\tCLOSE,\n\n\t\t/** A conversion match is where the type converter must be used to transform some of the parameter types. */\n\t\tREQUIRES_CONVERSION\n\t}\n\n\n\t/**\n\t * An instance of {@code ArgumentsMatchInfo} describes what kind of match was achieved\n\t * between two sets of arguments - the set that a method/constructor is expecting\n\t * and the set that is being supplied at the point of invocation.\n\t *\n\t * @param kind the kind of match that was achieved\n\t */\n\trecord ArgumentsMatchInfo(ArgumentsMatchKind kind) {\n\n\t\tpublic boolean isExactMatch() {\n\t\t\treturn (this.kind == ArgumentsMatchKind.EXACT);\n\t\t}\n\n\t\tpublic boolean isCloseMatch() {\n\t\t\treturn (this.kind == ArgumentsMatchKind.CLOSE);\n\t\t}\n\n\t\tpublic boolean isMatchRequiringConversion() {\n\t\t\treturn (this.kind == ArgumentsMatchKind.REQUIRES_CONVERSION);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"ArgumentsMatchInfo: \" + this.kind;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.expression.spel.support.ReflectionHelper#convertAllArguments(converter,arguments,method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the supplied set of arguments into the parameter types of the supplied\n\t * {@link Method}.\n\t * <p>If the supplied method is a varargs method, the final parameter type must be an\n\t * array whose component type should be used as the conversion target for extraneous\n\t * arguments. For example, if the parameter types are <code>{Integer, String[]}</code>\n\t * and the input arguments are <code>{Integer, boolean, float}</code>, then both the\n\t * {@code boolean} and the {@code float} must be converted to strings.\n\t * <p>This method does <strong>not</strong> repackage the arguments into a form suitable\n\t * for the varargs invocation: a subsequent call to\n\t * {@link #setupArgumentsForVarargsInvocation(Class[], Object...)} is required for that.\n\t * @param converter the converter to use for type conversions\n\t * @param arguments the arguments to convert to the required parameter types\n\t * @param method the target {@code Method}\n\t * @return {@code true} if some kind of conversion occurred on an argument\n\t * @throws SpelEvaluationException if a problem occurs during conversion\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "converter",
      "arguments",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "boolean",
    "signature": "public boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method)",
    "source_code": "\tpublic static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method)"
  },
  "org.springframework.expression.spel.support.ReflectionHelper#convertAllMethodHandleArguments(converter,arguments,methodHandle,varargsPosition)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the supplied set of arguments into the parameter types of the supplied\n\t * {@link MethodHandle}, taking the varargs position into account.\n\t * <p>The arguments are converted 'in-place' in the input array.\n\t * @param converter the converter to use for type conversions\n\t * @param arguments the arguments to convert to the required parameter types\n\t * @param methodHandle the target {@code MethodHandle}\n\t * @param varargsPosition the known position of the varargs argument, if any\n\t * ({@code null} if not varargs)\n\t * @return {@code true} if some kind of conversion occurred on an argument\n\t * @throws EvaluationException if a problem occurs during conversion\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "converter",
      "arguments",
      "methodHandle",
      "varargsPosition"
    ],
    "position": {
      "column": 1,
      "line": 364
    },
    "return": "boolean",
    "signature": "public boolean convertAllMethodHandleArguments(TypeConverter converter, Object[] arguments,\n\t\t\tMethodHandle methodHandle, @Nullable Integer varargsPosition)",
    "source_code": "\tpublic static boolean convertAllMethodHandleArguments(TypeConverter converter, Object[] arguments,"
  },
  "org.springframework.expression.spel.support.ReflectionHelper#getTypeDifferenceWeight(paramTypes,argTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Based on {@link MethodInvoker#getTypeDifferenceWeight(Class[], Object[])} but operates on TypeDescriptors.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramTypes",
      "argTypes"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "int",
    "signature": "public int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes)",
    "source_code": "\tpublic static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {\n\t\tint result = 0;\n\t\tfor (int i = 0; i < paramTypes.size(); i++) {\n\t\t\tTypeDescriptor paramType = paramTypes.get(i);\n\t\t\tTypeDescriptor argType = (i < argTypes.size() ? argTypes.get(i) : null);\n\t\t\tif (argType == null) {\n\t\t\t\tif (paramType.isPrimitive()) {\n\t\t\t\t\treturn Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tClass<?> paramTypeClazz = paramType.getType();\n\t\t\t\tif (!ClassUtils.isAssignable(paramTypeClazz, argType.getType())) {\n\t\t\t\t\treturn Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t\tif (paramTypeClazz.isPrimitive()) {\n\t\t\t\t\tparamTypeClazz = Object.class;\n\t\t\t\t}\n\t\t\t\tClass<?> superClass = argType.getType().getSuperclass();\n\t\t\t\twhile (superClass != null) {\n\t\t\t\t\tif (paramTypeClazz.equals(superClass)) {\n\t\t\t\t\t\tresult = result + 2;\n\t\t\t\t\t\tsuperClass = null;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {\n\t\t\t\t\t\tresult = result + 2;\n\t\t\t\t\t\tsuperClass = superClass.getSuperclass();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsuperClass = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (paramTypeClazz.isInterface()) {\n\t\t\t\t\tresult = result + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.expression.spel.support.ReflectionHelper#isCloseMatch()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 550
    },
    "return": "boolean",
    "signature": "public boolean isCloseMatch()",
    "source_code": "\t\tpublic boolean isCloseMatch() {\n\t\t\treturn (this.kind == ArgumentsMatchKind.CLOSE);\n\t\t}"
  },
  "org.springframework.expression.spel.support.ReflectionHelper#isExactMatch()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 546
    },
    "return": "boolean",
    "signature": "public boolean isExactMatch()",
    "source_code": "\t\tpublic boolean isExactMatch() {\n\t\t\treturn (this.kind == ArgumentsMatchKind.EXACT);\n\t\t}"
  },
  "org.springframework.expression.spel.support.ReflectionHelper#isMatchRequiringConversion()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 554
    },
    "return": "boolean",
    "signature": "public boolean isMatchRequiringConversion()",
    "source_code": "\t\tpublic boolean isMatchRequiringConversion() {\n\t\t\treturn (this.kind == ArgumentsMatchKind.REQUIRES_CONVERSION);\n\t\t}"
  },
  "org.springframework.expression.spel.support.ReflectionHelper#setupArgumentsForVarargsInvocation(requiredParameterTypes,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Package up the supplied {@code args} so that they correctly match what is\n\t * expected in {@code requiredParameterTypes}.\n\t * <p>For example, if {@code requiredParameterTypes} is {@code (int, String[])}\n\t * because the second parameter was declared as {@code String...}, then if\n\t * {@code args} is {@code [1, \"a\", \"b\"]} it must be repackaged as\n\t * {@code [1, new String[] {\"a\", \"b\"}]} in order to match the expected types.\n\t * @param requiredParameterTypes the types of the parameters for the invocation\n\t * @param args the arguments to be set up for the invocation\n\t * @return a repackaged array of arguments where any varargs setup has been performed\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredParameterTypes",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 483
    },
    "return": "Object[]",
    "signature": "public Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args)",
    "source_code": "\tpublic static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args) {\n\t\tAssert.notEmpty(requiredParameterTypes, \"Required parameter types array must not be empty\");\n\n\t\tint parameterCount = requiredParameterTypes.length;\n\t\tClass<?> lastRequiredParameterType = requiredParameterTypes[parameterCount - 1];\n\t\tAssert.isTrue(lastRequiredParameterType.isArray(),\n\t\t\t\t\"The last required parameter type must be an array to support varargs invocation\");\n\n\t\tint argumentCount = args.length;\n\t\tObject lastArgument = (argumentCount > 0 ? args[argumentCount - 1] : null);\n\n\t\t// Check if repackaging is needed...\n\t\tif (parameterCount != argumentCount || !lastRequiredParameterType.isInstance(lastArgument)) {\n\t\t\t// Create an array for the leading arguments plus the varargs array argument.\n\t\t\tObject[] newArgs = new Object[parameterCount];\n\t\t\t// Copy all leading arguments to the new array, omitting the varargs array argument.\n\t\t\tSystem.arraycopy(args, 0, newArgs, 0, newArgs.length - 1);\n\n\t\t\t// Now sort out the final argument, which is the varargs one. Before entering this method,\n\t\t\t// the arguments should have been converted to the box form of the required type.\n\t\t\tint varargsArraySize = 0;  // zero size array if nothing to pass as the varargs parameter\n\t\t\tif (argumentCount >= parameterCount) {\n\t\t\t\tvarargsArraySize = argumentCount - (parameterCount - 1);\n\t\t\t}\n\t\t\tClass<?> componentType = lastRequiredParameterType.componentType();\n\t\t\tObject varargsArray = Array.newInstance(componentType, varargsArraySize);\n\t\t\tfor (int i = 0; i < varargsArraySize; i++) {\n\t\t\t\tArray.set(varargsArray, i, args[parameterCount - 1 + i]);\n\t\t\t}\n\t\t\t// Finally, add the varargs array to the new arguments array.\n\t\t\tnewArgs[newArgs.length - 1] = varargsArray;\n\t\t\treturn newArgs;\n\t\t}\n\n\t\treturn args;\n\t}"
  },
  "org.springframework.expression.spel.support.ReflectionHelper#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 559
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn \"ArgumentsMatchInfo: \" + this.kind;\n\t\t}"
  },
  "org.springframework.expression.spel.support.ReflectivePropertyAccessor#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 599
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other || (other instanceof PropertyCacheKey that &&\n\t\t\t\t\tthis.clazz == that.clazz && this.property.equals(that.property) &&\n\t\t\t\t\tthis.targetIsClass == that.targetIsClass));\n\t\t}"
  },
  "org.springframework.expression.spel.support.ReflectivePropertyAccessor#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 606
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\t\tpublic int hashCode() {\n\t\t\treturn (this.clazz.hashCode() * 29 + this.property.hashCode());\n\t\t}"
  },
  "org.springframework.expression.spel.support.ReflectivePropertyAccessor#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 611
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn \"PropertyCacheKey [clazz=\" + this.clazz.getName() + \", property=\" + this.property +\n\t\t\t\t\t\", targetIsClass=\" + this.targetIsClass + \"]\";\n\t\t}"
  },
  "org.springframework.expression.spel.support.member": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * The member being accessed.\n\t\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 640
    },
    "signature": "public Member member",
    "source_code": "\t\tpublic final Member member;",
    "type": "Member"
  },
  "org.springframework.format.datetime.standard.DurationFormatterUtils": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Support {@code Duration} parsing and printing in several styles, as listed in\n * {@link DurationFormat.Style}.\n * <p>Some styles may not enforce any unit to be present, defaulting to {@code DurationFormat.Unit#MILLIS}\n * in that case. Methods in this class offer overloads that take a {@link DurationFormat.Unit} to\n * be used as a fall-back instead of the ultimate MILLIS default.\n *\n * @author Phillip Webb\n * @author Valentine Wu\n * @author Simon Basl\u00e9\n * @since 6.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 40
    },
    "signature": "public class DurationFormatterUtils",
    "source_code": "public abstract class DurationFormatterUtils {\n\n\tprivate DurationFormatterUtils() {\n\t\t// singleton\n\t}\n\n\t/**\n\t * Parse the given value to a duration.\n\t * @param value the value to parse\n\t * @param style the style in which to parse\n\t * @return a duration\n\t */\n\tpublic static Duration parse(String value, DurationFormat.Style style) {\n\t\treturn parse(value, style, null);\n\t}\n\n\t/**\n\t * Parse the given value to a duration.\n\t * @param value the value to parse\n\t * @param style the style in which to parse\n\t * @param unit the duration unit to use if the value doesn't specify one ({@code null}\n\t * will default to ms)\n\t * @return a duration\n\t */\n\tpublic static Duration parse(String value, DurationFormat.Style style, @Nullable DurationFormat.Unit unit) {\n\t\tAssert.hasText(value, () -> \"Value must not be empty\");\n\t\treturn switch (style) {\n\t\t\tcase ISO8601 -> parseIso8601(value);\n\t\t\tcase SIMPLE -> parseSimple(value, unit);\n\t\t\tcase COMPOSITE -> parseComposite(value);\n\t\t};\n\t}\n\n\t/**\n\t * Print the specified duration in the specified style.\n\t * @param value the value to print\n\t * @param style the style to print in\n\t * @return the printed result\n\t */\n\tpublic static String print(Duration value, DurationFormat.Style style) {\n\t\treturn print(value, style, null);\n\t}\n\n\t/**\n\t * Print the specified duration in the specified style using the given unit.\n\t * @param value the value to print\n\t * @param style the style to print in\n\t * @param unit the unit to use for printing, if relevant ({@code null} will default\n\t * to ms)\n\t * @return the printed result\n\t */\n\tpublic static String print(Duration value, DurationFormat.Style style, @Nullable DurationFormat.Unit unit) {\n\t\treturn switch (style) {\n\t\t\tcase ISO8601 -> value.toString();\n\t\t\tcase SIMPLE -> printSimple(value, unit);\n\t\t\tcase COMPOSITE -> printComposite(value);\n\t\t};\n\t}\n\n\t/**\n\t * Detect the style then parse the value to return a duration.\n\t * @param value the value to parse\n\t * @return the parsed duration\n\t * @throws IllegalArgumentException if the value is not a known style or cannot be\n\t * parsed\n\t */\n\tpublic static Duration detectAndParse(String value) {\n\t\treturn detectAndParse(value, null);\n\t}\n\n\t/**\n\t * Detect the style then parse the value to return a duration.\n\t * @param value the value to parse\n\t * @param unit the duration unit to use if the value doesn't specify one ({@code null}\n\t * will default to ms)\n\t * @return the parsed duration\n\t * @throws IllegalArgumentException if the value is not a known style or cannot be\n\t * parsed\n\t */\n\tpublic static Duration detectAndParse(String value, @Nullable DurationFormat.Unit unit) {\n\t\treturn parse(value, detect(value), unit);\n\t}\n\n\t/**\n\t * Detect the style from the given source value.\n\t * @param value the source value\n\t * @return the duration style\n\t * @throws IllegalArgumentException if the value is not a known style\n\t */\n\tpublic static DurationFormat.Style detect(String value) {\n\t\tAssert.notNull(value, \"Value must not be null\");\n\t\t// warning: the order of parsing starts to matter if multiple patterns accept a plain integer (no unit suffix)\n\t\tif (ISO_8601_PATTERN.matcher(value).matches()) {\n\t\t\treturn DurationFormat.Style.ISO8601;\n\t\t}\n\t\tif (SIMPLE_PATTERN.matcher(value).matches()) {\n\t\t\treturn DurationFormat.Style.SIMPLE;\n\t\t}\n\t\tif (COMPOSITE_PATTERN.matcher(value).matches()) {\n\t\t\treturn DurationFormat.Style.COMPOSITE;\n\t\t}\n\t\tthrow new IllegalArgumentException(\"'\" + value + \"' is not a valid duration, cannot detect any known style\");\n\t}\n\n\tprivate static final Pattern ISO_8601_PATTERN = Pattern.compile(\"^[+-]?[pP].*$\");\n\tprivate static final Pattern SIMPLE_PATTERN = Pattern.compile(\"^([+-]?\\\\d+)([a-zA-Z]{0,2})$\");\n\tprivate static final Pattern COMPOSITE_PATTERN = Pattern.compile(\"^([+-]?)\\\\(?\\\\s?(\\\\d+d)?\\\\s?(\\\\d+h)?\\\\s?(\\\\d+m)?\" +\n\t\t\t\"\\\\s?(\\\\d+s)?\\\\s?(\\\\d+ms)?\\\\s?(\\\\d+us)?\\\\s?(\\\\d+ns)?\\\\)?$\");\n\n\tprivate static Duration parseIso8601(String value) {\n\t\ttry {\n\t\t\treturn Duration.parse(value);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new IllegalArgumentException(\"'\" + value + \"' is not a valid ISO-8601 duration\", ex);\n\t\t}\n\t}\n\n\tprivate static Duration parseSimple(String text, @Nullable DurationFormat.Unit fallbackUnit) {\n\t\ttry {\n\t\t\tMatcher matcher = SIMPLE_PATTERN.matcher(text);\n\t\t\tAssert.state(matcher.matches(), \"Does not match simple duration pattern\");\n\t\t\tString suffix = matcher.group(2);\n\t\t\tDurationFormat.Unit parsingUnit = (fallbackUnit == null ? DurationFormat.Unit.MILLIS : fallbackUnit);\n\t\t\tif (StringUtils.hasLength(suffix)) {\n\t\t\t\tparsingUnit = DurationFormat.Unit.fromSuffix(suffix);\n\t\t\t}\n\t\t\treturn parsingUnit.parse(matcher.group(1));\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new IllegalArgumentException(\"'\" + text + \"' is not a valid simple duration\", ex);\n\t\t}\n\t}\n\n\tprivate static String printSimple(Duration duration, @Nullable DurationFormat.Unit unit) {\n\t\tunit = (unit == null ? DurationFormat.Unit.MILLIS : unit);\n\t\treturn unit.print(duration);\n\t}\n\n\tprivate static Duration parseComposite(String text) {\n\t\ttry {\n\t\t\tMatcher matcher = COMPOSITE_PATTERN.matcher(text);\n\t\t\tAssert.state(matcher.matches() && matcher.groupCount() > 1, \"Does not match composite duration pattern\");\n\t\t\tString sign = matcher.group(1);\n\t\t\tboolean negative = sign != null && sign.equals(\"-\");\n\n\t\t\tDuration result = Duration.ZERO;\n\t\t\tDurationFormat.Unit[] units = DurationFormat.Unit.values();\n\t\t\tfor (int i = 2; i < matcher.groupCount() + 1; i++) {\n\t\t\t\tString segment = matcher.group(i);\n\t\t\t\tif (StringUtils.hasText(segment)) {\n\t\t\t\t\tDurationFormat.Unit unit = units[units.length - i + 1];\n\t\t\t\t\tresult = result.plus(unit.parse(segment.replace(unit.asSuffix(), \"\")));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn negative ? result.negated() : result;\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new IllegalArgumentException(\"'\" + text + \"' is not a valid composite duration\", ex);\n\t\t}\n\t}\n\n\tprivate static String printComposite(Duration duration) {\n\t\tif (duration.isZero()) {\n\t\t\treturn DurationFormat.Unit.SECONDS.print(duration);\n\t\t}\n\t\tStringBuilder result = new StringBuilder();\n\t\tif (duration.isNegative()) {\n\t\t\tresult.append('-');\n\t\t\tduration = duration.negated();\n\t\t}\n\t\tlong days = duration.toDaysPart();\n\t\tif (days != 0) {\n\t\t\tresult.append(days).append(DurationFormat.Unit.DAYS.asSuffix());\n\t\t}\n\t\tint hours = duration.toHoursPart();\n\t\tif (hours != 0) {\n\t\t\tresult.append(hours).append(DurationFormat.Unit.HOURS.asSuffix());\n\t\t}\n\t\tint minutes = duration.toMinutesPart();\n\t\tif (minutes != 0) {\n\t\t\tresult.append(minutes).append(DurationFormat.Unit.MINUTES.asSuffix());\n\t\t}\n\t\tint seconds = duration.toSecondsPart();\n\t\tif (seconds != 0) {\n\t\t\tresult.append(seconds).append(DurationFormat.Unit.SECONDS.asSuffix());\n\t\t}\n\t\tint millis = duration.toMillisPart();\n\t\tif (millis != 0) {\n\t\t\tresult.append(millis).append(DurationFormat.Unit.MILLIS.asSuffix());\n\t\t}\n\t\t//special handling of nanos: remove the millis part and then divide into microseconds and nanoseconds\n\t\tlong nanos = duration.toNanosPart() - Duration.ofMillis(millis).toNanos();\n\t\tif (nanos != 0) {\n\t\t\tlong micros = nanos / 1000;\n\t\t\tlong remainder = nanos - (micros * 1000);\n\t\t\tif (micros > 0) {\n\t\t\t\tresult.append(micros).append(DurationFormat.Unit.MICROS.asSuffix());\n\t\t\t}\n\t\t\tif (remainder > 0) {\n\t\t\t\tresult.append(remainder).append(DurationFormat.Unit.NANOS.asSuffix());\n\t\t\t}\n\t\t}\n\t\treturn result.toString();\n\t}\n\n}"
  },
  "org.springframework.format.datetime.standard.DurationFormatterUtils#detectAndParse(value)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Detect the style then parse the value to return a duration.\n\t * @param value the value to parse\n\t * @return the parsed duration\n\t * @throws IllegalArgumentException if the value is not a known style or cannot be\n\t * parsed\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "Duration",
    "signature": "public Duration detectAndParse(String value)",
    "source_code": "\tpublic static Duration detectAndParse(String value) {\n\t\treturn detectAndParse(value, null);\n\t}"
  },
  "org.springframework.format.datetime.standard.DurationFormatterUtils#detectAndParse(value,unit)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Detect the style then parse the value to return a duration.\n\t * @param value the value to parse\n\t * @param unit the duration unit to use if the value doesn't specify one ({@code null}\n\t * will default to ms)\n\t * @return the parsed duration\n\t * @throws IllegalArgumentException if the value is not a known style or cannot be\n\t * parsed\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "unit"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "Duration",
    "signature": "public Duration detectAndParse(String value, @Nullable DurationFormat.Unit unit)",
    "source_code": "\tpublic static Duration detectAndParse(String value, @Nullable DurationFormat.Unit unit) {\n\t\treturn parse(value, detect(value), unit);\n\t}"
  },
  "org.springframework.format.datetime.standard.DurationFormatterUtils#parse(value,style)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the given value to a duration.\n\t * @param value the value to parse\n\t * @param style the style in which to parse\n\t * @return a duration\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "style"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "Duration",
    "signature": "public Duration parse(String value, DurationFormat.Style style)",
    "source_code": "\tpublic static Duration parse(String value, DurationFormat.Style style) {\n\t\treturn parse(value, style, null);\n\t}"
  },
  "org.springframework.format.datetime.standard.DurationFormatterUtils#parse(value,style,unit)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the given value to a duration.\n\t * @param value the value to parse\n\t * @param style the style in which to parse\n\t * @param unit the duration unit to use if the value doesn't specify one ({@code null}\n\t * will default to ms)\n\t * @return a duration\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "style",
      "unit"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "Duration",
    "signature": "public Duration parse(String value, DurationFormat.Style style, @Nullable DurationFormat.Unit unit)",
    "source_code": "\tpublic static Duration parse(String value, DurationFormat.Style style, @Nullable DurationFormat.Unit unit) {\n\t\tAssert.hasText(value, () -> \"Value must not be empty\");\n\t\treturn switch (style) {\n\t\t\tcase ISO8601 -> parseIso8601(value);\n\t\t\tcase SIMPLE -> parseSimple(value, unit);\n\t\t\tcase COMPOSITE -> parseComposite(value);\n\t\t};\n\t}"
  },
  "org.springframework.format.datetime.standard.DurationFormatterUtils#print(value,style)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Print the specified duration in the specified style.\n\t * @param value the value to print\n\t * @param style the style to print in\n\t * @return the printed result\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "style"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "String",
    "signature": "public String print(Duration value, DurationFormat.Style style)",
    "source_code": "\tpublic static String print(Duration value, DurationFormat.Style style) {\n\t\treturn print(value, style, null);\n\t}"
  },
  "org.springframework.format.datetime.standard.DurationFormatterUtils#print(value,style,unit)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Print the specified duration in the specified style using the given unit.\n\t * @param value the value to print\n\t * @param style the style to print in\n\t * @param unit the unit to use for printing, if relevant ({@code null} will default\n\t * to ms)\n\t * @return the printed result\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "style",
      "unit"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "String",
    "signature": "public String print(Duration value, DurationFormat.Style style, @Nullable DurationFormat.Unit unit)",
    "source_code": "\tpublic static String print(Duration value, DurationFormat.Style style, @Nullable DurationFormat.Unit unit) {\n\t\treturn switch (style) {\n\t\t\tcase ISO8601 -> value.toString();\n\t\t\tcase SIMPLE -> printSimple(value, unit);\n\t\t\tcase COMPOSITE -> printComposite(value);\n\t\t};\n\t}"
  },
  "org.springframework.http.APPLICATION_YAML": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Public constant media type for {@code application/yaml}.\n\t * @since 6.2\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "signature": "public MediaType APPLICATION_YAML",
    "source_code": "\tpublic static final MediaType APPLICATION_YAML;",
    "type": "MediaType"
  },
  "org.springframework.http.APPLICATION_YAML_VALUE": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * A String equivalent of {@link MediaType#APPLICATION_YAML}.\n\t * @since 6.2\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 329
    },
    "signature": "public String APPLICATION_YAML_VALUE",
    "source_code": "\tpublic static final String APPLICATION_YAML_VALUE = \"application/yaml\";",
    "type": "String"
  },
  "org.springframework.http.ETag#compare(other,strong)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform a strong or weak comparison to another {@link ETag}.\n\t * @param other the ETag to compare to\n\t * @param strong whether to perform strong or weak comparison\n\t * @return whether there is a match or not\n\t * @since 6.2\n\t * @see <a href=\"https://datatracker.ietf.org/doc/html/rfc9110#section-8.8.3.2\">RFC 9110, Section 8.8.3.2</a>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other",
      "strong"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "boolean",
    "signature": "public boolean compare(ETag other, boolean strong)",
    "source_code": "\tpublic boolean compare(ETag other, boolean strong) {\n\t\tif (!StringUtils.hasLength(tag()) || !StringUtils.hasLength(other.tag())) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (strong && (weak() || other.weak())) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn tag().equals(other.tag());\n\t}"
  },
  "org.springframework.http.ETag#create(rawValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an {@link ETag} instance from a String representation.\n\t * @param rawValue the formatted ETag value\n\t * @return the created instance\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rawValue"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "ETag",
    "signature": "public ETag create(String rawValue)",
    "source_code": "\tpublic static ETag create(String rawValue) {\n\t\tboolean weak = rawValue.startsWith(\"W/\");\n\t\tif (weak) {\n\t\t\trawValue = rawValue.substring(2);\n\t\t}\n\t\tif (rawValue.length() > 2 && rawValue.startsWith(\"\\\"\") && rawValue.endsWith(\"\\\"\")) {\n\t\t\trawValue = rawValue.substring(1, rawValue.length() - 1);\n\t\t}\n\t\treturn new ETag(rawValue, weak);\n\t}"
  },
  "org.springframework.http.ETag#equals(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "boolean",
    "signature": "public boolean equals(Object other)",
    "source_code": "\tpublic boolean equals(Object other) {\n\t\treturn (this == other ||\n\t\t\t\t(other instanceof ETag oet && this.tag.equals(oet.tag) && this.weak == oet.weak));\n\t}"
  },
  "org.springframework.http.ETag#hashCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\tint result = this.tag.hashCode();\n\t\tresult = 31 * result + Boolean.hashCode(this.weak);\n\t\treturn result;\n\t}"
  },
  "org.springframework.http.ETag#quoteETagIfNecessary(tag)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add quotes around the ETag value if not present already.\n\t * @param tag the ETag value\n\t * @return the resulting, quoted value\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "tag"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "String",
    "signature": "public String quoteETagIfNecessary(String tag)",
    "source_code": "\tpublic static String quoteETagIfNecessary(String tag) {\n\t\tif (tag.startsWith(\"W/\\\"\")) {\n\t\t\tif (tag.length() > 3 && tag.endsWith(\"\\\"\")) {\n\t\t\t\treturn tag;\n\t\t\t}\n\t\t}\n\t\telse if (tag.startsWith(\"\\\"\")) {\n\t\t\tif (tag.length() > 1 && tag.endsWith(\"\\\"\")) {\n\t\t\t\treturn tag;\n\t\t\t}\n\t\t}\n\t\treturn (\"\\\"\" + tag + \"\\\"\");\n\t}"
  },
  "org.springframework.http.HttpHeaders#asSingleValueMap()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1799
    },
    "return": "String>",
    "signature": "public String> asSingleValueMap()",
    "source_code": "\tpublic Map<String, String> asSingleValueMap() {\n\t\treturn this.headers.asSingleValueMap();\n\t}"
  },
  "org.springframework.http.HttpHeaders#setETag(etag)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the (new) entity tag of the body, as specified by the {@code ETag} header.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "etag"
    ],
    "position": {
      "column": 1,
      "line": 1061
    },
    "return": "void",
    "signature": "public void setETag(@Nullable String etag)",
    "source_code": "\tpublic void setETag(@Nullable String etag) {\n\t\tif (etag != null) {\n\t\t\tAssert.isTrue(etag.startsWith(\"\\\"\") || etag.startsWith(\"W/\\\"\"), \"ETag does not start with W/\\\" or \\\"\");\n\t\t\tAssert.isTrue(etag.endsWith(\"\\\"\"), \"ETag does not end with \\\"\");\n\t\t\tset(ETAG, etag);\n\t\t}\n\t\telse {\n\t\t\tremove(ETAG);\n\t\t}\n\t}"
  },
  "org.springframework.http.HttpHeaders#setETag(tag)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the (new) entity tag of the body, as specified by the {@code ETag} header.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "tag"
    ],
    "position": {
      "column": 1,
      "line": 1093
    },
    "return": "void",
    "signature": "public void setETag(@Nullable String tag)",
    "source_code": "\tpublic void setETag(@Nullable String tag) {\n\t\tif (tag != null) {\n\t\t\tset(ETAG, ETag.quoteETagIfNecessary(tag));\n\t\t}\n\t\telse {\n\t\t\tremove(ETAG);\n\t\t}\n\t}"
  },
  "org.springframework.http.RequestEntity": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Extension of {@link HttpEntity} that also exposes the HTTP method and the\n * target URL. For use in the {@code RestTemplate} to prepare requests with\n * and in {@code @Controller} methods to represent request input.\n *\n * <p>Example use with the {@code RestTemplate}:\n * <pre class=\"code\">\n * MyRequest body = ...\n * RequestEntity&lt;MyRequest&gt; request = RequestEntity\n *     .post(&quot;https://example.com/{foo}&quot;, &quot;bar&quot;)\n *     .accept(MediaType.APPLICATION_JSON)\n *     .body(body);\n * ResponseEntity&lt;MyResponse&gt; response = template.exchange(request, MyResponse.class);\n * </pre>\n *\n * <p>Example use in an {@code @Controller}:\n * <pre class=\"code\">\n * &#64;RequestMapping(\"/handle\")\n * public void handle(RequestEntity&lt;String&gt; request) {\n *   HttpMethod method = request.getMethod();\n *   URI url = request.getUrl();\n *   String body = request.getBody();\n * }\n * </pre>\n *\n * @author Arjen Poutsma\n * @author Sebastien Deleuze\n * @author Parviz Rozikov\n * @since 4.1\n * @param <T> the body type\n * @see #getMethod()\n * @see #getUrl()\n * @see org.springframework.web.client.RestOperations#exchange(RequestEntity, Class)\n * @see ResponseEntity\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "signature": "public class RequestEntity",
    "source_code": "public class RequestEntity<T> extends HttpEntity<T> {\n\n\t@Nullable\n\tprivate final HttpMethod method;\n\n\t@Nullable\n\tprivate final URI url;\n\n\t@Nullable\n\tprivate final Type type;\n\n\t/**\n\t * Constructor with method and URL but without body nor headers.\n\t * @param method the method\n\t * @param url the URL\n\t */\n\tpublic RequestEntity(HttpMethod method, URI url) {\n\t\tthis(null, null, method, url, null);\n\t}\n\n\t/**\n\t * Constructor with method, URL and body but without headers.\n\t * @param body the body\n\t * @param method the method\n\t * @param url the URL\n\t */\n\tpublic RequestEntity(@Nullable T body, HttpMethod method, URI url) {\n\t\tthis(body, null, method, url, null);\n\t}\n\n\t/**\n\t * Constructor with method, URL, body and type but without headers.\n\t * @param body the body\n\t * @param method the method\n\t * @param url the URL\n\t * @param type the type used for generic type resolution\n\t * @since 4.3\n\t */\n\tpublic RequestEntity(@Nullable T body, HttpMethod method, URI url, Type type) {\n\t\tthis(body, null, method, url, type);\n\t}\n\n\t/**\n\t * Constructor with method, URL and headers but without body.\n\t * @param headers the headers\n\t * @param method the method\n\t * @param url the URL\n\t */\n\tpublic RequestEntity(MultiValueMap<String, String> headers, HttpMethod method, URI url) {\n\t\tthis(null, headers, method, url, null);\n\t}\n\n\t/**\n\t * Constructor with method, URL, headers and body.\n\t * @param body the body\n\t * @param headers the headers\n\t * @param method the method\n\t * @param url the URL\n\t */\n\tpublic RequestEntity(@Nullable T body, @Nullable MultiValueMap<String, String> headers,\n\t\t\t@Nullable HttpMethod method, URI url) {\n\n\t\tthis(body, headers, method, url, null);\n\t}\n\n\t/**\n\t * Constructor with method, URL, headers, body and type.\n\t * @param body the body\n\t * @param headers the headers\n\t * @param method the method\n\t * @param url the URL\n\t * @param type the type used for generic type resolution\n\t * @since 4.3\n\t */\n\tpublic RequestEntity(@Nullable T body, @Nullable MultiValueMap<String, String> headers,\n\t\t\t@Nullable HttpMethod method, @Nullable URI url, @Nullable Type type) {\n\n\t\tsuper(body, headers);\n\t\tthis.method = method;\n\t\tthis.url = url;\n\t\tthis.type = type;\n\t}\n\n\n\t/**\n\t * Return the HTTP method of the request.\n\t * @return the HTTP method as an {@code HttpMethod} enum value\n\t */\n\t@Nullable\n\tpublic HttpMethod getMethod() {\n\t\treturn this.method;\n\t}\n\n\t/**\n\t * Return the {@link URI} for the target HTTP endpoint.\n\t * <p><strong>Note:</strong> This method raises\n\t * {@link UnsupportedOperationException} if the {@code RequestEntity} was\n\t * created with a URI template and variables rather than with a {@link URI}\n\t * instance. This is because a URI cannot be created without further input\n\t * on how to expand template and encode the URI. In such cases, the\n\t * {@code URI} is prepared by the\n\t * {@link org.springframework.web.client.RestTemplate} with the help of the\n\t * {@link org.springframework.web.util.UriTemplateHandler} it is configured with.\n\t */\n\tpublic URI getUrl() {\n\t\tif (this.url == null) {\n\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\"The RequestEntity was created with a URI template and variables, \" +\n\t\t\t\t\t\t\t\"and there is not enough information on how to correctly expand and \" +\n\t\t\t\t\t\t\t\"encode the URI template. This will be done by the RestTemplate instead \" +\n\t\t\t\t\t\t\t\"with help from the UriTemplateHandler it is configured with.\");\n\t\t}\n\t\treturn this.url;\n\t}\n\n\n\t/**\n\t * Return the type of the request's body.\n\t * @return the request's body type, or {@code null} if not known\n\t * @since 4.3\n\t */\n\t@Nullable\n\tpublic Type getType() {\n\t\tif (this.type == null) {\n\t\t\tT body = getBody();\n\t\t\tif (body != null) {\n\t\t\t\treturn body.getClass();\n\t\t\t}\n\t\t}\n\t\treturn this.type;\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!super.equals(other)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (other instanceof RequestEntity<?> otherEntity &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.method, otherEntity.method) &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.url, otherEntity.url));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tint hashCode = super.hashCode();\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(this.method);\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(this.url);\n\t\treturn hashCode;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn format(getMethod(), getUrl().toString(), getBody(), getHeaders());\n\t}\n\n\tstatic <T> String format(@Nullable HttpMethod httpMethod, String url, @Nullable T body, HttpHeaders headers) {\n\t\tStringBuilder builder = new StringBuilder(\"<\");\n\t\tbuilder.append(httpMethod);\n\t\tbuilder.append(' ');\n\t\tbuilder.append(url);\n\t\tbuilder.append(',');\n\t\tif (body != null) {\n\t\t\tbuilder.append(body);\n\t\t\tbuilder.append(',');\n\t\t}\n\t\tbuilder.append(headers);\n\t\tbuilder.append('>');\n\t\treturn builder.toString();\n\t}\n\n\n\t// Static builder methods\n\n\t/**\n\t * Create a builder with the given method and url.\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param url the URL\n\t * @return the created builder\n\t */\n\tpublic static BodyBuilder method(HttpMethod method, URI url) {\n\t\treturn new DefaultBodyBuilder(method, url);\n\t}\n\n\t/**\n\t * Create a builder with the given HTTP method, URI template, and variables.\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */\n\tpublic static BodyBuilder method(HttpMethod method, String uriTemplate, Object... uriVariables) {\n\t\treturn new DefaultBodyBuilder(method, uriTemplate, uriVariables);\n\t}\n\n\t/**\n\t * Create a builder with the given HTTP method, URI template, and variables.\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param uriTemplate the uri template to use\n\t * @return the created builder\n\t * @since 5.3\n\t */\n\tpublic static BodyBuilder method(HttpMethod method, String uriTemplate, Map<String, ?> uriVariables) {\n\t\treturn new DefaultBodyBuilder(method, uriTemplate, uriVariables);\n\t}\n\n\n\t/**\n\t * Create an HTTP GET builder with the given url.\n\t * @param url the URL\n\t * @return the created builder\n\t */\n\tpublic static HeadersBuilder<?> get(URI url) {\n\t\treturn method(HttpMethod.GET, url);\n\t}\n\n\t/**\n\t * Create an HTTP GET builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */\n\tpublic static HeadersBuilder<?> get(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.GET, uriTemplate, uriVariables);\n\t}\n\n\t/**\n\t * Create an HTTP HEAD builder with the given url.\n\t * @param url the URL\n\t * @return the created builder\n\t */\n\tpublic static HeadersBuilder<?> head(URI url) {\n\t\treturn method(HttpMethod.HEAD, url);\n\t}\n\n\t/**\n\t * Create an HTTP HEAD builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */\n\tpublic static HeadersBuilder<?> head(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.HEAD, uriTemplate, uriVariables);\n\t}\n\n\t/**\n\t * Create an HTTP POST builder with the given url.\n\t * @param url the URL\n\t * @return the created builder\n\t */\n\tpublic static BodyBuilder post(URI url) {\n\t\treturn method(HttpMethod.POST, url);\n\t}\n\n\t/**\n\t * Create an HTTP POST builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */\n\tpublic static BodyBuilder post(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.POST, uriTemplate, uriVariables);\n\t}\n\n\t/**\n\t * Create an HTTP PUT builder with the given url.\n\t * @param url the URL\n\t * @return the created builder\n\t */\n\tpublic static BodyBuilder put(URI url) {\n\t\treturn method(HttpMethod.PUT, url);\n\t}\n\n\t/**\n\t * Create an HTTP PUT builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */\n\tpublic static BodyBuilder put(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.PUT, uriTemplate, uriVariables);\n\t}\n\n\t/**\n\t * Create an HTTP PATCH builder with the given url.\n\t * @param url the URL\n\t * @return the created builder\n\t */\n\tpublic static BodyBuilder patch(URI url) {\n\t\treturn method(HttpMethod.PATCH, url);\n\t}\n\n\t/**\n\t * Create an HTTP PATCH builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */\n\tpublic static BodyBuilder patch(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.PATCH, uriTemplate, uriVariables);\n\t}\n\n\t/**\n\t * Create an HTTP DELETE builder with the given url.\n\t * @param url the URL\n\t * @return the created builder\n\t */\n\tpublic static HeadersBuilder<?> delete(URI url) {\n\t\treturn method(HttpMethod.DELETE, url);\n\t}\n\n\t/**\n\t * Create an HTTP DELETE builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */\n\tpublic static HeadersBuilder<?> delete(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.DELETE, uriTemplate, uriVariables);\n\t}\n\n\t/**\n\t * Creates an HTTP OPTIONS builder with the given url.\n\t * @param url the URL\n\t * @return the created builder\n\t */\n\tpublic static HeadersBuilder<?> options(URI url) {\n\t\treturn method(HttpMethod.OPTIONS, url);\n\t}\n\n\t/**\n\t * Creates an HTTP OPTIONS builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */\n\tpublic static HeadersBuilder<?> options(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.OPTIONS, uriTemplate, uriVariables);\n\t}\n\n\n\t/**\n\t * Defines a builder that adds headers to the request entity.\n\t * @param <B> the builder subclass\n\t */\n\tpublic interface HeadersBuilder<B extends HeadersBuilder<B>> {\n\n\t\t/**\n\t\t * Add the given, single header value under the given name.\n\t\t * @param headerName  the header name\n\t\t * @param headerValues the header value(s)\n\t\t * @return this builder\n\t\t * @see HttpHeaders#add(String, String)\n\t\t */\n\t\tB header(String headerName, String... headerValues);\n\n\t\t/**\n\t\t * Copy the given headers into the entity's headers map.\n\t\t * @param headers the existing HttpHeaders to copy from\n\t\t * @return this builder\n\t\t * @since 5.2\n\t\t * @see HttpHeaders#add(String, String)\n\t\t */\n\t\tB headers(@Nullable HttpHeaders headers);\n\n\t\t/**\n\t\t * Manipulate this entity's headers with the given consumer. The\n\t\t * headers provided to the consumer are \"live\", so that the consumer can be used to\n\t\t * {@linkplain HttpHeaders#set(String, String) overwrite} existing header values,\n\t\t * {@linkplain HttpHeaders#remove(Object) remove} values, or use any of the other\n\t\t * {@link HttpHeaders} methods.\n\t\t * @param headersConsumer a function that consumes the {@code HttpHeaders}\n\t\t * @return this builder\n\t\t * @since 5.2\n\t\t */\n\t\tB headers(Consumer<HttpHeaders> headersConsumer);\n\n\t\t/**\n\t\t * Set the list of acceptable {@linkplain MediaType media types}, as\n\t\t * specified by the {@code Accept} header.\n\t\t * @param acceptableMediaTypes the acceptable media types\n\t\t */\n\t\tB accept(MediaType... acceptableMediaTypes);\n\n\t\t/**\n\t\t * Set the list of acceptable {@linkplain Charset charsets}, as specified\n\t\t * by the {@code Accept-Charset} header.\n\t\t * @param acceptableCharsets the acceptable charsets\n\t\t */\n\t\tB acceptCharset(Charset... acceptableCharsets);\n\n\t\t/**\n\t\t * Set the value of the {@code If-Modified-Since} header.\n\t\t * @param ifModifiedSince the new value of the header\n\t\t * @since 5.1.4\n\t\t */\n\t\tB ifModifiedSince(ZonedDateTime ifModifiedSince);\n\n\t\t/**\n\t\t * Set the value of the {@code If-Modified-Since} header.\n\t\t * @param ifModifiedSince the new value of the header\n\t\t * @since 5.1.4\n\t\t */\n\t\tB ifModifiedSince(Instant ifModifiedSince);\n\n\t\t/**\n\t\t * Set the value of the {@code If-Modified-Since} header.\n\t\t * <p>The date should be specified as the number of milliseconds since\n\t\t * January 1, 1970 GMT.\n\t\t * @param ifModifiedSince the new value of the header\n\t\t */\n\t\tB ifModifiedSince(long ifModifiedSince);\n\n\t\t/**\n\t\t * Set the values of the {@code If-None-Match} header.\n\t\t * @param ifNoneMatches the new value of the header\n\t\t */\n\t\tB ifNoneMatch(String... ifNoneMatches);\n\n\t\t/**\n\t\t * Builds the request entity with no body.\n\t\t * @return the request entity\n\t\t * @see BodyBuilder#body(Object)\n\t\t */\n\t\tRequestEntity<Void> build();\n\t}\n\n\n\t/**\n\t * Defines a builder that adds a body to the response entity.\n\t */\n\tpublic interface BodyBuilder extends HeadersBuilder<BodyBuilder> {\n\n\t\t/**\n\t\t * Set the length of the body in bytes, as specified by the\n\t\t * {@code Content-Length} header.\n\t\t * @param contentLength the content length\n\t\t * @return this builder\n\t\t * @see HttpHeaders#setContentLength(long)\n\t\t */\n\t\tBodyBuilder contentLength(long contentLength);\n\n\t\t/**\n\t\t * Set the {@linkplain MediaType media type} of the body, as specified\n\t\t * by the {@code Content-Type} header.\n\t\t * @param contentType the content type\n\t\t * @return this builder\n\t\t * @see HttpHeaders#setContentType(MediaType)\n\t\t */\n\t\tBodyBuilder contentType(MediaType contentType);\n\n\t\t/**\n\t\t * Set the body of the request entity and build the RequestEntity.\n\t\t * @param <T> the type of the body\n\t\t * @param body the body of the request entity\n\t\t * @return the built request entity\n\t\t */\n\t\t<T> RequestEntity<T> body(T body);\n\n\t\t/**\n\t\t * Set the body and type of the request entity and build the RequestEntity.\n\t\t * @param <T> the type of the body\n\t\t * @param body the body of the request entity\n\t\t * @param type the type of the body, useful for generic type resolution\n\t\t * @return the built request entity\n\t\t * @since 4.3\n\t\t */\n\t\t<T> RequestEntity<T> body(T body, Type type);\n\t}\n\n\n\tprivate static class DefaultBodyBuilder implements BodyBuilder {\n\n\t\tprivate final HttpMethod method;\n\n\t\tprivate final HttpHeaders headers = new HttpHeaders();\n\n\t\t@Nullable\n\t\tprivate final URI uri;\n\n\t\t@Nullable\n\t\tprivate final String uriTemplate;\n\n\t\t@Nullable\n\t\tprivate final Object[] uriVarsArray;\n\n\t\t@Nullable\n\t\tprivate final Map<String, ?> uriVarsMap;\n\n\t\tDefaultBodyBuilder(HttpMethod method, URI url) {\n\t\t\tthis.method = method;\n\t\t\tthis.uri = url;\n\t\t\tthis.uriTemplate = null;\n\t\t\tthis.uriVarsArray = null;\n\t\t\tthis.uriVarsMap = null;\n\t\t}\n\n\t\tDefaultBodyBuilder(HttpMethod method, String uriTemplate, Object... uriVars) {\n\t\t\tthis.method = method;\n\t\t\tthis.uri = null;\n\t\t\tthis.uriTemplate = uriTemplate;\n\t\t\tthis.uriVarsArray = uriVars;\n\t\t\tthis.uriVarsMap = null;\n\t\t}\n\n\t\tDefaultBodyBuilder(HttpMethod method, String uriTemplate, Map<String, ?> uriVars) {\n\t\t\tthis.method = method;\n\t\t\tthis.uri = null;\n\t\t\tthis.uriTemplate = uriTemplate;\n\t\t\tthis.uriVarsArray = null;\n\t\t\tthis.uriVarsMap = uriVars;\n\t\t}\n\n\t\t@Override\n\t\tpublic BodyBuilder header(String headerName, String... headerValues) {\n\t\t\tfor (String headerValue : headerValues) {\n\t\t\t\tthis.headers.add(headerName, headerValue);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic BodyBuilder headers(@Nullable HttpHeaders headers) {\n\t\t\tif (headers != null) {\n\t\t\t\tthis.headers.putAll(headers);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic BodyBuilder headers(Consumer<HttpHeaders> headersConsumer) {\n\t\t\theadersConsumer.accept(this.headers);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic BodyBuilder accept(MediaType... acceptableMediaTypes) {\n\t\t\tthis.headers.setAccept(Arrays.asList(acceptableMediaTypes));\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic BodyBuilder acceptCharset(Charset... acceptableCharsets) {\n\t\t\tthis.headers.setAcceptCharset(Arrays.asList(acceptableCharsets));\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic BodyBuilder contentLength(long contentLength) {\n\t\t\tthis.headers.setContentLength(contentLength);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic BodyBuilder contentType(MediaType contentType) {\n\t\t\tthis.headers.setContentType(contentType);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic BodyBuilder ifModifiedSince(ZonedDateTime ifModifiedSince) {\n\t\t\tthis.headers.setIfModifiedSince(ifModifiedSince);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic BodyBuilder ifModifiedSince(Instant ifModifiedSince) {\n\t\t\tthis.headers.setIfModifiedSince(ifModifiedSince);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic BodyBuilder ifModifiedSince(long ifModifiedSince) {\n\t\t\tthis.headers.setIfModifiedSince(ifModifiedSince);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic BodyBuilder ifNoneMatch(String... ifNoneMatches) {\n\t\t\tthis.headers.setIfNoneMatch(Arrays.asList(ifNoneMatches));\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic RequestEntity<Void> build() {\n\t\t\treturn buildInternal(null, null);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> RequestEntity<T> body(T body) {\n\t\t\treturn buildInternal(body, null);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> RequestEntity<T> body(T body, Type type) {\n\t\t\treturn buildInternal(body, type);\n\t\t}\n\n\t\tprivate <T> RequestEntity<T> buildInternal(@Nullable T body, @Nullable Type type) {\n\t\t\tif (this.uri != null) {\n\t\t\t\treturn new RequestEntity<>(body, this.headers, this.method, this.uri, type);\n\t\t\t}\n\t\t\telse if (this.uriTemplate != null){\n\t\t\t\treturn new UriTemplateRequestEntity<>(body, this.headers, this.method, type,\n\t\t\t\t\t\tthis.uriTemplate, this.uriVarsArray, this.uriVarsMap);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalStateException(\"Neither URI nor URI template\");\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * RequestEntity initialized with a URI template and variables instead of a {@link URI}.\n\t * @since 5.3\n\t * @param <T> the body type\n\t */\n\tpublic static class UriTemplateRequestEntity<T> extends RequestEntity<T> {\n\n\t\tprivate final String uriTemplate;\n\n\t\t@Nullable\n\t\tprivate final Object[] uriVarsArray;\n\n\t\t@Nullable\n\t\tprivate final Map<String, ?> uriVarsMap;\n\n\t\tUriTemplateRequestEntity(\n\t\t\t\t@Nullable T body, @Nullable MultiValueMap<String, String> headers,\n\t\t\t\t@Nullable HttpMethod method, @Nullable Type type, String uriTemplate,\n\t\t\t\t@Nullable Object[] uriVarsArray, @Nullable Map<String, ?> uriVarsMap) {\n\n\t\t\tsuper(body, headers, method, null, type);\n\t\t\tthis.uriTemplate = uriTemplate;\n\t\t\tthis.uriVarsArray = uriVarsArray;\n\t\t\tthis.uriVarsMap = uriVarsMap;\n\t\t}\n\n\t\tpublic String getUriTemplate() {\n\t\t\treturn this.uriTemplate;\n\t\t}\n\n\t\t@Nullable\n\t\tpublic Object[] getVars() {\n\t\t\treturn this.uriVarsArray;\n\t\t}\n\n\t\t@Nullable\n\t\tpublic Map<String, ?> getVarsMap() {\n\t\t\treturn this.uriVarsMap;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\tif (this == other) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!super.equals(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn (other instanceof UriTemplateRequestEntity<?> otherEntity &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.uriTemplate, otherEntity.uriTemplate) &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.uriVarsArray, otherEntity.uriVarsArray) &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.uriVarsMap, otherEntity.uriVarsMap));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn (29 * super.hashCode() + ObjectUtils.nullSafeHashCode(this.uriTemplate));\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn format(getMethod(), getUriTemplate(), getBody(), getHeaders());\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.http.RequestEntity#accept(acceptableMediaTypes)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "acceptableMediaTypes"
    ],
    "position": {
      "column": 1,
      "line": 614
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder accept(MediaType... acceptableMediaTypes)",
    "source_code": "\t\tpublic BodyBuilder accept(MediaType... acceptableMediaTypes) {\n\t\t\tthis.headers.setAccept(Arrays.asList(acceptableMediaTypes));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.RequestEntity#acceptCharset(acceptableCharsets)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "acceptableCharsets"
    ],
    "position": {
      "column": 1,
      "line": 620
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder acceptCharset(Charset... acceptableCharsets)",
    "source_code": "\t\tpublic BodyBuilder acceptCharset(Charset... acceptableCharsets) {\n\t\t\tthis.headers.setAcceptCharset(Arrays.asList(acceptableCharsets));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.RequestEntity#body(body)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body"
    ],
    "position": {
      "column": 1,
      "line": 667
    },
    "return": "RequestEntity<T>",
    "signature": "public RequestEntity<T> body(T body)",
    "source_code": "\t\tpublic <T> RequestEntity<T> body(T body) {\n\t\t\treturn buildInternal(body, null);\n\t\t}"
  },
  "org.springframework.http.RequestEntity#body(body,type)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 672
    },
    "return": "RequestEntity<T>",
    "signature": "public RequestEntity<T> body(T body, Type type)",
    "source_code": "\t\tpublic <T> RequestEntity<T> body(T body, Type type) {\n\t\t\treturn buildInternal(body, type);\n\t\t}"
  },
  "org.springframework.http.RequestEntity#build()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 662
    },
    "return": "RequestEntity<Void>",
    "signature": "public RequestEntity<Void> build()",
    "source_code": "\t\tpublic RequestEntity<Void> build() {\n\t\t\treturn buildInternal(null, null);\n\t\t}"
  },
  "org.springframework.http.RequestEntity#contentLength(contentLength)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentLength"
    ],
    "position": {
      "column": 1,
      "line": 626
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder contentLength(long contentLength)",
    "source_code": "\t\tpublic BodyBuilder contentLength(long contentLength) {\n\t\t\tthis.headers.setContentLength(contentLength);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.RequestEntity#contentType(contentType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 632
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder contentType(MediaType contentType)",
    "source_code": "\t\tpublic BodyBuilder contentType(MediaType contentType) {\n\t\t\tthis.headers.setContentType(contentType);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.RequestEntity#equals(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 732
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\tif (this == other) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!super.equals(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn (other instanceof UriTemplateRequestEntity<?> otherEntity &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.uriTemplate, otherEntity.uriTemplate) &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.uriVarsArray, otherEntity.uriVarsArray) &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.uriVarsMap, otherEntity.uriVarsMap));\n\t\t}"
  },
  "org.springframework.http.RequestEntity#getMethod()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the HTTP method of the request.\n\t * @return the HTTP method as an {@code HttpMethod} enum value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "HttpMethod",
    "signature": "public HttpMethod getMethod()",
    "source_code": "\tpublic HttpMethod getMethod() {\n\t\treturn this.method;\n\t}"
  },
  "org.springframework.http.RequestEntity#getType()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the type of the request's body.\n\t * @return the request's body type, or {@code null} if not known\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "Type",
    "signature": "public Type getType()",
    "source_code": "\tpublic Type getType() {\n\t\tif (this.type == null) {\n\t\t\tT body = getBody();\n\t\t\tif (body != null) {\n\t\t\t\treturn body.getClass();\n\t\t\t}\n\t\t}\n\t\treturn this.type;\n\t}"
  },
  "org.springframework.http.RequestEntity#getUriTemplate()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 717
    },
    "return": "String",
    "signature": "public String getUriTemplate()",
    "source_code": "\t\tpublic String getUriTemplate() {\n\t\t\treturn this.uriTemplate;\n\t\t}"
  },
  "org.springframework.http.RequestEntity#getUrl()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link URI} for the target HTTP endpoint.\n\t * <p><strong>Note:</strong> This method raises\n\t * {@link UnsupportedOperationException} if the {@code RequestEntity} was\n\t * created with a URI template and variables rather than with a {@link URI}\n\t * instance. This is because a URI cannot be created without further input\n\t * on how to expand template and encode the URI. In such cases, the\n\t * {@code URI} is prepared by the\n\t * {@link org.springframework.web.client.RestTemplate} with the help of the\n\t * {@link org.springframework.web.util.UriTemplateHandler} it is configured with.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "URI",
    "signature": "public URI getUrl()",
    "source_code": "\tpublic URI getUrl() {\n\t\tif (this.url == null) {\n\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\"The RequestEntity was created with a URI template and variables, \" +\n\t\t\t\t\t\t\t\"and there is not enough information on how to correctly expand and \" +\n\t\t\t\t\t\t\t\"encode the URI template. This will be done by the RestTemplate instead \" +\n\t\t\t\t\t\t\t\"with help from the UriTemplateHandler it is configured with.\");\n\t\t}\n\t\treturn this.url;\n\t}"
  },
  "org.springframework.http.RequestEntity#getVars()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 722
    },
    "return": "Object[]",
    "signature": "public Object[] getVars()",
    "source_code": "\t\tpublic Object[] getVars() {\n\t\t\treturn this.uriVarsArray;\n\t\t}"
  },
  "org.springframework.http.RequestEntity#hashCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 746
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\t\tpublic int hashCode() {\n\t\t\treturn (29 * super.hashCode() + ObjectUtils.nullSafeHashCode(this.uriTemplate));\n\t\t}"
  },
  "org.springframework.http.RequestEntity#header(headerName,headerValues)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 592
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder header(String headerName, String... headerValues)",
    "source_code": "\t\tpublic BodyBuilder header(String headerName, String... headerValues) {\n\t\t\tfor (String headerValue : headerValues) {\n\t\t\t\tthis.headers.add(headerName, headerValue);\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.RequestEntity#headers(headers)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 600
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder headers(@Nullable HttpHeaders headers)",
    "source_code": "\t\tpublic BodyBuilder headers(@Nullable HttpHeaders headers) {\n\t\t\tif (headers != null) {\n\t\t\t\tthis.headers.putAll(headers);\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.RequestEntity#headers(headersConsumer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headersConsumer"
    ],
    "position": {
      "column": 1,
      "line": 608
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder headers(Consumer<HttpHeaders> headersConsumer)",
    "source_code": "\t\tpublic BodyBuilder headers(Consumer<HttpHeaders> headersConsumer) {\n\t\t\theadersConsumer.accept(this.headers);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.RequestEntity#ifModifiedSince(ifModifiedSince)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ifModifiedSince"
    ],
    "position": {
      "column": 1,
      "line": 650
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder ifModifiedSince(long ifModifiedSince)",
    "source_code": "\t\tpublic BodyBuilder ifModifiedSince(long ifModifiedSince) {\n\t\t\tthis.headers.setIfModifiedSince(ifModifiedSince);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.RequestEntity#ifNoneMatch(ifNoneMatches)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ifNoneMatches"
    ],
    "position": {
      "column": 1,
      "line": 656
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder ifNoneMatch(String... ifNoneMatches)",
    "source_code": "\t\tpublic BodyBuilder ifNoneMatch(String... ifNoneMatches) {\n\t\t\tthis.headers.setIfNoneMatch(Arrays.asList(ifNoneMatches));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.RequestEntity#method(method,uriTemplate,Map<String,uriVariables)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a builder with the given HTTP method, URI template, and variables.\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param uriTemplate the uri template to use\n\t * @return the created builder\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "uriTemplate",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder method(HttpMethod method, String uriTemplate, Map<String, ?> uriVariables)",
    "source_code": "\tpublic static BodyBuilder method(HttpMethod method, String uriTemplate, Map<String, ?> uriVariables) {\n\t\treturn new DefaultBodyBuilder(method, uriTemplate, uriVariables);\n\t}"
  },
  "org.springframework.http.RequestEntity#method(method,uriTemplate,uriVariables)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a builder with the given HTTP method, URI template, and variables.\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder method(HttpMethod method, String uriTemplate, Object... uriVariables)",
    "source_code": "\tpublic static BodyBuilder method(HttpMethod method, String uriTemplate, Object... uriVariables) {\n\t\treturn new DefaultBodyBuilder(method, uriTemplate, uriVariables);\n\t}"
  },
  "org.springframework.http.RequestEntity#method(method,url)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a builder with the given method and url.\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param url the URL\n\t * @return the created builder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "url"
    ],
    "position": {
      "column": 1,
      "line": 250
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder method(HttpMethod method, URI url)",
    "source_code": "\tpublic static BodyBuilder method(HttpMethod method, URI url) {\n\t\treturn new DefaultBodyBuilder(method, url);\n\t}"
  },
  "org.springframework.http.RequestEntity#patch(uriTemplate,uriVariables)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an HTTP PATCH builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 374
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder patch(String uriTemplate, Object... uriVariables)",
    "source_code": "\tpublic static BodyBuilder patch(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.PATCH, uriTemplate, uriVariables);\n\t}"
  },
  "org.springframework.http.RequestEntity#patch(url)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an HTTP PATCH builder with the given url.\n\t * @param url the URL\n\t * @return the created builder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder patch(URI url)",
    "source_code": "\tpublic static BodyBuilder patch(URI url) {\n\t\treturn method(HttpMethod.PATCH, url);\n\t}"
  },
  "org.springframework.http.RequestEntity#post(uriTemplate,uriVariables)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an HTTP POST builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder post(String uriTemplate, Object... uriVariables)",
    "source_code": "\tpublic static BodyBuilder post(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.POST, uriTemplate, uriVariables);\n\t}"
  },
  "org.springframework.http.RequestEntity#post(url)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an HTTP POST builder with the given url.\n\t * @param url the URL\n\t * @return the created builder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder post(URI url)",
    "source_code": "\tpublic static BodyBuilder post(URI url) {\n\t\treturn method(HttpMethod.POST, url);\n\t}"
  },
  "org.springframework.http.RequestEntity#put(uriTemplate,uriVariables)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an HTTP PUT builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 354
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder put(String uriTemplate, Object... uriVariables)",
    "source_code": "\tpublic static BodyBuilder put(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.PUT, uriTemplate, uriVariables);\n\t}"
  },
  "org.springframework.http.RequestEntity#put(url)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an HTTP PUT builder with the given url.\n\t * @param url the URL\n\t * @return the created builder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url"
    ],
    "position": {
      "column": 1,
      "line": 343
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder put(URI url)",
    "source_code": "\tpublic static BodyBuilder put(URI url) {\n\t\treturn method(HttpMethod.PUT, url);\n\t}"
  },
  "org.springframework.http.RequestEntity#toString()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 751
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn format(getMethod(), getUriTemplate(), getBody(), getHeaders());\n\t\t}"
  },
  "org.springframework.http.ResponseCookie#isPartitioned()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return {@code true} if the cookie has the \"Partitioned\" attribute.\n\t * @since 6.2\n\t * @see <a href=\"https://datatracker.ietf.org/doc/html/draft-cutler-httpbis-partitioned-cookies#section-2.1\">The Partitioned attribute spec</a>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "boolean",
    "signature": "public boolean isPartitioned()",
    "source_code": "\tpublic boolean isPartitioned() {\n\t\treturn this.partitioned;\n\t}"
  },
  "org.springframework.http.ResponseCookie#partitioned(partitioned)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "partitioned"
    ],
    "position": {
      "column": 1,
      "line": 490
    },
    "return": "ResponseCookieBuilder",
    "signature": "public ResponseCookieBuilder partitioned(boolean partitioned)",
    "source_code": "\t\tpublic ResponseCookieBuilder partitioned(boolean partitioned) {\n\t\t\tthis.partitioned = partitioned;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.ResponseEntity#eTag(etag)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "etag"
    ],
    "position": {
      "column": 1,
      "line": 572
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder eTag(@Nullable String etag)",
    "source_code": "\t\tpublic BodyBuilder eTag(@Nullable String etag) {\n\t\t\tif (etag != null) {\n\t\t\t\tif (!etag.startsWith(\"\\\"\") && !etag.startsWith(\"W/\\\"\")) {\n\t\t\t\t\tetag = \"\\\"\" + etag;\n\t\t\t\t}\n\t\t\t\tif (!etag.endsWith(\"\\\"\")) {\n\t\t\t\t\tetag = etag + \"\\\"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.headers.setETag(etag);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.ResponseEntity#eTag(tag)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "tag"
    ],
    "position": {
      "column": 1,
      "line": 571
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder eTag(@Nullable String tag)",
    "source_code": "\t\tpublic BodyBuilder eTag(@Nullable String tag) {\n\t\t\tthis.headers.setETag(tag);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.UriTemplateRequestEntity": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * RequestEntity initialized with a URI template and variables instead of a {@link URI}.\n\t * @since 5.3\n\t * @param <T> the body type\n\t */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 696
    },
    "signature": "public class UriTemplateRequestEntity",
    "source_code": "\tpublic static class UriTemplateRequestEntity<T> extends RequestEntity<T> {\n\n\t\tprivate final String uriTemplate;\n\n\t\t@Nullable\n\t\tprivate final Object[] uriVarsArray;\n\n\t\t@Nullable\n\t\tprivate final Map<String, ?> uriVarsMap;\n\n\t\tUriTemplateRequestEntity(\n\t\t\t\t@Nullable T body, @Nullable MultiValueMap<String, String> headers,\n\t\t\t\t@Nullable HttpMethod method, @Nullable Type type, String uriTemplate,\n\t\t\t\t@Nullable Object[] uriVarsArray, @Nullable Map<String, ?> uriVarsMap) {\n\n\t\t\tsuper(body, headers, method, null, type);\n\t\t\tthis.uriTemplate = uriTemplate;\n\t\t\tthis.uriVarsArray = uriVarsArray;\n\t\t\tthis.uriVarsMap = uriVarsMap;\n\t\t}\n\n\t\tpublic String getUriTemplate() {\n\t\t\treturn this.uriTemplate;\n\t\t}\n\n\t\t@Nullable\n\t\tpublic Object[] getVars() {\n\t\t\treturn this.uriVarsArray;\n\t\t}\n\n\t\t@Nullable\n\t\tpublic Map<String, ?> getVarsMap() {\n\t\t\treturn this.uriVarsMap;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\tif (this == other) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!super.equals(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn (other instanceof UriTemplateRequestEntity<?> otherEntity &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.uriTemplate, otherEntity.uriTemplate) &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.uriVarsArray, otherEntity.uriVarsArray) &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.uriVarsMap, otherEntity.uriVarsMap));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn (29 * super.hashCode() + ObjectUtils.nullSafeHashCode(this.uriTemplate));\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn format(getMethod(), getUriTemplate(), getBody(), getHeaders());\n\t\t}\n\t}"
  },
  "org.springframework.http.client.<unknown>#map(b)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer map(int b)",
    "source_code": "\t\tpublic ByteBuffer map(int b) {\n\t\t\tByteBuffer byteBuffer = ByteBuffer.allocate(1);\n\t\t\tbyteBuffer.put((byte) b);\n\t\t\tbyteBuffer.flip();\n\t\t\treturn byteBuffer;\n\t\t}"
  },
  "org.springframework.http.client.<unknown>#map(b,off,len)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b",
      "off",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer map(byte[] b, int off, int len)",
    "source_code": "\t\tpublic ByteBuffer map(byte[] b, int off, int len) {\n\t\t\tByteBuffer byteBuffer = ByteBuffer.allocate(len);\n\t\t\tbyteBuffer.put(b, off, len);\n\t\t\tbyteBuffer.flip();\n\t\t\treturn byteBuffer;\n\t\t}"
  },
  "org.springframework.http.client.<unknown>#wrapInputStream(response)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "response"
    ],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "InputStream",
    "signature": "public InputStream wrapInputStream(HttpResponse<InputStream> response)",
    "source_code": "\t\tpublic InputStream wrapInputStream(HttpResponse<InputStream> response) {\n\t\t\tInputStream body = response.body();\n\t\t\tif (body == null) {\n\t\t\t\treturn body;\n\t\t\t}\n\t\t\treturn new FilterInputStream(body) {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void close() throws IOException {\n\t\t\t\t\tTimeoutHandler.this.timeoutFuture.cancel(false);\n\t\t\t\t\tsuper.close();\n\t\t\t\t}\n\t\t\t};\n\t\t}"
  },
  "org.springframework.http.client.HttpComponentsClientHttpRequestFactory#setReadTimeout(readTimeout)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the response timeout for the underlying {@link RequestConfig}.\n\t * A timeout value of 0 specifies an infinite timeout.\n\t * <p>Additional properties can be configured by specifying a\n\t * {@link RequestConfig} instance on a custom {@link HttpClient}.\n\t * @param readTimeout the timeout as a {@code Duration}.\n\t * @since 6.2\n\t * @see RequestConfig#getResponseTimeout()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "readTimeout"
    ],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "void",
    "signature": "public void setReadTimeout(Duration readTimeout)",
    "source_code": "\tpublic void setReadTimeout(Duration readTimeout) {\n\t\tAssert.notNull(readTimeout, \"ReadTimeout must not be null\");\n\t\tAssert.isTrue(!readTimeout.isNegative(), \"Timeout must be a non-negative value\");\n\t\tthis.readTimeout = readTimeout.toMillis();\n\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link ClientHttpConnector} for the Jetty Reactive Streams HttpClient.\n *\n * @author Sebastien Deleuze\n * @since 5.1\n * @see <a href=\"https://github.com/jetty-project/jetty-reactive-httpclient\">Jetty ReactiveStreams HttpClient</a>\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "signature": "public class JettyClientHttpConnector",
    "source_code": "public class JettyClientHttpConnector implements ClientHttpConnector {\n\n\tprivate final HttpClient httpClient;\n\n\tprivate DataBufferFactory bufferFactory = DefaultDataBufferFactory.sharedInstance;\n\n\n\t/**\n\t * Default constructor that creates a new instance of {@link HttpClient}.\n\t */\n\tpublic JettyClientHttpConnector() {\n\t\tthis(new HttpClient());\n\t}\n\n\t/**\n\t * Constructor with an initialized {@link HttpClient}.\n\t */\n\tpublic JettyClientHttpConnector(HttpClient httpClient) {\n\t\tthis(httpClient, null);\n\t}\n\n\t/**\n\t * Constructor with an initialized {@link HttpClient} and configures it\n\t * with the given {@link JettyResourceFactory}.\n\t * @param httpClient the {@link HttpClient} to use\n\t * @param resourceFactory the {@link JettyResourceFactory} to use\n\t * @since 5.2\n\t */\n\tpublic JettyClientHttpConnector(HttpClient httpClient, @Nullable JettyResourceFactory resourceFactory) {\n\t\tAssert.notNull(httpClient, \"HttpClient is required\");\n\t\tif (resourceFactory != null) {\n\t\t\thttpClient.setExecutor(resourceFactory.getExecutor());\n\t\t\thttpClient.setByteBufferPool(resourceFactory.getByteBufferPool());\n\t\t\thttpClient.setScheduler(resourceFactory.getScheduler());\n\t\t}\n\t\tthis.httpClient = httpClient;\n\t}\n\n\t/**\n\t * Constructor with an {@link JettyResourceFactory} that will manage shared resources.\n\t * @param resourceFactory the {@link JettyResourceFactory} to use\n\t * @param customizer the lambda used to customize the {@link HttpClient}\n\t * @deprecated as of 5.2, in favor of\n\t * {@link JettyClientHttpConnector#JettyClientHttpConnector(HttpClient, JettyResourceFactory)}\n\t */\n\t@Deprecated\n\tpublic JettyClientHttpConnector(JettyResourceFactory resourceFactory, @Nullable Consumer<HttpClient> customizer) {\n\t\tthis(new HttpClient(), resourceFactory);\n\t\tif (customizer != null) {\n\t\t\tcustomizer.accept(this.httpClient);\n\t\t}\n\t}\n\n\n\t/**\n\t * Set the buffer factory to use.\n\t */\n\tpublic void setBufferFactory(DataBufferFactory bufferFactory) {\n\t\tthis.bufferFactory = bufferFactory;\n\t}\n\n\n\t@Override\n\tpublic Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,\n\t\t\tFunction<? super ClientHttpRequest, Mono<Void>> requestCallback) {\n\n\t\tif (!uri.isAbsolute()) {\n\t\t\treturn Mono.error(new IllegalArgumentException(\"URI is not absolute: \" + uri));\n\t\t}\n\n\t\tif (!this.httpClient.isStarted()) {\n\t\t\ttry {\n\t\t\t\tthis.httpClient.start();\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\treturn Mono.error(ex);\n\t\t\t}\n\t\t}\n\n\t\tRequest jettyRequest = this.httpClient.newRequest(uri).method(method.toString());\n\t\tJettyClientHttpRequest request = new JettyClientHttpRequest(jettyRequest, this.bufferFactory);\n\n\t\treturn requestCallback.apply(request).then(execute(request));\n\t}\n\n\tprivate Mono<ClientHttpResponse> execute(JettyClientHttpRequest request) {\n\t\treturn Mono.fromDirect(request.toReactiveRequest()\n\t\t\t\t.response((reactiveResponse, chunkPublisher) -> {\n\t\t\t\t\tFlux<DataBuffer> content = Flux.from(chunkPublisher).map(this::toDataBuffer);\n\t\t\t\t\treturn Mono.just(new JettyClientHttpResponse(reactiveResponse, content));\n\t\t\t\t}));\n\t}\n\n\tprivate DataBuffer toDataBuffer(Content.Chunk chunk) {\n\t\tDataBuffer delegate = this.bufferFactory.wrap(chunk.getByteBuffer());\n\t\treturn new JettyDataBuffer(delegate, chunk);\n\t}\n\n\n\tprivate static final class JettyDataBuffer implements PooledDataBuffer {\n\n\t\tprivate final DataBuffer delegate;\n\n\t\tprivate final Content.Chunk chunk;\n\n\t\tprivate final AtomicInteger refCount = new AtomicInteger(1);\n\n\t\tpublic JettyDataBuffer(DataBuffer delegate, Content.Chunk chunk) {\n\t\t\tAssert.notNull(delegate, \"Delegate must not be null\");\n\t\t\tAssert.notNull(chunk, \"Chunk must not be null\");\n\n\t\t\tthis.delegate = delegate;\n\t\t\tthis.chunk = chunk;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isAllocated() {\n\t\t\treturn this.refCount.get() > 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic PooledDataBuffer retain() {\n\t\t\tif (this.delegate instanceof PooledDataBuffer pooledDelegate) {\n\t\t\t\tpooledDelegate.retain();\n\t\t\t}\n\t\t\tthis.chunk.retain();\n\t\t\tthis.refCount.getAndUpdate(c -> {\n\t\t\t\tif (c != 0) {\n\t\t\t\t\treturn c + 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean release() {\n\t\t\tif (this.delegate instanceof PooledDataBuffer pooledDelegate) {\n\t\t\t\tpooledDelegate.release();\n\t\t\t}\n\t\t\tthis.chunk.release();\n\t\t\tint refCount = this.refCount.updateAndGet(c -> {\n\t\t\t\tif (c != 0) {\n\t\t\t\t\treturn c - 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalStateException(\"already released \" + this);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn refCount == 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic PooledDataBuffer touch(Object hint) {\n\t\t\tif (this.delegate instanceof TouchableDataBuffer touchableDelegate) {\n\t\t\t\ttouchableDelegate.touch(hint);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\t// delegation\n\n\t\t@Override\n\t\tpublic DataBufferFactory factory() {\n\t\t\treturn this.delegate.factory();\n\t\t}\n\n\t\t@Override\n\t\tpublic int indexOf(IntPredicate predicate, int fromIndex) {\n\t\t\treturn this.delegate.indexOf(predicate, fromIndex);\n\t\t}\n\n\t\t@Override\n\t\tpublic int lastIndexOf(IntPredicate predicate, int fromIndex) {\n\t\t\treturn this.delegate.lastIndexOf(predicate, fromIndex);\n\t\t}\n\n\t\t@Override\n\t\tpublic int readableByteCount() {\n\t\t\treturn this.delegate.readableByteCount();\n\t\t}\n\n\t\t@Override\n\t\tpublic int writableByteCount() {\n\t\t\treturn this.delegate.writableByteCount();\n\t\t}\n\n\t\t@Override\n\t\tpublic int capacity() {\n\t\t\treturn this.delegate.capacity();\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic DataBuffer capacity(int capacity) {\n\t\t\tthis.delegate.capacity(capacity);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer ensureWritable(int capacity) {\n\t\t\tthis.delegate.ensureWritable(capacity);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic int readPosition() {\n\t\t\treturn this.delegate.readPosition();\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer readPosition(int readPosition) {\n\t\t\tthis.delegate.readPosition(readPosition);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic int writePosition() {\n\t\t\treturn this.delegate.writePosition();\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer writePosition(int writePosition) {\n\t\t\tthis.delegate.writePosition(writePosition);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic byte getByte(int index) {\n\t\t\treturn this.delegate.getByte(index);\n\t\t}\n\n\t\t@Override\n\t\tpublic byte read() {\n\t\t\treturn this.delegate.read();\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer read(byte[] destination) {\n\t\t\tthis.delegate.read(destination);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer read(byte[] destination, int offset, int length) {\n\t\t\tthis.delegate.read(destination, offset, length);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer write(byte b) {\n\t\t\tthis.delegate.write(b);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer write(byte[] source) {\n\t\t\tthis.delegate.write(source);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer write(byte[] source, int offset, int length) {\n\t\t\tthis.delegate.write(source, offset, length);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer write(DataBuffer... buffers) {\n\t\t\tthis.delegate.write(buffers);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer write(ByteBuffer... buffers) {\n\t\t\tthis.delegate.write(buffers);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic DataBuffer slice(int index, int length) {\n\t\t\tDataBuffer delegateSlice = this.delegate.slice(index, length);\n\t\t\tthis.chunk.retain();\n\t\t\treturn new JettyDataBuffer(delegateSlice, this.chunk);\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer split(int index) {\n\t\t\tDataBuffer delegateSplit = this.delegate.split(index);\n\t\t\tthis.chunk.retain();\n\t\t\treturn new JettyDataBuffer(delegateSplit, this.chunk);\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic ByteBuffer asByteBuffer() {\n\t\t\treturn this.delegate.asByteBuffer();\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic ByteBuffer asByteBuffer(int index, int length) {\n\t\t\treturn this.delegate.asByteBuffer(index, length);\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic ByteBuffer toByteBuffer(int index, int length) {\n\t\t\treturn this.delegate.toByteBuffer(index, length);\n\t\t}\n\n\t\t@Override\n\t\tpublic void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length) {\n\t\t\tthis.delegate.toByteBuffer(srcPos, dest, destPos, length);\n\t\t}\n\n\t\t@Override\n\t\tpublic ByteBufferIterator readableByteBuffers() {\n\t\t\tByteBufferIterator delegateIterator = this.delegate.readableByteBuffers();\n\t\t\treturn new JettyByteBufferIterator(delegateIterator, this.chunk);\n\t\t}\n\n\t\t@Override\n\t\tpublic ByteBufferIterator writableByteBuffers() {\n\t\t\tByteBufferIterator delegateIterator = this.delegate.writableByteBuffers();\n\t\t\treturn new JettyByteBufferIterator(delegateIterator, this.chunk);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString(int index, int length, Charset charset) {\n\t\t\treturn this.delegate.toString(index, length, charset);\n\t\t}\n\n\n\t\tprivate static final class JettyByteBufferIterator implements ByteBufferIterator {\n\n\t\t\tprivate final ByteBufferIterator delegate;\n\n\t\t\tprivate final Content.Chunk chunk;\n\n\t\t\tpublic JettyByteBufferIterator(ByteBufferIterator delegate, Content.Chunk chunk) {\n\t\t\t\tAssert.notNull(delegate, \"Delegate must not be null\");\n\t\t\t\tAssert.notNull(chunk, \"Chunk must not be null\");\n\n\t\t\t\tthis.delegate = delegate;\n\t\t\t\tthis.chunk = chunk;\n\t\t\t\tthis.chunk.retain();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void close() {\n\t\t\t\tthis.delegate.close();\n\t\t\t\tthis.chunk.release();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn this.delegate.hasNext();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ByteBuffer next() {\n\t\t\t\treturn this.delegate.next();\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#asByteBuffer()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer asByteBuffer()",
    "source_code": "\t\tpublic ByteBuffer asByteBuffer() {\n\t\t\treturn this.delegate.asByteBuffer();\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#asByteBuffer(index,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 353
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer asByteBuffer(int index, int length)",
    "source_code": "\t\tpublic ByteBuffer asByteBuffer(int index, int length) {\n\t\t\treturn this.delegate.asByteBuffer(index, length);\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#capacity()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "int",
    "signature": "public int capacity()",
    "source_code": "\t\tpublic int capacity() {\n\t\t\treturn this.delegate.capacity();\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#capacity(capacity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 245
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer capacity(int capacity)",
    "source_code": "\t\tpublic DataBuffer capacity(int capacity) {\n\t\t\tthis.delegate.capacity(capacity);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#close()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 402
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\t\t\tpublic void close() {\n\t\t\t\tthis.delegate.close();\n\t\t\t\tthis.chunk.release();\n\t\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#connect(method,uri,ClientHttpRequest,requestCallback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "uri",
      "ClientHttpRequest",
      "requestCallback"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "Mono<ClientHttpResponse>",
    "signature": "public Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,\n\t\t\tFunction<? super ClientHttpRequest, Mono<Void>> requestCallback)",
    "source_code": "\tpublic Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#ensureWritable(capacity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer ensureWritable(int capacity)",
    "source_code": "\t\tpublic DataBuffer ensureWritable(int capacity) {\n\t\t\tthis.delegate.ensureWritable(capacity);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#factory()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "DataBufferFactory",
    "signature": "public DataBufferFactory factory()",
    "source_code": "\t\tpublic DataBufferFactory factory() {\n\t\t\treturn this.delegate.factory();\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#getByte(index)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index"
    ],
    "position": {
      "column": 1,
      "line": 279
    },
    "return": "byte",
    "signature": "public byte getByte(int index)",
    "source_code": "\t\tpublic byte getByte(int index) {\n\t\t\treturn this.delegate.getByte(index);\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#hasNext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 408
    },
    "return": "boolean",
    "signature": "public boolean hasNext()",
    "source_code": "\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn this.delegate.hasNext();\n\t\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#indexOf(predicate,fromIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "fromIndex"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "int",
    "signature": "public int indexOf(IntPredicate predicate, int fromIndex)",
    "source_code": "\t\tpublic int indexOf(IntPredicate predicate, int fromIndex) {\n\t\t\treturn this.delegate.indexOf(predicate, fromIndex);\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#isAllocated()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "boolean",
    "signature": "public boolean isAllocated()",
    "source_code": "\t\tpublic boolean isAllocated() {\n\t\t\treturn this.refCount.get() > 0;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#lastIndexOf(predicate,fromIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "fromIndex"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "int",
    "signature": "public int lastIndexOf(IntPredicate predicate, int fromIndex)",
    "source_code": "\t\tpublic int lastIndexOf(IntPredicate predicate, int fromIndex) {\n\t\t\treturn this.delegate.lastIndexOf(predicate, fromIndex);\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#next()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 413
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer next()",
    "source_code": "\t\t\tpublic ByteBuffer next() {\n\t\t\t\treturn this.delegate.next();\n\t\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#read()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "byte",
    "signature": "public byte read()",
    "source_code": "\t\tpublic byte read() {\n\t\t\treturn this.delegate.read();\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#read(destination)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 289
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer read(byte[] destination)",
    "source_code": "\t\tpublic DataBuffer read(byte[] destination) {\n\t\t\tthis.delegate.read(destination);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#read(destination,offset,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 295
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer read(byte[] destination, int offset, int length)",
    "source_code": "\t\tpublic DataBuffer read(byte[] destination, int offset, int length) {\n\t\t\tthis.delegate.read(destination, offset, length);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#readPosition()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 257
    },
    "return": "int",
    "signature": "public int readPosition()",
    "source_code": "\t\tpublic int readPosition() {\n\t\t\treturn this.delegate.readPosition();\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#readPosition(readPosition)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "readPosition"
    ],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer readPosition(int readPosition)",
    "source_code": "\t\tpublic DataBuffer readPosition(int readPosition) {\n\t\t\tthis.delegate.readPosition(readPosition);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#readableByteBuffers()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 369
    },
    "return": "ByteBufferIterator",
    "signature": "public ByteBufferIterator readableByteBuffers()",
    "source_code": "\t\tpublic ByteBufferIterator readableByteBuffers() {\n\t\t\tByteBufferIterator delegateIterator = this.delegate.readableByteBuffers();\n\t\t\treturn new JettyByteBufferIterator(delegateIterator, this.chunk);\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#readableByteCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "int",
    "signature": "public int readableByteCount()",
    "source_code": "\t\tpublic int readableByteCount() {\n\t\t\treturn this.delegate.readableByteCount();\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#release()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "boolean",
    "signature": "public boolean release()",
    "source_code": "\t\tpublic boolean release() {\n\t\t\tif (this.delegate instanceof PooledDataBuffer pooledDelegate) {\n\t\t\t\tpooledDelegate.release();\n\t\t\t}\n\t\t\tthis.chunk.release();\n\t\t\tint refCount = this.refCount.updateAndGet(c -> {\n\t\t\t\tif (c != 0) {\n\t\t\t\t\treturn c - 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalStateException(\"already released \" + this);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn refCount == 0;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#retain()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "PooledDataBuffer",
    "signature": "public PooledDataBuffer retain()",
    "source_code": "\t\tpublic PooledDataBuffer retain() {\n\t\t\tif (this.delegate instanceof PooledDataBuffer pooledDelegate) {\n\t\t\t\tpooledDelegate.retain();\n\t\t\t}\n\t\t\tthis.chunk.retain();\n\t\t\tthis.refCount.getAndUpdate(c -> {\n\t\t\t\tif (c != 0) {\n\t\t\t\t\treturn c + 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#setBufferFactory(bufferFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the buffer factory to use.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bufferFactory"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "void",
    "signature": "public void setBufferFactory(DataBufferFactory bufferFactory)",
    "source_code": "\tpublic void setBufferFactory(DataBufferFactory bufferFactory) {\n\t\tthis.bufferFactory = bufferFactory;\n\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#slice(index,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 332
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer slice(int index, int length)",
    "source_code": "\t\tpublic DataBuffer slice(int index, int length) {\n\t\t\tDataBuffer delegateSlice = this.delegate.slice(index, length);\n\t\t\tthis.chunk.retain();\n\t\t\treturn new JettyDataBuffer(delegateSlice, this.chunk);\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#split(index)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index"
    ],
    "position": {
      "column": 1,
      "line": 339
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer split(int index)",
    "source_code": "\t\tpublic DataBuffer split(int index) {\n\t\t\tDataBuffer delegateSplit = this.delegate.split(index);\n\t\t\tthis.chunk.retain();\n\t\t\treturn new JettyDataBuffer(delegateSplit, this.chunk);\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#toByteBuffer(index,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 359
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer toByteBuffer(int index, int length)",
    "source_code": "\t\tpublic ByteBuffer toByteBuffer(int index, int length) {\n\t\t\treturn this.delegate.toByteBuffer(index, length);\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#toByteBuffer(srcPos,dest,destPos,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "srcPos",
      "dest",
      "destPos",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 364
    },
    "return": "void",
    "signature": "public void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length)",
    "source_code": "\t\tpublic void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length) {\n\t\t\tthis.delegate.toByteBuffer(srcPos, dest, destPos, length);\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#toString(index,length,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 381
    },
    "return": "String",
    "signature": "public String toString(int index, int length, Charset charset)",
    "source_code": "\t\tpublic String toString(int index, int length, Charset charset) {\n\t\t\treturn this.delegate.toString(index, length, charset);\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#touch(hint)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hint"
    ],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "PooledDataBuffer",
    "signature": "public PooledDataBuffer touch(Object hint)",
    "source_code": "\t\tpublic PooledDataBuffer touch(Object hint) {\n\t\t\tif (this.delegate instanceof TouchableDataBuffer touchableDelegate) {\n\t\t\t\ttouchableDelegate.touch(hint);\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#writableByteBuffers()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 375
    },
    "return": "ByteBufferIterator",
    "signature": "public ByteBufferIterator writableByteBuffers()",
    "source_code": "\t\tpublic ByteBufferIterator writableByteBuffers() {\n\t\t\tByteBufferIterator delegateIterator = this.delegate.writableByteBuffers();\n\t\t\treturn new JettyByteBufferIterator(delegateIterator, this.chunk);\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#writableByteCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 234
    },
    "return": "int",
    "signature": "public int writableByteCount()",
    "source_code": "\t\tpublic int writableByteCount() {\n\t\t\treturn this.delegate.writableByteCount();\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#write(b)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b"
    ],
    "position": {
      "column": 1,
      "line": 301
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer write(byte b)",
    "source_code": "\t\tpublic DataBuffer write(byte b) {\n\t\t\tthis.delegate.write(b);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#write(buffers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "buffers"
    ],
    "position": {
      "column": 1,
      "line": 325
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer write(ByteBuffer... buffers)",
    "source_code": "\t\tpublic DataBuffer write(ByteBuffer... buffers) {\n\t\t\tthis.delegate.write(buffers);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#write(source)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source"
    ],
    "position": {
      "column": 1,
      "line": 307
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer write(byte[] source)",
    "source_code": "\t\tpublic DataBuffer write(byte[] source) {\n\t\t\tthis.delegate.write(source);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#write(source,offset,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 313
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer write(byte[] source, int offset, int length)",
    "source_code": "\t\tpublic DataBuffer write(byte[] source, int offset, int length) {\n\t\t\tthis.delegate.write(source, offset, length);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#writePosition()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 268
    },
    "return": "int",
    "signature": "public int writePosition()",
    "source_code": "\t\tpublic int writePosition() {\n\t\t\treturn this.delegate.writePosition();\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#writePosition(writePosition)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "writePosition"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer writePosition(int writePosition)",
    "source_code": "\t\tpublic DataBuffer writePosition(int writePosition) {\n\t\t\tthis.delegate.writePosition(writePosition);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.codec.Builder": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * A mutable builder for a {@code ServerSentEvent}.\n\t *\n\t * @param <T> the type of data that this event contains\n\t */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 181
    },
    "signature": "public interface Builder",
    "source_code": "\tpublic interface Builder<T> {\n\n\t\t/**\n\t\t * Set the value of the {@code id} field.\n\t\t * @param id the value of the id field\n\t\t * @return {@code this} builder\n\t\t */\n\t\tBuilder<T> id(String id);\n\n\t\t/**\n\t\t * Set the value of the {@code event} field.\n\t\t * @param event the value of the event field\n\t\t * @return {@code this} builder\n\t\t */\n\t\tBuilder<T> event(String event);\n\n\t\t/**\n\t\t * Set the value of the {@code retry} field.\n\t\t * @param retry the value of the retry field\n\t\t * @return {@code this} builder\n\t\t */\n\t\tBuilder<T> retry(Duration retry);\n\n\t\t/**\n\t\t * Set SSE comment. If a multi-line comment is provided, it will be turned into multiple\n\t\t * SSE comment lines as defined in Server-Sent Events W3C recommendation.\n\t\t * @param comment the comment to set\n\t\t * @return {@code this} builder\n\t\t */\n\t\tBuilder<T> comment(String comment);\n\n\t\t/**\n\t\t * Set the value of the {@code data} field. If the {@code data} argument is a multi-line\n\t\t * {@code String}, it will be turned into multiple {@code data} field lines as defined\n\t\t * in the Server-Sent Events W3C recommendation. If {@code data} is not a String, it will\n\t\t * be {@linkplain org.springframework.http.codec.json.Jackson2JsonEncoder encoded} into JSON.\n\t\t * @param data the value of the data field\n\t\t * @return {@code this} builder\n\t\t */\n\t\tBuilder<T> data(@Nullable T data);\n\n\t\t/**\n\t\t * Builds the event.\n\t\t * @return the built event\n\t\t */\n\t\tServerSentEvent<T> build();\n\t}"
  },
  "org.springframework.http.codec.EMPTY_BYTES": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "signature": "protected byte[] EMPTY_BYTES",
    "source_code": "\tprotected static final byte[] EMPTY_BYTES = new byte[0];",
    "type": "byte[]"
  },
  "org.springframework.http.codec.KotlinSerializationStringEncoder": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Abstract base class for {@link Encoder} implementations that defer to Kotlin\n * {@linkplain StringFormat string serializers}.\n *\n * @author Sebastien Deleuze\n * @author Iain Henderson\n * @author Arjen Poutsma\n * @since 6.0\n * @param <T> the type of {@link StringFormat}\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "signature": "public class KotlinSerializationStringEncoder",
    "source_code": "public abstract class KotlinSerializationStringEncoder<T extends StringFormat> extends KotlinSerializationSupport<T>"
  },
  "org.springframework.http.codec.KotlinSerializationStringEncoder#canEncode(elementType,mimeType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "boolean",
    "signature": "public boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType)",
    "source_code": "\tpublic boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType) {\n\t\treturn canSerialize(elementType, mimeType);\n\t}"
  },
  "org.springframework.http.codec.KotlinSerializationStringEncoder#encode(inputStream,bufferFactory,elementType,mimeType,Map<String,hints)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inputStream",
      "bufferFactory",
      "elementType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> encode(Publisher<?> inputStream, DataBufferFactory bufferFactory,\n\t\t\tResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic Flux<DataBuffer> encode(Publisher<?> inputStream, DataBufferFactory bufferFactory,"
  },
  "org.springframework.http.codec.KotlinSerializationStringEncoder#encodeNonStream(inputStream,bufferFactory,elementType,mimeType,Map<String,hints)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "inputStream",
      "bufferFactory",
      "elementType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "Flux<DataBuffer>",
    "signature": "protected Flux<DataBuffer> encodeNonStream(Publisher<?> inputStream, DataBufferFactory bufferFactory,\n\t\t\tResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tprotected Flux<DataBuffer> encodeNonStream(Publisher<?> inputStream, DataBufferFactory bufferFactory,"
  },
  "org.springframework.http.codec.KotlinSerializationStringEncoder#encodeStreamingValue(value,bufferFactory,valueType,mimeType,Map<String,hints,prefix,suffix)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "bufferFactory",
      "valueType",
      "mimeType",
      "Map<String",
      "hints",
      "prefix",
      "suffix"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "DataBuffer",
    "signature": "protected DataBuffer encodeStreamingValue(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType,\n\t\t\t@Nullable Map<String, Object> hints, byte[] prefix, byte[] suffix)",
    "source_code": "\tprotected DataBuffer encodeStreamingValue(Object value, DataBufferFactory bufferFactory,"
  },
  "org.springframework.http.codec.KotlinSerializationStringEncoder#encodeValue(value,bufferFactory,valueType,mimeType,Map<String,hints)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "bufferFactory",
      "valueType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer encodeValue(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType,\n\t\t\t@Nullable Map<String, Object> hints)",
    "source_code": "\tpublic DataBuffer encodeValue(Object value, DataBufferFactory bufferFactory,"
  },
  "org.springframework.http.codec.KotlinSerializationStringEncoder#getEncodableMimeTypes()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "List<MimeType>",
    "signature": "public List<MimeType> getEncodableMimeTypes()",
    "source_code": "\tpublic List<MimeType> getEncodableMimeTypes() {\n\t\treturn supportedMimeTypes();\n\t}"
  },
  "org.springframework.http.codec.KotlinSerializationStringEncoder#getEncodableMimeTypes(elementType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "List<MimeType>",
    "signature": "public List<MimeType> getEncodableMimeTypes(ResolvableType elementType)",
    "source_code": "\tpublic List<MimeType> getEncodableMimeTypes(ResolvableType elementType) {\n\t\treturn supportedMimeTypes();\n\t}"
  },
  "org.springframework.http.codec.KotlinSerializationStringEncoder#setStreamingMediaTypes(streamingMediaTypes)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set streaming {@link MediaType MediaTypes}.\n\t * @param streamingMediaTypes streaming {@link MediaType MediaTypes}\n\t * @since 6.1.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "streamingMediaTypes"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "void",
    "signature": "public void setStreamingMediaTypes(Collection<MediaType> streamingMediaTypes)",
    "source_code": "\tpublic void setStreamingMediaTypes(Collection<MediaType> streamingMediaTypes) {\n\t\tthis.streamingMediaTypes.clear();\n\t\tthis.streamingMediaTypes.addAll(streamingMediaTypes);\n\t}"
  },
  "org.springframework.http.codec.KotlinSerializationSupport": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Base class providing support methods for encoding and decoding with Kotlin\n * serialization.\n *\n * @author Sebastien Deleuze\n * @author Iain Henderson\n * @author Arjen Poutsma\n * @since 6.0\n * @param <T> the type of {@link SerialFormat}\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "signature": "public class KotlinSerializationSupport",
    "source_code": "public abstract class KotlinSerializationSupport<T extends SerialFormat> {\n\n\tprivate final Map<Type, KSerializer<Object>> typeSerializerCache = new ConcurrentReferenceHashMap<>();\n\n\tprivate final Map<KType, KSerializer<Object>> kTypeSerializerCache = new ConcurrentReferenceHashMap<>();\n\n\n\tprivate final T format;\n\n\tprivate final List<MimeType> supportedMimeTypes;\n\n\t/**\n\t * Creates a new instance of this support class with the given format\n\t * and supported mime types.\n\t */\n\tprotected KotlinSerializationSupport(T format, MimeType... supportedMimeTypes) {\n\t\tthis.format = format;\n\t\tthis.supportedMimeTypes = Arrays.asList(supportedMimeTypes);\n\t}\n\n\t/**\n\t * Returns the format.\n\t */\n\tprotected final T format() {\n\t\treturn this.format;\n\t}\n\n\t/**\n\t * Returns the supported mime types.\n\t */\n\tprotected final List<MimeType> supportedMimeTypes() {\n\t\treturn this.supportedMimeTypes;\n\t}\n\n\t/**\n\t * Indicates whether the given type can be serialized using Kotlin\n\t * serialization.\n\t * @param type the type to be serialized\n\t * @param mimeType the mimetype to use (can be {@code null})\n\t * @return {@code true} if {@code type} can be serialized; false otherwise\n\t */\n\tprotected final boolean canSerialize(ResolvableType type, @Nullable MimeType mimeType) {\n\t\tKSerializer<Object> serializer = serializer(type);\n\t\tif (serializer == null) {\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn (supports(mimeType) && !String.class.isAssignableFrom(type.toClass()) &&\n\t\t\t\t\t!ServerSentEvent.class.isAssignableFrom(type.toClass()));\n\t\t}\n\n\t}\n\n\tprivate boolean supports(@Nullable MimeType mimeType) {\n\t\tif (mimeType == null) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (MimeType candidate : this.supportedMimeTypes) {\n\t\t\tif (candidate.isCompatibleWith(mimeType)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\t/**\n\t * Returns the serializer that can (de)serialize instances of the given\n\t * type. If no serializer can be found, or if {@code resolvableType} is\n\t * a <a href=\"https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/polymorphism.md#open-polymorphism\">open polymorphic</a>\n\t * type, {@code null} is returned.\n\t * @param resolvableType the type to find a serializer for\n\t * @return a resolved serializer for the given type, or {@code null}\n\t */\n\t@Nullable\n\tprotected final KSerializer<Object> serializer(ResolvableType resolvableType) {\n\t\tif (resolvableType.getSource() instanceof MethodParameter parameter) {\n\t\t\tMethod method = parameter.getMethod();\n\t\t\tAssert.notNull(method, \"Method must not be null\");\n\t\t\tif (KotlinDetector.isKotlinType(method.getDeclaringClass())) {\n\t\t\t\tKFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);\n\t\t\t\tif (function != null) {\n\t\t\t\t\tKType type = (parameter.getParameterIndex() == -1 ? function.getReturnType() :\n\t\t\t\t\t\t\tKCallables.getValueParameters(function).get(parameter.getParameterIndex()).getType());\n\t\t\t\t\tKSerializer<Object> serializer = this.kTypeSerializerCache.get(type);\n\t\t\t\t\tif (serializer == null) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tserializer = SerializersKt.serializerOrNull(this.format.getSerializersModule(), type);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (IllegalArgumentException ignored) {\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (serializer != null) {\n\t\t\t\t\t\t\tif (hasPolymorphism(serializer.getDescriptor(), new HashSet<>())) {\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.kTypeSerializerCache.put(type, serializer);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn serializer;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tType type = resolvableType.getType();\n\t\tKSerializer<Object> serializer = this.typeSerializerCache.get(type);\n\t\tif (serializer == null) {\n\t\t\ttry {\n\t\t\t\tserializer = SerializersKt.serializerOrNull(this.format.getSerializersModule(), type);\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ignored) {\n\t\t\t}\n\t\t\tif (serializer != null) {\n\t\t\t\tif (hasPolymorphism(serializer.getDescriptor(), new HashSet<>())) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tthis.typeSerializerCache.put(type, serializer);\n\t\t\t}\n\t\t}\n\t\treturn serializer;\n\t}\n\n\tprivate static boolean hasPolymorphism(SerialDescriptor descriptor, Set<String> alreadyProcessed) {\n\t\talreadyProcessed.add(descriptor.getSerialName());\n\t\tif (descriptor.getKind().equals(PolymorphicKind.OPEN.INSTANCE)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (int i = 0 ; i < descriptor.getElementsCount() ; i++) {\n\t\t\tSerialDescriptor elementDescriptor = descriptor.getElementDescriptor(i);\n\t\t\tif (!alreadyProcessed.contains(elementDescriptor.getSerialName()) && hasPolymorphism(elementDescriptor, alreadyProcessed)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n}"
  },
  "org.springframework.http.codec.KotlinSerializationSupport#canSerialize(type,mimeType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Indicates whether the given type can be serialized using Kotlin\n\t * serialization.\n\t * @param type the type to be serialized\n\t * @param mimeType the mimetype to use (can be {@code null})\n\t * @return {@code true} if {@code type} can be serialized; false otherwise\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "type",
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "boolean",
    "signature": "protected boolean canSerialize(ResolvableType type, @Nullable MimeType mimeType)",
    "source_code": "\tprotected final boolean canSerialize(ResolvableType type, @Nullable MimeType mimeType) {\n\t\tKSerializer<Object> serializer = serializer(type);\n\t\tif (serializer == null) {\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn (supports(mimeType) && !String.class.isAssignableFrom(type.toClass()) &&\n\t\t\t\t\t!ServerSentEvent.class.isAssignableFrom(type.toClass()));\n\t\t}\n\n\t}"
  },
  "org.springframework.http.codec.KotlinSerializationSupport#format()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns the format.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "T",
    "signature": "protected T format()",
    "source_code": "\tprotected final T format() {\n\t\treturn this.format;\n\t}"
  },
  "org.springframework.http.codec.KotlinSerializationSupport#serializer(resolvableType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns the serializer that can (de)serialize instances of the given\n\t * type. If no serializer can be found, or if {@code resolvableType} is\n\t * a <a href=\"https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/polymorphism.md#open-polymorphism\">open polymorphic</a>\n\t * type, {@code null} is returned.\n\t * @param resolvableType the type to find a serializer for\n\t * @return a resolved serializer for the given type, or {@code null}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resolvableType"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "KSerializer<Object>",
    "signature": "protected KSerializer<Object> serializer(ResolvableType resolvableType)",
    "source_code": "\tprotected final KSerializer<Object> serializer(ResolvableType resolvableType) {\n\t\tif (resolvableType.getSource() instanceof MethodParameter parameter) {\n\t\t\tMethod method = parameter.getMethod();\n\t\t\tAssert.notNull(method, \"Method must not be null\");\n\t\t\tif (KotlinDetector.isKotlinType(method.getDeclaringClass())) {\n\t\t\t\tKFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);\n\t\t\t\tif (function != null) {\n\t\t\t\t\tKType type = (parameter.getParameterIndex() == -1 ? function.getReturnType() :\n\t\t\t\t\t\t\tKCallables.getValueParameters(function).get(parameter.getParameterIndex()).getType());\n\t\t\t\t\tKSerializer<Object> serializer = this.kTypeSerializerCache.get(type);\n\t\t\t\t\tif (serializer == null) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tserializer = SerializersKt.serializerOrNull(this.format.getSerializersModule(), type);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (IllegalArgumentException ignored) {\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (serializer != null) {\n\t\t\t\t\t\t\tif (hasPolymorphism(serializer.getDescriptor(), new HashSet<>())) {\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.kTypeSerializerCache.put(type, serializer);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn serializer;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tType type = resolvableType.getType();\n\t\tKSerializer<Object> serializer = this.typeSerializerCache.get(type);\n\t\tif (serializer == null) {\n\t\t\ttry {\n\t\t\t\tserializer = SerializersKt.serializerOrNull(this.format.getSerializersModule(), type);\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ignored) {\n\t\t\t}\n\t\t\tif (serializer != null) {\n\t\t\t\tif (hasPolymorphism(serializer.getDescriptor(), new HashSet<>())) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tthis.typeSerializerCache.put(type, serializer);\n\t\t\t}\n\t\t}\n\t\treturn serializer;\n\t}"
  },
  "org.springframework.http.codec.KotlinSerializationSupport#supportedMimeTypes()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns the supported mime types.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "List<MimeType>",
    "signature": "protected List<MimeType> supportedMimeTypes()",
    "source_code": "\tprotected final List<MimeType> supportedMimeTypes() {\n\t\treturn this.supportedMimeTypes;\n\t}"
  },
  "org.springframework.http.codec.ResourceHttpMessageWriter#addHeaders(message,resource,contentType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Adds the default headers for the given resource to the given message.\n\t * @since 6.0\n\t * @deprecated since 6.1, in favor of {@link #addDefaultHeaders(ReactiveHttpOutputMessage, Resource, MediaType, Map)},\n\t * for removal = 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "resource",
      "contentType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "void",
    "signature": "public void addHeaders(ReactiveHttpOutputMessage message, Resource resource, @Nullable MediaType contentType, Map<String, Object> hints)",
    "source_code": "\tpublic void addHeaders(ReactiveHttpOutputMessage message, Resource resource, @Nullable MediaType contentType, Map<String, Object> hints) {\n\t\taddDefaultHeaders(message, resource, contentType, hints).block();\n\t}"
  },
  "org.springframework.http.codec.ServerSentEvent": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Representation for a Server-Sent Event for use with Spring's reactive Web support.\n * {@code Flux<ServerSentEvent>} or {@code Observable<ServerSentEvent>} is the\n * reactive equivalent to Spring MVC's {@code SseEmitter}.\n *\n * @author Sebastien Deleuze\n * @author Arjen Poutsma\n * @since 5.0\n * @param <T> the type of data that this event contains\n * @see ServerSentEventHttpMessageWriter\n * @see <a href=\"https://www.w3.org/TR/eventsource/\">Server-Sent Events W3C recommendation</a>\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "signature": "public class ServerSentEvent",
    "source_code": "public final class ServerSentEvent<T> {\n\n\t@Nullable\n\tprivate final String id;\n\n\t@Nullable\n\tprivate final String event;\n\n\t@Nullable\n\tprivate final Duration retry;\n\n\t@Nullable\n\tprivate final String comment;\n\n\t@Nullable\n\tprivate final T data;\n\n\n\tprivate ServerSentEvent(@Nullable String id, @Nullable String event, @Nullable Duration retry,\n\t\t\t@Nullable String comment, @Nullable T data) {\n\n\t\tthis.id = id;\n\t\tthis.event = event;\n\t\tthis.retry = retry;\n\t\tthis.comment = comment;\n\t\tthis.data = data;\n\t}\n\n\n\t/**\n\t * Return the {@code id} field of this event, if available.\n\t */\n\t@Nullable\n\tpublic String id() {\n\t\treturn this.id;\n\t}\n\n\t/**\n\t * Return the {@code event} field of this event, if available.\n\t */\n\t@Nullable\n\tpublic String event() {\n\t\treturn this.event;\n\t}\n\n\t/**\n\t * Return the {@code retry} field of this event, if available.\n\t */\n\t@Nullable\n\tpublic Duration retry() {\n\t\treturn this.retry;\n\t}\n\n\t/**\n\t * Return the comment of this event, if available.\n\t */\n\t@Nullable\n\tpublic String comment() {\n\t\treturn this.comment;\n\t}\n\n\t/**\n\t * Return the {@code data} field of this event, if available.\n\t */\n\t@Nullable\n\tpublic T data() {\n\t\treturn this.data;\n\t}\n\n\t/**\n\t * Return a StringBuilder with the id, event, retry, and comment fields fully\n\t * serialized, and also appending \"data:\" if there is data.\n\t * @since 6.2.1\n\t */\n\tpublic String format() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif (this.id != null) {\n\t\t\tappendAttribute(\"id\", this.id, sb);\n\t\t}\n\t\tif (this.event != null) {\n\t\t\tappendAttribute(\"event\", this.event, sb);\n\t\t}\n\t\tif (this.retry != null) {\n\t\t\tappendAttribute(\"retry\", this.retry.toMillis(), sb);\n\t\t}\n\t\tif (this.comment != null) {\n\t\t\tsb.append(':').append(StringUtils.replace(this.comment, \"\\n\", \"\\n:\")).append('\\n');\n\t\t}\n\t\tif (this.data != null) {\n\t\t\tsb.append(\"data:\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate void appendAttribute(String fieldName, Object fieldValue, StringBuilder sb) {\n\t\tsb.append(fieldName).append(':').append(fieldValue).append('\\n');\n\t}\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof ServerSentEvent<?> that &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.id, that.id) &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.event, that.event) &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.retry, that.retry) &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.comment, that.comment) &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.data, that.data)));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn ObjectUtils.nullSafeHash(this.id, this.event, this.retry, this.comment, this.data);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn (\"ServerSentEvent [id = '\" + this.id + \"', event='\" + this.event + \"', retry=\" +\n\t\t\t\tthis.retry + \", comment='\" + this.comment + \"', data=\" + this.data + ']');\n\t}\n\n\n\t/**\n\t * Return a builder for a {@code ServerSentEvent}.\n\t * @param <T> the type of data that this event contains\n\t * @return the builder\n\t */\n\tpublic static <T> Builder<T> builder() {\n\t\treturn new BuilderImpl<>();\n\t}\n\n\t/**\n\t * Return a builder for a {@code ServerSentEvent}, populated with the given {@linkplain #data() data}.\n\t * @param <T> the type of data that this event contains\n\t * @return the builder\n\t */\n\tpublic static <T> Builder<T> builder(T data) {\n\t\treturn new BuilderImpl<>(data);\n\t}\n\n\n\t/**\n\t * A mutable builder for a {@code ServerSentEvent}.\n\t *\n\t * @param <T> the type of data that this event contains\n\t */\n\tpublic interface Builder<T> {\n\n\t\t/**\n\t\t * Set the value of the {@code id} field.\n\t\t * @param id the value of the id field\n\t\t * @return {@code this} builder\n\t\t */\n\t\tBuilder<T> id(String id);\n\n\t\t/**\n\t\t * Set the value of the {@code event} field.\n\t\t * @param event the value of the event field\n\t\t * @return {@code this} builder\n\t\t */\n\t\tBuilder<T> event(String event);\n\n\t\t/**\n\t\t * Set the value of the {@code retry} field.\n\t\t * @param retry the value of the retry field\n\t\t * @return {@code this} builder\n\t\t */\n\t\tBuilder<T> retry(Duration retry);\n\n\t\t/**\n\t\t * Set SSE comment. If a multi-line comment is provided, it will be turned into multiple\n\t\t * SSE comment lines as defined in Server-Sent Events W3C recommendation.\n\t\t * @param comment the comment to set\n\t\t * @return {@code this} builder\n\t\t */\n\t\tBuilder<T> comment(String comment);\n\n\t\t/**\n\t\t * Set the value of the {@code data} field. If the {@code data} argument is a multi-line\n\t\t * {@code String}, it will be turned into multiple {@code data} field lines as defined\n\t\t * in the Server-Sent Events W3C recommendation. If {@code data} is not a String, it will\n\t\t * be {@linkplain org.springframework.http.codec.json.Jackson2JsonEncoder encoded} into JSON.\n\t\t * @param data the value of the data field\n\t\t * @return {@code this} builder\n\t\t */\n\t\tBuilder<T> data(@Nullable T data);\n\n\t\t/**\n\t\t * Builds the event.\n\t\t * @return the built event\n\t\t */\n\t\tServerSentEvent<T> build();\n\t}\n\n\n\tprivate static class BuilderImpl<T> implements Builder<T> {\n\n\t\t@Nullable\n\t\tprivate String id;\n\n\t\t@Nullable\n\t\tprivate String event;\n\n\t\t@Nullable\n\t\tprivate Duration retry;\n\n\t\t@Nullable\n\t\tprivate String comment;\n\n\t\t@Nullable\n\t\tprivate T data;\n\n\t\tpublic BuilderImpl() {\n\t\t}\n\n\t\tpublic BuilderImpl(T data) {\n\t\t\tthis.data = data;\n\t\t}\n\n\t\t@Override\n\t\tpublic Builder<T> id(String id) {\n\t\t\tthis.id = id;\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic Builder<T> event(String event) {\n\t\t\tthis.event = event;\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic Builder<T> retry(Duration retry) {\n\t\t\tthis.retry = retry;\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic Builder<T> comment(String comment) {\n\t\t\tthis.comment = comment;\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic Builder<T> data(@Nullable T data) {\n\t\t\tthis.data = data;\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic ServerSentEvent<T> build() {\n\t\t\treturn new ServerSentEvent<>(this.id, this.event, this.retry, this.comment, this.data);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.http.codec.ServerSentEvent#build()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 285
    },
    "return": "ServerSentEvent<T>",
    "signature": "public ServerSentEvent<T> build()",
    "source_code": "\t\tpublic ServerSentEvent<T> build() {\n\t\t\treturn new ServerSentEvent<>(this.id, this.event, this.retry, this.comment, this.data);\n\t\t}"
  },
  "org.springframework.http.codec.ServerSentEvent#builder()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a builder for a {@code ServerSentEvent}.\n\t * @param <T> the type of data that this event contains\n\t * @return the builder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "Builder<T>",
    "signature": "public Builder<T> builder()",
    "source_code": "\tpublic static <T> Builder<T> builder() {\n\t\treturn new BuilderImpl<>();\n\t}"
  },
  "org.springframework.http.codec.ServerSentEvent#builder(data)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a builder for a {@code ServerSentEvent}, populated with the given {@linkplain #data() data}.\n\t * @param <T> the type of data that this event contains\n\t * @return the builder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "data"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "Builder<T>",
    "signature": "public Builder<T> builder(T data)",
    "source_code": "\tpublic static <T> Builder<T> builder(T data) {\n\t\treturn new BuilderImpl<>(data);\n\t}"
  },
  "org.springframework.http.codec.ServerSentEvent#comment()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the comment of this event, if available.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "String",
    "signature": "public String comment()",
    "source_code": "\tpublic String comment() {\n\t\treturn this.comment;\n\t}"
  },
  "org.springframework.http.codec.ServerSentEvent#comment(comment)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "comment"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "Builder<T>",
    "signature": "public Builder<T> comment(String comment)",
    "source_code": "\t\tpublic Builder<T> comment(String comment) {\n\t\t\tthis.comment = comment;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.codec.ServerSentEvent#data()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@code data} field of this event, if available.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "T",
    "signature": "public T data()",
    "source_code": "\tpublic T data() {\n\t\treturn this.data;\n\t}"
  },
  "org.springframework.http.codec.ServerSentEvent#data(data)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "data"
    ],
    "position": {
      "column": 1,
      "line": 279
    },
    "return": "Builder<T>",
    "signature": "public Builder<T> data(@Nullable T data)",
    "source_code": "\t\tpublic Builder<T> data(@Nullable T data) {\n\t\t\tthis.data = data;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.codec.ServerSentEvent#equals(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof ServerSentEvent<?> that &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.id, that.id) &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.event, that.event) &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.retry, that.retry) &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.comment, that.comment) &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.data, that.data)));\n\t}"
  },
  "org.springframework.http.codec.ServerSentEvent#event()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@code event} field of this event, if available.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "String",
    "signature": "public String event()",
    "source_code": "\tpublic String event() {\n\t\treturn this.event;\n\t}"
  },
  "org.springframework.http.codec.ServerSentEvent#event(event)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "event"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "Builder<T>",
    "signature": "public Builder<T> event(String event)",
    "source_code": "\t\tpublic Builder<T> event(String event) {\n\t\t\tthis.event = event;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.codec.ServerSentEvent#format()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a StringBuilder with the id, event, retry, and comment fields fully\n\t * serialized, and also appending \"data:\" if there is data.\n\t * @since 6.2.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "String",
    "signature": "public String format()",
    "source_code": "\tpublic String format() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif (this.id != null) {\n\t\t\tappendAttribute(\"id\", this.id, sb);\n\t\t}\n\t\tif (this.event != null) {\n\t\t\tappendAttribute(\"event\", this.event, sb);\n\t\t}\n\t\tif (this.retry != null) {\n\t\t\tappendAttribute(\"retry\", this.retry.toMillis(), sb);\n\t\t}\n\t\tif (this.comment != null) {\n\t\t\tsb.append(':').append(StringUtils.replace(this.comment, \"\\n\", \"\\n:\")).append('\\n');\n\t\t}\n\t\tif (this.data != null) {\n\t\t\tsb.append(\"data:\");\n\t\t}\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.http.codec.ServerSentEvent#hashCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn ObjectUtils.nullSafeHash(this.id, this.event, this.retry, this.comment, this.data);\n\t}"
  },
  "org.springframework.http.codec.ServerSentEvent#id()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@code id} field of this event, if available.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "String",
    "signature": "public String id()",
    "source_code": "\tpublic String id() {\n\t\treturn this.id;\n\t}"
  },
  "org.springframework.http.codec.ServerSentEvent#id(id)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "id"
    ],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "Builder<T>",
    "signature": "public Builder<T> id(String id)",
    "source_code": "\t\tpublic Builder<T> id(String id) {\n\t\t\tthis.id = id;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.codec.ServerSentEvent#retry()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@code retry} field of this event, if available.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "Duration",
    "signature": "public Duration retry()",
    "source_code": "\tpublic Duration retry() {\n\t\treturn this.retry;\n\t}"
  },
  "org.springframework.http.codec.ServerSentEvent#retry(retry)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "retry"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "Builder<T>",
    "signature": "public Builder<T> retry(Duration retry)",
    "source_code": "\t\tpublic Builder<T> retry(Duration retry) {\n\t\t\tthis.retry = retry;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.codec.ServerSentEvent#toString()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn (\"ServerSentEvent [id = '\" + this.id + \"', event='\" + this.event + \"', retry=\" +\n\t\t\t\tthis.retry + \", comment='\" + this.comment + \"', data=\" + this.data + ']');\n\t}"
  },
  "org.springframework.http.converter.AbstractKotlinSerializationHttpMessageConverter": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Abstract base class for {@link HttpMessageConverter} implementations that\n * use Kotlin serialization.\n *\n * @author Andreas Ahlenstorf\n * @author Sebastien Deleuze\n * @author Juergen Hoeller\n * @author Iain Henderson\n * @author Arjen Poutsma\n * @since 6.0\n * @param <T> the type of {@link SerialFormat}\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "signature": "public class AbstractKotlinSerializationHttpMessageConverter",
    "source_code": "public abstract class AbstractKotlinSerializationHttpMessageConverter<T extends SerialFormat> extends AbstractSmartHttpMessageConverter<Object> {\n\n\tprivate final Map<KType, KSerializer<Object>> kTypeSerializerCache = new ConcurrentReferenceHashMap<>();\n\n\tprivate final Map<Type, KSerializer<Object>> typeSerializerCache = new ConcurrentReferenceHashMap<>();\n\n\tprivate final T format;\n\n\n\t/**\n\t * Construct an {@code AbstractKotlinSerializationHttpMessageConverter} with multiple supported media type and\n\t * format.\n\t * @param format the format\n\t * @param supportedMediaTypes the supported media types\n\t */\n\tprotected AbstractKotlinSerializationHttpMessageConverter(T format, MediaType... supportedMediaTypes) {\n\t\tsuper(supportedMediaTypes);\n\t\tthis.format = format;\n\t}\n\n\t@Override\n\tprotected boolean supports(Class<?> clazz) {\n\t\treturn serializer(ResolvableType.forClass(clazz)) != null;\n\t}\n\n\t@Override\n\tpublic boolean canRead(ResolvableType type, @Nullable MediaType mediaType) {\n\t\tif (!ResolvableType.NONE.equals(type) && serializer(type) != null) {\n\t\t\treturn canRead(mediaType);\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean canWrite(ResolvableType type, Class<?> clazz, @Nullable MediaType mediaType) {\n\t\tif (!ResolvableType.NONE.equals(type) && serializer(type) != null) {\n\t\t\treturn canWrite(mediaType);\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Override\n\tpublic final Object read(ResolvableType type, HttpInputMessage inputMessage, @Nullable Map<String, Object> hints)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tKSerializer<Object> serializer = serializer(type);\n\t\tif (serializer == null) {\n\t\t\tthrow new HttpMessageNotReadableException(\"Could not find KSerializer for \" + type, inputMessage);\n\t\t}\n\t\treturn readInternal(serializer, this.format, inputMessage);\n\t}\n\n\t/**\n\t * Reads the given input message with the given serializer and format.\n\t */\n\tprotected abstract Object readInternal(KSerializer<Object> serializer, T format, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException;\n\n\t@Override\n\tprotected final void writeInternal(Object object, ResolvableType type, HttpOutputMessage outputMessage,\n\t\t\t@Nullable Map<String, Object> hints) throws IOException, HttpMessageNotWritableException {\n\n\t\tResolvableType resolvableType = (ResolvableType.NONE.equals(type) ? ResolvableType.forInstance(object) : type);\n\t\tKSerializer<Object> serializer = serializer(resolvableType);\n\t\tif (serializer == null) {\n\t\t\tthrow new HttpMessageNotWritableException(\"Could not find KSerializer for \" + resolvableType);\n\t\t}\n\t\twriteInternal(object, serializer, this.format, outputMessage);\n\t}\n\n\t/**\n\t * Write the given object to the output message with the given serializer and format.\n\t */\n\tprotected abstract void writeInternal(Object object, KSerializer<Object> serializer, T format,\n\t\t\tHttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException;\n\n\t/**\n\t * Tries to find a serializer that can marshall or unmarshall instances of the given type\n\t * using kotlinx.serialization. If no serializer can be found, {@code null} is returned.\n\t * <p>Resolved serializers are cached and cached results are returned on successive calls.\n\t * @param resolvableType the type to find a serializer for\n\t * @return a resolved serializer for the given type, or {@code null}\n\t */\n\t@Nullable\n\tprivate KSerializer<Object> serializer(ResolvableType resolvableType) {\n\t\tif (resolvableType.getSource() instanceof MethodParameter parameter) {\n\t\t\tMethod method = parameter.getMethod();\n\t\t\tAssert.notNull(method, \"Method must not be null\");\n\t\t\tif (KotlinDetector.isKotlinType(method.getDeclaringClass())) {\n\t\t\t\tKFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);\n\t\t\t\tif (function != null) {\n\t\t\t\t\tKType type = (parameter.getParameterIndex() == -1 ? function.getReturnType() :\n\t\t\t\t\t\t\tKCallables.getValueParameters(function).get(parameter.getParameterIndex()).getType());\n\t\t\t\t\tKSerializer<Object> serializer = this.kTypeSerializerCache.get(type);\n\t\t\t\t\tif (serializer == null) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tserializer = SerializersKt.serializerOrNull(this.format.getSerializersModule(), type);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (IllegalArgumentException ignored) {\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (serializer != null) {\n\t\t\t\t\t\t\tif (hasPolymorphism(serializer.getDescriptor(), new HashSet<>())) {\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.kTypeSerializerCache.put(type, serializer);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn serializer;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tType type = resolvableType.getType();\n\t\tKSerializer<Object> serializer = this.typeSerializerCache.get(type);\n\t\tif (serializer == null) {\n\t\t\ttry {\n\t\t\t\tserializer = SerializersKt.serializerOrNull(this.format.getSerializersModule(), type);\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ignored) {\n\t\t\t}\n\t\t\tif (serializer != null) {\n\t\t\t\tif (hasPolymorphism(serializer.getDescriptor(), new HashSet<>())) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tthis.typeSerializerCache.put(type, serializer);\n\t\t\t}\n\t\t}\n\t\treturn serializer;\n\t}\n\n\tprivate boolean hasPolymorphism(SerialDescriptor descriptor, Set<String> alreadyProcessed) {\n\t\talreadyProcessed.add(descriptor.getSerialName());\n\t\tif (descriptor.getKind().equals(PolymorphicKind.OPEN.INSTANCE)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (int i = 0 ; i < descriptor.getElementsCount() ; i++) {\n\t\t\tSerialDescriptor elementDescriptor = descriptor.getElementDescriptor(i);\n\t\t\tif (!alreadyProcessed.contains(elementDescriptor.getSerialName()) && hasPolymorphism(elementDescriptor, alreadyProcessed)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tprotected boolean supportsRepeatableWrites(Object object) {\n\t\treturn true;\n\t}\n}"
  },
  "org.springframework.http.converter.AbstractKotlinSerializationHttpMessageConverter#canRead(type,mediaType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "boolean",
    "signature": "public boolean canRead(ResolvableType type, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canRead(ResolvableType type, @Nullable MediaType mediaType) {\n\t\tif (!ResolvableType.NONE.equals(type) && serializer(type) != null) {\n\t\t\treturn canRead(mediaType);\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.AbstractKotlinSerializationHttpMessageConverter#canWrite(type,clazz,mediaType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "clazz",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "boolean",
    "signature": "public boolean canWrite(ResolvableType type, Class<?> clazz, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canWrite(ResolvableType type, Class<?> clazz, @Nullable MediaType mediaType) {\n\t\tif (!ResolvableType.NONE.equals(type) && serializer(type) != null) {\n\t\t\treturn canWrite(mediaType);\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.AbstractKotlinSerializationHttpMessageConverter#read(type,inputMessage,Map<String,hints)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "inputMessage",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "Object",
    "signature": "public Object read(ResolvableType type, HttpInputMessage inputMessage, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic final Object read(ResolvableType type, HttpInputMessage inputMessage, @Nullable Map<String, Object> hints)"
  },
  "org.springframework.http.converter.AbstractKotlinSerializationHttpMessageConverter#readInternal(serializer,format,inputMessage)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Reads the given input message with the given serializer and format.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "serializer",
      "format",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "Object",
    "signature": "protected Object readInternal(KSerializer<Object> serializer, T format, HttpInputMessage inputMessage)",
    "source_code": "\tprotected abstract Object readInternal(KSerializer<Object> serializer, T format, HttpInputMessage inputMessage)"
  },
  "org.springframework.http.converter.AbstractKotlinSerializationHttpMessageConverter#supports(clazz)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "boolean",
    "signature": "protected boolean supports(Class<?> clazz)",
    "source_code": "\tprotected boolean supports(Class<?> clazz) {\n\t\treturn serializer(ResolvableType.forClass(clazz)) != null;\n\t}"
  },
  "org.springframework.http.converter.AbstractKotlinSerializationHttpMessageConverter#supportsRepeatableWrites(object)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "boolean",
    "signature": "protected boolean supportsRepeatableWrites(Object object)",
    "source_code": "\tprotected boolean supportsRepeatableWrites(Object object) {\n\t\treturn true;\n\t}"
  },
  "org.springframework.http.converter.AbstractKotlinSerializationHttpMessageConverter#writeInternal(object,serializer,format,outputMessage)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Write the given object to the output message with the given serializer and format.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "serializer",
      "format",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "void",
    "signature": "protected void writeInternal(Object object, KSerializer<Object> serializer, T format,\n\t\t\tHttpOutputMessage outputMessage)",
    "source_code": "\tprotected abstract void writeInternal(Object object, KSerializer<Object> serializer, T format,"
  },
  "org.springframework.http.converter.AbstractKotlinSerializationHttpMessageConverter#writeInternal(object,type,outputMessage,Map<String,hints)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "type",
      "outputMessage",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "void",
    "signature": "protected void writeInternal(Object object, ResolvableType type, HttpOutputMessage outputMessage,\n\t\t\t@Nullable Map<String, Object> hints)",
    "source_code": "\tprotected final void writeInternal(Object object, ResolvableType type, HttpOutputMessage outputMessage,"
  },
  "org.springframework.http.converter.AbstractSmartHttpMessageConverter": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Abstract base class for most {@link SmartHttpMessageConverter} implementations.\n *\n * @author Sebastien Deleuze\n * @since 6.2\n * @param <T> the converted object type\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "signature": "public class AbstractSmartHttpMessageConverter",
    "source_code": "public abstract class AbstractSmartHttpMessageConverter<T> extends AbstractHttpMessageConverter<T>"
  },
  "org.springframework.http.converter.AbstractSmartHttpMessageConverter#canRead(type,mediaType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "boolean",
    "signature": "public boolean canRead(ResolvableType type, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canRead(ResolvableType type, @Nullable MediaType mediaType) {\n\t\tClass<?> clazz = type.resolve();\n\t\treturn (clazz != null ? canRead(clazz, mediaType) : canRead(mediaType));\n\t}"
  },
  "org.springframework.http.converter.AbstractSmartHttpMessageConverter#canWrite(type,clazz,mediaType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "clazz",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "boolean",
    "signature": "public boolean canWrite(ResolvableType type, Class<?> clazz, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canWrite(ResolvableType type, Class<?> clazz, @Nullable MediaType mediaType) {\n\t\treturn canWrite(clazz, mediaType);\n\t}"
  },
  "org.springframework.http.converter.AbstractSmartHttpMessageConverter#getBody()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "OutputStream",
    "signature": "public OutputStream getBody()",
    "source_code": "\t\t\t\t\t\tpublic OutputStream getBody() {\n\t\t\t\t\t\t\treturn outputStream;\n\t\t\t\t\t\t}"
  },
  "org.springframework.http.converter.AbstractSmartHttpMessageConverter#getHeaders()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders getHeaders()",
    "source_code": "\t\t\t\t\t\tpublic HttpHeaders getHeaders() {\n\t\t\t\t\t\t\treturn headers;\n\t\t\t\t\t\t}"
  },
  "org.springframework.http.converter.AbstractSmartHttpMessageConverter#readInternal(clazz,inputMessage)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "T",
    "signature": "protected T readInternal(Class<? extends T> clazz, HttpInputMessage inputMessage)",
    "source_code": "\tprotected T readInternal(Class<? extends T> clazz, HttpInputMessage inputMessage)"
  },
  "org.springframework.http.converter.AbstractSmartHttpMessageConverter#repeatable()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "boolean",
    "signature": "public boolean repeatable()",
    "source_code": "\t\t\t\tpublic boolean repeatable() {\n\t\t\t\t\treturn supportsRepeatableWrites(t);\n\t\t\t\t}"
  },
  "org.springframework.http.converter.AbstractSmartHttpMessageConverter#supports(clazz)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "boolean",
    "signature": "protected boolean supports(Class<?> clazz)",
    "source_code": "\tprotected boolean supports(Class<?> clazz) {\n\t\treturn true;\n\t}"
  },
  "org.springframework.http.converter.AbstractSmartHttpMessageConverter#write(t,type,contentType,outputMessage,Map<String,hints)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation sets the default headers by calling {@link #addDefaultHeaders},\n\t * and then calls {@link #writeInternal}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "t",
      "type",
      "contentType",
      "outputMessage",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "void",
    "signature": "public void write(T t, ResolvableType type, @Nullable MediaType contentType,\n\t\t\tHttpOutputMessage outputMessage, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic final void write(T t, ResolvableType type, @Nullable MediaType contentType,"
  },
  "org.springframework.http.converter.AbstractSmartHttpMessageConverter#writeInternal(t,outputMessage)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "t",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "void",
    "signature": "protected void writeInternal(T t, HttpOutputMessage outputMessage)",
    "source_code": "\tprotected void writeInternal(T t, HttpOutputMessage outputMessage)"
  },
  "org.springframework.http.converter.AbstractSmartHttpMessageConverter#writeInternal(t,type,outputMessage,Map<String,hints)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method that writes the actual body. Invoked from\n\t * {@link #write(Object, ResolvableType, MediaType, HttpOutputMessage, Map)}.\n\t * @param t the object to write to the output message\n\t * @param type the type of object to write\n\t * @param outputMessage the HTTP output message to write to\n\t * @param hints additional information about how to encode\n\t * @throws IOException in case of I/O errors\n\t * @throws HttpMessageNotWritableException in case of conversion errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "t",
      "type",
      "outputMessage",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "void",
    "signature": "protected void writeInternal(T t, ResolvableType type, HttpOutputMessage outputMessage,\n\t\t\t@Nullable Map<String, Object> hints)",
    "source_code": "\tprotected abstract void writeInternal(T t, ResolvableType type, HttpOutputMessage outputMessage,"
  },
  "org.springframework.http.converter.AbstractSmartHttpMessageConverter#writeTo(outputStream)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outputStream"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "public void writeTo(OutputStream outputStream)",
    "source_code": "\t\t\t\tpublic void writeTo(OutputStream outputStream) throws IOException {\n\t\t\t\t\twriteInternal(t, type, new HttpOutputMessage() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic OutputStream getBody() {\n\t\t\t\t\t\t\treturn outputStream;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic HttpHeaders getHeaders() {\n\t\t\t\t\t\t\treturn headers;\n\t\t\t\t\t\t}\n\t\t\t\t\t}, hints);\n\t\t\t\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#yaml()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a {@link Jackson2ObjectMapperBuilder} instance in order to\n\t * build a YAML data format {@link ObjectMapper} instance.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 942
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder yaml()",
    "source_code": "\tpublic static Jackson2ObjectMapperBuilder yaml() {\n\t\treturn new Jackson2ObjectMapperBuilder().factory(new YamlFactoryInitializer().create());\n\t}"
  },
  "org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverter#writeToResult(o,headers,result)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "o",
      "headers",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "void",
    "signature": "protected void writeToResult(Object o, HttpHeaders headers, Result result)",
    "source_code": "\tprotected void writeToResult(Object o, HttpHeaders headers, Result result) throws Exception {\n\t\ttry {\n\t\t\tClass<?> clazz = ClassUtils.getUserClass(o);\n\t\t\tMarshaller marshaller = createMarshaller(clazz);\n\t\t\tsetCharset(headers.getContentType(), marshaller);\n\t\t\tmarshaller.marshal(o, result);\n\t\t}\n\t\tcatch (MarshalException ex) {\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (JAXBException ex) {\n\t\t\tthrow new HttpMessageConversionException(\"Invalid JAXB setup: \" + ex.getMessage(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverter#writeToResult(value,headers,result)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "headers",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 197
    },
    "return": "void",
    "signature": "protected void writeToResult(Object value, HttpHeaders headers, Result result)",
    "source_code": "\tprotected void writeToResult(Object value, HttpHeaders headers, Result result) throws Exception {\n\t\ttry {\n\t\t\tClass<?> clazz = getMarshallerType(value);\n\t\t\tMarshaller marshaller = createMarshaller(clazz);\n\t\t\tsetCharset(headers.getContentType(), marshaller);\n\t\t\tmarshaller.marshal(value, result);\n\t\t}\n\t\tcatch (MarshalException ex) {\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (JAXBException ex) {\n\t\t\tthrow new HttpMessageConversionException(\"Invalid JAXB setup: \" + ex.getMessage(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.http.server.ServletServerHttpRequest#clear()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 360
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\t\tpublic void clear() {\n\t\t\tfor (Enumeration<String> names = servletRequest.getAttributeNames(); names.hasMoreElements(); ) {\n\t\t\t\tString name = names.nextElement();\n\t\t\t\tservletRequest.removeAttribute(name);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.http.server.ServletServerHttpRequest#entrySet()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 420
    },
    "return": "Object>>",
    "signature": "public Object>> entrySet()",
    "source_code": "\t\tpublic Set<Entry<String, Object>> entrySet() {\n\t\t\tSet<Entry<String, Object>> entrySet = this.entrySet;\n\t\t\tif (entrySet == null) {\n\t\t\t\tentrySet = new AbstractSet<>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Iterator<Entry<String, Object>> iterator() {\n\t\t\t\t\t\tEnumeration<String> e = servletRequest.getAttributeNames();\n\t\t\t\t\t\treturn new Iterator<>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic boolean hasNext() {\n\t\t\t\t\t\t\t\treturn e.hasMoreElements();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic Entry<String, Object> next() {\n\t\t\t\t\t\t\t\tString name = e.nextElement();\n\t\t\t\t\t\t\t\tObject value = servletRequest.getAttribute(name);\n\t\t\t\t\t\t\t\treturn new SimpleImmutableEntry<>(name, value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic int size() {\n\t\t\t\t\t\treturn AttributesMap.this.size();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tthis.entrySet = entrySet;\n\t\t\t}\n\t\t\treturn entrySet;\n\t\t}"
  },
  "org.springframework.http.server.ServletServerHttpRequest#get(key)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 329
    },
    "return": "Object",
    "signature": "public Object get(Object key)",
    "source_code": "\t\tpublic Object get(Object key) {\n\t\t\tif (key instanceof String name) {\n\t\t\t\treturn servletRequest.getAttribute(name);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.http.server.ServletServerHttpRequest#getAttributes()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "Object>",
    "signature": "public Object> getAttributes()",
    "source_code": "\tpublic Map<String, Object> getAttributes() {\n\t\tMap<String, Object> attributes = this.attributes;\n\t\tif (attributes == null) {\n\t\t\tattributes = new AttributesMap();\n\t\t\tthis.attributes = attributes;\n\t\t}\n\t\treturn attributes;\n\t}"
  },
  "org.springframework.http.server.ServletServerHttpRequest#hasNext()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "boolean",
    "signature": "public boolean hasNext()",
    "source_code": "\t\t\t\t\t\t\tpublic boolean hasNext() {\n\t\t\t\t\t\t\t\treturn e.hasMoreElements();\n\t\t\t\t\t\t\t}"
  },
  "org.springframework.http.server.ServletServerHttpRequest#iterator()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 425
    },
    "return": "Object>>",
    "signature": "public Object>> iterator()",
    "source_code": "\t\t\t\t\tpublic Iterator<Entry<String, Object>> iterator() {\n\t\t\t\t\t\tEnumeration<String> e = servletRequest.getAttributeNames();\n\t\t\t\t\t\treturn new Iterator<>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic boolean hasNext() {\n\t\t\t\t\t\t\t\treturn e.hasMoreElements();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic Entry<String, Object> next() {\n\t\t\t\t\t\t\t\tString name = e.nextElement();\n\t\t\t\t\t\t\t\tObject value = servletRequest.getAttribute(name);\n\t\t\t\t\t\t\t\treturn new SimpleImmutableEntry<>(name, value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}"
  },
  "org.springframework.http.server.ServletServerHttpRequest#keySet()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 368
    },
    "return": "Set<String>",
    "signature": "public Set<String> keySet()",
    "source_code": "\t\tpublic Set<String> keySet() {\n\t\t\tSet<String> keySet = this.keySet;\n\t\t\tif (keySet == null) {\n\t\t\t\tkeySet = new AbstractSet<>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Iterator<String> iterator() {\n\t\t\t\t\t\treturn servletRequest.getAttributeNames().asIterator();\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic int size() {\n\t\t\t\t\t\treturn AttributesMap.this.size();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tthis.keySet = keySet;\n\t\t\t}\n\t\t\treturn keySet;\n\t\t}"
  },
  "org.springframework.http.server.ServletServerHttpRequest#next()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 434
    },
    "return": "Object>",
    "signature": "public Object> next()",
    "source_code": "\t\t\t\t\t\t\tpublic Entry<String, Object> next() {\n\t\t\t\t\t\t\t\tString name = e.nextElement();\n\t\t\t\t\t\t\t\tObject value = servletRequest.getAttribute(name);\n\t\t\t\t\t\t\t\treturn new SimpleImmutableEntry<>(name, value);\n\t\t\t\t\t\t\t}"
  },
  "org.springframework.http.server.ServletServerHttpRequest#put(key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 340
    },
    "return": "Object",
    "signature": "public Object put(String key, Object value)",
    "source_code": "\t\tpublic Object put(String key, Object value) {\n\t\t\tObject old = get(key);\n\t\t\tservletRequest.setAttribute(key, value);\n\t\t\treturn old;\n\t\t}"
  },
  "org.springframework.http.server.ServletServerHttpRequest#remove(key)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 348
    },
    "return": "Object",
    "signature": "public Object remove(Object key)",
    "source_code": "\t\tpublic Object remove(Object key) {\n\t\t\tif (key instanceof String name) {\n\t\t\t\tObject old = get(key);\n\t\t\t\tservletRequest.removeAttribute(name);\n\t\t\t\treturn old;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.http.server.ServletServerHttpRequest#size()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 443
    },
    "return": "int",
    "signature": "public int size()",
    "source_code": "\t\t\t\t\tpublic int size() {\n\t\t\t\t\t\treturn AttributesMap.this.size();\n\t\t\t\t\t}"
  },
  "org.springframework.http.server.ServletServerHttpRequest#values()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 388
    },
    "return": "Collection<Object>",
    "signature": "public Collection<Object> values()",
    "source_code": "\t\tpublic Collection<Object> values() {\n\t\t\tCollection<Object> values = this.values;\n\t\t\tif (values == null) {\n\t\t\t\tvalues = new AbstractCollection<>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Iterator<Object> iterator() {\n\t\t\t\t\t\tEnumeration<String> e = servletRequest.getAttributeNames();\n\t\t\t\t\t\treturn new Iterator<>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic boolean hasNext() {\n\t\t\t\t\t\t\t\treturn e.hasMoreElements();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic Object next() {\n\t\t\t\t\t\t\t\tString name = e.nextElement();\n\t\t\t\t\t\t\t\treturn servletRequest.getAttribute(name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic int size() {\n\t\t\t\t\t\treturn AttributesMap.this.size();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tthis.values = values;\n\t\t\t}\n\t\t\treturn values;\n\t\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#getAttributes()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "String>",
    "signature": "public String> getAttributes()",
    "source_code": "\t\tpublic Map<String, String> getAttributes() {\n\t\t\treturn Collections.emptyMap();\n\t\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#getComment()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "String",
    "signature": "public String getComment()",
    "source_code": "\t\tpublic String getComment() {\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#getDomain()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "String",
    "signature": "public String getDomain()",
    "source_code": "\t\tpublic String getDomain() {\n\t\t\treturn this.responseCookie.getDomain();\n\t\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#getMaxAge()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "long",
    "signature": "public long getMaxAge()",
    "source_code": "\t\tpublic long getMaxAge() {\n\t\t\treturn this.responseCookie.getMaxAge().toSeconds();\n\t\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#getName()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "String",
    "signature": "public String getName()",
    "source_code": "\t\tpublic String getName() {\n\t\t\treturn this.responseCookie.getName();\n\t\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#getPath()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "String",
    "signature": "public String getPath()",
    "source_code": "\t\tpublic String getPath() {\n\t\t\treturn this.responseCookie.getPath();\n\t\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#getSameSite()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "SameSite",
    "signature": "public SameSite getSameSite()",
    "source_code": "\t\tpublic SameSite getSameSite() {\n\t\t\t// Adding non-null return site breaks tests.\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#getVersion()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "int",
    "signature": "public int getVersion()",
    "source_code": "\t\tpublic int getVersion() {\n\t\t\treturn 0;\n\t\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#isHttpOnly()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "boolean",
    "signature": "public boolean isHttpOnly()",
    "source_code": "\t\tpublic boolean isHttpOnly() {\n\t\t\treturn this.responseCookie.isHttpOnly();\n\t\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#isPartitioned()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "boolean",
    "signature": "public boolean isPartitioned()",
    "source_code": "\t\tpublic boolean isPartitioned() {\n\t\t\treturn this.responseCookie.isPartitioned();\n\t\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#isSecure()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "boolean",
    "signature": "public boolean isSecure()",
    "source_code": "\t\tpublic boolean isSecure() {\n\t\t\treturn this.responseCookie.isSecure();\n\t\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#onCompleteFailure(cause)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "cause"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "protected void onCompleteFailure(Throwable cause)",
    "source_code": "\t\t\t\tprotected void onCompleteFailure(Throwable cause) {\n\t\t\t\t\tbyteBufferIterator.close();\n\t\t\t\t\tDataBufferUtils.release(dataBuffer);\n\t\t\t\t\tcallback.failed(cause);\n\t\t\t\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#onCompleteSuccess()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "void",
    "signature": "protected void onCompleteSuccess()",
    "source_code": "\t\t\t\tprotected void onCompleteSuccess() {\n\t\t\t\t\tbyteBufferIterator.close();\n\t\t\t\t\tDataBufferUtils.release(dataBuffer);\n\t\t\t\t\tcallback.complete(null);\n\t\t\t\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#process()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "Action",
    "signature": "protected Action process()",
    "source_code": "\t\t\t\tprotected Action process() {\n\t\t\t\t\tif (!byteBufferIterator.hasNext()) {\n\t\t\t\t\t\treturn Action.SUCCEEDED;\n\t\t\t\t\t}\n\t\t\t\t\tresponse.write(false, byteBufferIterator.next(), this);\n\t\t\t\t\treturn Action.SCHEDULED;\n\t\t\t\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#writeAndFlushWithInternal(body)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "body"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> writeAndFlushWithInternal(Publisher<? extends Publisher<? extends DataBuffer>> body)",
    "source_code": "\tprotected Mono<Void> writeAndFlushWithInternal(Publisher<? extends Publisher<? extends DataBuffer>> body) {\n\t\treturn Flux.from(body).concatMap(this::writeWithInternal).then();\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#writeWithInternal(body)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "body"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> writeWithInternal(Publisher<? extends DataBuffer> body)",
    "source_code": "\tprotected Mono<Void> writeWithInternal(Publisher<? extends DataBuffer> body) {\n\t\treturn Flux.from(body)\n\t\t\t\t.concatMap(this::sendDataBuffer)\n\t\t\t\t.then();\n\t}"
  },
  "org.springframework.http.server.reactive.ServerHttpRequestDecorator#getAttributes()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "Object>",
    "signature": "public Object> getAttributes()",
    "source_code": "\tpublic Map<String, Object> getAttributes() {\n\t\treturn getDelegate().getAttributes();\n\t}"
  },
  "org.springframework.jdbc.datasource.embedded.<unknown>#getConfigurer(type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a configurer instance for the given embedded database type.\n\t * @param type the embedded database type (HSQL, H2 or Derby)\n\t * @return the configurer instance\n\t * @throws IllegalStateException if the driver for the specified database type is not available\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "return": "EmbeddedDatabaseConfigurer",
    "signature": "public EmbeddedDatabaseConfigurer getConfigurer(EmbeddedDatabaseType type)",
    "source_code": "\tpublic static EmbeddedDatabaseConfigurer getConfigurer(EmbeddedDatabaseType type) throws IllegalStateException {\n\t\tAssert.notNull(type, \"EmbeddedDatabaseType is required\");\n\t\ttry {\n\t\t\treturn switch (type) {\n\t\t\t\tcase HSQL -> HsqlEmbeddedDatabaseConfigurer.getInstance();\n\t\t\t\tcase H2 -> H2EmbeddedDatabaseConfigurer.getInstance();\n\t\t\t\tcase DERBY -> DerbyEmbeddedDatabaseConfigurer.getInstance();\n\t\t\t\tdefault -> throw new UnsupportedOperationException(\"Embedded database type [\" + type + \"] is not supported\");\n\t\t\t};\n\t\t}\n\t\tcatch (ClassNotFoundException | NoClassDefFoundError ex) {\n\t\t\tthrow new IllegalStateException(\"Driver for test database type [\" + type + \"] is not available\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseConfigurers": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Maps well-known {@linkplain EmbeddedDatabaseType embedded database types}\n * to {@link EmbeddedDatabaseConfigurer} strategies.\n *\n * @author Keith Donald\n * @author Oliver Gierke\n * @author Sam Brannen\n * @author Stephane Nicoll\n * @since 6.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 33
    },
    "signature": "public class EmbeddedDatabaseConfigurers",
    "source_code": "public abstract class EmbeddedDatabaseConfigurers {\n\n\t/**\n\t * Return a configurer instance for the given embedded database type.\n\t * @param type the {@linkplain EmbeddedDatabaseType embedded database type}\n\t * @return the configurer instance\n\t * @throws IllegalStateException if the driver for the specified database type is not available\n\t */\n\tpublic static EmbeddedDatabaseConfigurer getConfigurer(EmbeddedDatabaseType type) {\n\t\tAssert.notNull(type, \"EmbeddedDatabaseType is required\");\n\t\ttry {\n\t\t\treturn switch (type) {\n\t\t\t\tcase HSQL -> HsqlEmbeddedDatabaseConfigurer.getInstance();\n\t\t\t\tcase H2 -> H2EmbeddedDatabaseConfigurer.getInstance();\n\t\t\t\tcase DERBY -> DerbyEmbeddedDatabaseConfigurer.getInstance();\n\t\t\t};\n\t\t}\n\t\tcatch (ClassNotFoundException | NoClassDefFoundError ex) {\n\t\t\tthrow new IllegalStateException(\"Driver for test database type [\" + type + \"] is not available\", ex);\n\t\t}\n\t}\n\n\t/**\n\t * Customize the default configurer for the given embedded database type.\n\t * <p>The {@code customizer} typically uses\n\t * {@link EmbeddedDatabaseConfigurerDelegate} to customize things as necessary.\n\t * @param type the {@linkplain EmbeddedDatabaseType embedded database type}\n\t * @param customizer the customizer to return based on the default\n\t * @return the customized configurer instance\n\t * @throws IllegalStateException if the driver for the specified database type is not available\n\t */\n\tpublic static EmbeddedDatabaseConfigurer customizeConfigurer(\n\t\t\tEmbeddedDatabaseType type, UnaryOperator<EmbeddedDatabaseConfigurer> customizer) {\n\n\t\tEmbeddedDatabaseConfigurer defaultConfigurer = getConfigurer(type);\n\t\treturn customizer.apply(defaultConfigurer);\n\t}\n\n}"
  },
  "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseConfigurers#customizeConfigurer(type,customizer)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the default configurer for the given embedded database type.\n\t * <p>The {@code customizer} typically uses\n\t * {@link EmbeddedDatabaseConfigurerDelegate} to customize things as necessary.\n\t * @param type the {@linkplain EmbeddedDatabaseType embedded database type}\n\t * @param customizer the customizer to return based on the default\n\t * @return the customized configurer instance\n\t * @throws IllegalStateException if the driver for the specified database type is not available\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "customizer"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "EmbeddedDatabaseConfigurer",
    "signature": "public EmbeddedDatabaseConfigurer customizeConfigurer(EmbeddedDatabaseType type, UnaryOperator<EmbeddedDatabaseConfigurer> customizer)",
    "source_code": "\tpublic static EmbeddedDatabaseConfigurer customizeConfigurer("
  },
  "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseConfigurers#getConfigurer(type)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a configurer instance for the given embedded database type.\n\t * @param type the {@linkplain EmbeddedDatabaseType embedded database type}\n\t * @return the configurer instance\n\t * @throws IllegalStateException if the driver for the specified database type is not available\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "return": "EmbeddedDatabaseConfigurer",
    "signature": "public EmbeddedDatabaseConfigurer getConfigurer(EmbeddedDatabaseType type)",
    "source_code": "\tpublic static EmbeddedDatabaseConfigurer getConfigurer(EmbeddedDatabaseType type) {\n\t\tAssert.notNull(type, \"EmbeddedDatabaseType is required\");\n\t\ttry {\n\t\t\treturn switch (type) {\n\t\t\t\tcase HSQL -> HsqlEmbeddedDatabaseConfigurer.getInstance();\n\t\t\t\tcase H2 -> H2EmbeddedDatabaseConfigurer.getInstance();\n\t\t\t\tcase DERBY -> DerbyEmbeddedDatabaseConfigurer.getInstance();\n\t\t\t};\n\t\t}\n\t\tcatch (ClassNotFoundException | NoClassDefFoundError ex) {\n\t\t\tthrow new IllegalStateException(\"Driver for test database type [\" + type + \"] is not available\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Helper bean for registering {@link JmsListenerEndpoint} with a {@link JmsListenerEndpointRegistry}.\n *\n * @author Stephane Nicoll\n * @author Juergen Hoeller\n * @since 4.1\n * @see org.springframework.jms.annotation.JmsListenerConfigurer\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class JmsListenerEndpointRegistrar",
    "source_code": "public class JmsListenerEndpointRegistrar implements BeanFactoryAware, InitializingBean {\n\n\t@Nullable\n\tprivate JmsListenerEndpointRegistry endpointRegistry;\n\n\t@Nullable\n\tprivate MessageHandlerMethodFactory messageHandlerMethodFactory;\n\n\t@Nullable\n\tprivate JmsListenerContainerFactory<?> containerFactory;\n\n\t@Nullable\n\tprivate String containerFactoryBeanName;\n\n\t@Nullable\n\tprivate BeanFactory beanFactory;\n\n\tprivate final List<JmsListenerEndpointDescriptor> endpointDescriptors = new ArrayList<>();\n\n\tprivate boolean startImmediately;\n\n\tprivate Object mutex = this.endpointDescriptors;\n\n\n\t/**\n\t * Set the {@link JmsListenerEndpointRegistry} instance to use.\n\t */\n\tpublic void setEndpointRegistry(@Nullable JmsListenerEndpointRegistry endpointRegistry) {\n\t\tthis.endpointRegistry = endpointRegistry;\n\t}\n\n\t/**\n\t * Return the {@link JmsListenerEndpointRegistry} instance for this\n\t * registrar, may be {@code null}.\n\t */\n\t@Nullable\n\tpublic JmsListenerEndpointRegistry getEndpointRegistry() {\n\t\treturn this.endpointRegistry;\n\t}\n\n\t/**\n\t * Set the {@link MessageHandlerMethodFactory} to use to configure the message\n\t * listener responsible to serve an endpoint detected by this processor.\n\t * <p>By default, {@link DefaultMessageHandlerMethodFactory} is used and it\n\t * can be configured further to support additional method arguments\n\t * or to customize conversion and validation support. See\n\t * {@link DefaultMessageHandlerMethodFactory} javadoc for more details.\n\t */\n\tpublic void setMessageHandlerMethodFactory(@Nullable MessageHandlerMethodFactory messageHandlerMethodFactory) {\n\t\tthis.messageHandlerMethodFactory = messageHandlerMethodFactory;\n\t}\n\n\t/**\n\t * Return the custom {@link MessageHandlerMethodFactory} to use, if any.\n\t */\n\t@Nullable\n\tpublic MessageHandlerMethodFactory getMessageHandlerMethodFactory() {\n\t\treturn this.messageHandlerMethodFactory;\n\t}\n\n\t/**\n\t * Set the {@link JmsListenerContainerFactory} to use in case a {@link JmsListenerEndpoint}\n\t * is registered with a {@code null} container factory.\n\t * <p>Alternatively, the bean name of the {@link JmsListenerContainerFactory} to use\n\t * can be specified for a lazy lookup, see {@link #setContainerFactoryBeanName}.\n\t */\n\tpublic void setContainerFactory(JmsListenerContainerFactory<?> containerFactory) {\n\t\tthis.containerFactory = containerFactory;\n\t}\n\n\t/**\n\t * Set the bean name of the {@link JmsListenerContainerFactory} to use in case\n\t * a {@link JmsListenerEndpoint} is registered with a {@code null} container factory.\n\t * Alternatively, the container factory instance can be registered directly:\n\t * see {@link #setContainerFactory(JmsListenerContainerFactory)}.\n\t * @see #setBeanFactory\n\t */\n\tpublic void setContainerFactoryBeanName(String containerFactoryBeanName) {\n\t\tthis.containerFactoryBeanName = containerFactoryBeanName;\n\t}\n\n\t/**\n\t * A {@link BeanFactory} only needs to be available in conjunction with\n\t * {@link #setContainerFactoryBeanName}.\n\t */\n\t@Override\n\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t\tif (beanFactory instanceof ConfigurableBeanFactory cbf) {\n\t\t\tthis.mutex = cbf.getSingletonMutex();\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic void afterPropertiesSet() {\n\t\tregisterAllEndpoints();\n\t}\n\n\tprotected void registerAllEndpoints() {\n\t\tAssert.state(this.endpointRegistry != null, \"No JmsListenerEndpointRegistry set\");\n\t\tsynchronized (this.mutex) {\n\t\t\tfor (JmsListenerEndpointDescriptor descriptor : this.endpointDescriptors) {\n\t\t\t\tthis.endpointRegistry.registerListenerContainer(\n\t\t\t\t\t\tdescriptor.endpoint, resolveContainerFactory(descriptor));\n\t\t\t}\n\t\t\tthis.startImmediately = true;  // trigger immediate startup\n\t\t}\n\t}\n\n\tprivate JmsListenerContainerFactory<?> resolveContainerFactory(JmsListenerEndpointDescriptor descriptor) {\n\t\tif (descriptor.containerFactory != null) {\n\t\t\treturn descriptor.containerFactory;\n\t\t}\n\t\telse if (this.containerFactory != null) {\n\t\t\treturn this.containerFactory;\n\t\t}\n\t\telse if (this.containerFactoryBeanName != null) {\n\t\t\tAssert.state(this.beanFactory != null, \"BeanFactory must be set to obtain container factory by bean name\");\n\t\t\t// Consider changing this if live change of the factory is required...\n\t\t\tthis.containerFactory = this.beanFactory.getBean(\n\t\t\t\t\tthis.containerFactoryBeanName, JmsListenerContainerFactory.class);\n\t\t\treturn this.containerFactory;\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\"Could not resolve the \" +\n\t\t\t\t\tJmsListenerContainerFactory.class.getSimpleName() + \" to use for [\" +\n\t\t\t\t\tdescriptor.endpoint + \"] no factory was given and no default is set.\");\n\t\t}\n\t}\n\n\t/**\n\t * Register a new {@link JmsListenerEndpoint} alongside the\n\t * {@link JmsListenerContainerFactory} to use to create the underlying container.\n\t * <p>The {@code factory} may be {@code null} if the default factory should be\n\t * used for the supplied endpoint.\n\t */\n\tpublic void registerEndpoint(JmsListenerEndpoint endpoint, @Nullable JmsListenerContainerFactory<?> factory) {\n\t\tAssert.notNull(endpoint, \"Endpoint must not be null\");\n\t\tAssert.hasText(endpoint.getId(), \"Endpoint id must be set\");\n\n\t\t// Factory may be null, we defer the resolution right before actually creating the container\n\t\tJmsListenerEndpointDescriptor descriptor = new JmsListenerEndpointDescriptor(endpoint, factory);\n\n\t\tsynchronized (this.mutex) {\n\t\t\tif (this.startImmediately) {  // register and start immediately\n\t\t\t\tAssert.state(this.endpointRegistry != null, \"No JmsListenerEndpointRegistry set\");\n\t\t\t\tthis.endpointRegistry.registerListenerContainer(descriptor.endpoint,\n\t\t\t\t\t\tresolveContainerFactory(descriptor), true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.endpointDescriptors.add(descriptor);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Register a new {@link JmsListenerEndpoint} using the default\n\t * {@link JmsListenerContainerFactory} to create the underlying container.\n\t * @see #setContainerFactory(JmsListenerContainerFactory)\n\t * @see #registerEndpoint(JmsListenerEndpoint, JmsListenerContainerFactory)\n\t */\n\tpublic void registerEndpoint(JmsListenerEndpoint endpoint) {\n\t\tregisterEndpoint(endpoint, null);\n\t}\n\n\n\tprivate static class JmsListenerEndpointDescriptor {\n\n\t\tpublic final JmsListenerEndpoint endpoint;\n\n\t\t@Nullable\n\t\tpublic final JmsListenerContainerFactory<?> containerFactory;\n\n\t\tpublic JmsListenerEndpointDescriptor(JmsListenerEndpoint endpoint,\n\t\t\t\t@Nullable JmsListenerContainerFactory<?> containerFactory) {\n\n\t\t\tthis.endpoint = endpoint;\n\t\t\tthis.containerFactory = containerFactory;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tregisterAllEndpoints();\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#getEndpointRegistry()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link JmsListenerEndpointRegistry} instance for this\n\t * registrar, may be {@code null}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "JmsListenerEndpointRegistry",
    "signature": "public JmsListenerEndpointRegistry getEndpointRegistry()",
    "source_code": "\tpublic JmsListenerEndpointRegistry getEndpointRegistry() {\n\t\treturn this.endpointRegistry;\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#getMessageHandlerMethodFactory()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the custom {@link MessageHandlerMethodFactory} to use, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "MessageHandlerMethodFactory",
    "signature": "public MessageHandlerMethodFactory getMessageHandlerMethodFactory()",
    "source_code": "\tpublic MessageHandlerMethodFactory getMessageHandlerMethodFactory() {\n\t\treturn this.messageHandlerMethodFactory;\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#registerAllEndpoints()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "void",
    "signature": "protected void registerAllEndpoints()",
    "source_code": "\tprotected void registerAllEndpoints() {\n\t\tAssert.state(this.endpointRegistry != null, \"No JmsListenerEndpointRegistry set\");\n\t\tsynchronized (this.mutex) {\n\t\t\tfor (JmsListenerEndpointDescriptor descriptor : this.endpointDescriptors) {\n\t\t\t\tthis.endpointRegistry.registerListenerContainer(\n\t\t\t\t\t\tdescriptor.endpoint, resolveContainerFactory(descriptor));\n\t\t\t}\n\t\t\tthis.startImmediately = true;  // trigger immediate startup\n\t\t}\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#registerEndpoint(endpoint)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a new {@link JmsListenerEndpoint} using the default\n\t * {@link JmsListenerContainerFactory} to create the underlying container.\n\t * @see #setContainerFactory(JmsListenerContainerFactory)\n\t * @see #registerEndpoint(JmsListenerEndpoint, JmsListenerContainerFactory)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "endpoint"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "void",
    "signature": "public void registerEndpoint(JmsListenerEndpoint endpoint)",
    "source_code": "\tpublic void registerEndpoint(JmsListenerEndpoint endpoint) {\n\t\tregisterEndpoint(endpoint, null);\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#registerEndpoint(endpoint,factory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a new {@link JmsListenerEndpoint} alongside the\n\t * {@link JmsListenerContainerFactory} to use to create the underlying container.\n\t * <p>The {@code factory} may be {@code null} if the default factory should be\n\t * used for the supplied endpoint.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "endpoint",
      "factory"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "void",
    "signature": "public void registerEndpoint(JmsListenerEndpoint endpoint, @Nullable JmsListenerContainerFactory<?> factory)",
    "source_code": "\tpublic void registerEndpoint(JmsListenerEndpoint endpoint, @Nullable JmsListenerContainerFactory<?> factory) {\n\t\tAssert.notNull(endpoint, \"Endpoint must not be null\");\n\t\tAssert.hasText(endpoint.getId(), \"Endpoint id must be set\");\n\n\t\t// Factory may be null, we defer the resolution right before actually creating the container\n\t\tJmsListenerEndpointDescriptor descriptor = new JmsListenerEndpointDescriptor(endpoint, factory);\n\n\t\tsynchronized (this.mutex) {\n\t\t\tif (this.startImmediately) {  // register and start immediately\n\t\t\t\tAssert.state(this.endpointRegistry != null, \"No JmsListenerEndpointRegistry set\");\n\t\t\t\tthis.endpointRegistry.registerListenerContainer(descriptor.endpoint,\n\t\t\t\t\t\tresolveContainerFactory(descriptor), true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.endpointDescriptors.add(descriptor);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A {@link BeanFactory} only needs to be available in conjunction with\n\t * {@link #setContainerFactoryBeanName}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "void",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t\tif (beanFactory instanceof ConfigurableBeanFactory cbf) {\n\t\t\tthis.mutex = cbf.getSingletonMutex();\n\t\t}\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#setContainerFactory(containerFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link JmsListenerContainerFactory} to use in case a {@link JmsListenerEndpoint}\n\t * is registered with a {@code null} container factory.\n\t * <p>Alternatively, the bean name of the {@link JmsListenerContainerFactory} to use\n\t * can be specified for a lazy lookup, see {@link #setContainerFactoryBeanName}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "containerFactory"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "void",
    "signature": "public void setContainerFactory(JmsListenerContainerFactory<?> containerFactory)",
    "source_code": "\tpublic void setContainerFactory(JmsListenerContainerFactory<?> containerFactory) {\n\t\tthis.containerFactory = containerFactory;\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#setContainerFactoryBeanName(containerFactoryBeanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the bean name of the {@link JmsListenerContainerFactory} to use in case\n\t * a {@link JmsListenerEndpoint} is registered with a {@code null} container factory.\n\t * Alternatively, the container factory instance can be registered directly:\n\t * see {@link #setContainerFactory(JmsListenerContainerFactory)}.\n\t * @see #setBeanFactory\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "containerFactoryBeanName"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "void",
    "signature": "public void setContainerFactoryBeanName(String containerFactoryBeanName)",
    "source_code": "\tpublic void setContainerFactoryBeanName(String containerFactoryBeanName) {\n\t\tthis.containerFactoryBeanName = containerFactoryBeanName;\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#setEndpointRegistry(endpointRegistry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link JmsListenerEndpointRegistry} instance to use.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "endpointRegistry"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "void",
    "signature": "public void setEndpointRegistry(@Nullable JmsListenerEndpointRegistry endpointRegistry)",
    "source_code": "\tpublic void setEndpointRegistry(@Nullable JmsListenerEndpointRegistry endpointRegistry) {\n\t\tthis.endpointRegistry = endpointRegistry;\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#setMessageHandlerMethodFactory(messageHandlerMethodFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link MessageHandlerMethodFactory} to use to configure the message\n\t * listener responsible to serve an endpoint detected by this processor.\n\t * <p>By default, {@link DefaultMessageHandlerMethodFactory} is used and it\n\t * can be configured further to support additional method arguments\n\t * or to customize conversion and validation support. See\n\t * {@link DefaultMessageHandlerMethodFactory} javadoc for more details.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageHandlerMethodFactory"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "void",
    "signature": "public void setMessageHandlerMethodFactory(@Nullable MessageHandlerMethodFactory messageHandlerMethodFactory)",
    "source_code": "\tpublic void setMessageHandlerMethodFactory(@Nullable MessageHandlerMethodFactory messageHandlerMethodFactory) {\n\t\tthis.messageHandlerMethodFactory = messageHandlerMethodFactory;\n\t}"
  },
  "org.springframework.jms.config.endpoint": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "signature": "public JmsListenerEndpoint endpoint",
    "source_code": "\t\tpublic final JmsListenerEndpoint endpoint;",
    "type": "JmsListenerEndpoint"
  },
  "org.springframework.jms.connection.UserCredentialsConnectionFactoryAdapter#doCreateContext(username,password)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 312
    },
    "return": "JMSContext",
    "signature": "protected JMSContext doCreateContext(@Nullable String username, @Nullable String password)",
    "source_code": "\tprotected JMSContext doCreateContext(@Nullable String username, @Nullable String password) {\n\t\tif (StringUtils.hasLength(username)) {\n\t\t\treturn obtainTargetConnectionFactory().createContext(username, password);\n\t\t}\n\t\telse {\n\t\t\treturn obtainTargetConnectionFactory().createContext();\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.UserCredentialsConnectionFactoryAdapter#doCreateContext(username,password,sessionMode)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "username",
      "password",
      "sessionMode"
    ],
    "position": {
      "column": 1,
      "line": 342
    },
    "return": "JMSContext",
    "signature": "protected JMSContext doCreateContext(@Nullable String username, @Nullable String password, int sessionMode)",
    "source_code": "\tprotected JMSContext doCreateContext(@Nullable String username, @Nullable String password, int sessionMode) {\n\t\tif (StringUtils.hasLength(username)) {\n\t\t\treturn obtainTargetConnectionFactory().createContext(username, password, sessionMode);\n\t\t}\n\t\telse {\n\t\t\treturn obtainTargetConnectionFactory().createContext(sessionMode);\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#setVirtualThreads(virtualThreads)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether the default {@link SimpleAsyncTaskExecutor} should be\n\t * configured to use virtual threads instead of platform threads, for\n\t * efficient blocking behavior in listener threads on Java 21 or higher.\n\t * This is off by default, setting up one platform thread per consumer.\n\t * <p>Only applicable if the internal default executor is in use rather than\n\t * an externally provided {@link #setTaskExecutor TaskExecutor} instance.\n\t * The thread name prefix for virtual threads will be derived from the\n\t * listener container's bean name, just like with default platform threads.\n\t * <p>Alternatively, pass in a virtual threads based executor through\n\t * {@link #setTaskExecutor} (with externally defined thread naming).\n\t * <p>Consider specifying concurrency limits through {@link #setConcurrency}\n\t * or {@link #setConcurrentConsumers}/{@link #setMaxConcurrentConsumers},\n\t * for potential dynamic scaling. This works fine with the default executor;\n\t * see {@link #setIdleReceivesPerTaskLimit} with its effective default of 10.\n\t * @since 6.2\n\t * @see #setTaskExecutor\n\t * @see SimpleAsyncTaskExecutor#setVirtualThreads\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "virtualThreads"
    ],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "void",
    "signature": "public void setVirtualThreads(boolean virtualThreads)",
    "source_code": "\tpublic void setVirtualThreads(boolean virtualThreads) {\n\t\tthis.virtualThreads = virtualThreads;\n\t}"
  },
  "org.springframework.mail.javamail.MimeMessageHelper#addInline(contentId,inlineFilename,dataSource)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an inline element to the MimeMessage, taking the content from a\n\t * {@code jakarta.activation.DataSource} and assigning the provided\n\t * {@code inlineFileName} to the element.\n\t * <p>Note that the InputStream returned by the DataSource implementation\n\t * needs to be a <i>fresh one on each call</i>, as JavaMail will invoke\n\t * {@code getInputStream()} multiple times.\n\t * <p><b>NOTE:</b> Invoke {@code addInline} <i>after</i> {@link #setText};\n\t * else, mail readers might not be able to resolve inline references correctly.\n\t * @param contentId the content ID to use. Will end up as \"Content-ID\" header\n\t * in the body part, surrounded by angle brackets: for example, \"myId\" &rarr; \"&lt;myId&gt;\".\n\t * Can be referenced in HTML source via src=\"cid:myId\" expressions.\n\t * @param inlineFilename the fileName to use for the inline element's part\n\t * @param dataSource the {@code jakarta.activation.DataSource} to take\n\t * the content from, determining the InputStream and the content type\n\t * @throws MessagingException in case of errors\n\t * @since 6.2\n\t * @see #addInline(String, java.io.File)\n\t * @see #addInline(String, org.springframework.core.io.Resource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentId",
      "inlineFilename",
      "dataSource"
    ],
    "position": {
      "column": 1,
      "line": 932
    },
    "return": "void",
    "signature": "public void addInline(String contentId, @Nullable String inlineFilename, DataSource dataSource)",
    "source_code": "\tpublic void addInline(String contentId, @Nullable String inlineFilename, DataSource dataSource)"
  },
  "org.springframework.mail.javamail.MimeMessageHelper#addInline(contentId,inlineFilename,inputStreamSource)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an inline element to the MimeMessage, taking the content from an\n\t * {@code org.springframework.core.InputStreamResource}, and\n\t * specifying the inline fileName explicitly.\n\t * <p>The content type will be determined by the name of the given\n\t * content file. Do not use this for temporary files with arbitrary\n\t * filenames (possibly ending in \".tmp\" or the like)!\n\t * <p>Note that the InputStream returned by the InputStreamSource implementation\n\t * needs to be a <i>fresh one on each call</i>, as JavaMail will invoke\n\t * {@code getInputStream()} multiple times.\n\t * <p><b>NOTE:</b> Invoke {@code addInline} <i>after</i> {@code setText};\n\t * else, mail readers might not be able to resolve inline references correctly.\n\t * @param contentId the content ID to use. Will end up as \"Content-ID\" header\n\t * in the body part, surrounded by angle brackets: for example, \"myId\" &rarr; \"&lt;myId&gt;\".\n\t * Can be referenced in HTML source via src=\"cid:myId\" expressions.\n\t * @param inlineFilename the file name to use for the inline element\n\t * @param inputStreamSource the resource to take the content from\n\t * @throws MessagingException in case of errors\n\t * @since 6.2\n\t * @see #setText(String)\n\t * @see #getFileTypeMap\n\t * @see #addInline(String, org.springframework.core.io.Resource)\n\t * @see #addInline(String, String, jakarta.activation.DataSource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentId",
      "inlineFilename",
      "inputStreamSource"
    ],
    "position": {
      "column": 1,
      "line": 1056
    },
    "return": "void",
    "signature": "public void addInline(String contentId, String inlineFilename, InputStreamSource inputStreamSource)",
    "source_code": "\tpublic void addInline(String contentId, String inlineFilename, InputStreamSource inputStreamSource)"
  },
  "org.springframework.mail.javamail.MimeMessageHelper#addInline(contentId,inlineFilename,inputStreamSource,contentType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an inline element to the MimeMessage, taking the content from an\n\t * {@code org.springframework.core.InputStreamResource}, and\n\t * specifying the inline fileName and content type explicitly.\n\t * <p>You can determine the content type for any given filename via a Java\n\t * Activation Framework's FileTypeMap, for example the one held by this helper.\n\t * <p>Note that the InputStream returned by the InputStreamSource implementation\n\t * needs to be a <i>fresh one on each call</i>, as JavaMail will invoke\n\t * {@code getInputStream()} multiple times.\n\t * <p><b>NOTE:</b> Invoke {@code addInline} <i>after</i> {@code setText};\n\t * else, mail readers might not be able to resolve inline references correctly.\n\t * @param contentId the content ID to use. Will end up as \"Content-ID\" header\n\t * in the body part, surrounded by angle brackets: for example, \"myId\" &rarr; \"&lt;myId&gt;\".\n\t * Can be referenced in HTML source via src=\"cid:myId\" expressions.\n\t * @param inlineFilename the fileName to use for the inline element's part\n\t * @param inputStreamSource the resource to take the content from\n\t * @param contentType the content type to use for the element\n\t * @throws MessagingException in case of errors\n\t * @since 6.2\n\t * @see #setText\n\t * @see #getFileTypeMap\n\t * @see #addInline(String, org.springframework.core.io.Resource)\n\t * @see #addInline(String, String, jakarta.activation.DataSource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentId",
      "inlineFilename",
      "inputStreamSource",
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 1087
    },
    "return": "void",
    "signature": "public void addInline(String contentId, String inlineFilename, InputStreamSource inputStreamSource, String contentType)",
    "source_code": "\tpublic void addInline(String contentId, String inlineFilename, InputStreamSource inputStreamSource, String contentType)"
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#brokerChannelExecutor(clientInboundChannel,clientOutboundChannel)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel"
    ],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "TaskExecutor",
    "signature": "public TaskExecutor brokerChannelExecutor(AbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel)",
    "source_code": "\tpublic TaskExecutor brokerChannelExecutor("
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#clientInboundChannelExecutor()": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "TaskExecutor",
    "signature": "public TaskExecutor clientInboundChannelExecutor()",
    "source_code": "\tpublic TaskExecutor clientInboundChannelExecutor() {\n\t\tChannelRegistration registration = getClientInboundChannelRegistration();\n\t\tTaskExecutor executor = getTaskExecutor(registration, \"clientInboundChannel-\", this::defaultTaskExecutor);\n\t\tif (executor instanceof ExecutorConfigurationSupport executorSupport) {\n\t\t\texecutorSupport.setPhase(getPhase());\n\t\t}\n\t\treturn executor;\n\t}"
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#clientOutboundChannelExecutor()": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "TaskExecutor",
    "signature": "public TaskExecutor clientOutboundChannelExecutor()",
    "source_code": "\tpublic TaskExecutor clientOutboundChannelExecutor() {\n\t\tChannelRegistration registration = getClientOutboundChannelRegistration();\n\t\tTaskExecutor executor = getTaskExecutor(registration, \"clientOutboundChannel-\", this::defaultTaskExecutor);\n\t\tif (executor instanceof ExecutorConfigurationSupport executorSupport) {\n\t\t\texecutorSupport.setPhase(getPhase());\n\t\t}\n\t\treturn executor;\n\t}"
  },
  "org.springframework.messaging.support.MessageHeaderAccessor#fromMap(Map<String,map)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an instance from a plain {@link Map}.\n\t * @param map the raw headers\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "MessageHeaderAccessor",
    "signature": "public MessageHeaderAccessor fromMap(@Nullable Map<String, Object> map)",
    "source_code": "\tpublic static MessageHeaderAccessor fromMap(@Nullable Map<String, Object> map) {\n\t\treturn fromMessageHeaders(new MessageHeaders(map));\n\t}"
  },
  "org.springframework.messaging.support.MessageHeaderAccessor#fromMessageHeaders(headers)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an instance from an existing {@link MessageHeaders} instance.\n\t * @param headers the headers\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "MessageHeaderAccessor",
    "signature": "public MessageHeaderAccessor fromMessageHeaders(@Nullable MessageHeaders headers)",
    "source_code": "\tpublic static MessageHeaderAccessor fromMessageHeaders(@Nullable MessageHeaders headers) {\n\t\treturn new MessageHeaderAccessor(headers);\n\t}"
  },
  "org.springframework.mock.web.MockHttpServletRequest#getUriTemplate()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the original URI template used to prepare the request, if any.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1305
    },
    "return": "String",
    "signature": "public String getUriTemplate()",
    "source_code": "\tpublic String getUriTemplate() {\n\t\treturn this.uriTemplate;\n\t}"
  },
  "org.springframework.mock.web.MockHttpServletRequest#setUriTemplate(uriTemplate)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the original URI template used to prepare the request, if any.\n\t * @param uriTemplate the URI template used to set up the request, if any\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate"
    ],
    "position": {
      "column": 1,
      "line": 1296
    },
    "return": "void",
    "signature": "public void setUriTemplate(@Nullable String uriTemplate)",
    "source_code": "\tpublic void setUriTemplate(@Nullable String uriTemplate) {\n\t\tthis.uriTemplate = uriTemplate;\n\t}"
  },
  "org.springframework.mock.web.MockHttpServletResponse#sendRedirect(url,sc,clearBuffer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "sc",
      "clearBuffer"
    ],
    "position": {
      "column": 1,
      "line": 640
    },
    "return": "void",
    "signature": "public void sendRedirect(String url, int sc, boolean clearBuffer)",
    "source_code": "\tpublic void sendRedirect(String url, int sc, boolean clearBuffer) throws IOException {\n\t\tAssert.state(!isCommitted(), \"Cannot send redirect - response is already committed\");\n\t\tAssert.notNull(url, \"Redirect URL must not be null\");\n\t\tsetHeader(HttpHeaders.LOCATION, url);\n\t\tsetStatus(sc);\n\t\tsetCommitted(true);\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#afterSingletonsInstantiated()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 609
    },
    "return": "void",
    "signature": "public void afterSingletonsInstantiated()",
    "source_code": "\tpublic void afterSingletonsInstantiated() {\n\t\t// Enforce completion of asynchronous Hibernate initialization before context refresh completion.\n\t\tif (this.sessionFactory instanceof InfrastructureProxy proxy) {\n\t\t\tproxy.getWrappedObject();\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.AbstractEntityManagerFactoryBean#afterSingletonsInstantiated()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 411
    },
    "return": "void",
    "signature": "public void afterSingletonsInstantiated()",
    "source_code": "\tpublic void afterSingletonsInstantiated() {\n\t\t// Enforce completion of asynchronous JPA initialization before context refresh completion.\n\t\tgetNativeEntityManagerFactory();\n\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bindValues(source)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source"
    ],
    "position": {
      "column": 1,
      "line": 313
    },
    "return": "GenericExecuteSpec",
    "signature": "public GenericExecuteSpec bindValues(List<?> source)",
    "source_code": "\t\tpublic GenericExecuteSpec bindValues(List<?> source) {\n\t\t\tassertNotPreparedOperation();\n\t\t\tAssert.notNull(source, \"Source list must not be null\");\n\t\t\tMap<Integer, Parameter> byIndex = new LinkedHashMap<>(this.byIndex);\n\t\t\tListIterator<?> listIterator = source.listIterator();\n\t\t\twhile (listIterator.hasNext()) {\n\t\t\t\tbyIndex.put(listIterator.nextIndex(), resolveParameter(listIterator.next()));\n\t\t\t}\n\t\t\treturn new DefaultGenericExecuteSpec(byIndex, this.byName, this.sqlSupplier, this.filterFunction);\n\t\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#toString()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn this.displayName;\n\t\t}"
  },
  "org.springframework.scheduling.annotation.AsyncResult#forExecutionException(ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new async result which exposes the given exception as an\n\t * {@link ExecutionException} from {@link Future#get()}.\n\t * @param ex the exception to expose (either an pre-built {@link ExecutionException}\n\t * or a cause to be wrapped in an {@link ExecutionException})\n\t * @since 4.2\n\t * @see ExecutionException\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "ListenableFuture<V>",
    "signature": "public ListenableFuture<V> forExecutionException(Throwable ex)",
    "source_code": "\tpublic static <V> ListenableFuture<V> forExecutionException(Throwable ex) {\n\t\treturn new AsyncResult<>(null, ex);\n\t}"
  },
  "org.springframework.scheduling.annotation.AsyncResult#forValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new async result which exposes the given value from {@link Future#get()}.\n\t * @param value the value to expose\n\t * @since 4.2\n\t * @see Future#get()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "ListenableFuture<V>",
    "signature": "public ListenableFuture<V> forValue(V value)",
    "source_code": "\tpublic static <V> ListenableFuture<V> forValue(V value) {\n\t\treturn new AsyncResult<>(value, null);\n\t}"
  },
  "org.springframework.scheduling.concurrent.DEFAULT_PHASE": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * The default phase for an executor {@link SmartLifecycle}: {@code Integer.MAX_VALUE / 2}.\n\t * <p>This is different from the default phase {@code Integer.MAX_VALUE} associated with\n\t * other {@link SmartLifecycle} implementations, putting the typically auto-started\n\t * executor/scheduler beans into an earlier startup phase and a later shutdown phase while\n\t * still leaving room for regular {@link Lifecycle} components with the common phase 0.\n\t * @since 6.2\n\t * @see #getPhase()\n\t * @see SmartLifecycle#DEFAULT_PHASE\n\t * @see org.springframework.context.support.DefaultLifecycleProcessor#setTimeoutPerShutdownPhase\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "signature": "public int DEFAULT_PHASE",
    "source_code": "\tpublic static final int DEFAULT_PHASE = Integer.MAX_VALUE / 2;",
    "type": "int"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#setVirtualThreads(virtualThreads)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether to use virtual threads instead of platform threads.\n\t * This is off by default, setting up a traditional platform thread pool.\n\t * <p>Set this flag to {@code true} on Java 21 or higher for a tightly\n\t * managed thread pool setup with virtual threads. In contrast to\n\t * {@link SimpleAsyncTaskExecutor}, this is integrated with Spring's\n\t * lifecycle management for stopping and restarting execution threads,\n\t * including an early stop signal for a graceful shutdown arrangement.\n\t * <p>Specify either this or {@link #setThreadFactory}, not both.\n\t * @since 6.2\n\t * @see #setThreadFactory\n\t * @see VirtualThreadTaskExecutor#getVirtualThreadFactory()\n\t * @see SimpleAsyncTaskExecutor#setVirtualThreads\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "virtualThreads"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "void",
    "signature": "public void setVirtualThreads(boolean virtualThreads)",
    "source_code": "\tpublic void setVirtualThreads(boolean virtualThreads) {\n\t\tthis.virtualThreads = virtualThreads;\n\t\tthis.threadFactory = this;\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#execute(task)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "void",
    "signature": "public void execute(Runnable task)",
    "source_code": "\tpublic void execute(Runnable task) {\n\t\tsuper.execute(TaskUtils.decorateTaskWithErrorHandler(task, this.errorHandler, false));\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#setErrorHandler(errorHandler)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide an {@link ErrorHandler} strategy.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorHandler"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "void",
    "signature": "public void setErrorHandler(ErrorHandler errorHandler)",
    "source_code": "\tpublic void setErrorHandler(ErrorHandler errorHandler) {\n\t\tAssert.notNull(errorHandler, \"ErrorHandler must not be null\");\n\t\tthis.errorHandler = errorHandler;\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#submit(task)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 268
    },
    "return": "Future<T>",
    "signature": "public Future<T> submit(Callable<T> task)",
    "source_code": "\tpublic <T> Future<T> submit(Callable<T> task) {\n\t\treturn super.submit(new DelegatingErrorHandlingCallable<>(task, this.errorHandler));\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#call()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 478
    },
    "return": "V",
    "signature": "public V call()",
    "source_code": "\t\tpublic V call() throws Exception {\n\t\t\ttry {\n\t\t\t\treturn this.delegate.call();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthis.errorHandler.handleError(ex);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#cancel(mayInterruptIfRunning)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mayInterruptIfRunning"
    ],
    "position": {
      "column": 1,
      "line": 512
    },
    "return": "boolean",
    "signature": "public boolean cancel(boolean mayInterruptIfRunning)",
    "source_code": "\t\tpublic boolean cancel(boolean mayInterruptIfRunning) {\n\t\t\treturn this.future.cancel(mayInterruptIfRunning);\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#compareTo(o)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o"
    ],
    "position": {
      "column": 1,
      "line": 547
    },
    "return": "int",
    "signature": "public int compareTo(Delayed o)",
    "source_code": "\t\tpublic int compareTo(Delayed o) {\n\t\t\treturn this.future.compareTo(o);\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#decorateTask(callable,task)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "callable",
      "task"
    ],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "RunnableScheduledFuture<V>",
    "signature": "protected RunnableScheduledFuture<V> decorateTask(Callable<V> callable, RunnableScheduledFuture<V> task)",
    "source_code": "\t\t\tprotected <V> RunnableScheduledFuture<V> decorateTask(Callable<V> callable, RunnableScheduledFuture<V> task) {\n\t\t\t\treturn decorateTaskIfNecessary(task);\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#decorateTask(runnable,task)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "runnable",
      "task"
    ],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "RunnableScheduledFuture<V>",
    "signature": "protected RunnableScheduledFuture<V> decorateTask(Runnable runnable, RunnableScheduledFuture<V> task)",
    "source_code": "\t\t\tprotected <V> RunnableScheduledFuture<V> decorateTask(Runnable runnable, RunnableScheduledFuture<V> task) {\n\t\t\t\treturn decorateTaskIfNecessary(task);\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#get()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 527
    },
    "return": "V",
    "signature": "public V get()",
    "source_code": "\t\tpublic V get() throws InterruptedException, ExecutionException {\n\t\t\treturn this.future.get();\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#get(timeout,unit)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeout",
      "unit"
    ],
    "position": {
      "column": 1,
      "line": 532
    },
    "return": "V",
    "signature": "public V get(long timeout, TimeUnit unit)",
    "source_code": "\t\tpublic V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n\t\t\treturn this.future.get(timeout, unit);\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#getDelay(unit)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "unit"
    ],
    "position": {
      "column": 1,
      "line": 542
    },
    "return": "long",
    "signature": "public long getDelay(TimeUnit unit)",
    "source_code": "\t\tpublic long getDelay(TimeUnit unit) {\n\t\t\treturn this.future.getDelay(unit);\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#isCancelled()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 517
    },
    "return": "boolean",
    "signature": "public boolean isCancelled()",
    "source_code": "\t\tpublic boolean isCancelled() {\n\t\t\treturn this.future.isCancelled();\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#isDone()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 522
    },
    "return": "boolean",
    "signature": "public boolean isDone()",
    "source_code": "\t\tpublic boolean isDone() {\n\t\t\treturn this.future.isDone();\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#isPeriodic()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 537
    },
    "return": "boolean",
    "signature": "public boolean isPeriodic()",
    "source_code": "\t\tpublic boolean isPeriodic() {\n\t\t\treturn this.future.isPeriodic();\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#run()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 507
    },
    "return": "void",
    "signature": "public void run()",
    "source_code": "\t\tpublic void run() {\n\t\t\tthis.decoratedRunnable.run();\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#setTaskDecorator(taskDecorator)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify a custom {@link TaskDecorator} to be applied to any {@link Runnable}\n\t * about to be executed.\n\t * <p>Note that such a decorator is not being applied to the user-supplied\n\t * {@code Runnable}/{@code Callable} but rather to the scheduled execution\n\t * callback (a wrapper around the user-supplied task).\n\t * <p>The primary use case is to set some execution context around the task's\n\t * invocation, or to provide some monitoring/statistics for task execution.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "taskDecorator"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "void",
    "signature": "public void setTaskDecorator(TaskDecorator taskDecorator)",
    "source_code": "\tpublic void setTaskDecorator(TaskDecorator taskDecorator) {\n\t\tthis.taskDecorator = taskDecorator;\n\t}"
  },
  "org.springframework.scheduling.config.Status": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Status of the task execution outcome.\n\t */",
    "kind": "enum",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "signature": "public enum Status",
    "source_code": "\tpublic enum Status {\n\n\t\t/**\n\t\t * The task has not been executed so far.\n\t\t */\n\t\tNONE,\n\n\t\t/**\n\t\t * The task execution has been started and is ongoing.\n\t\t */\n\t\tSTARTED,\n\n\t\t/**\n\t\t * The task execution finished successfully.\n\t\t */\n\t\tSUCCESS,\n\n\t\t/**\n\t\t * The task execution finished with an error.\n\t\t */\n\t\tERROR\n\n\t}"
  },
  "org.springframework.scheduling.config.Task": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Holder class defining a {@code Runnable} to be executed as a task, typically at a\n * scheduled time or interval. See subclass hierarchy for various scheduling approaches.\n *\n * @author Chris Beams\n * @author Juergen Hoeller\n * @author Brian Clozel\n * @since 3.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 34
    },
    "signature": "public class Task",
    "source_code": "public class Task {\n\n\tprivate final Runnable runnable;\n\n\tprivate TaskExecutionOutcome lastExecutionOutcome;\n\n\n\t/**\n\t * Create a new {@code Task}.\n\t * @param runnable the underlying task to execute\n\t */\n\tpublic Task(Runnable runnable) {\n\t\tAssert.notNull(runnable, \"Runnable must not be null\");\n\t\tthis.runnable = new OutcomeTrackingRunnable(runnable);\n\t\tthis.lastExecutionOutcome = TaskExecutionOutcome.create();\n\t}\n\n\n\t/**\n\t * Return the underlying task.\n\t */\n\tpublic Runnable getRunnable() {\n\t\treturn this.runnable;\n\t}\n\n\t/**\n\t * Return the outcome of the last task execution.\n\t * @since 6.2\n\t */\n\tpublic TaskExecutionOutcome getLastExecutionOutcome() {\n\t\treturn this.lastExecutionOutcome;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn this.runnable.toString();\n\t}\n\n\n\tprivate class OutcomeTrackingRunnable implements SchedulingAwareRunnable {\n\n\t\tprivate final Runnable runnable;\n\n\t\tpublic OutcomeTrackingRunnable(Runnable runnable) {\n\t\t\tthis.runnable = runnable;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\ttry {\n\t\t\t\tTask.this.lastExecutionOutcome = Task.this.lastExecutionOutcome.start(Instant.now());\n\t\t\t\tthis.runnable.run();\n\t\t\t\tTask.this.lastExecutionOutcome = Task.this.lastExecutionOutcome.success();\n\t\t\t}\n\t\t\tcatch (Throwable exc) {\n\t\t\t\tTask.this.lastExecutionOutcome = Task.this.lastExecutionOutcome.failure(exc);\n\t\t\t\tthrow exc;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isLongLived() {\n\t\t\tif (this.runnable instanceof SchedulingAwareRunnable sar) {\n\t\t\t\treturn sar.isLongLived();\n\t\t\t}\n\t\t\treturn SchedulingAwareRunnable.super.isLongLived();\n\t\t}\n\n\t\t@Nullable\n\t\t@Override\n\t\tpublic String getQualifier() {\n\t\t\tif (this.runnable instanceof SchedulingAwareRunnable sar) {\n\t\t\t\treturn sar.getQualifier();\n\t\t\t}\n\t\t\treturn SchedulingAwareRunnable.super.getQualifier();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn this.runnable.toString();\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.scheduling.config.Task#getLastExecutionOutcome()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the outcome of the last task execution.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "TaskExecutionOutcome",
    "signature": "public TaskExecutionOutcome getLastExecutionOutcome()",
    "source_code": "\tpublic TaskExecutionOutcome getLastExecutionOutcome() {\n\t\treturn this.lastExecutionOutcome;\n\t}"
  },
  "org.springframework.scheduling.config.Task#getQualifier()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "String",
    "signature": "public String getQualifier()",
    "source_code": "\t\tpublic String getQualifier() {\n\t\t\tif (this.runnable instanceof SchedulingAwareRunnable sar) {\n\t\t\t\treturn sar.getQualifier();\n\t\t\t}\n\t\t\treturn SchedulingAwareRunnable.super.getQualifier();\n\t\t}"
  },
  "org.springframework.scheduling.config.Task#getRunnable()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the underlying task.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 55
    },
    "return": "Runnable",
    "signature": "public Runnable getRunnable()",
    "source_code": "\tpublic Runnable getRunnable() {\n\t\treturn this.runnable;\n\t}"
  },
  "org.springframework.scheduling.config.Task#isLongLived()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "boolean",
    "signature": "public boolean isLongLived()",
    "source_code": "\t\tpublic boolean isLongLived() {\n\t\t\tif (this.runnable instanceof SchedulingAwareRunnable sar) {\n\t\t\t\treturn sar.isLongLived();\n\t\t\t}\n\t\t\treturn SchedulingAwareRunnable.super.isLongLived();\n\t\t}"
  },
  "org.springframework.scheduling.config.Task#run()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "void",
    "signature": "public void run()",
    "source_code": "\t\tpublic void run() {\n\t\t\ttry {\n\t\t\t\tTask.this.lastExecutionOutcome = Task.this.lastExecutionOutcome.start(Instant.now());\n\t\t\t\tthis.runnable.run();\n\t\t\t\tTask.this.lastExecutionOutcome = Task.this.lastExecutionOutcome.success();\n\t\t\t}\n\t\t\tcatch (Throwable exc) {\n\t\t\t\tTask.this.lastExecutionOutcome = Task.this.lastExecutionOutcome.failure(exc);\n\t\t\t\tthrow exc;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.scheduling.config.Task#toString()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn this.runnable.toString();\n\t\t}"
  },
  "org.springframework.scheduling.config.TaskExecutionOutcome": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Outcome of a {@link Task} execution.\n *\n * @author Brian Clozel\n * @since 6.2\n * @param executionTime the instant when the task execution started, or\n * {@code null} if the task has not started\n * @param status the {@link Status} of the execution outcome\n * @param throwable the exception thrown from the task execution, if any\n */",
    "kind": "record",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 34
    },
    "signature": "public record TaskExecutionOutcome",
    "source_code": "public record TaskExecutionOutcome(@Nullable Instant executionTime, Status status, @Nullable Throwable throwable) {\n\n\tTaskExecutionOutcome start(Instant executionTime) {\n\t\treturn new TaskExecutionOutcome(executionTime, Status.STARTED, null);\n\t}\n\n\tTaskExecutionOutcome success() {\n\t\tAssert.state(this.executionTime != null, \"Task has not been started yet\");\n\t\treturn new TaskExecutionOutcome(this.executionTime, Status.SUCCESS, null);\n\t}\n\n\tTaskExecutionOutcome failure(Throwable throwable) {\n\t\tAssert.state(this.executionTime != null, \"Task has not been started yet\");\n\t\treturn new TaskExecutionOutcome(this.executionTime, Status.ERROR, throwable);\n\t}\n\n\tstatic TaskExecutionOutcome create() {\n\t\treturn new TaskExecutionOutcome(null, Status.NONE, null);\n\t}\n\n\n\t/**\n\t * Status of the task execution outcome.\n\t */\n\tpublic enum Status {\n\n\t\t/**\n\t\t * The task has not been executed so far.\n\t\t */\n\t\tNONE,\n\n\t\t/**\n\t\t * The task execution has been started and is ongoing.\n\t\t */\n\t\tSTARTED,\n\n\t\t/**\n\t\t * The task execution finished successfully.\n\t\t */\n\t\tSUCCESS,\n\n\t\t/**\n\t\t * The task execution finished with an error.\n\t\t */\n\t\tERROR\n\n\t}\n\n}"
  },
  "org.springframework.scheduling.config.TaskExecutionOutcome#<init>(executionTime,status,throwable)": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Outcome of a {@link Task} execution.\n *\n * @author Brian Clozel\n * @since 6.2\n * @param executionTime the instant when the task execution started, or\n * {@code null} if the task has not started\n * @param status the {@link Status} of the execution outcome\n * @param throwable the exception thrown from the task execution, if any\n */",
    "kind": "constructor",
    "modifiers": [
      "public"
    ],
    "params": [
      "executionTime",
      "status",
      "throwable"
    ],
    "position": {
      "column": 1,
      "line": 34
    },
    "signature": "public TaskExecutionOutcome(@Nullable Instant executionTime, Status status, @Nullable Throwable throwable)",
    "source_code": "public record TaskExecutionOutcome(@Nullable Instant executionTime, Status status, @Nullable Throwable throwable) {\n\n\tTaskExecutionOutcome start(Instant executionTime) {\n\t\treturn new TaskExecutionOutcome(executionTime, Status.STARTED, null);\n\t}\n\n\tTaskExecutionOutcome success() {\n\t\tAssert.state(this.executionTime != null, \"Task has not been started yet\");\n\t\treturn new TaskExecutionOutcome(this.executionTime, Status.SUCCESS, null);\n\t}\n\n\tTaskExecutionOutcome failure(Throwable throwable) {\n\t\tAssert.state(this.executionTime != null, \"Task has not been started yet\");\n\t\treturn new TaskExecutionOutcome(this.executionTime, Status.ERROR, throwable);\n\t}\n\n\tstatic TaskExecutionOutcome create() {\n\t\treturn new TaskExecutionOutcome(null, Status.NONE, null);\n\t}\n\n\n\t/**\n\t * Status of the task execution outcome.\n\t */\n\tpublic enum Status {\n\n\t\t/**\n\t\t * The task has not been executed so far.\n\t\t */\n\t\tNONE,\n\n\t\t/**\n\t\t * The task execution has been started and is ongoing.\n\t\t */\n\t\tSTARTED,\n\n\t\t/**\n\t\t * The task execution finished successfully.\n\t\t */\n\t\tSUCCESS,\n\n\t\t/**\n\t\t * The task execution finished with an error.\n\t\t */\n\t\tERROR\n\n\t}\n\n}"
  },
  "org.springframework.test.context.bean.override.<unknown>#getOrder()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "int",
    "signature": "public int getOrder()",
    "source_code": "\tpublic int getOrder() {\n\t\treturn Ordered.LOWEST_PRECEDENCE - 10;\n\t}"
  },
  "org.springframework.test.context.bean.override.<unknown>#postProcessBeanFactory(beanFactory)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "void",
    "signature": "public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)",
    "source_code": "\tpublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n\t\tSet<String> generatedBeanNames = new HashSet<>();\n\t\tfor (BeanOverrideHandler handler : this.beanOverrideHandlers) {\n\t\t\tregisterBeanOverride(beanFactory, handler, generatedBeanNames);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.bean.override.convention.<unknown>#createHandler(overrideAnnotation,testClass,field)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "overrideAnnotation",
      "testClass",
      "field"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "TestBeanOverrideHandler",
    "signature": "public TestBeanOverrideHandler createHandler(Annotation overrideAnnotation, Class<?> testClass, Field field)",
    "source_code": "\tpublic TestBeanOverrideHandler createHandler(Annotation overrideAnnotation, Class<?> testClass, Field field) {\n\t\tif (!(overrideAnnotation instanceof TestBean testBean)) {\n\t\t\tthrow new IllegalStateException(\"Invalid annotation passed to %s: expected @TestBean on field %s.%s\"\n\t\t\t\t\t.formatted(getClass().getSimpleName(), field.getDeclaringClass().getName(), field.getName()));\n\t\t}\n\n\t\tString beanName = (!testBean.name().isBlank() ? testBean.name() : null);\n\t\tString methodName = testBean.methodName();\n\t\tBeanOverrideStrategy strategy = (testBean.enforceOverride() ? REPLACE : REPLACE_OR_CREATE);\n\n\t\tMethod factoryMethod;\n\t\tif (!methodName.isBlank()) {\n\t\t\t// If the user specified an explicit method name, search for that.\n\t\t\tfactoryMethod = findTestBeanFactoryMethod(field.getDeclaringClass(), field.getType(), methodName);\n\t\t}\n\t\telse {\n\t\t\t// Otherwise, search for candidate factory methods whose names match either\n\t\t\t// the field name or the explicit bean name (if any).\n\t\t\tList<String> candidateMethodNames = new ArrayList<>();\n\t\t\tcandidateMethodNames.add(field.getName());\n\n\t\t\tif (beanName != null) {\n\t\t\t\tcandidateMethodNames.add(beanName);\n\t\t\t}\n\t\t\tfactoryMethod = findTestBeanFactoryMethod(field.getDeclaringClass(), field.getType(), candidateMethodNames);\n\t\t}\n\n\t\treturn new TestBeanOverrideHandler(\n\t\t\t\tfield, ResolvableType.forField(field, testClass), beanName, strategy, factoryMethod);\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.<unknown>#createHandler(overrideAnnotation,testClass,field)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "overrideAnnotation",
      "testClass",
      "field"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "return": "AbstractMockitoBeanOverrideHandler",
    "signature": "public AbstractMockitoBeanOverrideHandler createHandler(Annotation overrideAnnotation, Class<?> testClass, Field field)",
    "source_code": "\tpublic AbstractMockitoBeanOverrideHandler createHandler(Annotation overrideAnnotation, Class<?> testClass, Field field) {\n\t\tif (overrideAnnotation instanceof MockitoBean mockitoBean) {\n\t\t\tAssert.state(mockitoBean.types().length == 0,\n\t\t\t\t\t\"The @MockitoBean 'types' attribute must be omitted when declared on a field\");\n\t\t\treturn new MockitoBeanOverrideHandler(field, ResolvableType.forField(field, testClass), mockitoBean);\n\t\t}\n\t\telse if (overrideAnnotation instanceof MockitoSpyBean mockitoSpyBean) {\n\t\t\tAssert.state(mockitoSpyBean.types().length == 0,\n\t\t\t\t\t\"The @MockitoSpyBean 'types' attribute must be omitted when declared on a field\");\n\t\t\treturn new MockitoSpyBeanOverrideHandler(field, ResolvableType.forField(field, testClass), mockitoSpyBean);\n\t\t}\n\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\tInvalid annotation passed to MockitoBeanOverrideProcessor: \\\n\t\t\t\texpected either @MockitoBean or @MockitoSpyBean on field %s.%s\"\"\"\n\t\t\t\t\t.formatted(field.getDeclaringClass().getName(), field.getName()));\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.<unknown>#createHandlers(overrideAnnotation,testClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "overrideAnnotation",
      "testClass"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "List<BeanOverrideHandler>",
    "signature": "public List<BeanOverrideHandler> createHandlers(Annotation overrideAnnotation, Class<?> testClass)",
    "source_code": "\tpublic List<BeanOverrideHandler> createHandlers(Annotation overrideAnnotation, Class<?> testClass) {\n\t\tif (overrideAnnotation instanceof MockitoBean mockitoBean) {\n\t\t\tClass<?>[] types = mockitoBean.types();\n\t\t\tAssert.state(types.length > 0,\n\t\t\t\t\t\"The @MockitoBean 'types' attribute must not be empty when declared on a class\");\n\t\t\tAssert.state(mockitoBean.name().isEmpty() || types.length == 1,\n\t\t\t\t\t\"The @MockitoBean 'name' attribute cannot be used when mocking multiple types\");\n\t\t\tList<BeanOverrideHandler> handlers = new ArrayList<>();\n\t\t\tfor (Class<?> type : types) {\n\t\t\t\thandlers.add(new MockitoBeanOverrideHandler(ResolvableType.forClass(type), mockitoBean));\n\t\t\t}\n\t\t\treturn handlers;\n\t\t}\n\t\telse if (overrideAnnotation instanceof MockitoSpyBean mockitoSpyBean) {\n\t\t\tClass<?>[] types = mockitoSpyBean.types();\n\t\t\tAssert.state(types.length > 0,\n\t\t\t\t\t\"The @MockitoSpyBean 'types' attribute must not be empty when declared on a class\");\n\t\t\tAssert.state(mockitoSpyBean.name().isEmpty() || types.length == 1,\n\t\t\t\t\t\"The @MockitoSpyBean 'name' attribute cannot be used when mocking multiple types\");\n\t\t\tList<BeanOverrideHandler> handlers = new ArrayList<>();\n\t\t\tfor (Class<?> type : types) {\n\t\t\t\thandlers.add(new MockitoSpyBeanOverrideHandler(ResolvableType.forClass(type), mockitoSpyBean));\n\t\t\t}\n\t\t\treturn handlers;\n\t\t}\n\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\tInvalid annotation passed to MockitoBeanOverrideProcessor: \\\n\t\t\t\texpected either @MockitoBean or @MockitoSpyBean on test class %s\"\"\"\n\t\t\t\t\t.formatted(testClass.getName()));\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.<unknown>#createOverrideInstance(beanName,existingBeanDefinition,existingBeanInstance)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "existingBeanDefinition",
      "existingBeanInstance"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "Object",
    "signature": "protected Object createOverrideInstance(String beanName,\n\t\t\t@Nullable BeanDefinition existingBeanDefinition, @Nullable Object existingBeanInstance)",
    "source_code": "\tprotected Object createOverrideInstance(String beanName,"
  },
  "org.springframework.test.context.bean.override.mockito.<unknown>#equals(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\tif (other == this) {\n\t\t\treturn true;\n\t\t}\n\t\treturn (other instanceof AbstractMockitoBeanOverrideHandler that && super.equals(that) &&\n\t\t\t\tthis.reset == that.reset);\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.<unknown>#hashCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn super.hashCode() + this.reset.hashCode();\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.<unknown>#toString()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn new ToStringCreator(this)\n\t\t\t\t.append(\"field\", getField())\n\t\t\t\t.append(\"beanType\", getBeanType())\n\t\t\t\t.append(\"beanName\", getBeanName())\n\t\t\t\t.append(\"strategy\", getStrategy())\n\t\t\t\t.append(\"reset\", getReset())\n\t\t\t\t.toString();\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.<unknown>#trackOverrideInstance(mock,trackingBeanRegistry)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mock",
      "trackingBeanRegistry"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "void",
    "signature": "protected void trackOverrideInstance(Object mock, SingletonBeanRegistry trackingBeanRegistry)",
    "source_code": "\tprotected void trackOverrideInstance(Object mock, SingletonBeanRegistry trackingBeanRegistry) {\n\t\tgetMockBeans(trackingBeanRegistry).add(mock);\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockReset": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Reset strategy used on a mock bean.\n *\n * <p>Usually applied to a mock via the {@link MockitoBean @MockitoBean} or\n * {@link MockitoSpyBean @MockitoSpyBean} annotation but can also be directly\n * applied to any mock in the {@code ApplicationContext} using the static methods\n * in this class.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n * @since 6.2\n * @see MockitoResetTestExecutionListener\n */",
    "kind": "enum",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "signature": "public enum MockReset",
    "source_code": "public enum MockReset {\n\n\t/**\n\t * Reset the mock before the test method runs.\n\t */\n\tBEFORE,\n\n\t/**\n\t * Reset the mock after the test method runs.\n\t */\n\tAFTER,\n\n\t/**\n\t * Do not reset the mock.\n\t */\n\tNONE;\n\n\n\t/**\n\t * Create {@link MockSettings settings} to be used with mocks where reset\n\t * should occur before each test method runs.\n\t * @return mock settings\n\t */\n\tpublic static MockSettings before() {\n\t\treturn withSettings(BEFORE);\n\t}\n\n\t/**\n\t * Create {@link MockSettings settings} to be used with mocks where reset\n\t * should occur after each test method runs.\n\t * @return mock settings\n\t */\n\tpublic static MockSettings after() {\n\t\treturn withSettings(AFTER);\n\t}\n\n\t/**\n\t * Create {@link MockSettings settings} to be used with mocks where a\n\t * specific reset should occur.\n\t * @param reset the reset type\n\t * @return mock settings\n\t */\n\tpublic static MockSettings withSettings(MockReset reset) {\n\t\treturn apply(reset, Mockito.withSettings());\n\t}\n\n\t/**\n\t * Apply {@link MockReset} to existing {@link MockSettings settings}.\n\t * @param reset the reset type\n\t * @param settings the settings\n\t * @return the configured settings\n\t */\n\tpublic static MockSettings apply(MockReset reset, MockSettings settings) {\n\t\tAssert.notNull(settings, \"Settings must not be null\");\n\t\tif (reset != null && reset != NONE) {\n\t\t\tsettings.invocationListeners(new ResetInvocationListener(reset));\n\t\t}\n\t\treturn settings;\n\t}\n\n\t/**\n\t * Get the {@link MockReset} strategy associated with the given mock.\n\t * @param mock the mock\n\t * @return the reset strategy for the given mock, or {@link MockReset#NONE}\n\t * if no strategy is associated with the given mock\n\t */\n\tstatic MockReset get(Object mock) {\n\t\tMockingDetails mockingDetails = Mockito.mockingDetails(mock);\n\t\tif (mockingDetails.isMock()) {\n\t\t\tMockCreationSettings<?> settings = mockingDetails.getMockCreationSettings();\n\t\t\tfor (InvocationListener listener : settings.getInvocationListeners()) {\n\t\t\t\tif (listener instanceof ResetInvocationListener resetInvocationListener) {\n\t\t\t\t\treturn resetInvocationListener.reset;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn MockReset.NONE;\n\t}\n\n\t/**\n\t * Dummy {@link InvocationListener} used to hold the {@link MockReset} value.\n\t */\n\tprivate record ResetInvocationListener(MockReset reset) implements InvocationListener {\n\n\t\t@Override\n\t\tpublic void reportInvocation(MethodInvocationReport methodInvocationReport) {\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.test.context.bean.override.mockito.MockReset#after()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create {@link MockSettings settings} to be used with mocks where reset\n\t * should occur after each test method runs.\n\t * @return mock settings\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "MockSettings",
    "signature": "public MockSettings after()",
    "source_code": "\tpublic static MockSettings after() {\n\t\treturn withSettings(AFTER);\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockReset#apply(reset,settings)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply {@link MockReset} to existing {@link MockSettings settings}.\n\t * @param reset the reset type\n\t * @param settings the settings\n\t * @return the configured settings\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "reset",
      "settings"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "MockSettings",
    "signature": "public MockSettings apply(MockReset reset, MockSettings settings)",
    "source_code": "\tpublic static MockSettings apply(MockReset reset, MockSettings settings) {\n\t\tAssert.notNull(settings, \"Settings must not be null\");\n\t\tif (reset != null && reset != NONE) {\n\t\t\tsettings.invocationListeners(new ResetInvocationListener(reset));\n\t\t}\n\t\treturn settings;\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockReset#before()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create {@link MockSettings settings} to be used with mocks where reset\n\t * should occur before each test method runs.\n\t * @return mock settings\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "MockSettings",
    "signature": "public MockSettings before()",
    "source_code": "\tpublic static MockSettings before() {\n\t\treturn withSettings(BEFORE);\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockReset#reportInvocation(methodInvocationReport)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodInvocationReport"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void reportInvocation(MethodInvocationReport methodInvocationReport)",
    "source_code": "\t\tpublic void reportInvocation(MethodInvocationReport methodInvocationReport) {\n\t\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockReset#withSettings(reset)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create {@link MockSettings settings} to be used with mocks where a\n\t * specific reset should occur.\n\t * @param reset the reset type\n\t * @return mock settings\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "reset"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "MockSettings",
    "signature": "public MockSettings withSettings(MockReset reset)",
    "source_code": "\tpublic static MockSettings withSettings(MockReset reset) {\n\t\treturn apply(reset, Mockito.withSettings());\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockitoResetTestExecutionListener": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * {@code TestExecutionListener} that resets any mock beans that have been marked\n * with a {@link MockReset}.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n * @since 6.2\n * @see MockitoBean @MockitoBean\n * @see MockitoSpyBean @MockitoSpyBean\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "public class MockitoResetTestExecutionListener",
    "source_code": "public class MockitoResetTestExecutionListener extends AbstractTestExecutionListener {\n\n\t/**\n\t * The {@link #getOrder() order} value for this listener\n\t * ({@code Ordered.LOWEST_PRECEDENCE - 100}): {@value}.\n\t * @since 6.2.3\n\t */\n\tpublic static final int ORDER = Ordered.LOWEST_PRECEDENCE - 100;\n\n\tprivate static final Log logger = LogFactory.getLog(MockitoResetTestExecutionListener.class);\n\n\t/**\n\t * Boolean flag which tracks whether Mockito is present in the classpath.\n\t * @see #mockitoInitialized\n\t * @see #isEnabled()\n\t */\n\tprivate static final boolean mockitoPresent = ClassUtils.isPresent(\"org.mockito.Mockito\",\n\t\t\tMockitoResetTestExecutionListener.class.getClassLoader());\n\n\t/**\n\t * Boolean flag which tracks whether Mockito has been successfully initialized\n\t * in the current environment.\n\t * <p>Even if {@link #mockitoPresent} evaluates to {@code true}, this flag\n\t * may eventually evaluate to {@code false} &mdash; for example, in a GraalVM\n\t * native image if the necessary reachability metadata has not been registered\n\t * for the {@link org.mockito.plugins.MockMaker} in use.\n\t * @see #mockitoPresent\n\t * @see #isEnabled()\n\t */\n\t@Nullable\n\tprivate static volatile Boolean mockitoInitialized;\n\n\n\t/**\n\t * Returns {@value #ORDER}, which ensures that the\n\t * {@code MockitoResetTestExecutionListener} is ordered after all standard\n\t * {@code TestExecutionListener} implementations.\n\t * @see #ORDER\n\t */\n\t@Override\n\tpublic int getOrder() {\n\t\treturn ORDER;\n\t}\n\n\t@Override\n\tpublic void beforeTestMethod(TestContext testContext) {\n\t\tif (isEnabled()) {\n\t\t\tresetMocks(testContext.getApplicationContext(), MockReset.BEFORE);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void afterTestMethod(TestContext testContext) {\n\t\tif (isEnabled()) {\n\t\t\tresetMocks(testContext.getApplicationContext(), MockReset.AFTER);\n\t\t}\n\t}\n\n\n\tprivate static void resetMocks(ApplicationContext applicationContext, MockReset reset) {\n\t\tif (applicationContext instanceof ConfigurableApplicationContext configurableContext) {\n\t\t\tresetMocks(configurableContext, reset);\n\t\t}\n\t}\n\n\tprivate static void resetMocks(ConfigurableApplicationContext applicationContext, MockReset reset) {\n\t\tConfigurableListableBeanFactory beanFactory = applicationContext.getBeanFactory();\n\t\tString[] beanNames = beanFactory.getBeanDefinitionNames();\n\t\tSet<String> instantiatedSingletons = new HashSet<>(Arrays.asList(beanFactory.getSingletonNames()));\n\t\tfor (String beanName : beanNames) {\n\t\t\tBeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);\n\t\t\tif (beanDefinition.isSingleton() && instantiatedSingletons.contains(beanName)) {\n\t\t\t\tObject bean = getBean(beanFactory, beanName);\n\t\t\t\tif (bean != null && reset == MockReset.get(bean)) {\n\t\t\t\t\tMockito.reset(bean);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tbeanFactory.getBean(MockBeans.class).resetAll(reset);\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Continue\n\t\t}\n\t\tif (applicationContext.getParent() != null) {\n\t\t\tresetMocks(applicationContext.getParent(), reset);\n\t\t}\n\t}\n\n\t@Nullable\n\tprivate static Object getBean(ConfigurableListableBeanFactory beanFactory, String beanName) {\n\t\ttry {\n\t\t\tif (isStandardBeanOrSingletonFactoryBean(beanFactory, beanName)) {\n\t\t\t\treturn beanFactory.getBean(beanName);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\t// Continue\n\t\t}\n\t\treturn beanFactory.getSingleton(beanName);\n\t}\n\n\tprivate static boolean isStandardBeanOrSingletonFactoryBean(BeanFactory beanFactory, String beanName) {\n\t\tString factoryBeanName = BeanFactory.FACTORY_BEAN_PREFIX + beanName;\n\t\tif (beanFactory.containsBean(factoryBeanName)) {\n\t\t\tFactoryBean<?> factoryBean = (FactoryBean<?>) beanFactory.getBean(factoryBeanName);\n\t\t\treturn factoryBean.isSingleton();\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Determine if this listener is enabled in the current environment.\n\t * @see #mockitoPresent\n\t * @see #mockitoInitialized\n\t */\n\tprivate static boolean isEnabled() {\n\t\tif (!mockitoPresent) {\n\t\t\treturn false;\n\t\t}\n\t\tBoolean enabled = mockitoInitialized;\n\t\tif (enabled == null) {\n\t\t\ttry {\n\t\t\t\t// Invoke isMock() on a non-null object to initialize core Mockito classes\n\t\t\t\t// in order to reliably determine if this listener is \"enabled\" both on the\n\t\t\t\t// JVM as well as within a GraalVM native image.\n\t\t\t\tMockito.mockingDetails(\"a string is not a mock\").isMock();\n\n\t\t\t\t// If we got this far, we assume Mockito is usable in the current environment.\n\t\t\t\tenabled = true;\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tenabled = false;\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"\"\"\n\t\t\t\t\t\t\tMockitoResetTestExecutionListener is disabled in the current environment. \\\n\t\t\t\t\t\t\tSee exception for details.\"\"\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmockitoInitialized = enabled;\n\t\t}\n\t\treturn enabled;\n\t}\n\n}"
  },
  "org.springframework.test.context.bean.override.mockito.MockitoResetTestExecutionListener#afterTestMethod(testContext)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "void",
    "signature": "public void afterTestMethod(TestContext testContext)",
    "source_code": "\tpublic void afterTestMethod(TestContext testContext) {\n\t\tif (isEnabled()) {\n\t\t\tresetMocks(testContext.getApplicationContext(), MockReset.AFTER);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockitoResetTestExecutionListener#beforeTestMethod(testContext)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "void",
    "signature": "public void beforeTestMethod(TestContext testContext)",
    "source_code": "\tpublic void beforeTestMethod(TestContext testContext) {\n\t\tif (isEnabled()) {\n\t\t\tresetMocks(testContext.getApplicationContext(), MockReset.BEFORE);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockitoResetTestExecutionListener#getOrder()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns {@value #ORDER}, which ensures that the\n\t * {@code MockitoResetTestExecutionListener} is ordered after all standard\n\t * {@code TestExecutionListener} implementations.\n\t * @see #ORDER\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "int",
    "signature": "public int getOrder()",
    "source_code": "\tpublic int getOrder() {\n\t\treturn ORDER;\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.ORDER": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * The {@link #getOrder() order} value for this listener\n\t * ({@code Ordered.LOWEST_PRECEDENCE - 100}): {@value}.\n\t * @since 6.2.3\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "signature": "public int ORDER",
    "source_code": "\tpublic static final int ORDER = Ordered.LOWEST_PRECEDENCE - 100;",
    "type": "int"
  },
  "org.springframework.test.context.bean.override.mockito.SpringMockResolver": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * A {@link MockResolver} for testing Spring applications with Mockito.\n *\n * <p>Resolves mocks by walking the Spring AOP proxy chain until the target or a\n * non-static proxy is found.\n *\n * @author Sam Brannen\n * @author Andy Wilkinson\n * @author Juergen Hoeller\n * @since 6.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "signature": "public class SpringMockResolver",
    "source_code": "public class SpringMockResolver implements MockResolver {\n\n\tstatic final boolean springAopPresent = ClassUtils.isPresent(\n\t\t\t\"org.springframework.aop.framework.Advised\", SpringMockResolver.class.getClassLoader());\n\n\n\t@Override\n\tpublic Object resolve(Object instance) {\n\t\tif (springAopPresent) {\n\t\t\treturn getUltimateTargetObject(instance);\n\t\t}\n\t\treturn instance;\n\t}\n\n\t/**\n\t * This is a modified version of\n\t * {@link org.springframework.test.util.AopTestUtils#getUltimateTargetObject(Object)\n\t * AopTestUtils#getUltimateTargetObject()} which only checks static target sources.\n\t * @param candidate the instance to check (potentially a Spring AOP proxy;\n\t * never {@code null})\n\t * @return the target object or the {@code candidate} (never {@code null})\n\t * @throws IllegalStateException if an error occurs while unwrapping a proxy\n\t * @see Advised#getTargetSource()\n\t * @see TargetSource#isStatic()\n\t */\n\tstatic Object getUltimateTargetObject(Object candidate) {\n\t\tAssert.notNull(candidate, \"Candidate must not be null\");\n\t\ttry {\n\t\t\tif (AopUtils.isAopProxy(candidate) && candidate instanceof Advised advised) {\n\t\t\t\tTargetSource targetSource = advised.getTargetSource();\n\t\t\t\tif (targetSource.isStatic()) {\n\t\t\t\t\tObject target = targetSource.getTarget();\n\t\t\t\t\tif (target != null) {\n\t\t\t\t\t\treturn getUltimateTargetObject(target);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new IllegalStateException(\"Failed to unwrap proxied object\", ex);\n\t\t}\n\t\treturn candidate;\n\t}\n\n}"
  },
  "org.springframework.test.context.bean.override.mockito.SpringMockResolver#resolve(instance)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "instance"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "return": "Object",
    "signature": "public Object resolve(Object instance)",
    "source_code": "\tpublic Object resolve(Object instance) {\n\t\tif (springAopPresent) {\n\t\t\treturn getUltimateTargetObject(instance);\n\t\t}\n\t\treturn instance;\n\t}"
  },
  "org.springframework.test.context.jdbc.ORDER": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * The {@link #getOrder() order} value for this listener: {@value}.\n\t * @since 6.2.3\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "signature": "public int ORDER",
    "source_code": "\tpublic static final int ORDER = 5000;",
    "type": "int"
  },
  "org.springframework.test.context.observation.ORDER": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * The {@link #getOrder() order} value for this listener: {@value}.\n\t * @since 6.2.3\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "public int ORDER",
    "source_code": "\tpublic static final int ORDER = 2500;",
    "type": "int"
  },
  "org.springframework.test.context.support.<unknown>#getProperty(name)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "Object",
    "signature": "public Object getProperty(String name)",
    "source_code": "\tpublic Object getProperty(String name) {\n\t\treturn SupplierUtils.resolve(super.getProperty(name));\n\t}"
  },
  "org.springframework.test.context.support.AbstractDelegatingSmartContextLoader#loadContextForAotProcessing(mergedConfig,runtimeHints)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to an appropriate candidate {@code SmartContextLoader} to load\n\t * an {@link ApplicationContext} for AOT processing.\n\t * <p>Delegation is based on explicit knowledge of the implementations of the\n\t * default loaders. See {@link #loadContext(MergedContextConfiguration)} for\n\t * details.\n\t * @param mergedConfig the merged context configuration to use to load the application context\n\t * @param runtimeHints the runtime hints\n\t * @return a new application context\n\t * @throws IllegalArgumentException if the supplied merged configuration is {@code null}\n\t * @throws IllegalStateException if neither candidate loader is capable of loading an\n\t * {@code ApplicationContext} from the supplied merged context configuration\n\t * @since 6.2.4\n\t * @see AotContextLoader#loadContextForAotProcessing(MergedContextConfiguration, RuntimeHints)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedConfig",
      "runtimeHints"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "ApplicationContext",
    "signature": "public ApplicationContext loadContextForAotProcessing(MergedContextConfiguration mergedConfig,\n\t\t\tRuntimeHints runtimeHints)",
    "source_code": "\tpublic final ApplicationContext loadContextForAotProcessing(MergedContextConfiguration mergedConfig,"
  },
  "org.springframework.test.context.support.CommonCachesTestExecutionListener": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * {@code TestExecutionListener} which makes sure that common caches are cleared\n * once they are no longer required.\n *\n * <p>Clears the resource caches of the {@link ApplicationContext} since they are\n * only required during the bean initialization phase. Runs after\n * {@link DirtiesContextTestExecutionListener} since dirtying the context will\n * close it and remove it from the context cache, making it unnecessary to clear\n * the associated resource caches.\n *\n * @author Stephane Nicoll\n * @since 6.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 36
    },
    "signature": "public class CommonCachesTestExecutionListener",
    "source_code": "public class CommonCachesTestExecutionListener extends AbstractTestExecutionListener {\n\n\t/**\n\t * The {@link #getOrder() order} value for this listener: {@value}.\n\t * @since 6.2.3\n\t */\n\tpublic static final int ORDER = 3005;\n\n\n\t/**\n\t * Returns {@value #ORDER}, which ensures that the {@code CommonCachesTestExecutionListener}\n\t * is ordered after the\n\t * {@link DirtiesContextTestExecutionListener DirtiesContextTestExecutionListener} and before the\n\t * {@link org.springframework.test.context.transaction.TransactionalTestExecutionListener\n\t * TransactionalTestExecutionListener}.\n\t */\n\t@Override\n\tpublic final int getOrder() {\n\t\treturn ORDER;\n\t}\n\n\t@Override\n\tpublic void afterTestClass(TestContext testContext) throws Exception {\n\t\tif (testContext.hasApplicationContext()) {\n\t\t\tApplicationContext applicationContext = testContext.getApplicationContext();\n\t\t\tif (applicationContext instanceof AbstractApplicationContext ctx) {\n\t\t\t\tctx.clearResourceCaches();\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.test.context.support.CommonCachesTestExecutionListener#afterTestClass(testContext)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "void",
    "signature": "public void afterTestClass(TestContext testContext)",
    "source_code": "\tpublic void afterTestClass(TestContext testContext) throws Exception {\n\t\tif (testContext.hasApplicationContext()) {\n\t\t\tApplicationContext applicationContext = testContext.getApplicationContext();\n\t\t\tif (applicationContext instanceof AbstractApplicationContext ctx) {\n\t\t\t\tctx.clearResourceCaches();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.test.context.support.CommonCachesTestExecutionListener#getOrder()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns {@value #ORDER}, which ensures that the {@code CommonCachesTestExecutionListener}\n\t * is ordered after the\n\t * {@link DirtiesContextTestExecutionListener DirtiesContextTestExecutionListener} and before the\n\t * {@link org.springframework.test.context.transaction.TransactionalTestExecutionListener\n\t * TransactionalTestExecutionListener}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 53
    },
    "return": "int",
    "signature": "public int getOrder()",
    "source_code": "\tpublic final int getOrder() {\n\t\treturn ORDER;\n\t}"
  },
  "org.springframework.test.context.support.DynamicPropertyRegistrarBeanInitializer": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * {@link BeanFactoryInitializer} that eagerly initializes {@link DynamicPropertyRegistrar}\n * beans.\n *\n * <p>Primarily intended for internal use within the Spring TestContext Framework.\n *\n * @author Sam Brannen\n * @since 6.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "signature": "public class DynamicPropertyRegistrarBeanInitializer",
    "source_code": "public class DynamicPropertyRegistrarBeanInitializer implements BeanFactoryInitializer<ListableBeanFactory>, EnvironmentAware {\n\n\tprivate static final Log logger = LogFactory.getLog(DynamicPropertyRegistrarBeanInitializer.class);\n\n\t/**\n\t * The bean name of the internally managed {@code DynamicPropertyRegistrarBeanInitializer}.\n\t */\n\tstatic final String BEAN_NAME =\n\t\t\t\"org.springframework.test.context.support.internalDynamicPropertyRegistrarBeanInitializer\";\n\n\n\t@Nullable\n\tprivate ConfigurableEnvironment environment;\n\n\n\t@Override\n\tpublic void setEnvironment(Environment environment) {\n\t\tif (!(environment instanceof ConfigurableEnvironment configurableEnvironment)) {\n\t\t\tthrow new IllegalArgumentException(\"Environment must be a ConfigurableEnvironment\");\n\t\t}\n\t\tthis.environment = configurableEnvironment;\n\t}\n\n\t@Override\n\tpublic void initialize(ListableBeanFactory beanFactory) {\n\t\tif (this.environment == null) {\n\t\t\tthrow new IllegalStateException(\"Environment is required\");\n\t\t}\n\t\tString[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(\n\t\t\t\tbeanFactory, DynamicPropertyRegistrar.class);\n\t\tif (beanNames.length > 0) {\n\t\t\tDynamicValuesPropertySource propertySource = DynamicValuesPropertySource.getOrCreate(this.environment);\n\t\t\tDynamicPropertyRegistry registry = propertySource.dynamicPropertyRegistry;\n\t\t\tfor (String name : beanNames) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Eagerly initializing DynamicPropertyRegistrar bean '%s'\".formatted(name));\n\t\t\t\t}\n\t\t\t\tDynamicPropertyRegistrar registrar = beanFactory.getBean(name, DynamicPropertyRegistrar.class);\n\t\t\t\tregistrar.accept(registry);\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.test.context.support.DynamicPropertyRegistrarBeanInitializer#initialize(beanFactory)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "void",
    "signature": "public void initialize(ListableBeanFactory beanFactory)",
    "source_code": "\tpublic void initialize(ListableBeanFactory beanFactory) {\n\t\tif (this.environment == null) {\n\t\t\tthrow new IllegalStateException(\"Environment is required\");\n\t\t}\n\t\tString[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(\n\t\t\t\tbeanFactory, DynamicPropertyRegistrar.class);\n\t\tif (beanNames.length > 0) {\n\t\t\tDynamicValuesPropertySource propertySource = DynamicValuesPropertySource.getOrCreate(this.environment);\n\t\t\tDynamicPropertyRegistry registry = propertySource.dynamicPropertyRegistry;\n\t\t\tfor (String name : beanNames) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Eagerly initializing DynamicPropertyRegistrar bean '%s'\".formatted(name));\n\t\t\t\t}\n\t\t\t\tDynamicPropertyRegistrar registrar = beanFactory.getBean(name, DynamicPropertyRegistrar.class);\n\t\t\t\tregistrar.accept(registry);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.test.context.support.DynamicPropertyRegistrarBeanInitializer#setEnvironment(environment)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "environment"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "void",
    "signature": "public void setEnvironment(Environment environment)",
    "source_code": "\tpublic void setEnvironment(Environment environment) {\n\t\tif (!(environment instanceof ConfigurableEnvironment configurableEnvironment)) {\n\t\t\tthrow new IllegalArgumentException(\"Environment must be a ConfigurableEnvironment\");\n\t\t}\n\t\tthis.environment = configurableEnvironment;\n\t}"
  },
  "org.springframework.test.context.support.ORDER": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * The {@link #getOrder() order} value for this listener: {@value}.\n\t * @since 6.2.3\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public int ORDER",
    "source_code": "\tpublic static final int ORDER = 3005;",
    "type": "int"
  },
  "org.springframework.test.context.util.TestContextResourceUtils#convertToResourceList(resourceLoader,environment,paths)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the supplied paths to a list of {@link Resource} handles using the given\n\t * {@link ResourceLoader} and {@link Environment}.\n\t * @param resourceLoader the {@code ResourceLoader} to use to convert the paths\n\t * @param environment the {@code Environment} to use to resolve property placeholders\n\t * in the paths\n\t * @param paths the paths to be converted\n\t * @return a new, mutable list of resources\n\t * @since 6.2\n\t * @see #convertToResources(ResourceLoader, String...)\n\t * @see #convertToClasspathResourcePaths\n\t * @see Environment#resolveRequiredPlaceholders(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resourceLoader",
      "environment",
      "paths"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "List<Resource>",
    "signature": "public List<Resource> convertToResourceList(ResourceLoader resourceLoader, Environment environment, String... paths)",
    "source_code": "\tpublic static List<Resource> convertToResourceList("
  },
  "org.springframework.test.context.web.AbstractGenericWebContextLoader#loadContextForAotProcessing(mergedConfig,runtimeHints)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Load a {@link GenericWebApplicationContext} for AOT build-time processing based\n\t * on the supplied {@link MergedContextConfiguration}.\n\t * <p>In contrast to {@link #loadContext(MergedContextConfiguration)}, this\n\t * method does not\n\t * {@linkplain org.springframework.context.ConfigurableApplicationContext#refresh()\n\t * refresh} the {@code ApplicationContext} or\n\t * {@linkplain org.springframework.context.ConfigurableApplicationContext#registerShutdownHook()\n\t * register a JVM shutdown hook} for it. Otherwise, this method implements\n\t * behavior identical to {@link #loadContext(MergedContextConfiguration)}.\n\t * @param mergedConfig the merged context configuration to use to load the\n\t * application context\n\t * @param runtimeHints the runtime hints\n\t * @return a new web application context\n\t * @throws Exception if context loading failed\n\t * @since 6.2.4\n\t * @see AotContextLoader#loadContextForAotProcessing(MergedContextConfiguration, RuntimeHints)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedConfig",
      "runtimeHints"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "GenericWebApplicationContext",
    "signature": "public GenericWebApplicationContext loadContextForAotProcessing(MergedContextConfiguration mergedConfig,\n\t\t\tRuntimeHints runtimeHints)",
    "source_code": "\tpublic final GenericWebApplicationContext loadContextForAotProcessing(MergedContextConfiguration mergedConfig,"
  },
  "org.springframework.test.context.web.ORDER": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * The {@link #getOrder() order} value for this listener: {@value}.\n\t * @since 6.2.3\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "signature": "public int ORDER",
    "source_code": "\tpublic static final int ORDER = 1000;",
    "type": "int"
  },
  "org.springframework.test.context.web.WebMergedContextConfiguration": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * {@code WebMergedContextConfiguration} encapsulates the <em>merged</em> context\n * configuration declared on a test class and all of its superclasses and\n * enclosing classes via\n * {@link org.springframework.test.context.ContextConfiguration @ContextConfiguration},\n * {@link WebAppConfiguration @WebAppConfiguration},\n * {@link org.springframework.test.context.ActiveProfiles @ActiveProfiles}, and\n * {@link org.springframework.test.context.TestPropertySource @TestPropertySource}.\n *\n * <p>{@code WebMergedContextConfiguration} extends the contract of\n * {@link MergedContextConfiguration} by adding support for the {@linkplain\n * #getResourceBasePath() resource base path} configured via {@code @WebAppConfiguration}.\n * This allows the {@link org.springframework.test.context.cache.ContextCache ContextCache}\n * to properly cache the corresponding {@link\n * org.springframework.web.context.WebApplicationContext WebApplicationContext}\n * that was loaded using properties of this {@code WebMergedContextConfiguration}.\n *\n * @author Sam Brannen\n * @since 3.2\n * @see WebAppConfiguration\n * @see MergedContextConfiguration\n * @see org.springframework.test.context.ContextConfiguration\n * @see org.springframework.test.context.ActiveProfiles\n * @see org.springframework.test.context.ContextConfigurationAttributes\n * @see org.springframework.test.context.SmartContextLoader#loadContext(MergedContextConfiguration)\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "signature": "public class WebMergedContextConfiguration",
    "source_code": "public class WebMergedContextConfiguration extends MergedContextConfiguration {\n\n\tprivate static final long serialVersionUID = 7323361588604247458L;\n\n\tprivate final String resourceBasePath;\n\n\n\t/**\n\t * Create a new {@code WebMergedContextConfiguration} instance by copying\n\t * all properties from the supplied {@code MergedContextConfiguration}.\n\t * <p>If an <em>empty</em> value is supplied for the {@code resourceBasePath}\n\t * an empty string will be used.\n\t * @param resourceBasePath the resource path to the root directory of the web application\n\t * @since 4.1\n\t */\n\tpublic WebMergedContextConfiguration(MergedContextConfiguration mergedConfig, String resourceBasePath) {\n\t\tsuper(mergedConfig);\n\t\tthis.resourceBasePath = (StringUtils.hasText(resourceBasePath) ? resourceBasePath : \"\");\n\t}\n\n\t/**\n\t * Create a new {@code WebMergedContextConfiguration} instance for the\n\t * supplied parameters.\n\t * <p>If a {@code null} value is supplied for {@code locations},\n\t * {@code classes}, {@code activeProfiles}, {@code propertySourceLocations},\n\t * or {@code propertySourceProperties} an empty array will be stored instead.\n\t * If a {@code null} value is supplied for the\n\t * {@code contextInitializerClasses} an empty set will be stored instead.\n\t * If an <em>empty</em> value is supplied for the {@code resourceBasePath}\n\t * an empty string will be used. Furthermore, active profiles will be sorted,\n\t * and duplicate profiles will be removed.\n\t * @param testClass the test class for which the configuration was merged\n\t * @param locations the merged resource locations\n\t * @param classes the merged annotated classes\n\t * @param contextInitializerClasses the merged context initializer classes\n\t * @param activeProfiles the merged active bean definition profiles\n\t * @param propertySourceLocations the merged {@code PropertySource} locations\n\t * @param propertySourceProperties the merged {@code PropertySource} properties\n\t * @param resourceBasePath the resource path to the root directory of the web application\n\t * @param contextLoader the resolved {@code ContextLoader}\n\t * @param cacheAwareContextLoaderDelegate a cache-aware context loader\n\t * delegate with which to retrieve the parent context\n\t * @param parent the parent configuration or {@code null} if there is no parent\n\t * @since 4.1\n\t * @deprecated since 6.1 in favor of\n\t * {@link #WebMergedContextConfiguration(Class, String[], Class[], Set, String[], List, String[], Set, String, ContextLoader, CacheAwareContextLoaderDelegate, MergedContextConfiguration)}\n\t */\n\t@Deprecated(since = \"6.1\")\n\tpublic WebMergedContextConfiguration(Class<?> testClass, @Nullable String[] locations, @Nullable Class<?>[] classes,\n\t\t\t@Nullable Set<Class<? extends ApplicationContextInitializer<?>>> contextInitializerClasses,\n\t\t\t@Nullable String[] activeProfiles, @Nullable String[] propertySourceLocations, @Nullable String[] propertySourceProperties,\n\t\t\tString resourceBasePath, ContextLoader contextLoader,\n\t\t\tCacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate, @Nullable MergedContextConfiguration parent) {\n\n\t\tthis(testClass, locations, classes, contextInitializerClasses, activeProfiles, propertySourceLocations,\n\t\t\tpropertySourceProperties, null, resourceBasePath, contextLoader, cacheAwareContextLoaderDelegate, parent);\n\t}\n\n\t/**\n\t * Create a new {@code WebMergedContextConfiguration} instance for the\n\t * supplied parameters.\n\t * <p>If a {@code null} value is supplied for {@code locations},\n\t * {@code classes}, {@code activeProfiles}, {@code propertySourceLocations},\n\t * or {@code propertySourceProperties} an empty array will be stored instead.\n\t * If a {@code null} value is supplied for {@code contextInitializerClasses}\n\t * or {@code contextCustomizers}, an empty set will be stored instead.\n\t * If an <em>empty</em> value is supplied for the {@code resourceBasePath}\n\t * an empty string will be used. Furthermore, active profiles will be sorted,\n\t * and duplicate profiles will be removed.\n\t * @param testClass the test class for which the configuration was merged\n\t * @param locations the merged context resource locations\n\t * @param classes the merged annotated classes\n\t * @param contextInitializerClasses the merged context initializer classes\n\t * @param activeProfiles the merged active bean definition profiles\n\t * @param propertySourceLocations the merged {@code PropertySource} locations\n\t * @param propertySourceProperties the merged {@code PropertySource} properties\n\t * @param contextCustomizers the context customizers\n\t * @param resourceBasePath the resource path to the root directory of the web application\n\t * @param contextLoader the resolved {@code ContextLoader}\n\t * @param cacheAwareContextLoaderDelegate a cache-aware context loader\n\t * delegate with which to retrieve the parent context\n\t * @param parent the parent configuration or {@code null} if there is no parent\n\t * @since 4.3\n\t * @deprecated since 6.1 in favor of\n\t * {@link #WebMergedContextConfiguration(Class, String[], Class[], Set, String[], List, String[], Set, String, ContextLoader, CacheAwareContextLoaderDelegate, MergedContextConfiguration)}\n\t */\n\t@Deprecated(since = \"6.1\")\n\tpublic WebMergedContextConfiguration(Class<?> testClass, @Nullable String[] locations, @Nullable Class<?>[] classes,\n\t\t\t@Nullable Set<Class<? extends ApplicationContextInitializer<?>>> contextInitializerClasses,\n\t\t\t@Nullable String[] activeProfiles, @Nullable String[] propertySourceLocations, @Nullable String[] propertySourceProperties,\n\t\t\t@Nullable Set<ContextCustomizer> contextCustomizers, String resourceBasePath, ContextLoader contextLoader,\n\t\t\tCacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate, @Nullable MergedContextConfiguration parent) {\n\n\t\tthis(testClass, locations, classes, contextInitializerClasses, activeProfiles,\n\t\t\tList.of(new PropertySourceDescriptor(processStrings(propertySourceLocations))),\n\t\t\tpropertySourceProperties, contextCustomizers, resourceBasePath, contextLoader,\n\t\t\tcacheAwareContextLoaderDelegate, parent);\n\t}\n\n\t/**\n\t * Create a new {@code WebMergedContextConfiguration} instance for the supplied\n\t * parameters.\n\t * <p>If a {@code null} value is supplied for {@code locations}, {@code classes},\n\t * {@code activeProfiles}, or {@code propertySourceProperties} an empty array\n\t * will be stored instead. If a {@code null} value is supplied for\n\t * {@code contextInitializerClasses} or {@code contextCustomizers}, an empty\n\t * set will be stored instead. Furthermore, active profiles will be sorted,\n\t * and duplicate profiles will be removed.\n\t * @param testClass the test class for which the configuration was merged\n\t * @param locations the merged context resource locations\n\t * @param classes the merged annotated classes\n\t * @param contextInitializerClasses the merged context initializer classes\n\t * @param activeProfiles the merged active bean definition profiles\n\t * @param propertySourceDescriptors the merged property source descriptors\n\t * @param propertySourceProperties the merged inlined properties\n\t * @param contextCustomizers the context customizers\n\t * @param resourceBasePath the resource path to the root directory of the web application\n\t * @param contextLoader the resolved {@code ContextLoader}\n\t * @param cacheAwareContextLoaderDelegate a cache-aware context loader\n\t * delegate with which to retrieve the parent {@code ApplicationContext}\n\t * @param parent the parent configuration or {@code null} if there is no parent\n\t * @since 6.1\n\t */\n\tpublic WebMergedContextConfiguration(Class<?> testClass, @Nullable String[] locations, @Nullable Class<?>[] classes,\n\t\t\t@Nullable Set<Class<? extends ApplicationContextInitializer<?>>> contextInitializerClasses,\n\t\t\t@Nullable String[] activeProfiles,\n\t\t\tList<PropertySourceDescriptor> propertySourceDescriptors, @Nullable String[] propertySourceProperties,\n\t\t\t@Nullable Set<ContextCustomizer> contextCustomizers, String resourceBasePath, ContextLoader contextLoader,\n\t\t\tCacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate, @Nullable MergedContextConfiguration parent) {\n\n\t\tsuper(testClass, locations, classes, contextInitializerClasses, activeProfiles, propertySourceDescriptors,\n\t\t\tpropertySourceProperties, contextCustomizers, contextLoader, cacheAwareContextLoaderDelegate, parent);\n\n\t\tthis.resourceBasePath = (StringUtils.hasText(resourceBasePath) ? resourceBasePath : \"\");\n\t}\n\n\t/**\n\t * Get the resource path to the root directory of the web application for the\n\t * {@linkplain #getTestClass() test class}, configured via {@code @WebAppConfiguration}.\n\t * @see WebAppConfiguration\n\t */\n\tpublic String getResourceBasePath() {\n\t\treturn this.resourceBasePath;\n\t}\n\n\n\t/**\n\t * Determine if the supplied object is equal to this {@code WebMergedContextConfiguration}\n\t * instance by comparing both objects' {@linkplain #getLocations() locations},\n\t * {@linkplain #getClasses() annotated classes},\n\t * {@linkplain #getContextInitializerClasses() context initializer classes},\n\t * {@linkplain #getActiveProfiles() active profiles},\n\t * {@linkplain #getResourceBasePath() resource base paths},\n\t * {@linkplain #getPropertySourceDescriptors() property source descriptors},\n\t * {@linkplain #getPropertySourceProperties() property source properties},\n\t * {@linkplain #getContextCustomizers() context customizers},\n\t * {@linkplain #getParent() parents}, and the fully qualified names of their\n\t * {@link #getContextLoader() ContextLoaders}.\n\t */\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (super.equals(other) && other instanceof WebMergedContextConfiguration otherConfiguration &&\n\t\t\t\tthis.resourceBasePath.equals(otherConfiguration.resourceBasePath)));\n\t}\n\n\t/**\n\t * Generate a unique hash code for all properties of this\n\t * {@code WebMergedContextConfiguration} excluding the\n\t * {@linkplain #getTestClass() test class}.\n\t */\n\t@Override\n\tpublic int hashCode() {\n\t\treturn (31 * super.hashCode() + this.resourceBasePath.hashCode());\n\t}\n\n\t/**\n\t * Provide a String representation of the {@linkplain #getTestClass() test class},\n\t * {@linkplain #getLocations() locations}, {@linkplain #getClasses() annotated classes},\n\t * {@linkplain #getContextInitializerClasses() context initializer classes},\n\t * {@linkplain #getActiveProfiles() active profiles},\n\t * {@linkplain #getPropertySourceDescriptors() property source descriptors},\n\t * {@linkplain #getPropertySourceProperties() property source properties},\n\t * {@linkplain #getContextCustomizers() context customizers},\n\t * {@linkplain #getResourceBasePath() resource base path}, the name of the\n\t * {@link #getContextLoader() ContextLoader}, and the\n\t * {@linkplain #getParent() parent configuration}.\n\t */\n\t@Override\n\tpublic String toString() {\n\t\treturn new ToStringCreator(this, new DefaultToStringStyler(new SimpleValueStyler()))\n\t\t\t\t.append(\"testClass\", getTestClass())\n\t\t\t\t.append(\"locations\", getLocations())\n\t\t\t\t.append(\"classes\", getClasses())\n\t\t\t\t.append(\"contextInitializerClasses\", getContextInitializerClasses())\n\t\t\t\t.append(\"activeProfiles\", getActiveProfiles())\n\t\t\t\t.append(\"propertySourceDescriptors\", getPropertySourceDescriptors())\n\t\t\t\t.append(\"propertySourceProperties\", getPropertySourceProperties())\n\t\t\t\t.append(\"contextCustomizers\", getContextCustomizers())\n\t\t\t\t.append(\"resourceBasePath\", getResourceBasePath())\n\t\t\t\t.append(\"contextLoader\", (getContextLoader() != null ? getContextLoader().getClass() : null))\n\t\t\t\t.append(\"parent\", getParent())\n\t\t\t\t.toString();\n\t}\n\n}"
  },
  "org.springframework.test.context.web.WebMergedContextConfiguration#equals(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied object is equal to this {@code WebMergedContextConfiguration}\n\t * instance by comparing both objects' {@linkplain #getLocations() locations},\n\t * {@linkplain #getClasses() annotated classes},\n\t * {@linkplain #getContextInitializerClasses() context initializer classes},\n\t * {@linkplain #getActiveProfiles() active profiles},\n\t * {@linkplain #getResourceBasePath() resource base paths},\n\t * {@linkplain #getPropertySourceDescriptors() property source descriptors},\n\t * {@linkplain #getPropertySourceProperties() property source properties},\n\t * {@linkplain #getContextCustomizers() context customizers},\n\t * {@linkplain #getParent() parents}, and the fully qualified names of their\n\t * {@link #getContextLoader() ContextLoaders}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (super.equals(other) && other instanceof WebMergedContextConfiguration otherConfiguration &&\n\t\t\t\tthis.resourceBasePath.equals(otherConfiguration.resourceBasePath)));\n\t}"
  },
  "org.springframework.test.context.web.WebMergedContextConfiguration#getResourceBasePath()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the resource path to the root directory of the web application for the\n\t * {@linkplain #getTestClass() test class}, configured via {@code @WebAppConfiguration}.\n\t * @see WebAppConfiguration\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "String",
    "signature": "public String getResourceBasePath()",
    "source_code": "\tpublic String getResourceBasePath() {\n\t\treturn this.resourceBasePath;\n\t}"
  },
  "org.springframework.test.context.web.WebMergedContextConfiguration#hashCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate a unique hash code for all properties of this\n\t * {@code WebMergedContextConfiguration} excluding the\n\t * {@linkplain #getTestClass() test class}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 231
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn (31 * super.hashCode() + this.resourceBasePath.hashCode());\n\t}"
  },
  "org.springframework.test.context.web.WebMergedContextConfiguration#toString()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide a String representation of the {@linkplain #getTestClass() test class},\n\t * {@linkplain #getLocations() locations}, {@linkplain #getClasses() annotated classes},\n\t * {@linkplain #getContextInitializerClasses() context initializer classes},\n\t * {@linkplain #getActiveProfiles() active profiles},\n\t * {@linkplain #getPropertySourceDescriptors() property source descriptors},\n\t * {@linkplain #getPropertySourceProperties() property source properties},\n\t * {@linkplain #getContextCustomizers() context customizers},\n\t * {@linkplain #getResourceBasePath() resource base path}, the name of the\n\t * {@link #getContextLoader() ContextLoader}, and the\n\t * {@linkplain #getParent() parent configuration}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn new ToStringCreator(this, new DefaultToStringStyler(new SimpleValueStyler()))\n\t\t\t\t.append(\"testClass\", getTestClass())\n\t\t\t\t.append(\"locations\", getLocations())\n\t\t\t\t.append(\"classes\", getClasses())\n\t\t\t\t.append(\"contextInitializerClasses\", getContextInitializerClasses())\n\t\t\t\t.append(\"activeProfiles\", getActiveProfiles())\n\t\t\t\t.append(\"propertySourceDescriptors\", getPropertySourceDescriptors())\n\t\t\t\t.append(\"propertySourceProperties\", getPropertySourceProperties())\n\t\t\t\t.append(\"contextCustomizers\", getContextCustomizers())\n\t\t\t\t.append(\"resourceBasePath\", getResourceBasePath())\n\t\t\t\t.append(\"contextLoader\", (getContextLoader() != null ? getContextLoader().getClass() : null))\n\t\t\t\t.append(\"parent\", getParent())\n\t\t\t\t.toString();\n\t}"
  },
  "org.springframework.test.http.HttpMessageContentConverter": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Convert HTTP message content for testing purposes.\n *\n * @author Stephane Nicoll\n * @since 6.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "signature": "public class HttpMessageContentConverter",
    "source_code": "public class HttpMessageContentConverter {\n\n\tprivate static final MediaType JSON = MediaType.APPLICATION_JSON;\n\n\tprivate final List<HttpMessageConverter<?>> messageConverters;\n\n\tHttpMessageContentConverter(Iterable<HttpMessageConverter<?>> messageConverters) {\n\t\tthis.messageConverters = StreamSupport.stream(messageConverters.spliterator(), false).toList();\n\t\tAssert.notEmpty(this.messageConverters, \"At least one message converter needs to be specified\");\n\t}\n\n\n\t/**\n\t * Create an instance with an iterable of the candidates to use.\n\t * @param candidates the candidates\n\t */\n\tpublic static HttpMessageContentConverter of(Iterable<HttpMessageConverter<?>> candidates) {\n\t\treturn new HttpMessageContentConverter(candidates);\n\t}\n\n\t/**\n\t * Create an instance with a vararg of the candidates to use.\n\t * @param candidates the candidates\n\t */\n\tpublic static HttpMessageContentConverter of(HttpMessageConverter<?>... candidates) {\n\t\treturn new HttpMessageContentConverter(Arrays.asList(candidates));\n\t}\n\n\n\t/**\n\t * Convert the given {@link HttpInputMessage} whose content must match the\n\t * given {@link MediaType} to the requested {@code targetType}.\n\t * @param message an input message\n\t * @param mediaType the media type of the input\n\t * @param targetType the target type\n\t * @param <T> the converted object type\n\t * @return a value of the given {@code targetType}\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> T convert(HttpInputMessage message, MediaType mediaType, ResolvableType targetType)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\t\tClass<?> contextClass = targetType.getRawClass();\n\t\tSingletonSupplier<Type> javaType = SingletonSupplier.of(targetType::getType);\n\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n\t\t\tif (messageConverter instanceof GenericHttpMessageConverter<?> genericMessageConverter) {\n\t\t\t\tType type = javaType.obtain();\n\t\t\t\tif (genericMessageConverter.canRead(type, contextClass, mediaType)) {\n\t\t\t\t\treturn (T) genericMessageConverter.read(type, contextClass, message);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (messageConverter instanceof SmartHttpMessageConverter<?> smartMessageConverter) {\n\t\t\t\tif (smartMessageConverter.canRead(targetType, mediaType)) {\n\t\t\t\t\treturn (T) smartMessageConverter.read(targetType, message, null);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tClass<?> targetClass = (contextClass != null ? contextClass : Object.class);\n\t\t\t\tif (messageConverter.canRead(targetClass, mediaType)) {\n\t\t\t\t\tHttpMessageConverter<T> simpleMessageConverter = (HttpMessageConverter<T>) messageConverter;\n\t\t\t\t\tClass<? extends T> clazz = (Class<? extends T>) targetClass;\n\t\t\t\t\treturn simpleMessageConverter.read(clazz, message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new IllegalStateException(\"No converter found to read [%s] to [%s]\".formatted(mediaType, targetType));\n\t}\n\n\t/**\n\t * Convert the given raw value to the given {@code targetType} by writing\n\t * it first to JSON and reading it back.\n\t * @param value the value to convert\n\t * @param targetType the target type\n\t * @param <T> the converted object type\n\t * @return a value of the given {@code targetType}\n\t */\n\tpublic <T> T convertViaJson(Object value, ResolvableType targetType) throws IOException {\n\t\tMockHttpOutputMessage outputMessage = convertToJson(value, ResolvableType.forInstance(value));\n\t\treturn convert(fromHttpOutputMessage(outputMessage), JSON, targetType);\n\t}\n\n\t@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n\tprivate MockHttpOutputMessage convertToJson(Object value, ResolvableType valueType) throws IOException {\n\t\tMockHttpOutputMessage outputMessage = new MockHttpOutputMessage();\n\t\tClass<?> valueClass = value.getClass();\n\t\tSingletonSupplier<Type> javaType = SingletonSupplier.of(valueType::getType);\n\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n\t\t\tif (messageConverter instanceof GenericHttpMessageConverter genericMessageConverter) {\n\t\t\t\tType type = javaType.obtain();\n\t\t\t\tif (genericMessageConverter.canWrite(type, valueClass, JSON)) {\n\t\t\t\t\tgenericMessageConverter.write(value, type, JSON, outputMessage);\n\t\t\t\t\treturn outputMessage;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (messageConverter instanceof SmartHttpMessageConverter smartMessageConverter) {\n\t\t\t\tif (smartMessageConverter.canWrite(valueType, valueClass, JSON)) {\n\t\t\t\t\tsmartMessageConverter.write(value, valueType, JSON, outputMessage, null);\n\t\t\t\t\treturn outputMessage;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (messageConverter.canWrite(valueClass, JSON)) {\n\t\t\t\t((HttpMessageConverter<Object>) messageConverter).write(value, JSON, outputMessage);\n\t\t\t\treturn outputMessage;\n\t\t\t}\n\t\t}\n\t\tthrow new IllegalStateException(\"No converter found to convert [%s] to JSON\".formatted(valueType));\n\t}\n\n\tprivate static HttpInputMessage fromHttpOutputMessage(MockHttpOutputMessage message) {\n\t\tMockHttpInputMessage inputMessage = new MockHttpInputMessage(message.getBodyAsBytes());\n\t\tinputMessage.getHeaders().addAll(message.getHeaders());\n\t\treturn inputMessage;\n\t}\n\n}"
  },
  "org.springframework.test.http.HttpMessageContentConverter#convert(message,mediaType,targetType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given {@link HttpInputMessage} whose content must match the\n\t * given {@link MediaType} to the requested {@code targetType}.\n\t * @param message an input message\n\t * @param mediaType the media type of the input\n\t * @param targetType the target type\n\t * @param <T> the converted object type\n\t * @return a value of the given {@code targetType}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "mediaType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "T",
    "signature": "public T convert(HttpInputMessage message, MediaType mediaType, ResolvableType targetType)",
    "source_code": "\tpublic <T> T convert(HttpInputMessage message, MediaType mediaType, ResolvableType targetType)"
  },
  "org.springframework.test.http.HttpMessageContentConverter#convertViaJson(value,targetType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given raw value to the given {@code targetType} by writing\n\t * it first to JSON and reading it back.\n\t * @param value the value to convert\n\t * @param targetType the target type\n\t * @param <T> the converted object type\n\t * @return a value of the given {@code targetType}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "T",
    "signature": "public T convertViaJson(Object value, ResolvableType targetType)",
    "source_code": "\tpublic <T> T convertViaJson(Object value, ResolvableType targetType) throws IOException {\n\t\tMockHttpOutputMessage outputMessage = convertToJson(value, ResolvableType.forInstance(value));\n\t\treturn convert(fromHttpOutputMessage(outputMessage), JSON, targetType);\n\t}"
  },
  "org.springframework.test.http.HttpMessageContentConverter#of(candidates)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an instance with a vararg of the candidates to use.\n\t * @param candidates the candidates\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "candidates"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "HttpMessageContentConverter",
    "signature": "public HttpMessageContentConverter of(HttpMessageConverter<?>... candidates)",
    "source_code": "\tpublic static HttpMessageContentConverter of(HttpMessageConverter<?>... candidates) {\n\t\treturn new HttpMessageContentConverter(Arrays.asList(candidates));\n\t}"
  },
  "org.springframework.test.util.JsonPathExpectationsHelper#evaluateJsonPath(content,targetType)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #evaluateJsonPath(String)} with a target type.\n\t * <p>This can be useful for matching numbers reliably for example coercing an\n\t * integer into a double.\n\t * @param content the content to evaluate against\n\t * @return the result of the evaluation\n\t * @throws AssertionError if the evaluation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 314
    },
    "return": "Object",
    "signature": "public Object evaluateJsonPath(String content, Class<?> targetType)",
    "source_code": "\tpublic Object evaluateJsonPath(String content, Class<?> targetType) {\n\t\ttry {\n\t\t\treturn JsonPath.parse(content).read(this.expression, targetType);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tString message = \"No value at JSON path \\\"\" + this.expression + \"\\\"\";\n\t\t\tthrow new AssertionError(message, ex);\n\t\t}\n\t}"
  },
  "org.springframework.test.util.JsonPathExpectationsHelper#getType()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 425
    },
    "return": "Type",
    "signature": "public Type getType()",
    "source_code": "\t\tpublic Type getType() {\n\t\t\treturn this.type;\n\t\t}"
  },
  "org.springframework.test.web.client.match.ContentRequestMatchers#json(expectedJsonContent,comparator)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the request body and the given string as JSON and assert the two\n\t * using the given {@link JsonComparator}. If the comparison failed, throws an\n\t * {@link AssertionError} with the message of the {@link JsonComparison}.\n\t * <p>Use this matcher if you require a custom JSONAssert configuration or\n\t * if you desire to use another assertion library.\n\t * @param expectedJsonContent the expected JSON content\n\t * @param comparator the comparator to use\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedJsonContent",
      "comparator"
    ],
    "position": {
      "column": 1,
      "line": 382
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher json(String expectedJsonContent, JsonComparator comparator)",
    "source_code": "\tpublic RequestMatcher json(String expectedJsonContent, JsonComparator comparator) {\n\t\treturn request -> {\n\t\t\ttry {\n\t\t\t\tMockClientHttpRequest mockRequest = (MockClientHttpRequest) request;\n\t\t\t\tcomparator.assertIsMatch(expectedJsonContent, mockRequest.getBodyAsString());\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new AssertionError(\"Failed to parse expected or actual JSON request content\", ex);\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.test.web.client.match.ContentRequestMatchers#json(expectedJsonContent,compareMode)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the request body and the given string as JSON and assert the two\n\t * using the given {@linkplain JsonCompareMode mode}. If the comparison failed,\n\t * throws an {@link AssertionError} with the message of the {@link JsonComparison}.\n\t * <p>Use of this matcher requires the <a\n\t * href=\"https://jsonassert.skyscreamer.org/\">JSONassert</a> library.\n\t * @param expectedJsonContent the expected JSON content\n\t * @param compareMode the compare mode\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedJsonContent",
      "compareMode"
    ],
    "position": {
      "column": 1,
      "line": 368
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher json(String expectedJsonContent, JsonCompareMode compareMode)",
    "source_code": "\tpublic RequestMatcher json(String expectedJsonContent, JsonCompareMode compareMode) {\n\t\treturn json(expectedJsonContent, JsonAssert.comparator(compareMode));\n\t}"
  },
  "org.springframework.test.web.client.match.ContentRequestMatchers#multipartData(MultiValueMap<String,expectedMap,defaultCharset)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #multipartData(MultiValueMap)} with a defaultCharset.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "expectedMap",
      "defaultCharset"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher multipartData(MultiValueMap<String, ?> expectedMap, Charset defaultCharset)",
    "source_code": "\tpublic RequestMatcher multipartData(MultiValueMap<String, ?> expectedMap, Charset defaultCharset) {\n\t\treturn multipartData(expectedMap, defaultCharset, true);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.HandlerResultAssert": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * AssertJ {@linkplain org.assertj.core.api.Assert assertions} that can be applied\n * to a handler or handler method.\n\n * @author Stephane Nicoll\n * @since 6.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class HandlerResultAssert",
    "source_code": "public class HandlerResultAssert extends AbstractObjectAssert<HandlerResultAssert, Object> {\n\n\tpublic HandlerResultAssert(@Nullable Object actual) {\n\t\tsuper(actual, HandlerResultAssert.class);\n\t\tas(\"Handler result\");\n\t}\n\n\t/**\n\t * Return a new {@linkplain MethodAssert assertion} object that uses\n\t * the {@link Method} that handles the request as the object to test.\n\t * <p>Verifies first that the handler is a {@linkplain #isMethodHandler()\n\t * method handler}.\n\t * <p>Example: <pre><code class=\"java\">\n\t * // Check that a GET to \"/greet\" is invoked on a \"handleGreet\" method name\n\t * assertThat(mvc.perform(get(\"/greet\")).handler().method().hasName(\"handleGreet\");\n\t * </code></pre>\n\t */\n\tpublic MethodAssert method() {\n\t\treturn new MethodAssert(getHandlerMethod());\n\t}\n\n\t/**\n\t * Verify that the handler is managed by a method invocation, typically on\n\t * a controller.\n\t */\n\tpublic HandlerResultAssert isMethodHandler() {\n\t\treturn isNotNull().isInstanceOf(HandlerMethod.class);\n\t}\n\n\t/**\n\t * Verify that the handler is managed by the given {@code handlerMethod}.\n\t * <p>This creates a \"mock\" for the given {@code controllerType} and records\n\t * the method invocation in the {@code handlerMethod}. The arguments used by\n\t * the target method invocation can be {@code null} as the purpose of the mock\n\t * is to identify the method that was invoked.\n\t * <p>Example: <pre><code class=\"java\">\n\t * // If the method has a return type, you can return the result of the invocation\n\t * assertThat(mvc.perform(get(\"/greet\")).handler().isInvokedOn(\n\t *         GreetController.class, controller -> controller.sayGreet());\n\t *\n\t * // If the method has a void return type, the controller should be returned\n\t * assertThat(mvc.perform(post(\"/persons/\")).handler().isInvokedOn(\n\t *         PersonController.class, controller -> controller.createPerson(null, null));\n\t * </code></pre>\n\t * @param controllerType the controller to mock\n\t * @param handlerMethod the method\n\t */\n\tpublic <T> HandlerResultAssert isInvokedOn(Class<T> controllerType, Function<T, Object> handlerMethod) {\n\t\tMethodAssert actual = method();\n\t\tObject methodInvocationInfo = handlerMethod.apply(MvcUriComponentsBuilder.on(controllerType));\n\t\tAssertions.assertThat(methodInvocationInfo)\n\t\t\t\t.as(\"Method invocation on controller '%s'\", controllerType.getSimpleName())\n\t\t\t\t.isInstanceOfSatisfying(MethodInvocationInfo.class, mii ->\n\t\t\t\t\t\tactual.isEqualTo(mii.getControllerMethod()));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Verify that the handler is of the given {@code type}. For a controller\n\t * method, this is the type of the controller.\n\t * <p>Example: <pre><code class=\"java\">\n\t * // Check that a GET to \"/greet\" is managed by GreetController\n\t * assertThat(mvc.perform(get(\"/greet\")).handler().hasType(GreetController.class);\n\t * </code></pre>\n\t * @param type the expected type of the handler\n\t */\n\tpublic HandlerResultAssert hasType(Class<?> type) {\n\t\tisNotNull();\n\t\tClass<?> actualType = this.actual.getClass();\n\t\tif (this.actual instanceof HandlerMethod handlerMethod) {\n\t\t\tactualType = handlerMethod.getBeanType();\n\t\t}\n\t\tAssertions.assertThat(ClassUtils.getUserClass(actualType)).as(\"Handler result type\").isEqualTo(type);\n\t\treturn this;\n\t}\n\n\tprivate Method getHandlerMethod() {\n\t\tisMethodHandler(); // validate type\n\t\treturn ((HandlerMethod) this.actual).getMethod();\n\t}\n\n\n}"
  },
  "org.springframework.test.web.servlet.assertj.HandlerResultAssert#hasType(type)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Verify that the handler is of the given {@code type}. For a controller\n\t * method, this is the type of the controller.\n\t * <p>Example: <pre><code class=\"java\">\n\t * // Check that a GET to \"/greet\" is managed by GreetController\n\t * assertThat(mvc.perform(get(\"/greet\")).handler().hasType(GreetController.class);\n\t * </code></pre>\n\t * @param type the expected type of the handler\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "HandlerResultAssert",
    "signature": "public HandlerResultAssert hasType(Class<?> type)",
    "source_code": "\tpublic HandlerResultAssert hasType(Class<?> type) {\n\t\tisNotNull();\n\t\tClass<?> actualType = this.actual.getClass();\n\t\tif (this.actual instanceof HandlerMethod handlerMethod) {\n\t\t\tactualType = handlerMethod.getBeanType();\n\t\t}\n\t\tAssertions.assertThat(ClassUtils.getUserClass(actualType)).as(\"Handler result type\").isEqualTo(type);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.HandlerResultAssert#isInvokedOn(controllerType,Function<T,handlerMethod)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Verify that the handler is managed by the given {@code handlerMethod}.\n\t * <p>This creates a \"mock\" for the given {@code controllerType} and records\n\t * the method invocation in the {@code handlerMethod}. The arguments used by\n\t * the target method invocation can be {@code null} as the purpose of the mock\n\t * is to identify the method that was invoked.\n\t * <p>Example: <pre><code class=\"java\">\n\t * // If the method has a return type, you can return the result of the invocation\n\t * assertThat(mvc.perform(get(\"/greet\")).handler().isInvokedOn(\n\t *         GreetController.class, controller -> controller.sayGreet());\n\t *\n\t * // If the method has a void return type, the controller should be returned\n\t * assertThat(mvc.perform(post(\"/persons/\")).handler().isInvokedOn(\n\t *         PersonController.class, controller -> controller.createPerson(null, null));\n\t * </code></pre>\n\t * @param controllerType the controller to mock\n\t * @param handlerMethod the method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "controllerType",
      "Function<T",
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "HandlerResultAssert",
    "signature": "public HandlerResultAssert isInvokedOn(Class<T> controllerType, Function<T, Object> handlerMethod)",
    "source_code": "\tpublic <T> HandlerResultAssert isInvokedOn(Class<T> controllerType, Function<T, Object> handlerMethod) {\n\t\tMethodAssert actual = method();\n\t\tObject methodInvocationInfo = handlerMethod.apply(MvcUriComponentsBuilder.on(controllerType));\n\t\tAssertions.assertThat(methodInvocationInfo)\n\t\t\t\t.as(\"Method invocation on controller '%s'\", controllerType.getSimpleName())\n\t\t\t\t.isInstanceOfSatisfying(MethodInvocationInfo.class, mii ->\n\t\t\t\t\t\tactual.isEqualTo(mii.getControllerMethod()));\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.HandlerResultAssert#isMethodHandler()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Verify that the handler is managed by a method invocation, typically on\n\t * a controller.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "HandlerResultAssert",
    "signature": "public HandlerResultAssert isMethodHandler()",
    "source_code": "\tpublic HandlerResultAssert isMethodHandler() {\n\t\treturn isNotNull().isInstanceOf(HandlerMethod.class);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.HandlerResultAssert#method()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a new {@linkplain MethodAssert assertion} object that uses\n\t * the {@link Method} that handles the request as the object to test.\n\t * <p>Verifies first that the handler is a {@linkplain #isMethodHandler()\n\t * method handler}.\n\t * <p>Example: <pre><code class=\"java\">\n\t * // Check that a GET to \"/greet\" is invoked on a \"handleGreet\" method name\n\t * assertThat(mvc.perform(get(\"/greet\")).handler().method().hasName(\"handleGreet\");\n\t * </code></pre>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "MethodAssert",
    "signature": "public MethodAssert method()",
    "source_code": "\tpublic MethodAssert method() {\n\t\treturn new MethodAssert(getHandlerMethod());\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.MockMultipartMvcRequestBuilder": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * A builder for {@link MockMultipartHttpServletRequest} that supports AssertJ.\n\t */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 494
    },
    "signature": "public class MockMultipartMvcRequestBuilder",
    "source_code": "\tpublic final class MockMultipartMvcRequestBuilder"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcRequestBuilder": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * A builder for {@link MockHttpServletRequest} that supports AssertJ.\n\t */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 426
    },
    "signature": "public class MockMvcRequestBuilder",
    "source_code": "\tpublic final class MockMvcRequestBuilder extends AbstractMockHttpServletRequestBuilder<MockMvcRequestBuilder>"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * {@code MockMvcTester} provides support for testing Spring MVC applications\n * with {@link MockMvc} for server request handling using\n * {@linkplain org.assertj.core.api.Assertions AssertJ}.\n *\n * <p>A tester instance can be created from a {@link WebApplicationContext}:\n * <pre><code class=\"java\">\n * // Create an instance with default settings\n * MockMvcTester mvc = MockMvcTester.from(applicationContext);\n *\n * // Create an instance with a custom Filter\n * MockMvcTester mvc = MockMvcTester.from(applicationContext,\n *         builder -> builder.addFilters(filter).build());\n * </code></pre>\n *\n * <p>A tester can be created in standalone mode by providing the controller\n * instances to include:<pre><code class=\"java\">\n * // Create an instance for PersonController\n * MockMvcTester mvc = MockMvcTester.of(new PersonController());\n * </code></pre>\n *\n * <p>Simple, single-statement assertions can be done wrapping the request\n * builder in {@code assertThat()} provides access to assertions. For instance:\n * <pre><code class=\"java\">\n * // perform a GET on /hi and assert the response body is equal to Hello\n * assertThat(mvc.get().uri(\"/hi\")).hasStatusOk().hasBodyTextEqualTo(\"Hello\");\n * </code></pre>\n *\n * <p>For more complex scenarios the {@linkplain MvcTestResult result} of the\n * exchange can be assigned in a variable to run multiple assertions:\n * <pre><code class=\"java\">\n * // perform a POST on /save and assert the response body is empty\n * MvcTestResult result = mvc.post().uri(\"/save\").exchange();\n * assertThat(result).hasStatus(HttpStatus.CREATED);\n * assertThat(result).body().isEmpty();\n * </code></pre>\n *\n * <p>If the request is processing asynchronously, {@code exchange} waits for\n * its completion, either using the\n * {@linkplain org.springframework.mock.web.MockAsyncContext#setTimeout default\n * timeout} or a given one. If you prefer to get the result of an\n * asynchronous request immediately, use {@code asyncExchange}:\n * <pre><code class=\"java\">\n * // perform a POST on /save and assert an asynchronous request has started\n * assertThat(mvc.post().uri(\"/save\").asyncExchange()).request().hasAsyncStarted();\n * </code></pre>\n *\n * <p>You can also perform requests using the static builders approach that\n * {@link MockMvc} uses. For instance:<pre><code class=\"java\">\n * // perform a GET on /hi and assert the response body is equal to Hello\n * assertThat(mvc.perform(get(\"/hi\")))\n *         .hasStatusOk().hasBodyTextEqualTo(\"Hello\");\n * </code></pre>\n *\n * <p>Use this approach if you have a custom {@link RequestBuilder} implementation\n * that you'd like to integrate here. This approach is also invoking {@link MockMvc}\n * without any additional processing of asynchronous requests.\n *\n * <p>One main difference between {@link MockMvc} and {@code MockMvcTester} is\n * that an unresolved exception is not thrown directly when using\n * {@code MockMvcTester}. Rather an {@link MvcTestResult} is available with an\n * {@linkplain MvcTestResult#getUnresolvedException() unresolved exception}.\n * Both resolved and unresolved exceptions are considered a failure that can\n * be asserted as follows:\n * <pre><code class=\"java\">\n * // perform a GET on /boom and assert the message for the exception\n * assertThat(mvc.get().uri(\"/boom\")).hasFailed()\n *         .failure().hasMessage(\"Test exception\");\n * </code></pre>\n *\n * <p>Any attempt to access the result with an unresolved exception will\n * throw an {@link AssertionError}:\n * <pre><code class=\"java\">\n * // throw an AssertionError with an unresolved exception\n * assertThat(mvc.get().uri(\"/boom\")).hasStatus5xxServerError();\n * </code></pre>\n *\n * <p>{@code MockMvcTester} can be configured with a list of\n * {@linkplain HttpMessageConverter message converters} to allow the response\n * body to be deserialized, rather than asserting on the raw values.\n *\n * @author Stephane Nicoll\n * @author Brian Clozel\n * @since 6.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "signature": "public class MockMvcTester",
    "source_code": "public final class MockMvcTester {\n\n\tprivate final MockMvc mockMvc;\n\n\t@Nullable\n\tprivate final HttpMessageContentConverter contentConverter;\n\n\n\tprivate MockMvcTester(MockMvc mockMvc, @Nullable HttpMessageContentConverter contentConverter) {\n\t\tAssert.notNull(mockMvc, \"mockMVC should not be null\");\n\t\tthis.mockMvc = mockMvc;\n\t\tthis.contentConverter = contentConverter;\n\t}\n\n\t/**\n\t * Create an instance that delegates to the given {@link MockMvc} instance.\n\t * @param mockMvc the MockMvc instance to delegate calls to\n\t */\n\tpublic static MockMvcTester create(MockMvc mockMvc) {\n\t\treturn new MockMvcTester(mockMvc, null);\n\t}\n\n\t/**\n\t * Create an instance using the given, fully initialized (i.e.,\n\t * <em>refreshed</em>) {@link WebApplicationContext}. The given\n\t * {@code customizations} are applied to the {@link DefaultMockMvcBuilder}\n\t * that ultimately creates the underlying {@link MockMvc} instance.\n\t * <p>If no further customization of the underlying {@link MockMvc} instance\n\t * is required, use {@link #from(WebApplicationContext)}.\n\t * @param applicationContext the application context to detect the Spring\n\t * MVC infrastructure and application controllers from\n\t * @param customizations a function that creates a {@link MockMvc}\n\t * instance based on a {@link DefaultMockMvcBuilder}\n\t * @see MockMvcBuilders#webAppContextSetup(WebApplicationContext)\n\t */\n\tpublic static MockMvcTester from(WebApplicationContext applicationContext,\n\t\t\tFunction<DefaultMockMvcBuilder, MockMvc> customizations) {\n\n\t\tDefaultMockMvcBuilder builder = MockMvcBuilders.webAppContextSetup(applicationContext);\n\t\tMockMvc mockMvc = customizations.apply(builder);\n\t\treturn create(mockMvc);\n\t}\n\n\t/**\n\t * Shortcut to create an instance using the given fully initialized (i.e.,\n\t * <em>refreshed</em>) {@link WebApplicationContext}.\n\t * <p>Consider using {@link #from(WebApplicationContext, Function)} if\n\t * further customization of the underlying {@link MockMvc} instance is\n\t * required.\n\t * @param applicationContext the application context to detect the Spring\n\t * MVC infrastructure and application controllers from\n\t * @see MockMvcBuilders#webAppContextSetup(WebApplicationContext)\n\t */\n\tpublic static MockMvcTester from(WebApplicationContext applicationContext) {\n\t\treturn from(applicationContext, DefaultMockMvcBuilder::build);\n\t}\n\n\t/**\n\t * Create an instance by registering one or more {@code @Controller} instances\n\t * and configuring Spring MVC infrastructure programmatically.\n\t * <p>This allows full control over the instantiation and initialization of\n\t * controllers and their dependencies, similar to plain unit tests while\n\t * also making it possible to test one controller at a time.\n\t * @param controllers one or more {@code @Controller} instances or\n\t * {@code @Controller} types to test; a type ({@code Class}) will be turned\n\t * into an instance\n\t * @param customizations a function that creates a {@link MockMvc} instance\n\t * based on a {@link StandaloneMockMvcBuilder}, typically to configure the\n\t * Spring MVC infrastructure\n\t * @see MockMvcBuilders#standaloneSetup(Object...)\n\t */\n\tpublic static MockMvcTester of(Collection<?> controllers,\n\t\t\tFunction<StandaloneMockMvcBuilder, MockMvc> customizations) {\n\n\t\tStandaloneMockMvcBuilder builder = MockMvcBuilders.standaloneSetup(controllers.toArray());\n\t\treturn create(customizations.apply(builder));\n\t}\n\n\t/**\n\t * Shortcut to create an instance by registering one or more {@code @Controller}\n\t * instances.\n\t * <p>The minimum infrastructure required by the\n\t * {@link org.springframework.web.servlet.DispatcherServlet DispatcherServlet}\n\t * to serve requests with annotated controllers is created. Consider using\n\t * {@link #of(Collection, Function)} if additional configuration of the MVC\n\t * infrastructure is required.\n\t * @param controllers one or more {@code @Controller} instances or\n\t * {@code @Controller} types to test; a type ({@code Class}) will be turned\n\t * into an instance\n\t * @see MockMvcBuilders#standaloneSetup(Object...)\n\t */\n\tpublic static MockMvcTester of(Object... controllers) {\n\t\treturn of(Arrays.asList(controllers), StandaloneMockMvcBuilder::build);\n\t}\n\n\t/**\n\t * Return a new instance using the specified {@linkplain HttpMessageConverter\n\t * message converters}.\n\t * <p>If none are specified, only basic assertions on the response body can\n\t * be performed. Consider registering a suitable JSON converter for asserting\n\t * against JSON data structures.\n\t * @param httpMessageConverters the message converters to use\n\t * @return a new instance using the specified converters\n\t */\n\tpublic MockMvcTester withHttpMessageConverters(Iterable<HttpMessageConverter<?>> httpMessageConverters) {\n\t\treturn new MockMvcTester(this.mockMvc, HttpMessageContentConverter.of(httpMessageConverters));\n\t}\n\n\t/**\n\t * Prepare an HTTP GET request.\n\t * <p>The returned builder can be wrapped in {@code assertThat} to enable\n\t * assertions on the result. For multi-statements assertions, use\n\t * {@link MockMvcRequestBuilder#exchange() exchange()} to assign the\n\t * result. To control the time to wait for asynchronous request to complete\n\t * on a per-request basis, use\n\t * {@link MockMvcRequestBuilder#exchange(Duration) exchange(Duration)}.\n\t * @return a request builder for specifying the target URI\n\t */\n\tpublic MockMvcRequestBuilder get() {\n\t\treturn method(HttpMethod.GET);\n\t}\n\n\t/**\n\t * Prepare an HTTP HEAD request.\n\t * <p>The returned builder can be wrapped in {@code assertThat} to enable\n\t * assertions on the result. For multi-statements assertions, use\n\t * {@link MockMvcRequestBuilder#exchange() exchange()} to assign the\n\t * result. To control the time to wait for asynchronous request to complete\n\t * on a per-request basis, use\n\t * {@link MockMvcRequestBuilder#exchange(Duration) exchange(Duration)}.\n\t * @return a request builder for specifying the target URI\n\t */\n\tpublic MockMvcRequestBuilder head() {\n\t\treturn method(HttpMethod.HEAD);\n\t}\n\n\t/**\n\t * Prepare an HTTP POST request.\n\t * <p>The returned builder can be wrapped in {@code assertThat} to enable\n\t * assertions on the result. For multi-statements assertions, use\n\t * {@link MockMvcRequestBuilder#exchange() exchange()} to assign the\n\t * result. To control the time to wait for asynchronous request to complete\n\t * on a per-request basis, use\n\t * {@link MockMvcRequestBuilder#exchange(Duration) exchange(Duration)}.\n\t * @return a request builder for specifying the target URI\n\t */\n\tpublic MockMvcRequestBuilder post() {\n\t\treturn method(HttpMethod.POST);\n\t}\n\n\t/**\n\t * Prepare an HTTP PUT request.\n\t * <p>The returned builder can be wrapped in {@code assertThat} to enable\n\t * assertions on the result. For multi-statements assertions, use\n\t * {@link MockMvcRequestBuilder#exchange() exchange()} to assign the\n\t * result. To control the time to wait for asynchronous request to complete\n\t * on a per-request basis, use\n\t * {@link MockMvcRequestBuilder#exchange(Duration) exchange(Duration)}.\n\t * @return a request builder for specifying the target URI\n\t */\n\tpublic MockMvcRequestBuilder put() {\n\t\treturn method(HttpMethod.PUT);\n\t}\n\n\t/**\n\t * Prepare an HTTP PATCH request.\n\t * <p>The returned builder can be wrapped in {@code assertThat} to enable\n\t * assertions on the result. For multi-statements assertions, use\n\t * {@link MockMvcRequestBuilder#exchange() exchange()} to assign the\n\t * result. To control the time to wait for asynchronous request to complete\n\t * on a per-request basis, use\n\t * {@link MockMvcRequestBuilder#exchange(Duration) exchange(Duration)}.\n\t * @return a request builder for specifying the target URI\n\t */\n\tpublic MockMvcRequestBuilder patch() {\n\t\treturn method(HttpMethod.PATCH);\n\t}\n\n\t/**\n\t * Prepare an HTTP DELETE request.\n\t * <p>The returned builder can be wrapped in {@code assertThat} to enable\n\t * assertions on the result. For multi-statements assertions, use\n\t * {@link MockMvcRequestBuilder#exchange() exchange()} to assign the\n\t * result. To control the time to wait for asynchronous request to complete\n\t * on a per-request basis, use\n\t * {@link MockMvcRequestBuilder#exchange(Duration) exchange(Duration)}.\n\t * @return a request builder for specifying the target URI\n\t */\n\tpublic MockMvcRequestBuilder delete() {\n\t\treturn method(HttpMethod.DELETE);\n\t}\n\n\t/**\n\t * Prepare an HTTP OPTIONS request.\n\t * <p>The returned builder can be wrapped in {@code assertThat} to enable\n\t * assertions on the result. For multi-statements assertions, use\n\t * {@link MockMvcRequestBuilder#exchange() exchange()} to assign the\n\t * result. To control the time to wait for asynchronous request to complete\n\t * on a per-request basis, use\n\t * {@link MockMvcRequestBuilder#exchange(Duration) exchange(Duration)}.\n\t * @return a request builder for specifying the target URI\n\t */\n\tpublic MockMvcRequestBuilder options() {\n\t\treturn method(HttpMethod.OPTIONS);\n\t}\n\n\t/**\n\t * Prepare a request for the specified {@code HttpMethod}.\n\t * <p>The returned builder can be wrapped in {@code assertThat} to enable\n\t * assertions on the result. For multi-statements assertions, use\n\t * {@link MockMvcRequestBuilder#exchange() exchange()} to assign the\n\t * result. To control the time to wait for asynchronous request to complete\n\t * on a per-request basis, use\n\t * {@link MockMvcRequestBuilder#exchange(Duration) exchange(Duration)}.\n\t * @return a request builder for specifying the target URI\n\t */\n\tpublic MockMvcRequestBuilder method(HttpMethod method) {\n\t\treturn new MockMvcRequestBuilder(method);\n\t}\n\n\t/**\n\t * Perform a request using the given {@link RequestBuilder} and return a\n\t * {@link MvcTestResult result} that can be used with standard\n\t * {@link org.assertj.core.api.Assertions AssertJ} assertions.\n\t * <p>Use only this method if you need to provide a custom\n\t * {@link RequestBuilder}. For regular cases, users should initiate the\n\t * configuration of the request using one of the methods available on\n\t * this instance, for example, {@link #get()} for HTTP GET.\n\t * <p>Contrary to {@link MockMvc#perform(RequestBuilder)}, this does not\n\t * throw an exception if the request fails with an unresolved exception.\n\t * Rather, the result provides the exception, if any. Assuming that a\n\t * {@link MockMvcRequestBuilders#post(URI) POST} request against\n\t * {@code /boom} throws an {@code IllegalStateException}, the following\n\t * asserts that the invocation has indeed failed with the expected error\n\t * message:\n\t * <pre><code class=\"java\">assertThat(mvc.post().uri(\"/boom\")))\n\t *       .failure().isInstanceOf(IllegalStateException.class)\n\t *       .hasMessage(\"Expected\");\n\t * </code></pre>\n\t * @param requestBuilder used to prepare the request to execute\n\t * @return an {@link MvcTestResult} to be wrapped in {@code assertThat}\n\t * @see MockMvc#perform(RequestBuilder)\n\t * @see #method(HttpMethod)\n\t */\n\tpublic MvcTestResult perform(RequestBuilder requestBuilder) {\n\t\tObject result = getMvcResultOrFailure(requestBuilder);\n\t\tif (result instanceof MvcResult mvcResult) {\n\t\t\treturn new DefaultMvcTestResult(mvcResult, null, this.contentConverter);\n\t\t}\n\t\telse {\n\t\t\treturn new DefaultMvcTestResult(null, (Exception) result, this.contentConverter);\n\t\t}\n\t}\n\n\tprivate Object getMvcResultOrFailure(RequestBuilder requestBuilder) {\n\t\ttry {\n\t\t\treturn this.mockMvc.perform(requestBuilder).andReturn();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\treturn ex;\n\t\t}\n\t}\n\n\t/**\n\t * Execute the request using the specified {@link RequestBuilder}. If the\n\t * request is processing asynchronously, wait at most the given\n\t * {@code timeToWait} duration. If not specified, then fall back on the\n\t * timeout value associated with the async request, see\n\t * {@link org.springframework.mock.web.MockAsyncContext#setTimeout}.\n\t */\n\tMvcTestResult exchange(RequestBuilder requestBuilder, @Nullable Duration timeToWait) {\n\t\tMvcTestResult result = perform(requestBuilder);\n\t\tif (result.getUnresolvedException() == null) {\n\t\t\tif (result.getRequest().isAsyncStarted()) {\n\t\t\t\t// Wait for async result before dispatching\n\t\t\t\tlong waitMs = (timeToWait != null ? timeToWait.toMillis() : -1);\n\t\t\t\tresult.getMvcResult().getAsyncResult(waitMs);\n\n\t\t\t\t// Perform ASYNC dispatch\n\t\t\t\tRequestBuilder dispatchRequest = servletContext -> {\n\t\t\t\t\tMockHttpServletRequest request = result.getMvcResult().getRequest();\n\t\t\t\t\trequest.setDispatcherType(DispatcherType.ASYNC);\n\t\t\t\t\trequest.setAsyncStarted(false);\n\t\t\t\t\treturn request;\n\t\t\t\t};\n\t\t\t\treturn perform(dispatchRequest);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\n\t/**\n\t * A builder for {@link MockHttpServletRequest} that supports AssertJ.\n\t */\n\tpublic final class MockMvcRequestBuilder extends AbstractMockHttpServletRequestBuilder<MockMvcRequestBuilder>\n\t\t\timplements AssertProvider<MvcTestResultAssert> {\n\n\t\tprivate final HttpMethod httpMethod;\n\n\t\tprivate MockMvcRequestBuilder(HttpMethod httpMethod) {\n\t\t\tsuper(httpMethod);\n\t\t\tthis.httpMethod = httpMethod;\n\t\t}\n\n\t\t/**\n\t\t * Enable file upload support using multipart.\n\t\t * @return a {@link MockMultipartMvcRequestBuilder} with the settings\n\t\t * configured thus far\n\t\t */\n\t\tpublic MockMultipartMvcRequestBuilder multipart() {\n\t\t\treturn new MockMultipartMvcRequestBuilder(this);\n\t\t}\n\n\t\t/**\n\t\t * Execute the request. If the request is processing asynchronously,\n\t\t * wait at most the given timeout value associated with the async request,\n\t\t * see {@link org.springframework.mock.web.MockAsyncContext#setTimeout}.\n\t\t * <p>For simple assertions, you can wrap this builder in\n\t\t * {@code assertThat} rather than calling this method explicitly:\n\t\t * <pre><code class=\"java\">\n\t\t * // These two examples are equivalent\n\t\t * assertThat(mvc.get().uri(\"/greet\")).hasStatusOk();\n\t\t * assertThat(mvc.get().uri(\"/greet\").exchange()).hasStatusOk();\n\t\t * </code></pre>\n\t\t * <p>For assertions on the original asynchronous request that might\n\t\t * still be in progress, use {@link #asyncExchange()}.\n\t\t * @see #exchange(Duration) to customize the timeout for async requests\n\t\t */\n\t\tpublic MvcTestResult exchange() {\n\t\t\treturn MockMvcTester.this.exchange(this, null);\n\t\t}\n\n\t\t/**\n\t\t * Execute the request and wait at most the given {@code timeToWait}\n\t\t * duration for the asynchronous request to complete. If the request\n\t\t * is not asynchronous, the {@code timeToWait} is ignored.\n\t\t * <p>For assertions on the original asynchronous request that might\n\t\t * still be in progress, use {@link #asyncExchange()}.\n\t\t * @see #exchange()\n\t\t */\n\t\tpublic MvcTestResult exchange(Duration timeToWait) {\n\t\t\treturn MockMvcTester.this.exchange(this, timeToWait);\n\t\t}\n\n\t\t/**\n\t\t * Execute the request and do not attempt to wait for the completion of\n\t\t * an asynchronous request. Contrary to {@link #exchange()}, this returns\n\t\t * the original result that might still be in progress.\n\t\t */\n\t\tpublic MvcTestResult asyncExchange() {\n\t\t\treturn MockMvcTester.this.perform(this);\n\t\t}\n\n\t\t@Override\n\t\tpublic MvcTestResultAssert assertThat() {\n\t\t\treturn new MvcTestResultAssert(exchange(), MockMvcTester.this.contentConverter);\n\t\t}\n\t}\n\n\t/**\n\t * A builder for {@link MockMultipartHttpServletRequest} that supports AssertJ.\n\t */\n\tpublic final class MockMultipartMvcRequestBuilder\n\t\t\textends AbstractMockMultipartHttpServletRequestBuilder<MockMultipartMvcRequestBuilder>\n\t\t\timplements AssertProvider<MvcTestResultAssert> {\n\n\t\tprivate MockMultipartMvcRequestBuilder(MockMvcRequestBuilder currentBuilder) {\n\t\t\tsuper(currentBuilder.httpMethod);\n\t\t\tmerge(currentBuilder);\n\t\t}\n\n\t\t/**\n\t\t * Execute the request. If the request is processing asynchronously,\n\t\t * wait at most the given timeout value associated with the async request,\n\t\t * see {@link org.springframework.mock.web.MockAsyncContext#setTimeout}.\n\t\t * <p>For simple assertions, you can wrap this builder in\n\t\t * {@code assertThat} rather than calling this method explicitly:\n\t\t * <pre><code class=\"java\">\n\t\t * // These two examples are equivalent\n\t\t * assertThat(mvc.get().uri(\"/greet\")).hasStatusOk();\n\t\t * assertThat(mvc.get().uri(\"/greet\").exchange()).hasStatusOk();\n\t\t * </code></pre>\n\t\t * <p>For assertions on the original asynchronous request that might\n\t\t * still be in progress, use {@link #asyncExchange()}.\n\t\t * @see #exchange(Duration) to customize the timeout for async requests\n\t\t */\n\t\tpublic MvcTestResult exchange() {\n\t\t\treturn MockMvcTester.this.exchange(this, null);\n\t\t}\n\n\t\t/**\n\t\t * Execute the request and wait at most the given {@code timeToWait}\n\t\t * duration for the asynchronous request to complete. If the request\n\t\t * is not asynchronous, the {@code timeToWait} is ignored.\n\t\t * <p>For assertions on the original asynchronous request that might\n\t\t * still be in progress, use {@link #asyncExchange()}.\n\t\t * @see #exchange()\n\t\t */\n\t\tpublic MvcTestResult exchange(Duration timeToWait) {\n\t\t\treturn MockMvcTester.this.exchange(this, timeToWait);\n\t\t}\n\n\t\t/**\n\t\t * Execute the request and do not attempt to wait for the completion of\n\t\t * an asynchronous request. Contrary to {@link #exchange()}, this returns\n\t\t * the original result that might still be in progress.\n\t\t */\n\t\tpublic MvcTestResult asyncExchange() {\n\t\t\treturn MockMvcTester.this.perform(this);\n\t\t}\n\n\t\t@Override\n\t\tpublic MvcTestResultAssert assertThat() {\n\t\t\treturn new MvcTestResultAssert(exchange(), MockMvcTester.this.contentConverter);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#assertThat()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 544
    },
    "return": "MvcTestResultAssert",
    "signature": "public MvcTestResultAssert assertThat()",
    "source_code": "\t\tpublic MvcTestResultAssert assertThat() {\n\t\t\treturn new MvcTestResultAssert(exchange(), MockMvcTester.this.contentConverter);\n\t\t}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#asyncExchange()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Execute the request and do not attempt to wait for the completion of\n\t\t * an asynchronous request. Contrary to {@link #exchange()}, this returns\n\t\t * the original result that might still be in progress.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 539
    },
    "return": "MvcTestResult",
    "signature": "public MvcTestResult asyncExchange()",
    "source_code": "\t\tpublic MvcTestResult asyncExchange() {\n\t\t\treturn MockMvcTester.this.perform(this);\n\t\t}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#create(mockMvc)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an instance that delegates to the given {@link MockMvc} instance.\n\t * @param mockMvc the MockMvc instance to delegate calls to\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mockMvc"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "MockMvcTester",
    "signature": "public MockMvcTester create(MockMvc mockMvc)",
    "source_code": "\tpublic static MockMvcTester create(MockMvc mockMvc) {\n\t\treturn new MockMvcTester(mockMvc, null);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#delete()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare an HTTP DELETE request.\n\t * <p>The returned builder can be wrapped in {@code assertThat} to enable\n\t * assertions on the result. For multi-statements assertions, use\n\t * {@link MockMvcRequestBuilder#exchange() exchange()} to assign the\n\t * result. To control the time to wait for asynchronous request to complete\n\t * on a per-request basis, use\n\t * {@link MockMvcRequestBuilder#exchange(Duration) exchange(Duration)}.\n\t * @return a request builder for specifying the target URI\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 319
    },
    "return": "MockMvcRequestBuilder",
    "signature": "public MockMvcRequestBuilder delete()",
    "source_code": "\tpublic MockMvcRequestBuilder delete() {\n\t\treturn method(HttpMethod.DELETE);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#exchange()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Execute the request. If the request is processing asynchronously,\n\t\t * wait at most the given timeout value associated with the async request,\n\t\t * see {@link org.springframework.mock.web.MockAsyncContext#setTimeout}.\n\t\t * <p>For simple assertions, you can wrap this builder in\n\t\t * {@code assertThat} rather than calling this method explicitly:\n\t\t * <pre><code class=\"java\">\n\t\t * // These two examples are equivalent\n\t\t * assertThat(mvc.get().uri(\"/greet\")).hasStatusOk();\n\t\t * assertThat(mvc.get().uri(\"/greet\").exchange()).hasStatusOk();\n\t\t * </code></pre>\n\t\t * <p>For assertions on the original asynchronous request that might\n\t\t * still be in progress, use {@link #asyncExchange()}.\n\t\t * @see #exchange(Duration) to customize the timeout for async requests\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 518
    },
    "return": "MvcTestResult",
    "signature": "public MvcTestResult exchange()",
    "source_code": "\t\tpublic MvcTestResult exchange() {\n\t\t\treturn MockMvcTester.this.exchange(this, null);\n\t\t}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#exchange(timeToWait)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Execute the request and wait at most the given {@code timeToWait}\n\t\t * duration for the asynchronous request to complete. If the request\n\t\t * is not asynchronous, the {@code timeToWait} is ignored.\n\t\t * <p>For assertions on the original asynchronous request that might\n\t\t * still be in progress, use {@link #asyncExchange()}.\n\t\t * @see #exchange()\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeToWait"
    ],
    "position": {
      "column": 1,
      "line": 530
    },
    "return": "MvcTestResult",
    "signature": "public MvcTestResult exchange(Duration timeToWait)",
    "source_code": "\t\tpublic MvcTestResult exchange(Duration timeToWait) {\n\t\t\treturn MockMvcTester.this.exchange(this, timeToWait);\n\t\t}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#from(applicationContext)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Shortcut to create an instance using the given fully initialized (i.e.,\n\t * <em>refreshed</em>) {@link WebApplicationContext}.\n\t * <p>Consider using {@link #from(WebApplicationContext, Function)} if\n\t * further customization of the underlying {@link MockMvc} instance is\n\t * required.\n\t * @param applicationContext the application context to detect the Spring\n\t * MVC infrastructure and application controllers from\n\t * @see MockMvcBuilders#webAppContextSetup(WebApplicationContext)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "applicationContext"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "MockMvcTester",
    "signature": "public MockMvcTester from(WebApplicationContext applicationContext)",
    "source_code": "\tpublic static MockMvcTester from(WebApplicationContext applicationContext) {\n\t\treturn from(applicationContext, DefaultMockMvcBuilder::build);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#from(applicationContext,Function<DefaultMockMvcBuilder,customizations)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an instance using the given, fully initialized (i.e.,\n\t * <em>refreshed</em>) {@link WebApplicationContext}. The given\n\t * {@code customizations} are applied to the {@link DefaultMockMvcBuilder}\n\t * that ultimately creates the underlying {@link MockMvc} instance.\n\t * <p>If no further customization of the underlying {@link MockMvc} instance\n\t * is required, use {@link #from(WebApplicationContext)}.\n\t * @param applicationContext the application context to detect the Spring\n\t * MVC infrastructure and application controllers from\n\t * @param customizations a function that creates a {@link MockMvc}\n\t * instance based on a {@link DefaultMockMvcBuilder}\n\t * @see MockMvcBuilders#webAppContextSetup(WebApplicationContext)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "applicationContext",
      "Function<DefaultMockMvcBuilder",
      "customizations"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "MockMvcTester",
    "signature": "public MockMvcTester from(WebApplicationContext applicationContext,\n\t\t\tFunction<DefaultMockMvcBuilder, MockMvc> customizations)",
    "source_code": "\tpublic static MockMvcTester from(WebApplicationContext applicationContext,"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#get()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare an HTTP GET request.\n\t * <p>The returned builder can be wrapped in {@code assertThat} to enable\n\t * assertions on the result. For multi-statements assertions, use\n\t * {@link MockMvcRequestBuilder#exchange() exchange()} to assign the\n\t * result. To control the time to wait for asynchronous request to complete\n\t * on a per-request basis, use\n\t * {@link MockMvcRequestBuilder#exchange(Duration) exchange(Duration)}.\n\t * @return a request builder for specifying the target URI\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "MockMvcRequestBuilder",
    "signature": "public MockMvcRequestBuilder get()",
    "source_code": "\tpublic MockMvcRequestBuilder get() {\n\t\treturn method(HttpMethod.GET);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#head()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare an HTTP HEAD request.\n\t * <p>The returned builder can be wrapped in {@code assertThat} to enable\n\t * assertions on the result. For multi-statements assertions, use\n\t * {@link MockMvcRequestBuilder#exchange() exchange()} to assign the\n\t * result. To control the time to wait for asynchronous request to complete\n\t * on a per-request basis, use\n\t * {@link MockMvcRequestBuilder#exchange(Duration) exchange(Duration)}.\n\t * @return a request builder for specifying the target URI\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "MockMvcRequestBuilder",
    "signature": "public MockMvcRequestBuilder head()",
    "source_code": "\tpublic MockMvcRequestBuilder head() {\n\t\treturn method(HttpMethod.HEAD);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#method(method)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare a request for the specified {@code HttpMethod}.\n\t * <p>The returned builder can be wrapped in {@code assertThat} to enable\n\t * assertions on the result. For multi-statements assertions, use\n\t * {@link MockMvcRequestBuilder#exchange() exchange()} to assign the\n\t * result. To control the time to wait for asynchronous request to complete\n\t * on a per-request basis, use\n\t * {@link MockMvcRequestBuilder#exchange(Duration) exchange(Duration)}.\n\t * @return a request builder for specifying the target URI\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "MockMvcRequestBuilder",
    "signature": "public MockMvcRequestBuilder method(HttpMethod method)",
    "source_code": "\tpublic MockMvcRequestBuilder method(HttpMethod method) {\n\t\treturn new MockMvcRequestBuilder(method);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#multipart()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Enable file upload support using multipart.\n\t\t * @return a {@link MockMultipartMvcRequestBuilder} with the settings\n\t\t * configured thus far\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 441
    },
    "return": "MockMultipartMvcRequestBuilder",
    "signature": "public MockMultipartMvcRequestBuilder multipart()",
    "source_code": "\t\tpublic MockMultipartMvcRequestBuilder multipart() {\n\t\t\treturn new MockMultipartMvcRequestBuilder(this);\n\t\t}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#of(controllers)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Shortcut to create an instance by registering one or more {@code @Controller}\n\t * instances.\n\t * <p>The minimum infrastructure required by the\n\t * {@link org.springframework.web.servlet.DispatcherServlet DispatcherServlet}\n\t * to serve requests with annotated controllers is created. Consider using\n\t * {@link #of(Collection, Function)} if additional configuration of the MVC\n\t * infrastructure is required.\n\t * @param controllers one or more {@code @Controller} instances or\n\t * {@code @Controller} types to test; a type ({@code Class}) will be turned\n\t * into an instance\n\t * @see MockMvcBuilders#standaloneSetup(Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "controllers"
    ],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "MockMvcTester",
    "signature": "public MockMvcTester of(Object... controllers)",
    "source_code": "\tpublic static MockMvcTester of(Object... controllers) {\n\t\treturn of(Arrays.asList(controllers), StandaloneMockMvcBuilder::build);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#of(controllers,Function<StandaloneMockMvcBuilder,customizations)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an instance by registering one or more {@code @Controller} instances\n\t * and configuring Spring MVC infrastructure programmatically.\n\t * <p>This allows full control over the instantiation and initialization of\n\t * controllers and their dependencies, similar to plain unit tests while\n\t * also making it possible to test one controller at a time.\n\t * @param controllers one or more {@code @Controller} instances or\n\t * {@code @Controller} types to test; a type ({@code Class}) will be turned\n\t * into an instance\n\t * @param customizations a function that creates a {@link MockMvc} instance\n\t * based on a {@link StandaloneMockMvcBuilder}, typically to configure the\n\t * Spring MVC infrastructure\n\t * @see MockMvcBuilders#standaloneSetup(Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "controllers",
      "Function<StandaloneMockMvcBuilder",
      "customizations"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "MockMvcTester",
    "signature": "public MockMvcTester of(Collection<?> controllers,\n\t\t\tFunction<StandaloneMockMvcBuilder, MockMvc> customizations)",
    "source_code": "\tpublic static MockMvcTester of(Collection<?> controllers,"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#options()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare an HTTP OPTIONS request.\n\t * <p>The returned builder can be wrapped in {@code assertThat} to enable\n\t * assertions on the result. For multi-statements assertions, use\n\t * {@link MockMvcRequestBuilder#exchange() exchange()} to assign the\n\t * result. To control the time to wait for asynchronous request to complete\n\t * on a per-request basis, use\n\t * {@link MockMvcRequestBuilder#exchange(Duration) exchange(Duration)}.\n\t * @return a request builder for specifying the target URI\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "MockMvcRequestBuilder",
    "signature": "public MockMvcRequestBuilder options()",
    "source_code": "\tpublic MockMvcRequestBuilder options() {\n\t\treturn method(HttpMethod.OPTIONS);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#patch()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare an HTTP PATCH request.\n\t * <p>The returned builder can be wrapped in {@code assertThat} to enable\n\t * assertions on the result. For multi-statements assertions, use\n\t * {@link MockMvcRequestBuilder#exchange() exchange()} to assign the\n\t * result. To control the time to wait for asynchronous request to complete\n\t * on a per-request basis, use\n\t * {@link MockMvcRequestBuilder#exchange(Duration) exchange(Duration)}.\n\t * @return a request builder for specifying the target URI\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 305
    },
    "return": "MockMvcRequestBuilder",
    "signature": "public MockMvcRequestBuilder patch()",
    "source_code": "\tpublic MockMvcRequestBuilder patch() {\n\t\treturn method(HttpMethod.PATCH);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#perform(requestBuilder)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform a request using the given {@link RequestBuilder} and return a\n\t * {@link MvcTestResult result} that can be used with standard\n\t * {@link org.assertj.core.api.Assertions AssertJ} assertions.\n\t * <p>Use only this method if you need to provide a custom\n\t * {@link RequestBuilder}. For regular cases, users should initiate the\n\t * configuration of the request using one of the methods available on\n\t * this instance, for example, {@link #get()} for HTTP GET.\n\t * <p>Contrary to {@link MockMvc#perform(RequestBuilder)}, this does not\n\t * throw an exception if the request fails with an unresolved exception.\n\t * Rather, the result provides the exception, if any. Assuming that a\n\t * {@link MockMvcRequestBuilders#post(URI) POST} request against\n\t * {@code /boom} throws an {@code IllegalStateException}, the following\n\t * asserts that the invocation has indeed failed with the expected error\n\t * message:\n\t * <pre><code class=\"java\">assertThat(mvc.post().uri(\"/boom\")))\n\t *       .failure().isInstanceOf(IllegalStateException.class)\n\t *       .hasMessage(\"Expected\");\n\t * </code></pre>\n\t * @param requestBuilder used to prepare the request to execute\n\t * @return an {@link MvcTestResult} to be wrapped in {@code assertThat}\n\t * @see MockMvc#perform(RequestBuilder)\n\t * @see #method(HttpMethod)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestBuilder"
    ],
    "position": {
      "column": 1,
      "line": 375
    },
    "return": "MvcTestResult",
    "signature": "public MvcTestResult perform(RequestBuilder requestBuilder)",
    "source_code": "\tpublic MvcTestResult perform(RequestBuilder requestBuilder) {\n\t\tObject result = getMvcResultOrFailure(requestBuilder);\n\t\tif (result instanceof MvcResult mvcResult) {\n\t\t\treturn new DefaultMvcTestResult(mvcResult, null, this.contentConverter);\n\t\t}\n\t\telse {\n\t\t\treturn new DefaultMvcTestResult(null, (Exception) result, this.contentConverter);\n\t\t}\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#post()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare an HTTP POST request.\n\t * <p>The returned builder can be wrapped in {@code assertThat} to enable\n\t * assertions on the result. For multi-statements assertions, use\n\t * {@link MockMvcRequestBuilder#exchange() exchange()} to assign the\n\t * result. To control the time to wait for asynchronous request to complete\n\t * on a per-request basis, use\n\t * {@link MockMvcRequestBuilder#exchange(Duration) exchange(Duration)}.\n\t * @return a request builder for specifying the target URI\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 277
    },
    "return": "MockMvcRequestBuilder",
    "signature": "public MockMvcRequestBuilder post()",
    "source_code": "\tpublic MockMvcRequestBuilder post() {\n\t\treturn method(HttpMethod.POST);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#put()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare an HTTP PUT request.\n\t * <p>The returned builder can be wrapped in {@code assertThat} to enable\n\t * assertions on the result. For multi-statements assertions, use\n\t * {@link MockMvcRequestBuilder#exchange() exchange()} to assign the\n\t * result. To control the time to wait for asynchronous request to complete\n\t * on a per-request basis, use\n\t * {@link MockMvcRequestBuilder#exchange(Duration) exchange(Duration)}.\n\t * @return a request builder for specifying the target URI\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "MockMvcRequestBuilder",
    "signature": "public MockMvcRequestBuilder put()",
    "source_code": "\tpublic MockMvcRequestBuilder put() {\n\t\treturn method(HttpMethod.PUT);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#withHttpMessageConverters(httpMessageConverters)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a new instance using the specified {@linkplain HttpMessageConverter\n\t * message converters}.\n\t * <p>If none are specified, only basic assertions on the response body can\n\t * be performed. Consider registering a suitable JSON converter for asserting\n\t * against JSON data structures.\n\t * @param httpMessageConverters the message converters to use\n\t * @return a new instance using the specified converters\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "httpMessageConverters"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "MockMvcTester",
    "signature": "public MockMvcTester withHttpMessageConverters(Iterable<HttpMessageConverter<?>> httpMessageConverters)",
    "source_code": "\tpublic MockMvcTester withHttpMessageConverters(Iterable<HttpMessageConverter<?>> httpMessageConverters) {\n\t\treturn new MockMvcTester(this.mockMvc, HttpMessageContentConverter.of(httpMessageConverters));\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Base builder for {@link MockHttpServletRequest} required as input to\n * perform requests in {@link MockMvc}.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Arjen Poutsma\n * @author Sam Brannen\n * @author Kamill Sokol\n * @since 6.2\n * @param <B> a self reference to the builder type\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "signature": "public class AbstractMockHttpServletRequestBuilder",
    "source_code": "public abstract class AbstractMockHttpServletRequestBuilder<B extends AbstractMockHttpServletRequestBuilder<B>>"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#accept(mediaTypes)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@code Accept} header using raw String values, possibly not even\n\t * well-formed (for testing purposes).\n\t * @param mediaTypes one or more media types; internally joined as\n\t * comma-separated String\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mediaTypes"
    ],
    "position": {
      "column": 1,
      "line": 336
    },
    "return": "B",
    "signature": "public B accept(String... mediaTypes)",
    "source_code": "\tpublic B accept(String... mediaTypes) {\n\t\tAssert.notEmpty(mediaTypes, \"'mediaTypes' must not be empty\");\n\t\tthis.headers.set(\"Accept\", String.join(\", \", mediaTypes));\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#buildRequest(servletContext)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@link MockHttpServletRequest}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 712
    },
    "return": "MockHttpServletRequest",
    "signature": "public MockHttpServletRequest buildRequest(ServletContext servletContext)",
    "source_code": "\tpublic final MockHttpServletRequest buildRequest(ServletContext servletContext) {\n\t\tAssert.notNull(this.uri, \"'uri' is required\");\n\t\tMockHttpServletRequest request = createServletRequest(servletContext);\n\n\t\trequest.setAsyncSupported(true);\n\t\trequest.setMethod(this.method.name());\n\n\t\trequest.setUriTemplate(this.uriTemplate);\n\n\t\tString requestUri = this.uri.getRawPath();\n\t\trequest.setRequestURI(requestUri);\n\n\t\tif (this.uri.getScheme() != null) {\n\t\t\trequest.setScheme(this.uri.getScheme());\n\t\t}\n\t\tif (this.uri.getHost() != null) {\n\t\t\trequest.setServerName(this.uri.getHost());\n\t\t}\n\t\tif (this.uri.getPort() != -1) {\n\t\t\trequest.setServerPort(this.uri.getPort());\n\t\t}\n\n\t\tupdatePathRequestProperties(request, requestUri);\n\n\t\tif (this.secure != null) {\n\t\t\trequest.setSecure(this.secure);\n\t\t}\n\t\tif (this.principal != null) {\n\t\t\trequest.setUserPrincipal(this.principal);\n\t\t}\n\t\tif (this.remoteAddress != null) {\n\t\t\trequest.setRemoteAddr(this.remoteAddress);\n\t\t}\n\t\tif (this.session != null) {\n\t\t\trequest.setSession(this.session);\n\t\t}\n\n\t\trequest.setCharacterEncoding(this.characterEncoding);\n\t\trequest.setContent(this.content);\n\t\trequest.setContentType(this.contentType);\n\n\t\tthis.headers.forEach((name, values) -> {\n\t\t\tfor (Object value : values) {\n\t\t\t\trequest.addHeader(name, value);\n\t\t\t}\n\t\t});\n\n\t\tif (!ObjectUtils.isEmpty(this.content) &&\n\t\t\t\t!this.headers.containsKey(HttpHeaders.CONTENT_LENGTH) &&\n\t\t\t\t!this.headers.containsKey(HttpHeaders.TRANSFER_ENCODING)) {\n\n\t\t\trequest.addHeader(HttpHeaders.CONTENT_LENGTH, this.content.length);\n\t\t}\n\n\t\tString query = this.uri.getRawQuery();\n\t\tif (!this.queryParams.isEmpty()) {\n\t\t\tString str = UriComponentsBuilder.newInstance().queryParams(this.queryParams).build().encode().getQuery();\n\t\t\tquery = StringUtils.hasLength(query) ? (query + \"&\" + str) : str;\n\t\t}\n\t\tif (query != null) {\n\t\t\trequest.setQueryString(query);\n\t\t}\n\t\taddRequestParams(request, UriComponentsBuilder.fromUri(this.uri).build().getQueryParams());\n\n\t\tthis.parameters.forEach((name, values) -> {\n\t\t\tfor (String value : values) {\n\t\t\t\trequest.addParameter(name, value);\n\t\t\t}\n\t\t});\n\n\t\tif (!this.formFields.isEmpty()) {\n\t\t\tif (this.content != null && this.content.length > 0) {\n\t\t\t\tthrow new IllegalStateException(\"Could not write form data with an existing body\");\n\t\t\t}\n\t\t\tCharset charset = (this.characterEncoding != null ?\n\t\t\t\t\tCharset.forName(this.characterEncoding) : StandardCharsets.UTF_8);\n\t\t\tMediaType mediaType = (request.getContentType() != null ?\n\t\t\t\t\tMediaType.parseMediaType(request.getContentType()) :\n\t\t\t\t\tnew MediaType(MediaType.APPLICATION_FORM_URLENCODED, charset));\n\t\t\tif (!mediaType.isCompatibleWith(MediaType.APPLICATION_FORM_URLENCODED)) {\n\t\t\t\tthrow new IllegalStateException(\"Invalid content type: '\" + mediaType +\n\t\t\t\t\t\t\"' is not compatible with '\" + MediaType.APPLICATION_FORM_URLENCODED + \"'\");\n\t\t\t}\n\t\t\trequest.setContent(writeFormData(mediaType, charset));\n\t\t\tif (request.getContentType() == null) {\n\t\t\t\trequest.setContentType(mediaType.toString());\n\t\t\t}\n\t\t}\n\t\tif (this.content != null && this.content.length > 0) {\n\t\t\tString requestContentType = request.getContentType();\n\t\t\tif (requestContentType != null) {\n\t\t\t\ttry {\n\t\t\t\t\tMediaType mediaType = MediaType.parseMediaType(requestContentType);\n\t\t\t\t\tif (MediaType.APPLICATION_FORM_URLENCODED.includes(mediaType)) {\n\t\t\t\t\t\taddRequestParams(request, parseFormData(mediaType));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t// Must be invalid, ignore\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!ObjectUtils.isEmpty(this.cookies)) {\n\t\t\trequest.setCookies(this.cookies.toArray(new Cookie[0]));\n\t\t}\n\t\tif (!ObjectUtils.isEmpty(this.locales)) {\n\t\t\trequest.setPreferredLocales(this.locales);\n\t\t}\n\n\t\tthis.requestAttributes.forEach(request::setAttribute);\n\t\tthis.sessionAttributes.forEach((name, attribute) -> {\n\t\t\tHttpSession session = request.getSession();\n\t\t\tAssert.state(session != null, \"No HttpSession\");\n\t\t\tsession.setAttribute(name, attribute);\n\t\t});\n\n\t\tFlashMap flashMap = new FlashMap();\n\t\tflashMap.putAll(this.flashAttributes);\n\t\tFlashMapManager flashMapManager = getFlashMapManager(request);\n\t\tflashMapManager.saveOutputFlashMap(flashMap, request, new MockHttpServletResponse());\n\n\t\treturn request;\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#characterEncoding(encoding)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the character encoding of the request.\n\t * @param encoding the character encoding\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "B",
    "signature": "public B characterEncoding(String encoding)",
    "source_code": "\tpublic B characterEncoding(String encoding) {\n\t\tthis.characterEncoding = encoding;\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#content(content)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the request body as a UTF-8 String.\n\t * <p>If content is provided and {@link #contentType(MediaType)} is set to\n\t * {@code application/x-www-form-urlencoded}, the content will be parsed\n\t * and used to populate the {@link #param(String, String...) request\n\t * parameters} map.\n\t * @param content the body content\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content"
    ],
    "position": {
      "column": 1,
      "line": 289
    },
    "return": "B",
    "signature": "public B content(String content)",
    "source_code": "\tpublic B content(String content) {\n\t\tthis.content = content.getBytes(StandardCharsets.UTF_8);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#contentType(contentType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the 'Content-Type' header of the request as a raw String value,\n\t * possibly not even well-formed (for testing purposes).\n\t * @param contentType the content type\n\t * @since 4.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 314
    },
    "return": "B",
    "signature": "public B contentType(String contentType)",
    "source_code": "\tpublic B contentType(String contentType) {\n\t\tAssert.notNull(contentType, \"'contentType' must not be null\");\n\t\tthis.contentType = contentType;\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#contextPath(contextPath)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the portion of the requestURI that represents the context path.\n\t * The context path, if specified, must match to the start of the request URI.\n\t * <p>In most cases, tests can be written by omitting the context path from\n\t * the requestURI. This is because most applications don't actually depend\n\t * on the name under which they're deployed. If specified here, the context\n\t * path must start with a \"/\" and must not end with a \"/\".\n\t * @see jakarta.servlet.http.HttpServletRequest#getContextPath()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contextPath"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "B",
    "signature": "public B contextPath(String contextPath)",
    "source_code": "\tpublic B contextPath(String contextPath) {\n\t\tif (StringUtils.hasText(contextPath)) {\n\t\t\tAssert.isTrue(contextPath.startsWith(\"/\"), \"Context path must start with a '/'\");\n\t\t\tAssert.isTrue(!contextPath.endsWith(\"/\"), \"Context path must not end with a '/'\");\n\t\t}\n\t\tthis.contextPath = contextPath;\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#cookie(cookies)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given cookies to the request. Cookies are always added.\n\t * @param cookies the cookies to add\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cookies"
    ],
    "position": {
      "column": 1,
      "line": 451
    },
    "return": "B",
    "signature": "public B cookie(Cookie... cookies)",
    "source_code": "\tpublic B cookie(Cookie... cookies) {\n\t\tAssert.notEmpty(cookies, \"'cookies' must not be empty\");\n\t\tthis.cookies.addAll(Arrays.asList(cookies));\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#createServletRequest(servletContext)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link MockHttpServletRequest} based on the supplied\n\t * {@code ServletContext}.\n\t * <p>Can be overridden in subclasses.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 842
    },
    "return": "MockHttpServletRequest",
    "signature": "protected MockHttpServletRequest createServletRequest(ServletContext servletContext)",
    "source_code": "\tprotected MockHttpServletRequest createServletRequest(ServletContext servletContext) {\n\t\treturn new MockHttpServletRequest(servletContext);\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#flashAttr(name,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set an \"input\" flash attribute.\n\t * @param name the flash attribute name\n\t * @param value the flash attribute value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 517
    },
    "return": "B",
    "signature": "public B flashAttr(String name, Object value)",
    "source_code": "\tpublic B flashAttr(String name, Object value) {\n\t\taddToMap(this.flashAttributes, name, value);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#flashAttrs(Map<String,flashAttributes)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set flash attributes.\n\t * @param flashAttributes the flash attributes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "flashAttributes"
    ],
    "position": {
      "column": 1,
      "line": 526
    },
    "return": "B",
    "signature": "public B flashAttrs(Map<String, Object> flashAttributes)",
    "source_code": "\tpublic B flashAttrs(Map<String, Object> flashAttributes) {\n\t\tAssert.notEmpty(flashAttributes, \"'flashAttributes' must not be empty\");\n\t\tflashAttributes.forEach(this::flashAttr);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#formField(name,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Append the given value(s) to the given form field and also add them to the\n\t * {@linkplain #param(String, String...) request parameters} map.\n\t * @param name the field name\n\t * @param values one or more values\n\t * @since 6.1.7\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 430
    },
    "return": "B",
    "signature": "public B formField(String name, String... values)",
    "source_code": "\tpublic B formField(String name, String... values) {\n\t\tparam(name, values);\n\t\tthis.formFields.addAll(name, Arrays.asList(values));\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#formFields(MultiValueMap<String,formFields)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #formField(String, String...)} with a {@link MultiValueMap}.\n\t * @param formFields the form fields to add\n\t * @since 6.1.7\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "formFields"
    ],
    "position": {
      "column": 1,
      "line": 441
    },
    "return": "B",
    "signature": "public B formFields(MultiValueMap<String, String> formFields)",
    "source_code": "\tpublic B formFields(MultiValueMap<String, String> formFields) {\n\t\tparams(formFields);\n\t\tthis.formFields.addAll(formFields);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#getBody()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 906
    },
    "return": "InputStream",
    "signature": "public InputStream getBody()",
    "source_code": "\t\t\tpublic InputStream getBody() {\n\t\t\t\tbyte[] bodyContent = AbstractMockHttpServletRequestBuilder.this.content;\n\t\t\t\treturn (bodyContent != null ? new ByteArrayInputStream(bodyContent) : InputStream.nullInputStream());\n\t\t\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#getHeaders()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 911
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders getHeaders()",
    "source_code": "\t\t\tpublic HttpHeaders getHeaders() {\n\t\t\t\tHttpHeaders headers = new HttpHeaders();\n\t\t\t\theaders.setContentType(mediaType);\n\t\t\t\treturn headers;\n\t\t\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#header(name,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a header to the request. Values are always added.\n\t * @param name the header name\n\t * @param values one or more header values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "B",
    "signature": "public B header(String name, Object... values)",
    "source_code": "\tpublic B header(String name, Object... values) {\n\t\taddToMultiValueMap(this.headers, name, values);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#headers(httpHeaders)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add all headers to the request. Values are always added.\n\t * @param httpHeaders the headers and values to add\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "httpHeaders"
    ],
    "position": {
      "column": 1,
      "line": 356
    },
    "return": "B",
    "signature": "public B headers(HttpHeaders httpHeaders)",
    "source_code": "\tpublic B headers(HttpHeaders httpHeaders) {\n\t\thttpHeaders.forEach(this.headers::addAll);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#isMergeEnabled()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * @return always returns {@code true}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 585
    },
    "return": "boolean",
    "signature": "public boolean isMergeEnabled()",
    "source_code": "\tpublic boolean isMergeEnabled() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#locale(locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the locale of the request, overriding any previous locales.\n\t * @param locale the locale, or {@code null} to reset it\n\t * @see #locale(Locale...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 474
    },
    "return": "B",
    "signature": "public B locale(@Nullable Locale locale)",
    "source_code": "\tpublic B locale(@Nullable Locale locale) {\n\t\tthis.locales.clear();\n\t\tif (locale != null) {\n\t\t\tthis.locales.add(locale);\n\t\t}\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#locale(locales)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the specified locales as preferred request locales.\n\t * @param locales the locales to add\n\t * @since 4.3.6\n\t * @see #locale(Locale)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locales"
    ],
    "position": {
      "column": 1,
      "line": 463
    },
    "return": "B",
    "signature": "public B locale(Locale... locales)",
    "source_code": "\tpublic B locale(Locale... locales) {\n\t\tAssert.notEmpty(locales, \"'locales' must not be empty\");\n\t\tthis.locales.addAll(Arrays.asList(locales));\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#merge(parent)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Merges the properties of the \"parent\" RequestBuilder accepting values\n\t * only if not already set in \"this\" instance.\n\t * @param parent the parent {@code RequestBuilder} to inherit properties from\n\t * @return the result of the merge\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parent"
    ],
    "position": {
      "column": 1,
      "line": 596
    },
    "return": "Object",
    "signature": "public Object merge(@Nullable Object parent)",
    "source_code": "\tpublic Object merge(@Nullable Object parent) {\n\t\tif (parent == null) {\n\t\t\treturn this;\n\t\t}\n\t\tif (!(parent instanceof AbstractMockHttpServletRequestBuilder<?> parentBuilder)) {\n\t\t\tthrow new IllegalArgumentException(\"Cannot merge with [\" + parent.getClass().getName() + \"]\");\n\t\t}\n\t\tif (this.uri == null) {\n\t\t\tthis.uri = parentBuilder.uri;\n\t\t\tthis.uriTemplate = parentBuilder.uriTemplate;\n\t\t}\n\t\tif (!StringUtils.hasText(this.contextPath)) {\n\t\t\tthis.contextPath = parentBuilder.contextPath;\n\t\t}\n\t\tif (!StringUtils.hasText(this.servletPath)) {\n\t\t\tthis.servletPath = parentBuilder.servletPath;\n\t\t}\n\t\tif (\"\".equals(this.pathInfo)) {\n\t\t\tthis.pathInfo = parentBuilder.pathInfo;\n\t\t}\n\n\t\tif (this.secure == null) {\n\t\t\tthis.secure = parentBuilder.secure;\n\t\t}\n\t\tif (this.principal == null) {\n\t\t\tthis.principal = parentBuilder.principal;\n\t\t}\n\t\tif (this.session == null) {\n\t\t\tthis.session = parentBuilder.session;\n\t\t}\n\t\tif (this.remoteAddress == null) {\n\t\t\tthis.remoteAddress = parentBuilder.remoteAddress;\n\t\t}\n\n\t\tif (this.characterEncoding == null) {\n\t\t\tthis.characterEncoding = parentBuilder.characterEncoding;\n\t\t}\n\t\tif (this.content == null) {\n\t\t\tthis.content = parentBuilder.content;\n\t\t}\n\t\tif (this.contentType == null) {\n\t\t\tthis.contentType = parentBuilder.contentType;\n\t\t}\n\n\t\tfor (Map.Entry<String, List<Object>> entry : parentBuilder.headers.entrySet()) {\n\t\t\tString headerName = entry.getKey();\n\t\t\tif (!this.headers.containsKey(headerName)) {\n\t\t\t\tthis.headers.put(headerName, entry.getValue());\n\t\t\t}\n\t\t}\n\t\tfor (Map.Entry<String, List<String>> entry : parentBuilder.parameters.entrySet()) {\n\t\t\tString paramName = entry.getKey();\n\t\t\tif (!this.parameters.containsKey(paramName)) {\n\t\t\t\tthis.parameters.put(paramName, entry.getValue());\n\t\t\t}\n\t\t}\n\t\tfor (Map.Entry<String, List<String>> entry : parentBuilder.queryParams.entrySet()) {\n\t\t\tString paramName = entry.getKey();\n\t\t\tif (!this.queryParams.containsKey(paramName)) {\n\t\t\t\tthis.queryParams.put(paramName, entry.getValue());\n\t\t\t}\n\t\t}\n\t\tfor (Map.Entry<String, List<String>> entry : parentBuilder.formFields.entrySet()) {\n\t\t\tString paramName = entry.getKey();\n\t\t\tif (!this.formFields.containsKey(paramName)) {\n\t\t\t\tthis.formFields.put(paramName, entry.getValue());\n\t\t\t}\n\t\t}\n\t\tfor (Cookie cookie : parentBuilder.cookies) {\n\t\t\tif (!containsCookie(cookie)) {\n\t\t\t\tthis.cookies.add(cookie);\n\t\t\t}\n\t\t}\n\t\tfor (Locale locale : parentBuilder.locales) {\n\t\t\tif (!this.locales.contains(locale)) {\n\t\t\t\tthis.locales.add(locale);\n\t\t\t}\n\t\t}\n\n\t\tfor (Map.Entry<String, Object> entry : parentBuilder.requestAttributes.entrySet()) {\n\t\t\tString attributeName = entry.getKey();\n\t\t\tif (!this.requestAttributes.containsKey(attributeName)) {\n\t\t\t\tthis.requestAttributes.put(attributeName, entry.getValue());\n\t\t\t}\n\t\t}\n\t\tfor (Map.Entry<String, Object> entry : parentBuilder.sessionAttributes.entrySet()) {\n\t\t\tString attributeName = entry.getKey();\n\t\t\tif (!this.sessionAttributes.containsKey(attributeName)) {\n\t\t\t\tthis.sessionAttributes.put(attributeName, entry.getValue());\n\t\t\t}\n\t\t}\n\t\tfor (Map.Entry<String, Object> entry : parentBuilder.flashAttributes.entrySet()) {\n\t\t\tString attributeName = entry.getKey();\n\t\t\tif (!this.flashAttributes.containsKey(attributeName)) {\n\t\t\t\tthis.flashAttributes.put(attributeName, entry.getValue());\n\t\t\t}\n\t\t}\n\n\t\tthis.postProcessors.addAll(0, parentBuilder.postProcessors);\n\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#param(name,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a request parameter to {@link MockHttpServletRequest#getParameterMap()}.\n\t * <p>In the Servlet API, a request parameter may be parsed from the query\n\t * string and/or from the body of an {@code application/x-www-form-urlencoded}\n\t * request. This method simply adds to the request parameter map. You may\n\t * also use add Servlet request parameters by specifying the query or form\n\t * data through one of the following:\n\t * <ul>\n\t * <li>Supply a URL with a query to {@link MockMvcRequestBuilders}.\n\t * <li>Add query params via {@link #queryParam} or {@link #queryParams}.\n\t * <li>Provide {@link #content} with {@link #contentType}\n\t * {@code application/x-www-form-urlencoded}.\n\t * </ul>\n\t * @param name the parameter name\n\t * @param values one or more values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 377
    },
    "return": "B",
    "signature": "public B param(String name, String... values)",
    "source_code": "\tpublic B param(String name, String... values) {\n\t\taddToMultiValueMap(this.parameters, name, values);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#params(MultiValueMap<String,params)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #param(String, String...)} with a {@link MultiValueMap}.\n\t * @param params the parameters to add\n\t * @since 4.2.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 387
    },
    "return": "B",
    "signature": "public B params(MultiValueMap<String, String> params)",
    "source_code": "\tpublic B params(MultiValueMap<String, String> params) {\n\t\tparams.forEach((name, values) -> {\n\t\t\tfor (String value : values) {\n\t\t\t\tthis.parameters.add(name, value);\n\t\t\t}\n\t\t});\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#pathInfo(pathInfo)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the portion of the requestURI that represents the pathInfo.\n\t * <p>If left unspecified (recommended), the pathInfo will be automatically derived\n\t * by removing the contextPath and the servletPath from the requestURI and using any\n\t * remaining part. If specified here, the pathInfo must start with a \"/\".\n\t * <p>If specified, the pathInfo will be used as-is.\n\t * @see jakarta.servlet.http.HttpServletRequest#getPathInfo()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pathInfo"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "B",
    "signature": "public B pathInfo(@Nullable String pathInfo)",
    "source_code": "\tpublic B pathInfo(@Nullable String pathInfo) {\n\t\tif (StringUtils.hasText(pathInfo)) {\n\t\t\tAssert.isTrue(pathInfo.startsWith(\"/\"), \"Path info must start with a '/'\");\n\t\t}\n\t\tthis.pathInfo = pathInfo;\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#postProcessRequest(request)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 940
    },
    "return": "MockHttpServletRequest",
    "signature": "public MockHttpServletRequest postProcessRequest(MockHttpServletRequest request)",
    "source_code": "\tpublic MockHttpServletRequest postProcessRequest(MockHttpServletRequest request) {\n\t\tfor (RequestPostProcessor postProcessor : this.postProcessors) {\n\t\t\trequest = postProcessor.postProcessRequest(request);\n\t\t}\n\t\treturn request;\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#principal(principal)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the principal of the request.\n\t * @param principal the principal\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "principal"
    ],
    "position": {
      "column": 1,
      "line": 548
    },
    "return": "B",
    "signature": "public B principal(Principal principal)",
    "source_code": "\tpublic B principal(Principal principal) {\n\t\tAssert.notNull(principal, \"'principal' must not be null\");\n\t\tthis.principal = principal;\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#queryParam(name,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Append to the query string and also add to the\n\t * {@link #param(String, String...) request parameters} map. The parameter\n\t * name and value are encoded when they are added to the query string.\n\t * @param name the parameter name\n\t * @param values one or more values\n\t * @since 5.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 404
    },
    "return": "B",
    "signature": "public B queryParam(String name, String... values)",
    "source_code": "\tpublic B queryParam(String name, String... values) {\n\t\tparam(name, values);\n\t\tthis.queryParams.addAll(name, Arrays.asList(values));\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#queryParams(MultiValueMap<String,params)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Append to the query string and also add to the\n\t * {@link #params(MultiValueMap) request parameters} map. The parameter\n\t * name and value are encoded when they are added to the query string.\n\t * @param params the parameters to add\n\t * @since 5.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 417
    },
    "return": "B",
    "signature": "public B queryParams(MultiValueMap<String, String> params)",
    "source_code": "\tpublic B queryParams(MultiValueMap<String, String> params) {\n\t\tparams(params);\n\t\tthis.queryParams.addAll(params);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#remoteAddress(remoteAddress)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the remote address of the request.\n\t * @param remoteAddress the remote address (IP)\n\t * @since 6.0.10\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "remoteAddress"
    ],
    "position": {
      "column": 1,
      "line": 559
    },
    "return": "B",
    "signature": "public B remoteAddress(String remoteAddress)",
    "source_code": "\tpublic B remoteAddress(String remoteAddress) {\n\t\tAssert.hasText(remoteAddress, \"'remoteAddress' must not be null or blank\");\n\t\tthis.remoteAddress = remoteAddress;\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#requestAttr(name,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a request attribute.\n\t * @param name the attribute name\n\t * @param value the attribute value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 487
    },
    "return": "B",
    "signature": "public B requestAttr(String name, Object value)",
    "source_code": "\tpublic B requestAttr(String name, Object value) {\n\t\taddToMap(this.requestAttributes, name, value);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#secure(secure)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the secure property of the {@link ServletRequest} indicating use of a\n\t * secure channel, such as HTTPS.\n\t * @param secure whether the request is using a secure channel\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "secure"
    ],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "B",
    "signature": "public B secure(boolean secure)",
    "source_code": "\tpublic B secure(boolean secure){\n\t\tthis.secure = secure;\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#self()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "B",
    "signature": "protected B self()",
    "source_code": "\tprotected B self() {\n\t\treturn (B) this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#servletPath(servletPath)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the portion of the requestURI that represents the path to which\n\t * the Servlet is mapped. This is typically a portion of the requestURI\n\t * after the context path.\n\t * <p>In most cases, tests can be written by omitting the servlet path from\n\t * the requestURI. This is because most applications don't actually depend\n\t * on the prefix to which a servlet is mapped. For example if a Servlet is\n\t * mapped to {@code \"/main/*\"}, tests can be written with the requestURI\n\t * {@code \"/accounts/1\"} as opposed to {@code \"/main/accounts/1\"}.\n\t * If specified here, the servletPath must start with a \"/\" and must not\n\t * end with a \"/\".\n\t * @see jakarta.servlet.http.HttpServletRequest#getServletPath()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletPath"
    ],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "B",
    "signature": "public B servletPath(String servletPath)",
    "source_code": "\tpublic B servletPath(String servletPath) {\n\t\tif (StringUtils.hasText(servletPath)) {\n\t\t\tAssert.isTrue(servletPath.startsWith(\"/\"), \"Servlet path must start with a '/'\");\n\t\t\tAssert.isTrue(!servletPath.endsWith(\"/\"), \"Servlet path must not end with a '/'\");\n\t\t}\n\t\tthis.servletPath = servletPath;\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#session(session)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the HTTP session to use, possibly re-used across requests.\n\t * <p>Individual attributes provided via {@link #sessionAttr(String, Object)}\n\t * override the content of the session provided here.\n\t * @param session the HTTP session\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 538
    },
    "return": "B",
    "signature": "public B session(MockHttpSession session)",
    "source_code": "\tpublic B session(MockHttpSession session) {\n\t\tAssert.notNull(session, \"'session' must not be null\");\n\t\tthis.session = session;\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#sessionAttr(name,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a session attribute.\n\t * @param name the session attribute name\n\t * @param value the session attribute value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 497
    },
    "return": "B",
    "signature": "public B sessionAttr(String name, Object value)",
    "source_code": "\tpublic B sessionAttr(String name, Object value) {\n\t\taddToMap(this.sessionAttributes, name, value);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#sessionAttrs(Map<String,sessionAttributes)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set session attributes.\n\t * @param sessionAttributes the session attributes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "sessionAttributes"
    ],
    "position": {
      "column": 1,
      "line": 506
    },
    "return": "B",
    "signature": "public B sessionAttrs(Map<String, Object> sessionAttributes)",
    "source_code": "\tpublic B sessionAttrs(Map<String, Object> sessionAttributes) {\n\t\tAssert.notEmpty(sessionAttributes, \"'sessionAttributes' must not be empty\");\n\t\tsessionAttributes.forEach(this::sessionAttr);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#uri(uri)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the URI using an absolute, fully constructed {@link java.net.URI}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uri"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "B",
    "signature": "public B uri(URI uri)",
    "source_code": "\tpublic B uri(URI uri) {\n\t\treturn updateUri(uri, null);\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#uri(uriTemplate,uriVariables)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the URI for the request using a URI template and URI variables.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "B",
    "signature": "public B uri(String uriTemplate, Object... uriVariables)",
    "source_code": "\tpublic B uri(String uriTemplate, Object... uriVariables) {\n\t\treturn updateUri(initUri(uriTemplate, uriVariables), uriTemplate);\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#with(postProcessor)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * An extension point for further initialization of {@link MockHttpServletRequest}\n\t * in ways not built directly into the {@code MockHttpServletRequestBuilder}.\n\t * Implementation of this interface can have builder-style methods themselves\n\t * and be made accessible through static factory methods.\n\t * @param postProcessor a post-processor to add\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 573
    },
    "return": "B",
    "signature": "public B with(RequestPostProcessor postProcessor)",
    "source_code": "\tpublic B with(RequestPostProcessor postProcessor) {\n\t\tAssert.notNull(postProcessor, \"postProcessor is required\");\n\t\tthis.postProcessors.add(postProcessor);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockMultipartHttpServletRequestBuilder": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Base builder for {@link MockMultipartHttpServletRequest}.\n *\n * @author Rossen Stoyanchev\n * @author Arjen Poutsma\n * @author Stephane Nicoll\n * @since 6.2\n * @param <B> a self reference to the builder type\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "public class AbstractMockMultipartHttpServletRequestBuilder",
    "source_code": "public abstract class AbstractMockMultipartHttpServletRequestBuilder<B extends AbstractMockMultipartHttpServletRequestBuilder<B>>"
  },
  "org.springframework.test.web.servlet.request.AbstractMockMultipartHttpServletRequestBuilder#createServletRequest(servletContext)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link MockMultipartHttpServletRequest} based on the\n\t * supplied {@code ServletContext} and the {@code MockMultipartFiles}\n\t * added to this builder.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "MockHttpServletRequest",
    "signature": "protected MockHttpServletRequest createServletRequest(ServletContext servletContext)",
    "source_code": "\tprotected final MockHttpServletRequest createServletRequest(ServletContext servletContext) {\n\t\tMockMultipartHttpServletRequest request = new MockMultipartHttpServletRequest(servletContext);\n\t\tCharset defaultCharset = (request.getCharacterEncoding() != null ?\n\t\t\t\tCharset.forName(request.getCharacterEncoding()) : StandardCharsets.UTF_8);\n\n\t\tthis.files.forEach(request::addFile);\n\t\tthis.parts.values().stream().flatMap(Collection::stream).forEach(part -> {\n\t\t\trequest.addPart(part);\n\t\t\ttry {\n\t\t\t\tString name = part.getName();\n\t\t\t\tString filename = part.getSubmittedFileName();\n\t\t\t\tInputStream is = part.getInputStream();\n\t\t\t\tif (filename != null) {\n\t\t\t\t\trequest.addFile(new MockMultipartFile(name, filename, part.getContentType(), is));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tInputStreamReader reader = new InputStreamReader(is, getCharsetOrDefault(part, defaultCharset));\n\t\t\t\t\tString value = FileCopyUtils.copyToString(reader);\n\t\t\t\t\trequest.addParameter(part.getName(), value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new IllegalStateException(\"Failed to read content for part \" + part.getName(), ex);\n\t\t\t}\n\t\t});\n\n\t\treturn request;\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockMultipartHttpServletRequestBuilder#file(file)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given {@link MockMultipartFile}.\n\t * @param file the multipart file\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "file"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "B",
    "signature": "public B file(MockMultipartFile file)",
    "source_code": "\tpublic B file(MockMultipartFile file) {\n\t\tthis.files.add(file);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockMultipartHttpServletRequestBuilder#file(name,content)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a new {@link MockMultipartFile} with the given content.\n\t * @param name the name of the file\n\t * @param content the content of the file\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "content"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "B",
    "signature": "public B file(String name, byte[] content)",
    "source_code": "\tpublic B file(String name, byte[] content) {\n\t\tthis.files.add(new MockMultipartFile(name, content));\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockMultipartHttpServletRequestBuilder#merge(parent)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parent"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "Object",
    "signature": "public Object merge(@Nullable Object parent)",
    "source_code": "\tpublic Object merge(@Nullable Object parent) {\n\t\tif (parent == null) {\n\t\t\treturn this;\n\t\t}\n\t\tif (parent instanceof AbstractMockHttpServletRequestBuilder<?>) {\n\t\t\tsuper.merge(parent);\n\t\t\tif (parent instanceof AbstractMockMultipartHttpServletRequestBuilder<?> parentBuilder) {\n\t\t\t\tthis.files.addAll(parentBuilder.files);\n\t\t\t\tparentBuilder.parts.keySet().forEach(name ->\n\t\t\t\t\t\tthis.parts.putIfAbsent(name, parentBuilder.parts.get(name)));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Cannot merge with [\" + parent.getClass().getName() + \"]\");\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockMultipartHttpServletRequestBuilder#part(parts)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add {@link Part} components to the request.\n\t * @param parts one or more parts to add\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parts"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "B",
    "signature": "public B part(Part... parts)",
    "source_code": "\tpublic B part(Part... parts) {\n\t\tAssert.notEmpty(parts, \"'parts' must not be empty\");\n\t\tfor (Part part : parts) {\n\t\t\tthis.parts.add(part.getName(), part);\n\t\t}\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Default builder for {@link MockHttpServletRequest} required as input to\n * perform requests in {@link MockMvc}.\n *\n * <p>Application tests will typically access this builder through the static\n * factory methods in {@link MockMvcRequestBuilders}.\n *\n * <p>This class is not open for extension. To apply custom initialization to\n * the created {@code MockHttpServletRequest}, please use the\n * {@link #with(RequestPostProcessor)} extension point.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Arjen Poutsma\n * @author Sam Brannen\n * @author Kamill Sokol\n * @since 3.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "signature": "public class MockHttpServletRequestBuilder",
    "source_code": "public class MockHttpServletRequestBuilder"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#accept(mediaTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@code Accept} header using raw String values, possibly not even\n\t * well-formed (for testing purposes).\n\t * @param mediaTypes one or more media types; internally joined as\n\t * comma-separated String\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mediaTypes"
    ],
    "position": {
      "column": 1,
      "line": 343
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder accept(String... mediaTypes)",
    "source_code": "\tpublic MockHttpServletRequestBuilder accept(String... mediaTypes) {\n\t\tAssert.notEmpty(mediaTypes, \"'mediaTypes' must not be empty\");\n\t\tthis.headers.set(\"Accept\", String.join(\", \", mediaTypes));\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#buildRequest(servletContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@link MockHttpServletRequest}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 715
    },
    "return": "MockHttpServletRequest",
    "signature": "public MockHttpServletRequest buildRequest(ServletContext servletContext)",
    "source_code": "\tpublic final MockHttpServletRequest buildRequest(ServletContext servletContext) {\n\t\tMockHttpServletRequest request = createServletRequest(servletContext);\n\n\t\trequest.setAsyncSupported(true);\n\t\trequest.setMethod(this.method);\n\n\t\tString requestUri = this.url.getRawPath();\n\t\trequest.setRequestURI(requestUri);\n\n\t\tif (this.url.getScheme() != null) {\n\t\t\trequest.setScheme(this.url.getScheme());\n\t\t}\n\t\tif (this.url.getHost() != null) {\n\t\t\trequest.setServerName(this.url.getHost());\n\t\t}\n\t\tif (this.url.getPort() != -1) {\n\t\t\trequest.setServerPort(this.url.getPort());\n\t\t}\n\n\t\tupdatePathRequestProperties(request, requestUri);\n\n\t\tif (this.secure != null) {\n\t\t\trequest.setSecure(this.secure);\n\t\t}\n\t\tif (this.principal != null) {\n\t\t\trequest.setUserPrincipal(this.principal);\n\t\t}\n\t\tif (this.remoteAddress != null) {\n\t\t\trequest.setRemoteAddr(this.remoteAddress);\n\t\t}\n\t\tif (this.session != null) {\n\t\t\trequest.setSession(this.session);\n\t\t}\n\n\t\trequest.setCharacterEncoding(this.characterEncoding);\n\t\trequest.setContent(this.content);\n\t\trequest.setContentType(this.contentType);\n\n\t\tthis.headers.forEach((name, values) -> {\n\t\t\tfor (Object value : values) {\n\t\t\t\trequest.addHeader(name, value);\n\t\t\t}\n\t\t});\n\n\t\tif (!ObjectUtils.isEmpty(this.content) &&\n\t\t\t\t!this.headers.containsKey(HttpHeaders.CONTENT_LENGTH) &&\n\t\t\t\t!this.headers.containsKey(HttpHeaders.TRANSFER_ENCODING)) {\n\n\t\t\trequest.addHeader(HttpHeaders.CONTENT_LENGTH, this.content.length);\n\t\t}\n\n\t\tString query = this.url.getRawQuery();\n\t\tif (!this.queryParams.isEmpty()) {\n\t\t\tString str = UriComponentsBuilder.newInstance().queryParams(this.queryParams).build().encode().getQuery();\n\t\t\tquery = StringUtils.hasLength(query) ? (query + \"&\" + str) : str;\n\t\t}\n\t\tif (query != null) {\n\t\t\trequest.setQueryString(query);\n\t\t}\n\t\taddRequestParams(request, UriComponentsBuilder.fromUri(this.url).build().getQueryParams());\n\n\t\tthis.parameters.forEach((name, values) -> {\n\t\t\tfor (String value : values) {\n\t\t\t\trequest.addParameter(name, value);\n\t\t\t}\n\t\t});\n\n\t\tif (!this.formFields.isEmpty()) {\n\t\t\tif (this.content != null && this.content.length > 0) {\n\t\t\t\tthrow new IllegalStateException(\"Could not write form data with an existing body\");\n\t\t\t}\n\t\t\tCharset charset = (this.characterEncoding != null ?\n\t\t\t\t\tCharset.forName(this.characterEncoding) : StandardCharsets.UTF_8);\n\t\t\tMediaType mediaType = (request.getContentType() != null ?\n\t\t\t\t\tMediaType.parseMediaType(request.getContentType()) :\n\t\t\t\t\tnew MediaType(MediaType.APPLICATION_FORM_URLENCODED, charset));\n\t\t\tif (!mediaType.isCompatibleWith(MediaType.APPLICATION_FORM_URLENCODED)) {\n\t\t\t\tthrow new IllegalStateException(\"Invalid content type: '\" + mediaType +\n\t\t\t\t\t\t\"' is not compatible with '\" + MediaType.APPLICATION_FORM_URLENCODED + \"'\");\n\t\t\t}\n\t\t\trequest.setContent(writeFormData(mediaType, charset));\n\t\t\tif (request.getContentType() == null) {\n\t\t\t\trequest.setContentType(mediaType.toString());\n\t\t\t}\n\t\t}\n\t\tif (this.content != null && this.content.length > 0) {\n\t\t\tString requestContentType = request.getContentType();\n\t\t\tif (requestContentType != null) {\n\t\t\t\ttry {\n\t\t\t\t\tMediaType mediaType = MediaType.parseMediaType(requestContentType);\n\t\t\t\t\tif (MediaType.APPLICATION_FORM_URLENCODED.includes(mediaType)) {\n\t\t\t\t\t\taddRequestParams(request, parseFormData(mediaType));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t// Must be invalid, ignore..\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!ObjectUtils.isEmpty(this.cookies)) {\n\t\t\trequest.setCookies(this.cookies.toArray(new Cookie[0]));\n\t\t}\n\t\tif (!ObjectUtils.isEmpty(this.locales)) {\n\t\t\trequest.setPreferredLocales(this.locales);\n\t\t}\n\n\t\tthis.requestAttributes.forEach(request::setAttribute);\n\t\tthis.sessionAttributes.forEach((name, attribute) -> {\n\t\t\tHttpSession session = request.getSession();\n\t\t\tAssert.state(session != null, \"No HttpSession\");\n\t\t\tsession.setAttribute(name, attribute);\n\t\t});\n\n\t\tFlashMap flashMap = new FlashMap();\n\t\tflashMap.putAll(this.flashAttributes);\n\t\tFlashMapManager flashMapManager = getFlashMapManager(request);\n\t\tflashMapManager.saveOutputFlashMap(flashMap, request, new MockHttpServletResponse());\n\n\t\treturn request;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#characterEncoding(encoding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the character encoding of the request.\n\t * @param encoding the character encoding\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 270
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder characterEncoding(String encoding)",
    "source_code": "\tpublic MockHttpServletRequestBuilder characterEncoding(String encoding) {\n\t\tthis.characterEncoding = encoding;\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#content(content)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the request body as a UTF-8 String.\n\t * <p>If content is provided and {@link #contentType(MediaType)} is set to\n\t * {@code application/x-www-form-urlencoded}, the content will be parsed\n\t * and used to populate the {@link #param(String, String...) request\n\t * parameters} map.\n\t * @param content the body content\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder content(String content)",
    "source_code": "\tpublic MockHttpServletRequestBuilder content(String content) {\n\t\tthis.content = content.getBytes(StandardCharsets.UTF_8);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#contentType(contentType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the 'Content-Type' header of the request as a raw String value,\n\t * possibly not even well-formed (for testing purposes).\n\t * @param contentType the content type\n\t * @since 4.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 321
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder contentType(String contentType)",
    "source_code": "\tpublic MockHttpServletRequestBuilder contentType(String contentType) {\n\t\tAssert.notNull(contentType, \"'contentType' must not be null\");\n\t\tthis.contentType = contentType;\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#contextPath(contextPath)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the portion of the requestURI that represents the context path.\n\t * The context path, if specified, must match to the start of the request URI.\n\t * <p>In most cases, tests can be written by omitting the context path from\n\t * the requestURI. This is because most applications don't actually depend\n\t * on the name under which they're deployed. If specified here, the context\n\t * path must start with a \"/\" and must not end with a \"/\".\n\t * @see jakarta.servlet.http.HttpServletRequest#getContextPath()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contextPath"
    ],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder contextPath(String contextPath)",
    "source_code": "\tpublic MockHttpServletRequestBuilder contextPath(String contextPath) {\n\t\tif (StringUtils.hasText(contextPath)) {\n\t\t\tAssert.isTrue(contextPath.startsWith(\"/\"), \"Context path must start with a '/'\");\n\t\t\tAssert.isTrue(!contextPath.endsWith(\"/\"), \"Context path must not end with a '/'\");\n\t\t}\n\t\tthis.contextPath = contextPath;\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#cookie(cookies)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given cookies to the request. Cookies are always added.\n\t * @param cookies the cookies to add\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cookies"
    ],
    "position": {
      "column": 1,
      "line": 458
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder cookie(Cookie... cookies)",
    "source_code": "\tpublic MockHttpServletRequestBuilder cookie(Cookie... cookies) {\n\t\tAssert.notEmpty(cookies, \"'cookies' must not be empty\");\n\t\tthis.cookies.addAll(Arrays.asList(cookies));\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#createServletRequest(servletContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link MockHttpServletRequest} based on the supplied\n\t * {@code ServletContext}.\n\t * <p>Can be overridden in subclasses.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 842
    },
    "return": "MockHttpServletRequest",
    "signature": "protected MockHttpServletRequest createServletRequest(ServletContext servletContext)",
    "source_code": "\tprotected MockHttpServletRequest createServletRequest(ServletContext servletContext) {\n\t\treturn new MockHttpServletRequest(servletContext);\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#flashAttr(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set an \"input\" flash attribute.\n\t * @param name the flash attribute name\n\t * @param value the flash attribute value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 524
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder flashAttr(String name, Object value)",
    "source_code": "\tpublic MockHttpServletRequestBuilder flashAttr(String name, Object value) {\n\t\taddToMap(this.flashAttributes, name, value);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#flashAttrs(Map<String,flashAttributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set flash attributes.\n\t * @param flashAttributes the flash attributes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "flashAttributes"
    ],
    "position": {
      "column": 1,
      "line": 533
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder flashAttrs(Map<String, Object> flashAttributes)",
    "source_code": "\tpublic MockHttpServletRequestBuilder flashAttrs(Map<String, Object> flashAttributes) {\n\t\tAssert.notEmpty(flashAttributes, \"'flashAttributes' must not be empty\");\n\t\tflashAttributes.forEach(this::flashAttr);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#formField(name,values)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Append the given value(s) to the given form field and also add them to the\n\t * {@linkplain #param(String, String...) request parameters} map.\n\t * @param name the field name\n\t * @param values one or more values\n\t * @since 6.1.7\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 437
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder formField(String name, String... values)",
    "source_code": "\tpublic MockHttpServletRequestBuilder formField(String name, String... values) {\n\t\tparam(name, values);\n\t\tthis.formFields.addAll(name, Arrays.asList(values));\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#formFields(MultiValueMap<String,formFields)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #formField(String, String...)} with a {@link MultiValueMap}.\n\t * @param formFields the form fields to add\n\t * @since 6.1.7\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "formFields"
    ],
    "position": {
      "column": 1,
      "line": 448
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder formFields(MultiValueMap<String, String> formFields)",
    "source_code": "\tpublic MockHttpServletRequestBuilder formFields(MultiValueMap<String, String> formFields) {\n\t\tparams(formFields);\n\t\tthis.formFields.addAll(formFields);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#getBody()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 905
    },
    "return": "InputStream",
    "signature": "public InputStream getBody()",
    "source_code": "\t\t\tpublic InputStream getBody() {\n\t\t\t\treturn (content != null ? new ByteArrayInputStream(content) : InputStream.nullInputStream());\n\t\t\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#getHeaders()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 909
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders getHeaders()",
    "source_code": "\t\t\tpublic HttpHeaders getHeaders() {\n\t\t\t\tHttpHeaders headers = new HttpHeaders();\n\t\t\t\theaders.setContentType(mediaType);\n\t\t\t\treturn headers;\n\t\t\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#header(name,values)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a header to the request. Values are always added.\n\t * @param name the header name\n\t * @param values one or more header values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 354
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder header(String name, Object... values)",
    "source_code": "\tpublic MockHttpServletRequestBuilder header(String name, Object... values) {\n\t\taddToMultiValueMap(this.headers, name, values);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#headers(httpHeaders)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add all headers to the request. Values are always added.\n\t * @param httpHeaders the headers and values to add\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "httpHeaders"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder headers(HttpHeaders httpHeaders)",
    "source_code": "\tpublic MockHttpServletRequestBuilder headers(HttpHeaders httpHeaders) {\n\t\thttpHeaders.forEach(this.headers::addAll);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#isMergeEnabled()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * @return always returns {@code true}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 592
    },
    "return": "boolean",
    "signature": "public boolean isMergeEnabled()",
    "source_code": "\tpublic boolean isMergeEnabled() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#locale(locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the locale of the request, overriding any previous locales.\n\t * @param locale the locale, or {@code null} to reset it\n\t * @see #locale(Locale...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 481
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder locale(@Nullable Locale locale)",
    "source_code": "\tpublic MockHttpServletRequestBuilder locale(@Nullable Locale locale) {\n\t\tthis.locales.clear();\n\t\tif (locale != null) {\n\t\t\tthis.locales.add(locale);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#locale(locales)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the specified locales as preferred request locales.\n\t * @param locales the locales to add\n\t * @since 4.3.6\n\t * @see #locale(Locale)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locales"
    ],
    "position": {
      "column": 1,
      "line": 470
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder locale(Locale... locales)",
    "source_code": "\tpublic MockHttpServletRequestBuilder locale(Locale... locales) {\n\t\tAssert.notEmpty(locales, \"'locales' must not be empty\");\n\t\tthis.locales.addAll(Arrays.asList(locales));\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#merge(parent)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Merges the properties of the \"parent\" RequestBuilder accepting values\n\t * only if not already set in \"this\" instance.\n\t * @param parent the parent {@code RequestBuilder} to inherit properties from\n\t * @return the result of the merge\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parent"
    ],
    "position": {
      "column": 1,
      "line": 603
    },
    "return": "Object",
    "signature": "public Object merge(@Nullable Object parent)",
    "source_code": "\tpublic Object merge(@Nullable Object parent) {\n\t\tif (parent == null) {\n\t\t\treturn this;\n\t\t}\n\t\tif (!(parent instanceof MockHttpServletRequestBuilder parentBuilder)) {\n\t\t\tthrow new IllegalArgumentException(\"Cannot merge with [\" + parent.getClass().getName() + \"]\");\n\t\t}\n\t\tif (!StringUtils.hasText(this.contextPath)) {\n\t\t\tthis.contextPath = parentBuilder.contextPath;\n\t\t}\n\t\tif (!StringUtils.hasText(this.servletPath)) {\n\t\t\tthis.servletPath = parentBuilder.servletPath;\n\t\t}\n\t\tif (\"\".equals(this.pathInfo)) {\n\t\t\tthis.pathInfo = parentBuilder.pathInfo;\n\t\t}\n\n\t\tif (this.secure == null) {\n\t\t\tthis.secure = parentBuilder.secure;\n\t\t}\n\t\tif (this.principal == null) {\n\t\t\tthis.principal = parentBuilder.principal;\n\t\t}\n\t\tif (this.session == null) {\n\t\t\tthis.session = parentBuilder.session;\n\t\t}\n\t\tif (this.remoteAddress == null) {\n\t\t\tthis.remoteAddress = parentBuilder.remoteAddress;\n\t\t}\n\n\t\tif (this.characterEncoding == null) {\n\t\t\tthis.characterEncoding = parentBuilder.characterEncoding;\n\t\t}\n\t\tif (this.content == null) {\n\t\t\tthis.content = parentBuilder.content;\n\t\t}\n\t\tif (this.contentType == null) {\n\t\t\tthis.contentType = parentBuilder.contentType;\n\t\t}\n\n\t\tfor (Map.Entry<String, List<Object>> entry : parentBuilder.headers.entrySet()) {\n\t\t\tString headerName = entry.getKey();\n\t\t\tif (!this.headers.containsKey(headerName)) {\n\t\t\t\tthis.headers.put(headerName, entry.getValue());\n\t\t\t}\n\t\t}\n\t\tfor (Map.Entry<String, List<String>> entry : parentBuilder.parameters.entrySet()) {\n\t\t\tString paramName = entry.getKey();\n\t\t\tif (!this.parameters.containsKey(paramName)) {\n\t\t\t\tthis.parameters.put(paramName, entry.getValue());\n\t\t\t}\n\t\t}\n\t\tfor (Map.Entry<String, List<String>> entry : parentBuilder.queryParams.entrySet()) {\n\t\t\tString paramName = entry.getKey();\n\t\t\tif (!this.queryParams.containsKey(paramName)) {\n\t\t\t\tthis.queryParams.put(paramName, entry.getValue());\n\t\t\t}\n\t\t}\n\t\tfor (Map.Entry<String, List<String>> entry : parentBuilder.formFields.entrySet()) {\n\t\t\tString paramName = entry.getKey();\n\t\t\tif (!this.formFields.containsKey(paramName)) {\n\t\t\t\tthis.formFields.put(paramName, entry.getValue());\n\t\t\t}\n\t\t}\n\t\tfor (Cookie cookie : parentBuilder.cookies) {\n\t\t\tif (!containsCookie(cookie)) {\n\t\t\t\tthis.cookies.add(cookie);\n\t\t\t}\n\t\t}\n\t\tfor (Locale locale : parentBuilder.locales) {\n\t\t\tif (!this.locales.contains(locale)) {\n\t\t\t\tthis.locales.add(locale);\n\t\t\t}\n\t\t}\n\n\t\tfor (Map.Entry<String, Object> entry : parentBuilder.requestAttributes.entrySet()) {\n\t\t\tString attributeName = entry.getKey();\n\t\t\tif (!this.requestAttributes.containsKey(attributeName)) {\n\t\t\t\tthis.requestAttributes.put(attributeName, entry.getValue());\n\t\t\t}\n\t\t}\n\t\tfor (Map.Entry<String, Object> entry : parentBuilder.sessionAttributes.entrySet()) {\n\t\t\tString attributeName = entry.getKey();\n\t\t\tif (!this.sessionAttributes.containsKey(attributeName)) {\n\t\t\t\tthis.sessionAttributes.put(attributeName, entry.getValue());\n\t\t\t}\n\t\t}\n\t\tfor (Map.Entry<String, Object> entry : parentBuilder.flashAttributes.entrySet()) {\n\t\t\tString attributeName = entry.getKey();\n\t\t\tif (!this.flashAttributes.containsKey(attributeName)) {\n\t\t\t\tthis.flashAttributes.put(attributeName, entry.getValue());\n\t\t\t}\n\t\t}\n\n\t\tthis.postProcessors.addAll(0, parentBuilder.postProcessors);\n\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#param(name,values)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a request parameter to {@link MockHttpServletRequest#getParameterMap()}.\n\t * <p>In the Servlet API, a request parameter may be parsed from the query\n\t * string and/or from the body of an {@code application/x-www-form-urlencoded}\n\t * request. This method simply adds to the request parameter map. You may\n\t * also use add Servlet request parameters by specifying the query or form\n\t * data through one of the following:\n\t * <ul>\n\t * <li>Supply a URL with a query to {@link MockMvcRequestBuilders}.\n\t * <li>Add query params via {@link #queryParam} or {@link #queryParams}.\n\t * <li>Provide {@link #content} with {@link #contentType}\n\t * {@code application/x-www-form-urlencoded}.\n\t * </ul>\n\t * @param name the parameter name\n\t * @param values one or more values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder param(String name, String... values)",
    "source_code": "\tpublic MockHttpServletRequestBuilder param(String name, String... values) {\n\t\taddToMultiValueMap(this.parameters, name, values);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#params(MultiValueMap<String,params)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #param(String, String...)} with a {@link MultiValueMap}.\n\t * @param params the parameters to add\n\t * @since 4.2.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 394
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder params(MultiValueMap<String, String> params)",
    "source_code": "\tpublic MockHttpServletRequestBuilder params(MultiValueMap<String, String> params) {\n\t\tparams.forEach((name, values) -> {\n\t\t\tfor (String value : values) {\n\t\t\t\tthis.parameters.add(name, value);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#pathInfo(pathInfo)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the portion of the requestURI that represents the pathInfo.\n\t * <p>If left unspecified (recommended), the pathInfo will be automatically derived\n\t * by removing the contextPath and the servletPath from the requestURI and using any\n\t * remaining part. If specified here, the pathInfo must start with a \"/\".\n\t * <p>If specified, the pathInfo will be used as-is.\n\t * @see jakarta.servlet.http.HttpServletRequest#getPathInfo()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pathInfo"
    ],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder pathInfo(@Nullable String pathInfo)",
    "source_code": "\tpublic MockHttpServletRequestBuilder pathInfo(@Nullable String pathInfo) {\n\t\tif (StringUtils.hasText(pathInfo)) {\n\t\t\tAssert.isTrue(pathInfo.startsWith(\"/\"), \"Path info must start with a '/'\");\n\t\t}\n\t\tthis.pathInfo = pathInfo;\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#postProcessRequest(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 938
    },
    "return": "MockHttpServletRequest",
    "signature": "public MockHttpServletRequest postProcessRequest(MockHttpServletRequest request)",
    "source_code": "\tpublic MockHttpServletRequest postProcessRequest(MockHttpServletRequest request) {\n\t\tfor (RequestPostProcessor postProcessor : this.postProcessors) {\n\t\t\trequest = postProcessor.postProcessRequest(request);\n\t\t}\n\t\treturn request;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#principal(principal)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the principal of the request.\n\t * @param principal the principal\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "principal"
    ],
    "position": {
      "column": 1,
      "line": 555
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder principal(Principal principal)",
    "source_code": "\tpublic MockHttpServletRequestBuilder principal(Principal principal) {\n\t\tAssert.notNull(principal, \"'principal' must not be null\");\n\t\tthis.principal = principal;\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#queryParam(name,values)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Append to the query string and also add to the\n\t * {@link #param(String, String...) request parameters} map. The parameter\n\t * name and value are encoded when they are added to the query string.\n\t * @param name the parameter name\n\t * @param values one or more values\n\t * @since 5.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 411
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder queryParam(String name, String... values)",
    "source_code": "\tpublic MockHttpServletRequestBuilder queryParam(String name, String... values) {\n\t\tparam(name, values);\n\t\tthis.queryParams.addAll(name, Arrays.asList(values));\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#queryParams(MultiValueMap<String,params)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Append to the query string and also add to the\n\t * {@link #params(MultiValueMap) request parameters} map. The parameter\n\t * name and value are encoded when they are added to the query string.\n\t * @param params the parameters to add\n\t * @since 5.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 424
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder queryParams(MultiValueMap<String, String> params)",
    "source_code": "\tpublic MockHttpServletRequestBuilder queryParams(MultiValueMap<String, String> params) {\n\t\tparams(params);\n\t\tthis.queryParams.addAll(params);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#remoteAddress(remoteAddress)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the remote address of the request.\n\t * @param remoteAddress the remote address (IP)\n\t * @since 6.0.10\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "remoteAddress"
    ],
    "position": {
      "column": 1,
      "line": 566
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder remoteAddress(String remoteAddress)",
    "source_code": "\tpublic MockHttpServletRequestBuilder remoteAddress(String remoteAddress) {\n\t\tAssert.hasText(remoteAddress, \"'remoteAddress' must not be null or blank\");\n\t\tthis.remoteAddress = remoteAddress;\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#requestAttr(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a request attribute.\n\t * @param name the attribute name\n\t * @param value the attribute value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 494
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder requestAttr(String name, Object value)",
    "source_code": "\tpublic MockHttpServletRequestBuilder requestAttr(String name, Object value) {\n\t\taddToMap(this.requestAttributes, name, value);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#secure(secure)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the secure property of the {@link ServletRequest} indicating use of a\n\t * secure channel, such as HTTPS.\n\t * @param secure whether the request is using a secure channel\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "secure"
    ],
    "position": {
      "column": 1,
      "line": 250
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder secure(boolean secure)",
    "source_code": "\tpublic MockHttpServletRequestBuilder secure(boolean secure){\n\t\tthis.secure = secure;\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#servletPath(servletPath)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the portion of the requestURI that represents the path to which\n\t * the Servlet is mapped. This is typically a portion of the requestURI\n\t * after the context path.\n\t * <p>In most cases, tests can be written by omitting the servlet path from\n\t * the requestURI. This is because most applications don't actually depend\n\t * on the prefix to which a servlet is mapped. For example if a Servlet is\n\t * mapped to {@code \"/main/*\"}, tests can be written with the requestURI\n\t * {@code \"/accounts/1\"} as opposed to {@code \"/main/accounts/1\"}.\n\t * If specified here, the servletPath must start with a \"/\" and must not\n\t * end with a \"/\".\n\t * @see jakarta.servlet.http.HttpServletRequest#getServletPath()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletPath"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder servletPath(String servletPath)",
    "source_code": "\tpublic MockHttpServletRequestBuilder servletPath(String servletPath) {\n\t\tif (StringUtils.hasText(servletPath)) {\n\t\t\tAssert.isTrue(servletPath.startsWith(\"/\"), \"Servlet path must start with a '/'\");\n\t\t\tAssert.isTrue(!servletPath.endsWith(\"/\"), \"Servlet path must not end with a '/'\");\n\t\t}\n\t\tthis.servletPath = servletPath;\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#session(session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the HTTP session to use, possibly re-used across requests.\n\t * <p>Individual attributes provided via {@link #sessionAttr(String, Object)}\n\t * override the content of the session provided here.\n\t * @param session the HTTP session\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 545
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder session(MockHttpSession session)",
    "source_code": "\tpublic MockHttpServletRequestBuilder session(MockHttpSession session) {\n\t\tAssert.notNull(session, \"'session' must not be null\");\n\t\tthis.session = session;\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#sessionAttr(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a session attribute.\n\t * @param name the session attribute name\n\t * @param value the session attribute value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 504
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder sessionAttr(String name, Object value)",
    "source_code": "\tpublic MockHttpServletRequestBuilder sessionAttr(String name, Object value) {\n\t\taddToMap(this.sessionAttributes, name, value);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#sessionAttrs(Map<String,sessionAttributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set session attributes.\n\t * @param sessionAttributes the session attributes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "sessionAttributes"
    ],
    "position": {
      "column": 1,
      "line": 513
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder sessionAttrs(Map<String, Object> sessionAttributes)",
    "source_code": "\tpublic MockHttpServletRequestBuilder sessionAttrs(Map<String, Object> sessionAttributes) {\n\t\tAssert.notEmpty(sessionAttributes, \"'sessionAttributes' must not be empty\");\n\t\tsessionAttributes.forEach(this::sessionAttr);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#with(postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An extension point for further initialization of {@link MockHttpServletRequest}\n\t * in ways not built directly into the {@code MockHttpServletRequestBuilder}.\n\t * Implementation of this interface can have builder-style methods themselves\n\t * and be made accessible through static factory methods.\n\t * @param postProcessor a post-processor to add\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 580
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder with(RequestPostProcessor postProcessor)",
    "source_code": "\tpublic MockHttpServletRequestBuilder with(RequestPostProcessor postProcessor) {\n\t\tAssert.notNull(postProcessor, \"postProcessor is required\");\n\t\tthis.postProcessors.add(postProcessor);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#destroy()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "void",
    "signature": "public void destroy()",
    "source_code": "\tpublic void destroy() {\n\t\tthis.delegate.destroy();\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#doFilter(request,response,filterChain)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "filterChain"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "void",
    "signature": "public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)",
    "source_code": "\tpublic void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#init(filterConfig)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "filterConfig"
    ],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "void",
    "signature": "public void init(FilterConfig filterConfig)",
    "source_code": "\tpublic void init(FilterConfig filterConfig) throws ServletException {\n\t\tthis.delegate.init(filterConfig);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#initIfRequired(servletContext)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "void",
    "signature": "public void initIfRequired(@Nullable ServletContext servletContext)",
    "source_code": "\tpublic void initIfRequired(@Nullable ServletContext servletContext) throws ServletException {\n\t\tif (this.filterConfigInitializer != null) {\n\t\t\tFilterConfig filterConfig = this.filterConfigInitializer.apply(servletContext);\n\t\t\tthis.delegate.init(filterConfig);\n\t\t}\n\t}"
  },
  "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * A {@code MockMvcBuilder} that accepts {@link RouterFunction} registrations\n * thus allowing full control over the instantiation and initialization of\n * router functions and their dependencies similar to plain unit tests, and also\n * making it possible to test one function at a time.\n *\n * <p>This builder creates the minimum infrastructure required by the\n * {@link DispatcherServlet} to serve requests with router functions and\n * also provides methods for customization. The resulting configuration and\n * customization options are equivalent to using MVC Java config except\n * using builder style methods.\n *\n * <p>To configure view resolution, either select a \"fixed\" view to use for every\n * request performed (see {@link #setSingleView(View)}) or provide a list of\n * {@code ViewResolver}s (see {@link #setViewResolvers(ViewResolver...)}).\n *\n * @author Arjen Poutsma\n * @since 6.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "signature": "public class RouterFunctionMockMvcBuilder",
    "source_code": "public class RouterFunctionMockMvcBuilder extends AbstractMockMvcBuilder<RouterFunctionMockMvcBuilder> {\n\n\tprivate final RouterFunction<?> routerFunction;\n\n\tprivate List<HttpMessageConverter<?>> messageConverters = new ArrayList<>();\n\n\tprivate final List<MappedInterceptor> mappedInterceptors = new ArrayList<>();\n\n\t@Nullable\n\tprivate List<HandlerExceptionResolver> handlerExceptionResolvers;\n\n\t@Nullable\n\tprivate Long asyncRequestTimeout;\n\n\t@Nullable\n\tprivate List<ViewResolver> viewResolvers;\n\n\t@Nullable\n\tprivate PathPatternParser patternParser;\n\n\tprivate Supplier<RouterFunctionMapping> handlerMappingFactory = RouterFunctionMapping::new;\n\n\n\tprotected RouterFunctionMockMvcBuilder(RouterFunction<?>... routerFunctions) {\n\t\tAssert.notEmpty(routerFunctions, \"RouterFunctions must not be empty\");\n\n\t\tthis.routerFunction = Arrays.stream(routerFunctions).reduce(RouterFunction::andOther).orElseThrow();\n\t}\n\n\n\t/**\n\t * Set the message converters to use in argument resolvers and in return value\n\t * handlers, which support reading and/or writing to the body of the request\n\t * and response. If no message converters are added to the list, a default\n\t * list of converters is added instead.\n\t */\n\tpublic RouterFunctionMockMvcBuilder setMessageConverters(HttpMessageConverter<?>...messageConverters) {\n\t\tthis.messageConverters = Arrays.asList(messageConverters);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add interceptors mapped to all incoming requests.\n\t */\n\tpublic RouterFunctionMockMvcBuilder addInterceptors(HandlerInterceptor... interceptors) {\n\t\taddMappedInterceptors(null, interceptors);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add interceptors mapped to a set of path patterns.\n\t */\n\tpublic RouterFunctionMockMvcBuilder addMappedInterceptors(@Nullable String[] pathPatterns,\n\t\t\tHandlerInterceptor... interceptors) {\n\n\t\tfor (HandlerInterceptor interceptor : interceptors) {\n\t\t\tthis.mappedInterceptors.add(new MappedInterceptor(pathPatterns, null, interceptor));\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the HandlerExceptionResolver types to use as a list.\n\t */\n\tpublic RouterFunctionMockMvcBuilder setHandlerExceptionResolvers(List<HandlerExceptionResolver> exceptionResolvers) {\n\t\tthis.handlerExceptionResolvers = exceptionResolvers;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the HandlerExceptionResolver types to use as an array.\n\t */\n\tpublic RouterFunctionMockMvcBuilder setHandlerExceptionResolvers(HandlerExceptionResolver... exceptionResolvers) {\n\t\tthis.handlerExceptionResolvers = Arrays.asList(exceptionResolvers);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Configure the factory to create a custom {@link RequestMappingHandlerMapping}.\n\t * @param factory the factory\n\t */\n\tpublic RouterFunctionMockMvcBuilder setCustomHandlerMapping(Supplier<RouterFunctionMapping> factory) {\n\t\tthis.handlerMappingFactory = factory;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set up view resolution with the given {@link ViewResolver ViewResolvers}.\n\t * <p>If not set, an {@link InternalResourceViewResolver} is used by default.\n\t */\n\tpublic RouterFunctionMockMvcBuilder setViewResolvers(ViewResolver...resolvers) {\n\t\tthis.viewResolvers = Arrays.asList(resolvers);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set up a single {@link ViewResolver} that always returns the provided\n\t * view instance.\n\t * <p>This is a convenient shortcut if you need to use one {@link View}\n\t * instance only &mdash; for example, rendering generated content (JSON, XML,\n\t * Atom).\n\t */\n\tpublic RouterFunctionMockMvcBuilder setSingleView(View view) {\n\t\tthis.viewResolvers = Collections.singletonList(new StaticViewResolver(view));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Specify the timeout value for async execution.\n\t * <p>In Spring MVC Test, this value is used to determine how long to wait\n\t * for async execution to complete so that a test can verify the results\n\t * synchronously.\n\t * @param timeout the timeout value in milliseconds\n\t */\n\tpublic RouterFunctionMockMvcBuilder setAsyncRequestTimeout(long timeout) {\n\t\tthis.asyncRequestTimeout = timeout;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Enable URL path matching with parsed\n\t * {@link org.springframework.web.util.pattern.PathPattern PathPatterns}\n\t * instead of String pattern matching with a {@link org.springframework.util.PathMatcher}.\n\t * @param parser the parser to use\n\t */\n\tpublic RouterFunctionMockMvcBuilder setPatternParser(@Nullable PathPatternParser parser) {\n\t\tthis.patternParser = parser;\n\t\treturn this;\n\t}\n\n\n\t@Override\n\tprotected WebApplicationContext initWebAppContext() {\n\t\tMockServletContext servletContext = new MockServletContext();\n\t\tStubWebApplicationContext wac = new StubWebApplicationContext(servletContext);\n\t\tregisterRouterFunction(wac);\n\t\tservletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, wac);\n\t\treturn wac;\n\t}\n\n\tprivate void registerRouterFunction(StubWebApplicationContext wac) {\n\t\tHandlerFunctionConfiguration config = new HandlerFunctionConfiguration();\n\t\tconfig.setApplicationContext(wac);\n\t\tServletContext sc = wac.getServletContext();\n\n\t\twac.addBean(\"routerFunction\", this.routerFunction);\n\n\t\tFormattingConversionService mvcConversionService = config.mvcConversionService();\n\t\twac.addBean(\"mvcConversionService\", mvcConversionService);\n\t\tResourceUrlProvider resourceUrlProvider = config.mvcResourceUrlProvider();\n\t\twac.addBean(\"mvcResourceUrlProvider\", resourceUrlProvider);\n\t\tContentNegotiationManager mvcContentNegotiationManager = config.mvcContentNegotiationManager();\n\t\twac.addBean(\"mvcContentNegotiationManager\", mvcContentNegotiationManager);\n\n\t\tRouterFunctionMapping hm = config.getHandlerMapping(mvcConversionService, resourceUrlProvider);\n\t\tif (sc != null) {\n\t\t\thm.setServletContext(sc);\n\t\t}\n\t\thm.setApplicationContext(wac);\n\t\thm.afterPropertiesSet();\n\t\twac.addBean(\"routerFunctionMapping\", hm);\n\n\t\tHandlerFunctionAdapter ha = config.handlerFunctionAdapter();\n\t\twac.addBean(\"handlerFunctionAdapter\", ha);\n\n\t\twac.addBean(\"handlerExceptionResolver\", config.handlerExceptionResolver(mvcContentNegotiationManager));\n\n\t\twac.addBeans(initViewResolvers(wac));\n\t}\n\n\tprivate List<ViewResolver> initViewResolvers(WebApplicationContext wac) {\n\t\tthis.viewResolvers = (this.viewResolvers != null ? this.viewResolvers :\n\t\t\t\tCollections.singletonList(new InternalResourceViewResolver()));\n\t\tfor (Object viewResolver : this.viewResolvers) {\n\t\t\tif (viewResolver instanceof WebApplicationObjectSupport support) {\n\t\t\t\tsupport.setApplicationContext(wac);\n\t\t\t}\n\t\t}\n\t\treturn this.viewResolvers;\n\t}\n\n\n\t/** Using the MVC Java configuration as the starting point for the \"standalone\" setup. */\n\tprivate class HandlerFunctionConfiguration extends WebMvcConfigurationSupport {\n\n\t\tpublic RouterFunctionMapping getHandlerMapping(\n\t\t\t\tFormattingConversionService mvcConversionService,\n\t\t\t\tResourceUrlProvider mvcResourceUrlProvider) {\n\n\t\t\tRouterFunctionMapping handlerMapping = handlerMappingFactory.get();\n\t\t\thandlerMapping.setOrder(0);\n\t\t\thandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));\n\t\t\thandlerMapping.setMessageConverters(getMessageConverters());\n\t\t\tif (patternParser != null) {\n\t\t\t\thandlerMapping.setPatternParser(patternParser);\n\t\t\t}\n\t\t\treturn handlerMapping;\n\t\t}\n\n\t\t@Override\n\t\tprotected void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n\t\t\tconverters.addAll(messageConverters);\n\t\t}\n\n\t\t@Override\n\t\tprotected void addInterceptors(InterceptorRegistry registry) {\n\t\t\tfor (MappedInterceptor interceptor : mappedInterceptors) {\n\t\t\t\tInterceptorRegistration registration = registry.addInterceptor(interceptor.getInterceptor());\n\t\t\t\tif (interceptor.getIncludePathPatterns() != null) {\n\t\t\t\t\tregistration.addPathPatterns(interceptor.getIncludePathPatterns());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void configureAsyncSupport(AsyncSupportConfigurer configurer) {\n\t\t\tif (asyncRequestTimeout != null) {\n\t\t\t\tconfigurer.setDefaultTimeout(asyncRequestTimeout);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tprotected void configureHandlerExceptionResolvers(List<HandlerExceptionResolver> exceptionResolvers) {\n\t\t\tif (handlerExceptionResolvers == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (HandlerExceptionResolver resolver : handlerExceptionResolvers) {\n\t\t\t\tif (resolver instanceof ApplicationContextAware applicationContextAware) {\n\t\t\t\t\tApplicationContext applicationContext = getApplicationContext();\n\t\t\t\t\tif (applicationContext != null) {\n\t\t\t\t\t\tapplicationContextAware.setApplicationContext(applicationContext);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (resolver instanceof InitializingBean initializingBean) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tinitializingBean.afterPropertiesSet();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"Failure from afterPropertiesSet\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\texceptionResolvers.add(resolver);\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#addInterceptors(interceptors)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add interceptors mapped to all incoming requests.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "interceptors"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "RouterFunctionMockMvcBuilder",
    "signature": "public RouterFunctionMockMvcBuilder addInterceptors(HandlerInterceptor... interceptors)",
    "source_code": "\tpublic RouterFunctionMockMvcBuilder addInterceptors(HandlerInterceptor... interceptors) {\n\t\taddMappedInterceptors(null, interceptors);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#addInterceptors(registry)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "void",
    "signature": "protected void addInterceptors(InterceptorRegistry registry)",
    "source_code": "\t\tprotected void addInterceptors(InterceptorRegistry registry) {\n\t\t\tfor (MappedInterceptor interceptor : mappedInterceptors) {\n\t\t\t\tInterceptorRegistration registration = registry.addInterceptor(interceptor.getInterceptor());\n\t\t\t\tif (interceptor.getIncludePathPatterns() != null) {\n\t\t\t\t\tregistration.addPathPatterns(interceptor.getIncludePathPatterns());\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#addMappedInterceptors(pathPatterns,interceptors)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add interceptors mapped to a set of path patterns.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pathPatterns",
      "interceptors"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "RouterFunctionMockMvcBuilder",
    "signature": "public RouterFunctionMockMvcBuilder addMappedInterceptors(@Nullable String[] pathPatterns,\n\t\t\tHandlerInterceptor... interceptors)",
    "source_code": "\tpublic RouterFunctionMockMvcBuilder addMappedInterceptors(@Nullable String[] pathPatterns,"
  },
  "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#configureAsyncSupport(configurer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "configurer"
    ],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "void",
    "signature": "public void configureAsyncSupport(AsyncSupportConfigurer configurer)",
    "source_code": "\t\tpublic void configureAsyncSupport(AsyncSupportConfigurer configurer) {\n\t\t\tif (asyncRequestTimeout != null) {\n\t\t\t\tconfigurer.setDefaultTimeout(asyncRequestTimeout);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#configureHandlerExceptionResolvers(exceptionResolvers)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exceptionResolvers"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "void",
    "signature": "protected void configureHandlerExceptionResolvers(List<HandlerExceptionResolver> exceptionResolvers)",
    "source_code": "\t\tprotected void configureHandlerExceptionResolvers(List<HandlerExceptionResolver> exceptionResolvers) {\n\t\t\tif (handlerExceptionResolvers == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (HandlerExceptionResolver resolver : handlerExceptionResolvers) {\n\t\t\t\tif (resolver instanceof ApplicationContextAware applicationContextAware) {\n\t\t\t\t\tApplicationContext applicationContext = getApplicationContext();\n\t\t\t\t\tif (applicationContext != null) {\n\t\t\t\t\t\tapplicationContextAware.setApplicationContext(applicationContext);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (resolver instanceof InitializingBean initializingBean) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tinitializingBean.afterPropertiesSet();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"Failure from afterPropertiesSet\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\texceptionResolvers.add(resolver);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#configureMessageConverters(converters)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "converters"
    ],
    "position": {
      "column": 1,
      "line": 275
    },
    "return": "void",
    "signature": "protected void configureMessageConverters(List<HttpMessageConverter<?>> converters)",
    "source_code": "\t\tprotected void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n\t\t\tconverters.addAll(messageConverters);\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#getHandlerMapping(mvcConversionService,mvcResourceUrlProvider)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mvcConversionService",
      "mvcResourceUrlProvider"
    ],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "RouterFunctionMapping",
    "signature": "public RouterFunctionMapping getHandlerMapping(FormattingConversionService mvcConversionService,\n\t\t\t\tResourceUrlProvider mvcResourceUrlProvider)",
    "source_code": "\t\tpublic RouterFunctionMapping getHandlerMapping("
  },
  "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#initWebAppContext()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "WebApplicationContext",
    "signature": "protected WebApplicationContext initWebAppContext()",
    "source_code": "\tprotected WebApplicationContext initWebAppContext() {\n\t\tMockServletContext servletContext = new MockServletContext();\n\t\tStubWebApplicationContext wac = new StubWebApplicationContext(servletContext);\n\t\tregisterRouterFunction(wac);\n\t\tservletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, wac);\n\t\treturn wac;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#setAsyncRequestTimeout(timeout)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the timeout value for async execution.\n\t * <p>In Spring MVC Test, this value is used to determine how long to wait\n\t * for async execution to complete so that a test can verify the results\n\t * synchronously.\n\t * @param timeout the timeout value in milliseconds\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "RouterFunctionMockMvcBuilder",
    "signature": "public RouterFunctionMockMvcBuilder setAsyncRequestTimeout(long timeout)",
    "source_code": "\tpublic RouterFunctionMockMvcBuilder setAsyncRequestTimeout(long timeout) {\n\t\tthis.asyncRequestTimeout = timeout;\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#setCustomHandlerMapping(factory)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the factory to create a custom {@link RequestMappingHandlerMapping}.\n\t * @param factory the factory\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "factory"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "RouterFunctionMockMvcBuilder",
    "signature": "public RouterFunctionMockMvcBuilder setCustomHandlerMapping(Supplier<RouterFunctionMapping> factory)",
    "source_code": "\tpublic RouterFunctionMockMvcBuilder setCustomHandlerMapping(Supplier<RouterFunctionMapping> factory) {\n\t\tthis.handlerMappingFactory = factory;\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#setHandlerExceptionResolvers(exceptionResolvers)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the HandlerExceptionResolver types to use as an array.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exceptionResolvers"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "RouterFunctionMockMvcBuilder",
    "signature": "public RouterFunctionMockMvcBuilder setHandlerExceptionResolvers(HandlerExceptionResolver... exceptionResolvers)",
    "source_code": "\tpublic RouterFunctionMockMvcBuilder setHandlerExceptionResolvers(HandlerExceptionResolver... exceptionResolvers) {\n\t\tthis.handlerExceptionResolvers = Arrays.asList(exceptionResolvers);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#setMessageConverters(HttpMessageConverter<?>...messageConverters)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the message converters to use in argument resolvers and in return value\n\t * handlers, which support reading and/or writing to the body of the request\n\t * and response. If no message converters are added to the list, a default\n\t * list of converters is added instead.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "HttpMessageConverter<?>...messageConverters"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "RouterFunctionMockMvcBuilder",
    "signature": "public RouterFunctionMockMvcBuilder setMessageConverters(HttpMessageConverter<?>...messageConverters)",
    "source_code": "\tpublic RouterFunctionMockMvcBuilder setMessageConverters(HttpMessageConverter<?>...messageConverters) {\n\t\tthis.messageConverters = Arrays.asList(messageConverters);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#setPatternParser(parser)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Enable URL path matching with parsed\n\t * {@link org.springframework.web.util.pattern.PathPattern PathPatterns}\n\t * instead of String pattern matching with a {@link org.springframework.util.PathMatcher}.\n\t * @param parser the parser to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parser"
    ],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "RouterFunctionMockMvcBuilder",
    "signature": "public RouterFunctionMockMvcBuilder setPatternParser(@Nullable PathPatternParser parser)",
    "source_code": "\tpublic RouterFunctionMockMvcBuilder setPatternParser(@Nullable PathPatternParser parser) {\n\t\tthis.patternParser = parser;\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#setSingleView(view)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set up a single {@link ViewResolver} that always returns the provided\n\t * view instance.\n\t * <p>This is a convenient shortcut if you need to use one {@link View}\n\t * instance only &mdash; for example, rendering generated content (JSON, XML,\n\t * Atom).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "view"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "RouterFunctionMockMvcBuilder",
    "signature": "public RouterFunctionMockMvcBuilder setSingleView(View view)",
    "source_code": "\tpublic RouterFunctionMockMvcBuilder setSingleView(View view) {\n\t\tthis.viewResolvers = Collections.singletonList(new StaticViewResolver(view));\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#setViewResolvers(ViewResolver...resolvers)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set up view resolution with the given {@link ViewResolver ViewResolvers}.\n\t * <p>If not set, an {@link InternalResourceViewResolver} is used by default.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ViewResolver...resolvers"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "RouterFunctionMockMvcBuilder",
    "signature": "public RouterFunctionMockMvcBuilder setViewResolvers(ViewResolver...resolvers)",
    "source_code": "\tpublic RouterFunctionMockMvcBuilder setViewResolvers(ViewResolver...resolvers) {\n\t\tthis.viewResolvers = Arrays.asList(resolvers);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder#resolveViewName(viewName,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 613
    },
    "return": "View",
    "signature": "public View resolveViewName(String viewName, Locale locale)",
    "source_code": "\t\tpublic View resolveViewName(String viewName, Locale locale) {\n\t\t\treturn this.view;\n\t\t}"
  },
  "org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#addDefaultRollbackRule(rollbackRule)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a default rollback rule, to be applied to all rule-based\n\t * transaction attributes returned by this source.\n\t * <p>By default, a rollback will be triggered on unchecked exceptions\n\t * but not on checked exceptions. A default rule may override this\n\t * while still respecting any custom rules in the transaction attribute.\n\t * @param rollbackRule a rollback rule overriding the default behavior,\n\t * for example, {@link RollbackRuleAttribute#ROLLBACK_ON_ALL_EXCEPTIONS}\n\t * @since 6.2\n\t * @see RuleBasedTransactionAttribute#getRollbackRules()\n\t * @see EnableTransactionManagement#rollbackOn()\n\t * @see Transactional#rollbackFor()\n\t * @see Transactional#noRollbackFor()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rollbackRule"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "void",
    "signature": "public void addDefaultRollbackRule(RollbackRuleAttribute rollbackRule)",
    "source_code": "\tpublic void addDefaultRollbackRule(RollbackRuleAttribute rollbackRule) {\n\t\tif (this.defaultRollbackRules == null) {\n\t\t\tthis.defaultRollbackRules = new LinkedHashSet<>();\n\t\t}\n\t\tthis.defaultRollbackRules.add(rollbackRule);\n\t}"
  },
  "org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#setPublicMethodsOnly(publicMethodsOnly)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether transactional methods are expected to be public.\n\t * <p>The default is {@code true}.\n\t * @since 6.2\n\t * @see #AnnotationTransactionAttributeSource(boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "publicMethodsOnly"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "void",
    "signature": "public void setPublicMethodsOnly(boolean publicMethodsOnly)",
    "source_code": "\tpublic void setPublicMethodsOnly(boolean publicMethodsOnly) {\n\t\tthis.publicMethodsOnly = publicMethodsOnly;\n\t}"
  },
  "org.springframework.transaction.interceptor.AbstractFallbackTransactionAttributeSource#hasTransactionAttribute(method,targetClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "boolean",
    "signature": "public boolean hasTransactionAttribute(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tpublic boolean hasTransactionAttribute(Method method, @Nullable Class<?> targetClass) {\n\t\treturn (getTransactionAttribute(method, targetClass, false) != null);\n\t}"
  },
  "org.springframework.transaction.interceptor.ROLLBACK_ON_ALL_EXCEPTIONS": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * The {@linkplain RollbackRuleAttribute rollback rule} for all\n\t * {@link Exception Exceptions}, including checked exceptions.\n\t * @since 6.2\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "signature": "public RollbackRuleAttribute ROLLBACK_ON_ALL_EXCEPTIONS",
    "source_code": "\tpublic static final RollbackRuleAttribute ROLLBACK_ON_ALL_EXCEPTIONS =",
    "type": "RollbackRuleAttribute"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#determineTransactionManager(txAttr,targetClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the specific transaction manager to use for the given transaction.\n\t * @param txAttr the current transaction attribute\n\t * @param targetClass the target class that the attribute has been declared on\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "txAttr",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 497
    },
    "return": "TransactionManager",
    "signature": "protected TransactionManager determineTransactionManager(@Nullable TransactionAttribute txAttr, @Nullable Class<?> targetClass)",
    "source_code": "\tprotected TransactionManager determineTransactionManager("
  },
  "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory#setDefaultCharset(defaultCharset)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link Charset} for the default encoding for the FreeMarker\n\t * {@link Configuration}, which is used to decode byte sequences to character\n\t * sequences when reading template files.\n\t * <p>See {@link #setDefaultEncoding(String)} for details.\n\t * @since 6.2\n\t * @see java.nio.charset.StandardCharsets\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultCharset"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "void",
    "signature": "public void setDefaultCharset(Charset defaultCharset)",
    "source_code": "\tpublic void setDefaultCharset(Charset defaultCharset) {\n\t\tthis.defaultEncoding = defaultCharset.name();\n\t}"
  },
  "org.springframework.util.<unknown>#asSingleValueMap()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "V>",
    "signature": "public V> asSingleValueMap()",
    "source_code": "\tpublic Map<K, V> asSingleValueMap() {\n\t\treturn this.delegate.asSingleValueMap();\n\t}"
  },
  "org.springframework.util.<unknown>#entrySet()": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "List<V>>>",
    "signature": "public List<V>>> entrySet()",
    "source_code": "\tpublic Set<Entry<K, List<V>>> entrySet() {\n\t\tif (this.entrySet == null) {\n\t\t\tthis.entrySet = new UnmodifiableEntrySet<>(this.delegate.entrySet());\n\t\t}\n\t\treturn this.entrySet;\n\t}"
  },
  "org.springframework.util.<unknown>#flagPlaceholderAsVisited(placeholder)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "placeholder"
    ],
    "position": {
      "column": 1,
      "line": 359
    },
    "return": "void",
    "signature": "public void flagPlaceholderAsVisited(String placeholder)",
    "source_code": "\t\tpublic void flagPlaceholderAsVisited(String placeholder) {\n\t\t\tif (this.visitedPlaceholders == null) {\n\t\t\t\tthis.visitedPlaceholders = new HashSet<>(4);\n\t\t\t}\n\t\t\tif (!this.visitedPlaceholders.add(placeholder)) {\n\t\t\t\tthrow new PlaceholderResolutionException(\n\t\t\t\t\t\t\"Circular placeholder reference '%s'\".formatted(placeholder), placeholder, null);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.util.<unknown>#get(key)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "List<V>",
    "signature": "public List<V> get(Object key)",
    "source_code": "\tpublic List<V> get(Object key) {\n\t\tList<V> result = this.delegate.get(key);\n\t\treturn (result != null ? Collections.unmodifiableList(result) : null);\n\t}"
  },
  "org.springframework.util.<unknown>#handleUnresolvablePlaceholder(key,text)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "text"
    ],
    "position": {
      "column": 1,
      "line": 342
    },
    "return": "String",
    "signature": "public String handleUnresolvablePlaceholder(String key, String text)",
    "source_code": "\t\tpublic String handleUnresolvablePlaceholder(String key, String text) {\n\t\t\tif (this.ignoreUnresolvablePlaceholders) {\n\t\t\t\treturn toPlaceholderText(key);\n\t\t\t}\n\t\t\tString originalValue = (!key.equals(text) ? toPlaceholderText(text) : null);\n\t\t\tthrow new PlaceholderResolutionException(\n\t\t\t\t\t\"Could not resolve placeholder '%s'\".formatted(key), key, originalValue);\n\t\t}"
  },
  "org.springframework.util.<unknown>#iterator()": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 569
    },
    "return": "Iterator<List<V>>",
    "signature": "public Iterator<List<V>> iterator()",
    "source_code": "\t\tpublic Iterator<List<V>> iterator() {\n\t\t\tIterator<List<V>> iterator = this.delegate.iterator();\n\t\t\treturn new Iterator<>() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean hasNext() {\n\t\t\t\t\treturn iterator.hasNext();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic List<V> next() {\n\t\t\t\t\treturn Collections.unmodifiableList(iterator.next());\n\t\t\t\t}\n\t\t\t};\n\t\t}"
  },
  "org.springframework.util.<unknown>#next()": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 578
    },
    "return": "List<V>",
    "signature": "public List<V> next()",
    "source_code": "\t\t\t\tpublic List<V> next() {\n\t\t\t\t\treturn Collections.unmodifiableList(iterator.next());\n\t\t\t\t}"
  },
  "org.springframework.util.<unknown>#parse(text)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text"
    ],
    "position": {
      "column": 1,
      "line": 355
    },
    "return": "List<Part>",
    "signature": "public List<Part> parse(String text)",
    "source_code": "\t\tpublic List<Part> parse(String text) {\n\t\t\treturn this.parser.apply(text);\n\t\t}"
  },
  "org.springframework.util.<unknown>#put(key,value)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "List<V>",
    "signature": "public List<V> put(K key, List<V> value)",
    "source_code": "\tpublic List<V> put(K key, List<V> value) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#put(key,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "List<V>",
    "signature": "public List<V> put(K key, List<V> values)",
    "source_code": "\tpublic List<V> put(K key, List<V> values) {\n\t\tif (values.isEmpty()) {\n\t\t\tV result = this.targetMap.put(key, null);\n\t\t\treturn (result != null) ? Collections.singletonList(result) : null;\n\t\t}\n\t\telse if (values.size() == 1) {\n\t\t\tV result = this.targetMap.put(key, values.get(0));\n\t\t\treturn (result != null) ? Collections.singletonList(result) : null;\n\t\t}\n\t\telse {\n\t\t\tthrow new UnsupportedOperationException(\"Duplicate key: \" + key);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#putAll(K,map)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "K",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends K, ? extends V> map)",
    "source_code": "\tpublic void putAll(Map<? extends K, ? extends V> map) {\n\t\tfor (Entry<? extends K, ? extends V> entry : map.entrySet()) {\n\t\t\tput(entry.getKey(), entry.getValue());\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#remove(key)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "List<V>",
    "signature": "public List<V> remove(Object key)",
    "source_code": "\tpublic List<V> remove(Object key) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#removePlaceholder(placeholder)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "placeholder"
    ],
    "position": {
      "column": 1,
      "line": 369
    },
    "return": "void",
    "signature": "public void removePlaceholder(String placeholder)",
    "source_code": "\t\tpublic void removePlaceholder(String placeholder) {\n\t\t\tAssert.state(this.visitedPlaceholders != null, \"Visited placeholders must not be null\");\n\t\t\tthis.visitedPlaceholders.remove(placeholder);\n\t\t}"
  },
  "org.springframework.util.<unknown>#replacePlaceholders(value,placeholderResolver)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Replace all placeholders of format {@code ${name}} with the value returned\n\t * from the supplied {@link PlaceholderResolver}.\n\t * @param value the value containing the placeholders to be replaced\n\t * @param placeholderResolver the {@code PlaceholderResolver} to use for replacement\n\t * @return the supplied value with placeholders replaced inline\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "placeholderResolver"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "String",
    "signature": "public String replacePlaceholders(String value, PlaceholderResolver placeholderResolver)",
    "source_code": "\tpublic String replacePlaceholders(String value, PlaceholderResolver placeholderResolver) {\n\t\tAssert.notNull(value, \"'value' must not be null\");\n\t\tParsedValue parsedValue = parse(value);\n\t\tPartResolutionContext resolutionContext = new PartResolutionContext(placeholderResolver,\n\t\t\t\tthis.prefix, this.suffix, this.ignoreUnresolvablePlaceholders,\n\t\t\t\tcandidate -> parse(candidate, false));\n\t\treturn parsedValue.resolve(resolutionContext);\n\t}"
  },
  "org.springframework.util.<unknown>#resolve(resolutionContext)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolutionContext"
    ],
    "position": {
      "column": 1,
      "line": 576
    },
    "return": "String",
    "signature": "public String resolve(PartResolutionContext resolutionContext)",
    "source_code": "\t\tpublic String resolve(PartResolutionContext resolutionContext) {\n\t\t\tString resolvedKey = Part.resolveAll(this.keyParts, resolutionContext);\n\t\t\tString value = resolveRecursively(resolutionContext, resolvedKey);\n\t\t\tif (value != null) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\telse if (this.defaultParts != null) {\n\t\t\t\treturn Part.resolveAll(this.defaultParts, resolutionContext);\n\t\t\t}\n\t\t\treturn resolutionContext.handleUnresolvablePlaceholder(resolvedKey, text());\n\t\t}"
  },
  "org.springframework.util.<unknown>#resolvePlaceholder(placeholderName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "placeholderName"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "String",
    "signature": "public String resolvePlaceholder(String placeholderName)",
    "source_code": "\t\tpublic String resolvePlaceholder(String placeholderName) {\n\t\t\tString value = this.resolver.resolvePlaceholder(placeholderName);\n\t\t\tif (value != null && logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Resolved placeholder '\" + placeholderName + \"'\");\n\t\t\t}\n\t\t\treturn value;\n\t\t}"
  },
  "org.springframework.util.<unknown>#resolveRecursively(resolutionContext,key)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Resolve the placeholder with the given {@code key}. If the result of such\n\t\t * resolution return other placeholders, those are resolved as well until the\n\t\t * resolution no longer contains any placeholders.\n\t\t * @param resolutionContext the resolution context to use\n\t\t * @param key the initial placeholder\n\t\t * @return the full resolution of the given {@code key} or {@code null} if\n\t\t * the placeholder has no value to begin with\n\t\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resolutionContext",
      "key"
    ],
    "position": {
      "column": 1,
      "line": 455
    },
    "return": "String",
    "signature": "protected String resolveRecursively(PartResolutionContext resolutionContext, String key)",
    "source_code": "\t\tprotected String resolveRecursively(PartResolutionContext resolutionContext, String key) {\n\t\t\tString resolvedValue = resolutionContext.resolvePlaceholder(key);\n\t\t\tif (resolvedValue != null) {\n\t\t\t\tresolutionContext.flagPlaceholderAsVisited(key);\n\t\t\t\t// Let's check if we need to recursively resolve that value\n\t\t\t\tList<Part> nestedParts = resolutionContext.parse(resolvedValue);\n\t\t\t\tString value = toText(nestedParts);\n\t\t\t\tif (!isTextOnly(nestedParts)) {\n\t\t\t\t\tvalue = new ParsedValue(resolvedValue, nestedParts).resolve(resolutionContext);\n\t\t\t\t}\n\t\t\t\tresolutionContext.removePlaceholder(key);\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\t// Not found\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.util.<unknown>#text()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 441
    },
    "return": "String",
    "signature": "public String text()",
    "source_code": "\t\tpublic String text() {\n\t\t\treturn this.text;\n\t\t}"
  },
  "org.springframework.util.<unknown>#values()": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "Collection<List<V>>",
    "signature": "public Collection<List<V>> values()",
    "source_code": "\tpublic Collection<List<V>> values() {\n\t\tif (this.values == null) {\n\t\t\tthis.values = new UnmodifiableValueCollection<>(this.delegate.values());\n\t\t}\n\t\treturn this.values;\n\t}"
  },
  "org.springframework.util.CollectionUtils#compositeMap(Map<K,first,Map<K,second)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a (partially unmodifiable) map that combines the provided two\n\t * maps. Invoking {@link Map#put(Object, Object)} or {@link Map#putAll(Map)}\n\t * on the returned map results in an {@link UnsupportedOperationException}.\n\t * <p>In the case of a key collision, {@code first} takes precedence over\n\t * {@code second}. In other words, entries in {@code second} with a key\n\t * that is also mapped by {@code first} are effectively ignored.\n\t * @param first the first map to compose\n\t * @param second the second map to compose\n\t * @return a new map that composes the given two maps\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<K",
      "first",
      "Map<K",
      "second"
    ],
    "position": {
      "column": 1,
      "line": 526
    },
    "return": "V>",
    "signature": "public V> compositeMap(Map<K,V> first, Map<K,V> second)",
    "source_code": "\tpublic static <K, V> Map<K, V> compositeMap(Map<K,V> first, Map<K,V> second) {\n\t\treturn new CompositeMap<>(first, second);\n\t}"
  },
  "org.springframework.util.CollectionUtils#compositeMap(Map<K,first,Map<K,second,BiFunction<K,V,putFunction,Consumer<Map<K,putAllFunction)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a map that combines the provided maps. Invoking\n\t * {@link Map#put(Object, Object)} on the returned map will apply\n\t * {@code putFunction}, or will throw an\n\t * {@link UnsupportedOperationException} {@code putFunction} is\n\t * {@code null}. The same applies to {@link Map#putAll(Map)} and\n\t * {@code putAllFunction}.\n\t * <p>In the case of a key collision, {@code first} takes precedence over\n\t * {@code second}. In other words, entries in {@code second} with a key\n\t * that is also mapped by {@code first} are effectively ignored.\n\t * @param first the first map to compose\n\t * @param second the second map to compose\n\t * @param putFunction applied when {@code Map::put} is invoked. If\n\t * {@code null}, {@code Map::put} throws an\n\t * {@code UnsupportedOperationException}.\n\t * @param putAllFunction applied when {@code Map::putAll} is invoked. If\n\t * {@code null}, {@code Map::putAll} throws an\n\t * {@code UnsupportedOperationException}.\n\t * @return a new map that composes the give maps\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<K",
      "first",
      "Map<K",
      "second",
      "BiFunction<K",
      "V",
      "putFunction",
      "Consumer<Map<K",
      "putAllFunction"
    ],
    "position": {
      "column": 1,
      "line": 551
    },
    "return": "V>",
    "signature": "public V> compositeMap(Map<K,V> first, Map<K,V> second,\n\t\t\t@Nullable BiFunction<K, V, V> putFunction,\n\t\t\t@Nullable Consumer<Map<K, V>> putAllFunction)",
    "source_code": "\tpublic static <K, V> Map<K, V> compositeMap(Map<K,V> first, Map<K,V> second,"
  },
  "org.springframework.util.CollectionUtils#newHashSet(expectedSize)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Instantiate a new {@link HashSet} with an initial capacity that can\n\t * accommodate the specified number of elements without any immediate\n\t * resize/rehash operations to be expected.\n\t * @param expectedSize the expected number of elements (with a corresponding\n\t * capacity to be derived so that no resize/rehash operations are needed)\n\t * @since 6.2\n\t * @see #newLinkedHashSet(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedSize"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "HashSet<E>",
    "signature": "public HashSet<E> newHashSet(int expectedSize)",
    "source_code": "\tpublic static <E> HashSet<E> newHashSet(int expectedSize) {\n\t\treturn new HashSet<>(computeInitialCapacity(expectedSize), DEFAULT_LOAD_FACTOR);\n\t}"
  },
  "org.springframework.util.CollectionUtils#newLinkedHashSet(expectedSize)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Instantiate a new {@link LinkedHashSet} with an initial capacity that can\n\t * accommodate the specified number of elements without any immediate\n\t * resize/rehash operations to be expected.\n\t * @param expectedSize the expected number of elements (with a corresponding\n\t * capacity to be derived so that no resize/rehash operations are needed)\n\t * @since 6.2\n\t * @see #newHashSet(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedSize"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "LinkedHashSet<E>",
    "signature": "public LinkedHashSet<E> newLinkedHashSet(int expectedSize)",
    "source_code": "\tpublic static <E> LinkedHashSet<E> newLinkedHashSet(int expectedSize) {\n\t\treturn new LinkedHashSet<>(computeInitialCapacity(expectedSize), DEFAULT_LOAD_FACTOR);\n\t}"
  },
  "org.springframework.util.xml.<unknown>#endPrefixMapping(prefix)": {
    "change": "modifier_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "prefix"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "void",
    "signature": "public void endPrefixMapping(String prefix)",
    "source_code": "\tpublic void endPrefixMapping(String prefix) {\n\t}"
  },
  "org.springframework.validation.FieldError": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Encapsulates a field error, that is, a reason for rejecting a specific\n * field value.\n *\n * <p>See the {@link DefaultMessageCodesResolver} javadoc for details on\n * how a message code list is built for a {@code FieldError}.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 10.03.2003\n * @see DefaultMessageCodesResolver\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 36
    },
    "signature": "public class FieldError",
    "source_code": "public class FieldError extends ObjectError {\n\n\tprivate final String field;\n\n\t@Nullable\n\tprivate final Object rejectedValue;\n\n\tprivate final boolean bindingFailure;\n\n\n\t/**\n\t * Create a new FieldError instance.\n\t * @param objectName the name of the affected object\n\t * @param field the affected field of the object\n\t * @param defaultMessage the default message to be used to resolve this message\n\t */\n\tpublic FieldError(String objectName, String field, String defaultMessage) {\n\t\tthis(objectName, field, null, false, null, null, defaultMessage);\n\t}\n\n\t/**\n\t * Create a new FieldError instance.\n\t * @param objectName the name of the affected object\n\t * @param field the affected field of the object\n\t * @param rejectedValue the rejected field value\n\t * @param bindingFailure whether this error represents a binding failure\n\t * (like a type mismatch); else, it is a validation failure\n\t * @param codes the codes to be used to resolve this message\n\t * @param arguments the array of arguments to be used to resolve this message\n\t * @param defaultMessage the default message to be used to resolve this message\n\t */\n\tpublic FieldError(String objectName, String field, @Nullable Object rejectedValue, boolean bindingFailure,\n\t\t\t@Nullable String[] codes, @Nullable Object[] arguments, @Nullable String defaultMessage) {\n\n\t\tsuper(objectName, codes, arguments, defaultMessage);\n\t\tAssert.notNull(field, \"Field must not be null\");\n\t\tthis.field = field;\n\t\tthis.rejectedValue = rejectedValue;\n\t\tthis.bindingFailure = bindingFailure;\n\t}\n\n\n\t/**\n\t * Return the affected field of the object.\n\t */\n\tpublic String getField() {\n\t\treturn this.field;\n\t}\n\n\t/**\n\t * Return the rejected field value.\n\t */\n\t@Nullable\n\tpublic Object getRejectedValue() {\n\t\treturn this.rejectedValue;\n\t}\n\n\t/**\n\t * Return whether this error represents a binding failure\n\t * (like a type mismatch); otherwise it is a validation failure.\n\t */\n\tpublic boolean isBindingFailure() {\n\t\treturn this.bindingFailure;\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!super.equals(other)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (other instanceof FieldError otherError && getField().equals(otherError.getField()) &&\n\t\t\t\tObjectUtils.nullSafeEquals(getRejectedValue(), otherError.getRejectedValue()) &&\n\t\t\t\tisBindingFailure() == otherError.isBindingFailure());\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tint hashCode = super.hashCode();\n\t\thashCode = 29 * hashCode + getField().hashCode();\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getRejectedValue());\n\t\thashCode = 29 * hashCode + (isBindingFailure() ? 1 : 0);\n\t\treturn hashCode;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\t// We would preferably use ObjectUtils.nullSafeConciseToString(rejectedValue) here but\n\t\t// keep including the full nullSafeToString representation for backwards compatibility.\n\t\treturn \"Field error in object '\" + getObjectName() + \"' on field '\" + this.field +\n\t\t\t\t\"': rejected value [\" + ObjectUtils.nullSafeToString(this.rejectedValue) + \"]; \" +\n\t\t\t\tresolvableToString();\n\t}\n\n}"
  },
  "org.springframework.validation.FieldError#equals(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!super.equals(other)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (other instanceof FieldError otherError && getField().equals(otherError.getField()) &&\n\t\t\t\tObjectUtils.nullSafeEquals(getRejectedValue(), otherError.getRejectedValue()) &&\n\t\t\t\tisBindingFailure() == otherError.isBindingFailure());\n\t}"
  },
  "org.springframework.validation.FieldError#getField()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the affected field of the object.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "String",
    "signature": "public String getField()",
    "source_code": "\tpublic String getField() {\n\t\treturn this.field;\n\t}"
  },
  "org.springframework.validation.FieldError#getRejectedValue()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the rejected field value.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "Object",
    "signature": "public Object getRejectedValue()",
    "source_code": "\tpublic Object getRejectedValue() {\n\t\treturn this.rejectedValue;\n\t}"
  },
  "org.springframework.validation.FieldError#hashCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\tint hashCode = super.hashCode();\n\t\thashCode = 29 * hashCode + getField().hashCode();\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getRejectedValue());\n\t\thashCode = 29 * hashCode + (isBindingFailure() ? 1 : 0);\n\t\treturn hashCode;\n\t}"
  },
  "org.springframework.validation.FieldError#isBindingFailure()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether this error represents a binding failure\n\t * (like a type mismatch); otherwise it is a validation failure.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "boolean",
    "signature": "public boolean isBindingFailure()",
    "source_code": "\tpublic boolean isBindingFailure() {\n\t\treturn this.bindingFailure;\n\t}"
  },
  "org.springframework.validation.FieldError#toString()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\t// We would preferably use ObjectUtils.nullSafeConciseToString(rejectedValue) here but\n\t\t// keep including the full nullSafeToString representation for backwards compatibility.\n\t\treturn \"Field error in object '\" + getObjectName() + \"' on field '\" + this.field +\n\t\t\t\t\"': rejected value [\" + ObjectUtils.nullSafeToString(this.rejectedValue) + \"]; \" +\n\t\t\t\tresolvableToString();\n\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#getViolation()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 567
    },
    "return": "ConstraintViolation<Object>",
    "signature": "public ConstraintViolation<Object> getViolation()",
    "source_code": "\t\tpublic ConstraintViolation<Object> getViolation() {\n\t\t\treturn this.violation;\n\t\t}"
  },
  "org.springframework.validation.method.ParameterValidationResult": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Store and expose the results of method validation for a method parameter.\n * <ul>\n * <li>Validation errors directly on method parameter values are exposed as a\n * list of {@link MessageSourceResolvable}s.\n * <li>Nested validation errors on an Object method parameter are exposed as\n * {@link org.springframework.validation.Errors} by the subclass\n * {@link ParameterErrors}.\n * </ul>\n *\n * <p>When the method parameter is a container such as a {@link List}, array,\n * or {@link java.util.Map}, then a separate {@link ParameterValidationResult}\n * is created for each element with errors. In that case, the properties\n * {@link #getContainer() container}, {@link #getContainerIndex() containerIndex},\n * and {@link #getContainerKey() containerKey} provide additional context.\n *\n * @author Rossen Stoyanchev\n * @since 6.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public class ParameterValidationResult",
    "source_code": "public class ParameterValidationResult {\n\n\tprivate final MethodParameter methodParameter;\n\n\t@Nullable\n\tprivate final Object argument;\n\n\tprivate final List<MessageSourceResolvable> resolvableErrors;\n\n\t@Nullable\n\tprivate final Object container;\n\n\t@Nullable\n\tprivate final Integer containerIndex;\n\n\t@Nullable\n\tprivate final Object containerKey;\n\n\tprivate final BiFunction<MessageSourceResolvable, Class<?>, Object> sourceLookup;\n\n\n\t/**\n\t * Create a {@code ParameterValidationResult}.\n\t */\n\tpublic ParameterValidationResult(\n\t\t\tMethodParameter param, @Nullable Object arg, Collection<? extends MessageSourceResolvable> errors,\n\t\t\t@Nullable Object container, @Nullable Integer index, @Nullable Object key,\n\t\t\tBiFunction<MessageSourceResolvable, Class<?>, Object> sourceLookup) {\n\n\t\tAssert.notNull(param, \"MethodParameter is required\");\n\t\tAssert.notEmpty(errors, \"`resolvableErrors` must not be empty\");\n\t\tthis.methodParameter = param;\n\t\tthis.argument = arg;\n\t\tthis.resolvableErrors = List.copyOf(errors);\n\t\tthis.container = container;\n\t\tthis.containerIndex = index;\n\t\tthis.containerKey = key;\n\t\tthis.sourceLookup = sourceLookup;\n\t}\n\n\t/**\n\t * Create a {@code ParameterValidationResult}.\n\t * @deprecated in favor of\n\t * {@link ParameterValidationResult#ParameterValidationResult(MethodParameter, Object, Collection, Object, Integer, Object, BiFunction)}\n\t */\n\t@Deprecated(since = \"6.2\", forRemoval = true)\n\tpublic ParameterValidationResult(\n\t\t\tMethodParameter param, @Nullable Object arg, Collection<? extends MessageSourceResolvable> errors,\n\t\t\t@Nullable Object container, @Nullable Integer index, @Nullable Object key) {\n\n\t\tthis(param, arg, errors, container, index, key, (error, sourceType) -> {\n\t\t\tthrow new IllegalArgumentException(\"No source object of the given type\");\n\t\t});\n\t}\n\n\t/**\n\t * Create a {@code ParameterValidationResult}.\n\t * @deprecated in favor of\n\t * {@link ParameterValidationResult#ParameterValidationResult(MethodParameter, Object, Collection, Object, Integer, Object, BiFunction)}\n\t */\n\t@Deprecated(since = \"6.1.3\", forRemoval = true)\n\tpublic ParameterValidationResult(\n\t\t\tMethodParameter param, @Nullable Object arg, Collection<? extends MessageSourceResolvable> errors) {\n\n\t\tthis(param, arg, errors, null, null, null, (error, sourceType) -> {\n\t\t\tthrow new IllegalArgumentException(\"No source object of the given type\");\n\t\t});\n\t}\n\n\n\t/**\n\t * The method parameter the validation results are for.\n\t */\n\tpublic MethodParameter getMethodParameter() {\n\t\treturn this.methodParameter;\n\t}\n\n\t/**\n\t * The method argument value that was validated.\n\t */\n\t@Nullable\n\tpublic Object getArgument() {\n\t\treturn this.argument;\n\t}\n\n\t/**\n\t * List of {@link MessageSourceResolvable} representations adapted from the\n\t * validation errors of the validation library.\n\t * <ul>\n\t * <li>For a constraints directly on a method parameter, error codes are\n\t * based on the names of the constraint annotation, the object, the method,\n\t * the parameter, and parameter type, for example,\n\t * {@code [\"Max.myObject#myMethod.myParameter\", \"Max.myParameter\", \"Max.int\", \"Max\"]}.\n\t * Arguments include the parameter itself as a {@link MessageSourceResolvable}, for example,\n\t * {@code [\"myObject#myMethod.myParameter\", \"myParameter\"]}, followed by actual\n\t * constraint annotation attributes (i.e. excluding \"message\", \"groups\" and\n\t * \"payload\") in alphabetical order of attribute names.\n\t * <li>For cascaded constraints via {@link jakarta.validation.Validator @Valid}\n\t * on a bean method parameter, this method returns\n\t * {@link org.springframework.validation.FieldError field errors} that you\n\t * can also access more conveniently through methods of the\n\t * {@link ParameterErrors} sub-class.\n\t * </ul>\n\t */\n\tpublic List<MessageSourceResolvable> getResolvableErrors() {\n\t\treturn this.resolvableErrors;\n\t}\n\n\t/**\n\t * When {@code @Valid} is declared on a container of elements such as\n\t * {@link java.util.Collection}, {@link java.util.Map},\n\t * {@link java.util.Optional}, and others, this method returns the container\n\t * of the validated {@link #getArgument() argument}, while\n\t * {@link #getContainerIndex()} and {@link #getContainerKey()} provide\n\t * information about the index or key if applicable.\n\t */\n\t@Nullable\n\tpublic Object getContainer() {\n\t\treturn this.container;\n\t}\n\n\t/**\n\t * When {@code @Valid} is declared on an indexed container of elements such as\n\t * {@link List} or array, this method returns the index of the validated\n\t * {@link #getArgument() argument}.\n\t */\n\t@Nullable\n\tpublic Integer getContainerIndex() {\n\t\treturn this.containerIndex;\n\t}\n\n\t/**\n\t * When {@code @Valid} is declared on a container of elements referenced by\n\t * key such as {@link java.util.Map}, this method returns the key of the\n\t * validated {@link #getArgument() argument}.\n\t */\n\t@Nullable\n\tpublic Object getContainerKey() {\n\t\treturn this.containerKey;\n\t}\n\n\t/**\n\t * Unwrap the source behind the given error. For Jakarta Bean validation the\n\t * source is a {@link jakarta.validation.ConstraintViolation}.\n\t * @param sourceType the expected source type\n\t * @return the source object of the given type\n\t * @since 6.2\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> T unwrap(MessageSourceResolvable error, Class<T> sourceType) {\n\t\treturn (T) this.sourceLookup.apply(error, sourceType);\n\t}\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!super.equals(other)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (other instanceof ParameterValidationResult otherResult &&\n\t\t\t\tgetMethodParameter().equals(otherResult.getMethodParameter()) &&\n\t\t\t\tObjectUtils.nullSafeEquals(getArgument(), otherResult.getArgument()) &&\n\t\t\t\tObjectUtils.nullSafeEquals(getContainerIndex(), otherResult.getContainerIndex()) &&\n\t\t\t\tObjectUtils.nullSafeEquals(getContainerKey(), otherResult.getContainerKey()));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tint hashCode = super.hashCode();\n\t\thashCode = 29 * hashCode + getMethodParameter().hashCode();\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getArgument());\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getContainerIndex());\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getContainerKey());\n\t\treturn hashCode;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \" for \" + this.methodParameter +\n\t\t\t\t\", argument value '\" + ObjectUtils.nullSafeConciseToString(this.argument) + \"',\" +\n\t\t\t\t(this.containerIndex != null ? \"containerIndex[\" + this.containerIndex + \"],\" : \"\") +\n\t\t\t\t(this.containerKey != null ? \"containerKey['\" + this.containerKey + \"'],\" : \"\") +\n\t\t\t\t\" errors: \" + getResolvableErrors();\n\t}\n\n}"
  },
  "org.springframework.validation.method.ParameterValidationResult#equals(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!super.equals(other)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (other instanceof ParameterValidationResult otherResult &&\n\t\t\t\tgetMethodParameter().equals(otherResult.getMethodParameter()) &&\n\t\t\t\tObjectUtils.nullSafeEquals(getArgument(), otherResult.getArgument()) &&\n\t\t\t\tObjectUtils.nullSafeEquals(getContainerIndex(), otherResult.getContainerIndex()) &&\n\t\t\t\tObjectUtils.nullSafeEquals(getContainerKey(), otherResult.getContainerKey()));\n\t}"
  },
  "org.springframework.validation.method.ParameterValidationResult#getArgument()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * The method argument value that was validated.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "Object",
    "signature": "public Object getArgument()",
    "source_code": "\tpublic Object getArgument() {\n\t\treturn this.argument;\n\t}"
  },
  "org.springframework.validation.method.ParameterValidationResult#getContainer()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * When {@code @Valid} is declared on a container of elements such as\n\t * {@link java.util.Collection}, {@link java.util.Map},\n\t * {@link java.util.Optional}, and others, this method returns the container\n\t * of the validated {@link #getArgument() argument}, while\n\t * {@link #getContainerIndex()} and {@link #getContainerKey()} provide\n\t * information about the index or key if applicable.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "Object",
    "signature": "public Object getContainer()",
    "source_code": "\tpublic Object getContainer() {\n\t\treturn this.container;\n\t}"
  },
  "org.springframework.validation.method.ParameterValidationResult#getContainerIndex()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * When {@code @Valid} is declared on an indexed container of elements such as\n\t * {@link List} or array, this method returns the index of the validated\n\t * {@link #getArgument() argument}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "Integer",
    "signature": "public Integer getContainerIndex()",
    "source_code": "\tpublic Integer getContainerIndex() {\n\t\treturn this.containerIndex;\n\t}"
  },
  "org.springframework.validation.method.ParameterValidationResult#getContainerKey()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * When {@code @Valid} is declared on a container of elements referenced by\n\t * key such as {@link java.util.Map}, this method returns the key of the\n\t * validated {@link #getArgument() argument}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "Object",
    "signature": "public Object getContainerKey()",
    "source_code": "\tpublic Object getContainerKey() {\n\t\treturn this.containerKey;\n\t}"
  },
  "org.springframework.validation.method.ParameterValidationResult#getMethodParameter()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * The method parameter the validation results are for.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter getMethodParameter()",
    "source_code": "\tpublic MethodParameter getMethodParameter() {\n\t\treturn this.methodParameter;\n\t}"
  },
  "org.springframework.validation.method.ParameterValidationResult#getResolvableErrors()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * List of {@link MessageSourceResolvable} representations adapted from the\n\t * validation errors of the validation library.\n\t * <ul>\n\t * <li>For a constraints directly on a method parameter, error codes are\n\t * based on the names of the constraint annotation, the object, the method,\n\t * the parameter, and parameter type, for example,\n\t * {@code [\"Max.myObject#myMethod.myParameter\", \"Max.myParameter\", \"Max.int\", \"Max\"]}.\n\t * Arguments include the parameter itself as a {@link MessageSourceResolvable}, for example,\n\t * {@code [\"myObject#myMethod.myParameter\", \"myParameter\"]}, followed by actual\n\t * constraint annotation attributes (i.e. excluding \"message\", \"groups\" and\n\t * \"payload\") in alphabetical order of attribute names.\n\t * <li>For cascaded constraints via {@link jakarta.validation.Validator @Valid}\n\t * on a bean method parameter, this method returns\n\t * {@link org.springframework.validation.FieldError field errors} that you\n\t * can also access more conveniently through methods of the\n\t * {@link ParameterErrors} sub-class.\n\t * </ul>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "List<MessageSourceResolvable>",
    "signature": "public List<MessageSourceResolvable> getResolvableErrors()",
    "source_code": "\tpublic List<MessageSourceResolvable> getResolvableErrors() {\n\t\treturn this.resolvableErrors;\n\t}"
  },
  "org.springframework.validation.method.ParameterValidationResult#hashCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\tint hashCode = super.hashCode();\n\t\thashCode = 29 * hashCode + getMethodParameter().hashCode();\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getArgument());\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getContainerIndex());\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getContainerKey());\n\t\treturn hashCode;\n\t}"
  },
  "org.springframework.validation.method.ParameterValidationResult#toString()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \" for \" + this.methodParameter +\n\t\t\t\t\", argument value '\" + ObjectUtils.nullSafeConciseToString(this.argument) + \"',\" +\n\t\t\t\t(this.containerIndex != null ? \"containerIndex[\" + this.containerIndex + \"],\" : \"\") +\n\t\t\t\t(this.containerKey != null ? \"containerKey['\" + this.containerKey + \"'],\" : \"\") +\n\t\t\t\t\" errors: \" + getResolvableErrors();\n\t}"
  },
  "org.springframework.validation.method.ParameterValidationResult#unwrap(error,sourceType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Unwrap the source behind the given error. For Jakarta Bean validation the\n\t * source is a {@link jakarta.validation.ConstraintViolation}.\n\t * @param sourceType the expected source type\n\t * @return the source object of the given type\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "error",
      "sourceType"
    ],
    "position": {
      "column": 1,
      "line": 197
    },
    "return": "T",
    "signature": "public T unwrap(MessageSourceResolvable error, Class<T> sourceType)",
    "source_code": "\tpublic <T> T unwrap(MessageSourceResolvable error, Class<T> sourceType) {\n\t\treturn (T) this.sourceLookup.apply(error, sourceType);\n\t}"
  },
  "org.springframework.web.client.<unknown>#attribute(name,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec attribute(String name, Object value)",
    "source_code": "\t\tpublic RequestBodySpec attribute(String name, Object value) {\n\t\t\tgetAttributes().put(name, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#attributes(Consumer<Map<String,attributesConsumer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Consumer<Map<String",
      "attributesConsumer"
    ],
    "position": {
      "column": 1,
      "line": 435
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec attributes(Consumer<Map<String, Object>> attributesConsumer)",
    "source_code": "\t\tpublic RequestBodySpec attributes(Consumer<Map<String, Object>> attributesConsumer) {\n\t\t\tattributesConsumer.accept(getAttributes());\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#cookie(name,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 393
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec cookie(String name, String value)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec cookie(String name, String value) {\n\t\t\tgetCookies().add(name, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#cookies(Consumer<MultiValueMap<String,cookiesConsumer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Consumer<MultiValueMap<String",
      "cookiesConsumer"
    ],
    "position": {
      "column": 1,
      "line": 399
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer) {\n\t\t\tcookiesConsumer.accept(getCookies());\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#executeAndExtract(exchangeFunction)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchangeFunction"
    ],
    "position": {
      "column": 1,
      "line": 808
    },
    "return": "T",
    "signature": "public T executeAndExtract(RequestHeadersSpec.ExchangeFunction<T> exchangeFunction)",
    "source_code": "\t\tpublic <T> T executeAndExtract(RequestHeadersSpec.ExchangeFunction<T> exchangeFunction) {\n\t\t\treturn this.requestHeadersSpec.exchange(exchangeFunction);\n\t\t}"
  },
  "org.springframework.web.client.DefaultResponseErrorHandler": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Spring's default implementation of the {@link ResponseErrorHandler} interface.\n *\n * <p>This error handler checks for the status code on the\n * {@link ClientHttpResponse}. Any code in the 4xx or 5xx series is considered\n * to be an error. This behavior can be changed by overriding\n * {@link #hasError(HttpStatusCode)}. Unknown status codes will be ignored by\n * {@link #hasError(ClientHttpResponse)}.\n *\n * <p>See {@link #handleError(URI, HttpMethod, ClientHttpResponse)}  for more\n * details on specific exception types.\n *\n * @author Arjen Poutsma\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 3.0\n * @see RestTemplate#setErrorHandler\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "signature": "public class DefaultResponseErrorHandler",
    "source_code": "public class DefaultResponseErrorHandler implements ResponseErrorHandler {\n\n\t@Nullable\n\tprivate List<HttpMessageConverter<?>> messageConverters;\n\n\n\t/**\n\t * For internal use from the RestTemplate, to pass the message converters\n\t * to use to decode error content.\n\t * @since 6.0\n\t */\n\tvoid setMessageConverters(List<HttpMessageConverter<?>> converters) {\n\t\tthis.messageConverters = Collections.unmodifiableList(converters);\n\t}\n\n\n\t/**\n\t * Delegates to {@link #hasError(HttpStatusCode)} with the response status code.\n\t * @see ClientHttpResponse#getStatusCode()\n\t * @see #hasError(HttpStatusCode)\n\t */\n\t@Override\n\tpublic boolean hasError(ClientHttpResponse response) throws IOException {\n\t\tHttpStatusCode statusCode = response.getStatusCode();\n\t\treturn hasError(statusCode);\n\t}\n\n\t/**\n\t * Template method called from {@link #hasError(ClientHttpResponse)}.\n\t * <p>The default implementation checks {@link HttpStatusCode#isError()}.\n\t * Can be overridden in subclasses.\n\t * @param statusCode the HTTP status code\n\t * @return {@code true} if the response indicates an error; {@code false} otherwise\n\t * @see HttpStatusCode#isError()\n\t */\n\tprotected boolean hasError(HttpStatusCode statusCode) {\n\t\treturn statusCode.isError();\n\t}\n\n\t/**\n\t * Template method called from {@link #hasError(ClientHttpResponse)}.\n\t * <p>The default implementation checks if the given status code is\n\t * {@link org.springframework.http.HttpStatus.Series#CLIENT_ERROR CLIENT_ERROR} or\n\t * {@link org.springframework.http.HttpStatus.Series#SERVER_ERROR SERVER_ERROR}.\n\t * Can be overridden in subclasses.\n\t * @param statusCode the HTTP status code as raw value\n\t * @return {@code true} if the response indicates an error; {@code false} otherwise\n\t * @since 4.3.21\n\t * @see org.springframework.http.HttpStatus.Series#CLIENT_ERROR\n\t * @see org.springframework.http.HttpStatus.Series#SERVER_ERROR\n\t * @deprecated in favor of {@link #hasError(HttpStatusCode)}\n\t */\n\t@Deprecated\n\tprotected boolean hasError(int statusCode) {\n\t\tHttpStatus.Series series = HttpStatus.Series.resolve(statusCode);\n\t\treturn (series == HttpStatus.Series.CLIENT_ERROR || series == HttpStatus.Series.SERVER_ERROR);\n\t}\n\n\t/**\n\t * Handle the error in the given response with the given resolved status code\n\t * and extra information providing access to the request URL and HTTP method.\n\t * <p>The default implementation throws:\n\t * <ul>\n\t * <li>{@link HttpClientErrorException} if the status code is in the 4xx\n\t * series, or one of its sub-classes such as\n\t * {@link HttpClientErrorException.BadRequest} and others.\n\t * <li>{@link HttpServerErrorException} if the status code is in the 5xx\n\t * series, or one of its sub-classes such as\n\t * {@link HttpServerErrorException.InternalServerError} and others.\n\t * <li>{@link UnknownHttpStatusCodeException} for error status codes not in the\n\t * {@link HttpStatus} enum range.\n\t * </ul>\n\t * @throws UnknownHttpStatusCodeException in case of an unresolvable status code\n\t * @since 6.2\n\t * @see #handleError(ClientHttpResponse, HttpStatusCode, URI, HttpMethod)\n\t */\n\t@Override\n\tpublic void handleError(URI url, HttpMethod method, ClientHttpResponse response) throws IOException {\n\n\t\t// For backwards compatibility try handle(response) first\n\t\tHandleErrorResponseDecorator decorator = new HandleErrorResponseDecorator(response);\n\t\thandleError(decorator);\n\t\tif (decorator.isHandled()) {\n\t\t\treturn;\n\t\t}\n\n\t\thandleError(response, response.getStatusCode(), url, method);\n\t}\n\n\t@SuppressWarnings(\"removal\")\n\t@Override\n\tpublic void handleError(ClientHttpResponse response) throws IOException {\n\n\t\t// Called via handleError(url, method, response)\n\t\tif (response instanceof HandleErrorResponseDecorator decorator) {\n\t\t\tdecorator.setNotHandled();\n\t\t\treturn;\n\t\t}\n\n\t\t// Called directly, so do handle\n\t\thandleError(response, response.getStatusCode(), null, null);\n\t}\n\n\t/**\n\t * Handle the error based on the resolved status code.\n\t * <p>The default implementation delegates to\n\t * {@link HttpClientErrorException#create} for errors in the 4xx range, to\n\t * {@link HttpServerErrorException#create} for errors in the 5xx range,\n\t * or otherwise raises {@link UnknownHttpStatusCodeException}.\n\t * @since 6.2\n\t * @see HttpClientErrorException#create\n\t * @see HttpServerErrorException#create\n\t */\n\tprotected void handleError(\n\t\t\tClientHttpResponse response, HttpStatusCode statusCode,\n\t\t\t@Nullable URI url, @Nullable HttpMethod method) throws IOException {\n\n\t\tString statusText = response.getStatusText();\n\t\tHttpHeaders headers = response.getHeaders();\n\t\tbyte[] body = getResponseBody(response);\n\t\tCharset charset = getCharset(response);\n\t\tString message = getErrorMessage(statusCode.value(), statusText, body, charset, url, method);\n\n\t\tRestClientResponseException ex;\n\t\tif (statusCode.is4xxClientError()) {\n\t\t\tex = HttpClientErrorException.create(message, statusCode, statusText, headers, body, charset);\n\t\t}\n\t\telse if (statusCode.is5xxServerError()) {\n\t\t\tex = HttpServerErrorException.create(message, statusCode, statusText, headers, body, charset);\n\t\t}\n\t\telse {\n\t\t\tex = new UnknownHttpStatusCodeException(message, statusCode.value(), statusText, headers, body, charset);\n\t\t}\n\n\t\tif (!CollectionUtils.isEmpty(this.messageConverters)) {\n\t\t\tex.setBodyConvertFunction(initBodyConvertFunction(response, body));\n\t\t}\n\n\t\tthrow ex;\n\t}\n\n\t/**\n\t * Read the body of the given response (for inclusion in a status exception).\n\t * @param response the response to inspect\n\t * @return the response body as a byte array,\n\t * or an empty byte array if the body could not be read\n\t * @since 4.3.8\n\t */\n\tprotected byte[] getResponseBody(ClientHttpResponse response) {\n\t\treturn RestClientUtils.getBody(response);\n\t}\n\n\t/**\n\t * Determine the charset of the response (for inclusion in a status exception).\n\t * @param response the response to inspect\n\t * @return the associated charset, or {@code null} if none\n\t * @since 4.3.8\n\t */\n\t@Nullable\n\tprotected Charset getCharset(ClientHttpResponse response) {\n\t\tMediaType contentType = response.getHeaders().getContentType();\n\t\treturn (contentType != null ? contentType.getCharset() : null);\n\t}\n\n\t/**\n\t * Return an error message with details from the response body. For example:\n\t * <pre>\n\t * 404 Not Found on GET request for \"https://example.com\": [{'id': 123, 'message': 'my message'}]\n\t * </pre>\n\t */\n\tprivate String getErrorMessage(\n\t\t\tint rawStatusCode, String statusText, @Nullable byte[] responseBody, @Nullable Charset charset,\n\t\t\t@Nullable URI url, @Nullable HttpMethod method) {\n\n\t\tStringBuilder msg = new StringBuilder(rawStatusCode + \" \" + statusText);\n\t\tif (method != null) {\n\t\t\tmsg.append(\" on \").append(method).append(\" request\");\n\t\t}\n\t\tif (url != null) {\n\t\t\tmsg.append(\" for \\\"\");\n\t\t\tString urlString = url.toString();\n\t\t\tint idx = urlString.indexOf('?');\n\t\t\tif (idx != -1) {\n\t\t\t\tmsg.append(urlString, 0, idx);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmsg.append(urlString);\n\t\t\t}\n\t\t\tmsg.append(\"\\\"\");\n\t\t}\n\t\tmsg.append(\": \");\n\t\tif (ObjectUtils.isEmpty(responseBody)) {\n\t\t\tmsg.append(\"[no body]\");\n\t\t}\n\t\telse {\n\t\t\tcharset = (charset != null ? charset : StandardCharsets.UTF_8);\n\t\t\tString bodyText = new String(responseBody, charset);\n\t\t\tbodyText = LogFormatUtils.formatValue(bodyText, -1, true);\n\t\t\tmsg.append(bodyText);\n\t\t}\n\t\treturn msg.toString();\n\t}\n\n\t/**\n\t * Return a function for decoding the error content. This can be passed to\n\t * {@link RestClientResponseException#setBodyConvertFunction(Function)}.\n\t * @since 6.0\n\t */\n\t@SuppressWarnings(\"NullAway\")\n\tprotected Function<ResolvableType, ?> initBodyConvertFunction(ClientHttpResponse response, byte[] body) {\n\t\tAssert.state(!CollectionUtils.isEmpty(this.messageConverters), \"Expected message converters\");\n\t\treturn resolvableType -> {\n\t\t\ttry {\n\t\t\t\tHttpMessageConverterExtractor<?> extractor =\n\t\t\t\t\t\tnew HttpMessageConverterExtractor<>(resolvableType.getType(), this.messageConverters);\n\n\t\t\t\treturn extractor.extractData(new ClientHttpResponseDecorator(response) {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic InputStream getBody() {\n\t\t\t\t\t\treturn new ByteArrayInputStream(body);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new RestClientException(\n\t\t\t\t\t\t\"Error while extracting response for type [\" + resolvableType + \"]\", ex);\n\t\t\t}\n\t\t};\n\t}\n\n\n\tprivate static class HandleErrorResponseDecorator extends ClientHttpResponseDecorator {\n\n\t\tprivate boolean handled = true;\n\n\t\tpublic HandleErrorResponseDecorator(ClientHttpResponse delegate) {\n\t\t\tsuper(delegate);\n\t\t}\n\n\t\tpublic void setNotHandled() {\n\t\t\tthis.handled = false;\n\t\t}\n\n\t\tpublic boolean isHandled() {\n\t\t\treturn this.handled;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.client.DefaultResponseErrorHandler#getBody()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 279
    },
    "return": "InputStream",
    "signature": "public InputStream getBody()",
    "source_code": "\t\t\t\t\tpublic InputStream getBody() {\n\t\t\t\t\t\treturn new ByteArrayInputStream(body);\n\t\t\t\t\t}"
  },
  "org.springframework.web.client.DefaultResponseErrorHandler#getCharset(response)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the charset of the response (for inclusion in a status exception).\n\t * @param response the response to inspect\n\t * @return the associated charset, or {@code null} if none\n\t * @since 4.3.8\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "response"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "Charset",
    "signature": "protected Charset getCharset(ClientHttpResponse response)",
    "source_code": "\tprotected Charset getCharset(ClientHttpResponse response) {\n\t\tMediaType contentType = response.getHeaders().getContentType();\n\t\treturn (contentType != null ? contentType.getCharset() : null);\n\t}"
  },
  "org.springframework.web.client.DefaultResponseErrorHandler#getResponseBody(response)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Read the body of the given response (for inclusion in a status exception).\n\t * @param response the response to inspect\n\t * @return the response body as a byte array,\n\t * or an empty byte array if the body could not be read\n\t * @since 4.3.8\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "response"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "byte[]",
    "signature": "protected byte[] getResponseBody(ClientHttpResponse response)",
    "source_code": "\tprotected byte[] getResponseBody(ClientHttpResponse response) {\n\t\treturn RestClientUtils.getBody(response);\n\t}"
  },
  "org.springframework.web.client.DefaultResponseErrorHandler#handleError(response)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "response"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "void",
    "signature": "public void handleError(ClientHttpResponse response)",
    "source_code": "\tpublic void handleError(ClientHttpResponse response) throws IOException {\n\n\t\t// Called via handleError(url, method, response)\n\t\tif (response instanceof HandleErrorResponseDecorator decorator) {\n\t\t\tdecorator.setNotHandled();\n\t\t\treturn;\n\t\t}\n\n\t\t// Called directly, so do handle\n\t\thandleError(response, response.getStatusCode(), null, null);\n\t}"
  },
  "org.springframework.web.client.DefaultResponseErrorHandler#handleError(response,statusCode,url,method)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the error based on the resolved status code.\n\t * <p>The default implementation delegates to\n\t * {@link HttpClientErrorException#create} for errors in the 4xx range, to\n\t * {@link HttpServerErrorException#create} for errors in the 5xx range,\n\t * or otherwise raises {@link UnknownHttpStatusCodeException}.\n\t * @since 6.2\n\t * @see HttpClientErrorException#create\n\t * @see HttpServerErrorException#create\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "response",
      "statusCode",
      "url",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "void",
    "signature": "protected void handleError(ClientHttpResponse response, HttpStatusCode statusCode,\n\t\t\t@Nullable URI url, @Nullable HttpMethod method)",
    "source_code": "\tprotected void handleError("
  },
  "org.springframework.web.client.DefaultResponseErrorHandler#handleError(url,method,response)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the error in the given response with the given resolved status code\n\t * and extra information providing access to the request URL and HTTP method.\n\t * <p>The default implementation throws:\n\t * <ul>\n\t * <li>{@link HttpClientErrorException} if the status code is in the 4xx\n\t * series, or one of its sub-classes such as\n\t * {@link HttpClientErrorException.BadRequest} and others.\n\t * <li>{@link HttpServerErrorException} if the status code is in the 5xx\n\t * series, or one of its sub-classes such as\n\t * {@link HttpServerErrorException.InternalServerError} and others.\n\t * <li>{@link UnknownHttpStatusCodeException} for error status codes not in the\n\t * {@link HttpStatus} enum range.\n\t * </ul>\n\t * @throws UnknownHttpStatusCodeException in case of an unresolvable status code\n\t * @since 6.2\n\t * @see #handleError(ClientHttpResponse, HttpStatusCode, URI, HttpMethod)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "method",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "void",
    "signature": "public void handleError(URI url, HttpMethod method, ClientHttpResponse response)",
    "source_code": "\tpublic void handleError(URI url, HttpMethod method, ClientHttpResponse response) throws IOException {\n\n\t\t// For backwards compatibility try handle(response) first\n\t\tHandleErrorResponseDecorator decorator = new HandleErrorResponseDecorator(response);\n\t\thandleError(decorator);\n\t\tif (decorator.isHandled()) {\n\t\t\treturn;\n\t\t}\n\n\t\thandleError(response, response.getStatusCode(), url, method);\n\t}"
  },
  "org.springframework.web.client.DefaultResponseErrorHandler#hasError(response)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@link #hasError(HttpStatusCode)} with the response status code.\n\t * @see ClientHttpResponse#getStatusCode()\n\t * @see #hasError(HttpStatusCode)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "response"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "boolean",
    "signature": "public boolean hasError(ClientHttpResponse response)",
    "source_code": "\tpublic boolean hasError(ClientHttpResponse response) throws IOException {\n\t\tHttpStatusCode statusCode = response.getStatusCode();\n\t\treturn hasError(statusCode);\n\t}"
  },
  "org.springframework.web.client.DefaultResponseErrorHandler#hasError(statusCode)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Template method called from {@link #hasError(ClientHttpResponse)}.\n\t * <p>The default implementation checks if the given status code is\n\t * {@link org.springframework.http.HttpStatus.Series#CLIENT_ERROR CLIENT_ERROR} or\n\t * {@link org.springframework.http.HttpStatus.Series#SERVER_ERROR SERVER_ERROR}.\n\t * Can be overridden in subclasses.\n\t * @param statusCode the HTTP status code as raw value\n\t * @return {@code true} if the response indicates an error; {@code false} otherwise\n\t * @since 4.3.21\n\t * @see org.springframework.http.HttpStatus.Series#CLIENT_ERROR\n\t * @see org.springframework.http.HttpStatus.Series#SERVER_ERROR\n\t * @deprecated in favor of {@link #hasError(HttpStatusCode)}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "statusCode"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "boolean",
    "signature": "protected boolean hasError(int statusCode)",
    "source_code": "\tprotected boolean hasError(int statusCode) {\n\t\tHttpStatus.Series series = HttpStatus.Series.resolve(statusCode);\n\t\treturn (series == HttpStatus.Series.CLIENT_ERROR || series == HttpStatus.Series.SERVER_ERROR);\n\t}"
  },
  "org.springframework.web.client.DefaultResponseErrorHandler#isHandled()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "boolean",
    "signature": "public boolean isHandled()",
    "source_code": "\t\tpublic boolean isHandled() {\n\t\t\treturn this.handled;\n\t\t}"
  },
  "org.springframework.web.client.DefaultResponseErrorHandler#setNotHandled()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 300
    },
    "return": "void",
    "signature": "public void setNotHandled()",
    "source_code": "\t\tpublic void setNotHandled() {\n\t\t\tthis.handled = false;\n\t\t}"
  },
  "org.springframework.web.context.request.KEY": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Key under which this accessor is registered in\n\t * {@link io.micrometer.context.ContextRegistry}.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "signature": "public String KEY",
    "source_code": "\tpublic static final String KEY = RequestAttributesThreadLocalAccessor.class.getName() + \".KEY\";",
    "type": "String"
  },
  "org.springframework.web.context.request.RequestAttributesThreadLocalAccessor": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Adapt {@link RequestContextHolder} to the {@link ThreadLocalAccessor} contract\n * to assist the Micrometer Context Propagation library with\n * {@link RequestAttributes} propagation.\n *\n * @author Tadaya Tsuyukubo\n * @author Rossen Stoyanchev\n * @since 6.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "signature": "public class RequestAttributesThreadLocalAccessor",
    "source_code": "public class RequestAttributesThreadLocalAccessor implements ThreadLocalAccessor<RequestAttributes> {\n\n\t/**\n\t * Key under which this accessor is registered in\n\t * {@link io.micrometer.context.ContextRegistry}.\n\t */\n\tpublic static final String KEY = RequestAttributesThreadLocalAccessor.class.getName() + \".KEY\";\n\n\t@Override\n\tpublic Object key() {\n\t\treturn KEY;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic RequestAttributes getValue() {\n\t\tRequestAttributes request = RequestContextHolder.getRequestAttributes();\n\t\tif (request instanceof ServletRequestAttributes sra && !(sra instanceof SnapshotServletRequestAttributes)) {\n\t\t\trequest = new SnapshotServletRequestAttributes(sra);\n\t\t}\n\t\treturn request;\n\t}\n\n\t@Override\n\tpublic void setValue(RequestAttributes value) {\n\t\tRequestContextHolder.setRequestAttributes(value);\n\t}\n\n\t@Override\n\tpublic void setValue() {\n\t\tRequestContextHolder.resetRequestAttributes();\n\t}\n\n\n\t/**\n\t * ServletRequestAttributes that takes another instance, and makes a copy of the\n\t * request attributes at present to provide extended read access during async\n\t * handling when the DispatcherServlet has exited from the initial REQUEST dispatch\n\t * and marked the request {@link ServletRequestAttributes#requestCompleted()}.\n\t * <p>Note that beyond access to request attributes, there is no attempt to support\n\t * setting or removing request attributes, nor to access session attributes after\n\t * the initial REQUEST dispatch has exited.\n\t */\n\tprivate static final class SnapshotServletRequestAttributes extends ServletRequestAttributes {\n\n\t\tprivate final ServletRequestAttributes delegate;\n\n\t\tprivate final Map<String, Object> attributeMap;\n\n\t\tpublic SnapshotServletRequestAttributes(ServletRequestAttributes requestAttributes) {\n\t\t\tsuper(requestAttributes.getRequest(), requestAttributes.getResponse());\n\t\t\tthis.delegate = requestAttributes;\n\t\t\tthis.attributeMap = getAttributes(requestAttributes.getRequest());\n\t\t}\n\n\t\tprivate static Map<String, Object> getAttributes(HttpServletRequest request) {\n\t\t\tMap<String, Object> map = new HashMap<>();\n\t\t\tEnumeration<String> names = request.getAttributeNames();\n\t\t\twhile (names.hasMoreElements()) {\n\t\t\t\tString name = names.nextElement();\n\t\t\t\tmap.put(name, request.getAttribute(name));\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\t// Delegate methods that check isRequestActive()\n\n\t\t@Nullable\n\t\t@Override\n\t\tpublic Object getAttribute(String name, int scope) {\n\t\t\tif (scope == RequestAttributes.SCOPE_REQUEST && !this.delegate.isRequestActive()) {\n\t\t\t\treturn this.attributeMap.get(name);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn this.delegate.getAttribute(name, scope);\n\t\t\t}\n\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\tif (scope == RequestAttributes.SCOPE_REQUEST) {\n\t\t\t\t\treturn this.attributeMap.get(name);\n\t\t\t\t}\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String[] getAttributeNames(int scope) {\n\t\t\tif (scope == RequestAttributes.SCOPE_REQUEST && !this.delegate.isRequestActive()) {\n\t\t\t\treturn this.attributeMap.keySet().toArray(new String[0]);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn this.delegate.getAttributeNames(scope);\n\t\t\t}\n\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\tif (scope == RequestAttributes.SCOPE_REQUEST) {\n\t\t\t\t\treturn this.attributeMap.keySet().toArray(new String[0]);\n\t\t\t\t}\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void setAttribute(String name, Object value, int scope) {\n\t\t\tthis.delegate.setAttribute(name, value, scope);\n\t\t}\n\n\t\t@Override\n\t\tpublic void removeAttribute(String name, int scope) {\n\t\t\tthis.delegate.removeAttribute(name, scope);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.context.request.RequestAttributesThreadLocalAccessor#getAttribute(name,scope)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "Object",
    "signature": "public Object getAttribute(String name, int scope)",
    "source_code": "\t\tpublic Object getAttribute(String name, int scope) {\n\t\t\tif (scope == RequestAttributes.SCOPE_REQUEST && !this.delegate.isRequestActive()) {\n\t\t\t\treturn this.attributeMap.get(name);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn this.delegate.getAttribute(name, scope);\n\t\t\t}\n\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\tif (scope == RequestAttributes.SCOPE_REQUEST) {\n\t\t\t\t\treturn this.attributeMap.get(name);\n\t\t\t\t}\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.context.request.RequestAttributesThreadLocalAccessor#getAttributeNames(scope)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "String[]",
    "signature": "public String[] getAttributeNames(int scope)",
    "source_code": "\t\tpublic String[] getAttributeNames(int scope) {\n\t\t\tif (scope == RequestAttributes.SCOPE_REQUEST && !this.delegate.isRequestActive()) {\n\t\t\t\treturn this.attributeMap.keySet().toArray(new String[0]);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn this.delegate.getAttributeNames(scope);\n\t\t\t}\n\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\tif (scope == RequestAttributes.SCOPE_REQUEST) {\n\t\t\t\t\treturn this.attributeMap.keySet().toArray(new String[0]);\n\t\t\t\t}\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.context.request.RequestAttributesThreadLocalAccessor#getValue()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "RequestAttributes",
    "signature": "public RequestAttributes getValue()",
    "source_code": "\tpublic RequestAttributes getValue() {\n\t\tRequestAttributes request = RequestContextHolder.getRequestAttributes();\n\t\tif (request instanceof ServletRequestAttributes sra && !(sra instanceof SnapshotServletRequestAttributes)) {\n\t\t\trequest = new SnapshotServletRequestAttributes(sra);\n\t\t}\n\t\treturn request;\n\t}"
  },
  "org.springframework.web.context.request.RequestAttributesThreadLocalAccessor#key()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 46
    },
    "return": "Object",
    "signature": "public Object key()",
    "source_code": "\tpublic Object key() {\n\t\treturn KEY;\n\t}"
  },
  "org.springframework.web.context.request.RequestAttributesThreadLocalAccessor#removeAttribute(name,scope)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "void",
    "signature": "public void removeAttribute(String name, int scope)",
    "source_code": "\t\tpublic void removeAttribute(String name, int scope) {\n\t\t\tthis.delegate.removeAttribute(name, scope);\n\t\t}"
  },
  "org.springframework.web.context.request.RequestAttributesThreadLocalAccessor#setAttribute(name,value,scope)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value",
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "void",
    "signature": "public void setAttribute(String name, Object value, int scope)",
    "source_code": "\t\tpublic void setAttribute(String name, Object value, int scope) {\n\t\t\tthis.delegate.setAttribute(name, value, scope);\n\t\t}"
  },
  "org.springframework.web.context.request.RequestAttributesThreadLocalAccessor#setValue()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "void",
    "signature": "public void setValue()",
    "source_code": "\tpublic void setValue() {\n\t\tRequestContextHolder.resetRequestAttributes();\n\t}"
  },
  "org.springframework.web.context.request.RequestAttributesThreadLocalAccessor#setValue(value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "void",
    "signature": "public void setValue(RequestAttributes value)",
    "source_code": "\tpublic void setValue(RequestAttributes value) {\n\t\tRequestContextHolder.setRequestAttributes(value);\n\t}"
  },
  "org.springframework.web.method.annotation.ExceptionHandlerMethodResolver": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Discovers {@linkplain ExceptionHandler @ExceptionHandler} methods in a given class,\n * including all of its superclasses, and helps to resolve a given {@link Exception}\n * and {@link MediaType} requested by clients to combinations supported by a given {@link Method}.\n * <p>This resolver will use the exception information declared as {@code @ExceptionHandler}\n * annotation attributes, or as a method argument as a fallback. This will throw\n * {@code IllegalStateException} instances if:\n * <ul>\n *     <li>No Exception information could be found for a method\n *     <li>An invalid {@link MediaType} has been declared as {@code @ExceptionHandler} attribute\n *     <li>Multiple handlers declare the same exception + media type mapping\n * </ul>\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Brian Clozel\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "signature": "public class ExceptionHandlerMethodResolver",
    "source_code": "public class ExceptionHandlerMethodResolver {\n\n\t/**\n\t * A filter for selecting {@code @ExceptionHandler} methods.\n\t */\n\tprivate static final MethodFilter EXCEPTION_HANDLER_METHODS = method ->\n\t\t\tAnnotatedElementUtils.hasAnnotation(method, ExceptionHandler.class);\n\n\tprivate static final ExceptionHandlerMappingInfo NO_MATCHING_EXCEPTION_HANDLER;\n\n\tstatic {\n\t\ttry {\n\t\t\tNO_MATCHING_EXCEPTION_HANDLER = new ExceptionHandlerMappingInfo(Set.of(), Set.of(),\n\t\t\t\t\tExceptionHandlerMethodResolver.class.getDeclaredMethod(\"noMatchingExceptionHandler\"));\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\tthrow new IllegalStateException(\"Expected method not found: \" + ex);\n\t\t}\n\t}\n\n\tprivate final Map<ExceptionMapping, ExceptionHandlerMappingInfo> mappedMethods = new HashMap<>(16);\n\n\tprivate final ConcurrentLruCache<ExceptionMapping, ExceptionHandlerMappingInfo> lookupCache = new ConcurrentLruCache<>(24,\n\t\t\tcacheKey -> getMappedMethod(cacheKey.exceptionType(), cacheKey.mediaType()));\n\n\n\t/**\n\t * A constructor that finds {@link ExceptionHandler} methods in the given type.\n\t * @param handlerType the type to introspect\n\t * @throws IllegalStateException in case of invalid or ambiguous exception mapping declarations\n\t */\n\tpublic ExceptionHandlerMethodResolver(Class<?> handlerType) {\n\t\tfor (Method method : MethodIntrospector.selectMethods(handlerType, EXCEPTION_HANDLER_METHODS)) {\n\t\t\tExceptionHandlerMappingInfo mappingInfo = detectExceptionMappings(method);\n\t\t\tfor (Class<? extends Throwable> exceptionType : mappingInfo.getExceptionTypes()) {\n\t\t\t\tfor (MediaType producibleType : mappingInfo.getProducibleTypes()) {\n\t\t\t\t\taddExceptionMapping(new ExceptionMapping(exceptionType, producibleType), mappingInfo);\n\t\t\t\t}\n\t\t\t\tif (mappingInfo.getProducibleTypes().isEmpty()) {\n\t\t\t\t\taddExceptionMapping(new ExceptionMapping(exceptionType, MediaType.ALL), mappingInfo);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Extract exception mappings from the {@code @ExceptionHandler} annotation first,\n\t * and then as a fallback from the method signature itself.\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprivate ExceptionHandlerMappingInfo detectExceptionMappings(Method method) {\n\t\tExceptionHandler exceptionHandler = readExceptionHandlerAnnotation(method);\n\t\tList<Class<? extends Throwable>> exceptions = new ArrayList<>(Arrays.asList(exceptionHandler.exception()));\n\t\tif (exceptions.isEmpty()) {\n\t\t\tfor (Class<?> paramType : method.getParameterTypes()) {\n\t\t\t\tif (Throwable.class.isAssignableFrom(paramType)) {\n\t\t\t\t\texceptions.add((Class<? extends Throwable>) paramType);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (exceptions.isEmpty()) {\n\t\t\tthrow new IllegalStateException(\"No exception types mapped to \" + method);\n\t\t}\n\t\tSet<MediaType> mediaTypes = new HashSet<>();\n\t\tfor (String mediaType : exceptionHandler.produces()) {\n\t\t\ttry {\n\t\t\t\tmediaTypes.add(MediaType.parseMediaType(mediaType));\n\t\t\t}\n\t\t\tcatch (InvalidMediaTypeException exc) {\n\t\t\t\tthrow new IllegalStateException(\"Invalid media type [\" + mediaType + \"] declared on @ExceptionHandler for \" + method, exc);\n\t\t\t}\n\t\t}\n\t\treturn new ExceptionHandlerMappingInfo(Set.copyOf(exceptions), mediaTypes, method);\n\t}\n\n\tprivate ExceptionHandler readExceptionHandlerAnnotation(Method method) {\n\t\tExceptionHandler ann = AnnotatedElementUtils.findMergedAnnotation(method, ExceptionHandler.class);\n\t\tAssert.state(ann != null, \"No ExceptionHandler annotation\");\n\t\treturn ann;\n\t}\n\n\tprivate void addExceptionMapping(ExceptionMapping mapping, ExceptionHandlerMappingInfo mappingInfo) {\n\t\tExceptionHandlerMappingInfo oldMapping = this.mappedMethods.put(mapping, mappingInfo);\n\t\tif (oldMapping != null && !oldMapping.getHandlerMethod().equals(mappingInfo.getHandlerMethod())) {\n\t\t\tthrow new IllegalStateException(\"Ambiguous @ExceptionHandler method mapped for [\" +\n\t\t\t\t\tmapping + \"]: {\" + oldMapping.getHandlerMethod() + \", \" + mappingInfo.getHandlerMethod() + \"}\");\n\t\t}\n\t}\n\n\t/**\n\t * Whether the contained type has any exception mappings.\n\t */\n\tpublic boolean hasExceptionMappings() {\n\t\treturn !this.mappedMethods.isEmpty();\n\t}\n\n\t/**\n\t * Find a {@link Method} to handle the given exception.\n\t * <p>Uses {@link ExceptionDepthComparator} if more than one match is found.\n\t * @param exception the exception\n\t * @return a Method to handle the exception, or {@code null} if none found\n\t */\n\t@Nullable\n\tpublic Method resolveMethod(Exception exception) {\n\t\tExceptionHandlerMappingInfo mappingInfo = resolveExceptionMapping(exception, MediaType.ALL);\n\t\treturn (mappingInfo != null) ? mappingInfo.getHandlerMethod() : null;\n\t}\n\n\t/**\n\t * Find a {@link Method} to handle the given Throwable.\n\t * <p>Uses {@link ExceptionDepthComparator} if more than one match is found.\n\t * @param exception the exception\n\t * @return a Method to handle the exception, or {@code null} if none found\n\t * @since 5.0\n\t */\n\t@Nullable\n\tpublic Method resolveMethodByThrowable(Throwable exception) {\n\t\tExceptionHandlerMappingInfo mappingInfo = resolveExceptionMapping(exception, MediaType.ALL);\n\t\treturn (mappingInfo != null) ? mappingInfo.getHandlerMethod() : null;\n\t}\n\n\t/**\n\t * Find a {@link Method} to handle the given Throwable for the requested {@link MediaType}.\n\t * <p>Uses {@link ExceptionDepthComparator} and {@link MediaType#isMoreSpecific(MimeType)}\n\t * if more than one match is found.\n\t * @param exception the exception\n\t * @param mediaType the media type requested by the HTTP client\n\t * @return a Method to handle the exception, or {@code null} if none found\n\t * @since 6.2\n\t */\n\t@Nullable\n\tpublic ExceptionHandlerMappingInfo resolveExceptionMapping(Throwable exception, MediaType mediaType) {\n\t\tExceptionHandlerMappingInfo mappingInfo = resolveExceptionMappingByExceptionType(exception.getClass(), mediaType);\n\t\tif (mappingInfo == null) {\n\t\t\tThrowable cause = exception.getCause();\n\t\t\tif (cause != null) {\n\t\t\t\tmappingInfo = resolveExceptionMapping(cause, mediaType);\n\t\t\t}\n\t\t}\n\t\treturn mappingInfo;\n\t}\n\n\t/**\n\t * Find a {@link Method} to handle the given exception type. This can be\n\t * useful if an {@link Exception} instance is not available (for example, for tools).\n\t * <p>Uses {@link ExceptionDepthComparator} if more than one match is found.\n\t * @param exceptionType the exception type\n\t * @return a Method to handle the exception, or {@code null} if none found\n\t */\n\t@Nullable\n\tpublic Method resolveMethodByExceptionType(Class<? extends Throwable> exceptionType) {\n\t\tExceptionHandlerMappingInfo mappingInfo = resolveExceptionMappingByExceptionType(exceptionType, MediaType.ALL);\n\t\treturn (mappingInfo != null) ? mappingInfo.getHandlerMethod() : null;\n\t}\n\n\t/**\n\t * Find a {@link Method} to handle the given exception type and media type.\n\t * This can be useful if an {@link Exception} instance is not available (for example, for tools).\n\t * @param exceptionType the exception type\n\t * @param mediaType the media type requested by the HTTP client\n\t * @return a Method to handle the exception, or {@code null} if none found\n\t */\n\t@Nullable\n\tpublic ExceptionHandlerMappingInfo resolveExceptionMappingByExceptionType(Class<? extends Throwable> exceptionType, MediaType mediaType) {\n\t\tExceptionHandlerMappingInfo mappingInfo = this.lookupCache.get(new ExceptionMapping(exceptionType, mediaType));\n\t\treturn (mappingInfo != NO_MATCHING_EXCEPTION_HANDLER ? mappingInfo : null);\n\t}\n\n\t/**\n\t * Return the {@link Method} mapped to the given exception type, or\n\t * {@link #NO_MATCHING_EXCEPTION_HANDLER} if none.\n\t */\n\t@Nullable\n\tprivate ExceptionHandlerMappingInfo getMappedMethod(Class<? extends Throwable> exceptionType, MediaType mediaType) {\n\t\tList<ExceptionMapping> matches = new ArrayList<>();\n\t\tfor (ExceptionMapping mappingInfo : this.mappedMethods.keySet()) {\n\t\t\tif (mappingInfo.exceptionType().isAssignableFrom(exceptionType) && mappingInfo.mediaType().isCompatibleWith(mediaType)) {\n\t\t\t\tmatches.add(mappingInfo);\n\t\t\t}\n\t\t}\n\t\tif (!matches.isEmpty()) {\n\t\t\tif (matches.size() > 1) {\n\t\t\t\tmatches.sort(new ExceptionMapingComparator(exceptionType, mediaType));\n\t\t\t}\n\t\t\treturn this.mappedMethods.get(matches.get(0));\n\t\t}\n\t\telse {\n\t\t\treturn NO_MATCHING_EXCEPTION_HANDLER;\n\t\t}\n\t}\n\n\t/**\n\t * For the {@link #NO_MATCHING_EXCEPTION_HANDLER} constant.\n \t */\n\t@SuppressWarnings(\"unused\")\n\tprivate void noMatchingExceptionHandler() {\n\t}\n\n\tprivate record ExceptionMapping(Class<? extends Throwable> exceptionType, MediaType mediaType) {\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"ExceptionHandler{\" +\n\t\t\t\t\t\"exceptionType=\" + this.exceptionType.getCanonicalName() +\n\t\t\t\t\t\", mediaType=\" + this.mediaType +\n\t\t\t\t\t'}';\n\t\t}\n\t}\n\n\tprivate static class ExceptionMapingComparator implements Comparator<ExceptionMapping> {\n\n\t\tprivate final ExceptionDepthComparator exceptionDepthComparator;\n\n\t\tprivate final MediaType mediaType;\n\n\t\tpublic ExceptionMapingComparator(Class<? extends Throwable> exceptionType, MediaType mediaType) {\n\t\t\tthis.exceptionDepthComparator = new ExceptionDepthComparator(exceptionType);\n\t\t\tthis.mediaType = mediaType;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compare(ExceptionMapping o1, ExceptionMapping o2) {\n\t\t\tint result = this.exceptionDepthComparator.compare(o1.exceptionType(), o2.exceptionType());\n\t\t\tif (result != 0) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tif(o1.mediaType.equals(this.mediaType)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(o2.mediaType.equals(this.mediaType)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (o1.mediaType.equals(o2.mediaType)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn (o1.mediaType.isMoreSpecific(o2.mediaType)) ? -1 : 1;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.method.annotation.ExceptionHandlerMethodResolver#compare(o1,o2)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o1",
      "o2"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "int",
    "signature": "public int compare(ExceptionMapping o1, ExceptionMapping o2)",
    "source_code": "\t\tpublic int compare(ExceptionMapping o1, ExceptionMapping o2) {\n\t\t\tint result = this.exceptionDepthComparator.compare(o1.exceptionType(), o2.exceptionType());\n\t\t\tif (result != 0) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tif(o1.mediaType.equals(this.mediaType)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(o2.mediaType.equals(this.mediaType)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (o1.mediaType.equals(o2.mediaType)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn (o1.mediaType.isMoreSpecific(o2.mediaType)) ? -1 : 1;\n\t\t}"
  },
  "org.springframework.web.method.annotation.ExceptionHandlerMethodResolver#hasExceptionMappings()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the contained type has any exception mappings.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "boolean",
    "signature": "public boolean hasExceptionMappings()",
    "source_code": "\tpublic boolean hasExceptionMappings() {\n\t\treturn !this.mappedMethods.isEmpty();\n\t}"
  },
  "org.springframework.web.method.annotation.ExceptionHandlerMethodResolver#resolveExceptionMapping(exception,mediaType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a {@link Method} to handle the given Throwable for the requested {@link MediaType}.\n\t * <p>Uses {@link ExceptionDepthComparator} and {@link MediaType#isMoreSpecific(MimeType)}\n\t * if more than one match is found.\n\t * @param exception the exception\n\t * @param mediaType the media type requested by the HTTP client\n\t * @return a Method to handle the exception, or {@code null} if none found\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exception",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "ExceptionHandlerMappingInfo",
    "signature": "public ExceptionHandlerMappingInfo resolveExceptionMapping(Throwable exception, MediaType mediaType)",
    "source_code": "\tpublic ExceptionHandlerMappingInfo resolveExceptionMapping(Throwable exception, MediaType mediaType) {\n\t\tExceptionHandlerMappingInfo mappingInfo = resolveExceptionMappingByExceptionType(exception.getClass(), mediaType);\n\t\tif (mappingInfo == null) {\n\t\t\tThrowable cause = exception.getCause();\n\t\t\tif (cause != null) {\n\t\t\t\tmappingInfo = resolveExceptionMapping(cause, mediaType);\n\t\t\t}\n\t\t}\n\t\treturn mappingInfo;\n\t}"
  },
  "org.springframework.web.method.annotation.ExceptionHandlerMethodResolver#resolveExceptionMappingByExceptionType(exceptionType,mediaType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a {@link Method} to handle the given exception type and media type.\n\t * This can be useful if an {@link Exception} instance is not available (for example, for tools).\n\t * @param exceptionType the exception type\n\t * @param mediaType the media type requested by the HTTP client\n\t * @return a Method to handle the exception, or {@code null} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exceptionType",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "ExceptionHandlerMappingInfo",
    "signature": "public ExceptionHandlerMappingInfo resolveExceptionMappingByExceptionType(Class<? extends Throwable> exceptionType, MediaType mediaType)",
    "source_code": "\tpublic ExceptionHandlerMappingInfo resolveExceptionMappingByExceptionType(Class<? extends Throwable> exceptionType, MediaType mediaType) {\n\t\tExceptionHandlerMappingInfo mappingInfo = this.lookupCache.get(new ExceptionMapping(exceptionType, mediaType));\n\t\treturn (mappingInfo != NO_MATCHING_EXCEPTION_HANDLER ? mappingInfo : null);\n\t}"
  },
  "org.springframework.web.method.annotation.ExceptionHandlerMethodResolver#resolveMethod(exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a {@link Method} to handle the given exception.\n\t * <p>Uses {@link ExceptionDepthComparator} if more than one match is found.\n\t * @param exception the exception\n\t * @return a Method to handle the exception, or {@code null} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "Method",
    "signature": "public Method resolveMethod(Exception exception)",
    "source_code": "\tpublic Method resolveMethod(Exception exception) {\n\t\tExceptionHandlerMappingInfo mappingInfo = resolveExceptionMapping(exception, MediaType.ALL);\n\t\treturn (mappingInfo != null) ? mappingInfo.getHandlerMethod() : null;\n\t}"
  },
  "org.springframework.web.method.annotation.ExceptionHandlerMethodResolver#resolveMethodByExceptionType(exceptionType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a {@link Method} to handle the given exception type. This can be\n\t * useful if an {@link Exception} instance is not available (for example, for tools).\n\t * <p>Uses {@link ExceptionDepthComparator} if more than one match is found.\n\t * @param exceptionType the exception type\n\t * @return a Method to handle the exception, or {@code null} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exceptionType"
    ],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "Method",
    "signature": "public Method resolveMethodByExceptionType(Class<? extends Throwable> exceptionType)",
    "source_code": "\tpublic Method resolveMethodByExceptionType(Class<? extends Throwable> exceptionType) {\n\t\tExceptionHandlerMappingInfo mappingInfo = resolveExceptionMappingByExceptionType(exceptionType, MediaType.ALL);\n\t\treturn (mappingInfo != null) ? mappingInfo.getHandlerMethod() : null;\n\t}"
  },
  "org.springframework.web.method.annotation.ExceptionHandlerMethodResolver#resolveMethodByThrowable(exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a {@link Method} to handle the given Throwable.\n\t * <p>Uses {@link ExceptionDepthComparator} if more than one match is found.\n\t * @param exception the exception\n\t * @return a Method to handle the exception, or {@code null} if none found\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "Method",
    "signature": "public Method resolveMethodByThrowable(Throwable exception)",
    "source_code": "\tpublic Method resolveMethodByThrowable(Throwable exception) {\n\t\tExceptionHandlerMappingInfo mappingInfo = resolveExceptionMapping(exception, MediaType.ALL);\n\t\treturn (mappingInfo != null) ? mappingInfo.getHandlerMethod() : null;\n\t}"
  },
  "org.springframework.web.method.annotation.ExceptionHandlerMethodResolver#toString()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn \"ExceptionHandler{\" +\n\t\t\t\t\t\"exceptionType=\" + this.exceptionType.getCanonicalName() +\n\t\t\t\t\t\", mediaType=\" + this.mediaType +\n\t\t\t\t\t'}';\n\t\t}"
  },
  "org.springframework.web.method.annotation.HandlerMethodValidationException": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * {@link ResponseStatusException} that is also {@link MethodValidationResult}.\n * Raised by {@link HandlerMethodValidator} in case of method validation errors\n * on a web controller method.\n *\n * <p>The {@link #getStatusCode()} is 400 for input validation errors, and 500\n * for validation errors on a return value.\n *\n * @author Rossen Stoyanchev\n * @since 6.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "signature": "public class HandlerMethodValidationException",
    "source_code": "public class HandlerMethodValidationException extends ResponseStatusException implements MethodValidationResult {\n\n\tprivate final MethodValidationResult validationResult;\n\n\tprivate final Predicate<MethodParameter> modelAttributePredicate;\n\n\tprivate final Predicate<MethodParameter> requestParamPredicate;\n\n\n\tpublic HandlerMethodValidationException(MethodValidationResult validationResult) {\n\t\tthis(validationResult,\n\t\t\t\tparam -> param.hasParameterAnnotation(ModelAttribute.class),\n\t\t\t\tparam -> param.hasParameterAnnotation(RequestParam.class));\n\t}\n\n\tpublic HandlerMethodValidationException(MethodValidationResult validationResult,\n\t\t\tPredicate<MethodParameter> modelAttributePredicate, Predicate<MethodParameter> requestParamPredicate) {\n\n\t\tsuper(initHttpStatus(validationResult), \"Validation failure\", null, null, null);\n\t\tthis.validationResult = validationResult;\n\t\tthis.modelAttributePredicate = modelAttributePredicate;\n\t\tthis.requestParamPredicate = requestParamPredicate;\n\t}\n\n\tprivate static HttpStatus initHttpStatus(MethodValidationResult validationResult) {\n\t\treturn (validationResult.isForReturnValue() ? HttpStatus.INTERNAL_SERVER_ERROR : HttpStatus.BAD_REQUEST);\n\t}\n\n\n\t@Override\n\tpublic Object[] getDetailMessageArguments(MessageSource messageSource, Locale locale) {\n\t\treturn new Object[] { BindErrorUtils.resolveAndJoin(getAllErrors(), messageSource, locale) };\n\t}\n\n\t@Override\n\tpublic Object[] getDetailMessageArguments() {\n\t\treturn new Object[] { BindErrorUtils.resolveAndJoin(getAllErrors()) };\n\t}\n\n\t@Override\n\tpublic Object getTarget() {\n\t\treturn this.validationResult.getTarget();\n\t}\n\n\t@Override\n\tpublic Method getMethod() {\n\t\treturn this.validationResult.getMethod();\n\t}\n\n\t@Override\n\tpublic boolean isForReturnValue() {\n\t\treturn this.validationResult.isForReturnValue();\n\t}\n\n\t@Override\n\tpublic List<ParameterValidationResult> getParameterValidationResults() {\n\t\treturn this.validationResult.getParameterValidationResults();\n\t}\n\n\t@Override\n\tpublic List<MessageSourceResolvable> getCrossParameterValidationResults() {\n\t\treturn this.validationResult.getCrossParameterValidationResults();\n\t}\n\n\t/**\n\t * Provide a {@link Visitor Visitor} to handle {@link ParameterValidationResult}s\n\t * through callback methods organized by controller method parameter type.\n\t */\n\tpublic void visitResults(Visitor visitor) {\n\t\tfor (ParameterValidationResult result : getParameterValidationResults()) {\n\t\t\tMethodParameter param = result.getMethodParameter();\n\t\t\tCookieValue cookieValue = param.getParameterAnnotation(CookieValue.class);\n\t\t\tif (cookieValue != null) {\n\t\t\t\tvisitor.cookieValue(cookieValue, result);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tMatrixVariable matrixVariable = param.getParameterAnnotation(MatrixVariable.class);\n\t\t\tif (matrixVariable != null) {\n\t\t\t\tvisitor.matrixVariable(matrixVariable, result);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (this.modelAttributePredicate.test(param)) {\n\t\t\t\tModelAttribute modelAttribute = param.getParameterAnnotation(ModelAttribute.class);\n\t\t\t\tvisitor.modelAttribute(modelAttribute, asErrors(result));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tPathVariable pathVariable = param.getParameterAnnotation(PathVariable.class);\n\t\t\tif (pathVariable != null) {\n\t\t\t\tvisitor.pathVariable(pathVariable, result);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRequestBody requestBody = param.getParameterAnnotation(RequestBody.class);\n\t\t\tif (requestBody != null) {\n\t\t\t\tif (result instanceof ParameterErrors errors) {\n\t\t\t\t\tvisitor.requestBody(requestBody, errors);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvisitor.requestBodyValidationResult(requestBody, result);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRequestHeader requestHeader = param.getParameterAnnotation(RequestHeader.class);\n\t\t\tif (requestHeader != null) {\n\t\t\t\tvisitor.requestHeader(requestHeader, result);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (this.requestParamPredicate.test(param)) {\n\t\t\t\tRequestParam requestParam = param.getParameterAnnotation(RequestParam.class);\n\t\t\t\tvisitor.requestParam(requestParam, result);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRequestPart requestPart = param.getParameterAnnotation(RequestPart.class);\n\t\t\tif (requestPart != null) {\n\t\t\t\tvisitor.requestPart(requestPart, asErrors(result));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvisitor.other(result);\n\t\t}\n\t}\n\n\tprivate static ParameterErrors asErrors(ParameterValidationResult result) {\n\t\tAssert.state(result instanceof ParameterErrors, \"Expected ParameterErrors\");\n\t\treturn (ParameterErrors) result;\n\t}\n\n\n\t/**\n\t * Contract to handle validation results with callbacks by controller method\n\t * parameter type, with {@link #other} serving as the fallthrough.\n\t */\n\tpublic interface Visitor {\n\n\t\t/**\n\t\t * Handle results for {@code @CookieValue} method parameters.\n\t\t * @param cookieValue the annotation declared on the parameter\n\t\t * @param result the validation result\n\t\t */\n\t\tvoid cookieValue(CookieValue cookieValue, ParameterValidationResult result);\n\n\t\t/**\n\t\t * Handle results for {@code @MatrixVariable} method parameters.\n\t\t * @param matrixVariable the annotation declared on the parameter\n\t\t * @param result the validation result\n\t\t */\n\t\tvoid matrixVariable(MatrixVariable matrixVariable, ParameterValidationResult result);\n\n\t\t/**\n\t\t * Handle results for {@code @ModelAttribute} method parameters.\n\t\t * @param modelAttribute the optional {@code ModelAttribute} annotation,\n\t\t * possibly {@code null} if the method parameter is declared without it.\n\t\t * @param errors the validation errors\n\t\t */\n\t\tvoid modelAttribute(@Nullable ModelAttribute modelAttribute, ParameterErrors errors);\n\n\t\t/**\n\t\t * Handle results for {@code @PathVariable} method parameters.\n\t\t * @param pathVariable the annotation declared on the parameter\n\t\t * @param result the validation result\n\t\t */\n\t\tvoid pathVariable(PathVariable pathVariable, ParameterValidationResult result);\n\n\t\t/**\n\t\t * Handle results for {@code @RequestBody} method parameters.\n\t\t * @param requestBody the annotation declared on the parameter\n\t\t * @param errors the validation error\n\t\t */\n\t\tvoid requestBody(RequestBody requestBody, ParameterErrors errors);\n\n\t\t/**\n\t\t * An additional {@code @RequestBody} callback for validation failures\n\t\t * for constraints on the method parameter. For example:\n\t\t * <pre class=\"code\">\n\t\t * &#064;RequestBody List&lt;&#064;NotEmpty String&gt; ids\n\t\t * </pre>\n\t\t * Handle results for {@code @RequestBody} method parameters.\n\t\t * @param requestBody the annotation declared on the parameter\n\t\t * @param result the validation result\n\t\t * @since 6.2.4\n\t\t */\n\t\tdefault void requestBodyValidationResult(RequestBody requestBody, ParameterValidationResult result) {\n\t\t}\n\n\t\t/**\n\t\t * Handle results for {@code @RequestHeader} method parameters.\n\t\t * @param requestHeader the annotation declared on the parameter\n\t\t * @param result the validation result\n\t\t */\n\t\tvoid requestHeader(RequestHeader requestHeader, ParameterValidationResult result);\n\n\t\t/**\n\t\t * Handle results for {@code @RequestParam} method parameters.\n\t\t * @param requestParam the optional {@code RequestParam} annotation,\n\t\t * possibly {@code null} if the method parameter is declared without it.\n\t\t * @param result the validation result\n\t\t */\n\t\tvoid requestParam(@Nullable RequestParam requestParam, ParameterValidationResult result);\n\n\t\t/**\n\t\t * Handle results for {@code @RequestPart} method parameters.\n\t\t * @param requestPart the annotation declared on the parameter\n\t\t * @param errors the validation errors\n\t\t */\n\t\tvoid requestPart(RequestPart requestPart, ParameterErrors errors);\n\n\t\t/**\n\t\t * Handle other results that aren't any of the above.\n\t\t * @param result the validation result\n\t\t */\n\t\tvoid other(ParameterValidationResult result);\n\n\t}\n\n}"
  },
  "org.springframework.web.method.annotation.HandlerMethodValidationException#getCrossParameterValidationResults()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "List<MessageSourceResolvable>",
    "signature": "public List<MessageSourceResolvable> getCrossParameterValidationResults()",
    "source_code": "\tpublic List<MessageSourceResolvable> getCrossParameterValidationResults() {\n\t\treturn this.validationResult.getCrossParameterValidationResults();\n\t}"
  },
  "org.springframework.web.method.annotation.HandlerMethodValidationException#getDetailMessageArguments()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "Object[]",
    "signature": "public Object[] getDetailMessageArguments()",
    "source_code": "\tpublic Object[] getDetailMessageArguments() {\n\t\treturn new Object[] { BindErrorUtils.resolveAndJoin(getAllErrors()) };\n\t}"
  },
  "org.springframework.web.method.annotation.HandlerMethodValidationException#getDetailMessageArguments(messageSource,locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSource",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "Object[]",
    "signature": "public Object[] getDetailMessageArguments(MessageSource messageSource, Locale locale)",
    "source_code": "\tpublic Object[] getDetailMessageArguments(MessageSource messageSource, Locale locale) {\n\t\treturn new Object[] { BindErrorUtils.resolveAndJoin(getAllErrors(), messageSource, locale) };\n\t}"
  },
  "org.springframework.web.method.annotation.HandlerMethodValidationException#getMethod()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "Method",
    "signature": "public Method getMethod()",
    "source_code": "\tpublic Method getMethod() {\n\t\treturn this.validationResult.getMethod();\n\t}"
  },
  "org.springframework.web.method.annotation.HandlerMethodValidationException#getParameterValidationResults()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "List<ParameterValidationResult>",
    "signature": "public List<ParameterValidationResult> getParameterValidationResults()",
    "source_code": "\tpublic List<ParameterValidationResult> getParameterValidationResults() {\n\t\treturn this.validationResult.getParameterValidationResults();\n\t}"
  },
  "org.springframework.web.method.annotation.HandlerMethodValidationException#getTarget()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "Object",
    "signature": "public Object getTarget()",
    "source_code": "\tpublic Object getTarget() {\n\t\treturn this.validationResult.getTarget();\n\t}"
  },
  "org.springframework.web.method.annotation.HandlerMethodValidationException#isForReturnValue()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "boolean",
    "signature": "public boolean isForReturnValue()",
    "source_code": "\tpublic boolean isForReturnValue() {\n\t\treturn this.validationResult.isForReturnValue();\n\t}"
  },
  "org.springframework.web.method.annotation.HandlerMethodValidationException#visitResults(visitor)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide a {@link Visitor Visitor} to handle {@link ParameterValidationResult}s\n\t * through callback methods organized by controller method parameter type.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "visitor"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "void",
    "signature": "public void visitResults(Visitor visitor)",
    "source_code": "\tpublic void visitResults(Visitor visitor) {\n\t\tfor (ParameterValidationResult result : getParameterValidationResults()) {\n\t\t\tMethodParameter param = result.getMethodParameter();\n\t\t\tCookieValue cookieValue = param.getParameterAnnotation(CookieValue.class);\n\t\t\tif (cookieValue != null) {\n\t\t\t\tvisitor.cookieValue(cookieValue, result);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tMatrixVariable matrixVariable = param.getParameterAnnotation(MatrixVariable.class);\n\t\t\tif (matrixVariable != null) {\n\t\t\t\tvisitor.matrixVariable(matrixVariable, result);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (this.modelAttributePredicate.test(param)) {\n\t\t\t\tModelAttribute modelAttribute = param.getParameterAnnotation(ModelAttribute.class);\n\t\t\t\tvisitor.modelAttribute(modelAttribute, asErrors(result));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tPathVariable pathVariable = param.getParameterAnnotation(PathVariable.class);\n\t\t\tif (pathVariable != null) {\n\t\t\t\tvisitor.pathVariable(pathVariable, result);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRequestBody requestBody = param.getParameterAnnotation(RequestBody.class);\n\t\t\tif (requestBody != null) {\n\t\t\t\tif (result instanceof ParameterErrors errors) {\n\t\t\t\t\tvisitor.requestBody(requestBody, errors);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvisitor.requestBodyValidationResult(requestBody, result);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRequestHeader requestHeader = param.getParameterAnnotation(RequestHeader.class);\n\t\t\tif (requestHeader != null) {\n\t\t\t\tvisitor.requestHeader(requestHeader, result);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (this.requestParamPredicate.test(param)) {\n\t\t\t\tRequestParam requestParam = param.getParameterAnnotation(RequestParam.class);\n\t\t\t\tvisitor.requestParam(requestParam, result);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRequestPart requestPart = param.getParameterAnnotation(RequestPart.class);\n\t\t\tif (requestPart != null) {\n\t\t\t\tvisitor.requestPart(requestPart, asErrors(result));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvisitor.other(result);\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.Visitor": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Contract to handle validation results with callbacks by controller method\n\t * parameter type, with {@link #other} serving as the fallthrough.\n\t */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 186
    },
    "signature": "public interface Visitor",
    "source_code": "\tpublic interface Visitor {\n\n\t\t/**\n\t\t * Handle results for {@code @CookieValue} method parameters.\n\t\t * @param cookieValue the annotation declared on the parameter\n\t\t * @param result the validation result\n\t\t */\n\t\tvoid cookieValue(CookieValue cookieValue, ParameterValidationResult result);\n\n\t\t/**\n\t\t * Handle results for {@code @MatrixVariable} method parameters.\n\t\t * @param matrixVariable the annotation declared on the parameter\n\t\t * @param result the validation result\n\t\t */\n\t\tvoid matrixVariable(MatrixVariable matrixVariable, ParameterValidationResult result);\n\n\t\t/**\n\t\t * Handle results for {@code @ModelAttribute} method parameters.\n\t\t * @param modelAttribute the optional {@code ModelAttribute} annotation,\n\t\t * possibly {@code null} if the method parameter is declared without it.\n\t\t * @param errors the validation errors\n\t\t */\n\t\tvoid modelAttribute(@Nullable ModelAttribute modelAttribute, ParameterErrors errors);\n\n\t\t/**\n\t\t * Handle results for {@code @PathVariable} method parameters.\n\t\t * @param pathVariable the annotation declared on the parameter\n\t\t * @param result the validation result\n\t\t */\n\t\tvoid pathVariable(PathVariable pathVariable, ParameterValidationResult result);\n\n\t\t/**\n\t\t * Handle results for {@code @RequestBody} method parameters.\n\t\t * @param requestBody the annotation declared on the parameter\n\t\t * @param errors the validation error\n\t\t */\n\t\tvoid requestBody(RequestBody requestBody, ParameterErrors errors);\n\n\t\t/**\n\t\t * An additional {@code @RequestBody} callback for validation failures\n\t\t * for constraints on the method parameter. For example:\n\t\t * <pre class=\"code\">\n\t\t * &#064;RequestBody List&lt;&#064;NotEmpty String&gt; ids\n\t\t * </pre>\n\t\t * Handle results for {@code @RequestBody} method parameters.\n\t\t * @param requestBody the annotation declared on the parameter\n\t\t * @param result the validation result\n\t\t * @since 6.2.4\n\t\t */\n\t\tdefault void requestBodyValidationResult(RequestBody requestBody, ParameterValidationResult result) {\n\t\t}\n\n\t\t/**\n\t\t * Handle results for {@code @RequestHeader} method parameters.\n\t\t * @param requestHeader the annotation declared on the parameter\n\t\t * @param result the validation result\n\t\t */\n\t\tvoid requestHeader(RequestHeader requestHeader, ParameterValidationResult result);\n\n\t\t/**\n\t\t * Handle results for {@code @RequestParam} method parameters.\n\t\t * @param requestParam the optional {@code RequestParam} annotation,\n\t\t * possibly {@code null} if the method parameter is declared without it.\n\t\t * @param result the validation result\n\t\t */\n\t\tvoid requestParam(@Nullable RequestParam requestParam, ParameterValidationResult result);\n\n\t\t/**\n\t\t * Handle results for {@code @RequestPart} method parameters.\n\t\t * @param requestPart the annotation declared on the parameter\n\t\t * @param errors the validation errors\n\t\t */\n\t\tvoid requestPart(RequestPart requestPart, ParameterErrors errors);\n\n\t\t/**\n\t\t * Handle other results that aren't any of the above.\n\t\t * @param result the validation result\n\t\t */\n\t\tvoid other(ParameterValidationResult result);\n\n\t}"
  },
  "org.springframework.web.reactive.BindingContext#createBinderInstance(target,name)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Extension point to create the WebDataBinder instance.\n\t * By default, this is {@code WebRequestDataBinder}.\n\t * @param target the binding target or {@code null} for type conversion only\n\t * @param name the binding target object name\n\t * @return the created {@link WebExchangeDataBinder} instance\n\t * @since 6.2.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "WebExchangeDataBinder",
    "signature": "protected WebExchangeDataBinder createBinderInstance(@Nullable Object target, String name)",
    "source_code": "\tprotected WebExchangeDataBinder createBinderInstance(@Nullable Object target, String name) {\n\t\treturn new WebExchangeDataBinder(target, name);\n\t}"
  },
  "org.springframework.web.reactive.BindingContext#getValuesToBind(exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "Object>>",
    "signature": "public Object>> getValuesToBind(ServerWebExchange exchange)",
    "source_code": "\t\tpublic Mono<Map<String, Object>> getValuesToBind(ServerWebExchange exchange) {\n\t\t\treturn super.getValuesToBind(exchange).doOnNext(map ->\n\t\t\t\t\tmap.putAll(exchange.<Map<String, String>>getAttributeOrDefault(\n\t\t\t\t\t\t\tHandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE, Collections.emptyMap())));\n\t\t}"
  },
  "org.springframework.web.reactive.function.BodyInserters#fromValue(body,bodyType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter to write the given value.\n\t * <p>Alternatively, consider using the {@code bodyValue(Object, ParameterizedTypeReference)} shortcuts on\n\t * {@link org.springframework.web.reactive.function.client.WebClient WebClient} and\n\t * {@link org.springframework.web.reactive.function.server.ServerResponse ServerResponse}.\n\t * @param body the value to write\n\t * @param bodyType the type of the body, used to capture the generic type\n\t * @param <T> the type of the body\n\t * @return the inserter to write a single value\n\t * @throws IllegalArgumentException if {@code body} is a {@link Publisher} or an\n\t * instance of a type supported by {@link ReactiveAdapterRegistry#getSharedInstance()},\n\t * for which {@link #fromPublisher(Publisher, ParameterizedTypeReference)} or\n\t * {@link #fromProducer(Object, ParameterizedTypeReference)} should be used.\n\t * @since 6.2\n\t * @see #fromPublisher(Publisher, ParameterizedTypeReference)\n\t * @see #fromProducer(Object, ParameterizedTypeReference)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> fromValue(T body, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic static <T> BodyInserter<T, ReactiveHttpOutputMessage> fromValue(T body, ParameterizedTypeReference<T> bodyType) {\n\t\tAssert.notNull(body, \"'body' must not be null\");\n\t\tAssert.notNull(bodyType, \"'bodyType' must not be null\");\n\t\tAssert.isNull(registry.getAdapter(body.getClass()),\n\t\t\t\t\"'body' should be an object, for reactive types use a variant specifying a publisher/producer and its related element type\");\n\t\treturn (message, context) ->\n\t\t\t\twriteWithMessageWriters(message, context, Mono.just(body), ResolvableType.forType(bodyType), null);\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#getAttributes()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "Object>",
    "signature": "public Object> getAttributes()",
    "source_code": "\t\tpublic Map<String, Object> getAttributes() {\n\t\t\treturn Collections.emptyMap();\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.support.WebClientAdapter#forClient(webClient)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link WebClientAdapter} for the given {@code WebClient} instance.\n\t * @param webClient the client to use\n\t * @return the created adapter instance\n\t * @deprecated in favor of {@link #create(WebClient)} aligning with other adapter\n\t * implementations; to be removed in 6.2.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webClient"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "WebClientAdapter",
    "signature": "public WebClientAdapter forClient(WebClient webClient)",
    "source_code": "\tpublic static WebClientAdapter forClient(WebClient webClient) {\n\t\treturn new WebClientAdapter(webClient);\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#apply(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "Mono<Resource>",
    "signature": "public Mono<Resource> apply(ServerRequest request)",
    "source_code": "\tpublic Mono<Resource> apply(ServerRequest request) {\n\t\tPathContainer pathContainer = request.requestPath().pathWithinApplication();\n\t\tif (!this.pattern.matches(pathContainer)) {\n\t\t\treturn Mono.empty();\n\t\t}\n\n\t\tpathContainer = this.pattern.extractPathWithinPattern(pathContainer);\n\t\tString path = processPath(pathContainer.value());\n\t\tif (!StringUtils.hasText(path) || isInvalidPath(path)) {\n\t\t\treturn Mono.empty();\n\t\t}\n\t\tif (isInvalidEncodedInputPath(path)) {\n\t\t\treturn Mono.empty();\n\t\t}\n\n\t\tif (!(this.location instanceof UrlResource)) {\n\t\t\tpath = UriUtils.decode(path, StandardCharsets.UTF_8);\n\t\t}\n\n\t\ttry {\n\t\t\tResource resource = this.location.createRelative(path);\n\t\t\tif (resource.isReadable() && isResourceUnderLocation(resource)) {\n\t\t\t\treturn Mono.just(resource);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn Mono.empty();\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new UncheckedIOException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#bodyValue(body,bodyType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> bodyValue(T body, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic <T> Mono<ServerResponse> bodyValue(T body, ParameterizedTypeReference<T> bodyType) {\n\t\treturn initBuilder(body, BodyInserters.fromValue(body, bodyType));\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#build()": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "Mono<RenderingResponse>",
    "signature": "public Mono<RenderingResponse> build()",
    "source_code": "\tpublic Mono<RenderingResponse> build() {\n\t\treturn Mono.just(\n\t\t\t\tnew DefaultRenderingResponse(this.status, this.headers, this.cookies, this.name, this.model));\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#processPath(path)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Process the given resource path.\n\t * <p>The default implementation replaces:\n\t * <ul>\n\t * <li>Backslash with forward slash.\n\t * <li>Duplicate occurrences of slash with a single slash.\n\t * <li>Any combination of leading slash and control characters (00-1F and 7F)\n\t * with a single \"/\" or \"\". For example {@code \"  / // foo/bar\"}\n\t * becomes {@code \"/foo/bar\"}.\n\t * </ul>\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "path"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "String",
    "signature": "protected String processPath(String path)",
    "source_code": "\tprotected String processPath(String path) {\n\t\tpath = StringUtils.replace(path, \"\\\\\", \"/\");\n\t\tpath = cleanDuplicateSlashes(path);\n\t\tpath = cleanLeadingSlash(path);\n\t\treturn normalizePath(path);\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 257
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn this.pattern + \" -> \" + this.location;\n\t}"
  },
  "org.springframework.web.reactive.resource.PathResourceResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A simple {@code ResourceResolver} that tries to find a resource under the given\n * locations matching to the request path.\n *\n * <p>This resolver does not delegate to the {@code ResourceResolverChain} and is\n * expected to be configured at the end in a chain of resolvers.\n *\n * @author Rossen Stoyanchev\n * @author Sam Brannen\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public class PathResourceResolver",
    "source_code": "public class PathResourceResolver extends AbstractResourceResolver {\n\n\t@Nullable\n\tprivate Resource[] allowedLocations;\n\n\n\t/**\n\t * By default, when a Resource is found, the path of the resolved resource is\n\t * compared to ensure it's under the input location where it was found.\n\t * However sometimes that may not be the case, e.g. when\n\t * {@link CssLinkResourceTransformer}\n\t * resolves public URLs of links it contains, the CSS file is the location\n\t * and the resources being resolved are css files, images, fonts and others\n\t * located in adjacent or parent directories.\n\t * <p>This property allows configuring a complete list of locations under\n\t * which resources must be so that if a resource is not under the location\n\t * relative to which it was found, this list may be checked as well.\n\t * <p>By default {@link ResourceWebHandler} initializes this property\n\t * to match its list of locations.\n\t * @param locations the list of allowed locations\n\t */\n\tpublic void setAllowedLocations(@Nullable Resource... locations) {\n\t\tthis.allowedLocations = locations;\n\t}\n\n\t@Nullable\n\tpublic Resource[] getAllowedLocations() {\n\t\treturn this.allowedLocations;\n\t}\n\n\n\t@Override\n\tprotected Mono<Resource> resolveResourceInternal(@Nullable ServerWebExchange exchange,\n\t\t\tString requestPath, List<? extends Resource> locations, ResourceResolverChain chain) {\n\n\t\treturn getResource(requestPath, locations);\n\t}\n\n\t@Override\n\tprotected Mono<String> resolveUrlPathInternal(String path, List<? extends Resource> locations,\n\t\t\tResourceResolverChain chain) {\n\n\t\tif (StringUtils.hasText(path)) {\n\t\t\treturn getResource(path, locations).map(resource -> path);\n\t\t}\n\t\telse {\n\t\t\treturn Mono.empty();\n\t\t}\n\t}\n\n\tprivate Mono<Resource> getResource(String resourcePath, List<? extends Resource> locations) {\n\t\treturn Flux.fromIterable(locations)\n\t\t\t\t.concatMap(location -> getResource(resourcePath, location))\n\t\t\t\t.next();\n\t}\n\n\t/**\n\t * Find the resource under the given location.\n\t * <p>The default implementation checks if there is a readable\n\t * {@code Resource} for the given path relative to the location.\n\t * @param resourcePath the path to the resource\n\t * @param location the location to check\n\t * @return the resource, or empty {@link Mono} if none found\n\t */\n\tprotected Mono<Resource> getResource(String resourcePath, Resource location) {\n\t\ttry {\n\t\t\tif (!(location instanceof UrlResource)) {\n\t\t\t\tresourcePath = UriUtils.decode(resourcePath, StandardCharsets.UTF_8);\n\t\t\t}\n\t\t\tResource resource = location.createRelative(resourcePath);\n\t\t\tif (resource.isReadable()) {\n\t\t\t\tif (checkResource(resource, location)) {\n\t\t\t\t\treturn Mono.just(resource);\n\t\t\t\t}\n\t\t\t\telse if (logger.isWarnEnabled()) {\n\t\t\t\t\tResource[] allowed = getAllowedLocations();\n\t\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\t\"Resource path \\\"\" + resourcePath + \"\\\" was successfully resolved \" +\n\t\t\t\t\t\t\t\t\t\"but resource \\\"\" + resource + \"\\\" is neither under the \" +\n\t\t\t\t\t\t\t\t\t\"current location \\\"\" + location + \"\\\" nor under any of the \" +\n\t\t\t\t\t\t\t\t\t\"allowed locations \" + (allowed != null ? Arrays.asList(allowed) : \"[]\"), -1, true));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Mono.empty();\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tString error = \"Skip location [\" + location + \"] due to error\";\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(error, ex);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlogger.debug(error + \": \" + ex.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Mono.error(ex);\n\t\t}\n\t}\n\n\t/**\n\t * Perform additional checks on a resolved resource beyond checking whether the\n\t * resource exists and is readable. The default implementation also verifies\n\t * the resource is either under the location relative to which it was found or\n\t * is under one of the {@link #setAllowedLocations allowed locations}.\n\t * @param resource the resource to check\n\t * @param location the location relative to which the resource was found\n\t * @return \"true\" if resource is in a valid location, \"false\" otherwise\n\t */\n\tprotected boolean checkResource(Resource resource, Resource location) throws IOException {\n\t\tif (isResourceUnderLocation(resource, location)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (getAllowedLocations() != null) {\n\t\t\tfor (Resource current : getAllowedLocations()) {\n\t\t\t\tif (isResourceUnderLocation(resource, current)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean isResourceUnderLocation(Resource resource, Resource location) throws IOException {\n\t\tif (resource.getClass() != location.getClass()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tString resourcePath;\n\t\tString locationPath;\n\n\t\tif (resource instanceof UrlResource) {\n\t\t\tresourcePath = resource.getURL().toExternalForm();\n\t\t\tlocationPath = StringUtils.cleanPath(location.getURL().toString());\n\t\t}\n\t\telse if (resource instanceof ClassPathResource classPathResource) {\n\t\t\tresourcePath = classPathResource.getPath();\n\t\t\tlocationPath = StringUtils.cleanPath(((ClassPathResource) location).getPath());\n\t\t}\n\t\telse {\n\t\t\tresourcePath = resource.getURL().getPath();\n\t\t\tlocationPath = StringUtils.cleanPath(location.getURL().getPath());\n\t\t}\n\n\t\tif (locationPath.equals(resourcePath)) {\n\t\t\treturn true;\n\t\t}\n\t\tlocationPath = (locationPath.endsWith(\"/\") || locationPath.isEmpty() ? locationPath : locationPath + \"/\");\n\t\treturn (resourcePath.startsWith(locationPath) && !isInvalidEncodedPath(resourcePath));\n\t}\n\n\tprivate boolean isInvalidEncodedPath(String resourcePath) {\n\t\tif (resourcePath.contains(\"%\")) {\n\t\t\t// Use URLDecoder (vs UriUtils) to preserve potentially decoded UTF-8 chars...\n\t\t\ttry {\n\t\t\t\tString decodedPath = URLDecoder.decode(resourcePath, StandardCharsets.UTF_8);\n\t\t\t\tif (decodedPath.contains(\"../\") || decodedPath.contains(\"..\\\\\")) {\n\t\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\t\"Resolved resource path contains encoded \\\"../\\\" or \\\"..\\\\\\\": \" + resourcePath, -1, true));\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t// May not be possible to decode...\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n}"
  },
  "org.springframework.web.reactive.resource.PathResourceResolver#checkResource(resource,location)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform additional checks on a resolved resource beyond checking whether the\n\t * resource exists and is readable. The default implementation also verifies\n\t * the resource is either under the location relative to which it was found or\n\t * is under one of the {@link #setAllowedLocations allowed locations}.\n\t * @param resource the resource to check\n\t * @param location the location relative to which the resource was found\n\t * @return \"true\" if resource is in a valid location, \"false\" otherwise\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resource",
      "location"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "boolean",
    "signature": "protected boolean checkResource(Resource resource, Resource location)",
    "source_code": "\tprotected boolean checkResource(Resource resource, Resource location) throws IOException {\n\t\tif (isResourceUnderLocation(resource, location)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (getAllowedLocations() != null) {\n\t\t\tfor (Resource current : getAllowedLocations()) {\n\t\t\t\tif (isResourceUnderLocation(resource, current)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.reactive.resource.PathResourceResolver#getAllowedLocations()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "Resource[]",
    "signature": "public Resource[] getAllowedLocations()",
    "source_code": "\tpublic Resource[] getAllowedLocations() {\n\t\treturn this.allowedLocations;\n\t}"
  },
  "org.springframework.web.reactive.resource.PathResourceResolver#getResource(resourcePath,location)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the resource under the given location.\n\t * <p>The default implementation checks if there is a readable\n\t * {@code Resource} for the given path relative to the location.\n\t * @param resourcePath the path to the resource\n\t * @param location the location to check\n\t * @return the resource, or empty {@link Mono} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourcePath",
      "location"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "Mono<Resource>",
    "signature": "protected Mono<Resource> getResource(String resourcePath, Resource location)",
    "source_code": "\tprotected Mono<Resource> getResource(String resourcePath, Resource location) {\n\t\ttry {\n\t\t\tif (!(location instanceof UrlResource)) {\n\t\t\t\tresourcePath = UriUtils.decode(resourcePath, StandardCharsets.UTF_8);\n\t\t\t}\n\t\t\tResource resource = location.createRelative(resourcePath);\n\t\t\tif (resource.isReadable()) {\n\t\t\t\tif (checkResource(resource, location)) {\n\t\t\t\t\treturn Mono.just(resource);\n\t\t\t\t}\n\t\t\t\telse if (logger.isWarnEnabled()) {\n\t\t\t\t\tResource[] allowed = getAllowedLocations();\n\t\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\t\"Resource path \\\"\" + resourcePath + \"\\\" was successfully resolved \" +\n\t\t\t\t\t\t\t\t\t\"but resource \\\"\" + resource + \"\\\" is neither under the \" +\n\t\t\t\t\t\t\t\t\t\"current location \\\"\" + location + \"\\\" nor under any of the \" +\n\t\t\t\t\t\t\t\t\t\"allowed locations \" + (allowed != null ? Arrays.asList(allowed) : \"[]\"), -1, true));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Mono.empty();\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tString error = \"Skip location [\" + location + \"] due to error\";\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(error, ex);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlogger.debug(error + \": \" + ex.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Mono.error(ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.resource.PathResourceResolver#resolveResourceInternal(exchange,requestPath,locations,chain)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exchange",
      "requestPath",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "Mono<Resource>",
    "signature": "protected Mono<Resource> resolveResourceInternal(@Nullable ServerWebExchange exchange,\n\t\t\tString requestPath, List<? extends Resource> locations, ResourceResolverChain chain)",
    "source_code": "\tprotected Mono<Resource> resolveResourceInternal(@Nullable ServerWebExchange exchange,"
  },
  "org.springframework.web.reactive.resource.PathResourceResolver#resolveUrlPathInternal(path,locations,chain)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "path",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "Mono<String>",
    "signature": "protected Mono<String> resolveUrlPathInternal(String path, List<? extends Resource> locations,\n\t\t\tResourceResolverChain chain)",
    "source_code": "\tprotected Mono<String> resolveUrlPathInternal(String path, List<? extends Resource> locations,"
  },
  "org.springframework.web.reactive.resource.PathResourceResolver#setAllowedLocations(locations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * By default, when a Resource is found, the path of the resolved resource is\n\t * compared to ensure it's under the input location where it was found.\n\t * However sometimes that may not be the case, e.g. when\n\t * {@link CssLinkResourceTransformer}\n\t * resolves public URLs of links it contains, the CSS file is the location\n\t * and the resources being resolved are css files, images, fonts and others\n\t * located in adjacent or parent directories.\n\t * <p>This property allows configuring a complete list of locations under\n\t * which resources must be so that if a resource is not under the location\n\t * relative to which it was found, this list may be checked as well.\n\t * <p>By default {@link ResourceWebHandler} initializes this property\n\t * to match its list of locations.\n\t * @param locations the list of allowed locations\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locations"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "public void setAllowedLocations(@Nullable Resource... locations)",
    "source_code": "\tpublic void setAllowedLocations(@Nullable Resource... locations) {\n\t\tthis.allowedLocations = locations;\n\t}"
  },
  "org.springframework.web.reactive.resource.ResourceHandlerUtils": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Resource handling utility methods to share common logic between\n * {@link ResourceWebHandler} and {@link org.springframework.web.reactive.function.server}.\n *\n * @author Rossen Stoyanchev\n * @since 6.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "signature": "public class ResourceHandlerUtils",
    "source_code": "public abstract class ResourceHandlerUtils {\n\n\tprivate static final Log logger = LogFactory.getLog(ResourceHandlerUtils.class);\n\n\tprivate static final String FOLDER_SEPARATOR = \"/\";\n\n\tprivate static final String WINDOWS_FOLDER_SEPARATOR = \"\\\\\";\n\n\n\t/**\n\t * Assert the given location is not null, and its path ends on slash.\n\t */\n\tpublic static void assertResourceLocation(@Nullable Resource location) {\n\t\tAssert.notNull(location, \"Resource location must not be null\");\n\t\ttry {\n\t\t\tString path;\n\t\t\tif (location instanceof org.springframework.core.io.PathResource) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if (location instanceof FileSystemResource fileSystemResource) {\n\t\t\t\tpath = fileSystemResource.getPath();\n\t\t\t}\n\t\t\telse if (location instanceof ClassPathResource classPathResource) {\n\t\t\t\tpath = classPathResource.getPath();\n\t\t\t}\n\t\t\telse if (location instanceof UrlResource) {\n\t\t\t\tpath = location.getURL().toExternalForm();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpath = location.getURL().getPath();\n\t\t\t}\n\t\t\tAssert.isTrue(path.endsWith(FOLDER_SEPARATOR) || path.endsWith(WINDOWS_FOLDER_SEPARATOR),\n\t\t\t\t\t\"Resource location does not end with slash: \" + path);\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\t// ignore\n\t\t}\n\t}\n\n\t/**\n\t * Check if the given static resource location path ends with a trailing\n\t * slash, and append it if necessary.\n\t * @param path the location path\n\t * @return the resulting path to use\n\t */\n\tpublic static String initLocationPath(String path) {\n\t\tString separator = (path.contains(FOLDER_SEPARATOR) ? FOLDER_SEPARATOR : WINDOWS_FOLDER_SEPARATOR);\n\t\tif (!path.endsWith(separator)) {\n\t\t\tpath = path.concat(separator);\n\t\t\tlogger.warn(\"Appended trailing slash to static resource location: \" + path);\n\t\t}\n\t\treturn path;\n\t}\n\n\t/**\n\t * Normalize the given resource path replacing the following:\n\t * <ul>\n\t * <li>Backslash with forward slash.\n\t * <li>Duplicate occurrences of slash with a single slash.\n\t * <li>Any combination of leading slash and control characters (00-1F and 7F)\n\t * with a single \"/\" or \"\". For example {@code \"  / // foo/bar\"}\n\t * becomes {@code \"/foo/bar\"}.\n\t * </ul>\n\t */\n\tpublic static String normalizeInputPath(String path) {\n\t\tpath = StringUtils.replace(path, \"\\\\\", \"/\");\n\t\tpath = cleanDuplicateSlashes(path);\n\t\treturn cleanLeadingSlash(path);\n\t}\n\n\tprivate static String cleanDuplicateSlashes(String path) {\n\t\tStringBuilder sb = null;\n\t\tchar prev = 0;\n\t\tfor (int i = 0; i < path.length(); i++) {\n\t\t\tchar curr = path.charAt(i);\n\t\t\ttry {\n\t\t\t\tif (curr == '/' && prev == '/') {\n\t\t\t\t\tif (sb == null) {\n\t\t\t\t\t\tsb = new StringBuilder(path.substring(0, i));\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (sb != null) {\n\t\t\t\t\tsb.append(path.charAt(i));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tprev = curr;\n\t\t\t}\n\t\t}\n\t\treturn (sb != null ? sb.toString() : path);\n\t}\n\n\tprivate static String cleanLeadingSlash(String path) {\n\t\tboolean slash = false;\n\t\tfor (int i = 0; i < path.length(); i++) {\n\t\t\tif (path.charAt(i) == '/') {\n\t\t\t\tslash = true;\n\t\t\t}\n\t\t\telse if (path.charAt(i) > ' ' && path.charAt(i) != 127) {\n\t\t\t\tif (i == 0 || (i == 1 && slash)) {\n\t\t\t\t\treturn path;\n\t\t\t\t}\n\t\t\t\treturn (slash ? \"/\" + path.substring(i) : path.substring(i));\n\t\t\t}\n\t\t}\n\t\treturn (slash ? \"/\" : \"\");\n\t}\n\n\t/**\n\t * Whether the given input path is invalid as determined by\n\t * {@link #isInvalidPath(String)}. The path is also decoded and the same\n\t * checks are performed again.\n\t */\n\tpublic static boolean shouldIgnoreInputPath(String path) {\n\t\treturn (!StringUtils.hasText(path) || isInvalidPath(path) || isInvalidEncodedPath(path));\n\t}\n\n\t/**\n\t * Checks for invalid resource input paths rejecting the following:\n\t * <ul>\n\t * <li>Paths that contain \"WEB-INF\" or \"META-INF\"\n\t * <li>Paths that contain \"../\" after a call to\n\t * {@link StringUtils#cleanPath}.\n\t * <li>Paths that represent a {@link ResourceUtils#isUrl\n\t * valid URL} or would represent one after the leading slash is removed.\n\t * </ul>\n\t * <p><strong>Note:</strong> this method assumes that leading, duplicate '/'\n\t * or control characters (e.g. white space) have been trimmed so that the\n\t * path starts predictably with a single '/' or does not have one.\n\t * @param path the path to validate\n\t * @return {@code true} if the path is invalid, {@code false} otherwise\n\t */\n\tpublic static boolean isInvalidPath(String path) {\n\t\tif (path.contains(\"WEB-INF\") || path.contains(\"META-INF\")) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\"Path with \\\"WEB-INF\\\" or \\\"META-INF\\\": [\" + path + \"]\", -1, true));\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tif (path.contains(\":/\")) {\n\t\t\tString relativePath = (path.charAt(0) == '/' ? path.substring(1) : path);\n\t\t\tif (ResourceUtils.isUrl(relativePath) || relativePath.startsWith(\"url:\")) {\n\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\t\"Path represents URL or has \\\"url:\\\" prefix: [\" + path + \"]\", -1, true));\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tif (path.contains(\"../\")) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\"Path contains \\\"../\\\" after call to StringUtils#cleanPath: [\" + path + \"]\", -1, true));\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate static boolean isInvalidEncodedPath(String path) {\n\t\tString decodedPath = decode(path);\n\t\tif (decodedPath.contains(\"%\")) {\n\t\t\tdecodedPath = decode(decodedPath);\n\t\t}\n\t\tif (!StringUtils.hasText(decodedPath)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (isInvalidPath(decodedPath)) {\n\t\t\treturn true;\n\t\t}\n\t\tdecodedPath = normalizeInputPath(decodedPath);\n\t\treturn isInvalidPath(decodedPath);\n\t}\n\n\tprivate static String decode(String path) {\n\t\ttry {\n\t\t\treturn UriUtils.decode(path, StandardCharsets.UTF_8);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\treturn \"\";\n\t\t}\n\t}\n\n\t/**\n\t * Create a resource relative to the given {@link Resource}, also decoding\n\t * the resource path for a {@link UrlResource}.\n\t */\n\tpublic static Resource createRelativeResource(Resource location, String resourcePath) throws IOException {\n\t\tif (!(location instanceof UrlResource)) {\n\t\t\tresourcePath = UriUtils.decode(resourcePath, StandardCharsets.UTF_8);\n\t\t}\n\t\treturn location.createRelative(resourcePath);\n\t}\n\n\t/**\n\t * Check whether the resource is under the given location.\n\t */\n\tpublic static boolean isResourceUnderLocation(Resource location, Resource resource) throws IOException {\n\t\tif (resource.getClass() != location.getClass()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tString resourcePath;\n\t\tString locationPath;\n\n\t\tif (resource instanceof UrlResource) {\n\t\t\tresourcePath = resource.getURL().toExternalForm();\n\t\t\tlocationPath = StringUtils.cleanPath(location.getURL().toString());\n\t\t}\n\t\telse if (resource instanceof ClassPathResource classPathResource) {\n\t\t\tresourcePath = classPathResource.getPath();\n\t\t\tlocationPath = StringUtils.cleanPath(((ClassPathResource) location).getPath());\n\t\t}\n\t\telse {\n\t\t\tresourcePath = resource.getURL().getPath();\n\t\t\tlocationPath = StringUtils.cleanPath(location.getURL().getPath());\n\t\t}\n\n\t\tif (locationPath.equals(resourcePath)) {\n\t\t\treturn true;\n\t\t}\n\t\tlocationPath = (locationPath.endsWith(\"/\") || locationPath.isEmpty() ? locationPath : locationPath + \"/\");\n\t\treturn (resourcePath.startsWith(locationPath) && !isInvalidEncodedResourcePath(resourcePath));\n\t}\n\n\tprivate static boolean isInvalidEncodedResourcePath(String resourcePath) {\n\t\tif (resourcePath.contains(\"%\")) {\n\t\t\t// Use URLDecoder (vs UriUtils) to preserve potentially decoded UTF-8 chars...\n\t\t\ttry {\n\t\t\t\tString decodedPath = URLDecoder.decode(resourcePath, StandardCharsets.UTF_8);\n\t\t\t\tif (decodedPath.contains(\"../\") || decodedPath.contains(\"..\\\\\")) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t// May not be possible to decode...\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n}"
  },
  "org.springframework.web.reactive.resource.ResourceHandlerUtils#assertResourceLocation(location)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert the given location is not null, and its path ends on slash.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "void",
    "signature": "public void assertResourceLocation(@Nullable Resource location)",
    "source_code": "\tpublic static void assertResourceLocation(@Nullable Resource location) {\n\t\tAssert.notNull(location, \"Resource location must not be null\");\n\t\ttry {\n\t\t\tString path;\n\t\t\tif (location instanceof org.springframework.core.io.PathResource) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if (location instanceof FileSystemResource fileSystemResource) {\n\t\t\t\tpath = fileSystemResource.getPath();\n\t\t\t}\n\t\t\telse if (location instanceof ClassPathResource classPathResource) {\n\t\t\t\tpath = classPathResource.getPath();\n\t\t\t}\n\t\t\telse if (location instanceof UrlResource) {\n\t\t\t\tpath = location.getURL().toExternalForm();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpath = location.getURL().getPath();\n\t\t\t}\n\t\t\tAssert.isTrue(path.endsWith(FOLDER_SEPARATOR) || path.endsWith(WINDOWS_FOLDER_SEPARATOR),\n\t\t\t\t\t\"Resource location does not end with slash: \" + path);\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\t// ignore\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.resource.ResourceHandlerUtils#createRelativeResource(location,resourcePath)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a resource relative to the given {@link Resource}, also decoding\n\t * the resource path for a {@link UrlResource}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location",
      "resourcePath"
    ],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "Resource",
    "signature": "public Resource createRelativeResource(Resource location, String resourcePath)",
    "source_code": "\tpublic static Resource createRelativeResource(Resource location, String resourcePath) throws IOException {\n\t\tif (!(location instanceof UrlResource)) {\n\t\t\tresourcePath = UriUtils.decode(resourcePath, StandardCharsets.UTF_8);\n\t\t}\n\t\treturn location.createRelative(resourcePath);\n\t}"
  },
  "org.springframework.web.reactive.resource.ResourceHandlerUtils#initLocationPath(path)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Check if the given static resource location path ends with a trailing\n\t * slash, and append it if necessary.\n\t * @param path the location path\n\t * @return the resulting path to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "String",
    "signature": "public String initLocationPath(String path)",
    "source_code": "\tpublic static String initLocationPath(String path) {\n\t\tString separator = (path.contains(FOLDER_SEPARATOR) ? FOLDER_SEPARATOR : WINDOWS_FOLDER_SEPARATOR);\n\t\tif (!path.endsWith(separator)) {\n\t\t\tpath = path.concat(separator);\n\t\t\tlogger.warn(\"Appended trailing slash to static resource location: \" + path);\n\t\t}\n\t\treturn path;\n\t}"
  },
  "org.springframework.web.reactive.resource.ResourceHandlerUtils#isInvalidPath(path)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Checks for invalid resource input paths rejecting the following:\n\t * <ul>\n\t * <li>Paths that contain \"WEB-INF\" or \"META-INF\"\n\t * <li>Paths that contain \"../\" after a call to\n\t * {@link StringUtils#cleanPath}.\n\t * <li>Paths that represent a {@link ResourceUtils#isUrl\n\t * valid URL} or would represent one after the leading slash is removed.\n\t * </ul>\n\t * <p><strong>Note:</strong> this method assumes that leading, duplicate '/'\n\t * or control characters (e.g. white space) have been trimmed so that the\n\t * path starts predictably with a single '/' or does not have one.\n\t * @param path the path to validate\n\t * @return {@code true} if the path is invalid, {@code false} otherwise\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "boolean",
    "signature": "public boolean isInvalidPath(String path)",
    "source_code": "\tpublic static boolean isInvalidPath(String path) {\n\t\tif (path.contains(\"WEB-INF\") || path.contains(\"META-INF\")) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\"Path with \\\"WEB-INF\\\" or \\\"META-INF\\\": [\" + path + \"]\", -1, true));\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tif (path.contains(\":/\")) {\n\t\t\tString relativePath = (path.charAt(0) == '/' ? path.substring(1) : path);\n\t\t\tif (ResourceUtils.isUrl(relativePath) || relativePath.startsWith(\"url:\")) {\n\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\t\"Path represents URL or has \\\"url:\\\" prefix: [\" + path + \"]\", -1, true));\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tif (path.contains(\"../\")) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\"Path contains \\\"../\\\" after call to StringUtils#cleanPath: [\" + path + \"]\", -1, true));\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.reactive.resource.ResourceHandlerUtils#isResourceUnderLocation(location,resource)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the resource is under the given location.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location",
      "resource"
    ],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "boolean",
    "signature": "public boolean isResourceUnderLocation(Resource location, Resource resource)",
    "source_code": "\tpublic static boolean isResourceUnderLocation(Resource location, Resource resource) throws IOException {\n\t\tif (resource.getClass() != location.getClass()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tString resourcePath;\n\t\tString locationPath;\n\n\t\tif (resource instanceof UrlResource) {\n\t\t\tresourcePath = resource.getURL().toExternalForm();\n\t\t\tlocationPath = StringUtils.cleanPath(location.getURL().toString());\n\t\t}\n\t\telse if (resource instanceof ClassPathResource classPathResource) {\n\t\t\tresourcePath = classPathResource.getPath();\n\t\t\tlocationPath = StringUtils.cleanPath(((ClassPathResource) location).getPath());\n\t\t}\n\t\telse {\n\t\t\tresourcePath = resource.getURL().getPath();\n\t\t\tlocationPath = StringUtils.cleanPath(location.getURL().getPath());\n\t\t}\n\n\t\tif (locationPath.equals(resourcePath)) {\n\t\t\treturn true;\n\t\t}\n\t\tlocationPath = (locationPath.endsWith(\"/\") || locationPath.isEmpty() ? locationPath : locationPath + \"/\");\n\t\treturn (resourcePath.startsWith(locationPath) && !isInvalidEncodedResourcePath(resourcePath));\n\t}"
  },
  "org.springframework.web.reactive.resource.ResourceHandlerUtils#normalizeInputPath(path)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Normalize the given resource path replacing the following:\n\t * <ul>\n\t * <li>Backslash with forward slash.\n\t * <li>Duplicate occurrences of slash with a single slash.\n\t * <li>Any combination of leading slash and control characters (00-1F and 7F)\n\t * with a single \"/\" or \"\". For example {@code \"  / // foo/bar\"}\n\t * becomes {@code \"/foo/bar\"}.\n\t * </ul>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "String",
    "signature": "public String normalizeInputPath(String path)",
    "source_code": "\tpublic static String normalizeInputPath(String path) {\n\t\tpath = StringUtils.replace(path, \"\\\\\", \"/\");\n\t\tpath = cleanDuplicateSlashes(path);\n\t\treturn cleanLeadingSlash(path);\n\t}"
  },
  "org.springframework.web.reactive.resource.ResourceHandlerUtils#shouldIgnoreInputPath(path)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the given input path is invalid as determined by\n\t * {@link #isInvalidPath(String)}. The path is also decoded and the same\n\t * checks are performed again.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "boolean",
    "signature": "public boolean shouldIgnoreInputPath(String path)",
    "source_code": "\tpublic static boolean shouldIgnoreInputPath(String path) {\n\t\treturn (!StringUtils.hasText(path) || isInvalidPath(path) || isInvalidEncodedPath(path));\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter#getContentTypeResolver()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured {@link RequestedContentTypeResolver}.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "RequestedContentTypeResolver",
    "signature": "public RequestedContentTypeResolver getContentTypeResolver()",
    "source_code": "\tpublic RequestedContentTypeResolver getContentTypeResolver() {\n\t\treturn this.contentTypeResolver;\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter#setContentTypeResolver(contentTypeResolver)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link RequestedContentTypeResolver} to use to determine requested\n\t * media types. If not set, the default constructor is used.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentTypeResolver"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "void",
    "signature": "public void setContentTypeResolver(RequestedContentTypeResolver contentTypeResolver)",
    "source_code": "\tpublic void setContentTypeResolver(RequestedContentTypeResolver contentTypeResolver) {\n\t\tAssert.notNull(contentTypeResolver, \"'contentTypeResolver' must not be null\");\n\t\tthis.contentTypeResolver = contentTypeResolver;\n\t}"
  },
  "org.springframework.web.reactive.result.view.ViewResolutionResultHandler#format(fragmentFlux,fragment,hints,exchange)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fragmentFlux",
      "fragment",
      "hints",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 570
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> format(Flux<DataBuffer> fragmentFlux, Fragment fragment, @Nullable Object hints,\n\t\t\t\tServerWebExchange exchange)",
    "source_code": "\t\tpublic Flux<DataBuffer> format("
  },
  "org.springframework.web.reactive.result.view.ViewResolutionResultHandler#getBodyFlux()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 489
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> getBodyFlux()",
    "source_code": "\t\tpublic Flux<DataBuffer> getBodyFlux() {\n\t\t\tAssert.state(this.bodyFlux != null, \"Body not set\");\n\t\t\treturn this.bodyFlux;\n\t\t}"
  },
  "org.springframework.web.reactive.result.view.ViewResolutionResultHandler#getHeaders()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 477
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders getHeaders()",
    "source_code": "\t\tpublic HttpHeaders getHeaders() {\n\t\t\tif (!super.getHeaders().containsKey(HttpHeaders.CONTENT_TYPE)) {\n\t\t\t\treturn super.getHeaders();\n\t\t\t}\n\t\t\t// Content-type is set, ignore further updates\n\t\t\tif (this.headers == null) {\n\t\t\t\tthis.headers = new HttpHeaders();\n\t\t\t\tthis.headers.putAll(super.getHeaders());\n\t\t\t}\n\t\t\treturn this.headers;\n\t\t}"
  },
  "org.springframework.web.reactive.result.view.ViewResolutionResultHandler#supports(request)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 543
    },
    "return": "boolean",
    "signature": "public boolean supports(ServerHttpRequest request)",
    "source_code": "\t\tpublic boolean supports(ServerHttpRequest request) {\n\t\t\tString header = request.getHeaders().getFirst(HttpHeaders.ACCEPT);\n\t\t\treturn (header != null && header.contains(MediaType.TEXT_EVENT_STREAM_VALUE));\n\t\t}"
  },
  "org.springframework.web.reactive.result.view.ViewResolutionResultHandler#updateResponse(exchange)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 549
    },
    "return": "void",
    "signature": "public void updateResponse(ServerWebExchange exchange)",
    "source_code": "\t\tpublic void updateResponse(ServerWebExchange exchange) {\n\t\t\tMediaType mediaType = MediaType.TEXT_EVENT_STREAM;\n\t\t\tCharset charset = getCharset(exchange.getRequest());\n\t\t\tmediaType = (charset != null ? new MediaType(mediaType, charset) : mediaType);\n\t\t\texchange.getResponse().getHeaders().setContentType(mediaType);\n\t\t}"
  },
  "org.springframework.web.reactive.result.view.ViewResolutionResultHandler#writeAndFlushWith(body)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body"
    ],
    "position": {
      "column": 1,
      "line": 501
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> writeAndFlushWith(Publisher<? extends Publisher<? extends DataBuffer>> body)",
    "source_code": "\t\tpublic Mono<Void> writeAndFlushWith(Publisher<? extends Publisher<? extends DataBuffer>> body) {\n\t\t\tthis.bodyFlux = Flux.from(body).flatMap(Flux::from);\n\t\t\treturn Mono.empty();\n\t\t}"
  },
  "org.springframework.web.reactive.result.view.ViewResolutionResultHandler#writeWith(body)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body"
    ],
    "position": {
      "column": 1,
      "line": 495
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> writeWith(Publisher<? extends DataBuffer> body)",
    "source_code": "\t\tpublic Mono<Void> writeWith(Publisher<? extends DataBuffer> body) {\n\t\t\tthis.bodyFlux = Flux.from(body);\n\t\t\treturn Mono.empty();\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketSession#canSuspendReceiving()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "boolean",
    "signature": "protected boolean canSuspendReceiving()",
    "source_code": "\tprotected boolean canSuspendReceiving() {\n\t\t// Jetty 12 TODO: research suspend functionality in Jetty 12\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketSession#closeStatus()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "Mono<CloseStatus>",
    "signature": "public Mono<CloseStatus> closeStatus()",
    "source_code": "\tpublic Mono<CloseStatus> closeStatus() {\n\t\treturn this.closeStatusSink.asMono();\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketSession#fail(x)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "x"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "void",
    "signature": "public void fail(Throwable x)",
    "source_code": "\t\tpublic void fail(Throwable x) {\n\t\t\tgetSendProcessor().cancel();\n\t\t\tgetSendProcessor().onError(x);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketSession#onCompleteFailure(cause)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "cause"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "void",
    "signature": "protected void onCompleteFailure(Throwable cause)",
    "source_code": "\t\t\t\t\t\tprotected void onCompleteFailure(Throwable cause) {\n\t\t\t\t\t\t\titerator.close();\n\t\t\t\t\t\t\tcompletable.fail(cause);\n\t\t\t\t\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketSession#onCompleteSuccess()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "void",
    "signature": "protected void onCompleteSuccess()",
    "source_code": "\t\t\t\t\t\tprotected void onCompleteSuccess() {\n\t\t\t\t\t\t\titerator.close();\n\t\t\t\t\t\t\tcompletable.succeed();\n\t\t\t\t\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketSession#process()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "Action",
    "signature": "protected Action process()",
    "source_code": "\t\t\t\t\t\tprotected Action process() {\n\t\t\t\t\t\t\tif (!iterator.hasNext()) {\n\t\t\t\t\t\t\t\treturn Action.SUCCEEDED;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tByteBuffer buffer = iterator.next();\n\t\t\t\t\t\t\tboolean last = iterator.hasNext();\n\t\t\t\t\t\t\tsession.sendPartialBinary(buffer, last, Callback.from(this::succeeded, this::failed));\n\t\t\t\t\t\t\treturn Action.SCHEDULED;\n\t\t\t\t\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketSession#receive()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "Flux<WebSocketMessage>",
    "signature": "public Flux<WebSocketMessage> receive()",
    "source_code": "\tpublic Flux<WebSocketMessage> receive() {\n\t\treturn this.flux;\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketSession#resumeReceiving()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "void",
    "signature": "protected void resumeReceiving()",
    "source_code": "\tprotected void resumeReceiving() {\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketSession#send(messages)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messages"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> send(Publisher<WebSocketMessage> messages)",
    "source_code": "\tpublic Mono<Void> send(Publisher<WebSocketMessage> messages) {\n\t\treturn Flux.from(messages)\n\t\t\t\t.flatMap(this::sendMessage, 1)\n\t\t\t\t.then();\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketSession#sendMessage(message)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "boolean",
    "signature": "protected boolean sendMessage(WebSocketMessage message)",
    "source_code": "\tprotected boolean sendMessage(WebSocketMessage message) throws IOException {\n\t\tDataBuffer dataBuffer = message.getPayload();\n\t\tSession session = getDelegate();\n\t\tif (WebSocketMessage.Type.TEXT.equals(message.getType())) {\n\t\t\tgetSendProcessor().setReadyToSend(false);\n\t\t\tString text = dataBuffer.toString(StandardCharsets.UTF_8);\n\t\t\tsession.sendText(text, new SendProcessorCallback());\n\t\t}\n\t\telse {\n\t\t\tif (WebSocketMessage.Type.BINARY.equals(message.getType())) {\n\t\t\t\tgetSendProcessor().setReadyToSend(false);\n\t\t\t}\n\t\t\ttry (DataBuffer.ByteBufferIterator iterator = dataBuffer.readableByteBuffers()) {\n\t\t\t\twhile (iterator.hasNext()) {\n\t\t\t\t\tByteBuffer byteBuffer = iterator.next();\n\t\t\t\t\tswitch (message.getType()) {\n\t\t\t\t\t\tcase BINARY -> session.sendBinary(byteBuffer, new SendProcessorCallback());\n\t\t\t\t\t\tcase PING -> session.sendPing(byteBuffer, new SendProcessorCallback());\n\t\t\t\t\t\tcase PONG -> session.sendPong(byteBuffer, new SendProcessorCallback());\n\t\t\t\t\t\tdefault -> throw new IllegalArgumentException(\"Unexpected message type: \" + message.getType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketSession#succeed()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "void",
    "signature": "public void succeed()",
    "source_code": "\t\tpublic void succeed() {\n\t\t\tgetSendProcessor().setReadyToSend(true);\n\t\t\tgetSendProcessor().onWritePossible();\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketSession#suspendReceiving()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "void",
    "signature": "protected void suspendReceiving()",
    "source_code": "\tprotected void suspendReceiving() {\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Default implementation of {@link ServerWebExchange}.\n *\n * @author Rossen Stoyanchev\n * @author Brian Clozel\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "signature": "public class DefaultServerWebExchange",
    "source_code": "public class DefaultServerWebExchange implements ServerWebExchange {\n\n\tprivate static final Set<HttpMethod> SAFE_METHODS = Set.of(HttpMethod.GET, HttpMethod.HEAD);\n\n\tprivate static final ResolvableType FORM_DATA_TYPE =\n\t\t\tResolvableType.forClassWithGenerics(MultiValueMap.class, String.class, String.class);\n\n\tprivate static final ResolvableType MULTIPART_DATA_TYPE = ResolvableType.forClassWithGenerics(\n\t\t\tMultiValueMap.class, String.class, Part.class);\n\n\tprivate static final Mono<MultiValueMap<String, String>> EMPTY_FORM_DATA =\n\t\t\tMono.just(CollectionUtils.unmodifiableMultiValueMap(new LinkedMultiValueMap<String, String>(0)))\n\t\t\t\t\t.cache();\n\n\tprivate static final Mono<MultiValueMap<String, Part>> EMPTY_MULTIPART_DATA =\n\t\t\tMono.just(CollectionUtils.unmodifiableMultiValueMap(new LinkedMultiValueMap<String, Part>(0)))\n\t\t\t\t\t.cache();\n\n\n\tprivate final ServerHttpRequest request;\n\n\tprivate final ServerHttpResponse response;\n\n\tprivate final Map<String, Object> attributes = new ConcurrentHashMap<>();\n\n\tprivate final Mono<WebSession> sessionMono;\n\n\tprivate final LocaleContextResolver localeContextResolver;\n\n\tprivate final Mono<MultiValueMap<String, String>> formDataMono;\n\n\tprivate final Mono<MultiValueMap<String, Part>> multipartDataMono;\n\n\tprivate volatile boolean multipartRead = false;\n\n\t@Nullable\n\tprivate final ApplicationContext applicationContext;\n\n\tprivate volatile boolean notModified;\n\n\tprivate Function<String, String> urlTransformer = url -> url;\n\n\t@Nullable\n\tprivate Object logId;\n\n\tprivate String logPrefix = \"\";\n\n\n\tpublic DefaultServerWebExchange(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSessionManager sessionManager, ServerCodecConfigurer codecConfigurer,\n\t\t\tLocaleContextResolver localeContextResolver) {\n\n\t\tthis(request, response, sessionManager, codecConfigurer, localeContextResolver, null);\n\t}\n\n\tprotected DefaultServerWebExchange(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSessionManager sessionManager, ServerCodecConfigurer codecConfigurer,\n\t\t\tLocaleContextResolver localeContextResolver, @Nullable ApplicationContext applicationContext) {\n\n\t\tAssert.notNull(request, \"'request' is required\");\n\t\tAssert.notNull(response, \"'response' is required\");\n\t\tAssert.notNull(sessionManager, \"'sessionManager' is required\");\n\t\tAssert.notNull(codecConfigurer, \"'codecConfigurer' is required\");\n\t\tAssert.notNull(localeContextResolver, \"'localeContextResolver' is required\");\n\n\t\t// Initialize before first call to getLogPrefix()\n\t\tthis.attributes.put(ServerWebExchange.LOG_ID_ATTRIBUTE, request.getId());\n\n\t\tthis.request = request;\n\t\tthis.response = response;\n\t\tthis.sessionMono = sessionManager.getSession(this).cache();\n\t\tthis.localeContextResolver = localeContextResolver;\n\t\tthis.formDataMono = initFormData(request, codecConfigurer, getLogPrefix());\n\t\tthis.multipartDataMono = initMultipartData(codecConfigurer, getLogPrefix());\n\t\tthis.applicationContext = applicationContext;\n\n\t\tif (request instanceof AbstractServerHttpRequest abstractServerHttpRequest) {\n\t\t\tabstractServerHttpRequest.setAttributesSupplier(() -> this.attributes);\n\t\t}\n\t}\n\n\tprivate static Mono<MultiValueMap<String, String>> initFormData(ServerHttpRequest request,\n\t\t\tServerCodecConfigurer configurer, String logPrefix) {\n\n\t\tMediaType contentType = getContentType(request);\n\t\tif (contentType == null || !contentType.isCompatibleWith(MediaType.APPLICATION_FORM_URLENCODED)) {\n\t\t\treturn EMPTY_FORM_DATA;\n\t\t}\n\n\t\tHttpMessageReader<MultiValueMap<String, String>> reader = getReader(configurer, contentType, FORM_DATA_TYPE);\n\t\tif (reader == null) {\n\t\t\treturn Mono.error(new IllegalStateException(\"No HttpMessageReader for \" + contentType));\n\t\t}\n\n\t\treturn reader\n\t\t\t\t.readMono(FORM_DATA_TYPE, request, Hints.from(Hints.LOG_PREFIX_HINT, logPrefix))\n\t\t\t\t.switchIfEmpty(EMPTY_FORM_DATA)\n\t\t\t\t.cache();\n\t}\n\n\tprivate Mono<MultiValueMap<String, Part>> initMultipartData(ServerCodecConfigurer configurer, String logPrefix) {\n\n\t\tMediaType contentType = getContentType(this.request);\n\t\tif (contentType == null || !contentType.getType().equalsIgnoreCase(\"multipart\")) {\n\t\t\treturn EMPTY_MULTIPART_DATA;\n\t\t}\n\n\t\tHttpMessageReader<MultiValueMap<String, Part>> reader = getReader(configurer, contentType, MULTIPART_DATA_TYPE);\n\t\tif (reader == null) {\n\t\t\treturn Mono.error(new IllegalStateException(\"No HttpMessageReader for \" + contentType));\n\t\t}\n\n\t\treturn reader\n\t\t\t\t.readMono(MULTIPART_DATA_TYPE, this.request, Hints.from(Hints.LOG_PREFIX_HINT, logPrefix))\n\t\t\t\t.doOnNext(ignored -> this.multipartRead = true)\n\t\t\t\t.switchIfEmpty(EMPTY_MULTIPART_DATA)\n\t\t\t\t.cache();\n\t}\n\n\t@Nullable\n\tprivate static MediaType getContentType(ServerHttpRequest request) {\n\t\tMediaType contentType = null;\n\t\ttry {\n\t\t\tcontentType = request.getHeaders().getContentType();\n\t\t}\n\t\tcatch (InvalidMediaTypeException ex) {\n\t\t\t// ignore\n\t\t}\n\t\treturn contentType;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Nullable\n\tprivate static <E> HttpMessageReader<E> getReader(\n\t\t\tServerCodecConfigurer configurer, MediaType contentType, ResolvableType targetType) {\n\n\t\tHttpMessageReader<E> result = null;\n\t\tfor (HttpMessageReader<?> reader : configurer.getReaders()) {\n\t\t\tif (reader.canRead(targetType, contentType)) {\n\t\t\t\tresult = (HttpMessageReader<E>) reader;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\n\t@Override\n\tpublic ServerHttpRequest getRequest() {\n\t\treturn this.request;\n\t}\n\n\tprivate HttpHeaders getRequestHeaders() {\n\t\treturn getRequest().getHeaders();\n\t}\n\n\t@Override\n\tpublic ServerHttpResponse getResponse() {\n\t\treturn this.response;\n\t}\n\n\tprivate HttpHeaders getResponseHeaders() {\n\t\treturn getResponse().getHeaders();\n\t}\n\n\t@Override\n\tpublic Map<String, Object> getAttributes() {\n\t\treturn this.attributes;\n\t}\n\n\t@Override\n\tpublic Mono<WebSession> getSession() {\n\t\treturn this.sessionMono;\n\t}\n\n\t@Override\n\tpublic <T extends Principal> Mono<T> getPrincipal() {\n\t\treturn Mono.empty();\n\t}\n\n\t@Override\n\tpublic Mono<MultiValueMap<String, String>> getFormData() {\n\t\treturn this.formDataMono;\n\t}\n\n\t@Override\n\tpublic Mono<MultiValueMap<String, Part>> getMultipartData() {\n\t\treturn this.multipartDataMono;\n\t}\n\n\t@Override\n\tpublic Mono<Void> cleanupMultipart() {\n\t\treturn Mono.defer(() -> {\n\t\t\tif (this.multipartRead) {\n\t\t\t\treturn Mono.usingWhen(getMultipartData().onErrorComplete().map(this::collectParts),\n\t\t\t\t\t\tparts -> Mono.empty(),\n\t\t\t\t\t\tparts -> Flux.fromIterable(parts).flatMap(part -> part.delete().onErrorComplete())\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn Mono.empty();\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate List<Part> collectParts(MultiValueMap<String, Part> multipartData) {\n\t\treturn multipartData.values().stream().flatMap(List::stream).collect(Collectors.toList());\n\t}\n\n\t@Override\n\tpublic LocaleContext getLocaleContext() {\n\t\treturn this.localeContextResolver.resolveLocaleContext(this);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic ApplicationContext getApplicationContext() {\n\t\treturn this.applicationContext;\n\t}\n\n\t@Override\n\tpublic boolean isNotModified() {\n\t\treturn this.notModified;\n\t}\n\n\t@Override\n\tpublic boolean checkNotModified(Instant lastModified) {\n\t\treturn checkNotModified(null, lastModified);\n\t}\n\n\t@Override\n\tpublic boolean checkNotModified(String etag) {\n\t\treturn checkNotModified(etag, Instant.MIN);\n\t}\n\n\t@Override\n\tpublic boolean checkNotModified(@Nullable String eTag, Instant lastModified) {\n\t\tHttpStatusCode status = getResponse().getStatusCode();\n\t\tif (this.notModified || (status != null && !HttpStatus.OK.equals(status))) {\n\t\t\treturn this.notModified;\n\t\t}\n\t\t// Evaluate conditions in order of precedence.\n\t\t// See https://datatracker.ietf.org/doc/html/rfc9110#section-13.2.2\n\t\t// 1) If-Match\n\t\tif (validateIfMatch(eTag)) {\n\t\t\tupdateResponseStateChanging(eTag, lastModified);\n\t\t\treturn this.notModified;\n\t\t}\n\t\t// 2) If-Unmodified-Since\n\t\telse if (validateIfUnmodifiedSince(lastModified)) {\n\t\t\tupdateResponseStateChanging(eTag, lastModified);\n\t\t\treturn this.notModified;\n\t\t}\n\t\t// 3) If-None-Match\n\t\tif (!validateIfNoneMatch(eTag)) {\n\t\t\t// 4) If-Modified-Since\n\t\t\tvalidateIfModifiedSince(lastModified);\n\t\t}\n\t\tupdateResponseIdempotent(eTag, lastModified);\n\t\treturn this.notModified;\n\t}\n\n\tprivate boolean validateIfMatch(@Nullable String eTag) {\n\t\ttry {\n\t\t\tif (SAFE_METHODS.contains(getRequest().getMethod())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tList<String> values = getRequestHeaders().getOrEmpty(HttpHeaders.IF_MATCH);\n\t\t\tif (CollectionUtils.isEmpty(values)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis.notModified = matchRequestedETags(values, eTag, false);\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate boolean matchRequestedETags(List<String> requestedETagValues, @Nullable String tag, boolean weakCompare) {\n\t\tif (StringUtils.hasLength(tag)) {\n\t\t\tETag eTag = ETag.create(tag);\n\t\t\tboolean isNotSafeMethod = !SAFE_METHODS.contains(getRequest().getMethod());\n\t\t\tfor (String eTagValue : requestedETagValues) {\n\t\t\t\tfor (ETag requestedETag : ETag.parse(eTagValue)) {\n\t\t\t\t\t// only consider \"lost updates\" checks for unsafe HTTP methods\n\t\t\t\t\tif (requestedETag.isWildcard() && isNotSafeMethod) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (requestedETag.compare(eTag, !weakCompare)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate void updateResponseStateChanging(@Nullable String eTag, Instant lastModified) {\n\t\tif (this.notModified) {\n\t\t\tgetResponse().setStatusCode(HttpStatus.PRECONDITION_FAILED);\n\t\t}\n\t\telse {\n\t\t\taddCachingResponseHeaders(eTag, lastModified);\n\t\t}\n\t}\n\n\tprivate boolean validateIfNoneMatch(@Nullable String eTag) {\n\t\ttry {\n\t\t\tif (CollectionUtils.isEmpty(getRequestHeaders().get(HttpHeaders.IF_NONE_MATCH))) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tList<String> values = getRequestHeaders().getOrEmpty(HttpHeaders.IF_NONE_MATCH);\n\t\t\tthis.notModified = !matchRequestedETags(values, eTag, true);\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate void updateResponseIdempotent(@Nullable String eTag, Instant lastModified) {\n\t\tboolean isSafeMethod = SAFE_METHODS.contains(getRequest().getMethod());\n\t\tif (this.notModified) {\n\t\t\tgetResponse().setStatusCode(isSafeMethod ?\n\t\t\t\t\tHttpStatus.NOT_MODIFIED : HttpStatus.PRECONDITION_FAILED);\n\t\t}\n\t\taddCachingResponseHeaders(eTag, lastModified);\n\t}\n\n\tprivate void addCachingResponseHeaders(@Nullable String tag, Instant lastModified) {\n\t\tif (SAFE_METHODS.contains(getRequest().getMethod())) {\n\t\t\tif (lastModified.isAfter(Instant.EPOCH) && getResponseHeaders().getLastModified() == -1) {\n\t\t\t\tgetResponseHeaders().setLastModified(lastModified.toEpochMilli());\n\t\t\t}\n\t\t\tif (StringUtils.hasLength(tag) && getResponseHeaders().getETag() == null) {\n\t\t\t\tgetResponseHeaders().setETag(tag);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean validateIfUnmodifiedSince(Instant lastModified) {\n\t\tif (lastModified.isBefore(Instant.EPOCH)) {\n\t\t\treturn false;\n\t\t}\n\t\tlong ifUnmodifiedSince = getRequestHeaders().getIfUnmodifiedSince();\n\t\tif (ifUnmodifiedSince == -1) {\n\t\t\treturn false;\n\t\t}\n\t\tInstant sinceInstant = Instant.ofEpochMilli(ifUnmodifiedSince);\n\t\tthis.notModified = sinceInstant.isBefore(lastModified.truncatedTo(ChronoUnit.SECONDS));\n\t\treturn true;\n\t}\n\n\tprivate void validateIfModifiedSince(Instant lastModified) {\n\t\tif (lastModified.isBefore(Instant.EPOCH)) {\n\t\t\treturn;\n\t\t}\n\t\tlong ifModifiedSince = getRequestHeaders().getIfModifiedSince();\n\t\tif (ifModifiedSince != -1) {\n\t\t\t// We will perform this validation...\n\t\t\tthis.notModified = ChronoUnit.SECONDS.between(lastModified, Instant.ofEpochMilli(ifModifiedSince)) >= 0;\n\t\t}\n\t}\n\n\t@Override\n\tpublic String transformUrl(String url) {\n\t\treturn this.urlTransformer.apply(url);\n\t}\n\n\t@Override\n\tpublic void addUrlTransformer(Function<String, String> transformer) {\n\t\tAssert.notNull(transformer, \"'encoder' must not be null\");\n\t\tthis.urlTransformer = this.urlTransformer.andThen(transformer);\n\t}\n\n\t@Override\n\tpublic String getLogPrefix() {\n\t\tObject value = getAttribute(LOG_ID_ATTRIBUTE);\n\t\tif (this.logId != value) {\n\t\t\tthis.logId = value;\n\t\t\tthis.logPrefix = value != null ? \"[\" + value + \"] \" : \"\";\n\t\t}\n\t\treturn this.logPrefix;\n\t}\n\n}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#addUrlTransformer(Function<String,transformer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<String",
      "transformer"
    ],
    "position": {
      "column": 1,
      "line": 437
    },
    "return": "void",
    "signature": "public void addUrlTransformer(Function<String, String> transformer)",
    "source_code": "\tpublic void addUrlTransformer(Function<String, String> transformer) {\n\t\tAssert.notNull(transformer, \"'encoder' must not be null\");\n\t\tthis.urlTransformer = this.urlTransformer.andThen(transformer);\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#checkNotModified(eTag,lastModified)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "eTag",
      "lastModified"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "boolean",
    "signature": "public boolean checkNotModified(@Nullable String eTag, Instant lastModified)",
    "source_code": "\tpublic boolean checkNotModified(@Nullable String eTag, Instant lastModified) {\n\t\tHttpStatusCode status = getResponse().getStatusCode();\n\t\tif (this.notModified || (status != null && !HttpStatus.OK.equals(status))) {\n\t\t\treturn this.notModified;\n\t\t}\n\t\t// Evaluate conditions in order of precedence.\n\t\t// See https://datatracker.ietf.org/doc/html/rfc9110#section-13.2.2\n\t\t// 1) If-Match\n\t\tif (validateIfMatch(eTag)) {\n\t\t\tupdateResponseStateChanging(eTag, lastModified);\n\t\t\treturn this.notModified;\n\t\t}\n\t\t// 2) If-Unmodified-Since\n\t\telse if (validateIfUnmodifiedSince(lastModified)) {\n\t\t\tupdateResponseStateChanging(eTag, lastModified);\n\t\t\treturn this.notModified;\n\t\t}\n\t\t// 3) If-None-Match\n\t\tif (!validateIfNoneMatch(eTag)) {\n\t\t\t// 4) If-Modified-Since\n\t\t\tvalidateIfModifiedSince(lastModified);\n\t\t}\n\t\tupdateResponseIdempotent(eTag, lastModified);\n\t\treturn this.notModified;\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#checkNotModified(etag)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "etag"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "boolean",
    "signature": "public boolean checkNotModified(String etag)",
    "source_code": "\tpublic boolean checkNotModified(String etag) {\n\t\treturn checkNotModified(etag, Instant.MIN);\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#checkNotModified(lastModified)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lastModified"
    ],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "boolean",
    "signature": "public boolean checkNotModified(Instant lastModified)",
    "source_code": "\tpublic boolean checkNotModified(Instant lastModified) {\n\t\treturn checkNotModified(null, lastModified);\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#cleanupMultipart()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 257
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> cleanupMultipart()",
    "source_code": "\tpublic Mono<Void> cleanupMultipart() {\n\t\treturn Mono.defer(() -> {\n\t\t\tif (this.multipartRead) {\n\t\t\t\treturn Mono.usingWhen(getMultipartData().onErrorComplete().map(this::collectParts),\n\t\t\t\t\t\tparts -> Mono.empty(),\n\t\t\t\t\t\tparts -> Flux.fromIterable(parts).flatMap(part -> part.delete().onErrorComplete())\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn Mono.empty();\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#getApplicationContext()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "ApplicationContext",
    "signature": "public ApplicationContext getApplicationContext()",
    "source_code": "\tpublic ApplicationContext getApplicationContext() {\n\t\treturn this.applicationContext;\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#getAttributes()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "Object>",
    "signature": "public Object> getAttributes()",
    "source_code": "\tpublic Map<String, Object> getAttributes() {\n\t\treturn this.attributes;\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#getFormData()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 247
    },
    "return": "String>>",
    "signature": "public String>> getFormData()",
    "source_code": "\tpublic Mono<MultiValueMap<String, String>> getFormData() {\n\t\treturn this.formDataMono;\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#getLocaleContext()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "LocaleContext",
    "signature": "public LocaleContext getLocaleContext()",
    "source_code": "\tpublic LocaleContext getLocaleContext() {\n\t\treturn this.localeContextResolver.resolveLocaleContext(this);\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#getLogPrefix()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 443
    },
    "return": "String",
    "signature": "public String getLogPrefix()",
    "source_code": "\tpublic String getLogPrefix() {\n\t\tObject value = getAttribute(LOG_ID_ATTRIBUTE);\n\t\tif (this.logId != value) {\n\t\t\tthis.logId = value;\n\t\t\tthis.logPrefix = value != null ? \"[\" + value + \"] \" : \"\";\n\t\t}\n\t\treturn this.logPrefix;\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#getMultipartData()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "Part>>",
    "signature": "public Part>> getMultipartData()",
    "source_code": "\tpublic Mono<MultiValueMap<String, Part>> getMultipartData() {\n\t\treturn this.multipartDataMono;\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#getPrincipal()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> getPrincipal()",
    "source_code": "\tpublic <T extends Principal> Mono<T> getPrincipal() {\n\t\treturn Mono.empty();\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#getRequest()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "ServerHttpRequest",
    "signature": "public ServerHttpRequest getRequest()",
    "source_code": "\tpublic ServerHttpRequest getRequest() {\n\t\treturn this.request;\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#getResponse()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "ServerHttpResponse",
    "signature": "public ServerHttpResponse getResponse()",
    "source_code": "\tpublic ServerHttpResponse getResponse() {\n\t\treturn this.response;\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#getSession()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "Mono<WebSession>",
    "signature": "public Mono<WebSession> getSession()",
    "source_code": "\tpublic Mono<WebSession> getSession() {\n\t\treturn this.sessionMono;\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#isNotModified()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "boolean",
    "signature": "public boolean isNotModified()",
    "source_code": "\tpublic boolean isNotModified() {\n\t\treturn this.notModified;\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#transformUrl(url)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url"
    ],
    "position": {
      "column": 1,
      "line": 432
    },
    "return": "String",
    "signature": "public String transformUrl(String url)",
    "source_code": "\tpublic String transformUrl(String url) {\n\t\treturn this.urlTransformer.apply(url);\n\t}"
  },
  "org.springframework.web.server.adapter.FORWARDED_HEADER_TRANSFORMER_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Well-known name for the ForwardedHeaderTransformer in the bean factory. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "signature": "public String FORWARDED_HEADER_TRANSFORMER_BEAN_NAME",
    "source_code": "\tpublic static final String FORWARDED_HEADER_TRANSFORMER_BEAN_NAME = \"forwardedHeaderTransformer\";",
    "type": "String"
  },
  "org.springframework.web.server.adapter.LOCALE_CONTEXT_RESOLVER_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Well-known name for the LocaleContextResolver in the bean factory. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "signature": "public String LOCALE_CONTEXT_RESOLVER_BEAN_NAME",
    "source_code": "\tpublic static final String LOCALE_CONTEXT_RESOLVER_BEAN_NAME = \"localeContextResolver\";",
    "type": "String"
  },
  "org.springframework.web.server.adapter.SERVER_CODEC_CONFIGURER_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Well-known name for the ServerCodecConfigurer in the bean factory. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "signature": "public String SERVER_CODEC_CONFIGURER_BEAN_NAME",
    "source_code": "\tpublic static final String SERVER_CODEC_CONFIGURER_BEAN_NAME = \"serverCodecConfigurer\";",
    "type": "String"
  },
  "org.springframework.web.server.adapter.SpringWebBlockHoundIntegration": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@code BlockHoundIntegration} for spring-web classes.\n\t * @since 5.3.6\n\t */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 475
    },
    "signature": "public class SpringWebBlockHoundIntegration",
    "source_code": "\tpublic static class SpringWebBlockHoundIntegration implements BlockHoundIntegration {\n\n\t\t@Override\n\t\tpublic void applyTo(BlockHound.Builder builder) {\n\n\t\t\t// Avoid hard references potentially anywhere in spring-web (no need for structural dependency)\n\n\t\t\tbuilder.allowBlockingCallsInside(\"org.springframework.http.MediaTypeFactory\", \"<clinit>\");\n\t\t\tbuilder.allowBlockingCallsInside(\"org.springframework.web.util.HtmlUtils\", \"<clinit>\");\n\t\t}\n\t}"
  },
  "org.springframework.web.server.adapter.WEB_HANDLER_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Well-known name for the target WebHandler in the bean factory. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "signature": "public String WEB_HANDLER_BEAN_NAME",
    "source_code": "\tpublic static final String WEB_HANDLER_BEAN_NAME = \"webHandler\";",
    "type": "String"
  },
  "org.springframework.web.server.adapter.WEB_SESSION_MANAGER_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Well-known name for the WebSessionManager in the bean factory. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "signature": "public String WEB_SESSION_MANAGER_BEAN_NAME",
    "source_code": "\tpublic static final String WEB_SESSION_MANAGER_BEAN_NAME = \"webSessionManager\";",
    "type": "String"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * This builder has two purposes:\n *\n * <p>One is to assemble a processing chain that consists of a target {@link WebHandler},\n * then decorated with a set of {@link WebFilter WebFilters}, then further decorated with\n * a set of {@link WebExceptionHandler WebExceptionHandlers}.\n *\n * <p>The second purpose is to adapt the resulting processing chain to an {@link HttpHandler}:\n * the lowest-level reactive HTTP handling abstraction which can then be used with any of the\n * supported runtimes. The adaptation is done with the help of {@link HttpWebHandlerAdapter}.\n *\n * <p>The processing chain can be assembled manually via builder methods, or detected from\n * a Spring {@link ApplicationContext} via {@link #applicationContext}, or a mix of both.\n *\n * @author Rossen Stoyanchev\n * @author Sebastien Deleuze\n * @since 5.0\n * @see HttpWebHandlerAdapter\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "signature": "public class WebHttpHandlerBuilder",
    "source_code": "public final class WebHttpHandlerBuilder {\n\n\t/** Well-known name for the target WebHandler in the bean factory. */\n\tpublic static final String WEB_HANDLER_BEAN_NAME = \"webHandler\";\n\n\t/** Well-known name for the WebSessionManager in the bean factory. */\n\tpublic static final String WEB_SESSION_MANAGER_BEAN_NAME = \"webSessionManager\";\n\n\t/** Well-known name for the ServerCodecConfigurer in the bean factory. */\n\tpublic static final String SERVER_CODEC_CONFIGURER_BEAN_NAME = \"serverCodecConfigurer\";\n\n\t/** Well-known name for the LocaleContextResolver in the bean factory. */\n\tpublic static final String LOCALE_CONTEXT_RESOLVER_BEAN_NAME = \"localeContextResolver\";\n\n\t/** Well-known name for the ForwardedHeaderTransformer in the bean factory. */\n\tpublic static final String FORWARDED_HEADER_TRANSFORMER_BEAN_NAME = \"forwardedHeaderTransformer\";\n\n\tprivate final WebHandler webHandler;\n\n\t@Nullable\n\tprivate final ApplicationContext applicationContext;\n\n\tprivate final List<WebFilter> filters = new ArrayList<>();\n\n\tprivate final List<WebExceptionHandler> exceptionHandlers = new ArrayList<>();\n\n\t@Nullable\n\tprivate Function<HttpHandler, HttpHandler> httpHandlerDecorator;\n\n\t@Nullable\n\tprivate WebSessionManager sessionManager;\n\n\t@Nullable\n\tprivate ServerCodecConfigurer codecConfigurer;\n\n\t@Nullable\n\tprivate LocaleContextResolver localeContextResolver;\n\n\t@Nullable\n\tprivate ForwardedHeaderTransformer forwardedHeaderTransformer;\n\n\t@Nullable\n\tprivate ObservationRegistry observationRegistry;\n\n\t@Nullable\n\tprivate ServerRequestObservationConvention observationConvention;\n\n\n\t/**\n\t * Private constructor to use when initialized from an ApplicationContext.\n\t */\n\tprivate WebHttpHandlerBuilder(WebHandler webHandler, @Nullable ApplicationContext applicationContext) {\n\t\tAssert.notNull(webHandler, \"WebHandler must not be null\");\n\t\tthis.webHandler = webHandler;\n\t\tthis.applicationContext = applicationContext;\n\t}\n\n\t/**\n\t * Copy constructor.\n\t */\n\tprivate WebHttpHandlerBuilder(WebHttpHandlerBuilder other) {\n\t\tthis.webHandler = other.webHandler;\n\t\tthis.applicationContext = other.applicationContext;\n\t\tthis.filters.addAll(other.filters);\n\t\tthis.exceptionHandlers.addAll(other.exceptionHandlers);\n\t\tthis.sessionManager = other.sessionManager;\n\t\tthis.codecConfigurer = other.codecConfigurer;\n\t\tthis.localeContextResolver = other.localeContextResolver;\n\t\tthis.forwardedHeaderTransformer = other.forwardedHeaderTransformer;\n\t\tthis.observationRegistry = other.observationRegistry;\n\t\tthis.observationConvention = other.observationConvention;\n\t\tthis.httpHandlerDecorator = other.httpHandlerDecorator;\n\t}\n\n\n\t/**\n\t * Static factory method to create a new builder instance.\n\t * @param webHandler the target handler for the request\n\t * @return the prepared builder\n\t */\n\tpublic static WebHttpHandlerBuilder webHandler(WebHandler webHandler) {\n\t\treturn new WebHttpHandlerBuilder(webHandler, null);\n\t}\n\n\t/**\n\t * Static factory method to create a new builder instance by detecting beans\n\t * in an {@link ApplicationContext}. The following are detected:\n\t * <ul>\n\t * <li>{@link WebHandler} [1] -- looked up by the name\n\t * {@link #WEB_HANDLER_BEAN_NAME}.\n\t * <li>{@link WebFilter} [0..N] -- detected by type and ordered,\n\t * see {@link AnnotationAwareOrderComparator}.\n\t * <li>{@link WebExceptionHandler} [0..N] -- detected by type and\n\t * ordered.\n\t * <li>{@link HttpHandlerDecoratorFactory} [0..N] -- detected by type and\n\t * ordered.\n\t * <li>{@link ObservationRegistry} -- detected by type and\n\t * configured if unique.\n\t * <li>{@link ServerRequestObservationConvention} -- detected by type and\n\t * configured if unique.\n\t * <li>{@link WebSessionManager} [0..1] -- looked up by the name\n\t * {@link #WEB_SESSION_MANAGER_BEAN_NAME}.\n\t * <li>{@link ServerCodecConfigurer} [0..1] -- looked up by the name\n\t * {@link #SERVER_CODEC_CONFIGURER_BEAN_NAME}.\n\t * <li>{@link LocaleContextResolver} [0..1] -- looked up by the name\n\t * {@link #LOCALE_CONTEXT_RESOLVER_BEAN_NAME}.\n\t * </ul>\n\t * @param context the application context to use for the lookup\n\t * @return the prepared builder\n\t */\n\tpublic static WebHttpHandlerBuilder applicationContext(ApplicationContext context) {\n\n\t\tWebHttpHandlerBuilder builder = new WebHttpHandlerBuilder(\n\t\t\t\tcontext.getBean(WEB_HANDLER_BEAN_NAME, WebHandler.class), context);\n\n\t\tList<WebFilter> webFilters = context\n\t\t\t\t.getBeanProvider(WebFilter.class)\n\t\t\t\t.orderedStream()\n\t\t\t\t.toList();\n\t\tbuilder.filters(filters -> filters.addAll(webFilters));\n\n\t\tList<WebExceptionHandler> exceptionHandlers = context\n\t\t\t\t.getBeanProvider(WebExceptionHandler.class)\n\t\t\t\t.orderedStream()\n\t\t\t\t.toList();\n\t\tbuilder.exceptionHandlers(handlers -> handlers.addAll(exceptionHandlers));\n\n\t\tcontext.getBeanProvider(HttpHandlerDecoratorFactory.class)\n\t\t\t\t.orderedStream()\n\t\t\t\t.forEach(builder::httpHandlerDecorator);\n\n\t\tcontext.getBeanProvider(ObservationRegistry.class).ifUnique(builder::observationRegistry);\n\t\tcontext.getBeanProvider(ServerRequestObservationConvention.class).ifAvailable(builder::observationConvention);\n\n\t\ttry {\n\t\t\tbuilder.sessionManager(\n\t\t\t\t\tcontext.getBean(WEB_SESSION_MANAGER_BEAN_NAME, WebSessionManager.class));\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Fall back on default\n\t\t}\n\n\t\ttry {\n\t\t\tbuilder.codecConfigurer(\n\t\t\t\t\tcontext.getBean(SERVER_CODEC_CONFIGURER_BEAN_NAME, ServerCodecConfigurer.class));\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Fall back on default\n\t\t}\n\n\t\ttry {\n\t\t\tbuilder.localeContextResolver(\n\t\t\t\t\tcontext.getBean(LOCALE_CONTEXT_RESOLVER_BEAN_NAME, LocaleContextResolver.class));\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Fall back on default\n\t\t}\n\n\t\ttry {\n\t\t\tbuilder.forwardedHeaderTransformer(\n\t\t\t\t\tcontext.getBean(FORWARDED_HEADER_TRANSFORMER_BEAN_NAME, ForwardedHeaderTransformer.class));\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Fall back on default\n\t\t}\n\n\t\treturn builder;\n\t}\n\n\n\t/**\n\t * Add the given filter(s).\n\t * @param filters the filter(s) to add that's\n\t */\n\tpublic WebHttpHandlerBuilder filter(WebFilter... filters) {\n\t\tif (!ObjectUtils.isEmpty(filters)) {\n\t\t\tthis.filters.addAll(Arrays.asList(filters));\n\t\t\tupdateFilters();\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Manipulate the \"live\" list of currently configured filters.\n\t * @param consumer the consumer to use\n\t */\n\tpublic WebHttpHandlerBuilder filters(Consumer<List<WebFilter>> consumer) {\n\t\tconsumer.accept(this.filters);\n\t\tupdateFilters();\n\t\treturn this;\n\t}\n\n\tprivate void updateFilters() {\n\t\tif (this.filters.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\tList<WebFilter> filtersToUse = this.filters.stream()\n\t\t\t\t.peek(filter -> {\n\t\t\t\t\tif (filter instanceof ForwardedHeaderTransformer forwardedHeaderTransformerFilter\n\t\t\t\t\t\t\t&& this.forwardedHeaderTransformer == null) {\n\t\t\t\t\t\tthis.forwardedHeaderTransformer = forwardedHeaderTransformerFilter;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.filter(filter -> !(filter instanceof ForwardedHeaderTransformer))\n\t\t\t\t.toList();\n\n\t\tthis.filters.clear();\n\t\tthis.filters.addAll(filtersToUse);\n\t}\n\n\t/**\n\t * Add the given exception handler(s).\n\t * @param handlers the exception handler(s)\n\t */\n\tpublic WebHttpHandlerBuilder exceptionHandler(WebExceptionHandler... handlers) {\n\t\tif (!ObjectUtils.isEmpty(handlers)) {\n\t\t\tthis.exceptionHandlers.addAll(Arrays.asList(handlers));\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Manipulate the \"live\" list of currently configured exception handlers.\n\t * @param consumer the consumer to use\n\t */\n\tpublic WebHttpHandlerBuilder exceptionHandlers(Consumer<List<WebExceptionHandler>> consumer) {\n\t\tconsumer.accept(this.exceptionHandlers);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Configure the {@link WebSessionManager} to set on the\n\t * {@link ServerWebExchange WebServerExchange}.\n\t * <p>By default {@link DefaultWebSessionManager} is used.\n\t * @param manager the session manager\n\t * @see HttpWebHandlerAdapter#setSessionManager(WebSessionManager)\n\t */\n\tpublic WebHttpHandlerBuilder sessionManager(WebSessionManager manager) {\n\t\tthis.sessionManager = manager;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Whether a {@code WebSessionManager} is configured or not, either detected from an\n\t * {@code ApplicationContext} or explicitly configured via {@link #sessionManager}.\n\t * @since 5.0.9\n\t */\n\tpublic boolean hasSessionManager() {\n\t\treturn (this.sessionManager != null);\n\t}\n\n\t/**\n\t * Configure the {@link ServerCodecConfigurer} to set on the {@code WebServerExchange}.\n\t * @param codecConfigurer the codec configurer\n\t */\n\tpublic WebHttpHandlerBuilder codecConfigurer(ServerCodecConfigurer codecConfigurer) {\n\t\tthis.codecConfigurer = codecConfigurer;\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Whether a {@code ServerCodecConfigurer} is configured or not, either detected from an\n\t * {@code ApplicationContext} or explicitly configured via {@link #codecConfigurer}.\n\t * @since 5.0.9\n\t */\n\tpublic boolean hasCodecConfigurer() {\n\t\treturn (this.codecConfigurer != null);\n\t}\n\n\t/**\n\t * Configure the {@link LocaleContextResolver} to set on the\n\t * {@link ServerWebExchange WebServerExchange}.\n\t * @param localeContextResolver the locale context resolver\n\t */\n\tpublic WebHttpHandlerBuilder localeContextResolver(LocaleContextResolver localeContextResolver) {\n\t\tthis.localeContextResolver = localeContextResolver;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Whether a {@code LocaleContextResolver} is configured or not, either detected from an\n\t * {@code ApplicationContext} or explicitly configured via {@link #localeContextResolver}.\n\t * @since 5.0.9\n\t */\n\tpublic boolean hasLocaleContextResolver() {\n\t\treturn (this.localeContextResolver != null);\n\t}\n\n\t/**\n\t * Configure the {@link ForwardedHeaderTransformer} for extracting and/or\n\t * removing forwarded headers.\n\t * @param transformer the transformer\n\t * @since 5.1\n\t */\n\tpublic WebHttpHandlerBuilder forwardedHeaderTransformer(ForwardedHeaderTransformer transformer) {\n\t\tthis.forwardedHeaderTransformer = transformer;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Whether a {@code ForwardedHeaderTransformer} is configured or not, either\n\t * detected from an {@code ApplicationContext} or explicitly configured via\n\t * {@link #forwardedHeaderTransformer(ForwardedHeaderTransformer)}.\n\t * @since 5.1\n\t */\n\tpublic boolean hasForwardedHeaderTransformer() {\n\t\treturn (this.forwardedHeaderTransformer != null);\n\t}\n\n\t/**\n\t * Configure an {@link ObservationRegistry} for recording server exchange observations.\n\t * By default, a {@link ObservationRegistry#NOOP no-op} registry will be configured.\n\t * @param observationRegistry the observation registry\n\t * @since 6.1\n\t */\n\tpublic WebHttpHandlerBuilder observationRegistry(ObservationRegistry observationRegistry) {\n\t\tthis.observationRegistry = observationRegistry;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Configure a {@link ServerRequestObservationConvention} to use for server observations.\n\t * By default, a {@link DefaultServerRequestObservationConvention} will be used.\n\t * @param observationConvention the convention to use for all recorded observations\n\t * @since 6.1\n\t */\n\tpublic WebHttpHandlerBuilder observationConvention(ServerRequestObservationConvention observationConvention) {\n\t\tthis.observationConvention = observationConvention;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Configure a {@link Function} to decorate the {@link HttpHandler} returned\n\t * by this builder which effectively wraps the entire\n\t * {@link WebExceptionHandler} - {@link WebFilter} - {@link WebHandler}\n\t * processing chain. This provides access to the request and response before\n\t * the entire chain and likewise the ability to observe the result of\n\t * the entire chain.\n\t * @param handlerDecorator the decorator to apply\n\t * @since 5.3\n\t */\n\tpublic WebHttpHandlerBuilder httpHandlerDecorator(Function<HttpHandler, HttpHandler> handlerDecorator) {\n\t\tthis.httpHandlerDecorator = (this.httpHandlerDecorator != null ?\n\t\t\t\thandlerDecorator.andThen(this.httpHandlerDecorator) : handlerDecorator);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Whether a decorator for {@link HttpHandler} is configured or not via\n\t * {@link #httpHandlerDecorator(Function)}.\n\t * @since 5.3\n\t */\n\tpublic boolean hasHttpHandlerDecorator() {\n\t\treturn (this.httpHandlerDecorator != null);\n\t}\n\n\t/**\n\t * Build the {@link HttpHandler}.\n\t */\n\tpublic HttpHandler build() {\n\t\tWebHandler decorated = new FilteringWebHandler(this.webHandler, this.filters);\n\t\tdecorated = new ExceptionHandlingWebHandler(decorated, this.exceptionHandlers);\n\n\t\tHttpWebHandlerAdapter adapted = new HttpWebHandlerAdapter(decorated);\n\t\tif (this.sessionManager != null) {\n\t\t\tadapted.setSessionManager(this.sessionManager);\n\t\t}\n\t\tif (this.codecConfigurer != null) {\n\t\t\tadapted.setCodecConfigurer(this.codecConfigurer);\n\t\t}\n\t\tif (this.localeContextResolver != null) {\n\t\t\tadapted.setLocaleContextResolver(this.localeContextResolver);\n\t\t}\n\t\tif (this.forwardedHeaderTransformer != null) {\n\t\t\tadapted.setForwardedHeaderTransformer(this.forwardedHeaderTransformer);\n\t\t}\n\t\tif (this.observationRegistry != null) {\n\t\t\tadapted.setObservationRegistry(this.observationRegistry);\n\t\t}\n\t\tif (this.observationConvention != null) {\n\t\t\tadapted.setObservationConvention(this.observationConvention);\n\t\t}\n\t\tif (this.applicationContext != null) {\n\t\t\tadapted.setApplicationContext(this.applicationContext);\n\t\t}\n\t\tadapted.afterPropertiesSet();\n\n\t\treturn (this.httpHandlerDecorator != null ? this.httpHandlerDecorator.apply(adapted) : adapted);\n\t}\n\n\t/**\n\t * Clone this {@link WebHttpHandlerBuilder}.\n\t * @return the cloned builder instance\n\t */\n\t@Override\n\tpublic WebHttpHandlerBuilder clone() {\n\t\treturn new WebHttpHandlerBuilder(this);\n\t}\n\n\n\t/**\n\t * {@code BlockHoundIntegration} for spring-web classes.\n\t * @since 5.3.6\n\t */\n\tpublic static class SpringWebBlockHoundIntegration implements BlockHoundIntegration {\n\n\t\t@Override\n\t\tpublic void applyTo(BlockHound.Builder builder) {\n\n\t\t\t// Avoid hard references potentially anywhere in spring-web (no need for structural dependency)\n\n\t\t\tbuilder.allowBlockingCallsInside(\"org.springframework.http.MediaTypeFactory\", \"<clinit>\");\n\t\t\tbuilder.allowBlockingCallsInside(\"org.springframework.web.util.HtmlUtils\", \"<clinit>\");\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#applicationContext(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create a new builder instance by detecting beans\n\t * in an {@link ApplicationContext}. The following are detected:\n\t * <ul>\n\t * <li>{@link WebHandler} [1] -- looked up by the name\n\t * {@link #WEB_HANDLER_BEAN_NAME}.\n\t * <li>{@link WebFilter} [0..N] -- detected by type and ordered,\n\t * see {@link AnnotationAwareOrderComparator}.\n\t * <li>{@link WebExceptionHandler} [0..N] -- detected by type and\n\t * ordered.\n\t * <li>{@link HttpHandlerDecoratorFactory} [0..N] -- detected by type and\n\t * ordered.\n\t * <li>{@link ObservationRegistry} -- detected by type and\n\t * configured if unique.\n\t * <li>{@link ServerRequestObservationConvention} -- detected by type and\n\t * configured if unique.\n\t * <li>{@link WebSessionManager} [0..1] -- looked up by the name\n\t * {@link #WEB_SESSION_MANAGER_BEAN_NAME}.\n\t * <li>{@link ServerCodecConfigurer} [0..1] -- looked up by the name\n\t * {@link #SERVER_CODEC_CONFIGURER_BEAN_NAME}.\n\t * <li>{@link LocaleContextResolver} [0..1] -- looked up by the name\n\t * {@link #LOCALE_CONTEXT_RESOLVER_BEAN_NAME}.\n\t * </ul>\n\t * @param context the application context to use for the lookup\n\t * @return the prepared builder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder applicationContext(ApplicationContext context)",
    "source_code": "\tpublic static WebHttpHandlerBuilder applicationContext(ApplicationContext context) {\n\n\t\tWebHttpHandlerBuilder builder = new WebHttpHandlerBuilder(\n\t\t\t\tcontext.getBean(WEB_HANDLER_BEAN_NAME, WebHandler.class), context);\n\n\t\tList<WebFilter> webFilters = context\n\t\t\t\t.getBeanProvider(WebFilter.class)\n\t\t\t\t.orderedStream()\n\t\t\t\t.toList();\n\t\tbuilder.filters(filters -> filters.addAll(webFilters));\n\n\t\tList<WebExceptionHandler> exceptionHandlers = context\n\t\t\t\t.getBeanProvider(WebExceptionHandler.class)\n\t\t\t\t.orderedStream()\n\t\t\t\t.toList();\n\t\tbuilder.exceptionHandlers(handlers -> handlers.addAll(exceptionHandlers));\n\n\t\tcontext.getBeanProvider(HttpHandlerDecoratorFactory.class)\n\t\t\t\t.orderedStream()\n\t\t\t\t.forEach(builder::httpHandlerDecorator);\n\n\t\tcontext.getBeanProvider(ObservationRegistry.class).ifUnique(builder::observationRegistry);\n\t\tcontext.getBeanProvider(ServerRequestObservationConvention.class).ifAvailable(builder::observationConvention);\n\n\t\ttry {\n\t\t\tbuilder.sessionManager(\n\t\t\t\t\tcontext.getBean(WEB_SESSION_MANAGER_BEAN_NAME, WebSessionManager.class));\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Fall back on default\n\t\t}\n\n\t\ttry {\n\t\t\tbuilder.codecConfigurer(\n\t\t\t\t\tcontext.getBean(SERVER_CODEC_CONFIGURER_BEAN_NAME, ServerCodecConfigurer.class));\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Fall back on default\n\t\t}\n\n\t\ttry {\n\t\t\tbuilder.localeContextResolver(\n\t\t\t\t\tcontext.getBean(LOCALE_CONTEXT_RESOLVER_BEAN_NAME, LocaleContextResolver.class));\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Fall back on default\n\t\t}\n\n\t\ttry {\n\t\t\tbuilder.forwardedHeaderTransformer(\n\t\t\t\t\tcontext.getBean(FORWARDED_HEADER_TRANSFORMER_BEAN_NAME, ForwardedHeaderTransformer.class));\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Fall back on default\n\t\t}\n\n\t\treturn builder;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#applyTo(builder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "builder"
    ],
    "position": {
      "column": 1,
      "line": 478
    },
    "return": "void",
    "signature": "public void applyTo(BlockHound.Builder builder)",
    "source_code": "\t\tpublic void applyTo(BlockHound.Builder builder) {\n\n\t\t\t// Avoid hard references potentially anywhere in spring-web (no need for structural dependency)\n\n\t\t\tbuilder.allowBlockingCallsInside(\"org.springframework.http.MediaTypeFactory\", \"<clinit>\");\n\t\t\tbuilder.allowBlockingCallsInside(\"org.springframework.web.util.HtmlUtils\", \"<clinit>\");\n\t\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#build()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build the {@link HttpHandler}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 430
    },
    "return": "HttpHandler",
    "signature": "public HttpHandler build()",
    "source_code": "\tpublic HttpHandler build() {\n\t\tWebHandler decorated = new FilteringWebHandler(this.webHandler, this.filters);\n\t\tdecorated = new ExceptionHandlingWebHandler(decorated, this.exceptionHandlers);\n\n\t\tHttpWebHandlerAdapter adapted = new HttpWebHandlerAdapter(decorated);\n\t\tif (this.sessionManager != null) {\n\t\t\tadapted.setSessionManager(this.sessionManager);\n\t\t}\n\t\tif (this.codecConfigurer != null) {\n\t\t\tadapted.setCodecConfigurer(this.codecConfigurer);\n\t\t}\n\t\tif (this.localeContextResolver != null) {\n\t\t\tadapted.setLocaleContextResolver(this.localeContextResolver);\n\t\t}\n\t\tif (this.forwardedHeaderTransformer != null) {\n\t\t\tadapted.setForwardedHeaderTransformer(this.forwardedHeaderTransformer);\n\t\t}\n\t\tif (this.observationRegistry != null) {\n\t\t\tadapted.setObservationRegistry(this.observationRegistry);\n\t\t}\n\t\tif (this.observationConvention != null) {\n\t\t\tadapted.setObservationConvention(this.observationConvention);\n\t\t}\n\t\tif (this.applicationContext != null) {\n\t\t\tadapted.setApplicationContext(this.applicationContext);\n\t\t}\n\t\tadapted.afterPropertiesSet();\n\n\t\treturn (this.httpHandlerDecorator != null ? this.httpHandlerDecorator.apply(adapted) : adapted);\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#clone()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Clone this {@link WebHttpHandlerBuilder}.\n\t * @return the cloned builder instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 466
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder clone()",
    "source_code": "\tpublic WebHttpHandlerBuilder clone() {\n\t\treturn new WebHttpHandlerBuilder(this);\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#codecConfigurer(codecConfigurer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@link ServerCodecConfigurer} to set on the {@code WebServerExchange}.\n\t * @param codecConfigurer the codec configurer\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "codecConfigurer"
    ],
    "position": {
      "column": 1,
      "line": 325
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder codecConfigurer(ServerCodecConfigurer codecConfigurer)",
    "source_code": "\tpublic WebHttpHandlerBuilder codecConfigurer(ServerCodecConfigurer codecConfigurer) {\n\t\tthis.codecConfigurer = codecConfigurer;\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#exceptionHandler(handlers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given exception handler(s).\n\t * @param handlers the exception handler(s)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handlers"
    ],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder exceptionHandler(WebExceptionHandler... handlers)",
    "source_code": "\tpublic WebHttpHandlerBuilder exceptionHandler(WebExceptionHandler... handlers) {\n\t\tif (!ObjectUtils.isEmpty(handlers)) {\n\t\t\tthis.exceptionHandlers.addAll(Arrays.asList(handlers));\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#exceptionHandlers(consumer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Manipulate the \"live\" list of currently configured exception handlers.\n\t * @param consumer the consumer to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "consumer"
    ],
    "position": {
      "column": 1,
      "line": 295
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder exceptionHandlers(Consumer<List<WebExceptionHandler>> consumer)",
    "source_code": "\tpublic WebHttpHandlerBuilder exceptionHandlers(Consumer<List<WebExceptionHandler>> consumer) {\n\t\tconsumer.accept(this.exceptionHandlers);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#filter(filters)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given filter(s).\n\t * @param filters the filter(s) to add that's\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "filters"
    ],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder filter(WebFilter... filters)",
    "source_code": "\tpublic WebHttpHandlerBuilder filter(WebFilter... filters) {\n\t\tif (!ObjectUtils.isEmpty(filters)) {\n\t\t\tthis.filters.addAll(Arrays.asList(filters));\n\t\t\tupdateFilters();\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#filters(consumer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Manipulate the \"live\" list of currently configured filters.\n\t * @param consumer the consumer to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "consumer"
    ],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder filters(Consumer<List<WebFilter>> consumer)",
    "source_code": "\tpublic WebHttpHandlerBuilder filters(Consumer<List<WebFilter>> consumer) {\n\t\tconsumer.accept(this.filters);\n\t\tupdateFilters();\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#forwardedHeaderTransformer(transformer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@link ForwardedHeaderTransformer} for extracting and/or\n\t * removing forwarded headers.\n\t * @param transformer the transformer\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "transformer"
    ],
    "position": {
      "column": 1,
      "line": 365
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder forwardedHeaderTransformer(ForwardedHeaderTransformer transformer)",
    "source_code": "\tpublic WebHttpHandlerBuilder forwardedHeaderTransformer(ForwardedHeaderTransformer transformer) {\n\t\tthis.forwardedHeaderTransformer = transformer;\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#hasCodecConfigurer()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether a {@code ServerCodecConfigurer} is configured or not, either detected from an\n\t * {@code ApplicationContext} or explicitly configured via {@link #codecConfigurer}.\n\t * @since 5.0.9\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 336
    },
    "return": "boolean",
    "signature": "public boolean hasCodecConfigurer()",
    "source_code": "\tpublic boolean hasCodecConfigurer() {\n\t\treturn (this.codecConfigurer != null);\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#hasForwardedHeaderTransformer()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether a {@code ForwardedHeaderTransformer} is configured or not, either\n\t * detected from an {@code ApplicationContext} or explicitly configured via\n\t * {@link #forwardedHeaderTransformer(ForwardedHeaderTransformer)}.\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 376
    },
    "return": "boolean",
    "signature": "public boolean hasForwardedHeaderTransformer()",
    "source_code": "\tpublic boolean hasForwardedHeaderTransformer() {\n\t\treturn (this.forwardedHeaderTransformer != null);\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#hasHttpHandlerDecorator()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether a decorator for {@link HttpHandler} is configured or not via\n\t * {@link #httpHandlerDecorator(Function)}.\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 423
    },
    "return": "boolean",
    "signature": "public boolean hasHttpHandlerDecorator()",
    "source_code": "\tpublic boolean hasHttpHandlerDecorator() {\n\t\treturn (this.httpHandlerDecorator != null);\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#hasLocaleContextResolver()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether a {@code LocaleContextResolver} is configured or not, either detected from an\n\t * {@code ApplicationContext} or explicitly configured via {@link #localeContextResolver}.\n\t * @since 5.0.9\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 355
    },
    "return": "boolean",
    "signature": "public boolean hasLocaleContextResolver()",
    "source_code": "\tpublic boolean hasLocaleContextResolver() {\n\t\treturn (this.localeContextResolver != null);\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#hasSessionManager()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether a {@code WebSessionManager} is configured or not, either detected from an\n\t * {@code ApplicationContext} or explicitly configured via {@link #sessionManager}.\n\t * @since 5.0.9\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 317
    },
    "return": "boolean",
    "signature": "public boolean hasSessionManager()",
    "source_code": "\tpublic boolean hasSessionManager() {\n\t\treturn (this.sessionManager != null);\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#httpHandlerDecorator(Function<HttpHandler,handlerDecorator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a {@link Function} to decorate the {@link HttpHandler} returned\n\t * by this builder which effectively wraps the entire\n\t * {@link WebExceptionHandler} - {@link WebFilter} - {@link WebHandler}\n\t * processing chain. This provides access to the request and response before\n\t * the entire chain and likewise the ability to observe the result of\n\t * the entire chain.\n\t * @param handlerDecorator the decorator to apply\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<HttpHandler",
      "handlerDecorator"
    ],
    "position": {
      "column": 1,
      "line": 412
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder httpHandlerDecorator(Function<HttpHandler, HttpHandler> handlerDecorator)",
    "source_code": "\tpublic WebHttpHandlerBuilder httpHandlerDecorator(Function<HttpHandler, HttpHandler> handlerDecorator) {\n\t\tthis.httpHandlerDecorator = (this.httpHandlerDecorator != null ?\n\t\t\t\thandlerDecorator.andThen(this.httpHandlerDecorator) : handlerDecorator);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#localeContextResolver(localeContextResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@link LocaleContextResolver} to set on the\n\t * {@link ServerWebExchange WebServerExchange}.\n\t * @param localeContextResolver the locale context resolver\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "localeContextResolver"
    ],
    "position": {
      "column": 1,
      "line": 345
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder localeContextResolver(LocaleContextResolver localeContextResolver)",
    "source_code": "\tpublic WebHttpHandlerBuilder localeContextResolver(LocaleContextResolver localeContextResolver) {\n\t\tthis.localeContextResolver = localeContextResolver;\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#observationConvention(observationConvention)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a {@link ServerRequestObservationConvention} to use for server observations.\n\t * By default, a {@link DefaultServerRequestObservationConvention} will be used.\n\t * @param observationConvention the convention to use for all recorded observations\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "observationConvention"
    ],
    "position": {
      "column": 1,
      "line": 397
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder observationConvention(ServerRequestObservationConvention observationConvention)",
    "source_code": "\tpublic WebHttpHandlerBuilder observationConvention(ServerRequestObservationConvention observationConvention) {\n\t\tthis.observationConvention = observationConvention;\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#observationRegistry(observationRegistry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure an {@link ObservationRegistry} for recording server exchange observations.\n\t * By default, a {@link ObservationRegistry#NOOP no-op} registry will be configured.\n\t * @param observationRegistry the observation registry\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "observationRegistry"
    ],
    "position": {
      "column": 1,
      "line": 386
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder observationRegistry(ObservationRegistry observationRegistry)",
    "source_code": "\tpublic WebHttpHandlerBuilder observationRegistry(ObservationRegistry observationRegistry) {\n\t\tthis.observationRegistry = observationRegistry;\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#sessionManager(manager)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@link WebSessionManager} to set on the\n\t * {@link ServerWebExchange WebServerExchange}.\n\t * <p>By default {@link DefaultWebSessionManager} is used.\n\t * @param manager the session manager\n\t * @see HttpWebHandlerAdapter#setSessionManager(WebSessionManager)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "manager"
    ],
    "position": {
      "column": 1,
      "line": 307
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder sessionManager(WebSessionManager manager)",
    "source_code": "\tpublic WebHttpHandlerBuilder sessionManager(WebSessionManager manager) {\n\t\tthis.sessionManager = manager;\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#webHandler(webHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create a new builder instance.\n\t * @param webHandler the target handler for the request\n\t * @return the prepared builder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webHandler"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder webHandler(WebHandler webHandler)",
    "source_code": "\tpublic static WebHttpHandlerBuilder webHandler(WebHandler webHandler) {\n\t\treturn new WebHttpHandlerBuilder(webHandler, null);\n\t}"
  },
  "org.springframework.web.service.invoker.AbstractNamedValueArgumentResolver#createNamedValueInfo(parameter,metadata)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #createNamedValueInfo(MethodParameter)} that also provides\n\t * access to the static values set from {@code @HttpExchange} attributes.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "metadata"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "NamedValueInfo",
    "signature": "protected NamedValueInfo createNamedValueInfo(MethodParameter parameter, HttpRequestValues.Metadata metadata)",
    "source_code": "\tprotected NamedValueInfo createNamedValueInfo("
  },
  "org.springframework.web.service.invoker.HttpMethodArgumentResolver": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * {@link HttpServiceArgumentResolver} that resolves the target\n * request's HTTP method from an {@link HttpMethod} argument.\n *\n * @author Olga Maciaszek-Sharma\n * @author Rossen Stoyanchev\n * @since 6.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "signature": "public class HttpMethodArgumentResolver",
    "source_code": "public class HttpMethodArgumentResolver implements HttpServiceArgumentResolver {\n\n\tprivate static final Log logger = LogFactory.getLog(HttpMethodArgumentResolver.class);\n\n\n\t@Override\n\tpublic boolean resolve(\n\t\t\t@Nullable Object argument, MethodParameter parameter, HttpRequestValues.Builder requestValues) {\n\n\t\tparameter = parameter.nestedIfOptional();\n\n\t\tif (!parameter.getNestedParameterType().equals(HttpMethod.class)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (argument instanceof Optional<?> optionalValue) {\n\t\t\targument = optionalValue.orElse(null);\n\t\t}\n\n\t\tif (argument == null) {\n\t\t\tAssert.isTrue(parameter.isOptional(), \"HttpMethod is required\");\n\t\t\treturn true;\n\t\t}\n\n\t\tHttpMethod httpMethod = (HttpMethod) argument;\n\t\trequestValues.setHttpMethod(httpMethod);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Resolved HTTP method to: \" + httpMethod.name());\n\t\t}\n\n\t\treturn true;\n\t}\n\n}"
  },
  "org.springframework.web.service.invoker.HttpMethodArgumentResolver#resolve(argument,parameter,requestValues)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argument",
      "parameter",
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "return": "boolean",
    "signature": "public boolean resolve(@Nullable Object argument, MethodParameter parameter, HttpRequestValues.Builder requestValues)",
    "source_code": "\tpublic boolean resolve("
  },
  "org.springframework.web.service.invoker.HttpServiceProxyFactory#blockTimeout(blockTimeout)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Configure how long to block for the response of an HTTP service method\n\t\t * with a synchronous (blocking) method signature.\n\t\t * <p>By default this is not set, in which case the behavior depends on\n\t\t * connection and request timeout settings of the underlying HTTP client.\n\t\t * We recommend configuring timeout values directly on the underlying HTTP\n\t\t * client, which provides more control over such settings.\n\t\t * @param blockTimeout the timeout value\n\t\t * @return this same builder instance\n\t\t * @deprecated in favor of setting the same directly on the {@link HttpExchangeAdapter}\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "blockTimeout"
    ],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "Builder",
    "signature": "public Builder blockTimeout(@Nullable Duration blockTimeout)",
    "source_code": "\t\tpublic Builder blockTimeout(@Nullable Duration blockTimeout) {\n\t\t\tif (this.exchangeAdapter instanceof AbstractReactorHttpExchangeAdapter settable) {\n\t\t\t\tsettable.setBlockTimeout(blockTimeout);\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.service.invoker.HttpServiceProxyFactory#builder(clientAdapter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a builder that's initialized with the given client.\n\t * @deprecated in favor of {@link #builderFor(HttpExchangeAdapter)};\n\t * to be removed in 6.2.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clientAdapter"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "Builder",
    "signature": "public Builder builder(HttpClientAdapter clientAdapter)",
    "source_code": "\tpublic static Builder builder(HttpClientAdapter clientAdapter) {\n\t\treturn new Builder().exchangeAdapter(clientAdapter.asReactorExchangeAdapter());\n\t}"
  },
  "org.springframework.web.service.invoker.HttpServiceProxyFactory#clientAdapter(clientAdapter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Provide the HTTP client to perform requests through.\n\t\t * @param clientAdapter a client adapted to {@link HttpClientAdapter}\n\t\t * @return this same builder instance\n\t\t * @deprecated in favor of {@link #exchangeAdapter(HttpExchangeAdapter)};\n\t\t * to be removed in 6.2\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clientAdapter"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "Builder",
    "signature": "public Builder clientAdapter(HttpClientAdapter clientAdapter)",
    "source_code": "\t\tpublic Builder clientAdapter(HttpClientAdapter clientAdapter) {\n\t\t\tthis.exchangeAdapter = clientAdapter.asReactorExchangeAdapter();\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.service.invoker.HttpServiceProxyFactory#reactiveAdapterRegistry(registry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Set the {@link ReactiveAdapterRegistry} to use to support different\n\t\t * asynchronous types for HTTP service method return values.\n\t\t * <p>By default this is {@link ReactiveAdapterRegistry#getSharedInstance()}.\n\t\t * @return this same builder instance\n\t\t * @deprecated in favor of setting the same directly on the {@link HttpExchangeAdapter}\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "Builder",
    "signature": "public Builder reactiveAdapterRegistry(ReactiveAdapterRegistry registry)",
    "source_code": "\t\tpublic Builder reactiveAdapterRegistry(ReactiveAdapterRegistry registry) {\n\t\t\tif (this.exchangeAdapter instanceof AbstractReactorHttpExchangeAdapter settable) {\n\t\t\t\tsettable.setReactiveAdapterRegistry(registry);\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.service.invoker.UriBuilderFactoryArgumentResolver": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * An {@link HttpServiceArgumentResolver} that uses the provided\n * {@link UriBuilderFactory} to expand the {@link UriTemplate}.\n * <p>Unlike with the {@link UrlArgumentResolver},\n * if the {@link UriBuilderFactoryArgumentResolver} is provided,\n * it will not override the entire {@link URL}, but just the {@code baseUri}.\n * <p>This allows for dynamically setting the {@code baseUri},\n * while keeping the {@code path} specified through class\n * and method annotations.\n *\n * @author Olga Maciaszek-Sharma\n * @since 6.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "signature": "public class UriBuilderFactoryArgumentResolver",
    "source_code": "public class UriBuilderFactoryArgumentResolver implements HttpServiceArgumentResolver {\n\n\t@Override\n\tpublic boolean resolve(\n\t\t\t@Nullable Object argument, MethodParameter parameter, HttpRequestValues.Builder requestValues) {\n\n\t\tparameter = parameter.nestedIfOptional();\n\n\t\tif (!parameter.getNestedParameterType().equals(UriBuilderFactory.class)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (argument instanceof Optional<?> optionalValue) {\n\t\t\targument = optionalValue.orElse(null);\n\t\t}\n\n\t\tif (argument == null) {\n\t\t\tAssert.isTrue(parameter.isOptional(), \"UriBuilderFactory is required\");\n\t\t\treturn true;\n\t\t}\n\n\t\trequestValues.setUriBuilderFactory((UriBuilderFactory) argument);\n\t\treturn true;\n\t}\n}"
  },
  "org.springframework.web.service.invoker.UriBuilderFactoryArgumentResolver#resolve(argument,parameter,requestValues)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argument",
      "parameter",
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "return": "boolean",
    "signature": "public boolean resolve(@Nullable Object argument, MethodParameter parameter, HttpRequestValues.Builder requestValues)",
    "source_code": "\tpublic boolean resolve("
  },
  "org.springframework.web.service.invoker.UrlArgumentResolver": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * {@link HttpServiceArgumentResolver} that resolves the URL for the request\n * from a {@link URI} argument.\n *\n * @author Rossen Stoyanchev\n * @author Olga Maciaszek-Sharma\n * @since 6.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 34
    },
    "signature": "public class UrlArgumentResolver",
    "source_code": "public class UrlArgumentResolver implements HttpServiceArgumentResolver {\n\n\t@Override\n\tpublic boolean resolve(\n\t\t\t@Nullable Object argument, MethodParameter parameter, HttpRequestValues.Builder requestValues) {\n\n\t\tparameter = parameter.nestedIfOptional();\n\n\t\tif (!parameter.getNestedParameterType().equals(URI.class)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (argument instanceof Optional<?> optionalValue) {\n\t\t\targument = optionalValue.orElse(null);\n\t\t}\n\n\t\tif (argument == null) {\n\t\t\tAssert.isTrue(parameter.isOptional(), \"URI is required\");\n\t\t\treturn true;\n\t\t}\n\n\t\trequestValues.setUri((URI) argument);\n\t\treturn true;\n\t}\n\n}"
  },
  "org.springframework.web.service.invoker.UrlArgumentResolver#resolve(argument,parameter,requestValues)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argument",
      "parameter",
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "return": "boolean",
    "signature": "public boolean resolve(@Nullable Object argument, MethodParameter parameter, HttpRequestValues.Builder requestValues)",
    "source_code": "\tpublic boolean resolve("
  },
  "org.springframework.web.servlet.function.<unknown>#apply(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "Optional<Resource>",
    "signature": "public Optional<Resource> apply(ServerRequest request)",
    "source_code": "\tpublic Optional<Resource> apply(ServerRequest request) {\n\t\tPathContainer pathContainer = request.requestPath().pathWithinApplication();\n\t\tif (!this.pattern.matches(pathContainer)) {\n\t\t\treturn Optional.empty();\n\t\t}\n\n\t\tpathContainer = this.pattern.extractPathWithinPattern(pathContainer);\n\t\tString path = processPath(pathContainer.value());\n\t\tif (!StringUtils.hasText(path) || isInvalidPath(path)) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\tif (isInvalidEncodedInputPath(path)) {\n\t\t\treturn Optional.empty();\n\t\t}\n\n\t\tif (!(this.location instanceof UrlResource)) {\n\t\t\tpath = UriUtils.decode(path, StandardCharsets.UTF_8);\n\t\t}\n\n\t\ttry {\n\t\t\tResource resource = this.location.createRelative(path);\n\t\t\tif (resource.isReadable() && isResourceUnderLocation(resource)) {\n\t\t\t\treturn Optional.of(resource);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn Optional.empty();\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new UncheckedIOException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#block()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "ServerResponse",
    "signature": "public ServerResponse block()",
    "source_code": "\tpublic ServerResponse block() {\n\t\ttry {\n\t\t\tif (this.timeout != null) {\n\t\t\t\treturn this.futureResponse.get(this.timeout.toMillis(), TimeUnit.MILLISECONDS);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn this.futureResponse.get();\n\t\t\t}\n\t\t}\n\t\tcatch (InterruptedException | ExecutionException | TimeoutException ex) {\n\t\t\tthrow new IllegalStateException(\"Failed to get future response\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#create(obj,timeout)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "AsyncServerResponse",
    "signature": "public AsyncServerResponse create(Object obj, @Nullable Duration timeout)",
    "source_code": "\tpublic static AsyncServerResponse create(Object obj, @Nullable Duration timeout) {\n\t\tAssert.notNull(obj, \"Argument to async must not be null\");\n\n\t\tif (obj instanceof CompletableFuture futureResponse) {\n\t\t\treturn new DefaultAsyncServerResponse(futureResponse, timeout);\n\t\t}\n\t\telse if (reactiveStreamsPresent) {\n\t\t\tReactiveAdapterRegistry registry = ReactiveAdapterRegistry.getSharedInstance();\n\t\t\tReactiveAdapter publisherAdapter = registry.getAdapter(obj.getClass());\n\t\t\tif (publisherAdapter != null) {\n\t\t\t\tPublisher<ServerResponse> publisher = publisherAdapter.toPublisher(obj);\n\t\t\t\tReactiveAdapter futureAdapter = registry.getAdapter(CompletableFuture.class);\n\t\t\t\tif (futureAdapter != null) {\n\t\t\t\t\tCompletableFuture<ServerResponse> futureResponse =\n\t\t\t\t\t\t\t(CompletableFuture<ServerResponse>) futureAdapter.fromPublisher(publisher);\n\t\t\t\t\treturn new DefaultAsyncServerResponse(futureResponse, timeout);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Asynchronous type not supported: \" + obj.getClass());\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#flush()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "void",
    "signature": "public void flush()",
    "source_code": "\t\tpublic void flush() throws IOException {\n\t\t\tif (this.sendFailed) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tthis.outputMessage.flush();\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthis.sendFailed = true;\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#headers()": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders headers()",
    "source_code": "\tpublic HttpHeaders headers() {\n\t\treturn delegate(ServerResponse::headers);\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#onComplete(onCompletion)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "onCompletion"
    ],
    "position": {
      "column": 1,
      "line": 275
    },
    "return": "SseBuilder",
    "signature": "public SseBuilder onComplete(Runnable onCompletion)",
    "source_code": "\t\tpublic SseBuilder onComplete(Runnable onCompletion) {\n\t\t\tthis.deferredResult.onCompletion(onCompletion);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#onError(onError)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "onError"
    ],
    "position": {
      "column": 1,
      "line": 269
    },
    "return": "SseBuilder",
    "signature": "public SseBuilder onError(Consumer<Throwable> onError)",
    "source_code": "\t\tpublic SseBuilder onError(Consumer<Throwable> onError) {\n\t\t\tthis.deferredResult.onError(onError);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#onTimeout(onTimeout)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "onTimeout"
    ],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "SseBuilder",
    "signature": "public SseBuilder onTimeout(Runnable onTimeout)",
    "source_code": "\t\tpublic SseBuilder onTimeout(Runnable onTimeout) {\n\t\t\tthis.deferredResult.onTimeout(onTimeout);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#processPath(path)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Process the given resource path.\n\t * <p>The default implementation replaces:\n\t * <ul>\n\t * <li>Backslash with forward slash.\n\t * <li>Duplicate occurrences of slash with a single slash.\n\t * <li>Any combination of leading slash and control characters (00-1F and 7F)\n\t * with a single \"/\" or \"\". For example {@code \"  / // foo/bar\"}\n\t * becomes {@code \"/foo/bar\"}.\n\t * </ul>\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "path"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "String",
    "signature": "protected String processPath(String path)",
    "source_code": "\tprotected String processPath(String path) {\n\t\tpath = StringUtils.replace(path, \"\\\\\", \"/\");\n\t\tpath = cleanDuplicateSlashes(path);\n\t\tpath = cleanLeadingSlash(path);\n\t\treturn normalizePath(path);\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#rawStatusCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "int",
    "signature": "public int rawStatusCode()",
    "source_code": "\tpublic int rawStatusCode() {\n\t\treturn delegate(ServerResponse::rawStatusCode);\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#sendRedirect(location,sc,clearBuffer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location",
      "sc",
      "clearBuffer"
    ],
    "position": {
      "column": 1,
      "line": 690
    },
    "return": "void",
    "signature": "public void sendRedirect(String location, int sc, boolean clearBuffer)",
    "source_code": "\t\tpublic void sendRedirect(String location, int sc, boolean clearBuffer) throws IOException {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#statusCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "HttpStatusCode",
    "signature": "public HttpStatusCode statusCode()",
    "source_code": "\tpublic HttpStatusCode statusCode() {\n\t\treturn delegate(ServerResponse::statusCode);\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#write(object)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "StreamBuilder",
    "signature": "public StreamBuilder write(Object object)",
    "source_code": "\t\tpublic StreamBuilder write(Object object) throws IOException {\n\t\t\twrite(object, null);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#write(object,mediaType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "StreamBuilder",
    "signature": "public StreamBuilder write(Object object, @Nullable MediaType mediaType)",
    "source_code": "\t\tpublic StreamBuilder write(Object object, @Nullable MediaType mediaType) throws IOException {\n\t\t\tAssert.notNull(object, \"data must not be null\");\n\t\t\ttry {\n\t\t\t\tif (object instanceof byte[] bytes) {\n\t\t\t\t\tthis.outputMessage.getBody().write(bytes);\n\t\t\t\t}\n\t\t\t\telse if (object instanceof String str) {\n\t\t\t\t\tthis.outputMessage.getBody().write(str.getBytes(StandardCharsets.UTF_8));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteObject(object, mediaType);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthis.sendFailed = true;\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#writeTo(request,response,context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "ModelAndView",
    "signature": "public ModelAndView writeTo(HttpServletRequest request, HttpServletResponse response, Context context)",
    "source_code": "\tpublic ModelAndView writeTo(HttpServletRequest request, HttpServletResponse response, Context context)"
  },
  "org.springframework.web.servlet.function.AsyncServerResponse": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Asynchronous subtype of {@link ServerResponse} that exposes the future\n * response.\n *\n * @author Arjen Poutsma\n * @since 5.3.2\n * @see ServerResponse#async(Object)\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "signature": "public interface AsyncServerResponse",
    "source_code": "public interface AsyncServerResponse extends ServerResponse {\n\n\t/**\n\t * Blocks indefinitely until the future response is obtained.\n\t */\n\tServerResponse block();\n\n\n\t// Static creation methods\n\n\t/**\n\t * Create a {@code AsyncServerResponse} with the given asynchronous response.\n\t * Parameter {@code asyncResponse} can be a\n\t * {@link CompletableFuture CompletableFuture&lt;ServerResponse&gt;} or\n\t * {@link Publisher Publisher&lt;ServerResponse&gt;} (or any\n\t * asynchronous producer of a single {@code ServerResponse} that can be\n\t * adapted via the {@link ReactiveAdapterRegistry}).\n\t * @param asyncResponse a {@code CompletableFuture<ServerResponse>} or\n\t * {@code Publisher<ServerResponse>}\n\t * @return the asynchronous response\n\t */\n\tstatic AsyncServerResponse create(Object asyncResponse) {\n\t\treturn createInternal(asyncResponse, null);\n\t}\n\n\t/**\n\t * Create a (built) response with the given asynchronous response.\n\t * Parameter {@code asyncResponse} can be a\n\t * {@link CompletableFuture CompletableFuture&lt;ServerResponse&gt;} or\n\t * {@link Publisher Publisher&lt;ServerResponse&gt;} (or any\n\t * asynchronous producer of a single {@code ServerResponse} that can be\n\t * adapted via the {@link ReactiveAdapterRegistry}).\n\t * @param asyncResponse a {@code CompletableFuture<ServerResponse>} or\n\t * {@code Publisher<ServerResponse>}\n\t * @param timeout maximum time period to wait for before timing out\n\t * @return the asynchronous response\n\t */\n\tstatic AsyncServerResponse create(Object asyncResponse, Duration timeout) {\n\t\treturn createInternal(asyncResponse, timeout);\n\t}\n\n\tprivate static AsyncServerResponse createInternal(Object asyncResponse, @Nullable Duration timeout) {\n\t\tAssert.notNull(asyncResponse, \"AsyncResponse must not be null\");\n\n\t\tCompletableFuture<ServerResponse> futureResponse = toCompletableFuture(asyncResponse);\n\t\tif (futureResponse.isDone() &&\n\t\t\t\t!futureResponse.isCancelled() &&\n\t\t\t\t!futureResponse.isCompletedExceptionally()) {\n\n\t\t\ttry {\n\t\t\t\tServerResponse completedResponse = futureResponse.get();\n\t\t\t\treturn new CompletedAsyncServerResponse(completedResponse);\n\t\t\t}\n\t\t\tcatch (InterruptedException | ExecutionException ignored) {\n\t\t\t\t// fall through to use DefaultAsyncServerResponse\n\t\t\t}\n\t\t}\n\t\treturn new DefaultAsyncServerResponse(futureResponse, timeout);\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate static CompletableFuture<ServerResponse> toCompletableFuture(Object obj) {\n\t\tif (obj instanceof CompletableFuture<?> futureResponse) {\n\t\t\treturn (CompletableFuture<ServerResponse>) futureResponse;\n\t\t}\n\t\telse if (DefaultAsyncServerResponse.reactiveStreamsPresent) {\n\t\t\tReactiveAdapterRegistry registry = ReactiveAdapterRegistry.getSharedInstance();\n\t\t\tReactiveAdapter publisherAdapter = registry.getAdapter(obj.getClass());\n\t\t\tif (publisherAdapter != null) {\n\t\t\t\tPublisher<ServerResponse> publisher = publisherAdapter.toPublisher(obj);\n\t\t\t\tReactiveAdapter futureAdapter = registry.getAdapter(CompletableFuture.class);\n\t\t\t\tif (futureAdapter != null) {\n\t\t\t\t\treturn (CompletableFuture<ServerResponse>) futureAdapter.fromPublisher(publisher);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Asynchronous type not supported: \" + obj.getClass());\n\t}\n\n}"
  },
  "org.springframework.web.servlet.handler.AbstractHandlerMapping#handlePreFlight(request,response)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 744
    },
    "return": "void",
    "signature": "public void handlePreFlight(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\t\tpublic void handlePreFlight(HttpServletRequest request, HttpServletResponse response) throws IOException {\n\t\t\tinvokeCorsProcessor(request, response);\n\t\t}"
  },
  "org.springframework.web.servlet.handler.AbstractHandlerMapping#invokeCorsProcessor(request,response)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 723
    },
    "return": "boolean",
    "signature": "protected boolean invokeCorsProcessor(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\t\tprotected boolean invokeCorsProcessor("
  },
  "org.springframework.web.servlet.handler.AbstractUrlHandlerMapping#registerHandler(urlPath,handler)": {
    "change": "modifier_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Register the specified handler for the given URL path.\n\t * @param urlPath the URL the bean should be mapped to\n\t * @param handler the handler instance or handler bean name String\n\t * (a bean name will automatically be resolved into the corresponding handler bean)\n\t * @throws BeansException if the handler couldn't be registered\n\t * @throws IllegalStateException if there is a conflicting handler registered\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "urlPath",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 414
    },
    "return": "void",
    "signature": "protected void registerHandler(String urlPath, Object handler)",
    "source_code": "\tprotected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {\n\t\tAssert.notNull(urlPath, \"URL path must not be null\");\n\t\tAssert.notNull(handler, \"Handler object must not be null\");\n\t\tObject resolvedHandler = handler;\n\n\t\t// Eagerly resolve handler if referencing singleton via name.\n\t\tif (!this.lazyInitHandlers && handler instanceof String handlerName) {\n\t\t\tApplicationContext applicationContext = obtainApplicationContext();\n\t\t\tif (applicationContext.isSingleton(handlerName)) {\n\t\t\t\tresolvedHandler = applicationContext.getBean(handlerName);\n\t\t\t}\n\t\t}\n\n\t\tObject mappedHandler = this.handlerMap.get(urlPath);\n\t\tif (mappedHandler != null) {\n\t\t\tif (mappedHandler != resolvedHandler) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Cannot map \" + getHandlerDescription(handler) + \" to URL path [\" + urlPath +\n\t\t\t\t\t\t\"]: There is already \" + getHandlerDescription(mappedHandler) + \" mapped.\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (urlPath.equals(\"/\")) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Root mapping to \" + getHandlerDescription(handler));\n\t\t\t\t}\n\t\t\t\tsetRootHandler(resolvedHandler);\n\t\t\t}\n\t\t\telse if (urlPath.equals(\"/*\")) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Default mapping to \" + getHandlerDescription(handler));\n\t\t\t\t}\n\t\t\t\tsetDefaultHandler(resolvedHandler);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.handlerMap.put(urlPath, resolvedHandler);\n\t\t\t\tif (getPatternParser() != null) {\n\t\t\t\t\tthis.pathPatternHandlerMap.put(getPatternParser().parse(urlPath), resolvedHandler);\n\t\t\t\t}\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Mapped [\" + urlPath + \"] onto \" + getHandlerDescription(handler));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.AbstractUrlHandlerMapping#registerHandler(urlPaths,beanName)": {
    "change": "modifier_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Register the specified handler for the given URL paths.\n\t * @param urlPaths the URLs that the bean should be mapped to\n\t * @param beanName the name of the handler bean\n\t * @throws BeansException if the handler couldn't be registered\n\t * @throws IllegalStateException if there is a conflicting handler registered\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "urlPaths",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 399
    },
    "return": "void",
    "signature": "protected void registerHandler(String[] urlPaths, String beanName)",
    "source_code": "\tprotected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {\n\t\tAssert.notNull(urlPaths, \"URL path array must not be null\");\n\t\tfor (String urlPath : urlPaths) {\n\t\t\tregisterHandler(urlPath, beanName);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.AbstractUrlHandlerMapping#unregisterHandler(urlPath)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Remove the mapping for the handler registered for the given URL path.\n\t * @param urlPath the mapping to remove\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "urlPath"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "void",
    "signature": "public void unregisterHandler(String urlPath)",
    "source_code": "\tpublic void unregisterHandler(String urlPath) {\n\t\tAssert.notNull(urlPath, \"URL path must not be null\");\n\t\tif (urlPath.equals(\"/\")) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Removing root mapping: \" + getRootHandler());\n\t\t\t}\n\t\t\tsetRootHandler(null);\n\t\t}\n\t\telse if (urlPath.equals(\"/*\")) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Removing default mapping: \" + getDefaultHandler());\n\t\t\t}\n\t\t\tsetDefaultHandler(null);\n\t\t}\n\t\telse {\n\t\t\tObject mappedHandler = this.handlerMap.get(urlPath);\n\t\t\tif (mappedHandler == null) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"No mapping for [\" + urlPath + \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Removing mapping \\\"\" + urlPath + \"\\\": \" + getHandlerDescription(mappedHandler));\n\t\t\t\t}\n\t\t\t\tthis.handlerMap.remove(urlPath);\n\t\t\t\tif (getPatternParser() != null) {\n\t\t\t\t\tthis.pathPatternHandlerMap.remove(getPatternParser().parse(urlPath));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.HandlerMappingIntrospector#allHandlerMappingsUsePathPatternParser()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return {@code true} if all {@link HandlerMapping} beans\n\t * {@link HandlerMapping#usesPathPatterns() use parsed PathPatterns},\n\t * and {@code false} if any don't.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "boolean",
    "signature": "public boolean allHandlerMappingsUsePathPatternParser()",
    "source_code": "\tpublic boolean allHandlerMappingsUsePathPatternParser() {\n\t\tAssert.state(this.handlerMappings != null, \"Not yet initialized via afterPropertiesSet.\");\n\t\treturn getHandlerMappings().stream().allMatch(HandlerMapping::usesPathPatterns);\n\t}"
  },
  "org.springframework.web.servlet.handler.HandlerMappingIntrospector#handlePreFlight(request,response)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the matching {@link HandlerMapping} for the request, and invoke the\n\t * handler it returns as a {@link PreFlightRequestHandler}.\n\t * @throws NoHandlerFoundException if no handler matches the request\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "void",
    "signature": "public void handlePreFlight(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tpublic void handlePreFlight(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t\tAssert.state(this.handlerMappings != null, \"Not yet initialized via afterPropertiesSet.\");\n\t\tAssert.state(CorsUtils.isPreFlightRequest(request), \"Not a pre-flight request.\");\n\t\tRequestPath previousPath = (RequestPath) request.getAttribute(ServletRequestPathUtils.PATH_ATTRIBUTE);\n\t\ttry {\n\t\t\tServletRequestPathUtils.parseAndCache(request);\n\t\t\tfor (HandlerMapping mapping : this.handlerMappings) {\n\t\t\t\tHandlerExecutionChain chain = mapping.getHandler(request);\n\t\t\t\tif (chain != null) {\n\t\t\t\t\tObject handler = chain.getHandler();\n\t\t\t\t\tif (handler instanceof PreFlightRequestHandler preFlightHandler) {\n\t\t\t\t\t\tpreFlightHandler.handlePreFlight(request, response);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthrow new IllegalStateException(\"Expected PreFlightRequestHandler: \" + handler.getClass());\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new NoHandlerFoundException(\n\t\t\t\t\trequest.getMethod(), request.getRequestURI(), new ServletServerHttpRequest(request).getHeaders());\n\t\t}\n\t\tfinally {\n\t\t\tServletRequestPathUtils.setParsedRequestPath(previousPath, request);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#getTaskDecorator()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 591
    },
    "return": "TaskDecorator",
    "signature": "public TaskDecorator getTaskDecorator()",
    "source_code": "\t\tpublic TaskDecorator getTaskDecorator() {\n\t\t\treturn new ContextPropagatingTaskDecorator(this.snapshotFactory);\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver#getNestedTypeIfNeeded(type)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the generic type of the {@code returnType} (or of the nested type\n\t * if it is an {@link HttpEntity} or/and an {@link Optional}).\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 253
    },
    "return": "ResolvableType",
    "signature": "protected ResolvableType getNestedTypeIfNeeded(ResolvableType type)",
    "source_code": "\tprotected ResolvableType getNestedTypeIfNeeded(ResolvableType type) {\n\t\tResolvableType genericType = type;\n\t\tif (Optional.class.isAssignableFrom(genericType.toClass())) {\n\t\t\tgenericType = genericType.getNested(2);\n\t\t}\n\t\tif (HttpEntity.class.isAssignableFrom(genericType.toClass())) {\n\t\t\tgenericType = genericType.getNested(2);\n\t\t}\n\t\treturn genericType;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor#invokeErrorResponseInterceptors(detail,errorResponse)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the configured {@link ErrorResponse.Interceptor}'s.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "detail",
      "errorResponse"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "void",
    "signature": "protected void invokeErrorResponseInterceptors(ProblemDetail detail, @Nullable ErrorResponse errorResponse)",
    "source_code": "\tprotected void invokeErrorResponseInterceptors(ProblemDetail detail, @Nullable ErrorResponse errorResponse) {\n\t\ttry {\n\t\t\tfor (ErrorResponse.Interceptor handler : this.errorResponseInterceptors) {\n\t\t\t\thandler.handleError(detail, errorResponse);\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\t// ignore\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ConverterType": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "enum",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "signature": "protected enum ConverterType",
    "source_code": "\tprotected enum ConverterType { BASE, GENERIC, SMART };"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#getExceptionHandlerMethod(handlerMethod,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find an {@code @ExceptionHandler} method for the given exception. The default\n\t * implementation searches methods in the class hierarchy of the controller first\n\t * and if not found, it continues searching for additional {@code @ExceptionHandler}\n\t * methods assuming some {@linkplain ControllerAdvice @ControllerAdvice}\n\t * Spring-managed beans were detected.\n\t * @param handlerMethod the method where the exception was raised (may be {@code null})\n\t * @param exception the raised exception\n\t * @return a method to handle the exception, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handlerMethod",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 477
    },
    "return": "ServletInvocableHandlerMethod",
    "signature": "protected ServletInvocableHandlerMethod getExceptionHandlerMethod(@Nullable HandlerMethod handlerMethod, Exception exception)",
    "source_code": "\tprotected ServletInvocableHandlerMethod getExceptionHandlerMethod("
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#getExceptionHandlerMethod(handlerMethod,exception,webRequest)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find an {@code @ExceptionHandler} method for the given exception. The default\n\t * implementation searches methods in the class hierarchy of the controller first\n\t * and if not found, it continues searching for additional {@code @ExceptionHandler}\n\t * methods assuming some {@linkplain ControllerAdvice @ControllerAdvice}\n\t * Spring-managed beans were detected.\n\t * @param handlerMethod the method where the exception was raised (may be {@code null})\n\t * @param exception the raised exception\n\t * @param webRequest the original web request that resulted in a handler error\n\t * @return a method to handle the exception, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handlerMethod",
      "exception",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 517
    },
    "return": "ServletInvocableHandlerMethod",
    "signature": "protected ServletInvocableHandlerMethod getExceptionHandlerMethod(@Nullable HandlerMethod handlerMethod, Exception exception, ServletWebRequest webRequest)",
    "source_code": "\tprotected ServletInvocableHandlerMethod getExceptionHandlerMethod("
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#setErrorResponseInterceptors(interceptors)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a list of {@link ErrorResponse.Interceptor}'s to apply when\n\t * rendering an RFC 9457 {@link org.springframework.http.ProblemDetail}\n\t * error response.\n\t * @param interceptors the handlers to use\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "interceptors"
    ],
    "position": {
      "column": 1,
      "line": 259
    },
    "return": "void",
    "signature": "public void setErrorResponseInterceptors(List<ErrorResponse.Interceptor> interceptors)",
    "source_code": "\tpublic void setErrorResponseInterceptors(List<ErrorResponse.Interceptor> interceptors) {\n\t\tthis.errorResponseInterceptors.clear();\n\t\tthis.errorResponseInterceptors.addAll(interceptors);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExtendedServletRequestDataBinder": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Subclass of {@link ServletRequestDataBinder} that adds URI template variables\n * to the values used for data binding.\n *\n * <p><strong>WARNING</strong>: Data binding can lead to security issues by exposing\n * parts of the object graph that are not meant to be accessed or modified by\n * external clients. Therefore, the design and use of data binding should be considered\n * carefully with regard to security. For more details, please refer to the dedicated\n * sections on data binding for\n * <a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-initbinder-model-design\">Spring Web MVC</a> and\n * <a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-initbinder-model-design\">Spring WebFlux</a>\n * in the reference manual.\n *\n * @author Rossen Stoyanchev\n * @since 3.1\n * @see ServletRequestDataBinder\n * @see HandlerMapping#URI_TEMPLATE_VARIABLES_ATTRIBUTE\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "signature": "public class ExtendedServletRequestDataBinder",
    "source_code": "public class ExtendedServletRequestDataBinder extends ServletRequestDataBinder {\n\n\tprivate static final Set<String> FILTERED_HEADER_NAMES = Set.of(\"accept\", \"authorization\", \"connection\",\n\t\t\t\"cookie\", \"from\", \"host\", \"origin\", \"priority\", \"range\", \"referer\", \"upgrade\");\n\n\n\tprivate Predicate<String> headerPredicate = name -> !FILTERED_HEADER_NAMES.contains(name.toLowerCase(Locale.ROOT));\n\n\n\t/**\n\t * Create a new instance, with default object name.\n\t * @param target the target object to bind onto (or {@code null}\n\t * if the binder is just used to convert a plain parameter value)\n\t * @see #DEFAULT_OBJECT_NAME\n\t */\n\tpublic ExtendedServletRequestDataBinder(@Nullable Object target) {\n\t\tsuper(target);\n\t}\n\n\t/**\n\t * Create a new instance.\n\t * @param target the target object to bind onto (or {@code null}\n\t * if the binder is just used to convert a plain parameter value)\n\t * @param objectName the name of the target object\n\t * @see #DEFAULT_OBJECT_NAME\n\t */\n\tpublic ExtendedServletRequestDataBinder(@Nullable Object target, String objectName) {\n\t\tsuper(target, objectName);\n\t}\n\n\n\t/**\n\t * Add a Predicate that filters the header names to use for data binding.\n\t * Multiple predicates are combined with {@code AND}.\n\t * @param headerPredicate the predicate to add\n\t * @since 6.2.1\n\t */\n\tpublic void addHeaderPredicate(Predicate<String> headerPredicate) {\n\t\tthis.headerPredicate = this.headerPredicate.and(headerPredicate);\n\t}\n\n\t/**\n\t * Set the Predicate that filters the header names to use for data binding.\n\t * <p>Note that this method resets any previous predicates that may have been\n\t * set, including headers excluded by default such as the RFC 9218 defined\n\t * \"Priority\" header.\n\t * @param headerPredicate the predicate to add\n\t * @since 6.2.1\n\t */\n\tpublic void setHeaderPredicate(Predicate<String> headerPredicate) {\n\t\tthis.headerPredicate = headerPredicate;\n\t}\n\n\n\t@Override\n\tprotected ServletRequestValueResolver createValueResolver(ServletRequest request) {\n\t\treturn new ExtendedServletRequestValueResolver(request, this);\n\t}\n\n\t/**\n\t * Merge URI variables into the property values to use for data binding.\n\t */\n\t@Override\n\tprotected void addBindValues(MutablePropertyValues mpvs, ServletRequest request) {\n\t\tMap<String, String> uriVars = getUriVars(request);\n\t\tif (uriVars != null) {\n\t\t\turiVars.forEach((name, value) -> addValueIfNotPresent(mpvs, \"URI variable\", name, value));\n\t\t}\n\t\tif (request instanceof HttpServletRequest httpRequest) {\n\t\t\tEnumeration<String> names = httpRequest.getHeaderNames();\n\t\t\twhile (names.hasMoreElements()) {\n\t\t\t\tString name = names.nextElement();\n\t\t\t\tObject value = getHeaderValue(httpRequest, name);\n\t\t\t\tif (value != null) {\n\t\t\t\t\tname = normalizeHeaderName(name);\n\t\t\t\t\taddValueIfNotPresent(mpvs, \"Header\", name, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Nullable\n\tprivate static Map<String, String> getUriVars(ServletRequest request) {\n\t\treturn (Map<String, String>) request.getAttribute(HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE);\n\t}\n\n\tprivate static void addValueIfNotPresent(MutablePropertyValues mpvs, String label, String name, Object value) {\n\t\tif (mpvs.contains(name)) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(label + \" '\" + name + \"' overridden by request bind value.\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tmpvs.addPropertyValue(name, value);\n\t\t}\n\t}\n\n\t@Nullable\n\tprivate Object getHeaderValue(HttpServletRequest request, String name) {\n\t\tif (!this.headerPredicate.test(name)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tEnumeration<String> valuesEnum = request.getHeaders(name);\n\t\tif (!valuesEnum.hasMoreElements()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString value = valuesEnum.nextElement();\n\t\tif (!valuesEnum.hasMoreElements()) {\n\t\t\treturn value;\n\t\t}\n\n\t\tList<Object> values = new ArrayList<>();\n\t\tvalues.add(value);\n\t\twhile (valuesEnum.hasMoreElements()) {\n\t\t\tvalues.add(valuesEnum.nextElement());\n\t\t}\n\t\treturn values;\n\t}\n\n\tprivate static String normalizeHeaderName(String name) {\n\t\treturn StringUtils.uncapitalize(name.replace(\"-\", \"\"));\n\t}\n\n\n\t/**\n\t * Resolver of values that looks up URI path variables.\n\t */\n\tprivate class ExtendedServletRequestValueResolver extends ServletRequestValueResolver {\n\n\t\tExtendedServletRequestValueResolver(ServletRequest request, WebDataBinder dataBinder) {\n\t\t\tsuper(request, dataBinder);\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tprotected Object getRequestParameter(String name, Class<?> type) {\n\t\t\tObject value = super.getRequestParameter(name, type);\n\t\t\tif (value == null) {\n\t\t\t\tMap<String, String> uriVars = getUriVars(getRequest());\n\t\t\t\tif (uriVars != null) {\n\t\t\t\t\tvalue = uriVars.get(name);\n\t\t\t\t}\n\t\t\t\tif (value == null && getRequest() instanceof HttpServletRequest httpServletRequest) {\n\t\t\t\t\tvalue = getHeaderValue(httpServletRequest, name);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Set<String> initParameterNames(ServletRequest request) {\n\t\t\tSet<String> set = super.initParameterNames(request);\n\t\t\tMap<String, String> uriVars = getUriVars(getRequest());\n\t\t\tif (uriVars != null) {\n\t\t\t\tset.addAll(uriVars.keySet());\n\t\t\t}\n\t\t\tif (request instanceof HttpServletRequest httpServletRequest) {\n\t\t\t\tEnumeration<String> enumeration = httpServletRequest.getHeaderNames();\n\t\t\t\twhile (enumeration.hasMoreElements()) {\n\t\t\t\t\tString name = enumeration.nextElement();\n\t\t\t\t\tif (headerPredicate.test(name)) {\n\t\t\t\t\t\tset.add(normalizeHeaderName(name));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn set;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExtendedServletRequestDataBinder#addBindValues(mpvs,request)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Merge URI variables into the property values to use for data binding.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mpvs",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "void",
    "signature": "protected void addBindValues(MutablePropertyValues mpvs, ServletRequest request)",
    "source_code": "\tprotected void addBindValues(MutablePropertyValues mpvs, ServletRequest request) {\n\t\tMap<String, String> uriVars = getUriVars(request);\n\t\tif (uriVars != null) {\n\t\t\turiVars.forEach((name, value) -> addValueIfNotPresent(mpvs, \"URI variable\", name, value));\n\t\t}\n\t\tif (request instanceof HttpServletRequest httpRequest) {\n\t\t\tEnumeration<String> names = httpRequest.getHeaderNames();\n\t\t\twhile (names.hasMoreElements()) {\n\t\t\t\tString name = names.nextElement();\n\t\t\t\tObject value = getHeaderValue(httpRequest, name);\n\t\t\t\tif (value != null) {\n\t\t\t\t\tname = normalizeHeaderName(name);\n\t\t\t\t\taddValueIfNotPresent(mpvs, \"Header\", name, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExtendedServletRequestDataBinder#addHeaderPredicate(headerPredicate)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a Predicate that filters the header names to use for data binding.\n\t * Multiple predicates are combined with {@code AND}.\n\t * @param headerPredicate the predicate to add\n\t * @since 6.2.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerPredicate"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "void",
    "signature": "public void addHeaderPredicate(Predicate<String> headerPredicate)",
    "source_code": "\tpublic void addHeaderPredicate(Predicate<String> headerPredicate) {\n\t\tthis.headerPredicate = this.headerPredicate.and(headerPredicate);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExtendedServletRequestDataBinder#createValueResolver(request)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "ServletRequestValueResolver",
    "signature": "protected ServletRequestValueResolver createValueResolver(ServletRequest request)",
    "source_code": "\tprotected ServletRequestValueResolver createValueResolver(ServletRequest request) {\n\t\treturn new ExtendedServletRequestValueResolver(request, this);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExtendedServletRequestDataBinder#getRequestParameter(name,type)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "Object",
    "signature": "protected Object getRequestParameter(String name, Class<?> type)",
    "source_code": "\t\tprotected Object getRequestParameter(String name, Class<?> type) {\n\t\t\tObject value = super.getRequestParameter(name, type);\n\t\t\tif (value == null) {\n\t\t\t\tMap<String, String> uriVars = getUriVars(getRequest());\n\t\t\t\tif (uriVars != null) {\n\t\t\t\t\tvalue = uriVars.get(name);\n\t\t\t\t}\n\t\t\t\tif (value == null && getRequest() instanceof HttpServletRequest httpServletRequest) {\n\t\t\t\t\tvalue = getHeaderValue(httpServletRequest, name);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExtendedServletRequestDataBinder#initParameterNames(request)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "Set<String>",
    "signature": "protected Set<String> initParameterNames(ServletRequest request)",
    "source_code": "\t\tprotected Set<String> initParameterNames(ServletRequest request) {\n\t\t\tSet<String> set = super.initParameterNames(request);\n\t\t\tMap<String, String> uriVars = getUriVars(getRequest());\n\t\t\tif (uriVars != null) {\n\t\t\t\tset.addAll(uriVars.keySet());\n\t\t\t}\n\t\t\tif (request instanceof HttpServletRequest httpServletRequest) {\n\t\t\t\tEnumeration<String> enumeration = httpServletRequest.getHeaderNames();\n\t\t\t\twhile (enumeration.hasMoreElements()) {\n\t\t\t\t\tString name = enumeration.nextElement();\n\t\t\t\t\tif (headerPredicate.test(name)) {\n\t\t\t\t\t\tset.add(normalizeHeaderName(name));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn set;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExtendedServletRequestDataBinder#setHeaderPredicate(headerPredicate)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Predicate that filters the header names to use for data binding.\n\t * <p>Note that this method resets any previous predicates that may have been\n\t * set, including headers excluded by default such as the RFC 9218 defined\n\t * \"Priority\" header.\n\t * @param headerPredicate the predicate to add\n\t * @since 6.2.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerPredicate"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "void",
    "signature": "public void setHeaderPredicate(Predicate<String> headerPredicate)",
    "source_code": "\tpublic void setHeaderPredicate(Predicate<String> headerPredicate) {\n\t\tthis.headerPredicate = headerPredicate;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#setErrorResponseInterceptors(interceptors)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a list of {@link ErrorResponse.Interceptor}'s to apply when\n\t * rendering an RFC 9457 {@link org.springframework.http.ProblemDetail}\n\t * error response.\n\t * @param interceptors the interceptors to use\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "interceptors"
    ],
    "position": {
      "column": 1,
      "line": 416
    },
    "return": "void",
    "signature": "public void setErrorResponseInterceptors(List<ErrorResponse.Interceptor> interceptors)",
    "source_code": "\tpublic void setErrorResponseInterceptors(List<ErrorResponse.Interceptor> interceptors) {\n\t\tthis.errorResponseInterceptors.clear();\n\t\tthis.errorResponseInterceptors.addAll(interceptors);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ResponseBodyEmitterReturnValueHandler#getFragmentContent()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 472
    },
    "return": "byte[]",
    "signature": "public byte[] getFragmentContent()",
    "source_code": "\t\tpublic byte[] getFragmentContent() {\n\t\t\tthis.writer.flush();\n\t\t\tString content = this.outputStream.toString(this.charset);\n\t\t\tcontent = content.replace(\"\\n\", \"\\ndata:\");\n\t\t\treturn content.getBytes(this.charset);\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ResponseBodyEmitterReturnValueHandler#getOutputStream()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 463
    },
    "return": "ServletOutputStream",
    "signature": "public ServletOutputStream getOutputStream()",
    "source_code": "\t\tpublic ServletOutputStream getOutputStream() {\n\t\t\treturn this.outputStream;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ResponseBodyEmitterReturnValueHandler#getWriter()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 468
    },
    "return": "PrintWriter",
    "signature": "public PrintWriter getWriter()",
    "source_code": "\t\tpublic PrintWriter getWriter() {\n\t\t\treturn this.writer;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ResponseBodyEmitterReturnValueHandler#handle(modelAndView)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "modelAndView"
    ],
    "position": {
      "column": 1,
      "line": 390
    },
    "return": "void",
    "signature": "public void handle(ModelAndView modelAndView)",
    "source_code": "\t\tpublic void handle(ModelAndView modelAndView) throws IOException {\n\t\t\tRequestContextHolder.setRequestAttributes(this.requestAttributes);\n\t\t\ttry {\n\t\t\t\tFragmentHttpServletResponse fragmentResponse =\n\t\t\t\t\t\tnew FragmentHttpServletResponse(this.response, this.charset);\n\n\t\t\t\tFragmentsRendering render = FragmentsRendering.with(List.of(modelAndView)).build();\n\t\t\t\trender.resolveNestedViews(this::resolveViewName, this.locale);\n\t\t\t\trender.render(modelAndView.getModel(), this.request, fragmentResponse);\n\n\t\t\t\tbyte[] content = fragmentResponse.getFragmentContent();\n\t\t\t\tthis.response.getOutputStream().write(content);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new RuntimeException(\"Failed to render \" + modelAndView, ex);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tRequestContextHolder.resetRequestAttributes();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ResponseBodyEmitterReturnValueHandler#isReady()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 504
    },
    "return": "boolean",
    "signature": "public boolean isReady()",
    "source_code": "\t\tpublic boolean isReady() {\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ResponseBodyEmitterReturnValueHandler#resolveViewName(viewName,locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 415
    },
    "return": "View",
    "signature": "public View resolveViewName(String viewName, Locale locale)",
    "source_code": "\t\tpublic View resolveViewName(String viewName, Locale locale) throws Exception {\n\t\t\tfor (ViewResolver resolver : this.viewResolvers) {\n\t\t\t\tView view = resolver.resolveViewName(viewName, locale);\n\t\t\t\tif (view != null) {\n\t\t\t\t\treturn view;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ResponseBodyEmitterReturnValueHandler#setCharacterEncoding(charset)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 453
    },
    "return": "void",
    "signature": "public void setCharacterEncoding(String charset)",
    "source_code": "\t\tpublic void setCharacterEncoding(String charset) {\n\t\t\t// ignore\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ResponseBodyEmitterReturnValueHandler#setContentLength(len)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "len"
    ],
    "position": {
      "column": 1,
      "line": 458
    },
    "return": "void",
    "signature": "public void setContentLength(int len)",
    "source_code": "\t\tpublic void setContentLength(int len) {\n\t\t\t// ignore\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ResponseBodyEmitterReturnValueHandler#setContentType(type)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 448
    },
    "return": "void",
    "signature": "public void setContentType(String type)",
    "source_code": "\t\tpublic void setContentType(String type) {\n\t\t\t// ignore\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ResponseBodyEmitterReturnValueHandler#setWriteListener(writeListener)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "writeListener"
    ],
    "position": {
      "column": 1,
      "line": 509
    },
    "return": "void",
    "signature": "public void setWriteListener(WriteListener writeListener)",
    "source_code": "\t\tpublic void setWriteListener(WriteListener writeListener) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ResponseBodyEmitterReturnValueHandler#toString(charset)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 513
    },
    "return": "String",
    "signature": "public String toString(Charset charset)",
    "source_code": "\t\tpublic String toString(Charset charset) {\n\t\t\treturn this.outputStream.toString(charset);\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ResponseBodyEmitterReturnValueHandler#write(b)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b"
    ],
    "position": {
      "column": 1,
      "line": 494
    },
    "return": "void",
    "signature": "public void write(byte[] b)",
    "source_code": "\t\tpublic void write(byte[] b) throws IOException {\n\t\t\tthis.outputStream.write(b);\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ResponseBodyEmitterReturnValueHandler#write(b,off,len)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b",
      "off",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 499
    },
    "return": "void",
    "signature": "public void write(byte[] b, int off, int len)",
    "source_code": "\t\tpublic void write(byte[] b, int off, int len) {\n\t\t\tthis.outputStream.write(b, off, len);\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler#handleAsyncRequestNotUsableException(ex,request)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link AsyncRequestNotUsableException}.\n\t * <p>By default, return {@code null} since the response is not usable.\n\t * @param ex the exception to handle\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 584
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleAsyncRequestNotUsableException(AsyncRequestNotUsableException ex, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleAsyncRequestNotUsableException("
  },
  "org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler#handleBindException(ex,headers,status,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link BindException}.\n\t * <p>By default this method creates a {@link ProblemDetail} with the status\n\t * and a short detail message, and then delegates to\n\t * {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @deprecated as of 6.0 since {@link org.springframework.web.method.annotation.ModelAttributeMethodProcessor}\n\t * now raises the {@link MethodArgumentNotValidException} subclass instead.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 568
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleBindException(BindException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleBindException("
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#handleBindException(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where an {@linkplain ModelAttribute @ModelAttribute} method\n\t * argument has binding or validation errors and is not followed by another\n\t * method argument of type {@link BindingResult}.\n\t * <p>By default, an HTTP 400 error is sent back to the client.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @deprecated as of 6.0 since {@link org.springframework.web.method.annotation.ModelAttributeMethodProcessor}\n\t * now raises the {@link MethodArgumentNotValidException} subclass instead.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 683
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleBindException(BindException ex, HttpServletRequest request,\n\t\t\tHttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleBindException(BindException ex, HttpServletRequest request,"
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#handleDisconnectedClientException(ex,request,response,handler)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle an Exception that indicates the client has gone away. This is\n\t * typically an {@link IOException} of a specific subtype or with a message\n\t * specific to the underlying Servlet container. Those are detected through\n\t * {@link DisconnectedClientHelper#isClientDisconnectedException(Throwable)}\n\t * <p>By default, do nothing since the response is not usable.\n\t * @param ex the {@code Exception} to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen\n\t * at the time of the exception (for example, if multipart resolution failed)\n\t * @return an empty ModelAndView indicating the exception was handled\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 535
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleDisconnectedClientException(Exception ex, HttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleDisconnectedClientException("
  },
  "org.springframework.web.servlet.resource.PathResourceResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A simple {@code ResourceResolver} that tries to find a resource under the given\n * locations matching to the request path.\n *\n * <p>This resolver does not delegate to the {@code ResourceResolverChain} and is\n * expected to be configured at the end in a chain of resolvers.\n *\n * @author Jeremy Grelle\n * @author Rossen Stoyanchev\n * @author Sam Brannen\n * @since 4.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "signature": "public class PathResourceResolver",
    "source_code": "public class PathResourceResolver extends AbstractResourceResolver {\n\n\t@Nullable\n\tprivate Resource[] allowedLocations;\n\n\tprivate final Map<Resource, Charset> locationCharsets = new HashMap<>(4);\n\n\t@Nullable\n\tprivate UrlPathHelper urlPathHelper;\n\n\n\t/**\n\t * By default, when a Resource is found, the path of the resolved resource is\n\t * compared to ensure it's under the input location where it was found.\n\t * However sometimes that may not be the case, e.g. when\n\t * {@link org.springframework.web.servlet.resource.CssLinkResourceTransformer}\n\t * resolves public URLs of links it contains, the CSS file is the location\n\t * and the resources being resolved are css files, images, fonts and others\n\t * located in adjacent or parent directories.\n\t * <p>This property allows configuring a complete list of locations under\n\t * which resources must be so that if a resource is not under the location\n\t * relative to which it was found, this list may be checked as well.\n\t * <p>By default {@link ResourceHttpRequestHandler} initializes this property\n\t * to match its list of locations.\n\t * @param locations the list of allowed locations\n\t * @since 4.1.2\n\t * @see ResourceHttpRequestHandler#initAllowedLocations()\n\t */\n\tpublic void setAllowedLocations(@Nullable Resource... locations) {\n\t\tthis.allowedLocations = locations;\n\t}\n\n\t@Nullable\n\tpublic Resource[] getAllowedLocations() {\n\t\treturn this.allowedLocations;\n\t}\n\n\t/**\n\t * Configure charsets associated with locations. If a static resource is found\n\t * under a {@link org.springframework.core.io.UrlResource URL resource}\n\t * location the charset is used to encode the relative path\n\t * <p><strong>Note:</strong> the charset is used only if the\n\t * {@link #setUrlPathHelper urlPathHelper} property is also configured and\n\t * its {@code urlDecode} property is set to true.\n\t * @since 4.3.13\n\t */\n\tpublic void setLocationCharsets(Map<Resource, Charset> locationCharsets) {\n\t\tthis.locationCharsets.clear();\n\t\tthis.locationCharsets.putAll(locationCharsets);\n\t}\n\n\t/**\n\t * Return charsets associated with static resource locations.\n\t * @since 4.3.13\n\t */\n\tpublic Map<Resource, Charset> getLocationCharsets() {\n\t\treturn Collections.unmodifiableMap(this.locationCharsets);\n\t}\n\n\t/**\n\t * Provide a reference to the {@link UrlPathHelper} used to map requests to\n\t * static resources. This helps to derive information about the lookup path\n\t * such as whether it is decoded or not.\n\t * @since 4.3.13\n\t */\n\tpublic void setUrlPathHelper(@Nullable UrlPathHelper urlPathHelper) {\n\t\tthis.urlPathHelper = urlPathHelper;\n\t}\n\n\t/**\n\t * The configured {@link UrlPathHelper}.\n\t * @since 4.3.13\n\t */\n\t@Nullable\n\tpublic UrlPathHelper getUrlPathHelper() {\n\t\treturn this.urlPathHelper;\n\t}\n\n\n\t@Override\n\t@Nullable\n\tprotected Resource resolveResourceInternal(@Nullable HttpServletRequest request, String requestPath,\n\t\t\tList<? extends Resource> locations, ResourceResolverChain chain) {\n\n\t\treturn getResource(requestPath, request, locations);\n\t}\n\n\t@Override\n\t@Nullable\n\tprotected String resolveUrlPathInternal(String resourcePath, List<? extends Resource> locations,\n\t\t\tResourceResolverChain chain) {\n\n\t\treturn (StringUtils.hasText(resourcePath) &&\n\t\t\t\tgetResource(resourcePath, null, locations) != null ? resourcePath : null);\n\t}\n\n\t@Nullable\n\tprivate Resource getResource(String resourcePath, @Nullable HttpServletRequest request,\n\t\t\tList<? extends Resource> locations) {\n\n\t\tfor (Resource location : locations) {\n\t\t\ttry {\n\t\t\t\tString pathToUse = encodeOrDecodeIfNecessary(resourcePath, request, location);\n\t\t\t\tResource resource = getResource(pathToUse, location);\n\t\t\t\tif (resource != null) {\n\t\t\t\t\treturn resource;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tString error = \"Skip location [\" + location + \"] due to error\";\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(error, ex);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlogger.debug(error + \": \" + ex.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Find the resource under the given location.\n\t * <p>The default implementation checks if there is a readable\n\t * {@code Resource} for the given path relative to the location.\n\t * @param resourcePath the path to the resource\n\t * @param location the location to check\n\t * @return the resource, or {@code null} if none found\n\t */\n\t@Nullable\n\tprotected Resource getResource(String resourcePath, Resource location) throws IOException {\n\t\tResource resource = location.createRelative(resourcePath);\n\t\tif (resource.isReadable()) {\n\t\t\tif (checkResource(resource, location)) {\n\t\t\t\treturn resource;\n\t\t\t}\n\t\t\telse if (logger.isWarnEnabled()) {\n\t\t\t\tResource[] allowed = getAllowedLocations();\n\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\"Resource path \\\"\" + resourcePath + \"\\\" was successfully resolved \" +\n\t\t\t\t\t\t\t\t\"but resource \\\"\" + resource + \"\\\" is neither under \" +\n\t\t\t\t\t\t\t\t\"the current location \\\"\" + location + \"\\\" nor under any of \" +\n\t\t\t\t\t\t\t\t\"the allowed locations \" + (allowed != null ? Arrays.asList(allowed) : \"[]\"), -1, true));\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Perform additional checks on a resolved resource beyond checking whether the\n\t * resource exists and is readable. The default implementation also verifies\n\t * the resource is either under the location relative to which it was found or\n\t * is under one of the {@linkplain #setAllowedLocations allowed locations}.\n\t * @param resource the resource to check\n\t * @param location the location relative to which the resource was found\n\t * @return \"true\" if resource is in a valid location, \"false\" otherwise\n\t * @since 4.1.2\n\t */\n\tprotected boolean checkResource(Resource resource, Resource location) throws IOException {\n\t\tif (isResourceUnderLocation(resource, location)) {\n\t\t\treturn true;\n\t\t}\n\t\tResource[] allowedLocations = getAllowedLocations();\n\t\tif (allowedLocations != null) {\n\t\t\tfor (Resource current : allowedLocations) {\n\t\t\t\tif (isResourceUnderLocation(resource, current)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean isResourceUnderLocation(Resource resource, Resource location) throws IOException {\n\t\tif (resource.getClass() != location.getClass()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tString resourcePath;\n\t\tString locationPath;\n\n\t\tif (resource instanceof UrlResource) {\n\t\t\tresourcePath = resource.getURL().toExternalForm();\n\t\t\tlocationPath = StringUtils.cleanPath(location.getURL().toString());\n\t\t}\n\t\telse if (resource instanceof ClassPathResource classPathResource) {\n\t\t\tresourcePath = classPathResource.getPath();\n\t\t\tlocationPath = StringUtils.cleanPath(((ClassPathResource) location).getPath());\n\t\t}\n\t\telse if (resource instanceof ServletContextResource servletContextResource) {\n\t\t\tresourcePath = servletContextResource.getPath();\n\t\t\tlocationPath = StringUtils.cleanPath(((ServletContextResource) location).getPath());\n\t\t}\n\t\telse {\n\t\t\tresourcePath = resource.getURL().getPath();\n\t\t\tlocationPath = StringUtils.cleanPath(location.getURL().getPath());\n\t\t}\n\n\t\tif (locationPath.equals(resourcePath)) {\n\t\t\treturn true;\n\t\t}\n\t\tlocationPath = (locationPath.endsWith(\"/\") || locationPath.isEmpty() ? locationPath : locationPath + \"/\");\n\t\treturn (resourcePath.startsWith(locationPath) && !isInvalidEncodedPath(resourcePath));\n\t}\n\n\tprivate String encodeOrDecodeIfNecessary(String path, @Nullable HttpServletRequest request, Resource location) {\n\t\tif (request != null) {\n\t\t\tboolean usesPathPattern = (\n\t\t\t\t\tServletRequestPathUtils.hasCachedPath(request) &&\n\t\t\t\t\tServletRequestPathUtils.getCachedPath(request) instanceof PathContainer);\n\n\t\t\tif (shouldDecodeRelativePath(location, usesPathPattern)) {\n\t\t\t\treturn UriUtils.decode(path, StandardCharsets.UTF_8);\n\t\t\t}\n\t\t\telse if (shouldEncodeRelativePath(location, usesPathPattern)) {\n\t\t\t\tCharset charset = this.locationCharsets.getOrDefault(location, StandardCharsets.UTF_8);\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tStringTokenizer tokenizer = new StringTokenizer(path, \"/\");\n\t\t\t\twhile (tokenizer.hasMoreTokens()) {\n\t\t\t\t\tString value = UriUtils.encode(tokenizer.nextToken(), charset);\n\t\t\t\t\tsb.append(value);\n\t\t\t\t\tsb.append('/');\n\t\t\t\t}\n\t\t\t\tif (!path.endsWith(\"/\")) {\n\t\t\t\t\tsb.setLength(sb.length() - 1);\n\t\t\t\t}\n\t\t\t\treturn sb.toString();\n\t\t\t}\n\t\t}\n\t\treturn path;\n\t}\n\n\t/**\n\t * When the {@code HandlerMapping} is set to not decode the URL path, the\n\t * path needs to be decoded for non-{@code UrlResource} locations.\n\t */\n\tprivate boolean shouldDecodeRelativePath(Resource location, boolean usesPathPattern) {\n\t\treturn (!(location instanceof UrlResource) &&\n\t\t\t\t(usesPathPattern || (this.urlPathHelper != null && !this.urlPathHelper.isUrlDecode())));\n\t}\n\n\t/**\n\t * When the {@code HandlerMapping} is set to decode the URL path, the path\n\t * needs to be encoded for {@code UrlResource} locations.\n\t */\n\tprivate boolean shouldEncodeRelativePath(Resource location, boolean usesPathPattern) {\n\t\treturn (location instanceof UrlResource && !usesPathPattern &&\n\t\t\t\tthis.urlPathHelper != null && this.urlPathHelper.isUrlDecode());\n\t}\n\n\tprivate boolean isInvalidEncodedPath(String resourcePath) {\n\t\tif (resourcePath.contains(\"%\")) {\n\t\t\t// Use URLDecoder (vs UriUtils) to preserve potentially decoded UTF-8 chars...\n\t\t\ttry {\n\t\t\t\tString decodedPath = URLDecoder.decode(resourcePath, StandardCharsets.UTF_8);\n\t\t\t\tif (decodedPath.contains(\"../\") || decodedPath.contains(\"..\\\\\")) {\n\t\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\t\"Resolved resource path contains encoded \\\"../\\\" or \\\"..\\\\\\\": \" + resourcePath, -1, true));\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t// May not be possible to decode...\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n}"
  },
  "org.springframework.web.servlet.resource.PathResourceResolver#checkResource(resource,location)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform additional checks on a resolved resource beyond checking whether the\n\t * resource exists and is readable. The default implementation also verifies\n\t * the resource is either under the location relative to which it was found or\n\t * is under one of the {@linkplain #setAllowedLocations allowed locations}.\n\t * @param resource the resource to check\n\t * @param location the location relative to which the resource was found\n\t * @return \"true\" if resource is in a valid location, \"false\" otherwise\n\t * @since 4.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resource",
      "location"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "boolean",
    "signature": "protected boolean checkResource(Resource resource, Resource location)",
    "source_code": "\tprotected boolean checkResource(Resource resource, Resource location) throws IOException {\n\t\tif (isResourceUnderLocation(resource, location)) {\n\t\t\treturn true;\n\t\t}\n\t\tResource[] allowedLocations = getAllowedLocations();\n\t\tif (allowedLocations != null) {\n\t\t\tfor (Resource current : allowedLocations) {\n\t\t\t\tif (isResourceUnderLocation(resource, current)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.servlet.resource.PathResourceResolver#getAllowedLocations()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "Resource[]",
    "signature": "public Resource[] getAllowedLocations()",
    "source_code": "\tpublic Resource[] getAllowedLocations() {\n\t\treturn this.allowedLocations;\n\t}"
  },
  "org.springframework.web.servlet.resource.PathResourceResolver#getLocationCharsets()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return charsets associated with static resource locations.\n\t * @since 4.3.13\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "Charset>",
    "signature": "public Charset> getLocationCharsets()",
    "source_code": "\tpublic Map<Resource, Charset> getLocationCharsets() {\n\t\treturn Collections.unmodifiableMap(this.locationCharsets);\n\t}"
  },
  "org.springframework.web.servlet.resource.PathResourceResolver#getResource(resourcePath,location)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the resource under the given location.\n\t * <p>The default implementation checks if there is a readable\n\t * {@code Resource} for the given path relative to the location.\n\t * @param resourcePath the path to the resource\n\t * @param location the location to check\n\t * @return the resource, or {@code null} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourcePath",
      "location"
    ],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "Resource",
    "signature": "protected Resource getResource(String resourcePath, Resource location)",
    "source_code": "\tprotected Resource getResource(String resourcePath, Resource location) throws IOException {\n\t\tResource resource = location.createRelative(resourcePath);\n\t\tif (resource.isReadable()) {\n\t\t\tif (checkResource(resource, location)) {\n\t\t\t\treturn resource;\n\t\t\t}\n\t\t\telse if (logger.isWarnEnabled()) {\n\t\t\t\tResource[] allowed = getAllowedLocations();\n\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\"Resource path \\\"\" + resourcePath + \"\\\" was successfully resolved \" +\n\t\t\t\t\t\t\t\t\"but resource \\\"\" + resource + \"\\\" is neither under \" +\n\t\t\t\t\t\t\t\t\"the current location \\\"\" + location + \"\\\" nor under any of \" +\n\t\t\t\t\t\t\t\t\"the allowed locations \" + (allowed != null ? Arrays.asList(allowed) : \"[]\"), -1, true));\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.resource.PathResourceResolver#getUrlPathHelper()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The configured {@link UrlPathHelper}.\n\t * @since 4.3.13\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "UrlPathHelper",
    "signature": "public UrlPathHelper getUrlPathHelper()",
    "source_code": "\tpublic UrlPathHelper getUrlPathHelper() {\n\t\treturn this.urlPathHelper;\n\t}"
  },
  "org.springframework.web.servlet.resource.PathResourceResolver#resolveResourceInternal(request,requestPath,locations,chain)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "requestPath",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "Resource",
    "signature": "protected Resource resolveResourceInternal(@Nullable HttpServletRequest request, String requestPath,\n\t\t\tList<? extends Resource> locations, ResourceResolverChain chain)",
    "source_code": "\tprotected Resource resolveResourceInternal(@Nullable HttpServletRequest request, String requestPath,"
  },
  "org.springframework.web.servlet.resource.PathResourceResolver#resolveUrlPathInternal(resourcePath,locations,chain)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourcePath",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "String",
    "signature": "protected String resolveUrlPathInternal(String resourcePath, List<? extends Resource> locations,\n\t\t\tResourceResolverChain chain)",
    "source_code": "\tprotected String resolveUrlPathInternal(String resourcePath, List<? extends Resource> locations,"
  },
  "org.springframework.web.servlet.resource.PathResourceResolver#setAllowedLocations(locations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * By default, when a Resource is found, the path of the resolved resource is\n\t * compared to ensure it's under the input location where it was found.\n\t * However sometimes that may not be the case, e.g. when\n\t * {@link org.springframework.web.servlet.resource.CssLinkResourceTransformer}\n\t * resolves public URLs of links it contains, the CSS file is the location\n\t * and the resources being resolved are css files, images, fonts and others\n\t * located in adjacent or parent directories.\n\t * <p>This property allows configuring a complete list of locations under\n\t * which resources must be so that if a resource is not under the location\n\t * relative to which it was found, this list may be checked as well.\n\t * <p>By default {@link ResourceHttpRequestHandler} initializes this property\n\t * to match its list of locations.\n\t * @param locations the list of allowed locations\n\t * @since 4.1.2\n\t * @see ResourceHttpRequestHandler#initAllowedLocations()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locations"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "void",
    "signature": "public void setAllowedLocations(@Nullable Resource... locations)",
    "source_code": "\tpublic void setAllowedLocations(@Nullable Resource... locations) {\n\t\tthis.allowedLocations = locations;\n\t}"
  },
  "org.springframework.web.servlet.resource.PathResourceResolver#setLocationCharsets(Map<Resource,locationCharsets)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure charsets associated with locations. If a static resource is found\n\t * under a {@link org.springframework.core.io.UrlResource URL resource}\n\t * location the charset is used to encode the relative path\n\t * <p><strong>Note:</strong> the charset is used only if the\n\t * {@link #setUrlPathHelper urlPathHelper} property is also configured and\n\t * its {@code urlDecode} property is set to true.\n\t * @since 4.3.13\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Resource",
      "locationCharsets"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "void",
    "signature": "public void setLocationCharsets(Map<Resource, Charset> locationCharsets)",
    "source_code": "\tpublic void setLocationCharsets(Map<Resource, Charset> locationCharsets) {\n\t\tthis.locationCharsets.clear();\n\t\tthis.locationCharsets.putAll(locationCharsets);\n\t}"
  },
  "org.springframework.web.servlet.resource.PathResourceResolver#setUrlPathHelper(urlPathHelper)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide a reference to the {@link UrlPathHelper} used to map requests to\n\t * static resources. This helps to derive information about the lookup path\n\t * such as whether it is decoded or not.\n\t * @since 4.3.13\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "urlPathHelper"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "void",
    "signature": "public void setUrlPathHelper(@Nullable UrlPathHelper urlPathHelper)",
    "source_code": "\tpublic void setUrlPathHelper(@Nullable UrlPathHelper urlPathHelper) {\n\t\tthis.urlPathHelper = urlPathHelper;\n\t}"
  },
  "org.springframework.web.servlet.resource.ResourceHandlerUtils": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Resource handling utility methods to share common logic between\n * {@link ResourceHttpRequestHandler} and {@link org.springframework.web.servlet.function}.\n *\n * @author Rossen Stoyanchev\n * @since 6.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "signature": "public class ResourceHandlerUtils",
    "source_code": "public abstract class ResourceHandlerUtils {\n\n\tprivate static final Log logger = LogFactory.getLog(ResourceHandlerUtils.class);\n\n\tprivate static final String FOLDER_SEPARATOR = \"/\";\n\n\tprivate static final String WINDOWS_FOLDER_SEPARATOR = \"\\\\\";\n\n\n\t/**\n\t * Assert the given location is not null, and its path ends on slash.\n\t */\n\tpublic static void assertResourceLocation(@Nullable Resource location) {\n\t\tAssert.notNull(location, \"Resource location must not be null\");\n\t\ttry {\n\t\t\tString path;\n\t\t\tif (location instanceof org.springframework.core.io.PathResource) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if (location instanceof FileSystemResource fileSystemResource) {\n\t\t\t\tpath = fileSystemResource.getPath();\n\t\t\t}\n\t\t\telse if (location instanceof ClassPathResource classPathResource) {\n\t\t\t\tpath = classPathResource.getPath();\n\t\t\t}\n\t\t\telse if (location instanceof UrlResource) {\n\t\t\t\tpath = location.getURL().toExternalForm();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpath = location.getURL().getPath();\n\t\t\t}\n\t\t\tAssert.isTrue(path.endsWith(FOLDER_SEPARATOR) || path.endsWith(WINDOWS_FOLDER_SEPARATOR),\n\t\t\t\t\t\"Resource location does not end with slash: \" + path);\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\t// ignore\n\t\t}\n\t}\n\n\t/**\n\t * Check if the given static resource location path ends with a trailing\n\t * slash, and append it if necessary.\n\t * @param path the location path\n\t * @return the resulting path to use\n\t */\n\tpublic static String initLocationPath(String path) {\n\t\tString separator = (path.contains(FOLDER_SEPARATOR) ? FOLDER_SEPARATOR : WINDOWS_FOLDER_SEPARATOR);\n\t\tif (!path.endsWith(separator)) {\n\t\t\tpath = path.concat(separator);\n\t\t\tlogger.warn(\"Appended trailing slash to static resource location: \" + path);\n\t\t}\n\t\treturn path;\n\t}\n\n\t/**\n\t * Normalize the given resource path replacing the following:\n\t * <ul>\n\t * <li>Backslash with forward slash.\n\t * <li>Duplicate occurrences of slash with a single slash.\n\t * <li>Any combination of leading slash and control characters (00-1F and 7F)\n\t * with a single \"/\" or \"\". For example {@code \"  / // foo/bar\"}\n\t * becomes {@code \"/foo/bar\"}.\n\t * </ul>\n\t */\n\tpublic static String normalizeInputPath(String path) {\n\t\tpath = StringUtils.replace(path, \"\\\\\", \"/\");\n\t\tpath = cleanDuplicateSlashes(path);\n\t\treturn cleanLeadingSlash(path);\n\t}\n\n\tprivate static String cleanDuplicateSlashes(String path) {\n\t\tStringBuilder sb = null;\n\t\tchar prev = 0;\n\t\tfor (int i = 0; i < path.length(); i++) {\n\t\t\tchar curr = path.charAt(i);\n\t\t\ttry {\n\t\t\t\tif ((curr == '/') && (prev == '/')) {\n\t\t\t\t\tif (sb == null) {\n\t\t\t\t\t\tsb = new StringBuilder(path.substring(0, i));\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (sb != null) {\n\t\t\t\t\tsb.append(path.charAt(i));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tprev = curr;\n\t\t\t}\n\t\t}\n\t\treturn (sb != null ? sb.toString() : path);\n\t}\n\n\tprivate static String cleanLeadingSlash(String path) {\n\t\tboolean slash = false;\n\t\tfor (int i = 0; i < path.length(); i++) {\n\t\t\tif (path.charAt(i) == '/') {\n\t\t\t\tslash = true;\n\t\t\t}\n\t\t\telse if (path.charAt(i) > ' ' && path.charAt(i) != 127) {\n\t\t\t\tif (i == 0 || (i == 1 && slash)) {\n\t\t\t\t\treturn path;\n\t\t\t\t}\n\t\t\t\treturn (slash ? \"/\" + path.substring(i) : path.substring(i));\n\t\t\t}\n\t\t}\n\t\treturn (slash ? \"/\" : \"\");\n\t}\n\n\t/**\n\t * Whether the given input path is invalid as determined by\n\t * {@link #isInvalidPath(String)}. The path is also decoded and the same\n\t * checks are performed again.\n\t */\n\tpublic static boolean shouldIgnoreInputPath(String path) {\n\t\treturn (!StringUtils.hasText(path) || isInvalidPath(path) || isInvalidEncodedPath(path));\n\t}\n\n\t/**\n\t * Checks for invalid resource input paths rejecting the following:\n\t * <ul>\n\t * <li>Paths that contain \"WEB-INF\" or \"META-INF\"\n\t * <li>Paths that contain \"../\" after a call to\n\t * {@link org.springframework.util.StringUtils#cleanPath}.\n\t * <li>Paths that represent a {@link org.springframework.util.ResourceUtils#isUrl\n\t * valid URL} or would represent one after the leading slash is removed.\n\t * </ul>\n\t * <p><strong>Note:</strong> this method assumes that leading, duplicate '/'\n\t * or control characters (e.g. white space) have been trimmed so that the\n\t * path starts predictably with a single '/' or does not have one.\n\t * @param path the path to validate\n\t * @return {@code true} if the path is invalid, {@code false} otherwise\n\t */\n\tpublic static boolean isInvalidPath(String path) {\n\t\tif (path.contains(\"WEB-INF\") || path.contains(\"META-INF\")) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\"Path with \\\"WEB-INF\\\" or \\\"META-INF\\\": [\" + path + \"]\", -1, true));\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tif (path.contains(\":/\")) {\n\t\t\tString relativePath = (path.charAt(0) == '/' ? path.substring(1) : path);\n\t\t\tif (ResourceUtils.isUrl(relativePath) || relativePath.startsWith(\"url:\")) {\n\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\t\"Path represents URL or has \\\"url:\\\" prefix: [\" + path + \"]\", -1, true));\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tif (path.contains(\"../\")) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\"Path contains \\\"../\\\" after call to StringUtils#cleanPath: [\" + path + \"]\", -1, true));\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check whether the given path contains invalid escape sequences.\n\t * @param path the path to validate\n\t * @return {@code true} if the path is invalid, {@code false} otherwise\n\t */\n\tprivate static boolean isInvalidEncodedPath(String path) {\n\t\tString decodedPath = decode(path);\n\t\tif (decodedPath.contains(\"%\")) {\n\t\t\tdecodedPath = decode(decodedPath);\n\t\t}\n\t\tif (!StringUtils.hasText(decodedPath)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (isInvalidPath(decodedPath)) {\n\t\t\treturn true;\n\t\t}\n\t\tdecodedPath = normalizeInputPath(decodedPath);\n\t\treturn isInvalidPath(decodedPath);\n\t}\n\n\tprivate static String decode(String path) {\n\t\ttry {\n\t\t\treturn UriUtils.decode(path, StandardCharsets.UTF_8);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\treturn \"\";\n\t\t}\n\t}\n\n\n\t/**\n\t * Check whether the resource is under the given location.\n\t */\n\tpublic static boolean isResourceUnderLocation(Resource location, Resource resource) throws IOException {\n\t\tif (resource.getClass() != location.getClass()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tString resourcePath;\n\t\tString locationPath;\n\n\t\tif (resource instanceof UrlResource) {\n\t\t\tresourcePath = resource.getURL().toExternalForm();\n\t\t\tlocationPath = StringUtils.cleanPath(location.getURL().toString());\n\t\t}\n\t\telse if (resource instanceof ClassPathResource classPathResource) {\n\t\t\tresourcePath = classPathResource.getPath();\n\t\t\tlocationPath = StringUtils.cleanPath(((ClassPathResource) location).getPath());\n\t\t}\n\t\telse if (resource instanceof ServletContextResource servletContextResource) {\n\t\t\tresourcePath = servletContextResource.getPath();\n\t\t\tlocationPath = StringUtils.cleanPath(((ServletContextResource) location).getPath());\n\t\t}\n\t\telse {\n\t\t\tresourcePath = resource.getURL().getPath();\n\t\t\tlocationPath = StringUtils.cleanPath(location.getURL().getPath());\n\t\t}\n\n\t\tif (locationPath.equals(resourcePath)) {\n\t\t\treturn true;\n\t\t}\n\t\tlocationPath = (locationPath.endsWith(\"/\") || locationPath.isEmpty() ? locationPath : locationPath + \"/\");\n\t\treturn (resourcePath.startsWith(locationPath) && !isInvalidEncodedResourcePath(resourcePath));\n\t}\n\n\tprivate static boolean isInvalidEncodedResourcePath(String resourcePath) {\n\t\tif (resourcePath.contains(\"%\")) {\n\t\t\t// Use URLDecoder (vs UriUtils) to preserve potentially decoded UTF-8 chars...\n\t\t\ttry {\n\t\t\t\tString decodedPath = URLDecoder.decode(resourcePath, StandardCharsets.UTF_8);\n\t\t\t\tif (decodedPath.contains(\"../\") || decodedPath.contains(\"..\\\\\")) {\n\t\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\t\"Resolved resource path contains encoded \\\"../\\\" or \\\"..\\\\\\\": \" + resourcePath, -1, true));\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t// May not be possible to decode...\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n}"
  },
  "org.springframework.web.servlet.resource.ResourceHandlerUtils#assertResourceLocation(location)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert the given location is not null, and its path ends on slash.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "void",
    "signature": "public void assertResourceLocation(@Nullable Resource location)",
    "source_code": "\tpublic static void assertResourceLocation(@Nullable Resource location) {\n\t\tAssert.notNull(location, \"Resource location must not be null\");\n\t\ttry {\n\t\t\tString path;\n\t\t\tif (location instanceof org.springframework.core.io.PathResource) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if (location instanceof FileSystemResource fileSystemResource) {\n\t\t\t\tpath = fileSystemResource.getPath();\n\t\t\t}\n\t\t\telse if (location instanceof ClassPathResource classPathResource) {\n\t\t\t\tpath = classPathResource.getPath();\n\t\t\t}\n\t\t\telse if (location instanceof UrlResource) {\n\t\t\t\tpath = location.getURL().toExternalForm();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpath = location.getURL().getPath();\n\t\t\t}\n\t\t\tAssert.isTrue(path.endsWith(FOLDER_SEPARATOR) || path.endsWith(WINDOWS_FOLDER_SEPARATOR),\n\t\t\t\t\t\"Resource location does not end with slash: \" + path);\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\t// ignore\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.resource.ResourceHandlerUtils#initLocationPath(path)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Check if the given static resource location path ends with a trailing\n\t * slash, and append it if necessary.\n\t * @param path the location path\n\t * @return the resulting path to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "String",
    "signature": "public String initLocationPath(String path)",
    "source_code": "\tpublic static String initLocationPath(String path) {\n\t\tString separator = (path.contains(FOLDER_SEPARATOR) ? FOLDER_SEPARATOR : WINDOWS_FOLDER_SEPARATOR);\n\t\tif (!path.endsWith(separator)) {\n\t\t\tpath = path.concat(separator);\n\t\t\tlogger.warn(\"Appended trailing slash to static resource location: \" + path);\n\t\t}\n\t\treturn path;\n\t}"
  },
  "org.springframework.web.servlet.resource.ResourceHandlerUtils#isInvalidPath(path)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Checks for invalid resource input paths rejecting the following:\n\t * <ul>\n\t * <li>Paths that contain \"WEB-INF\" or \"META-INF\"\n\t * <li>Paths that contain \"../\" after a call to\n\t * {@link org.springframework.util.StringUtils#cleanPath}.\n\t * <li>Paths that represent a {@link org.springframework.util.ResourceUtils#isUrl\n\t * valid URL} or would represent one after the leading slash is removed.\n\t * </ul>\n\t * <p><strong>Note:</strong> this method assumes that leading, duplicate '/'\n\t * or control characters (e.g. white space) have been trimmed so that the\n\t * path starts predictably with a single '/' or does not have one.\n\t * @param path the path to validate\n\t * @return {@code true} if the path is invalid, {@code false} otherwise\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path"
    ],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "boolean",
    "signature": "public boolean isInvalidPath(String path)",
    "source_code": "\tpublic static boolean isInvalidPath(String path) {\n\t\tif (path.contains(\"WEB-INF\") || path.contains(\"META-INF\")) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\"Path with \\\"WEB-INF\\\" or \\\"META-INF\\\": [\" + path + \"]\", -1, true));\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tif (path.contains(\":/\")) {\n\t\t\tString relativePath = (path.charAt(0) == '/' ? path.substring(1) : path);\n\t\t\tif (ResourceUtils.isUrl(relativePath) || relativePath.startsWith(\"url:\")) {\n\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\t\"Path represents URL or has \\\"url:\\\" prefix: [\" + path + \"]\", -1, true));\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tif (path.contains(\"../\")) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\"Path contains \\\"../\\\" after call to StringUtils#cleanPath: [\" + path + \"]\", -1, true));\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.servlet.resource.ResourceHandlerUtils#isResourceUnderLocation(location,resource)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the resource is under the given location.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location",
      "resource"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "boolean",
    "signature": "public boolean isResourceUnderLocation(Resource location, Resource resource)",
    "source_code": "\tpublic static boolean isResourceUnderLocation(Resource location, Resource resource) throws IOException {\n\t\tif (resource.getClass() != location.getClass()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tString resourcePath;\n\t\tString locationPath;\n\n\t\tif (resource instanceof UrlResource) {\n\t\t\tresourcePath = resource.getURL().toExternalForm();\n\t\t\tlocationPath = StringUtils.cleanPath(location.getURL().toString());\n\t\t}\n\t\telse if (resource instanceof ClassPathResource classPathResource) {\n\t\t\tresourcePath = classPathResource.getPath();\n\t\t\tlocationPath = StringUtils.cleanPath(((ClassPathResource) location).getPath());\n\t\t}\n\t\telse if (resource instanceof ServletContextResource servletContextResource) {\n\t\t\tresourcePath = servletContextResource.getPath();\n\t\t\tlocationPath = StringUtils.cleanPath(((ServletContextResource) location).getPath());\n\t\t}\n\t\telse {\n\t\t\tresourcePath = resource.getURL().getPath();\n\t\t\tlocationPath = StringUtils.cleanPath(location.getURL().getPath());\n\t\t}\n\n\t\tif (locationPath.equals(resourcePath)) {\n\t\t\treturn true;\n\t\t}\n\t\tlocationPath = (locationPath.endsWith(\"/\") || locationPath.isEmpty() ? locationPath : locationPath + \"/\");\n\t\treturn (resourcePath.startsWith(locationPath) && !isInvalidEncodedResourcePath(resourcePath));\n\t}"
  },
  "org.springframework.web.servlet.resource.ResourceHandlerUtils#normalizeInputPath(path)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Normalize the given resource path replacing the following:\n\t * <ul>\n\t * <li>Backslash with forward slash.\n\t * <li>Duplicate occurrences of slash with a single slash.\n\t * <li>Any combination of leading slash and control characters (00-1F and 7F)\n\t * with a single \"/\" or \"\". For example {@code \"  / // foo/bar\"}\n\t * becomes {@code \"/foo/bar\"}.\n\t * </ul>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "String",
    "signature": "public String normalizeInputPath(String path)",
    "source_code": "\tpublic static String normalizeInputPath(String path) {\n\t\tpath = StringUtils.replace(path, \"\\\\\", \"/\");\n\t\tpath = cleanDuplicateSlashes(path);\n\t\treturn cleanLeadingSlash(path);\n\t}"
  },
  "org.springframework.web.servlet.resource.ResourceHandlerUtils#shouldIgnoreInputPath(path)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the given input path is invalid as determined by\n\t * {@link #isInvalidPath(String)}. The path is also decoded and the same\n\t * checks are performed again.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "boolean",
    "signature": "public boolean shouldIgnoreInputPath(String path)",
    "source_code": "\tpublic static boolean shouldIgnoreInputPath(String path) {\n\t\treturn (!StringUtils.hasText(path) || isInvalidPath(path) || isInvalidEncodedPath(path));\n\t}"
  },
  "org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Convenience subclass of {@link org.springframework.web.servlet.view.UrlBasedViewResolver}\n * that supports {@link FreeMarkerView} (i.e. FreeMarker templates) and custom subclasses of it.\n *\n * <p>The view class for all views generated by this resolver can be specified\n * via the \"viewClass\" property. See {@code UrlBasedViewResolver} for details.\n *\n * <p><b>Note:</b> To ensure that the correct encoding is used when the rendering\n * the response, set the {@linkplain #setContentType(String) content type} with an\n * appropriate {@code charset} attribute &mdash; for example,\n * {@code \"text/html;charset=UTF-8\"}; however, as of Spring Framework 6.2, it is\n * no longer strictly necessary to explicitly set the content type in the\n * {@code FreeMarkerViewResolver} if you have set an explicit encoding via either\n * {@link FreeMarkerView#setEncoding(String)},\n * {@link FreeMarkerConfigurer#setDefaultEncoding(String)}, or\n * {@link Configuration#setDefaultEncoding(String)}.\n *\n * <p><b>Note:</b> When chaining ViewResolvers, a {@code FreeMarkerViewResolver} will\n * check for the existence of the specified template resources and only return\n * a non-null {@code View} object if the template was actually found.\n *\n * <p>Note: Spring's FreeMarker support requires FreeMarker 2.3.33 or higher.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 1.1\n * @see #setViewClass\n * @see #setPrefix\n * @see #setSuffix\n * @see #setContentType\n * @see #setRequestContextAttribute\n * @see #setExposeSpringMacroHelpers\n * @see FreeMarkerView\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "signature": "public class FreeMarkerViewResolver",
    "source_code": "public class FreeMarkerViewResolver extends AbstractTemplateViewResolver {\n\n\t/**\n\t * Sets the default {@link #setViewClass view class} to {@link #requiredViewClass}:\n\t * by default {@link FreeMarkerView}.\n\t */\n\tpublic FreeMarkerViewResolver() {\n\t\tsetViewClass(requiredViewClass());\n\t}\n\n\t/**\n\t * A convenience constructor that allows for specifying {@link #setPrefix prefix}\n\t * and {@link #setSuffix suffix} as constructor arguments.\n\t * @param prefix the prefix that gets prepended to view names when building a URL\n\t * @param suffix the suffix that gets appended to view names when building a URL\n\t * @since 4.3\n\t */\n\tpublic FreeMarkerViewResolver(String prefix, String suffix) {\n\t\tthis();\n\t\tsetPrefix(prefix);\n\t\tsetSuffix(suffix);\n\t}\n\n\n\t/**\n\t * Requires {@link FreeMarkerView}.\n\t */\n\t@Override\n\tprotected Class<?> requiredViewClass() {\n\t\treturn FreeMarkerView.class;\n\t}\n\n\t@Override\n\tprotected AbstractUrlBasedView instantiateView() {\n\t\treturn (getViewClass() == FreeMarkerView.class ? new FreeMarkerView() : super.instantiateView());\n\t}\n\n\t/**\n\t * Delegates to {@code super.loadView(viewName, locale)} for standard behavior\n\t * and then to {@link #postProcessView(FreeMarkerView)} for customization.\n\t * @since 6.2\n\t * @see org.springframework.web.servlet.view.UrlBasedViewResolver#loadView(String, Locale)\n\t * @see #postProcessView(FreeMarkerView)\n\t */\n\t@Override\n\t@Nullable\n\tprotected View loadView(String viewName, Locale locale) throws Exception {\n\t\tView view = super.loadView(viewName, locale);\n\t\tif (view instanceof FreeMarkerView freeMarkerView) {\n\t\t\tpostProcessView(freeMarkerView);\n\t\t}\n\t\treturn view;\n\t}\n\n\t/**\n\t * Post process the supplied {@link FreeMarkerView} after it has been {@linkplain\n\t * org.springframework.web.servlet.view.UrlBasedViewResolver#loadView(String, Locale)\n\t * loaded}.\n\t * <p>The default implementation attempts to override the\n\t * {@linkplain org.springframework.web.servlet.view.AbstractView#setContentType(String)\n\t * content type} of the view with {@code \"text/html;charset=<encoding>\"},\n\t * where {@code <encoding>} is equal to an explicitly configured character\n\t * encoding for the underlying FreeMarker template file. If an explicit content\n\t * type has been configured for this view resolver or if no explicit character\n\t * encoding has been configured for the template file, this method does not\n\t * modify the supplied {@code FreeMarkerView}.\n\t * @since 6.2\n\t * @see #loadView(String, Locale)\n\t * @see #setContentType(String)\n\t * @see org.springframework.web.servlet.view.AbstractView#setContentType(String)\n\t */\n\tprotected void postProcessView(FreeMarkerView freeMarkerView) {\n\t\t// If an explicit content type has been configured for all views, it has\n\t\t// already been set in the view in UrlBasedViewResolver#buildView(String),\n\t\t// and there is no need to override it here.\n\t\tif (getContentType() != null) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if the view has an explicit encoding set.\n\t\tString encoding = freeMarkerView.getEncoding();\n\t\tif (encoding == null) {\n\t\t\t// If an explicit encoding has not been configured for this particular view,\n\t\t\t// use the explicit default encoding for the FreeMarker Configuration, if set.\n\t\t\tConfiguration configuration = freeMarkerView.obtainConfiguration();\n\t\t\tif (configuration.isDefaultEncodingExplicitlySet()) {\n\t\t\t\tencoding = configuration.getDefaultEncoding();\n\t\t\t}\n\t\t}\n\t\tif (StringUtils.hasText(encoding)) {\n\t\t\tString contentType = \"text/html;charset=\" + encoding;\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Setting Content-Type for view [%s] to: %s\".formatted(freeMarkerView, contentType));\n\t\t\t}\n\t\t\tfreeMarkerView.setContentType(contentType);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver#instantiateView()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "AbstractUrlBasedView",
    "signature": "protected AbstractUrlBasedView instantiateView()",
    "source_code": "\tprotected AbstractUrlBasedView instantiateView() {\n\t\treturn (getViewClass() == FreeMarkerView.class ? new FreeMarkerView() : super.instantiateView());\n\t}"
  },
  "org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver#loadView(viewName,locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@code super.loadView(viewName, locale)} for standard behavior\n\t * and then to {@link #postProcessView(FreeMarkerView)} for customization.\n\t * @since 6.2\n\t * @see org.springframework.web.servlet.view.UrlBasedViewResolver#loadView(String, Locale)\n\t * @see #postProcessView(FreeMarkerView)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "View",
    "signature": "protected View loadView(String viewName, Locale locale)",
    "source_code": "\tprotected View loadView(String viewName, Locale locale) throws Exception {\n\t\tView view = super.loadView(viewName, locale);\n\t\tif (view instanceof FreeMarkerView freeMarkerView) {\n\t\t\tpostProcessView(freeMarkerView);\n\t\t}\n\t\treturn view;\n\t}"
  },
  "org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver#postProcessView(freeMarkerView)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Post process the supplied {@link FreeMarkerView} after it has been {@linkplain\n\t * org.springframework.web.servlet.view.UrlBasedViewResolver#loadView(String, Locale)\n\t * loaded}.\n\t * <p>The default implementation attempts to override the\n\t * {@linkplain org.springframework.web.servlet.view.AbstractView#setContentType(String)\n\t * content type} of the view with {@code \"text/html;charset=<encoding>\"},\n\t * where {@code <encoding>} is equal to an explicitly configured character\n\t * encoding for the underlying FreeMarker template file. If an explicit content\n\t * type has been configured for this view resolver or if no explicit character\n\t * encoding has been configured for the template file, this method does not\n\t * modify the supplied {@code FreeMarkerView}.\n\t * @since 6.2\n\t * @see #loadView(String, Locale)\n\t * @see #setContentType(String)\n\t * @see org.springframework.web.servlet.view.AbstractView#setContentType(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "freeMarkerView"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "void",
    "signature": "protected void postProcessView(FreeMarkerView freeMarkerView)",
    "source_code": "\tprotected void postProcessView(FreeMarkerView freeMarkerView) {\n\t\t// If an explicit content type has been configured for all views, it has\n\t\t// already been set in the view in UrlBasedViewResolver#buildView(String),\n\t\t// and there is no need to override it here.\n\t\tif (getContentType() != null) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if the view has an explicit encoding set.\n\t\tString encoding = freeMarkerView.getEncoding();\n\t\tif (encoding == null) {\n\t\t\t// If an explicit encoding has not been configured for this particular view,\n\t\t\t// use the explicit default encoding for the FreeMarker Configuration, if set.\n\t\t\tConfiguration configuration = freeMarkerView.obtainConfiguration();\n\t\t\tif (configuration.isDefaultEncodingExplicitlySet()) {\n\t\t\t\tencoding = configuration.getDefaultEncoding();\n\t\t\t}\n\t\t}\n\t\tif (StringUtils.hasText(encoding)) {\n\t\t\tString contentType = \"text/html;charset=\" + encoding;\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Setting Content-Type for view [%s] to: %s\".formatted(freeMarkerView, contentType));\n\t\t\t}\n\t\t\tfreeMarkerView.setContentType(contentType);\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#getOutboundMessageSizeLimit()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the configured outbound message buffer size in bytes.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "Integer",
    "signature": "public Integer getOutboundMessageSizeLimit()",
    "source_code": "\tpublic Integer getOutboundMessageSizeLimit() {\n\t\treturn this.outboundMessageSizeLimit;\n\t}"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#hasSplittingEncoder()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 635
    },
    "return": "boolean",
    "signature": "public boolean hasSplittingEncoder()",
    "source_code": "\t\tpublic boolean hasSplittingEncoder() {\n\t\t\treturn (this.splittingEncoder != null);\n\t\t}"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#setOutboundMessageSizeLimit(outboundMessageSizeLimit)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the maximum size allowed for outbound STOMP message.\n\t * If STOMP message's size exceeds {@link WebSocketStompClient#outboundMessageSizeLimit},\n\t * STOMP message is split into multiple frames.\n\t * <p>By default this is not set in which case each STOMP message are not split.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outboundMessageSizeLimit"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "void",
    "signature": "public void setOutboundMessageSizeLimit(Integer outboundMessageSizeLimit)",
    "source_code": "\tpublic void setOutboundMessageSizeLimit(Integer outboundMessageSizeLimit) {\n\t\tthis.outboundMessageSizeLimit = outboundMessageSizeLimit;\n\t}"
  },
  "org.springframework.web.util.<unknown>#address()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 2222
    },
    "return": "IpAddress",
    "signature": "public IpAddress address()",
    "source_code": "\t\tpublic IpAddress address() {\n\t\t\treturn this.address;\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#append(codePoint)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "codePoint"
    ],
    "position": {
      "column": 1,
      "line": 3038
    },
    "return": "void",
    "signature": "public void append(int codePoint)",
    "source_code": "\t\tpublic void append(int codePoint) {\n\t\t\tthis.segments.add(new PathSegment(codePoint));\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#append(s)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "s"
    ],
    "position": {
      "column": 1,
      "line": 2953
    },
    "return": "void",
    "signature": "public void append(String s)",
    "source_code": "\t\tpublic void append(String s) {\n\t\t\tthis.segment = null;\n\t\t\tif (this.builder == null) {\n\t\t\t\tthis.builder = new StringBuilder(s);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.builder.append(s);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#append(segment)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "segment"
    ],
    "position": {
      "column": 1,
      "line": 3043
    },
    "return": "void",
    "signature": "public void append(String segment)",
    "source_code": "\t\tpublic void append(String segment) {\n\t\t\tthis.segments.add(new PathSegment(segment));\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#appendToUsername(s)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "s"
    ],
    "position": {
      "column": 1,
      "line": 1804
    },
    "return": "void",
    "signature": "public void appendToUsername(String s)",
    "source_code": "\t\tpublic void appendToUsername(String s) {\n\t\t\tif (this.username == null) {\n\t\t\t\tthis.username = new StringBuilder(s);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.username.append(s);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#clone()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 3080
    },
    "return": "Path",
    "signature": "public Path clone()",
    "source_code": "\t\tpublic Path clone() {\n\t\t\treturn new PathSegments(this.segments);\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#domain()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 2175
    },
    "return": "String",
    "signature": "public String domain()",
    "source_code": "\t\tpublic String domain() {\n\t\t\treturn this.domain;\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#equals(o)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o"
    ],
    "position": {
      "column": 1,
      "line": 3095
    },
    "return": "boolean",
    "signature": "public boolean equals(Object o)",
    "source_code": "\t\tpublic boolean equals(Object o) {\n\t\t\tif (o == this) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (o instanceof PathSegments other) {\n\t\t\t\treturn this.segments.equals(other.segments);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 2832
    },
    "return": "boolean",
    "signature": "public boolean equals(Object obj)",
    "source_code": "\t\tpublic boolean equals(Object obj) {\n\t\t\tif (obj == this) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (obj instanceof Ipv6Address other) {\n\t\t\t\treturn Arrays.equals(this.pieces, other.pieces);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#fragment()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * A URL\u2019s fragment is either {@code null}  or an ASCII string\n\t\t * that can be used for further processing on the resource the URL\u2019s\n\t\t * other components identify.\n\t\t * <p>It is initially {@code null}.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1962
    },
    "return": "String",
    "signature": "public String fragment()",
    "source_code": "\t\tpublic String fragment() {\n\t\t\treturn (this.fragment != null ? this.fragment.toString() : null);\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#get(i)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "i"
    ],
    "position": {
      "column": 1,
      "line": 3051
    },
    "return": "String",
    "signature": "public String get(int i)",
    "source_code": "\t\tpublic String get(int i) {\n\t\t\treturn this.segments.get(i).segment();\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#handle(c,url,p)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "c",
      "url",
      "p"
    ],
    "position": {
      "column": 1,
      "line": 1712
    },
    "return": "void",
    "signature": "public void handle(int c, UrlRecord url, WhatWgUrlParser p)",
    "source_code": "\t\tpublic abstract void handle(int c, UrlRecord url, WhatWgUrlParser p);"
  },
  "org.springframework.web.util.<unknown>#hasOpaquePath()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * A URL has an opaque path if its path is a URL path segment.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1767
    },
    "return": "boolean",
    "signature": "public boolean hasOpaquePath()",
    "source_code": "\t\tpublic boolean hasOpaquePath() {\n\t\t\treturn path().isOpaque();\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#hash()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * The hash getter steps are:\n\t\t * <ol>\n\t\t * <li>If this URL\u2019s fragment is either null or the empty string, then return the empty string.\n\t\t * <li>Return U+0023 (#), followed by this\u2019s URL\u2019s fragment.\n\t\t * </ol>\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1974
    },
    "return": "String",
    "signature": "public String hash()",
    "source_code": "\t\tpublic String hash() {\n\t\t\tString fragment = fragment();\n\t\t\treturn (fragment != null && !fragment.isEmpty() ? \"#\" + fragment : \"\");\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#host()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * A URL\u2019s host is {@code null} or a {@linkplain Host host}.\n\t\t * It is initially {@code null}.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1857
    },
    "return": "Host",
    "signature": "public Host host()",
    "source_code": "\t\tpublic Host host() {\n\t\t\treturn this.host;\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#hostString()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t *The host getter steps are:\n\t\t * <ol>\n\t\t * <li>Let url be this URL.\n\t\t * <li>If url\u2019s host is null, then return the empty string.\n\t\t * <li>If url\u2019s port is null, return url\u2019s host, serialized.\n\t\t * <li>Return url\u2019s host, serialized, followed by U+003A (:) and url\u2019s port, serialized.\n\t\t * </ol>\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1871
    },
    "return": "String",
    "signature": "public String hostString()",
    "source_code": "\t\tpublic String hostString() {\n\t\t\tif (host() == null) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t\tStringBuilder builder = new StringBuilder(hostname());\n\t\t\tPort port = port();\n\t\t\tif (port != null) {\n\t\t\t\tbuilder.append(':');\n\t\t\t\tbuilder.append(port);\n\t\t\t}\n\t\t\treturn builder.toString();\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#hostname()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1884
    },
    "return": "String",
    "signature": "public String hostname()",
    "source_code": "\t\tpublic String hostname() {\n\t\t\tHost host = host();\n\t\t\treturn (host != null ? host.toString() : \"\");\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#href()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1979
    },
    "return": "String",
    "signature": "public String href()",
    "source_code": "\t\tpublic String href() {\n\t\t\t// Let output be url\u2019s scheme and U+003A (:) concatenated.\n\t\t\tStringBuilder output = new StringBuilder(scheme());\n\t\t\toutput.append(':');\n\t\t\tHost host = host();\n\t\t\t// If url\u2019s host is non-null:\n\t\t\tif (host != null) {\n\t\t\t\t// Append \"//\" to output.\n\t\t\t\toutput.append(\"//\");\n\t\t\t\t// If url includes credentials, then:\n\t\t\t\tif (includesCredentials()) {\n\t\t\t\t\t// Append url\u2019s username to output.\n\t\t\t\t\toutput.append(username());\n\t\t\t\t\tString password = password();\n\t\t\t\t\t// If url\u2019s password is not the empty string, then append U+003A (:),\n\t\t\t\t\t// followed by url\u2019s password, to output.\n\t\t\t\t\tif (!password.isEmpty()) {\n\t\t\t\t\t\toutput.append(':');\n\t\t\t\t\t\toutput.append(password);\n\t\t\t\t\t}\n\t\t\t\t\t// Append U+0040 (@) to output.\n\t\t\t\t\toutput.append('@');\n\t\t\t\t}\n\t\t\t\t// Append url\u2019s host, serialized, to output.\n\t\t\t\toutput.append(hostname());\n\t\t\t\tPort port = port();\n\t\t\t\t// If url\u2019s port is non-null, append U+003A (:) followed by url\u2019s port, serialized, to output.\n\t\t\t\tif (port != null) {\n\t\t\t\t\toutput.append(':');\n\t\t\t\t\toutput.append(port());\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If url\u2019s host is null, url does not have an opaque path, url\u2019s path\u2019s size is greater than 1,\n\t\t\t// and url\u2019s path[0] is the empty string, then append U+002F (/) followed by U+002E (.) to output.\n\t\t\telse if (!hasOpaquePath() &&\n\t\t\t\t\tpath() instanceof PathSegments pathSegments &&\n\t\t\t\t\tpathSegments.size() > 1 &&\n\t\t\t\t\tpathSegments.get(0).isEmpty()) {\n\t\t\t\toutput.append(\"/.\");\n\t\t\t}\n\t\t\t// Append the result of URL path serializing url to output.\n\t\t\toutput.append(pathname());\n\t\t\t// If url\u2019s query is non-null, append U+003F (?), followed by url\u2019s query, to output.\n\t\t\tString query = query();\n\t\t\tif (query != null) {\n\t\t\t\toutput.append('?');\n\t\t\t\toutput.append(query);\n\t\t\t}\n\t\t\t// If exclude fragment is false and url\u2019s fragment is non-null, then append U+0023 (#),\n\t\t\t// followed by url\u2019s fragment, to output.\n\t\t\tString fragment = fragment();\n\t\t\tif (fragment != null) {\n\t\t\t\toutput.append('#');\n\t\t\t\toutput.append(fragment);\n\t\t\t}\n\t\t\t// Return output.\n\t\t\treturn output.toString();\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#includesCredentials()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * A URL includes credentials if its username or password is not the empty string.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1759
    },
    "return": "boolean",
    "signature": "public boolean includesCredentials()",
    "source_code": "\t\tpublic boolean includesCredentials() {\n\t\t\treturn (this.username != null && !this.username.isEmpty() ||\n\t\t\t\t\tthis.password != null && !this.password.isEmpty());\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#isEmpty()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 3056
    },
    "return": "boolean",
    "signature": "public boolean isEmpty()",
    "source_code": "\t\tpublic boolean isEmpty() {\n\t\t\treturn this.segments.isEmpty();\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#isOpaque()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 3074
    },
    "return": "boolean",
    "signature": "public boolean isOpaque()",
    "source_code": "\t\tpublic boolean isOpaque() {\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#isSpecial()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * A URL is special if its scheme is a special scheme. A URL is not special if its scheme is not a special scheme.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1752
    },
    "return": "boolean",
    "signature": "public boolean isSpecial()",
    "source_code": "\t\tpublic boolean isSpecial() {\n\t\t\treturn isSpecialScheme(this.scheme);\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#isUnreservedOrSubDelimiter(c)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Combined check whether a character is unreserved or a sub-delimiter.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "c"
    ],
    "position": {
      "column": 1,
      "line": 737
    },
    "return": "boolean",
    "signature": "protected boolean isUnreservedOrSubDelimiter(int c)",
    "source_code": "\t\tprotected boolean isUnreservedOrSubDelimiter(int c) {\n\t\t\treturn (c < unreservedOrSubDelimiterArray.length && c >= 0 && unreservedOrSubDelimiterArray[c]);\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#name()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 3085
    },
    "return": "String",
    "signature": "public String name()",
    "source_code": "\t\tpublic String name() {\n\t\t\tStringBuilder output = new StringBuilder();\n\t\t\tfor (PathSegment segment : this.segments) {\n\t\t\t\toutput.append('/');\n\t\t\t\toutput.append(segment.name());\n\t\t\t}\n\t\t\treturn output.toString();\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#parse(input)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * The IPv6 parser takes a scalar value string input and then runs these steps.\n\t\t * They return failure or an IPv6 address.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "input"
    ],
    "position": {
      "column": 1,
      "line": 2563
    },
    "return": "Ipv6Address",
    "signature": "public Ipv6Address parse(String input)",
    "source_code": "\t\tpublic static Ipv6Address parse(String input) {\n\t\t\t// Let address be a new IPv6 address whose IPv6 pieces are all 0.\n\t\t\tint[] address = new int[8];\n\t\t\t// Let pieceIndex be 0.\n\t\t\tint pieceIndex = 0;\n\t\t\t// Let compress be null.\n\t\t\tInteger compress = null;\n\t\t\t// Let pointer be a pointer for input.\n\t\t\tint pointer = 0;\n\t\t\tint inputLength = input.length();\n\t\t\tint c = (inputLength > 0) ? input.codePointAt(0) : EOF;\n\t\t\t// If c is U+003A (:), then:\n\t\t\tif (c == ':') {\n\t\t\t\t// If remaining does not start with U+003A (:),\n\t\t\t\t// IPv6-invalid-compression validation error, return failure.\n\t\t\t\tif (inputLength > 1 && input.codePointAt(1) != ':') {\n\t\t\t\t\tthrow new InvalidUrlException(\"IPv6 address begins with improper compression.\");\n\t\t\t\t}\n\t\t\t\t// Increase pointer by 2.\n\t\t\t\tpointer += 2;\n\t\t\t\t// Increase pieceIndex by 1 and then set compress to pieceIndex.\n\t\t\t\tpieceIndex++;\n\t\t\t\tcompress = pieceIndex;\n\t\t\t}\n\t\t\tc = (pointer < inputLength) ? input.codePointAt(pointer) : EOF;\n\t\t\t// While c is not the EOF code point:\n\t\t\twhile (c != EOF) {\n\t\t\t\t// If pieceIndex is 8, IPv6-too-many-pieces validation error, return failure.\n\t\t\t\tif (pieceIndex == 8) {\n\t\t\t\t\tthrow new InvalidUrlException(\"IPv6 address contains more than 8 pieces.\");\n\t\t\t\t}\n\t\t\t\t// If c is U+003A (:), then:\n\t\t\t\tif (c == ':') {\n\t\t\t\t\t// If compress is non-null, IPv6-multiple-compression validation error, return failure.\n\t\t\t\t\tif (compress != null) {\n\t\t\t\t\t\tthrow new InvalidUrlException(\"IPv6 address is compressed in more than one spot.\");\n\t\t\t\t\t}\n\t\t\t\t\t// Increase pointer and pieceIndex by 1, set compress to pieceIndex, and then continue.\n\t\t\t\t\tpointer++;\n\t\t\t\t\tpieceIndex++;\n\t\t\t\t\tcompress = pieceIndex;\n\t\t\t\t\tc = (pointer < inputLength) ? input.codePointAt(pointer) : EOF;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// Let value and length be 0.\n\t\t\t\tint value = 0;\n\t\t\t\tint length = 0;\n\t\t\t\t// While length is less than 4 and c is an ASCII hex digit,\n\t\t\t\t// set value to value \u00d7 0x10 + c interpreted as hexadecimal number,\n\t\t\t\t// and increase pointer and length by 1.\n\t\t\t\twhile (length < 4 && isAsciiHexDigit(c)) {\n\t\t\t\t\tint cHex = Character.digit(c, 16);\n\t\t\t\t\tvalue = (value * 0x10) + cHex;\n\t\t\t\t\tpointer++;\n\t\t\t\t\tlength++;\n\t\t\t\t\tc = (pointer < inputLength) ? input.codePointAt(pointer) : EOF;\n\t\t\t\t}\n\t\t\t\t// If c is U+002E (.), then:\n\t\t\t\tif (c == '.') {\n\t\t\t\t\t// If length is 0, IPv4-in-IPv6-invalid-code-point validation error, return failure.\n\t\t\t\t\tif (length == 0) {\n\t\t\t\t\t\tthrow new InvalidUrlException(\n\t\t\t\t\t\t\t\t\"IPv6 address with IPv4 address syntax: IPv4 part is empty.\");\n\t\t\t\t\t}\n\t\t\t\t\t// Decrease pointer by length.\n\t\t\t\t\tpointer -= length;\n\t\t\t\t\t// If pieceIndex is greater than 6,\n\t\t\t\t\t// IPv4-in-IPv6-too-many-pieces validation error, return failure.\n\t\t\t\t\tif (pieceIndex > 6) {\n\t\t\t\t\t\tthrow new InvalidUrlException(\n\t\t\t\t\t\t\t\t\"IPv6 address with IPv4 address syntax: IPv6 address has more than 6 pieces.\");\n\t\t\t\t\t}\n\t\t\t\t\t// Let numbersSeen be 0.\n\t\t\t\t\tint numbersSeen = 0;\n\t\t\t\t\tc = (pointer < inputLength) ? input.codePointAt(pointer) : EOF;\n\t\t\t\t\t// While c is not the EOF code point:\n\t\t\t\t\twhile (c != EOF) {\n\t\t\t\t\t\t// Let ipv4Piece be null.\n\t\t\t\t\t\tInteger ipv4Piece = null;\n\t\t\t\t\t\t// If numbersSeen is greater than 0, then:\n\t\t\t\t\t\tif (numbersSeen > 0) {\n\t\t\t\t\t\t\t// If c is a U+002E (.) and numbersSeen is less than 4, then increase pointer by 1.\n\t\t\t\t\t\t\tif (c =='.' && numbersSeen < 4) {\n\t\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t\t\tc = (pointer < inputLength) ? input.codePointAt(pointer) : EOF;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Otherwise, IPv4-in-IPv6-invalid-code-point validation error, return failure.\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tthrow new InvalidUrlException(\n\t\t\t\t\t\t\t\t\t\t\"IPv6 address with IPv4 address syntax: \" +\n\t\t\t\t\t\t\t\t\t\t\t\t\"IPv4 part is empty or contains a non-ASCII digit.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// If c is not an ASCII digit,\n\t\t\t\t\t\t// IPv4-in-IPv6-invalid-code-point validation error, return failure.\n\t\t\t\t\t\tif (!isAsciiDigit(c)) {\n\t\t\t\t\t\t\tthrow new InvalidUrlException(\n\t\t\t\t\t\t\t\t\t\"IPv6 address with IPv4 address syntax: IPv4 part contains a non-ASCII digit.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// While c is an ASCII digit:\n\t\t\t\t\t\twhile (isAsciiDigit(c)) {\n\t\t\t\t\t\t\t// Let number be c interpreted as decimal number.\n\t\t\t\t\t\t\tint number = Character.digit(c, 10);\n\t\t\t\t\t\t\t// If ipv4Piece is null, then set ipv4Piece to number.\n\t\t\t\t\t\t\tif (ipv4Piece == null) {\n\t\t\t\t\t\t\t\tipv4Piece = number;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Otherwise, if ipv4Piece is 0,\n\t\t\t\t\t\t\t// IPv4-in-IPv6-invalid-code-point validation error, return failure.\n\t\t\t\t\t\t\telse if (ipv4Piece == 0) {\n\t\t\t\t\t\t\t\tthrow new InvalidUrlException(\n\t\t\t\t\t\t\t\t\t\t\"IPv6 address with IPv4 address syntax: IPv4 part contains a non-ASCII digit.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Otherwise, set ipv4Piece to ipv4Piece \u00d7 10 + number.\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tipv4Piece = ipv4Piece * 10 + number;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// If ipv4Piece is greater than 255,\n\t\t\t\t\t\t\t// IPv4-in-IPv6-out-of-range-part validation error, return failure.\n\t\t\t\t\t\t\tif (ipv4Piece > 255) {\n\t\t\t\t\t\t\t\tthrow new InvalidUrlException(\n\t\t\t\t\t\t\t\t\t\t\"IPv6 address with IPv4 address syntax: IPv4 part exceeds 255.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Increase pointer by 1.\n\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t\tc = (pointer < inputLength) ? input.codePointAt(pointer) : EOF;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Set address[pieceIndex] to address[pieceIndex] \u00d7 0x100 + ipv4Piece.\n\t\t\t\t\t\taddress[pieceIndex] = address[pieceIndex] * 0x100 + (ipv4Piece != null ? ipv4Piece : 0);\n\t\t\t\t\t\t// Increase numbersSeen by 1.\n\t\t\t\t\t\tnumbersSeen++;\n\t\t\t\t\t\t// If numbersSeen is 2 or 4, then increase pieceIndex by 1.\n\t\t\t\t\t\tif (numbersSeen == 2 || numbersSeen == 4) {\n\t\t\t\t\t\t\tpieceIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc = (pointer < inputLength) ? input.codePointAt(pointer) : EOF;\n\t\t\t\t\t}\n\t\t\t\t\t// If numbersSeen is not 4,\n\t\t\t\t\t// IPv4-in-IPv6-too-few-parts validation error, return failure.\n\t\t\t\t\tif (numbersSeen != 4) {\n\t\t\t\t\t\tthrow new InvalidUrlException(\n\t\t\t\t\t\t\t\t\"IPv6 address with IPv4 address syntax: IPv4 address contains too few parts.\");\n\t\t\t\t\t}\n\t\t\t\t\t// Break.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// Otherwise, if c is U+003A (:):\n\t\t\t\telse if (c == ':') {\n\t\t\t\t\t// Increase pointer by 1.\n\t\t\t\t\tpointer++;\n\t\t\t\t\tc = (pointer < inputLength) ? input.codePointAt(pointer) : EOF;\n\t\t\t\t\t// If c is the EOF code point, IPv6-invalid-code-point validation error, return failure.\n\t\t\t\t\tif (c == EOF) {\n\t\t\t\t\t\tthrow new InvalidUrlException(\"IPv6 address unexpectedly ends.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Otherwise, if c is not the EOF code point,\n\t\t\t\t// IPv6-invalid-code-point validation error, return failure.\n\t\t\t\telse if (c != EOF) {\n\t\t\t\t\tthrow new InvalidUrlException(\n\t\t\t\t\t\t\t\"IPv6 address contains \\\"\" + Character.toString(c) + \"\\\", which is \" +\n\t\t\t\t\t\t\t\t\t\"neither an ASCII hex digit nor a ':'.\");\n\t\t\t\t}\n\t\t\t\t// Set address[pieceIndex] to value.\n\t\t\t\taddress[pieceIndex] = value;\n\t\t\t\t// Increase pieceIndex by 1.\n\t\t\t\tpieceIndex++;\n\t\t\t}\n\t\t\t// If compress is non-null, then:\n\t\t\tif (compress != null) {\n\t\t\t\t// Let swaps be pieceIndex \u2212 compress.\n\t\t\t\tint swaps = pieceIndex - compress;\n\t\t\t\t// Set pieceIndex to 7.\n\t\t\t\tpieceIndex = 7;\n\t\t\t\t// While pieceIndex is not 0 and swaps is greater than 0,\n\t\t\t\t// swap address[pieceIndex] with address[compress + swaps \u2212 1], and\n\t\t\t\t// then decrease both pieceIndex and swaps by 1.\n\t\t\t\twhile (pieceIndex != 0 && swaps > 0) {\n\t\t\t\t\tint tmp = address[pieceIndex];\n\t\t\t\t\taddress[pieceIndex] = address[compress + swaps - 1];\n\t\t\t\t\taddress[compress + swaps - 1] = tmp;\n\t\t\t\t\tpieceIndex--;\n\t\t\t\t\tswaps--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Otherwise, if compress is null and pieceIndex is not 8,\n\t\t\t// IPv6-too-few-pieces validation error, return failure.\n\t\t\telse if (pieceIndex != 8) {\n\t\t\t\tthrow new InvalidUrlException(\"An uncompressed IPv6 address contains fewer than 8 pieces.\");\n\t\t\t}\n\t\t\t// Return address.\n\t\t\treturn new Ipv6Address(address);\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#parse(input,base,encoding,validationErrorHandler)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the given input into a URL record.\n\t * @param input the scalar value string\n\t * @param base the optional base URL to resolve relative URLs against. If\n\t * {@code null}, relative URLs cannot be parsed.\n\t * @param encoding the optional encoding to use. If {@code null}, no\n\t * encoding is performed.\n\t * @param validationErrorHandler optional consumer for non-fatal URL\n\t * validation messages\n\t * @return a URL record, as defined in the\n\t * <a href=\"https://url.spec.whatwg.org/#concept-url\">living URL\n\t * specification</a>\n\t * @throws InvalidUrlException if the {@code input} does not contain a\n\t * parsable URL\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "input",
      "base",
      "encoding",
      "validationErrorHandler"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "UrlRecord",
    "signature": "public UrlRecord parse(String input, @Nullable UrlRecord base,\n\t\t\t@Nullable Charset encoding, @Nullable Consumer<String> validationErrorHandler)",
    "source_code": "\tpublic static UrlRecord parse(String input, @Nullable UrlRecord base,"
  },
  "org.springframework.web.util.<unknown>#parse(input,p)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "input",
      "p"
    ],
    "position": {
      "column": 1,
      "line": 2380
    },
    "return": "Ipv4Address",
    "signature": "public Ipv4Address parse(String input, WhatWgUrlParser p)",
    "source_code": "\t\tpublic static Ipv4Address parse(String input, WhatWgUrlParser p) {\n\t\t\t// Let parts be the result of strictly splitting input on U+002E (.).\n\t\t\tList<String> parts = strictSplit(input, '.');\n\t\t\tint partsSize = parts.size();\n\t\t\t// If the last item in parts is the empty string, then:\n\t\t\tif (parts.get(partsSize - 1).isEmpty()) {\n\t\t\t\t// IPv4-empty-part validation error.\n\t\t\t\tp.validationError(\"IPv4 address ends with \\\".\\\"\");\n\t\t\t\t// If parts\u2019s size is greater than 1, then remove the last item from parts.\n\t\t\t\tif (partsSize > 1) {\n\t\t\t\t\tparts.remove(partsSize - 1);\n\t\t\t\t\tpartsSize--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If parts\u2019s size is greater than 4, IPv4-too-many-parts validation error, return failure.\n\t\t\tif (partsSize > 4) {\n\t\t\t\tthrow new InvalidUrlException(\"IPv4 address does not consist of exactly 4 parts.\");\n\t\t\t}\n\t\t\t// Let numbers be an empty list.\n\t\t\tList<Integer> numbers = new ArrayList<>(partsSize);\n\t\t\t// For each part of parts:\n\t\t\tfor (int i = 0; i < partsSize; i++) {\n\t\t\t\tString part = parts.get(i);\n\t\t\t\t// Let result be the result of parsing part.\n\t\t\t\tParseIpv4NumberResult result = parseIpv4Number(part);\n\t\t\t\t// If result is failure, IPv4-non-numeric-part validation error, return failure.\n\t\t\t\tif (result == ParseIpv4NumberFailure.INSTANCE) {\n\t\t\t\t\tp.failure(\"An IPv4 address part is not numeric.\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tParseIpv4NumberSuccess success = (ParseIpv4NumberSuccess) result;\n\t\t\t\t\tif (p.validate() && success.validationError()) {\n\t\t\t\t\t\tp.validationError(\n\t\t\t\t\t\t\t\t\"The IPv4 address contains numbers expressed using hexadecimal or octal digits.\");\n\t\t\t\t\t}\n\t\t\t\t\t// Append result to numbers.\n\t\t\t\t\tnumbers.add(success.number());\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (Iterator<Integer> iterator = numbers.iterator(); iterator.hasNext(); ) {\n\t\t\t\tInteger number = iterator.next();\n\t\t\t\t// If any item in numbers is greater than 255, IPv4-out-of-range-part validation error.\n\t\t\t\tif (p.validate() && number > 255) {\n\t\t\t\t\tp.validationError(\"An IPv4 address part exceeds 255.\");\n\t\t\t\t}\n\t\t\t\tif (iterator.hasNext()) {\n\t\t\t\t\t// If any but the last item in numbers is greater than 255, then return failure.\n\t\t\t\t\tif (number > 255) {\n\t\t\t\t\t\tthrow new InvalidUrlException(\"An IPv4 address part exceeds 255.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// If the last item in numbers is greater than or equal to 256^(5 \u2212 numbers\u2019s size),\n\t\t\t\t\t// then return failure.\n\t\t\t\t\tdouble limit = Math.pow(256, (5 - numbers.size()));\n\t\t\t\t\tif (number >= limit) {\n\t\t\t\t\t\tthrow new InvalidUrlException(\n\t\t\t\t\t\t\t\t\"IPv4 address part \" + number + \" exceeds \" + limit + \".'\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Let ipv4 be the last item in numbers.\n\t\t\tint ipv4 = numbers.get(numbers.size() - 1);\n\t\t\t// Remove the last item from numbers.\n\t\t\tnumbers.remove(numbers.size() - 1);\n\t\t\t// Let counter be 0.\n\t\t\tint counter = 0;\n\t\t\t// For each n of numbers:\n\t\t\tfor (Integer n : numbers) {\n\t\t\t\t// Increment ipv4 by n \u00d7 256^(3 \u2212 counter).\n\t\t\t\tint increment = n * (int) Math.pow(256, 3 - counter);\n\t\t\t\tipv4 += increment;\n\t\t\t\t// Increment counter by 1.\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t\t// Return ipv4.\n\t\t\treturn new Ipv4Address(ipv4);\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#password()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * A URL\u2019s password is an ASCII string identifying a password. It is initially the empty string.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1816
    },
    "return": "String",
    "signature": "public String password()",
    "source_code": "\t\tpublic String password() {\n\t\t\treturn (this.password != null ? this.password.toString() : \"\");\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#path()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * A URL\u2019s path is a URL {@linkplain Path path}, usually identifying a location.\n\t\t * <p>It is initially {@code \u00ab \u00bb}.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1907
    },
    "return": "Path",
    "signature": "public Path path()",
    "source_code": "\t\tpublic Path path() {\n\t\t\treturn this.path;\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#pathname()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1911
    },
    "return": "String",
    "signature": "public String pathname()",
    "source_code": "\t\tpublic String pathname() {\n\t\t\treturn path().name();\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#port()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * A URL\u2019s port is either null, a string representing a 16-bit unsigned\n\t\t * integer, or a string containing a uri template.\n\t\t * <p>It is initially {@code null}.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1895
    },
    "return": "Port",
    "signature": "public Port port()",
    "source_code": "\t\tpublic Port port() {\n\t\t\treturn this.port;\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#portString()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1899
    },
    "return": "String",
    "signature": "public String portString()",
    "source_code": "\t\tpublic String portString() {\n\t\t\treturn (port() != null ? port().toString() : \"\");\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#protocol()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * The protocol getter steps are to return this\u2019s URL\u2019s scheme, followed by U+003A (:).\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1785
    },
    "return": "String",
    "signature": "public String protocol()",
    "source_code": "\t\tpublic String protocol() {\n\t\t\treturn scheme() + \":\";\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#query()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * A URL\u2019s query is either {@code null} or an ASCII string.\n\t\t * <p>It is initially {@code null}.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1934
    },
    "return": "String",
    "signature": "public String query()",
    "source_code": "\t\tpublic String query() {\n\t\t\treturn (this.query != null ? this.query.toString() : null);\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#scheme()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * A URL\u2019s scheme is an ASCII string that identifies the type of URL and\n\t\t * can be used to dispatch a URL for further processing after parsing.\n\t\t * It is initially the empty string.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1777
    },
    "return": "String",
    "signature": "public String scheme()",
    "source_code": "\t\tpublic String scheme() {\n\t\t\treturn this.scheme;\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#search()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * The search getter steps are:\n\t\t * <ol>\n\t\t * <li>If this URL\u2019s query is either null or the empty string, then return the empty string.\n\t\t * <li>Return U+003F (?), followed by this URL\u2019s query.\n\t\t * </ol>\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1945
    },
    "return": "String",
    "signature": "public String search()",
    "source_code": "\t\tpublic String search() {\n\t\t\tString query = query();\n\t\t\tif (query == null) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn \"?\" + query;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#segment()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 2933
    },
    "return": "String",
    "signature": "public String segment()",
    "source_code": "\t\tpublic String segment() {\n\t\t\tString result = this.segment;\n\t\t\tif (result == null) {\n\t\t\t\tAssert.state(this.builder != null, \"String nor StringBuilder available\");\n\t\t\t\tresult = this.builder.toString();\n\t\t\t\tthis.segment = result;\n\t\t\t}\n\t\t\treturn result;\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#shorten(scheme)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scheme"
    ],
    "position": {
      "column": 1,
      "line": 3061
    },
    "return": "void",
    "signature": "public void shorten(String scheme)",
    "source_code": "\t\tpublic void shorten(String scheme) {\n\t\t\tint size = size();\n\t\t\tif (\"file\".equals(scheme) &&\n\t\t\t\t\tsize == 1 &&\n\t\t\t\t\tisWindowsDriveLetter(get(0), true)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!isEmpty()) {\n\t\t\t\tthis.segments.remove(size - 1);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#shortenPath()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * To shorten a url\u2019s path:\n\t\t * <ol>\n\t \t * <li>Assert: url does not have an opaque path.</li>\n\t\t * <li>Let path be url\u2019s path.</li>\n\t\t * <li>If url\u2019s scheme is \"file\", path\u2019s size is 1, and path[0] is a\n\t\t * normalized Windows drive letter, then return.</li>\n\t\t * <li>Remove path\u2019s last item, if any.</li>\n\t\t * </ol>\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1925
    },
    "return": "void",
    "signature": "public void shortenPath()",
    "source_code": "\t\tpublic void shortenPath() {\n\t\t\tthis.path.shorten(this.scheme);\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#size()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 3047
    },
    "return": "int",
    "signature": "public int size()",
    "source_code": "\t\tpublic int size() {\n\t\t\treturn this.segments.size();\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#toString()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 3113
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\tStringBuilder output = new StringBuilder();\n\t\t\tfor (PathSegment segment : this.segments) {\n\t\t\t\toutput.append(segment);\n\t\t\t}\n\t\t\treturn output.toString();\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#userInfo()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Convenience method to return the full user info.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1840
    },
    "return": "String",
    "signature": "public String userInfo()",
    "source_code": "\t\tpublic String userInfo() {\n\t\t\tif (!includesCredentials()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tStringBuilder userInfo = new StringBuilder(username());\n\t\t\tif (!password().isEmpty()) {\n\t\t\t\tuserInfo.append(':');\n\t\t\t\tuserInfo.append(password());\n\t\t\t}\n\t\t\treturn userInfo.toString();\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#username()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * A URL\u2019s username is an ASCII string identifying a username.\n\t\t * It is initially the empty string.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1793
    },
    "return": "String",
    "signature": "public String username()",
    "source_code": "\t\tpublic String username() {\n\t\t\treturn (this.username != null ? this.username.toString() : \"\");\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#value()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 2887
    },
    "return": "int",
    "signature": "public int value()",
    "source_code": "\t\tpublic int value() {\n\t\t\treturn this.port;\n\t\t}"
  },
  "org.springframework.web.util.EMPTY_RECORD": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "signature": "public UrlRecord EMPTY_RECORD",
    "source_code": "\tpublic static final UrlRecord EMPTY_RECORD = new UrlRecord();",
    "type": "UrlRecord"
  },
  "org.springframework.web.util.INSTANCE": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 3134
    },
    "signature": "public ParseIpv4NumberFailure INSTANCE",
    "source_code": "\t\tpublic static final ParseIpv4NumberFailure INSTANCE = new ParseIpv4NumberFailure();",
    "type": "ParseIpv4NumberFailure"
  },
  "org.springframework.web.util.ParserType": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Enum to provide a choice of URI parsers to use in {@link #fromUriString(String, ParserType)}.\n\t * @since 6.2\n\t */",
    "kind": "enum",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 787
    },
    "signature": "public enum ParserType",
    "source_code": "\tpublic enum ParserType {\n\n\t\t/**\n\t\t * This parser type expects URI's to conform to RFC 3986 syntax.\n\t\t */\n\t\tRFC,\n\n\t\t/**\n\t\t * This parser follows the\n\t\t * <a href=\"https://url.spec.whatwg.org/#url-parsing\">URL parsing algorithm</a>\n\t\t * in the WhatWG URL Living standard that browsers implement to align on\n\t\t * lenient handling of user typed URL's that may not conform to RFC syntax.\n\t\t * @see <a href=\"https://url.spec.whatwg.org\">URL Living Standard</a>\n\t\t * @see <a href=\"https://github.com/web-platform-tests/wpt/tree/master/url\">URL tests</a>\n\t\t */\n\t\tWHAT_WG\n\n\t}"
  },
  "org.springframework.web.util.ServletRequestPathUtils#getServletPathPrefix(request)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Check if the Servlet is mapped by a path prefix, and if so return that\n\t * path prefix.\n\t * @param request the current request\n\t * @return the prefix, or {@code null} if the Servlet is not mapped by prefix\n\t * @since 6.2.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "String",
    "signature": "public String getServletPathPrefix(HttpServletRequest request)",
    "source_code": "\tpublic static String getServletPathPrefix(HttpServletRequest request) {\n\t\tHttpServletMapping mapping = (HttpServletMapping) request.getAttribute(RequestDispatcher.INCLUDE_MAPPING);\n\t\tmapping = (mapping != null ? mapping : request.getHttpServletMapping());\n\t\tif (ObjectUtils.nullSafeEquals(mapping.getMappingMatch(), MappingMatch.PATH)) {\n\t\t\tString servletPath = (String) request.getAttribute(WebUtils.INCLUDE_SERVLET_PATH_ATTRIBUTE);\n\t\t\tservletPath = (servletPath != null ? servletPath : request.getServletPath());\n\t\t\tservletPath = (servletPath.endsWith(\"/\") ? servletPath.substring(0, servletPath.length() - 1) : servletPath);\n\t\t\treturn servletPath;\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#fromUriString(uri,parserType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a builder that is initialized by parsing the given URI string.\n\t * <p><strong>Note:</strong> The presence of reserved characters can prevent\n\t * correct parsing of the URI string. For example if a query parameter\n\t * contains {@code '='} or {@code '&'} characters, the query string cannot\n\t * be parsed unambiguously. Such values should be substituted for URI\n\t * variables to enable correct parsing:\n\t * <pre class=\"code\">\n\t * String uriString = &quot;/hotels/42?filter={value}&quot;;\n\t * UriComponentsBuilder.fromUriString(uriString).buildAndExpand(&quot;hot&amp;cold&quot;);\n\t * </pre>\n\t * @param uri the URI string to initialize with\n\t * @param parserType the parsing algorithm to use\n\t * @return the new {@code UriComponentsBuilder}\n\t * @throws InvalidUrlException if {@code uri} cannot be parsed\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uri",
      "parserType"
    ],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder fromUriString(String uri, ParserType parserType)",
    "source_code": "\tpublic static UriComponentsBuilder fromUriString(String uri, ParserType parserType) throws InvalidUrlException {\n\t\tAssert.notNull(uri, \"URI must not be null\");\n\t\tif (uri.isEmpty()) {\n\t\t\treturn new UriComponentsBuilder();\n\t\t}\n\t\tUriComponentsBuilder builder = new UriComponentsBuilder();\n\t\treturn switch (parserType) {\n\t\t\tcase RFC -> {\n\t\t\t\tRfcUriParser.UriRecord record = RfcUriParser.parse(uri);\n\t\t\t\tyield builder.rfcUriRecord(record);\n\t\t\t}\n\t\t\tcase WHAT_WG -> {\n\t\t\t\tWhatWgUrlParser.UrlRecord record =\n\t\t\t\t\t\tWhatWgUrlParser.parse(uri, WhatWgUrlParser.EMPTY_RECORD, null, null);\n\t\t\t\tyield builder.whatWgUrlRecord(record);\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#parseForwardedFor(request,remoteAddress)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the first \"Forwarded: for=...\" or \"X-Forwarded-For\" header value to\n\t * an {@code InetSocketAddress} representing the address of the client.\n\t * @param request a request with headers that may contain forwarded headers\n\t * @param remoteAddress the current remoteAddress\n\t * @return an {@code InetSocketAddress} with the extracted host and port, or\n\t * {@code null} if the headers are not present.\n\t * @since 5.3\n\t * @deprecated in favor of {@link ForwardedHeaderUtils#parseForwardedFor};\n\t * to be removed in 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "remoteAddress"
    ],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "InetSocketAddress",
    "signature": "public InetSocketAddress parseForwardedFor(HttpRequest request, @Nullable InetSocketAddress remoteAddress)",
    "source_code": "\tpublic static InetSocketAddress parseForwardedFor("
  }
}