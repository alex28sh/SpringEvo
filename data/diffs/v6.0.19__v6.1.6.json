{
  "org.springframework.aop.interceptor.CustomizableTraceInterceptor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code MethodInterceptor} implementation that allows for highly customizable\n * method-level tracing, using placeholders.\n *\n * <p>Trace messages are written on method entry, and if the method invocation succeeds\n * on method exit. If an invocation results in an exception, then an exception message\n * is written. The contents of these trace messages is fully customizable and special\n * placeholders are available to allow you to include runtime information in your log\n * messages. The placeholders available are:\n *\n * <p><ul>\n * <li>{@code $[methodName]} - replaced with the name of the method being invoked</li>\n * <li>{@code $[targetClassName]} - replaced with the name of the class that is\n * the target of the invocation</li>\n * <li>{@code $[targetClassShortName]} - replaced with the short name of the class\n * that is the target of the invocation</li>\n * <li>{@code $[returnValue]} - replaced with the value returned by the invocation</li>\n * <li>{@code $[argumentTypes]} - replaced with a comma-separated list of the\n * short class names of the method arguments</li>\n * <li>{@code $[arguments]} - replaced with a comma-separated list of the\n * {@code String} representation of the method arguments</li>\n * <li>{@code $[exception]} - replaced with the {@code String} representation\n * of any {@code Throwable} raised during the invocation</li>\n * <li>{@code $[invocationTime]} - replaced with the time, in milliseconds,\n * taken by the method invocation</li>\n * </ul>\n *\n * <p>There are restrictions on which placeholders can be used in which messages:\n * see the individual message properties for details on the valid placeholders.\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 1.2\n * @see #setEnterMessage\n * @see #setExitMessage\n * @see #setExceptionMessage\n * @see SimpleTraceInterceptor\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "signature": "public class CustomizableTraceInterceptor",
    "source_code": "public class CustomizableTraceInterceptor extends AbstractTraceInterceptor {\n\n\t/**\n\t * The {@code $[methodName]} placeholder.\n\t * Replaced with the name of the method being invoked.\n\t */\n\tpublic static final String PLACEHOLDER_METHOD_NAME = \"$[methodName]\";\n\n\t/**\n\t * The {@code $[targetClassName]} placeholder.\n\t * Replaced with the fully-qualified name of the {@code Class}\n\t * of the method invocation target.\n\t */\n\tpublic static final String PLACEHOLDER_TARGET_CLASS_NAME = \"$[targetClassName]\";\n\n\t/**\n\t * The {@code $[targetClassShortName]} placeholder.\n\t * Replaced with the short name of the {@code Class} of the\n\t * method invocation target.\n\t */\n\tpublic static final String PLACEHOLDER_TARGET_CLASS_SHORT_NAME = \"$[targetClassShortName]\";\n\n\t/**\n\t * The {@code $[returnValue]} placeholder.\n\t * Replaced with the {@code String} representation of the value\n\t * returned by the method invocation.\n\t */\n\tpublic static final String PLACEHOLDER_RETURN_VALUE = \"$[returnValue]\";\n\n\t/**\n\t * The {@code $[argumentTypes]} placeholder.\n\t * Replaced with a comma-separated list of the argument types for the\n\t * method invocation. Argument types are written as short class names.\n\t */\n\tpublic static final String PLACEHOLDER_ARGUMENT_TYPES = \"$[argumentTypes]\";\n\n\t/**\n\t * The {@code $[arguments]} placeholder.\n\t * Replaced with a comma separated list of the argument values for the\n\t * method invocation. Relies on the {@code toString()} method of\n\t * each argument type.\n\t */\n\tpublic static final String PLACEHOLDER_ARGUMENTS = \"$[arguments]\";\n\n\t/**\n\t * The {@code $[exception]} placeholder.\n\t * Replaced with the {@code String} representation of any\n\t * {@code Throwable} raised during method invocation.\n\t */\n\tpublic static final String PLACEHOLDER_EXCEPTION = \"$[exception]\";\n\n\t/**\n\t * The {@code $[invocationTime]} placeholder.\n\t * Replaced with the time taken by the invocation (in milliseconds).\n\t */\n\tpublic static final String PLACEHOLDER_INVOCATION_TIME = \"$[invocationTime]\";\n\n\t/**\n\t * The default message used for writing method entry messages.\n\t */\n\tprivate static final String DEFAULT_ENTER_MESSAGE = \"Entering method '\" +\n\t\t\tPLACEHOLDER_METHOD_NAME + \"' of class [\" + PLACEHOLDER_TARGET_CLASS_NAME + \"]\";\n\n\t/**\n\t * The default message used for writing method exit messages.\n\t */\n\tprivate static final String DEFAULT_EXIT_MESSAGE = \"Exiting method '\" +\n\t\t\tPLACEHOLDER_METHOD_NAME + \"' of class [\" + PLACEHOLDER_TARGET_CLASS_NAME + \"]\";\n\n\t/**\n\t * The default message used for writing exception messages.\n\t */\n\tprivate static final String DEFAULT_EXCEPTION_MESSAGE = \"Exception thrown in method '\" +\n\t\t\tPLACEHOLDER_METHOD_NAME + \"' of class [\" + PLACEHOLDER_TARGET_CLASS_NAME + \"]\";\n\n\t/**\n\t * The {@code Pattern} used to match placeholders.\n\t */\n\tprivate static final Pattern PATTERN = Pattern.compile(\"\\\\$\\\\[\\\\p{Alpha}+]\");\n\n\t/**\n\t * The {@code Set} of allowed placeholders.\n\t */\n\tstatic final Set<String> ALLOWED_PLACEHOLDERS = Set.of(\n\t\t\tPLACEHOLDER_METHOD_NAME,\n\t\t\tPLACEHOLDER_TARGET_CLASS_NAME,\n\t\t\tPLACEHOLDER_TARGET_CLASS_SHORT_NAME,\n\t\t\tPLACEHOLDER_RETURN_VALUE,\n\t\t\tPLACEHOLDER_ARGUMENT_TYPES,\n\t\t\tPLACEHOLDER_ARGUMENTS,\n\t\t\tPLACEHOLDER_EXCEPTION,\n\t\t\tPLACEHOLDER_INVOCATION_TIME);\n\n\n\t/**\n\t * The message for method entry.\n\t */\n\tprivate String enterMessage = DEFAULT_ENTER_MESSAGE;\n\n\t/**\n\t * The message for method exit.\n\t */\n\tprivate String exitMessage = DEFAULT_EXIT_MESSAGE;\n\n\t/**\n\t * The message for exceptions during method execution.\n\t */\n\tprivate String exceptionMessage = DEFAULT_EXCEPTION_MESSAGE;\n\n\n\t/**\n\t * Set the template used for method entry log messages.\n\t * This template can contain any of the following placeholders:\n\t * <ul>\n\t * <li>{@code $[targetClassName]}</li>\n\t * <li>{@code $[targetClassShortName]}</li>\n\t * <li>{@code $[argumentTypes]}</li>\n\t * <li>{@code $[arguments]}</li>\n\t * </ul>\n\t */\n\tpublic void setEnterMessage(String enterMessage) throws IllegalArgumentException {\n\t\tAssert.hasText(enterMessage, \"enterMessage must not be empty\");\n\t\tcheckForInvalidPlaceholders(enterMessage);\n\t\tAssert.doesNotContain(enterMessage, PLACEHOLDER_RETURN_VALUE,\n\t\t\t\t\"enterMessage cannot contain placeholder \" + PLACEHOLDER_RETURN_VALUE);\n\t\tAssert.doesNotContain(enterMessage, PLACEHOLDER_EXCEPTION,\n\t\t\t\t\"enterMessage cannot contain placeholder \" + PLACEHOLDER_EXCEPTION);\n\t\tAssert.doesNotContain(enterMessage, PLACEHOLDER_INVOCATION_TIME,\n\t\t\t\t\"enterMessage cannot contain placeholder \" + PLACEHOLDER_INVOCATION_TIME);\n\t\tthis.enterMessage = enterMessage;\n\t}\n\n\t/**\n\t * Set the template used for method exit log messages.\n\t * This template can contain any of the following placeholders:\n\t * <ul>\n\t * <li>{@code $[targetClassName]}</li>\n\t * <li>{@code $[targetClassShortName]}</li>\n\t * <li>{@code $[argumentTypes]}</li>\n\t * <li>{@code $[arguments]}</li>\n\t * <li>{@code $[returnValue]}</li>\n\t * <li>{@code $[invocationTime]}</li>\n\t * </ul>\n\t */\n\tpublic void setExitMessage(String exitMessage) {\n\t\tAssert.hasText(exitMessage, \"exitMessage must not be empty\");\n\t\tcheckForInvalidPlaceholders(exitMessage);\n\t\tAssert.doesNotContain(exitMessage, PLACEHOLDER_EXCEPTION,\n\t\t\t\t\"exitMessage cannot contain placeholder\" + PLACEHOLDER_EXCEPTION);\n\t\tthis.exitMessage = exitMessage;\n\t}\n\n\t/**\n\t * Set the template used for method exception log messages.\n\t * This template can contain any of the following placeholders:\n\t * <ul>\n\t * <li>{@code $[targetClassName]}</li>\n\t * <li>{@code $[targetClassShortName]}</li>\n\t * <li>{@code $[argumentTypes]}</li>\n\t * <li>{@code $[arguments]}</li>\n\t * <li>{@code $[exception]}</li>\n\t * </ul>\n\t */\n\tpublic void setExceptionMessage(String exceptionMessage) {\n\t\tAssert.hasText(exceptionMessage, \"exceptionMessage must not be empty\");\n\t\tcheckForInvalidPlaceholders(exceptionMessage);\n\t\tAssert.doesNotContain(exceptionMessage, PLACEHOLDER_RETURN_VALUE,\n\t\t\t\t\"exceptionMessage cannot contain placeholder \" + PLACEHOLDER_RETURN_VALUE);\n\t\tthis.exceptionMessage = exceptionMessage;\n\t}\n\n\n\t/**\n\t * Writes a log message before the invocation based on the value of {@code enterMessage}.\n\t * If the invocation succeeds, then a log message is written on exit based on the value\n\t * {@code exitMessage}. If an exception occurs during invocation, then a message is\n\t * written based on the value of {@code exceptionMessage}.\n\t * @see #setEnterMessage\n\t * @see #setExitMessage\n\t * @see #setExceptionMessage\n\t */\n\t@Override\n\tprotected Object invokeUnderTrace(MethodInvocation invocation, Log logger) throws Throwable {\n\t\tString name = ClassUtils.getQualifiedMethodName(invocation.getMethod());\n\t\tStopWatch stopWatch = new StopWatch(name);\n\t\tObject returnValue = null;\n\t\tboolean exitThroughException = false;\n\t\ttry {\n\t\t\tstopWatch.start(name);\n\t\t\twriteToLog(logger,\n\t\t\t\t\treplacePlaceholders(this.enterMessage, invocation, null, null, -1));\n\t\t\treturnValue = invocation.proceed();\n\t\t\treturn returnValue;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (stopWatch.isRunning()) {\n\t\t\t\tstopWatch.stop();\n\t\t\t}\n\t\t\texitThroughException = true;\n\t\t\twriteToLog(logger, replacePlaceholders(\n\t\t\t\t\tthis.exceptionMessage, invocation, null, ex, stopWatch.getTotalTimeMillis()), ex);\n\t\t\tthrow ex;\n\t\t}\n\t\tfinally {\n\t\t\tif (!exitThroughException) {\n\t\t\t\tif (stopWatch.isRunning()) {\n\t\t\t\t\tstopWatch.stop();\n\t\t\t\t}\n\t\t\t\twriteToLog(logger, replacePlaceholders(\n\t\t\t\t\t\tthis.exitMessage, invocation, returnValue, null, stopWatch.getTotalTimeMillis()));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Replace the placeholders in the given message with the supplied values,\n\t * or values derived from those supplied.\n\t * @param message the message template containing the placeholders to be replaced\n\t * @param methodInvocation the {@code MethodInvocation} being logged.\n\t * Used to derive values for all placeholders except {@code $[exception]}\n\t * and {@code $[returnValue]}.\n\t * @param returnValue any value returned by the invocation.\n\t * Used to replace the {@code $[returnValue]} placeholder. May be {@code null}.\n\t * @param throwable any {@code Throwable} raised during the invocation.\n\t * The value of {@code Throwable.toString()} is replaced for the\n\t * {@code $[exception]} placeholder. May be {@code null}.\n\t * @param invocationTime the value to write in place of the\n\t * {@code $[invocationTime]} placeholder\n\t * @return the formatted output to write to the log\n\t */\n\tprotected String replacePlaceholders(String message, MethodInvocation methodInvocation,\n\t\t\t@Nullable Object returnValue, @Nullable Throwable throwable, long invocationTime) {\n\n\t\tObject target = methodInvocation.getThis();\n\t\tAssert.state(target != null, \"Target must not be null\");\n\n\t\tStringBuilder output = new StringBuilder();\n\t\tMatcher matcher = PATTERN.matcher(message);\n\t\twhile (matcher.find()) {\n\t\t\tString match = matcher.group();\n\t\t\tswitch (match) {\n\t\t\t\tcase PLACEHOLDER_METHOD_NAME -> matcher.appendReplacement(output,\n\t\t\t\t\t\tMatcher.quoteReplacement(methodInvocation.getMethod().getName()));\n\t\t\t\tcase PLACEHOLDER_TARGET_CLASS_NAME -> {\n\t\t\t\t\tString className = getClassForLogging(target).getName();\n\t\t\t\t\tmatcher.appendReplacement(output, Matcher.quoteReplacement(className));\n\t\t\t\t}\n\t\t\t\tcase PLACEHOLDER_TARGET_CLASS_SHORT_NAME -> {\n\t\t\t\t\tString shortName = ClassUtils.getShortName(getClassForLogging(target));\n\t\t\t\t\tmatcher.appendReplacement(output, Matcher.quoteReplacement(shortName));\n\t\t\t\t}\n\t\t\t\tcase PLACEHOLDER_ARGUMENTS -> matcher.appendReplacement(output,\n\t\t\t\t\t\tMatcher.quoteReplacement(StringUtils.arrayToCommaDelimitedString(methodInvocation.getArguments())));\n\t\t\t\tcase PLACEHOLDER_ARGUMENT_TYPES -> appendArgumentTypes(methodInvocation, matcher, output);\n\t\t\t\tcase PLACEHOLDER_RETURN_VALUE -> appendReturnValue(methodInvocation, matcher, output, returnValue);\n\t\t\t\tcase PLACEHOLDER_EXCEPTION -> {\n\t\t\t\t\tif (throwable != null) {\n\t\t\t\t\t\tmatcher.appendReplacement(output, Matcher.quoteReplacement(throwable.toString()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcase PLACEHOLDER_INVOCATION_TIME -> matcher.appendReplacement(output, Long.toString(invocationTime));\n\t\t\t\tdefault -> {\n\t\t\t\t\t// Should not happen since placeholders are checked earlier.\n\t\t\t\t\tthrow new IllegalArgumentException(\"Unknown placeholder [\" + match + \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmatcher.appendTail(output);\n\n\t\treturn output.toString();\n\t}\n\n\t/**\n\t * Adds the {@code String} representation of the method return value\n\t * to the supplied {@code StringBuilder}. Correctly handles\n\t * {@code null} and {@code void} results.\n\t * @param methodInvocation the {@code MethodInvocation} that returned the value\n\t * @param matcher the {@code Matcher} containing the matched placeholder\n\t * @param output the {@code StringBuilder} to write output to\n\t * @param returnValue the value returned by the method invocation.\n\t */\n\tprivate static void appendReturnValue(\n\t\t\tMethodInvocation methodInvocation, Matcher matcher, StringBuilder output, @Nullable Object returnValue) {\n\n\t\tif (methodInvocation.getMethod().getReturnType() == void.class) {\n\t\t\tmatcher.appendReplacement(output, \"void\");\n\t\t}\n\t\telse if (returnValue == null) {\n\t\t\tmatcher.appendReplacement(output, \"null\");\n\t\t}\n\t\telse {\n\t\t\tmatcher.appendReplacement(output, Matcher.quoteReplacement(returnValue.toString()));\n\t\t}\n\t}\n\n\t/**\n\t * Adds a comma-separated list of the short {@code Class} names of the\n\t * method argument types to the output. For example, if a method has signature\n\t * {@code put(java.lang.String, java.lang.Object)} then the value returned\n\t * will be {@code String, Object}.\n\t * @param methodInvocation the {@code MethodInvocation} being logged.\n\t * Arguments will be retrieved from the corresponding {@code Method}.\n\t * @param matcher the {@code Matcher} containing the state of the output\n\t * @param output the {@code StringBuilder} containing the output\n\t */\n\tprivate static void appendArgumentTypes(MethodInvocation methodInvocation, Matcher matcher, StringBuilder output) {\n\t\tClass<?>[] argumentTypes = methodInvocation.getMethod().getParameterTypes();\n\t\tString[] argumentTypeShortNames = new String[argumentTypes.length];\n\t\tfor (int i = 0; i < argumentTypeShortNames.length; i++) {\n\t\t\targumentTypeShortNames[i] = ClassUtils.getShortName(argumentTypes[i]);\n\t\t}\n\t\tmatcher.appendReplacement(output,\n\t\t\t\tMatcher.quoteReplacement(StringUtils.arrayToCommaDelimitedString(argumentTypeShortNames)));\n\t}\n\n\t/**\n\t * Checks to see if the supplied {@code String} has any placeholders\n\t * that are not specified as constants on this class and throws an\n\t * {@code IllegalArgumentException} if so.\n\t */\n\tprivate static void checkForInvalidPlaceholders(String message) throws IllegalArgumentException {\n\t\tMatcher matcher = PATTERN.matcher(message);\n\t\twhile (matcher.find()) {\n\t\t\tString match = matcher.group();\n\t\t\tif (!ALLOWED_PLACEHOLDERS.contains(match)) {\n\t\t\t\tthrow new IllegalArgumentException(\"Placeholder [\" + match + \"] is not valid\");\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.aop.interceptor.CustomizableTraceInterceptor#invokeUnderTrace(invocation,logger)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Writes a log message before the invocation based on the value of {@code enterMessage}.\n\t * If the invocation succeeds, then a log message is written on exit based on the value\n\t * {@code exitMessage}. If an exception occurs during invocation, then a message is\n\t * written based on the value of {@code exceptionMessage}.\n\t * @see #setEnterMessage\n\t * @see #setExitMessage\n\t * @see #setExceptionMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "invocation",
      "logger"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "Object",
    "signature": "protected Object invokeUnderTrace(MethodInvocation invocation, Log logger)",
    "source_code": "\tprotected Object invokeUnderTrace(MethodInvocation invocation, Log logger) throws Throwable {\n\t\tString name = ClassUtils.getQualifiedMethodName(invocation.getMethod());\n\t\tStopWatch stopWatch = new StopWatch(name);\n\t\tObject returnValue = null;\n\t\tboolean exitThroughException = false;\n\t\ttry {\n\t\t\tstopWatch.start(name);\n\t\t\twriteToLog(logger,\n\t\t\t\t\treplacePlaceholders(this.enterMessage, invocation, null, null, -1));\n\t\t\treturnValue = invocation.proceed();\n\t\t\treturn returnValue;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (stopWatch.isRunning()) {\n\t\t\t\tstopWatch.stop();\n\t\t\t}\n\t\t\texitThroughException = true;\n\t\t\twriteToLog(logger, replacePlaceholders(\n\t\t\t\t\tthis.exceptionMessage, invocation, null, ex, stopWatch.getTotalTimeMillis()), ex);\n\t\t\tthrow ex;\n\t\t}\n\t\tfinally {\n\t\t\tif (!exitThroughException) {\n\t\t\t\tif (stopWatch.isRunning()) {\n\t\t\t\t\tstopWatch.stop();\n\t\t\t\t}\n\t\t\t\twriteToLog(logger, replacePlaceholders(\n\t\t\t\t\t\tthis.exitMessage, invocation, returnValue, null, stopWatch.getTotalTimeMillis()));\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.aop.interceptor.CustomizableTraceInterceptor#replacePlaceholders(message,methodInvocation,returnValue,throwable,invocationTime)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Replace the placeholders in the given message with the supplied values,\n\t * or values derived from those supplied.\n\t * @param message the message template containing the placeholders to be replaced\n\t * @param methodInvocation the {@code MethodInvocation} being logged.\n\t * Used to derive values for all placeholders except {@code $[exception]}\n\t * and {@code $[returnValue]}.\n\t * @param returnValue any value returned by the invocation.\n\t * Used to replace the {@code $[returnValue]} placeholder. May be {@code null}.\n\t * @param throwable any {@code Throwable} raised during the invocation.\n\t * The value of {@code Throwable.toString()} is replaced for the\n\t * {@code $[exception]} placeholder. May be {@code null}.\n\t * @param invocationTime the value to write in place of the\n\t * {@code $[invocationTime]} placeholder\n\t * @return the formatted output to write to the log\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "methodInvocation",
      "returnValue",
      "throwable",
      "invocationTime"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "String",
    "signature": "protected String replacePlaceholders(String message, MethodInvocation methodInvocation,\n\t\t\t@Nullable Object returnValue, @Nullable Throwable throwable, long invocationTime)",
    "source_code": "\tprotected String replacePlaceholders(String message, MethodInvocation methodInvocation,"
  },
  "org.springframework.aop.interceptor.CustomizableTraceInterceptor#setEnterMessage(enterMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the template used for method entry log messages.\n\t * This template can contain any of the following placeholders:\n\t * <ul>\n\t * <li>{@code $[targetClassName]}</li>\n\t * <li>{@code $[targetClassShortName]}</li>\n\t * <li>{@code $[argumentTypes]}</li>\n\t * <li>{@code $[arguments]}</li>\n\t * </ul>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "enterMessage"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "void",
    "signature": "public void setEnterMessage(String enterMessage)",
    "source_code": "\tpublic void setEnterMessage(String enterMessage) throws IllegalArgumentException {\n\t\tAssert.hasText(enterMessage, \"enterMessage must not be empty\");\n\t\tcheckForInvalidPlaceholders(enterMessage);\n\t\tAssert.doesNotContain(enterMessage, PLACEHOLDER_RETURN_VALUE,\n\t\t\t\t\"enterMessage cannot contain placeholder \" + PLACEHOLDER_RETURN_VALUE);\n\t\tAssert.doesNotContain(enterMessage, PLACEHOLDER_EXCEPTION,\n\t\t\t\t\"enterMessage cannot contain placeholder \" + PLACEHOLDER_EXCEPTION);\n\t\tAssert.doesNotContain(enterMessage, PLACEHOLDER_INVOCATION_TIME,\n\t\t\t\t\"enterMessage cannot contain placeholder \" + PLACEHOLDER_INVOCATION_TIME);\n\t\tthis.enterMessage = enterMessage;\n\t}"
  },
  "org.springframework.aop.interceptor.CustomizableTraceInterceptor#setExceptionMessage(exceptionMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the template used for method exception log messages.\n\t * This template can contain any of the following placeholders:\n\t * <ul>\n\t * <li>{@code $[targetClassName]}</li>\n\t * <li>{@code $[targetClassShortName]}</li>\n\t * <li>{@code $[argumentTypes]}</li>\n\t * <li>{@code $[arguments]}</li>\n\t * <li>{@code $[exception]}</li>\n\t * </ul>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exceptionMessage"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "void",
    "signature": "public void setExceptionMessage(String exceptionMessage)",
    "source_code": "\tpublic void setExceptionMessage(String exceptionMessage) {\n\t\tAssert.hasText(exceptionMessage, \"exceptionMessage must not be empty\");\n\t\tcheckForInvalidPlaceholders(exceptionMessage);\n\t\tAssert.doesNotContain(exceptionMessage, PLACEHOLDER_RETURN_VALUE,\n\t\t\t\t\"exceptionMessage cannot contain placeholder \" + PLACEHOLDER_RETURN_VALUE);\n\t\tthis.exceptionMessage = exceptionMessage;\n\t}"
  },
  "org.springframework.aop.interceptor.CustomizableTraceInterceptor#setExitMessage(exitMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the template used for method exit log messages.\n\t * This template can contain any of the following placeholders:\n\t * <ul>\n\t * <li>{@code $[targetClassName]}</li>\n\t * <li>{@code $[targetClassShortName]}</li>\n\t * <li>{@code $[argumentTypes]}</li>\n\t * <li>{@code $[arguments]}</li>\n\t * <li>{@code $[returnValue]}</li>\n\t * <li>{@code $[invocationTime]}</li>\n\t * </ul>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exitMessage"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "void",
    "signature": "public void setExitMessage(String exitMessage)",
    "source_code": "\tpublic void setExitMessage(String exitMessage) {\n\t\tAssert.hasText(exitMessage, \"exitMessage must not be empty\");\n\t\tcheckForInvalidPlaceholders(exitMessage);\n\t\tAssert.doesNotContain(exitMessage, PLACEHOLDER_EXCEPTION,\n\t\t\t\t\"exitMessage cannot contain placeholder\" + PLACEHOLDER_EXCEPTION);\n\t\tthis.exitMessage = exitMessage;\n\t}"
  },
  "org.springframework.aop.interceptor.PLACEHOLDER_ARGUMENTS": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The {@code $[arguments]} placeholder.\n\t * Replaced with a comma separated list of the argument values for the\n\t * method invocation. Relies on the {@code toString()} method of\n\t * each argument type.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "signature": "public String PLACEHOLDER_ARGUMENTS",
    "source_code": "\tpublic static final String PLACEHOLDER_ARGUMENTS = \"$[arguments]\";",
    "type": "String"
  },
  "org.springframework.aop.interceptor.PLACEHOLDER_ARGUMENT_TYPES": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The {@code $[argumentTypes]} placeholder.\n\t * Replaced with a comma-separated list of the argument types for the\n\t * method invocation. Argument types are written as short class names.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "signature": "public String PLACEHOLDER_ARGUMENT_TYPES",
    "source_code": "\tpublic static final String PLACEHOLDER_ARGUMENT_TYPES = \"$[argumentTypes]\";",
    "type": "String"
  },
  "org.springframework.aop.interceptor.PLACEHOLDER_EXCEPTION": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The {@code $[exception]} placeholder.\n\t * Replaced with the {@code String} representation of any\n\t * {@code Throwable} raised during method invocation.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "signature": "public String PLACEHOLDER_EXCEPTION",
    "source_code": "\tpublic static final String PLACEHOLDER_EXCEPTION = \"$[exception]\";",
    "type": "String"
  },
  "org.springframework.aop.interceptor.PLACEHOLDER_INVOCATION_TIME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The {@code $[invocationTime]} placeholder.\n\t * Replaced with the time taken by the invocation (in milliseconds).\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "signature": "public String PLACEHOLDER_INVOCATION_TIME",
    "source_code": "\tpublic static final String PLACEHOLDER_INVOCATION_TIME = \"$[invocationTime]\";",
    "type": "String"
  },
  "org.springframework.aop.interceptor.PLACEHOLDER_METHOD_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The {@code $[methodName]} placeholder.\n\t * Replaced with the name of the method being invoked.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "signature": "public String PLACEHOLDER_METHOD_NAME",
    "source_code": "\tpublic static final String PLACEHOLDER_METHOD_NAME = \"$[methodName]\";",
    "type": "String"
  },
  "org.springframework.aop.interceptor.PLACEHOLDER_RETURN_VALUE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The {@code $[returnValue]} placeholder.\n\t * Replaced with the {@code String} representation of the value\n\t * returned by the method invocation.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "signature": "public String PLACEHOLDER_RETURN_VALUE",
    "source_code": "\tpublic static final String PLACEHOLDER_RETURN_VALUE = \"$[returnValue]\";",
    "type": "String"
  },
  "org.springframework.aop.interceptor.PLACEHOLDER_TARGET_CLASS_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The {@code $[targetClassName]} placeholder.\n\t * Replaced with the fully-qualified name of the {@code Class}\n\t * of the method invocation target.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "signature": "public String PLACEHOLDER_TARGET_CLASS_NAME",
    "source_code": "\tpublic static final String PLACEHOLDER_TARGET_CLASS_NAME = \"$[targetClassName]\";",
    "type": "String"
  },
  "org.springframework.aop.interceptor.PLACEHOLDER_TARGET_CLASS_SHORT_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The {@code $[targetClassShortName]} placeholder.\n\t * Replaced with the short name of the {@code Class} of the\n\t * method invocation target.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "signature": "public String PLACEHOLDER_TARGET_CLASS_SHORT_NAME",
    "source_code": "\tpublic static final String PLACEHOLDER_TARGET_CLASS_SHORT_NAME = \"$[targetClassShortName]\";",
    "type": "String"
  },
  "org.springframework.aop.scope.<unknown>#generateInstanceSupplierCode(generationContext,beanRegistrationCode,allowDirectSupplierShortcut)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "allowDirectSupplierShortcut"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\t\tBeanRegistrationCode beanRegistrationCode, boolean allowDirectSupplierShortcut)",
    "source_code": "\t\tpublic CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,"
  },
  "org.springframework.aop.scope.<unknown>#generateInstanceSupplierCode(generationContext,beanRegistrationCode,constructorOrFactoryMethod,allowDirectSupplierShortcut)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "constructorOrFactoryMethod",
      "allowDirectSupplierShortcut"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\t\tBeanRegistrationCode beanRegistrationCode,\n\t\t\t\tExecutable constructorOrFactoryMethod,\n\t\t\t\tboolean allowDirectSupplierShortcut)",
    "source_code": "\t\tpublic CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,"
  },
  "org.springframework.aop.scope.<unknown>#getTarget(registeredBean)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "ClassName",
    "signature": "public ClassName getTarget(RegisteredBean registeredBean)",
    "source_code": "\t\tpublic ClassName getTarget(RegisteredBean registeredBean) {\n\t\t\treturn ClassName.get(this.targetBeanDefinition.getResolvableType().toClass());\n\t\t}"
  },
  "org.springframework.aop.scope.<unknown>#getTarget(registeredBean,constructorOrFactoryMethod)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean",
      "constructorOrFactoryMethod"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "ClassName",
    "signature": "public ClassName getTarget(RegisteredBean registeredBean, Executable constructorOrFactoryMethod)",
    "source_code": "\t\tpublic ClassName getTarget(RegisteredBean registeredBean, Executable constructorOrFactoryMethod) {\n\t\t\treturn ClassName.get(this.targetBeanDefinition.getResolvableType().toClass());\n\t\t}"
  },
  "org.springframework.aop.support.AopUtils#invokeSuspendingFunction(method,target,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "target",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 376
    },
    "return": "Object",
    "signature": "public Object invokeSuspendingFunction(Method method, @Nullable Object target, Object... args)",
    "source_code": "\t\tpublic static Object invokeSuspendingFunction(Method method, @Nullable Object target, Object... args) {\n\t\t\tContinuation<?> continuation = (Continuation<?>) args[args.length -1];\n\t\t\tAssert.state(continuation != null, \"No Continuation available\");\n\t\t\tCoroutineContext context = continuation.getContext().minusKey(Job.Key);\n\t\t\treturn CoroutinesUtils.invokeSuspendingFunction(context, method, target, args);\n\t\t}"
  },
  "org.springframework.aop.support.ClassFilters#negate(classFilter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a class filter that represents the logical negation of the specified\n\t * filter instance.\n\t * @param classFilter the {@link ClassFilter} to negate\n\t * @return a filter that represents the logical negation of the specified filter\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classFilter"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "ClassFilter",
    "signature": "public ClassFilter negate(ClassFilter classFilter)",
    "source_code": "\tpublic static ClassFilter negate(ClassFilter classFilter) {\n\t\tAssert.notNull(classFilter, \"ClassFilter must not be null\");\n\t\treturn new NegateClassFilter(classFilter);\n\t}"
  },
  "org.springframework.aop.support.ControlFlowPointcut#incrementEvaluationCount()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Increment the {@link #getEvaluations() evaluation count}.\n\t * @since 6.1\n\t * @see #matches(Method, Class, Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "void",
    "signature": "protected void incrementEvaluationCount()",
    "source_code": "\tprotected final void incrementEvaluationCount() {\n\t\tthis.evaluationCount.incrementAndGet();\n\t}"
  },
  "org.springframework.aop.support.ControlFlowPointcut#isMatch(methodName,methodNamePattern)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the given method name matches the method name pattern.\n\t * <p>This method is invoked by {@link #isMatch(String, int)}.\n\t * <p>The default implementation checks for direct equality as well as\n\t * {@code xxx*}, {@code *xxx}, {@code *xxx*}, and {@code xxx*yyy} matches.\n\t * <p>Can be overridden in subclasses &mdash; for example, to support a\n\t * different style of simple pattern matching.\n\t * @param methodName the method name to check\n\t * @param methodNamePattern the method name pattern\n\t * @return {@code true} if the method name matches the pattern\n\t * @since 6.1\n\t * @see #isMatch(String, int)\n\t * @see PatternMatchUtils#simpleMatch(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "methodName",
      "methodNamePattern"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "boolean",
    "signature": "protected boolean isMatch(String methodName, String methodNamePattern)",
    "source_code": "\tprotected boolean isMatch(String methodName, String methodNamePattern) {\n\t\treturn (methodName.equals(methodNamePattern) ||\n\t\t\t\tPatternMatchUtils.simpleMatch(methodNamePattern, methodName));\n\t}"
  },
  "org.springframework.aop.support.ControlFlowPointcut#isMatch(methodName,patternIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the given method name matches the method name pattern at the\n\t * specified index.\n\t * <p>This method is invoked by {@link #matches(Method, Class, Object...)}.\n\t * <p>The default implementation retrieves the method name pattern from\n\t * {@link #methodNamePatterns} and delegates to {@link #isMatch(String, String)}.\n\t * <p>Can be overridden in subclasses &mdash; for example, to support\n\t * regular expressions.\n\t * @param methodName the method name to check\n\t * @param patternIndex the index of the method name pattern\n\t * @return {@code true} if the method name matches the pattern at the specified\n\t * index\n\t * @since 6.1\n\t * @see #methodNamePatterns\n\t * @see #isMatch(String, String)\n\t * @see #matches(Method, Class, Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "methodName",
      "patternIndex"
    ],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "boolean",
    "signature": "protected boolean isMatch(String methodName, int patternIndex)",
    "source_code": "\tprotected boolean isMatch(String methodName, int patternIndex) {\n\t\tString methodNamePattern = this.methodNamePatterns.get(patternIndex);\n\t\treturn isMatch(methodName, methodNamePattern);\n\t}"
  },
  "org.springframework.aop.support.MethodMatchers#negate(methodMatcher)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a method matcher that represents the logical negation of the specified\n\t * matcher instance.\n\t * @param methodMatcher the {@link MethodMatcher} to negate\n\t * @return a matcher that represents the logical negation of the specified matcher\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodMatcher"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "MethodMatcher",
    "signature": "public MethodMatcher negate(MethodMatcher methodMatcher)",
    "source_code": "\tpublic static MethodMatcher negate(MethodMatcher methodMatcher) {\n\t\tAssert.notNull(methodMatcher, \"MethodMatcher must not be null\");\n\t\treturn new NegateMethodMatcher(methodMatcher);\n\t}"
  },
  "org.springframework.aop.support.NameMatchMethodPointcut#addMethodName(mappedNamePattern)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add another method name pattern, in addition to those already configured.\n\t * <p>Like the \"set\" methods, this method is for use when configuring proxies,\n\t * before a proxy is used.\n\t * <p><b>NOTE:</b> This method does not work after the proxy is in use, since\n\t * advice chains will be cached.\n\t * @param mappedNamePattern the additional method name pattern\n\t * @return this pointcut to allow for method chaining\n\t * @see #setMappedNames(String...)\n\t * @see #setMappedName(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedNamePattern"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "NameMatchMethodPointcut",
    "signature": "public NameMatchMethodPointcut addMethodName(String mappedNamePattern)",
    "source_code": "\tpublic NameMatchMethodPointcut addMethodName(String mappedNamePattern) {\n\t\tthis.mappedNamePatterns.add(mappedNamePattern);\n\t\treturn this;\n\t}"
  },
  "org.springframework.aop.support.NameMatchMethodPointcut#addMethodName(name)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add another eligible method name, in addition to those already named.\n\t * Like the set methods, this method is for use when configuring proxies,\n\t * before a proxy is used.\n\t * <p><b>NB:</b> This method does not work after the proxy is in\n\t * use, as advice chains will be cached.\n\t * @param name the name of the additional method that will match\n\t * @return this pointcut to allow for multiple additions in one line\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "NameMatchMethodPointcut",
    "signature": "public NameMatchMethodPointcut addMethodName(String name)",
    "source_code": "\tpublic NameMatchMethodPointcut addMethodName(String name) {\n\t\tthis.mappedNames.add(name);\n\t\treturn this;\n\t}"
  },
  "org.springframework.aop.support.NameMatchMethodPointcut#isMatch(methodName,mappedName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return if the given method name matches the mapped name.\n\t * <p>The default implementation checks for \"xxx*\", \"*xxx\" and \"*xxx*\" matches,\n\t * as well as direct equality. Can be overridden in subclasses.\n\t * @param methodName the method name of the class\n\t * @param mappedName the name in the descriptor\n\t * @return if the names match\n\t * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "methodName",
      "mappedName"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "boolean",
    "signature": "protected boolean isMatch(String methodName, String mappedName)",
    "source_code": "\tprotected boolean isMatch(String methodName, String mappedName) {\n\t\treturn PatternMatchUtils.simpleMatch(mappedName, methodName);\n\t}"
  },
  "org.springframework.aop.support.NameMatchMethodPointcut#isMatch(methodName,mappedNamePattern)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the given method name matches the mapped name pattern.\n\t * <p>The default implementation checks for {@code xxx*}, {@code *xxx},\n\t * {@code *xxx*}, and {@code xxx*yyy} matches, as well as direct equality.\n\t * <p>Can be overridden in subclasses.\n\t * @param methodName the method name to check\n\t * @param mappedNamePattern the method name pattern\n\t * @return {@code true} if the method name matches the pattern\n\t * @see PatternMatchUtils#simpleMatch(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "methodName",
      "mappedNamePattern"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "boolean",
    "signature": "protected boolean isMatch(String methodName, String mappedNamePattern)",
    "source_code": "\tprotected boolean isMatch(String methodName, String mappedNamePattern) {\n\t\treturn PatternMatchUtils.simpleMatch(mappedNamePattern, methodName);\n\t}"
  },
  "org.springframework.aop.support.NameMatchMethodPointcut#setMappedName(mappedName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenience method when we have only a single method name to match.\n\t * Use either this method or {@code setMappedNames}, not both.\n\t * @see #setMappedNames\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedName"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "return": "void",
    "signature": "public void setMappedName(String mappedName)",
    "source_code": "\tpublic void setMappedName(String mappedName) {\n\t\tsetMappedNames(mappedName);\n\t}"
  },
  "org.springframework.aop.support.NameMatchMethodPointcut#setMappedName(mappedNamePattern)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenience method for configuring a single method name pattern.\n\t * <p>Use either this method or {@link #setMappedNames(String...)}, but not both.\n\t * @see #setMappedNames\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedNamePattern"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "void",
    "signature": "public void setMappedName(String mappedNamePattern)",
    "source_code": "\tpublic void setMappedName(String mappedNamePattern) {\n\t\tsetMappedNames(mappedNamePattern);\n\t}"
  },
  "org.springframework.aop.support.NameMatchMethodPointcut#setMappedNames(mappedNamePatterns)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the method name patterns defining methods to match.\n\t * <p>Matching will be the union of all these; if any match, the pointcut matches.\n\t * @see #setMappedName(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedNamePatterns"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "void",
    "signature": "public void setMappedNames(String... mappedNamePatterns)",
    "source_code": "\tpublic void setMappedNames(String... mappedNamePatterns) {\n\t\tthis.mappedNamePatterns = new ArrayList<>(Arrays.asList(mappedNamePatterns));\n\t}"
  },
  "org.springframework.aop.support.NameMatchMethodPointcut#setMappedNames(mappedNames)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the method names defining methods to match.\n\t * Matching will be the union of all these; if any match,\n\t * the pointcut matches.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedNames"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "void",
    "signature": "public void setMappedNames(String... mappedNames)",
    "source_code": "\tpublic void setMappedNames(String... mappedNames) {\n\t\tthis.mappedNames = new ArrayList<>(Arrays.asList(mappedNames));\n\t}"
  },
  "org.springframework.aop.support.methodNamePatterns": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An immutable list of distinct method name patterns against which to match.\n\t * @since 6.1\n\t */",
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "signature": "protected List<String> methodNamePatterns",
    "source_code": "\tprotected final List<String> methodNamePatterns;",
    "type": "List<String>"
  },
  "org.springframework.aop.target.EmptyTargetSource#releaseTarget(target)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Nothing to release.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "void",
    "signature": "public void releaseTarget(Object target)",
    "source_code": "\tpublic void releaseTarget(Object target) {\n\t}"
  },
  "org.springframework.aop.target.HotSwappableTargetSource#isStatic()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "boolean",
    "signature": "public boolean isStatic()",
    "source_code": "\tpublic final boolean isStatic() {\n\t\treturn false;\n\t}"
  },
  "org.springframework.aop.target.HotSwappableTargetSource#releaseTarget(target)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "void",
    "signature": "public void releaseTarget(Object target)",
    "source_code": "\tpublic void releaseTarget(Object target) {\n\t\t// nothing to do\n\t}"
  },
  "org.springframework.aop.target.SingletonTargetSource#releaseTarget(target)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "void",
    "signature": "public void releaseTarget(Object target)",
    "source_code": "\tpublic void releaseTarget(Object target) {\n\t\t// nothing to do\n\t}"
  },
  "org.springframework.aot.generate.CollectionDelegate": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract {@link Delegate} for {@code Collection} types.\n\t * @param <T> type the collection type\n\t */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "signature": "public class CollectionDelegate",
    "source_code": "\tpublic abstract static class CollectionDelegate<T extends Collection<?>> implements Delegate {\n\n\t\tprivate final Class<?> collectionType;\n\n\t\tprivate final CodeBlock emptyResult;\n\n\t\tprotected CollectionDelegate(Class<?> collectionType, CodeBlock emptyResult) {\n\t\t\tthis.collectionType = collectionType;\n\t\t\tthis.emptyResult = emptyResult;\n\t\t}\n\n\t\t@Override\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Nullable\n\t\tpublic CodeBlock generateCode(ValueCodeGenerator valueCodeGenerator, Object value) {\n\t\t\tif (this.collectionType.isInstance(value)) {\n\t\t\t\tT collection = (T) value;\n\t\t\t\tif (collection.isEmpty()) {\n\t\t\t\t\treturn this.emptyResult;\n\t\t\t\t}\n\t\t\t\treturn generateCollectionCode(valueCodeGenerator, collection);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tprotected CodeBlock generateCollectionCode(ValueCodeGenerator valueCodeGenerator, T collection) {\n\t\t\treturn generateCollectionOf(valueCodeGenerator, collection, this.collectionType);\n\t\t}\n\n\t\tprotected final CodeBlock generateCollectionOf(ValueCodeGenerator valueCodeGenerator,\n\t\t\t\tCollection<?> collection, Class<?> collectionType) {\n\t\t\tBuilder code = CodeBlock.builder();\n\t\t\tcode.add(\"$T.of(\", collectionType);\n\t\t\tIterator<?> iterator = collection.iterator();\n\t\t\twhile (iterator.hasNext()) {\n\t\t\t\tObject element = iterator.next();\n\t\t\t\tcode.add(\"$L\", valueCodeGenerator.generateCode(element));\n\t\t\t\tif (iterator.hasNext()) {\n\t\t\t\t\tcode.add(\", \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tcode.add(\")\");\n\t\t\treturn code.build();\n\t\t}\n\t}"
  },
  "org.springframework.aot.generate.INSTANCES": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link Delegate} implementations for common value types.\n\t * These are:\n\t * <ul>\n\t * <li>Primitive types,</li>\n\t * <li>String,</li>\n\t * <li>Charset,</li>\n\t * <li>Enum,</li>\n\t * <li>Class,</li>\n\t * <li>{@link ResolvableType},</li>\n\t * <li>Array,</li>\n\t * <li>List via {@code List.of},</li>\n\t * <li>Set via {@code Set.of} and support of {@link LinkedHashSet},</li>\n\t * <li>Map via {@code Map.of} or {@code Map.ofEntries}.</li>\n\t * </ul>\n\t * Those implementations do not require the {@link ValueCodeGenerator} to be\n\t * {@linkplain ValueCodeGenerator#scoped(GeneratedMethods) scoped}.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "signature": "public List<Delegate> INSTANCES",
    "source_code": "\tpublic static final List<Delegate> INSTANCES = List.of(",
    "type": "List<Delegate>"
  },
  "org.springframework.aot.generate.MapDelegate": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@link Delegate} for {@link Map} types.\n\t */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "signature": "public class MapDelegate",
    "source_code": "\tpublic static class MapDelegate implements Delegate {\n\n\t\tprivate static final CodeBlock EMPTY_RESULT = CodeBlock.of(\"$T.emptyMap()\", Collections.class);\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic CodeBlock generateCode(ValueCodeGenerator valueCodeGenerator, Object value) {\n\t\t\tif (value instanceof Map<?, ?> map) {\n\t\t\t\tif (map.isEmpty()) {\n\t\t\t\t\treturn EMPTY_RESULT;\n\t\t\t\t}\n\t\t\t\treturn generateMapCode(valueCodeGenerator, map);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Generate the code for a non-empty {@link Map}.\n\t\t * @param valueCodeGenerator the code generator to use for embedded values\n\t\t * @param map the value to generate\n\t\t * @return the code that represents the specified map or {@code null} if\n\t\t * the specified map is not supported.\n\t\t */\n\t\t@Nullable\n\t\tprotected CodeBlock generateMapCode(ValueCodeGenerator valueCodeGenerator, Map<?, ?> map) {\n\t\t\tmap = orderForCodeConsistency(map);\n\t\t\tboolean useOfEntries = map.size() > 10;\n\t\t\tCodeBlock.Builder code = CodeBlock.builder();\n\t\t\tcode.add(\"$T\" + ((!useOfEntries) ? \".of(\" : \".ofEntries(\"), Map.class);\n\t\t\tIterator<? extends Entry<?, ?>> iterator = map.entrySet().iterator();\n\t\t\twhile (iterator.hasNext()) {\n\t\t\t\tEntry<?, ?> entry = iterator.next();\n\t\t\t\tCodeBlock keyCode = valueCodeGenerator.generateCode(entry.getKey());\n\t\t\t\tCodeBlock valueCode = valueCodeGenerator.generateCode(entry.getValue());\n\t\t\t\tif (!useOfEntries) {\n\t\t\t\t\tcode.add(\"$L, $L\", keyCode, valueCode);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcode.add(\"$T.entry($L,$L)\", Map.class, keyCode, valueCode);\n\t\t\t\t}\n\t\t\t\tif (iterator.hasNext()) {\n\t\t\t\t\tcode.add(\", \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tcode.add(\")\");\n\t\t\treturn code.build();\n\t\t}\n\n\t\tprivate <K, V> Map<K, V> orderForCodeConsistency(Map<K, V> map) {\n\t\t\ttry {\n\t\t\t\treturn new TreeMap<>(map);\n\t\t\t}\n\t\t\tcatch (ClassCastException ex) {\n\t\t\t\t// If elements are not comparable, just keep the original map\n\t\t\t\treturn map;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.aot.generate.ValueCodeGeneratorDelegates": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Code generator {@link Delegate} for well known value types.\n *\n * @author Stephane Nicoll\n * @since 6.1.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "signature": "public class ValueCodeGeneratorDelegates",
    "source_code": "public abstract class ValueCodeGeneratorDelegates {\n\n\t/**\n\t * Return the {@link Delegate} implementations for common value types.\n\t * These are:\n\t * <ul>\n\t * <li>Primitive types,</li>\n\t * <li>String,</li>\n\t * <li>Charset,</li>\n\t * <li>Enum,</li>\n\t * <li>Class,</li>\n\t * <li>{@link ResolvableType},</li>\n\t * <li>Array,</li>\n\t * <li>List via {@code List.of},</li>\n\t * <li>Set via {@code Set.of} and support of {@link LinkedHashSet},</li>\n\t * <li>Map via {@code Map.of} or {@code Map.ofEntries}.</li>\n\t * </ul>\n\t * Those implementations do not require the {@link ValueCodeGenerator} to be\n\t * {@linkplain ValueCodeGenerator#scoped(GeneratedMethods) scoped}.\n\t */\n\tpublic static final List<Delegate> INSTANCES = List.of(\n\t\t\tnew PrimitiveDelegate(),\n\t\t\tnew StringDelegate(),\n\t\t\tnew CharsetDelegate(),\n\t\t\tnew EnumDelegate(),\n\t\t\tnew ClassDelegate(),\n\t\t\tnew ResolvableTypeDelegate(),\n\t\t\tnew ArrayDelegate(),\n\t\t\tnew ListDelegate(),\n\t\t\tnew SetDelegate(),\n\t\t\tnew MapDelegate());\n\n\n\t/**\n\t * Abstract {@link Delegate} for {@code Collection} types.\n\t * @param <T> type the collection type\n\t */\n\tpublic abstract static class CollectionDelegate<T extends Collection<?>> implements Delegate {\n\n\t\tprivate final Class<?> collectionType;\n\n\t\tprivate final CodeBlock emptyResult;\n\n\t\tprotected CollectionDelegate(Class<?> collectionType, CodeBlock emptyResult) {\n\t\t\tthis.collectionType = collectionType;\n\t\t\tthis.emptyResult = emptyResult;\n\t\t}\n\n\t\t@Override\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Nullable\n\t\tpublic CodeBlock generateCode(ValueCodeGenerator valueCodeGenerator, Object value) {\n\t\t\tif (this.collectionType.isInstance(value)) {\n\t\t\t\tT collection = (T) value;\n\t\t\t\tif (collection.isEmpty()) {\n\t\t\t\t\treturn this.emptyResult;\n\t\t\t\t}\n\t\t\t\treturn generateCollectionCode(valueCodeGenerator, collection);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tprotected CodeBlock generateCollectionCode(ValueCodeGenerator valueCodeGenerator, T collection) {\n\t\t\treturn generateCollectionOf(valueCodeGenerator, collection, this.collectionType);\n\t\t}\n\n\t\tprotected final CodeBlock generateCollectionOf(ValueCodeGenerator valueCodeGenerator,\n\t\t\t\tCollection<?> collection, Class<?> collectionType) {\n\t\t\tBuilder code = CodeBlock.builder();\n\t\t\tcode.add(\"$T.of(\", collectionType);\n\t\t\tIterator<?> iterator = collection.iterator();\n\t\t\twhile (iterator.hasNext()) {\n\t\t\t\tObject element = iterator.next();\n\t\t\t\tcode.add(\"$L\", valueCodeGenerator.generateCode(element));\n\t\t\t\tif (iterator.hasNext()) {\n\t\t\t\t\tcode.add(\", \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tcode.add(\")\");\n\t\t\treturn code.build();\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link Delegate} for {@link Map} types.\n\t */\n\tpublic static class MapDelegate implements Delegate {\n\n\t\tprivate static final CodeBlock EMPTY_RESULT = CodeBlock.of(\"$T.emptyMap()\", Collections.class);\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic CodeBlock generateCode(ValueCodeGenerator valueCodeGenerator, Object value) {\n\t\t\tif (value instanceof Map<?, ?> map) {\n\t\t\t\tif (map.isEmpty()) {\n\t\t\t\t\treturn EMPTY_RESULT;\n\t\t\t\t}\n\t\t\t\treturn generateMapCode(valueCodeGenerator, map);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Generate the code for a non-empty {@link Map}.\n\t\t * @param valueCodeGenerator the code generator to use for embedded values\n\t\t * @param map the value to generate\n\t\t * @return the code that represents the specified map or {@code null} if\n\t\t * the specified map is not supported.\n\t\t */\n\t\t@Nullable\n\t\tprotected CodeBlock generateMapCode(ValueCodeGenerator valueCodeGenerator, Map<?, ?> map) {\n\t\t\tmap = orderForCodeConsistency(map);\n\t\t\tboolean useOfEntries = map.size() > 10;\n\t\t\tCodeBlock.Builder code = CodeBlock.builder();\n\t\t\tcode.add(\"$T\" + ((!useOfEntries) ? \".of(\" : \".ofEntries(\"), Map.class);\n\t\t\tIterator<? extends Entry<?, ?>> iterator = map.entrySet().iterator();\n\t\t\twhile (iterator.hasNext()) {\n\t\t\t\tEntry<?, ?> entry = iterator.next();\n\t\t\t\tCodeBlock keyCode = valueCodeGenerator.generateCode(entry.getKey());\n\t\t\t\tCodeBlock valueCode = valueCodeGenerator.generateCode(entry.getValue());\n\t\t\t\tif (!useOfEntries) {\n\t\t\t\t\tcode.add(\"$L, $L\", keyCode, valueCode);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcode.add(\"$T.entry($L,$L)\", Map.class, keyCode, valueCode);\n\t\t\t\t}\n\t\t\t\tif (iterator.hasNext()) {\n\t\t\t\t\tcode.add(\", \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tcode.add(\")\");\n\t\t\treturn code.build();\n\t\t}\n\n\t\tprivate <K, V> Map<K, V> orderForCodeConsistency(Map<K, V> map) {\n\t\t\ttry {\n\t\t\t\treturn new TreeMap<>(map);\n\t\t\t}\n\t\t\tcatch (ClassCastException ex) {\n\t\t\t\t// If elements are not comparable, just keep the original map\n\t\t\t\treturn map;\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link Delegate} for {@code primitive} types.\n\t */\n\tprivate static class PrimitiveDelegate implements Delegate {\n\n\t\tprivate static final Map<Character, String> CHAR_ESCAPES = Map.of(\n\t\t\t\t'\\b', \"\\\\b\",\n\t\t\t\t'\\t', \"\\\\t\",\n\t\t\t\t'\\n', \"\\\\n\",\n\t\t\t\t'\\f', \"\\\\f\",\n\t\t\t\t'\\r', \"\\\\r\",\n\t\t\t\t'\\\"', \"\\\"\",\n\t\t\t\t'\\'', \"\\\\'\",\n\t\t\t\t'\\\\', \"\\\\\\\\\"\n\t\t);\n\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic CodeBlock generateCode(ValueCodeGenerator codeGenerator, Object value) {\n\t\t\tif (value instanceof Boolean || value instanceof Integer) {\n\t\t\t\treturn CodeBlock.of(\"$L\", value);\n\t\t\t}\n\t\t\tif (value instanceof Byte) {\n\t\t\t\treturn CodeBlock.of(\"(byte) $L\", value);\n\t\t\t}\n\t\t\tif (value instanceof Short) {\n\t\t\t\treturn CodeBlock.of(\"(short) $L\", value);\n\t\t\t}\n\t\t\tif (value instanceof Long) {\n\t\t\t\treturn CodeBlock.of(\"$LL\", value);\n\t\t\t}\n\t\t\tif (value instanceof Float) {\n\t\t\t\treturn CodeBlock.of(\"$LF\", value);\n\t\t\t}\n\t\t\tif (value instanceof Double) {\n\t\t\t\treturn CodeBlock.of(\"(double) $L\", value);\n\t\t\t}\n\t\t\tif (value instanceof Character character) {\n\t\t\t\treturn CodeBlock.of(\"'$L'\", escape(character));\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tprivate String escape(char ch) {\n\t\t\tString escaped = CHAR_ESCAPES.get(ch);\n\t\t\tif (escaped != null) {\n\t\t\t\treturn escaped;\n\t\t\t}\n\t\t\treturn (!Character.isISOControl(ch)) ? Character.toString(ch)\n\t\t\t\t\t: String.format(\"\\\\u%04x\", (int) ch);\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link Delegate} for {@link String} types.\n\t */\n\tprivate static class StringDelegate implements Delegate {\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic CodeBlock generateCode(ValueCodeGenerator codeGenerator, Object value) {\n\t\t\tif (value instanceof String) {\n\t\t\t\treturn CodeBlock.of(\"$S\", value);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link Delegate} for {@link Charset} types.\n\t */\n\tprivate static class CharsetDelegate implements Delegate {\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic CodeBlock generateCode(ValueCodeGenerator codeGenerator, Object value) {\n\t\t\tif (value instanceof Charset charset) {\n\t\t\t\treturn CodeBlock.of(\"$T.forName($S)\", Charset.class, charset.name());\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link Delegate} for {@link Enum} types.\n\t */\n\tprivate static class EnumDelegate implements Delegate {\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic CodeBlock generateCode(ValueCodeGenerator codeGenerator, Object value) {\n\t\t\tif (value instanceof Enum<?> enumValue) {\n\t\t\t\treturn CodeBlock.of(\"$T.$L\", enumValue.getDeclaringClass(),\n\t\t\t\t\t\tenumValue.name());\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link Delegate} for {@link Class} types.\n\t */\n\tprivate static class ClassDelegate implements Delegate {\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic CodeBlock generateCode(ValueCodeGenerator codeGenerator, Object value) {\n\t\t\tif (value instanceof Class<?> clazz) {\n\t\t\t\treturn CodeBlock.of(\"$T.class\", ClassUtils.getUserClass(clazz));\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link Delegate} for {@link ResolvableType} types.\n\t */\n\tprivate static class ResolvableTypeDelegate implements Delegate {\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic CodeBlock generateCode(ValueCodeGenerator codeGenerator, Object value) {\n\t\t\tif (value instanceof ResolvableType resolvableType) {\n\t\t\t\treturn generateCode(resolvableType, false);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\n\t\tprivate static CodeBlock generateCode(ResolvableType resolvableType, boolean allowClassResult) {\n\t\t\tif (ResolvableType.NONE.equals(resolvableType)) {\n\t\t\t\treturn CodeBlock.of(\"$T.NONE\", ResolvableType.class);\n\t\t\t}\n\t\t\tClass<?> type = ClassUtils.getUserClass(resolvableType.toClass());\n\t\t\tif (resolvableType.hasGenerics() && !resolvableType.hasUnresolvableGenerics()) {\n\t\t\t\treturn generateCodeWithGenerics(resolvableType, type);\n\t\t\t}\n\t\t\tif (allowClassResult) {\n\t\t\t\treturn CodeBlock.of(\"$T.class\", type);\n\t\t\t}\n\t\t\treturn CodeBlock.of(\"$T.forClass($T.class)\", ResolvableType.class, type);\n\t\t}\n\n\t\tprivate static CodeBlock generateCodeWithGenerics(ResolvableType target, Class<?> type) {\n\t\t\tResolvableType[] generics = target.getGenerics();\n\t\t\tboolean hasNoNestedGenerics = Arrays.stream(generics).noneMatch(ResolvableType::hasGenerics);\n\t\t\tCodeBlock.Builder code = CodeBlock.builder();\n\t\t\tcode.add(\"$T.forClassWithGenerics($T.class\", ResolvableType.class, type);\n\t\t\tfor (ResolvableType generic : generics) {\n\t\t\t\tcode.add(\", $L\", generateCode(generic, hasNoNestedGenerics));\n\t\t\t}\n\t\t\tcode.add(\")\");\n\t\t\treturn code.build();\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link Delegate} for {@code array} types.\n\t */\n\tprivate static class ArrayDelegate implements Delegate {\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic CodeBlock generateCode(ValueCodeGenerator codeGenerator, Object value) {\n\t\t\tif (value.getClass().isArray()) {\n\t\t\t\tStream<CodeBlock> elements = Arrays.stream(ObjectUtils.toObjectArray(value))\n\t\t\t\t\t\t.map(codeGenerator::generateCode);\n\t\t\t\tCodeBlock.Builder code = CodeBlock.builder();\n\t\t\t\tcode.add(\"new $T {\", value.getClass());\n\t\t\t\tcode.add(elements.collect(CodeBlock.joining(\", \")));\n\t\t\t\tcode.add(\"}\");\n\t\t\t\treturn code.build();\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link Delegate} for {@link List} types.\n\t */\n\tprivate static class ListDelegate extends CollectionDelegate<List<?>> {\n\n\t\tListDelegate() {\n\t\t\tsuper(List.class, CodeBlock.of(\"$T.emptyList()\", Collections.class));\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link Delegate} for {@link Set} types.\n\t */\n\tprivate static class SetDelegate extends CollectionDelegate<Set<?>> {\n\n\t\tSetDelegate() {\n\t\t\tsuper(Set.class, CodeBlock.of(\"$T.emptySet()\", Collections.class));\n\t\t}\n\n\t\t@Override\n\t\tprotected CodeBlock generateCollectionCode(ValueCodeGenerator valueCodeGenerator, Set<?> collection) {\n\t\t\tif (collection instanceof LinkedHashSet) {\n\t\t\t\treturn CodeBlock.of(\"new $T($L)\", LinkedHashSet.class,\n\t\t\t\t\t\tgenerateCollectionOf(valueCodeGenerator, collection, List.class));\n\t\t\t}\n\t\t\treturn super.generateCollectionCode(valueCodeGenerator,\n\t\t\t\t\torderForCodeConsistency(collection));\n\t\t}\n\n\t\tprivate Set<?> orderForCodeConsistency(Set<?> set) {\n\t\t\ttry {\n\t\t\t\treturn new TreeSet<Object>(set);\n\t\t\t}\n\t\t\tcatch (ClassCastException ex) {\n\t\t\t\t// If elements are not comparable, just keep the original set\n\t\t\t\treturn set;\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.aot.generate.ValueCodeGeneratorDelegates#generateCode(codeGenerator,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "codeGenerator",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 364
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateCode(ValueCodeGenerator codeGenerator, Object value)",
    "source_code": "\t\tpublic CodeBlock generateCode(ValueCodeGenerator codeGenerator, Object value) {\n\t\t\tif (value.getClass().isArray()) {\n\t\t\t\tStream<CodeBlock> elements = Arrays.stream(ObjectUtils.toObjectArray(value))\n\t\t\t\t\t\t.map(codeGenerator::generateCode);\n\t\t\t\tCodeBlock.Builder code = CodeBlock.builder();\n\t\t\t\tcode.add(\"new $T {\", value.getClass());\n\t\t\t\tcode.add(elements.collect(CodeBlock.joining(\", \")));\n\t\t\t\tcode.add(\"}\");\n\t\t\t\treturn code.build();\n\t\t\t}\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.aot.generate.ValueCodeGeneratorDelegates#generateCode(valueCodeGenerator,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "valueCodeGenerator",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateCode(ValueCodeGenerator valueCodeGenerator, Object value)",
    "source_code": "\t\tpublic CodeBlock generateCode(ValueCodeGenerator valueCodeGenerator, Object value) {\n\t\t\tif (value instanceof Map<?, ?> map) {\n\t\t\t\tif (map.isEmpty()) {\n\t\t\t\t\treturn EMPTY_RESULT;\n\t\t\t\t}\n\t\t\t\treturn generateMapCode(valueCodeGenerator, map);\n\t\t\t}\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.aot.generate.ValueCodeGeneratorDelegates#generateCollectionCode(valueCodeGenerator,collection)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "valueCodeGenerator",
      "collection"
    ],
    "position": {
      "column": 1,
      "line": 400
    },
    "return": "CodeBlock",
    "signature": "protected CodeBlock generateCollectionCode(ValueCodeGenerator valueCodeGenerator, Set<?> collection)",
    "source_code": "\t\tprotected CodeBlock generateCollectionCode(ValueCodeGenerator valueCodeGenerator, Set<?> collection) {\n\t\t\tif (collection instanceof LinkedHashSet) {\n\t\t\t\treturn CodeBlock.of(\"new $T($L)\", LinkedHashSet.class,\n\t\t\t\t\t\tgenerateCollectionOf(valueCodeGenerator, collection, List.class));\n\t\t\t}\n\t\t\treturn super.generateCollectionCode(valueCodeGenerator,\n\t\t\t\t\torderForCodeConsistency(collection));\n\t\t}"
  },
  "org.springframework.aot.generate.ValueCodeGeneratorDelegates#generateCollectionOf(valueCodeGenerator,collection,collectionType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "valueCodeGenerator",
      "collection",
      "collectionType"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "CodeBlock",
    "signature": "protected CodeBlock generateCollectionOf(ValueCodeGenerator valueCodeGenerator,\n\t\t\t\tCollection<?> collection, Class<?> collectionType)",
    "source_code": "\t\tprotected final CodeBlock generateCollectionOf(ValueCodeGenerator valueCodeGenerator,"
  },
  "org.springframework.aot.generate.ValueCodeGeneratorDelegates#generateMapCode(valueCodeGenerator,Map<?,map)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Generate the code for a non-empty {@link Map}.\n\t\t * @param valueCodeGenerator the code generator to use for embedded values\n\t\t * @param map the value to generate\n\t\t * @return the code that represents the specified map or {@code null} if\n\t\t * the specified map is not supported.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "valueCodeGenerator",
      "Map<?",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "CodeBlock",
    "signature": "protected CodeBlock generateMapCode(ValueCodeGenerator valueCodeGenerator, Map<?, ?> map)",
    "source_code": "\t\tprotected CodeBlock generateMapCode(ValueCodeGenerator valueCodeGenerator, Map<?, ?> map) {\n\t\t\tmap = orderForCodeConsistency(map);\n\t\t\tboolean useOfEntries = map.size() > 10;\n\t\t\tCodeBlock.Builder code = CodeBlock.builder();\n\t\t\tcode.add(\"$T\" + ((!useOfEntries) ? \".of(\" : \".ofEntries(\"), Map.class);\n\t\t\tIterator<? extends Entry<?, ?>> iterator = map.entrySet().iterator();\n\t\t\twhile (iterator.hasNext()) {\n\t\t\t\tEntry<?, ?> entry = iterator.next();\n\t\t\t\tCodeBlock keyCode = valueCodeGenerator.generateCode(entry.getKey());\n\t\t\t\tCodeBlock valueCode = valueCodeGenerator.generateCode(entry.getValue());\n\t\t\t\tif (!useOfEntries) {\n\t\t\t\t\tcode.add(\"$L, $L\", keyCode, valueCode);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcode.add(\"$T.entry($L,$L)\", Map.class, keyCode, valueCode);\n\t\t\t\t}\n\t\t\t\tif (iterator.hasNext()) {\n\t\t\t\t\tcode.add(\", \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tcode.add(\")\");\n\t\t\treturn code.build();\n\t\t}"
  },
  "org.springframework.aot.hint.AbstractTypeReference#compareTo(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "int",
    "signature": "public int compareTo(TypeReference other)",
    "source_code": "\tpublic int compareTo(TypeReference other) {\n\t\treturn this.getCanonicalName().compareToIgnoreCase(other.getCanonicalName());\n\t}"
  },
  "org.springframework.beans.<unknown>#getReadMethodType()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType getReadMethodType()",
    "source_code": "\tpublic ResolvableType getReadMethodType() {\n\t\tAssert.state(this.readMethodType != null, \"No read method available\");\n\t\treturn this.readMethodType;\n\t}"
  },
  "org.springframework.beans.<unknown>#getTypeDescriptor()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getTypeDescriptor()",
    "source_code": "\tpublic TypeDescriptor getTypeDescriptor() {\n\t\tTypeDescriptor typeDescriptor = this.typeDescriptor;\n\t\tif (typeDescriptor == null) {\n\t\t\tProperty property = new Property(getBeanClass(), getReadMethod(), getWriteMethod(), getName());\n\t\t\ttypeDescriptor = new TypeDescriptor(property);\n\t\t\tthis.typeDescriptor = typeDescriptor;\n\t\t}\n\t\treturn typeDescriptor;\n\t}"
  },
  "org.springframework.beans.<unknown>#getUniqueWriteMethodFallback()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "Method",
    "signature": "public Method getUniqueWriteMethodFallback()",
    "source_code": "\tpublic Method getUniqueWriteMethodFallback() {\n\t\tif (this.ambiguousWriteMethods != null && this.ambiguousWriteMethods.size() == 1) {\n\t\t\treturn this.ambiguousWriteMethods.iterator().next();\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.<unknown>#getWriteMethodFallback(valueType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "valueType"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "Method",
    "signature": "public Method getWriteMethodFallback(@Nullable Class<?> valueType)",
    "source_code": "\tpublic Method getWriteMethodFallback(@Nullable Class<?> valueType) {\n\t\tif (this.ambiguousWriteMethods != null) {\n\t\t\tfor (Method method : this.ambiguousWriteMethods) {\n\t\t\t\tClass<?> paramType = method.getParameterTypes()[0];\n\t\t\t\tif (valueType != null ? paramType.isAssignableFrom(valueType) : !paramType.isPrimitive()) {\n\t\t\t\t\treturn method;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.<unknown>#getWriteMethodType()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType getWriteMethodType()",
    "source_code": "\tpublic ResolvableType getWriteMethodType() {\n\t\tResolvableType writeMethodType = this.writeMethodType;\n\t\tif (writeMethodType == null) {\n\t\t\twriteMethodType = ResolvableType.forMethodParameter(getWriteMethodParameter());\n\t\t\tthis.writeMethodType = writeMethodType;\n\t\t}\n\t\treturn writeMethodType;\n\t}"
  },
  "org.springframework.beans.<unknown>#hasUniqueWriteMethod()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "boolean",
    "signature": "public boolean hasUniqueWriteMethod()",
    "source_code": "\tpublic boolean hasUniqueWriteMethod() {\n\t\treturn (this.writeMethod != null && this.ambiguousWriteMethods == null);\n\t}"
  },
  "org.springframework.beans.AbstractNestablePropertyAccessor#getCollectionType(nestingLevel)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nestingLevel"
    ],
    "position": {
      "column": 1,
      "line": 1057
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getCollectionType(int nestingLevel)",
    "source_code": "\t\tpublic TypeDescriptor getCollectionType(int nestingLevel) {\n\t\t\treturn TypeDescriptor.valueOf(getResolvableType().getNested(nestingLevel).asCollection().resolveGeneric());\n\t\t}"
  },
  "org.springframework.beans.AbstractNestablePropertyAccessor#getMapKeyType(nestingLevel)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nestingLevel"
    ],
    "position": {
      "column": 1,
      "line": 1049
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getMapKeyType(int nestingLevel)",
    "source_code": "\t\tpublic TypeDescriptor getMapKeyType(int nestingLevel) {\n\t\t\treturn TypeDescriptor.valueOf(getResolvableType().getNested(nestingLevel).asMap().resolveGeneric(0));\n\t\t}"
  },
  "org.springframework.beans.AbstractNestablePropertyAccessor#getMapValueType(nestingLevel)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nestingLevel"
    ],
    "position": {
      "column": 1,
      "line": 1053
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getMapValueType(int nestingLevel)",
    "source_code": "\t\tpublic TypeDescriptor getMapValueType(int nestingLevel) {\n\t\t\treturn TypeDescriptor.valueOf(getResolvableType().getNested(nestingLevel).asMap().resolveGeneric(1));\n\t\t}"
  },
  "org.springframework.beans.AbstractNestablePropertyAccessor#setValueFallbackIfPossible(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 1069
    },
    "return": "boolean",
    "signature": "public boolean setValueFallbackIfPossible(@Nullable Object value)",
    "source_code": "\t\tpublic boolean setValueFallbackIfPossible(@Nullable Object value) {\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.beans.BeanUtils#hasUniqueWriteMethod(pd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the specified property has a unique write method,\n\t * i.e. is writable but does not declare overloaded setter methods.\n\t * @param pd the PropertyDescriptor for the property\n\t * @return {@code true} if writable and unique, {@code false} otherwise\n\t * @since 6.1.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pd"
    ],
    "position": {
      "column": 1,
      "line": 615
    },
    "return": "boolean",
    "signature": "public boolean hasUniqueWriteMethod(PropertyDescriptor pd)",
    "source_code": "\tpublic static boolean hasUniqueWriteMethod(PropertyDescriptor pd) {\n\t\tif (pd instanceof GenericTypeAwarePropertyDescriptor gpd) {\n\t\t\treturn gpd.hasUniqueWriteMethod();\n\t\t}\n\t\telse {\n\t\t\treturn (pd.getWriteMethod() != null);\n\t\t}\n\t}"
  },
  "org.springframework.beans.BeanWrapperImpl": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Default {@link BeanWrapper} implementation that should be sufficient\n * for all typical use cases. Caches introspection results for efficiency.\n *\n * <p>Note: Auto-registers default property editors from the\n * {@code org.springframework.beans.propertyeditors} package, which apply\n * in addition to the JDK's standard PropertyEditors. Applications can call\n * the {@link #registerCustomEditor(Class, java.beans.PropertyEditor)} method\n * to register an editor for a particular instance (i.e. they are not shared\n * across the application). See the base class\n * {@link PropertyEditorRegistrySupport} for details.\n *\n * <p><b>NOTE: As of Spring 2.5, this is - for almost all purposes - an\n * internal class.</b> It is just public in order to allow for access from\n * other framework packages. For standard application access purposes, use the\n * {@link PropertyAccessorFactory#forBeanPropertyAccess} factory method instead.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Stephane Nicoll\n * @since 15 April 2001\n * @see #registerCustomEditor\n * @see #setPropertyValues\n * @see #setPropertyValue\n * @see #getPropertyValue\n * @see #getPropertyType\n * @see BeanWrapper\n * @see PropertyEditorRegistrySupport\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "signature": "public class BeanWrapperImpl",
    "source_code": "public class BeanWrapperImpl extends AbstractNestablePropertyAccessor implements BeanWrapper {\n\n\t/**\n\t * Cached introspections results for this object, to prevent encountering\n\t * the cost of JavaBeans introspection every time.\n\t */\n\t@Nullable\n\tprivate CachedIntrospectionResults cachedIntrospectionResults;\n\n\n\t/**\n\t * Create a new empty BeanWrapperImpl. Wrapped instance needs to be set afterwards.\n\t * Registers default editors.\n\t * @see #setWrappedInstance\n\t */\n\tpublic BeanWrapperImpl() {\n\t\tthis(true);\n\t}\n\n\t/**\n\t * Create a new empty BeanWrapperImpl. Wrapped instance needs to be set afterwards.\n\t * @param registerDefaultEditors whether to register default editors\n\t * (can be suppressed if the BeanWrapper won't need any type conversion)\n\t * @see #setWrappedInstance\n\t */\n\tpublic BeanWrapperImpl(boolean registerDefaultEditors) {\n\t\tsuper(registerDefaultEditors);\n\t}\n\n\t/**\n\t * Create a new BeanWrapperImpl for the given object.\n\t * @param object the object wrapped by this BeanWrapper\n\t */\n\tpublic BeanWrapperImpl(Object object) {\n\t\tsuper(object);\n\t}\n\n\t/**\n\t * Create a new BeanWrapperImpl, wrapping a new instance of the specified class.\n\t * @param clazz class to instantiate and wrap\n\t */\n\tpublic BeanWrapperImpl(Class<?> clazz) {\n\t\tsuper(clazz);\n\t}\n\n\t/**\n\t * Create a new BeanWrapperImpl for the given object,\n\t * registering a nested path that the object is in.\n\t * @param object the object wrapped by this BeanWrapper\n\t * @param nestedPath the nested path of the object\n\t * @param rootObject the root object at the top of the path\n\t */\n\tpublic BeanWrapperImpl(Object object, String nestedPath, Object rootObject) {\n\t\tsuper(object, nestedPath, rootObject);\n\t}\n\n\t/**\n\t * Create a new BeanWrapperImpl for the given object,\n\t * registering a nested path that the object is in.\n\t * @param object the object wrapped by this BeanWrapper\n\t * @param nestedPath the nested path of the object\n\t * @param parent the containing BeanWrapper (must not be {@code null})\n\t */\n\tprivate BeanWrapperImpl(Object object, String nestedPath, BeanWrapperImpl parent) {\n\t\tsuper(object, nestedPath, parent);\n\t}\n\n\n\t/**\n\t * Set a bean instance to hold, without any unwrapping of {@link java.util.Optional}.\n\t * @param object the actual target object\n\t * @since 4.3\n\t * @see #setWrappedInstance(Object)\n\t */\n\tpublic void setBeanInstance(Object object) {\n\t\tthis.wrappedObject = object;\n\t\tthis.rootObject = object;\n\t\tthis.typeConverterDelegate = new TypeConverterDelegate(this, this.wrappedObject);\n\t\tsetIntrospectionClass(object.getClass());\n\t}\n\n\t@Override\n\tpublic void setWrappedInstance(Object object, @Nullable String nestedPath, @Nullable Object rootObject) {\n\t\tsuper.setWrappedInstance(object, nestedPath, rootObject);\n\t\tsetIntrospectionClass(getWrappedClass());\n\t}\n\n\t/**\n\t * Set the class to introspect.\n\t * Needs to be called when the target object changes.\n\t * @param clazz the class to introspect\n\t */\n\tprotected void setIntrospectionClass(Class<?> clazz) {\n\t\tif (this.cachedIntrospectionResults != null && this.cachedIntrospectionResults.getBeanClass() != clazz) {\n\t\t\tthis.cachedIntrospectionResults = null;\n\t\t}\n\t}\n\n\t/**\n\t * Obtain a lazily initialized CachedIntrospectionResults instance\n\t * for the wrapped object.\n\t */\n\tprivate CachedIntrospectionResults getCachedIntrospectionResults() {\n\t\tif (this.cachedIntrospectionResults == null) {\n\t\t\tthis.cachedIntrospectionResults = CachedIntrospectionResults.forClass(getWrappedClass());\n\t\t}\n\t\treturn this.cachedIntrospectionResults;\n\t}\n\n\n\t/**\n\t * Convert the given value for the specified property to the latter's type.\n\t * <p>This method is only intended for optimizations in a BeanFactory.\n\t * Use the {@code convertIfNecessary} methods for programmatic conversion.\n\t * @param value the value to convert\n\t * @param propertyName the target property\n\t * (note that nested or indexed properties are not supported here)\n\t * @return the new value, possibly the result of type conversion\n\t * @throws TypeMismatchException if type conversion failed\n\t */\n\t@Nullable\n\tpublic Object convertForProperty(@Nullable Object value, String propertyName) throws TypeMismatchException {\n\t\tCachedIntrospectionResults cachedIntrospectionResults = getCachedIntrospectionResults();\n\t\tPropertyDescriptor pd = cachedIntrospectionResults.getPropertyDescriptor(propertyName);\n\t\tif (pd == null) {\n\t\t\tthrow new InvalidPropertyException(getRootClass(), getNestedPath() + propertyName,\n\t\t\t\t\t\"No property '\" + propertyName + \"' found\");\n\t\t}\n\t\tTypeDescriptor td = cachedIntrospectionResults.getTypeDescriptor(pd);\n\t\tif (td == null) {\n\t\t\ttd = cachedIntrospectionResults.addTypeDescriptor(pd, new TypeDescriptor(property(pd)));\n\t\t}\n\t\treturn convertForProperty(propertyName, null, value, td);\n\t}\n\n\tprivate Property property(PropertyDescriptor pd) {\n\t\tGenericTypeAwarePropertyDescriptor gpd = (GenericTypeAwarePropertyDescriptor) pd;\n\t\treturn new Property(gpd.getBeanClass(), gpd.getReadMethod(), gpd.getWriteMethod(), gpd.getName());\n\t}\n\n\t@Override\n\t@Nullable\n\tprotected BeanPropertyHandler getLocalPropertyHandler(String propertyName) {\n\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(propertyName);\n\t\treturn (pd != null ? new BeanPropertyHandler(pd) : null);\n\t}\n\n\t@Override\n\tprotected BeanWrapperImpl newNestedPropertyAccessor(Object object, String nestedPath) {\n\t\treturn new BeanWrapperImpl(object, nestedPath, this);\n\t}\n\n\t@Override\n\tprotected NotWritablePropertyException createNotWritablePropertyException(String propertyName) {\n\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n\t\tthrow new NotWritablePropertyException(getRootClass(), getNestedPath() + propertyName,\n\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t}\n\n\t@Override\n\tpublic PropertyDescriptor[] getPropertyDescriptors() {\n\t\treturn getCachedIntrospectionResults().getPropertyDescriptors();\n\t}\n\n\t@Override\n\tpublic PropertyDescriptor getPropertyDescriptor(String propertyName) throws InvalidPropertyException {\n\t\tBeanWrapperImpl nestedBw = (BeanWrapperImpl) getPropertyAccessorForPropertyPath(propertyName);\n\t\tString finalPath = getFinalPath(nestedBw, propertyName);\n\t\tPropertyDescriptor pd = nestedBw.getCachedIntrospectionResults().getPropertyDescriptor(finalPath);\n\t\tif (pd == null) {\n\t\t\tthrow new InvalidPropertyException(getRootClass(), getNestedPath() + propertyName,\n\t\t\t\t\t\"No property '\" + propertyName + \"' found\");\n\t\t}\n\t\treturn pd;\n\t}\n\n\n\tprivate class BeanPropertyHandler extends PropertyHandler {\n\n\t\tprivate final PropertyDescriptor pd;\n\n\t\tpublic BeanPropertyHandler(PropertyDescriptor pd) {\n\t\t\tsuper(pd.getPropertyType(), pd.getReadMethod() != null, pd.getWriteMethod() != null);\n\t\t\tthis.pd = pd;\n\t\t}\n\n\t\t@Override\n\t\tpublic ResolvableType getResolvableType() {\n\t\t\treturn ResolvableType.forMethodReturnType(this.pd.getReadMethod());\n\t\t}\n\n\t\t@Override\n\t\tpublic TypeDescriptor toTypeDescriptor() {\n\t\t\treturn new TypeDescriptor(property(this.pd));\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic TypeDescriptor nested(int level) {\n\t\t\treturn TypeDescriptor.nested(property(this.pd), level);\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Object getValue() throws Exception {\n\t\t\tMethod readMethod = this.pd.getReadMethod();\n\t\t\tReflectionUtils.makeAccessible(readMethod);\n\t\t\treturn readMethod.invoke(getWrappedInstance(), (Object[]) null);\n\t\t}\n\n\t\t@Override\n\t\tpublic void setValue(@Nullable Object value) throws Exception {\n\t\t\tMethod writeMethod = (this.pd instanceof GenericTypeAwarePropertyDescriptor typeAwarePd ?\n\t\t\t\t\ttypeAwarePd.getWriteMethodForActualAccess() : this.pd.getWriteMethod());\n\t\t\tReflectionUtils.makeAccessible(writeMethod);\n\t\t\twriteMethod.invoke(getWrappedInstance(), value);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.beans.BeanWrapperImpl#convertForProperty(value,propertyName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given value for the specified property to the latter's type.\n\t * <p>This method is only intended for optimizations in a BeanFactory.\n\t * Use the {@code convertIfNecessary} methods for programmatic conversion.\n\t * @param value the value to convert\n\t * @param propertyName the target property\n\t * (note that nested or indexed properties are not supported here)\n\t * @return the new value, possibly the result of type conversion\n\t * @throws TypeMismatchException if type conversion failed\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "propertyName"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "Object",
    "signature": "public Object convertForProperty(@Nullable Object value, String propertyName)",
    "source_code": "\tpublic Object convertForProperty(@Nullable Object value, String propertyName) throws TypeMismatchException {\n\t\tCachedIntrospectionResults cachedIntrospectionResults = getCachedIntrospectionResults();\n\t\tPropertyDescriptor pd = cachedIntrospectionResults.getPropertyDescriptor(propertyName);\n\t\tif (pd == null) {\n\t\t\tthrow new InvalidPropertyException(getRootClass(), getNestedPath() + propertyName,\n\t\t\t\t\t\"No property '\" + propertyName + \"' found\");\n\t\t}\n\t\tTypeDescriptor td = cachedIntrospectionResults.getTypeDescriptor(pd);\n\t\tif (td == null) {\n\t\t\ttd = cachedIntrospectionResults.addTypeDescriptor(pd, new TypeDescriptor(property(pd)));\n\t\t}\n\t\treturn convertForProperty(propertyName, null, value, td);\n\t}"
  },
  "org.springframework.beans.BeanWrapperImpl#createNotWritablePropertyException(propertyName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "propertyName"
    ],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "NotWritablePropertyException",
    "signature": "protected NotWritablePropertyException createNotWritablePropertyException(String propertyName)",
    "source_code": "\tprotected NotWritablePropertyException createNotWritablePropertyException(String propertyName) {\n\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n\t\tthrow new NotWritablePropertyException(getRootClass(), getNestedPath() + propertyName,\n\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t}"
  },
  "org.springframework.beans.BeanWrapperImpl#getLocalPropertyHandler(propertyName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "propertyName"
    ],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "BeanPropertyHandler",
    "signature": "protected BeanPropertyHandler getLocalPropertyHandler(String propertyName)",
    "source_code": "\tprotected BeanPropertyHandler getLocalPropertyHandler(String propertyName) {\n\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(propertyName);\n\t\treturn (pd != null ? new BeanPropertyHandler(pd) : null);\n\t}"
  },
  "org.springframework.beans.BeanWrapperImpl#getPropertyDescriptor(propertyName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "PropertyDescriptor",
    "signature": "public PropertyDescriptor getPropertyDescriptor(String propertyName)",
    "source_code": "\tpublic PropertyDescriptor getPropertyDescriptor(String propertyName) throws InvalidPropertyException {\n\t\tBeanWrapperImpl nestedBw = (BeanWrapperImpl) getPropertyAccessorForPropertyPath(propertyName);\n\t\tString finalPath = getFinalPath(nestedBw, propertyName);\n\t\tPropertyDescriptor pd = nestedBw.getCachedIntrospectionResults().getPropertyDescriptor(finalPath);\n\t\tif (pd == null) {\n\t\t\tthrow new InvalidPropertyException(getRootClass(), getNestedPath() + propertyName,\n\t\t\t\t\t\"No property '\" + propertyName + \"' found\");\n\t\t}\n\t\treturn pd;\n\t}"
  },
  "org.springframework.beans.BeanWrapperImpl#getPropertyDescriptors()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "PropertyDescriptor[]",
    "signature": "public PropertyDescriptor[] getPropertyDescriptors()",
    "source_code": "\tpublic PropertyDescriptor[] getPropertyDescriptors() {\n\t\treturn getCachedIntrospectionResults().getPropertyDescriptors();\n\t}"
  },
  "org.springframework.beans.BeanWrapperImpl#getResolvableType()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 245
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType getResolvableType()",
    "source_code": "\t\tpublic ResolvableType getResolvableType() {\n\t\t\treturn ResolvableType.forMethodReturnType(this.pd.getReadMethod());\n\t\t}"
  },
  "org.springframework.beans.BeanWrapperImpl#getValue()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "Object",
    "signature": "public Object getValue()",
    "source_code": "\t\tpublic Object getValue() throws Exception {\n\t\t\tMethod readMethod = this.pd.getReadMethod();\n\t\t\tReflectionUtils.makeAccessible(readMethod);\n\t\t\treturn readMethod.invoke(getWrappedInstance(), (Object[]) null);\n\t\t}"
  },
  "org.springframework.beans.BeanWrapperImpl#nested(level)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "level"
    ],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor nested(int level)",
    "source_code": "\t\tpublic TypeDescriptor nested(int level) {\n\t\t\treturn TypeDescriptor.nested(property(this.pd), level);\n\t\t}"
  },
  "org.springframework.beans.BeanWrapperImpl#newNestedPropertyAccessor(object,nestedPath)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "nestedPath"
    ],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "BeanWrapperImpl",
    "signature": "protected BeanWrapperImpl newNestedPropertyAccessor(Object object, String nestedPath)",
    "source_code": "\tprotected BeanWrapperImpl newNestedPropertyAccessor(Object object, String nestedPath) {\n\t\treturn new BeanWrapperImpl(object, nestedPath, this);\n\t}"
  },
  "org.springframework.beans.BeanWrapperImpl#setBeanInstance(object)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a bean instance to hold, without any unwrapping of {@link java.util.Optional}.\n\t * @param object the actual target object\n\t * @since 4.3\n\t * @see #setWrappedInstance(Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "void",
    "signature": "public void setBeanInstance(Object object)",
    "source_code": "\tpublic void setBeanInstance(Object object) {\n\t\tthis.wrappedObject = object;\n\t\tthis.rootObject = object;\n\t\tthis.typeConverterDelegate = new TypeConverterDelegate(this, this.wrappedObject);\n\t\tsetIntrospectionClass(object.getClass());\n\t}"
  },
  "org.springframework.beans.BeanWrapperImpl#setIntrospectionClass(clazz)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the class to introspect.\n\t * Needs to be called when the target object changes.\n\t * @param clazz the class to introspect\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "void",
    "signature": "protected void setIntrospectionClass(Class<?> clazz)",
    "source_code": "\tprotected void setIntrospectionClass(Class<?> clazz) {\n\t\tif (this.cachedIntrospectionResults != null && this.cachedIntrospectionResults.getBeanClass() != clazz) {\n\t\t\tthis.cachedIntrospectionResults = null;\n\t\t}\n\t}"
  },
  "org.springframework.beans.BeanWrapperImpl#setValue(value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 269
    },
    "return": "void",
    "signature": "public void setValue(@Nullable Object value)",
    "source_code": "\t\tpublic void setValue(@Nullable Object value) throws Exception {\n\t\t\tMethod writeMethod = (this.pd instanceof GenericTypeAwarePropertyDescriptor typeAwarePd ?\n\t\t\t\t\ttypeAwarePd.getWriteMethodForActualAccess() : this.pd.getWriteMethod());\n\t\t\tReflectionUtils.makeAccessible(writeMethod);\n\t\t\twriteMethod.invoke(getWrappedInstance(), value);\n\t\t}"
  },
  "org.springframework.beans.BeanWrapperImpl#setWrappedInstance(object,nestedPath,rootObject)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "nestedPath",
      "rootObject"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "void",
    "signature": "public void setWrappedInstance(Object object, @Nullable String nestedPath, @Nullable Object rootObject)",
    "source_code": "\tpublic void setWrappedInstance(Object object, @Nullable String nestedPath, @Nullable Object rootObject) {\n\t\tsuper.setWrappedInstance(object, nestedPath, rootObject);\n\t\tsetIntrospectionClass(getWrappedClass());\n\t}"
  },
  "org.springframework.beans.BeanWrapperImpl#toTypeDescriptor()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 250
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor toTypeDescriptor()",
    "source_code": "\t\tpublic TypeDescriptor toTypeDescriptor() {\n\t\t\treturn new TypeDescriptor(property(this.pd));\n\t\t}"
  },
  "org.springframework.beans.PropertyAccessorUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Utility methods for classes that perform bean property access\n * according to the {@link PropertyAccessor} interface.\n *\n * @author Juergen Hoeller\n * @since 1.2.6\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 28
    },
    "signature": "public class PropertyAccessorUtils",
    "source_code": "public abstract class PropertyAccessorUtils {\n\n\t/**\n\t * Return the actual property name for the given property path.\n\t * @param propertyPath the property path to determine the property name\n\t * for (can include property keys, for example for specifying a map entry)\n\t * @return the actual property name, without any key elements\n\t */\n\tpublic static String getPropertyName(String propertyPath) {\n\t\tint separatorIndex = (propertyPath.endsWith(PropertyAccessor.PROPERTY_KEY_SUFFIX) ?\n\t\t\t\tpropertyPath.indexOf(PropertyAccessor.PROPERTY_KEY_PREFIX_CHAR) : -1);\n\t\treturn (separatorIndex != -1 ? propertyPath.substring(0, separatorIndex) : propertyPath);\n\t}\n\n\t/**\n\t * Check whether the given property path indicates an indexed or nested property.\n\t * @param propertyPath the property path to check\n\t * @return whether the path indicates an indexed or nested property\n\t */\n\tpublic static boolean isNestedOrIndexedProperty(@Nullable String propertyPath) {\n\t\tif (propertyPath == null) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < propertyPath.length(); i++) {\n\t\t\tchar ch = propertyPath.charAt(i);\n\t\t\tif (ch == PropertyAccessor.NESTED_PROPERTY_SEPARATOR_CHAR ||\n\t\t\t\t\tch == PropertyAccessor.PROPERTY_KEY_PREFIX_CHAR) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Determine the first nested property separator in the\n\t * given property path, ignoring dots in keys (like \"map[my.key]\").\n\t * @param propertyPath the property path to check\n\t * @return the index of the nested property separator, or -1 if none\n\t */\n\tpublic static int getFirstNestedPropertySeparatorIndex(String propertyPath) {\n\t\treturn getNestedPropertySeparatorIndex(propertyPath, false);\n\t}\n\n\t/**\n\t * Determine the first nested property separator in the\n\t * given property path, ignoring dots in keys (like \"map[my.key]\").\n\t * @param propertyPath the property path to check\n\t * @return the index of the nested property separator, or -1 if none\n\t */\n\tpublic static int getLastNestedPropertySeparatorIndex(String propertyPath) {\n\t\treturn getNestedPropertySeparatorIndex(propertyPath, true);\n\t}\n\n\t/**\n\t * Determine the first (or last) nested property separator in the\n\t * given property path, ignoring dots in keys (like \"map[my.key]\").\n\t * @param propertyPath the property path to check\n\t * @param last whether to return the last separator rather than the first\n\t * @return the index of the nested property separator, or -1 if none\n\t */\n\tprivate static int getNestedPropertySeparatorIndex(String propertyPath, boolean last) {\n\t\tboolean inKey = false;\n\t\tint length = propertyPath.length();\n\t\tint i = (last ? length - 1 : 0);\n\t\twhile (last ? i >= 0 : i < length) {\n\t\t\tswitch (propertyPath.charAt(i)) {\n\t\t\t\tcase PropertyAccessor.PROPERTY_KEY_PREFIX_CHAR, PropertyAccessor.PROPERTY_KEY_SUFFIX_CHAR -> {\n\t\t\t\t\tinKey = !inKey;\n\t\t\t\t}\n\t\t\t\tcase PropertyAccessor.NESTED_PROPERTY_SEPARATOR_CHAR -> {\n\t\t\t\t\tif (!inKey) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (last) {\n\t\t\t\ti--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Determine whether the given registered path matches the given property path,\n\t * either indicating the property itself or an indexed element of the property.\n\t * @param propertyPath the property path (typically without index)\n\t * @param registeredPath the registered path (potentially with index)\n\t * @return whether the paths match\n\t */\n\tpublic static boolean matchesProperty(String registeredPath, String propertyPath) {\n\t\tif (!registeredPath.startsWith(propertyPath)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (registeredPath.length() == propertyPath.length()) {\n\t\t\treturn true;\n\t\t}\n\t\tif (registeredPath.charAt(propertyPath.length()) != PropertyAccessor.PROPERTY_KEY_PREFIX_CHAR) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (registeredPath.indexOf(PropertyAccessor.PROPERTY_KEY_SUFFIX_CHAR, propertyPath.length() + 1) ==\n\t\t\t\tregisteredPath.length() - 1);\n\t}\n\n\t/**\n\t * Determine the canonical name for the given property path.\n\t * Removes surrounding quotes from map keys:<br>\n\t * {@code map['key']} &rarr; {@code map[key]}<br>\n\t * {@code map[\"key\"]} &rarr; {@code map[key]}\n\t * @param propertyName the bean property path\n\t * @return the canonical representation of the property path\n\t */\n\tpublic static String canonicalPropertyName(@Nullable String propertyName) {\n\t\tif (propertyName == null) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder(propertyName);\n\t\tint searchIndex = 0;\n\t\twhile (searchIndex != -1) {\n\t\t\tint keyStart = sb.indexOf(PropertyAccessor.PROPERTY_KEY_PREFIX, searchIndex);\n\t\t\tsearchIndex = -1;\n\t\t\tif (keyStart != -1) {\n\t\t\t\tint keyEnd = sb.indexOf(\n\t\t\t\t\t\tPropertyAccessor.PROPERTY_KEY_SUFFIX, keyStart + PropertyAccessor.PROPERTY_KEY_PREFIX.length());\n\t\t\t\tif (keyEnd != -1) {\n\t\t\t\t\tString key = sb.substring(keyStart + PropertyAccessor.PROPERTY_KEY_PREFIX.length(), keyEnd);\n\t\t\t\t\tif ((key.startsWith(\"'\") && key.endsWith(\"'\")) || (key.startsWith(\"\\\"\") && key.endsWith(\"\\\"\"))) {\n\t\t\t\t\t\tsb.delete(keyStart + 1, keyStart + 2);\n\t\t\t\t\t\tsb.delete(keyEnd - 2, keyEnd - 1);\n\t\t\t\t\t\tkeyEnd = keyEnd - 2;\n\t\t\t\t\t}\n\t\t\t\t\tsearchIndex = keyEnd + PropertyAccessor.PROPERTY_KEY_SUFFIX.length();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\t/**\n\t * Determine the canonical names for the given property paths.\n\t * @param propertyNames the bean property paths (as array)\n\t * @return the canonical representation of the property paths\n\t * (as array of the same size)\n\t * @see #canonicalPropertyName(String)\n\t */\n\t@Nullable\n\tpublic static String[] canonicalPropertyNames(@Nullable String[] propertyNames) {\n\t\tif (propertyNames == null) {\n\t\t\treturn null;\n\t\t}\n\t\tString[] result = new String[propertyNames.length];\n\t\tfor (int i = 0; i < propertyNames.length; i++) {\n\t\t\tresult[i] = canonicalPropertyName(propertyNames[i]);\n\t\t}\n\t\treturn result;\n\t}\n\n}"
  },
  "org.springframework.beans.PropertyAccessorUtils#canonicalPropertyName(propertyName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the canonical name for the given property path.\n\t * Removes surrounding quotes from map keys:<br>\n\t * {@code map['key']} &rarr; {@code map[key]}<br>\n\t * {@code map[\"key\"]} &rarr; {@code map[key]}\n\t * @param propertyName the bean property path\n\t * @return the canonical representation of the property path\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "String",
    "signature": "public String canonicalPropertyName(@Nullable String propertyName)",
    "source_code": "\tpublic static String canonicalPropertyName(@Nullable String propertyName) {\n\t\tif (propertyName == null) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder(propertyName);\n\t\tint searchIndex = 0;\n\t\twhile (searchIndex != -1) {\n\t\t\tint keyStart = sb.indexOf(PropertyAccessor.PROPERTY_KEY_PREFIX, searchIndex);\n\t\t\tsearchIndex = -1;\n\t\t\tif (keyStart != -1) {\n\t\t\t\tint keyEnd = sb.indexOf(\n\t\t\t\t\t\tPropertyAccessor.PROPERTY_KEY_SUFFIX, keyStart + PropertyAccessor.PROPERTY_KEY_PREFIX.length());\n\t\t\t\tif (keyEnd != -1) {\n\t\t\t\t\tString key = sb.substring(keyStart + PropertyAccessor.PROPERTY_KEY_PREFIX.length(), keyEnd);\n\t\t\t\t\tif ((key.startsWith(\"'\") && key.endsWith(\"'\")) || (key.startsWith(\"\\\"\") && key.endsWith(\"\\\"\"))) {\n\t\t\t\t\t\tsb.delete(keyStart + 1, keyStart + 2);\n\t\t\t\t\t\tsb.delete(keyEnd - 2, keyEnd - 1);\n\t\t\t\t\t\tkeyEnd = keyEnd - 2;\n\t\t\t\t\t}\n\t\t\t\t\tsearchIndex = keyEnd + PropertyAccessor.PROPERTY_KEY_SUFFIX.length();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.beans.PropertyAccessorUtils#canonicalPropertyNames(propertyNames)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the canonical names for the given property paths.\n\t * @param propertyNames the bean property paths (as array)\n\t * @return the canonical representation of the property paths\n\t * (as array of the same size)\n\t * @see #canonicalPropertyName(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyNames"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "String[]",
    "signature": "public String[] canonicalPropertyNames(@Nullable String[] propertyNames)",
    "source_code": "\tpublic static String[] canonicalPropertyNames(@Nullable String[] propertyNames) {\n\t\tif (propertyNames == null) {\n\t\t\treturn null;\n\t\t}\n\t\tString[] result = new String[propertyNames.length];\n\t\tfor (int i = 0; i < propertyNames.length; i++) {\n\t\t\tresult[i] = canonicalPropertyName(propertyNames[i]);\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.PropertyAccessorUtils#getFirstNestedPropertySeparatorIndex(propertyPath)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the first nested property separator in the\n\t * given property path, ignoring dots in keys (like \"map[my.key]\").\n\t * @param propertyPath the property path to check\n\t * @return the index of the nested property separator, or -1 if none\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyPath"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "int",
    "signature": "public int getFirstNestedPropertySeparatorIndex(String propertyPath)",
    "source_code": "\tpublic static int getFirstNestedPropertySeparatorIndex(String propertyPath) {\n\t\treturn getNestedPropertySeparatorIndex(propertyPath, false);\n\t}"
  },
  "org.springframework.beans.PropertyAccessorUtils#getLastNestedPropertySeparatorIndex(propertyPath)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the first nested property separator in the\n\t * given property path, ignoring dots in keys (like \"map[my.key]\").\n\t * @param propertyPath the property path to check\n\t * @return the index of the nested property separator, or -1 if none\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyPath"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "int",
    "signature": "public int getLastNestedPropertySeparatorIndex(String propertyPath)",
    "source_code": "\tpublic static int getLastNestedPropertySeparatorIndex(String propertyPath) {\n\t\treturn getNestedPropertySeparatorIndex(propertyPath, true);\n\t}"
  },
  "org.springframework.beans.PropertyAccessorUtils#getPropertyName(propertyPath)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the actual property name for the given property path.\n\t * @param propertyPath the property path to determine the property name\n\t * for (can include property keys, for example for specifying a map entry)\n\t * @return the actual property name, without any key elements\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyPath"
    ],
    "position": {
      "column": 1,
      "line": 36
    },
    "return": "String",
    "signature": "public String getPropertyName(String propertyPath)",
    "source_code": "\tpublic static String getPropertyName(String propertyPath) {\n\t\tint separatorIndex = (propertyPath.endsWith(PropertyAccessor.PROPERTY_KEY_SUFFIX) ?\n\t\t\t\tpropertyPath.indexOf(PropertyAccessor.PROPERTY_KEY_PREFIX_CHAR) : -1);\n\t\treturn (separatorIndex != -1 ? propertyPath.substring(0, separatorIndex) : propertyPath);\n\t}"
  },
  "org.springframework.beans.PropertyAccessorUtils#isNestedOrIndexedProperty(propertyPath)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given property path indicates an indexed or nested property.\n\t * @param propertyPath the property path to check\n\t * @return whether the path indicates an indexed or nested property\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyPath"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "return": "boolean",
    "signature": "public boolean isNestedOrIndexedProperty(@Nullable String propertyPath)",
    "source_code": "\tpublic static boolean isNestedOrIndexedProperty(@Nullable String propertyPath) {\n\t\tif (propertyPath == null) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < propertyPath.length(); i++) {\n\t\t\tchar ch = propertyPath.charAt(i);\n\t\t\tif (ch == PropertyAccessor.NESTED_PROPERTY_SEPARATOR_CHAR ||\n\t\t\t\t\tch == PropertyAccessor.PROPERTY_KEY_PREFIX_CHAR) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.beans.PropertyAccessorUtils#matchesProperty(registeredPath,propertyPath)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given registered path matches the given property path,\n\t * either indicating the property itself or an indexed element of the property.\n\t * @param propertyPath the property path (typically without index)\n\t * @param registeredPath the registered path (potentially with index)\n\t * @return whether the paths match\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredPath",
      "propertyPath"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "boolean",
    "signature": "public boolean matchesProperty(String registeredPath, String propertyPath)",
    "source_code": "\tpublic static boolean matchesProperty(String registeredPath, String propertyPath) {\n\t\tif (!registeredPath.startsWith(propertyPath)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (registeredPath.length() == propertyPath.length()) {\n\t\t\treturn true;\n\t\t}\n\t\tif (registeredPath.charAt(propertyPath.length()) != PropertyAccessor.PROPERTY_KEY_PREFIX_CHAR) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (registeredPath.indexOf(PropertyAccessor.PROPERTY_KEY_SUFFIX_CHAR, propertyPath.length() + 1) ==\n\t\t\t\tregisteredPath.length() - 1);\n\t}"
  },
  "org.springframework.beans.factory.DefaultListableBeanFactoryBenchmark": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Benchmark for retrieving various bean types from the {@link DefaultListableBeanFactory}.\n *\n * @author Brian Clozel\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 40
    },
    "signature": "public class DefaultListableBeanFactoryBenchmark",
    "source_code": "public class DefaultListableBeanFactoryBenchmark {\n\n\tpublic static class Shared {\n\t\tpublic DefaultListableBeanFactory beanFactory;\n\t}\n\n\t@State(Scope.Benchmark)\n\tpublic static class PrototypeCreationState extends Shared {\n\n\t\t@Param({\"simple\", \"dependencyCheck\", \"constructor\", \"constructorArgument\", \"properties\", \"resolvedProperties\"})\n\t\tpublic String mode;\n\n\t\t@Setup\n\t\tpublic void setup() {\n\t\t\tthis.beanFactory = new DefaultListableBeanFactory();\n\t\t\tRootBeanDefinition rbd = new RootBeanDefinition(TestBean.class);\n\n\t\t\tswitch (this.mode) {\n\t\t\t\tcase \"simple\" -> {\n\t\t\t\t}\n\t\t\t\tcase \"dependencyCheck\" -> {\n\t\t\t\t\trbd = new RootBeanDefinition(LifecycleBean.class);\n\t\t\t\t\trbd.setDependencyCheck(RootBeanDefinition.DEPENDENCY_CHECK_OBJECTS);\n\t\t\t\t\tthis.beanFactory.addBeanPostProcessor(new LifecycleBean.PostProcessor());\n\t\t\t\t}\n\t\t\t\tcase \"constructor\" -> {\n\t\t\t\t\trbd.getConstructorArgumentValues().addGenericArgumentValue(\"juergen\");\n\t\t\t\t\trbd.getConstructorArgumentValues().addGenericArgumentValue(\"99\");\n\t\t\t\t}\n\t\t\t\tcase \"constructorArgument\" -> {\n\t\t\t\t\trbd.getConstructorArgumentValues().addGenericArgumentValue(new RuntimeBeanReference(\"spouse\"));\n\t\t\t\t\tthis.beanFactory.registerBeanDefinition(\"test\", rbd);\n\t\t\t\t\tthis.beanFactory.registerBeanDefinition(\"spouse\", new RootBeanDefinition(TestBean.class));\n\t\t\t\t}\n\t\t\t\tcase \"properties\" -> {\n\t\t\t\t\trbd.getPropertyValues().add(\"name\", \"juergen\");\n\t\t\t\t\trbd.getPropertyValues().add(\"age\", \"99\");\n\t\t\t\t}\n\t\t\t\tcase \"resolvedProperties\" -> {\n\t\t\t\t\trbd.getPropertyValues().add(\"spouse\", new RuntimeBeanReference(\"spouse\"));\n\t\t\t\t\tthis.beanFactory.registerBeanDefinition(\"spouse\", new RootBeanDefinition(TestBean.class));\n\t\t\t\t}\n\t\t\t}\n\t\t\trbd.setScope(BeanDefinition.SCOPE_PROTOTYPE);\n\t\t\tthis.beanFactory.registerBeanDefinition(\"test\", rbd);\n\t\t\tthis.beanFactory.freezeConfiguration();\n\t\t}\n\n\t}\n\n\t@Benchmark\n\tpublic Object prototypeCreation(PrototypeCreationState state) {\n\t\treturn state.beanFactory.getBean(\"test\");\n\t}\n\n\t@State(Scope.Benchmark)\n\tpublic static class SingletonLookupState extends Shared {\n\n\t\t@Setup\n\t\tpublic void setup() {\n\t\t\tthis.beanFactory = new DefaultListableBeanFactory();\n\t\t\tthis.beanFactory.registerBeanDefinition(\"test\", new RootBeanDefinition(TestBean.class));\n\t\t\tthis.beanFactory.freezeConfiguration();\n\t\t}\n\t}\n\n\t@Benchmark\n\tpublic Object singletLookup(SingletonLookupState state) {\n\t\treturn state.beanFactory.getBean(\"test\");\n\t}\n\n\t@Benchmark\n\tpublic Object singletLookupByType(SingletonLookupState state) {\n\t\treturn state.beanFactory.getBean(TestBean.class);\n\t}\n\n\t@State(Scope.Benchmark)\n\tpublic static class SingletonLookupManyBeansState extends Shared {\n\n\t\t@Setup\n\t\tpublic void setup() {\n\t\t\tthis.beanFactory = new DefaultListableBeanFactory();\n\t\t\tthis.beanFactory.registerBeanDefinition(\"test\", new RootBeanDefinition(TestBean.class));\n\t\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\t\tthis.beanFactory.registerBeanDefinition(\"a\" + i, new RootBeanDefinition(A.class));\n\t\t\t}\n\t\t\tthis.beanFactory.freezeConfiguration();\n\t\t}\n\t}\n\n\t// See SPR-6870\n\t@Benchmark\n\tpublic Object singletLookupByTypeManyBeans(SingletonLookupState state) {\n\t\treturn state.beanFactory.getBean(B.class);\n\t}\n\n\tstatic class A {\n\t}\n\n\tstatic class B {\n\t}\n\n}"
  },
  "org.springframework.beans.factory.DefaultListableBeanFactoryBenchmark#prototypeCreation(state)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "state"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "Object",
    "signature": "public Object prototypeCreation(PrototypeCreationState state)",
    "source_code": "\tpublic Object prototypeCreation(PrototypeCreationState state) {\n\t\treturn state.beanFactory.getBean(\"test\");\n\t}"
  },
  "org.springframework.beans.factory.DefaultListableBeanFactoryBenchmark#setup()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "void",
    "signature": "public void setup()",
    "source_code": "\t\tpublic void setup() {\n\t\t\tthis.beanFactory = new DefaultListableBeanFactory();\n\t\t\tthis.beanFactory.registerBeanDefinition(\"test\", new RootBeanDefinition(TestBean.class));\n\t\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\t\tthis.beanFactory.registerBeanDefinition(\"a\" + i, new RootBeanDefinition(A.class));\n\t\t\t}\n\t\t\tthis.beanFactory.freezeConfiguration();\n\t\t}"
  },
  "org.springframework.beans.factory.DefaultListableBeanFactoryBenchmark#singletLookup(state)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "state"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "Object",
    "signature": "public Object singletLookup(SingletonLookupState state)",
    "source_code": "\tpublic Object singletLookup(SingletonLookupState state) {\n\t\treturn state.beanFactory.getBean(\"test\");\n\t}"
  },
  "org.springframework.beans.factory.DefaultListableBeanFactoryBenchmark#singletLookupByType(state)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "state"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "Object",
    "signature": "public Object singletLookupByType(SingletonLookupState state)",
    "source_code": "\tpublic Object singletLookupByType(SingletonLookupState state) {\n\t\treturn state.beanFactory.getBean(TestBean.class);\n\t}"
  },
  "org.springframework.beans.factory.DefaultListableBeanFactoryBenchmark#singletLookupByTypeManyBeans(state)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "state"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "Object",
    "signature": "public Object singletLookupByTypeManyBeans(SingletonLookupState state)",
    "source_code": "\tpublic Object singletLookupByTypeManyBeans(SingletonLookupState state) {\n\t\treturn state.beanFactory.getBean(B.class);\n\t}"
  },
  "org.springframework.beans.factory.PrototypeCreationState": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "signature": "public class PrototypeCreationState",
    "source_code": "\tpublic static class PrototypeCreationState extends Shared {\n\n\t\t@Param({\"simple\", \"dependencyCheck\", \"constructor\", \"constructorArgument\", \"properties\", \"resolvedProperties\"})\n\t\tpublic String mode;\n\n\t\t@Setup\n\t\tpublic void setup() {\n\t\t\tthis.beanFactory = new DefaultListableBeanFactory();\n\t\t\tRootBeanDefinition rbd = new RootBeanDefinition(TestBean.class);\n\n\t\t\tswitch (this.mode) {\n\t\t\t\tcase \"simple\" -> {\n\t\t\t\t}\n\t\t\t\tcase \"dependencyCheck\" -> {\n\t\t\t\t\trbd = new RootBeanDefinition(LifecycleBean.class);\n\t\t\t\t\trbd.setDependencyCheck(RootBeanDefinition.DEPENDENCY_CHECK_OBJECTS);\n\t\t\t\t\tthis.beanFactory.addBeanPostProcessor(new LifecycleBean.PostProcessor());\n\t\t\t\t}\n\t\t\t\tcase \"constructor\" -> {\n\t\t\t\t\trbd.getConstructorArgumentValues().addGenericArgumentValue(\"juergen\");\n\t\t\t\t\trbd.getConstructorArgumentValues().addGenericArgumentValue(\"99\");\n\t\t\t\t}\n\t\t\t\tcase \"constructorArgument\" -> {\n\t\t\t\t\trbd.getConstructorArgumentValues().addGenericArgumentValue(new RuntimeBeanReference(\"spouse\"));\n\t\t\t\t\tthis.beanFactory.registerBeanDefinition(\"test\", rbd);\n\t\t\t\t\tthis.beanFactory.registerBeanDefinition(\"spouse\", new RootBeanDefinition(TestBean.class));\n\t\t\t\t}\n\t\t\t\tcase \"properties\" -> {\n\t\t\t\t\trbd.getPropertyValues().add(\"name\", \"juergen\");\n\t\t\t\t\trbd.getPropertyValues().add(\"age\", \"99\");\n\t\t\t\t}\n\t\t\t\tcase \"resolvedProperties\" -> {\n\t\t\t\t\trbd.getPropertyValues().add(\"spouse\", new RuntimeBeanReference(\"spouse\"));\n\t\t\t\t\tthis.beanFactory.registerBeanDefinition(\"spouse\", new RootBeanDefinition(TestBean.class));\n\t\t\t\t}\n\t\t\t}\n\t\t\trbd.setScope(BeanDefinition.SCOPE_PROTOTYPE);\n\t\t\tthis.beanFactory.registerBeanDefinition(\"test\", rbd);\n\t\t\tthis.beanFactory.freezeConfiguration();\n\t\t}\n\n\t}"
  },
  "org.springframework.beans.factory.Shared": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public class Shared",
    "source_code": "\tpublic static class Shared {\n\t\tpublic DefaultListableBeanFactory beanFactory;\n\t}"
  },
  "org.springframework.beans.factory.SingletonLookupManyBeansState": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "signature": "public class SingletonLookupManyBeansState",
    "source_code": "\tpublic static class SingletonLookupManyBeansState extends Shared {\n\n\t\t@Setup\n\t\tpublic void setup() {\n\t\t\tthis.beanFactory = new DefaultListableBeanFactory();\n\t\t\tthis.beanFactory.registerBeanDefinition(\"test\", new RootBeanDefinition(TestBean.class));\n\t\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\t\tthis.beanFactory.registerBeanDefinition(\"a\" + i, new RootBeanDefinition(A.class));\n\t\t\t}\n\t\t\tthis.beanFactory.freezeConfiguration();\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.SingletonLookupState": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "signature": "public class SingletonLookupState",
    "source_code": "\tpublic static class SingletonLookupState extends Shared {\n\n\t\t@Setup\n\t\tpublic void setup() {\n\t\t\tthis.beanFactory = new DefaultListableBeanFactory();\n\t\t\tthis.beanFactory.registerBeanDefinition(\"test\", new RootBeanDefinition(TestBean.class));\n\t\t\tthis.beanFactory.freezeConfiguration();\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateCode(value,type)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 550
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateCode(Object value, ResolvableType type)",
    "source_code": "\t\tpublic CodeBlock generateCode(Object value, ResolvableType type) {\n\t\t\tif (value instanceof RuntimeBeanReference runtimeBeanReference &&\n\t\t\t\t\truntimeBeanReference.getBeanType() != null) {\n\t\t\t\treturn CodeBlock.of(\"new $T($T.class)\", RuntimeBeanReference.class,\n\t\t\t\t\t\truntimeBeanReference.getBeanType());\n\t\t\t}\n\t\t\telse if (value instanceof BeanReference beanReference) {\n\t\t\t\treturn CodeBlock.of(\"new $T($S)\", RuntimeBeanReference.class,\n\t\t\t\t\t\tbeanReference.getBeanName());\n\t\t\t}\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateCode(valueCodeGenerator,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "valueCodeGenerator",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateCode(ValueCodeGenerator valueCodeGenerator, Object value)",
    "source_code": "\t\tpublic CodeBlock generateCode(ValueCodeGenerator valueCodeGenerator, Object value) {\n\t\t\tif (value instanceof TypedStringValue typedStringValue) {\n\t\t\t\treturn generateTypeStringValueCode(valueCodeGenerator, typedStringValue);\n\t\t\t}\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateCollectionCode(elementType,collection)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "elementType",
      "collection"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "CodeBlock",
    "signature": "protected CodeBlock generateCollectionCode(ResolvableType elementType, T collection)",
    "source_code": "\t\tprotected CodeBlock generateCollectionCode(ResolvableType elementType, T collection) {\n\t\t\treturn generateCollectionOf(collection, this.collectionType, elementType);\n\t\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateCollectionCode(elementType,set)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "elementType",
      "set"
    ],
    "position": {
      "column": 1,
      "line": 445
    },
    "return": "CodeBlock",
    "signature": "protected CodeBlock generateCollectionCode(ResolvableType elementType, Set<?> set)",
    "source_code": "\t\tprotected CodeBlock generateCollectionCode(ResolvableType elementType, Set<?> set) {\n\t\t\tif (set instanceof LinkedHashSet) {\n\t\t\t\treturn CodeBlock.of(\"new $T($L)\", LinkedHashSet.class,\n\t\t\t\t\t\tgenerateCollectionOf(set, List.class, elementType));\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tset = orderForCodeConsistency(set);\n\t\t\t}\n\t\t\tcatch (ClassCastException ex) {\n\t\t\t\t// If elements are not comparable, just keep the original set\n\t\t\t}\n\t\t\treturn super.generateCollectionCode(elementType, set);\n\t\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateCollectionOf(collection,collectionType,elementType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "collection",
      "collectionType",
      "elementType"
    ],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "CodeBlock",
    "signature": "protected CodeBlock generateCollectionOf(Collection<?> collection,\n\t\t\t\tClass<?> collectionType, ResolvableType elementType)",
    "source_code": "\t\tprotected final CodeBlock generateCollectionOf(Collection<?> collection,"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateInstanceSupplierCode(generationContext,beanRegistrationCode,allowDirectSupplierShortcut)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "allowDirectSupplierShortcut"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\tBeanRegistrationCode beanRegistrationCode, boolean allowDirectSupplierShortcut)",
    "source_code": "\tpublic CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateInstanceSupplierCode(generationContext,beanRegistrationCode,constructorOrFactoryMethod,allowDirectSupplierShortcut)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "constructorOrFactoryMethod",
      "allowDirectSupplierShortcut"
    ],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\tBeanRegistrationCode beanRegistrationCode,\n\t\t\tExecutable constructorOrFactoryMethod, boolean allowDirectSupplierShortcut)",
    "source_code": "\tpublic CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateMapCode(valueCodeGenerator,Map<?,map)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "valueCodeGenerator",
      "Map<?",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "CodeBlock",
    "signature": "protected CodeBlock generateMapCode(ValueCodeGenerator valueCodeGenerator, Map<?, ?> map)",
    "source_code": "\t\tprotected CodeBlock generateMapCode(ValueCodeGenerator valueCodeGenerator, Map<?, ?> map) {\n\t\t\tGeneratedMethods generatedMethods = valueCodeGenerator.getGeneratedMethods();\n\t\t\tif (map instanceof LinkedHashMap<?, ?> && generatedMethods != null) {\n\t\t\t\treturn generateLinkedHashMapCode(valueCodeGenerator, generatedMethods, map);\n\t\t\t}\n\t\t\treturn super.generateMapCode(valueCodeGenerator, map);\n\t\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#getTarget(registeredBean)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "ClassName",
    "signature": "public ClassName getTarget(RegisteredBean registeredBean)",
    "source_code": "\tpublic ClassName getTarget(RegisteredBean registeredBean) {\n\t\tif (hasInstanceSupplier()) {\n\t\t\tthrow new IllegalStateException(\"Default code generation is not supported for bean definitions \"\n\t\t\t\t\t+ \"declaring an instance supplier callback: \" + registeredBean.getMergedBeanDefinition());\n\t\t}\n\t\tClass<?> target = extractDeclaringClass(registeredBean.getBeanType(), this.constructorOrFactoryMethod.get());\n\t\twhile (target.getName().startsWith(\"java.\") && registeredBean.isInnerBean()) {\n\t\t\tRegisteredBean parent = registeredBean.getParent();\n\t\t\tAssert.state(parent != null, \"No parent available for inner bean\");\n\t\t\ttarget = parent.getBeanClass();\n\t\t}\n\t\treturn (target.isArray() ? ClassName.get(target.getComponentType()) : ClassName.get(target));\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#getTarget(registeredBean,constructorOrFactoryMethod)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean",
      "constructorOrFactoryMethod"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "ClassName",
    "signature": "public ClassName getTarget(RegisteredBean registeredBean,\n\t\t\tExecutable constructorOrFactoryMethod)",
    "source_code": "\tpublic ClassName getTarget(RegisteredBean registeredBean,"
  },
  "org.springframework.beans.factory.aot.<unknown>#registerRuntimeHints(runtimeHints,constructor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runtimeHints",
      "constructor"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "void",
    "signature": "public void registerRuntimeHints(RuntimeHints runtimeHints, Constructor<?> constructor)",
    "source_code": "\t\tpublic void registerRuntimeHints(RuntimeHints runtimeHints, Constructor<?> constructor) {\n\t\t\tClass<?>[] parameterTypes = constructor.getParameterTypes();\n\t\t\tfor (int i = 0; i < parameterTypes.length; i++) {\n\t\t\t\tMethodParameter methodParam = new MethodParameter(constructor, i);\n\t\t\t\tDependencyDescriptor dependencyDescriptor = new DependencyDescriptor(\n\t\t\t\t\t\tmethodParam, true);\n\t\t\t\tregisterProxyIfNecessary(runtimeHints, dependencyDescriptor);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#registerRuntimeHints(runtimeHints,method)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runtimeHints",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "void",
    "signature": "public void registerRuntimeHints(RuntimeHints runtimeHints, Method method)",
    "source_code": "\t\tpublic void registerRuntimeHints(RuntimeHints runtimeHints, Method method) {\n\t\t\tClass<?>[] parameterTypes = method.getParameterTypes();\n\t\t\tfor (int i = 0; i < parameterTypes.length; i++) {\n\t\t\t\tMethodParameter methodParam = new MethodParameter(method, i);\n\t\t\t\tDependencyDescriptor dependencyDescriptor = new DependencyDescriptor(methodParam, true);\n\t\t\t\tregisterProxyIfNecessary(runtimeHints, dependencyDescriptor);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.aot.INSTANCES": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link Delegate} implementations for common bean definition\n\t * property value types. These are:\n\t * <ul>\n\t * <li>{@link ManagedList},</li>\n\t * <li>{@link ManagedSet},</li>\n\t * <li>{@link ManagedMap},</li>\n\t * <li>{@link LinkedHashMap},</li>\n\t * <li>{@link BeanReference},</li>\n\t * <li>{@link TypedStringValue}.</li>\n\t * </ul>\n\t * When combined with {@linkplain ValueCodeGeneratorDelegates#INSTANCES the\n\t * delegates for common value types}, this should be added first as they have\n\t * special handling for list, set, and map.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "signature": "public List<Delegate> INSTANCES",
    "source_code": "\tpublic static final List<Delegate> INSTANCES = List.of(",
    "type": "List<Delegate>"
  },
  "org.springframework.beans.factory.aot.InstanceSupplierCodeGenerator": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Default code generator to create an {@link InstanceSupplier}, usually in\n * the form of a {@link BeanInstanceSupplier} that retains the executable\n * that is used to instantiate the bean. Takes care of registering the\n * necessary hints if reflection or a JDK proxy is required.\n *\n * <p>Generated code is usually a method reference that generates the\n * {@link BeanInstanceSupplier}, but some shortcut can be used as well such as:\n * <pre class=\"code\">\n * {@code InstanceSupplier.of(TheGeneratedClass::getMyBeanInstance);}\n * </pre>\n *\n * @author Phillip Webb\n * @author Stephane Nicoll\n * @author Juergen Hoeller\n * @author Sebastien Deleuze\n * @since 6.0\n * @see BeanRegistrationCodeFragments\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "signature": "public class InstanceSupplierCodeGenerator",
    "source_code": "public class InstanceSupplierCodeGenerator {\n\n\tprivate static final String REGISTERED_BEAN_PARAMETER_NAME = \"registeredBean\";\n\n\tprivate static final String ARGS_PARAMETER_NAME = \"args\";\n\n\tprivate static final javax.lang.model.element.Modifier[] PRIVATE_STATIC = {\n\t\t\tjavax.lang.model.element.Modifier.PRIVATE,\n\t\t\tjavax.lang.model.element.Modifier.STATIC };\n\n\tprivate static final CodeBlock NO_ARGS = CodeBlock.of(\"\");\n\n\n\tprivate final GenerationContext generationContext;\n\n\tprivate final ClassName className;\n\n\tprivate final GeneratedMethods generatedMethods;\n\n\tprivate final boolean allowDirectSupplierShortcut;\n\n\n\t/**\n\t * Create a new instance.\n\t * @param generationContext the generation context\n\t * @param className the class name of the bean to instantiate\n\t * @param generatedMethods the generated methods\n\t * @param allowDirectSupplierShortcut whether a direct supplier may be used rather\n\t * than always needing an {@link InstanceSupplier}\n\t */\n\tpublic InstanceSupplierCodeGenerator(GenerationContext generationContext,\n\t\t\tClassName className, GeneratedMethods generatedMethods, boolean allowDirectSupplierShortcut) {\n\n\t\tthis.generationContext = generationContext;\n\t\tthis.className = className;\n\t\tthis.generatedMethods = generatedMethods;\n\t\tthis.allowDirectSupplierShortcut = allowDirectSupplierShortcut;\n\t}\n\n\t/**\n\t * Generate the instance supplier code.\n\t * @param registeredBean the bean to handle\n\t * @param constructorOrFactoryMethod the executable to use to create the bean\n\t * @return the generated code\n\t */\n\tpublic CodeBlock generateCode(RegisteredBean registeredBean, Executable constructorOrFactoryMethod) {\n\t\tregisterRuntimeHintsIfNecessary(registeredBean, constructorOrFactoryMethod);\n\t\tif (constructorOrFactoryMethod instanceof Constructor<?> constructor) {\n\t\t\treturn generateCodeForConstructor(registeredBean, constructor);\n\t\t}\n\t\tif (constructorOrFactoryMethod instanceof Method method) {\n\t\t\treturn generateCodeForFactoryMethod(registeredBean, method);\n\t\t}\n\t\tthrow new IllegalStateException(\n\t\t\t\t\"No suitable executor found for \" + registeredBean.getBeanName());\n\t}\n\n\tprivate void registerRuntimeHintsIfNecessary(RegisteredBean registeredBean, Executable constructorOrFactoryMethod) {\n\t\tif (registeredBean.getBeanFactory() instanceof DefaultListableBeanFactory dlbf) {\n\t\t\tRuntimeHints runtimeHints = this.generationContext.getRuntimeHints();\n\t\t\tProxyRuntimeHintsRegistrar registrar = new ProxyRuntimeHintsRegistrar(dlbf.getAutowireCandidateResolver());\n\t\t\tif (constructorOrFactoryMethod instanceof Method method) {\n\t\t\t\tregistrar.registerRuntimeHints(runtimeHints, method);\n\t\t\t}\n\t\t\telse if (constructorOrFactoryMethod instanceof Constructor<?> constructor) {\n\t\t\t\tregistrar.registerRuntimeHints(runtimeHints, constructor);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate CodeBlock generateCodeForConstructor(RegisteredBean registeredBean, Constructor<?> constructor) {\n\t\tString beanName = registeredBean.getBeanName();\n\t\tClass<?> beanClass = registeredBean.getBeanClass();\n\t\tClass<?> declaringClass = constructor.getDeclaringClass();\n\t\tboolean dependsOnBean = ClassUtils.isInnerClass(declaringClass);\n\n\t\tVisibility accessVisibility = getAccessVisibility(registeredBean, constructor);\n\t\tif (KotlinDetector.isKotlinReflectPresent() && KotlinDelegate.hasConstructorWithOptionalParameter(beanClass)) {\n\t\t\treturn generateCodeForInaccessibleConstructor(beanName, beanClass, constructor,\n\t\t\t\t\tdependsOnBean, hints -> hints.registerType(beanClass, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS));\n\t\t}\n\t\telse if (accessVisibility != Visibility.PRIVATE) {\n\t\t\treturn generateCodeForAccessibleConstructor(beanName, beanClass, constructor,\n\t\t\t\t\tdependsOnBean, declaringClass);\n\t\t}\n\t\treturn generateCodeForInaccessibleConstructor(beanName, beanClass, constructor, dependsOnBean,\n\t\t\t\thints -> hints.registerConstructor(constructor, ExecutableMode.INVOKE));\n\t}\n\n\tprivate CodeBlock generateCodeForAccessibleConstructor(String beanName, Class<?> beanClass,\n\t\t\tConstructor<?> constructor, boolean dependsOnBean, Class<?> declaringClass) {\n\n\t\tthis.generationContext.getRuntimeHints().reflection().registerConstructor(\n\t\t\t\tconstructor, ExecutableMode.INTROSPECT);\n\n\t\tif (!dependsOnBean && constructor.getParameterCount() == 0) {\n\t\t\tif (!this.allowDirectSupplierShortcut) {\n\t\t\t\treturn CodeBlock.of(\"$T.using($T::new)\", InstanceSupplier.class, declaringClass);\n\t\t\t}\n\t\t\tif (!isThrowingCheckedException(constructor)) {\n\t\t\t\treturn CodeBlock.of(\"$T::new\", declaringClass);\n\t\t\t}\n\t\t\treturn CodeBlock.of(\"$T.of($T::new)\", ThrowingSupplier.class, declaringClass);\n\t\t}\n\n\t\tGeneratedMethod generatedMethod = generateGetInstanceSupplierMethod(method ->\n\t\t\t\tbuildGetInstanceMethodForConstructor(method, beanName, beanClass, constructor,\n\t\t\t\t\t\tdeclaringClass, dependsOnBean, PRIVATE_STATIC));\n\t\treturn generateReturnStatement(generatedMethod);\n\t}\n\n\tprivate CodeBlock generateCodeForInaccessibleConstructor(String beanName, Class<?> beanClass,\n\t\t\tConstructor<?> constructor, boolean dependsOnBean, Consumer<ReflectionHints> hints) {\n\n\t\tCodeWarnings codeWarnings = new CodeWarnings();\n\t\tcodeWarnings.detectDeprecation(beanClass, constructor)\n\t\t\t\t.detectDeprecation(Arrays.stream(constructor.getParameters()).map(Parameter::getType));\n\t\thints.accept(this.generationContext.getRuntimeHints().reflection());\n\n\t\tGeneratedMethod generatedMethod = generateGetInstanceSupplierMethod(method -> {\n\t\t\tmethod.addJavadoc(\"Get the bean instance supplier for '$L'.\", beanName);\n\t\t\tmethod.addModifiers(PRIVATE_STATIC);\n\t\t\tcodeWarnings.suppress(method);\n\t\t\tmethod.returns(ParameterizedTypeName.get(BeanInstanceSupplier.class, beanClass));\n\t\t\tint parameterOffset = (!dependsOnBean) ? 0 : 1;\n\t\t\tmethod.addStatement(generateResolverForConstructor(beanClass, constructor, parameterOffset));\n\t\t});\n\n\t\treturn generateReturnStatement(generatedMethod);\n\t}\n\n\tprivate void buildGetInstanceMethodForConstructor(MethodSpec.Builder method,\n\t\t\tString beanName, Class<?> beanClass, Constructor<?> constructor, Class<?> declaringClass,\n\t\t\tboolean dependsOnBean, javax.lang.model.element.Modifier... modifiers) {\n\n\t\tCodeWarnings codeWarnings = new CodeWarnings();\n\t\tcodeWarnings.detectDeprecation(beanClass, constructor, declaringClass)\n\t\t\t\t.detectDeprecation(Arrays.stream(constructor.getParameters()).map(Parameter::getType));\n\t\tmethod.addJavadoc(\"Get the bean instance supplier for '$L'.\", beanName);\n\t\tmethod.addModifiers(modifiers);\n\t\tcodeWarnings.suppress(method);\n\t\tmethod.returns(ParameterizedTypeName.get(BeanInstanceSupplier.class, beanClass));\n\n\t\tint parameterOffset = (!dependsOnBean) ? 0 : 1;\n\t\tCodeBlock.Builder code = CodeBlock.builder();\n\t\tcode.add(generateResolverForConstructor(beanClass, constructor, parameterOffset));\n\t\tboolean hasArguments = constructor.getParameterCount() > 0;\n\n\t\tCodeBlock arguments = hasArguments ?\n\t\t\t\tnew AutowiredArgumentsCodeGenerator(declaringClass, constructor)\n\t\t\t\t\t\t.generateCode(constructor.getParameterTypes(), parameterOffset)\n\t\t\t\t: NO_ARGS;\n\n\t\tCodeBlock newInstance = generateNewInstanceCodeForConstructor(dependsOnBean, declaringClass, arguments);\n\t\tcode.add(generateWithGeneratorCode(hasArguments, newInstance));\n\t\tmethod.addStatement(code.build());\n\t}\n\n\tprivate CodeBlock generateResolverForConstructor(Class<?> beanClass,\n\t\t\tConstructor<?> constructor, int parameterOffset) {\n\n\t\tCodeBlock parameterTypes = generateParameterTypesCode(constructor.getParameterTypes(), parameterOffset);\n\t\treturn CodeBlock.of(\"return $T.<$T>forConstructor($L)\", BeanInstanceSupplier.class, beanClass, parameterTypes);\n\t}\n\n\tprivate CodeBlock generateNewInstanceCodeForConstructor(boolean dependsOnBean,\n\t\t\tClass<?> declaringClass, CodeBlock args) {\n\n\t\tif (!dependsOnBean) {\n\t\t\treturn CodeBlock.of(\"new $T($L)\", declaringClass, args);\n\t\t}\n\n\t\treturn CodeBlock.of(\"$L.getBeanFactory().getBean($T.class).new $L($L)\",\n\t\t\t\tREGISTERED_BEAN_PARAMETER_NAME, declaringClass.getEnclosingClass(),\n\t\t\t\tdeclaringClass.getSimpleName(), args);\n\t}\n\n\tprivate CodeBlock generateCodeForFactoryMethod(RegisteredBean registeredBean, Method factoryMethod) {\n\t\tString beanName = registeredBean.getBeanName();\n\t\tClass<?> declaringClass = ClassUtils.getUserClass(factoryMethod.getDeclaringClass());\n\t\tboolean dependsOnBean = !Modifier.isStatic(factoryMethod.getModifiers());\n\n\t\tVisibility accessVisibility = getAccessVisibility(registeredBean, factoryMethod);\n\t\tif (accessVisibility != Visibility.PRIVATE) {\n\t\t\treturn generateCodeForAccessibleFactoryMethod(\n\t\t\t\t\tbeanName, factoryMethod, declaringClass, dependsOnBean);\n\t\t}\n\t\treturn generateCodeForInaccessibleFactoryMethod(beanName, factoryMethod, declaringClass);\n\t}\n\n\tprivate CodeBlock generateCodeForAccessibleFactoryMethod(String beanName,\n\t\t\tMethod factoryMethod, Class<?> declaringClass, boolean dependsOnBean) {\n\n\t\tthis.generationContext.getRuntimeHints().reflection().registerMethod(\n\t\t\t\tfactoryMethod, ExecutableMode.INTROSPECT);\n\n\t\tif (!dependsOnBean && factoryMethod.getParameterCount() == 0) {\n\t\t\tClass<?> suppliedType = ClassUtils.resolvePrimitiveIfNecessary(factoryMethod.getReturnType());\n\t\t\tCodeBlock.Builder code = CodeBlock.builder();\n\t\t\tcode.add(\"$T.<$T>forFactoryMethod($T.class, $S)\", BeanInstanceSupplier.class,\n\t\t\t\t\tsuppliedType, declaringClass, factoryMethod.getName());\n\t\t\tcode.add(\".withGenerator(($L) -> $T.$L())\", REGISTERED_BEAN_PARAMETER_NAME,\n\t\t\t\t\tdeclaringClass, factoryMethod.getName());\n\t\t\treturn code.build();\n\t\t}\n\n\t\tGeneratedMethod getInstanceMethod = generateGetInstanceSupplierMethod(method ->\n\t\t\t\tbuildGetInstanceMethodForFactoryMethod(method, beanName, factoryMethod,\n\t\t\t\t\t\tdeclaringClass, dependsOnBean, PRIVATE_STATIC));\n\t\treturn generateReturnStatement(getInstanceMethod);\n\t}\n\n\tprivate CodeBlock generateCodeForInaccessibleFactoryMethod(\n\t\t\tString beanName, Method factoryMethod, Class<?> declaringClass) {\n\n\t\tthis.generationContext.getRuntimeHints().reflection().registerMethod(factoryMethod, ExecutableMode.INVOKE);\n\t\tGeneratedMethod getInstanceMethod = generateGetInstanceSupplierMethod(method -> {\n\t\t\tClass<?> suppliedType = ClassUtils.resolvePrimitiveIfNecessary(factoryMethod.getReturnType());\n\t\t\tmethod.addJavadoc(\"Get the bean instance supplier for '$L'.\", beanName);\n\t\t\tmethod.addModifiers(PRIVATE_STATIC);\n\t\t\tmethod.returns(ParameterizedTypeName.get(BeanInstanceSupplier.class, suppliedType));\n\t\t\tmethod.addStatement(generateInstanceSupplierForFactoryMethod(\n\t\t\t\t\tfactoryMethod, suppliedType, declaringClass, factoryMethod.getName()));\n\t\t});\n\t\treturn generateReturnStatement(getInstanceMethod);\n\t}\n\n\tprivate void buildGetInstanceMethodForFactoryMethod(MethodSpec.Builder method,\n\t\t\tString beanName, Method factoryMethod, Class<?> declaringClass,\n\t\t\tboolean dependsOnBean, javax.lang.model.element.Modifier... modifiers) {\n\n\t\tString factoryMethodName = factoryMethod.getName();\n\t\tClass<?> suppliedType = ClassUtils.resolvePrimitiveIfNecessary(factoryMethod.getReturnType());\n\t\tCodeWarnings codeWarnings = new CodeWarnings();\n\t\tcodeWarnings.detectDeprecation(declaringClass, factoryMethod, suppliedType)\n\t\t\t\t.detectDeprecation(Arrays.stream(factoryMethod.getParameters()).map(Parameter::getType));\n\n\t\tmethod.addJavadoc(\"Get the bean instance supplier for '$L'.\", beanName);\n\t\tmethod.addModifiers(modifiers);\n\t\tcodeWarnings.suppress(method);\n\t\tmethod.returns(ParameterizedTypeName.get(BeanInstanceSupplier.class, suppliedType));\n\n\t\tCodeBlock.Builder code = CodeBlock.builder();\n\t\tcode.add(generateInstanceSupplierForFactoryMethod(\n\t\t\t\tfactoryMethod, suppliedType, declaringClass, factoryMethodName));\n\n\t\tboolean hasArguments = factoryMethod.getParameterCount() > 0;\n\t\tCodeBlock arguments = hasArguments ?\n\t\t\t\tnew AutowiredArgumentsCodeGenerator(declaringClass, factoryMethod)\n\t\t\t\t\t\t.generateCode(factoryMethod.getParameterTypes())\n\t\t\t\t: NO_ARGS;\n\n\t\tCodeBlock newInstance = generateNewInstanceCodeForMethod(\n\t\t\t\tdependsOnBean, declaringClass, factoryMethodName, arguments);\n\t\tcode.add(generateWithGeneratorCode(hasArguments, newInstance));\n\t\tmethod.addStatement(code.build());\n\t}\n\n\tprivate CodeBlock generateInstanceSupplierForFactoryMethod(Method factoryMethod,\n\t\t\tClass<?> suppliedType, Class<?> declaringClass, String factoryMethodName) {\n\n\t\tif (factoryMethod.getParameterCount() == 0) {\n\t\t\treturn CodeBlock.of(\"return $T.<$T>forFactoryMethod($T.class, $S)\",\n\t\t\t\t\tBeanInstanceSupplier.class, suppliedType, declaringClass, factoryMethodName);\n\t\t}\n\n\t\tCodeBlock parameterTypes = generateParameterTypesCode(factoryMethod.getParameterTypes(), 0);\n\t\treturn CodeBlock.of(\"return $T.<$T>forFactoryMethod($T.class, $S, $L)\",\n\t\t\t\tBeanInstanceSupplier.class, suppliedType, declaringClass, factoryMethodName, parameterTypes);\n\t}\n\n\tprivate CodeBlock generateNewInstanceCodeForMethod(boolean dependsOnBean,\n\t\t\tClass<?> declaringClass, String factoryMethodName, CodeBlock args) {\n\n\t\tif (!dependsOnBean) {\n\t\t\treturn CodeBlock.of(\"$T.$L($L)\", declaringClass, factoryMethodName, args);\n\t\t}\n\t\treturn CodeBlock.of(\"$L.getBeanFactory().getBean($T.class).$L($L)\",\n\t\t\t\tREGISTERED_BEAN_PARAMETER_NAME, declaringClass, factoryMethodName, args);\n\t}\n\n\tprivate CodeBlock generateReturnStatement(GeneratedMethod generatedMethod) {\n\t\treturn generatedMethod.toMethodReference().toInvokeCodeBlock(\n\t\t\t\tArgumentCodeGenerator.none(), this.className);\n\t}\n\n\tprivate CodeBlock generateWithGeneratorCode(boolean hasArguments, CodeBlock newInstance) {\n\t\tCodeBlock lambdaArguments = (hasArguments ?\n\t\t\t\tCodeBlock.of(\"($L, $L)\", REGISTERED_BEAN_PARAMETER_NAME, ARGS_PARAMETER_NAME) :\n\t\t\t\tCodeBlock.of(\"($L)\", REGISTERED_BEAN_PARAMETER_NAME));\n\t\tBuilder code = CodeBlock.builder();\n\t\tcode.add(\"\\n\");\n\t\tcode.indent().indent();\n\t\tcode.add(\".withGenerator($L -> $L)\", lambdaArguments, newInstance);\n\t\tcode.unindent().unindent();\n\t\treturn code.build();\n\t}\n\n\tprivate Visibility getAccessVisibility(RegisteredBean registeredBean, Member member) {\n\t\tAccessControl beanTypeAccessControl = AccessControl.forResolvableType(registeredBean.getBeanType());\n\t\tAccessControl memberAccessControl = AccessControl.forMember(member);\n\t\treturn AccessControl.lowest(beanTypeAccessControl, memberAccessControl).getVisibility();\n\t}\n\n\tprivate CodeBlock generateParameterTypesCode(Class<?>[] parameterTypes, int offset) {\n\t\tCodeBlock.Builder code = CodeBlock.builder();\n\t\tfor (int i = offset; i < parameterTypes.length; i++) {\n\t\t\tcode.add(i != offset ? \", \" : \"\");\n\t\t\tcode.add(\"$T.class\", parameterTypes[i]);\n\t\t}\n\t\treturn code.build();\n\t}\n\n\tprivate GeneratedMethod generateGetInstanceSupplierMethod(Consumer<MethodSpec.Builder> method) {\n\t\treturn this.generatedMethods.add(\"getInstanceSupplier\", method);\n\t}\n\n\tprivate boolean isThrowingCheckedException(Executable executable) {\n\t\treturn Arrays.stream(executable.getGenericExceptionTypes())\n\t\t\t\t.map(ResolvableType::forType).map(ResolvableType::toClass)\n\t\t\t\t.anyMatch(Exception.class::isAssignableFrom);\n\t}\n\n\t/**\n\t * Inner class to avoid a hard dependency on Kotlin at runtime.\n\t */\n\tprivate static class KotlinDelegate {\n\n\t\tpublic static boolean hasConstructorWithOptionalParameter(Class<?> beanClass) {\n\t\t\tif (KotlinDetector.isKotlinType(beanClass)) {\n\t\t\t\tKClass<?> kClass = JvmClassMappingKt.getKotlinClass(beanClass);\n\t\t\t\tfor (KFunction<?> constructor : kClass.getConstructors()) {\n\t\t\t\t\tfor (KParameter parameter : constructor.getParameters()) {\n\t\t\t\t\t\tif (parameter.isOptional()) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t}\n\n\n\tprivate static class ProxyRuntimeHintsRegistrar {\n\n\t\tprivate final AutowireCandidateResolver candidateResolver;\n\n\t\tpublic ProxyRuntimeHintsRegistrar(AutowireCandidateResolver candidateResolver) {\n\t\t\tthis.candidateResolver = candidateResolver;\n\t\t}\n\n\t\tpublic void registerRuntimeHints(RuntimeHints runtimeHints, Method method) {\n\t\t\tClass<?>[] parameterTypes = method.getParameterTypes();\n\t\t\tfor (int i = 0; i < parameterTypes.length; i++) {\n\t\t\t\tMethodParameter methodParam = new MethodParameter(method, i);\n\t\t\t\tDependencyDescriptor dependencyDescriptor = new DependencyDescriptor(methodParam, true);\n\t\t\t\tregisterProxyIfNecessary(runtimeHints, dependencyDescriptor);\n\t\t\t}\n\t\t}\n\n\t\tpublic void registerRuntimeHints(RuntimeHints runtimeHints, Constructor<?> constructor) {\n\t\t\tClass<?>[] parameterTypes = constructor.getParameterTypes();\n\t\t\tfor (int i = 0; i < parameterTypes.length; i++) {\n\t\t\t\tMethodParameter methodParam = new MethodParameter(constructor, i);\n\t\t\t\tDependencyDescriptor dependencyDescriptor = new DependencyDescriptor(\n\t\t\t\t\t\tmethodParam, true);\n\t\t\t\tregisterProxyIfNecessary(runtimeHints, dependencyDescriptor);\n\t\t\t}\n\t\t}\n\n\t\tprivate void registerProxyIfNecessary(RuntimeHints runtimeHints, DependencyDescriptor dependencyDescriptor) {\n\t\t\tClass<?> proxyType = this.candidateResolver.getLazyResolutionProxyClass(dependencyDescriptor, null);\n\t\t\tif (proxyType != null && Proxy.isProxyClass(proxyType)) {\n\t\t\t\truntimeHints.proxies().registerJdkProxy(proxyType.getInterfaces());\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.beans.factory.aot.InstanceSupplierCodeGenerator#generateCode(registeredBean,constructorOrFactoryMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate the instance supplier code.\n\t * @param registeredBean the bean to handle\n\t * @param constructorOrFactoryMethod the executable to use to create the bean\n\t * @return the generated code\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean",
      "constructorOrFactoryMethod"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateCode(RegisteredBean registeredBean, Executable constructorOrFactoryMethod)",
    "source_code": "\tpublic CodeBlock generateCode(RegisteredBean registeredBean, Executable constructorOrFactoryMethod) {\n\t\tregisterRuntimeHintsIfNecessary(registeredBean, constructorOrFactoryMethod);\n\t\tif (constructorOrFactoryMethod instanceof Constructor<?> constructor) {\n\t\t\treturn generateCodeForConstructor(registeredBean, constructor);\n\t\t}\n\t\tif (constructorOrFactoryMethod instanceof Method method) {\n\t\t\treturn generateCodeForFactoryMethod(registeredBean, method);\n\t\t}\n\t\tthrow new IllegalStateException(\n\t\t\t\t\"No suitable executor found for \" + registeredBean.getBeanName());\n\t}"
  },
  "org.springframework.beans.factory.aot.InstanceSupplierCodeGenerator#hasConstructorWithOptionalParameter(beanClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass"
    ],
    "position": {
      "column": 1,
      "line": 407
    },
    "return": "boolean",
    "signature": "public boolean hasConstructorWithOptionalParameter(Class<?> beanClass)",
    "source_code": "\t\tpublic static boolean hasConstructorWithOptionalParameter(Class<?> beanClass) {\n\t\t\tif (KotlinDetector.isKotlinType(beanClass)) {\n\t\t\t\tKClass<?> kClass = JvmClassMappingKt.getKotlinClass(beanClass);\n\t\t\t\tfor (KFunction<?> constructor : kClass.getConstructors()) {\n\t\t\t\t\tfor (KParameter parameter : constructor.getParameters()) {\n\t\t\t\t\t\tif (parameter.isOptional()) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.beans.factory.aot.InstanceSupplierCodeGenerator#registerRuntimeHints(runtimeHints,constructor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runtimeHints",
      "constructor"
    ],
    "position": {
      "column": 1,
      "line": 441
    },
    "return": "void",
    "signature": "public void registerRuntimeHints(RuntimeHints runtimeHints, Constructor<?> constructor)",
    "source_code": "\t\tpublic void registerRuntimeHints(RuntimeHints runtimeHints, Constructor<?> constructor) {\n\t\t\tClass<?>[] parameterTypes = constructor.getParameterTypes();\n\t\t\tfor (int i = 0; i < parameterTypes.length; i++) {\n\t\t\t\tMethodParameter methodParam = new MethodParameter(constructor, i);\n\t\t\t\tDependencyDescriptor dependencyDescriptor = new DependencyDescriptor(\n\t\t\t\t\t\tmethodParam, true);\n\t\t\t\tregisterProxyIfNecessary(runtimeHints, dependencyDescriptor);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.aot.InstanceSupplierCodeGenerator#registerRuntimeHints(runtimeHints,method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runtimeHints",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 432
    },
    "return": "void",
    "signature": "public void registerRuntimeHints(RuntimeHints runtimeHints, Method method)",
    "source_code": "\t\tpublic void registerRuntimeHints(RuntimeHints runtimeHints, Method method) {\n\t\t\tClass<?>[] parameterTypes = method.getParameterTypes();\n\t\t\tfor (int i = 0; i < parameterTypes.length; i++) {\n\t\t\t\tMethodParameter methodParam = new MethodParameter(method, i);\n\t\t\t\tDependencyDescriptor dependencyDescriptor = new DependencyDescriptor(methodParam, true);\n\t\t\t\tregisterProxyIfNecessary(runtimeHints, dependencyDescriptor);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.beanFactory": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "signature": "public DefaultListableBeanFactory beanFactory",
    "source_code": "\t\tpublic DefaultListableBeanFactory beanFactory;",
    "type": "DefaultListableBeanFactory"
  },
  "org.springframework.beans.factory.config.TypedStringValue#compareTo(o)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "int",
    "signature": "public int compareTo(@Nullable TypedStringValue o)",
    "source_code": "\tpublic int compareTo(@Nullable TypedStringValue o) {\n\t\treturn Comparator.comparing(TypedStringValue::getValue).compare(this, o);\n\t}"
  },
  "org.springframework.beans.factory.config.YamlProcessor#isGlobalTagAllowed(tag)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "tag"
    ],
    "position": {
      "column": 1,
      "line": 435
    },
    "return": "boolean",
    "signature": "public boolean isGlobalTagAllowed(Tag tag)",
    "source_code": "\t\tpublic boolean isGlobalTagAllowed(Tag tag) {\n\t\t\treturn supportedTypes.contains(tag.getClassName());\n\t\t}"
  },
  "org.springframework.beans.factory.mode": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "public String mode",
    "source_code": "\t\tpublic String mode;",
    "type": "String"
  },
  "org.springframework.beans.factory.support.<unknown>#await(destroyMethod,returnValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destroyMethod",
      "returnValue"
    ],
    "position": {
      "column": 1,
      "line": 494
    },
    "return": "boolean",
    "signature": "public boolean await(Method destroyMethod, Object returnValue)",
    "source_code": "\t\tpublic boolean await(Method destroyMethod, Object returnValue) throws InterruptedException {\n\t\t\tReactiveAdapter adapter = ReactiveAdapterRegistry.getSharedInstance().getAdapter(returnValue.getClass());\n\t\t\tif (adapter != null) {\n\t\t\t\tCountDownLatch latch = new CountDownLatch(1);\n\t\t\t\tadapter.toPublisher(returnValue).subscribe(new DestroyMethodSubscriber(destroyMethod, latch));\n\t\t\t\tlatch.await();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#onComplete()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 537
    },
    "return": "void",
    "signature": "public void onComplete()",
    "source_code": "\t\tpublic void onComplete() {\n\t\t\tthis.latch.countDown();\n\t\t\tlogDestroyMethodCompletion(this.destroyMethod, true);\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#onError(t)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "t"
    ],
    "position": {
      "column": 1,
      "line": 531
    },
    "return": "void",
    "signature": "public void onError(Throwable t)",
    "source_code": "\t\tpublic void onError(Throwable t) {\n\t\t\tthis.latch.countDown();\n\t\t\tlogDestroyMethodException(this.destroyMethod, t);\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#onNext(o)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o"
    ],
    "position": {
      "column": 1,
      "line": 527
    },
    "return": "void",
    "signature": "public void onNext(Object o)",
    "source_code": "\t\tpublic void onNext(Object o) {\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#onSubscribe(s)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "s"
    ],
    "position": {
      "column": 1,
      "line": 522
    },
    "return": "void",
    "signature": "public void onSubscribe(Subscription s)",
    "source_code": "\t\tpublic void onSubscribe(Subscription s) {\n\t\t\ts.request(Integer.MAX_VALUE);\n\t\t}"
  },
  "org.springframework.beans.factory.support.DefaultListableBeanFactory#isBeanDefinitionOverridable(beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns {@code true} if bean definition overriding\n\t * is generally allowed.\n\t * @see #setAllowBeanDefinitionOverriding\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 1161
    },
    "return": "boolean",
    "signature": "public boolean isBeanDefinitionOverridable(String beanName)",
    "source_code": "\tpublic boolean isBeanDefinitionOverridable(String beanName) {\n\t\treturn isAllowBeanDefinitionOverriding();\n\t}"
  },
  "org.springframework.beans.factory.support.ORDER_ATTRIBUTE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The name of an attribute that can be\n\t * {@link org.springframework.core.AttributeAccessor#setAttribute set} on a\n\t * {@link org.springframework.beans.factory.config.BeanDefinition} so that\n\t * bean definitions can indicate the sort order for the targeted bean.\n\t * This is analogous to the {@code @Order} annotation.\n\t * @since 6.1.2\n\t * @see org.springframework.core.annotation.Order\n\t * @see org.springframework.core.Ordered\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "signature": "public String ORDER_ATTRIBUTE",
    "source_code": "\tpublic static final String ORDER_ATTRIBUTE = \"order\";",
    "type": "String"
  },
  "org.springframework.beans.factory.support.PREFERRED_CONSTRUCTORS_ATTRIBUTE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The name of an attribute that can be\n\t * {@link org.springframework.core.AttributeAccessor#setAttribute set} on a\n\t * {@link org.springframework.beans.factory.config.BeanDefinition} so that\n\t * bean definitions can indicate one or more preferred constructors. This is\n\t * analogous to {@code @Autowired} annotated constructors on the bean class.\n\t * <p>The attribute value may be a single {@link java.lang.reflect.Constructor}\n\t * reference or an array thereof.\n\t * @since 6.1\n\t * @see org.springframework.beans.factory.annotation.Autowired\n\t * @see org.springframework.beans.factory.support.RootBeanDefinition#getPreferredConstructors()\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "signature": "public String PREFERRED_CONSTRUCTORS_ATTRIBUTE",
    "source_code": "\tpublic static final String PREFERRED_CONSTRUCTORS_ATTRIBUTE = \"preferredConstructors\";",
    "type": "String"
  },
  "org.springframework.cache.caffeine.CaffeineCache#getAsyncCache()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the internal Caffeine AsyncCache.\n\t * @throws IllegalStateException if no AsyncCache is available\n\t * @since 6.1\n\t * @see #CaffeineCache(String, AsyncCache, boolean)\n\t * @see CaffeineCacheManager#setAsyncCacheMode\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "Object>",
    "signature": "public Object> getAsyncCache()",
    "source_code": "\tpublic final AsyncCache<Object, Object> getAsyncCache() {\n\t\tAssert.state(this.asyncCache != null,\n\t\t\t\t\"No Caffeine AsyncCache available: set CaffeineCacheManager.setAsyncCacheMode(true)\");\n\t\treturn this.asyncCache;\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCache#retrieve(key,valueLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "valueLoader"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "CompletableFuture<T>",
    "signature": "public CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader)",
    "source_code": "\tpublic <T> CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader) {\n\t\tif (isAllowNullValues()) {\n\t\t\treturn (CompletableFuture<T>) getAsyncCache()\n\t\t\t\t\t.get(key, (k, e) -> valueLoader.get().thenApply(this::toStoreValue))\n\t\t\t\t\t.thenApply(this::fromStoreValue);\n\t\t}\n\t\telse {\n\t\t\treturn (CompletableFuture<T>) getAsyncCache().get(key, (k, e) -> valueLoader.get());\n\t\t}\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link CacheManager} implementation that lazily builds {@link CaffeineCache}\n * instances for each {@link #getCache} request. Also supports a 'static' mode\n * where the set of cache names is pre-defined through {@link #setCacheNames},\n * with no dynamic creation of further cache regions at runtime.\n *\n * <p>The configuration of the underlying cache can be fine-tuned through a\n * {@link Caffeine} builder or {@link CaffeineSpec}, passed into this\n * CacheManager through {@link #setCaffeine}/{@link #setCaffeineSpec}.\n * A {@link CaffeineSpec}-compliant expression value can also be applied\n * via the {@link #setCacheSpecification \"cacheSpecification\"} bean property.\n *\n * <p>Supports the asynchronous {@link Cache#retrieve(Object)} and\n * {@link Cache#retrieve(Object, Supplier)} operations through Caffeine's\n * {@link AsyncCache}, when configured via {@link #setAsyncCacheMode},\n * with early-determined cache misses.\n *\n * <p>Requires Caffeine 3.0 or higher, as of Spring Framework 6.1.\n *\n * @author Ben Manes\n * @author Juergen Hoeller\n * @author Stephane Nicoll\n * @author Sam Brannen\n * @author Brian Clozel\n * @since 4.3\n * @see CaffeineCache\n * @see #setCaffeineSpec\n * @see #setCacheSpecification\n * @see #setAsyncCacheMode\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "signature": "public class CaffeineCacheManager",
    "source_code": "public class CaffeineCacheManager implements CacheManager {\n\n\tprivate Caffeine<Object, Object> cacheBuilder = Caffeine.newBuilder();\n\n\t@Nullable\n\tprivate AsyncCacheLoader<Object, Object> cacheLoader;\n\n\tprivate boolean asyncCacheMode = false;\n\n\tprivate boolean allowNullValues = true;\n\n\tprivate boolean dynamic = true;\n\n\tprivate final Map<String, Cache> cacheMap = new ConcurrentHashMap<>(16);\n\n\tprivate final Collection<String> customCacheNames = new CopyOnWriteArrayList<>();\n\n\n\t/**\n\t * Construct a dynamic CaffeineCacheManager,\n\t * lazily creating cache instances as they are being requested.\n\t */\n\tpublic CaffeineCacheManager() {\n\t}\n\n\t/**\n\t * Construct a static CaffeineCacheManager,\n\t * managing caches for the specified cache names only.\n\t */\n\tpublic CaffeineCacheManager(String... cacheNames) {\n\t\tsetCacheNames(Arrays.asList(cacheNames));\n\t}\n\n\n\t/**\n\t * Specify the set of cache names for this CacheManager's 'static' mode.\n\t * <p>The number of caches and their names will be fixed after a call to this method,\n\t * with no creation of further cache regions at runtime.\n\t * <p>Calling this with a {@code null} collection argument resets the\n\t * mode to 'dynamic', allowing for further creation of caches again.\n\t */\n\tpublic void setCacheNames(@Nullable Collection<String> cacheNames) {\n\t\tif (cacheNames != null) {\n\t\t\tfor (String name : cacheNames) {\n\t\t\t\tthis.cacheMap.put(name, createCaffeineCache(name));\n\t\t\t}\n\t\t\tthis.dynamic = false;\n\t\t}\n\t\telse {\n\t\t\tthis.dynamic = true;\n\t\t}\n\t}\n\n\t/**\n\t * Set the Caffeine to use for building each individual\n\t * {@link CaffeineCache} instance.\n\t * @see #createNativeCaffeineCache\n\t * @see Caffeine#build()\n\t */\n\tpublic void setCaffeine(Caffeine<Object, Object> caffeine) {\n\t\tAssert.notNull(caffeine, \"Caffeine must not be null\");\n\t\tdoSetCaffeine(caffeine);\n\t}\n\n\t/**\n\t * Set the {@link CaffeineSpec} to use for building each individual\n\t * {@link CaffeineCache} instance.\n\t * @see #createNativeCaffeineCache\n\t * @see Caffeine#from(CaffeineSpec)\n\t */\n\tpublic void setCaffeineSpec(CaffeineSpec caffeineSpec) {\n\t\tdoSetCaffeine(Caffeine.from(caffeineSpec));\n\t}\n\n\t/**\n\t * Set the Caffeine cache specification String to use for building each\n\t * individual {@link CaffeineCache} instance. The given value needs to\n\t * comply with Caffeine's {@link CaffeineSpec} (see its javadoc).\n\t * @see #createNativeCaffeineCache\n\t * @see Caffeine#from(String)\n\t */\n\tpublic void setCacheSpecification(String cacheSpecification) {\n\t\tdoSetCaffeine(Caffeine.from(cacheSpecification));\n\t}\n\n\tprivate void doSetCaffeine(Caffeine<Object, Object> cacheBuilder) {\n\t\tif (!ObjectUtils.nullSafeEquals(this.cacheBuilder, cacheBuilder)) {\n\t\t\tthis.cacheBuilder = cacheBuilder;\n\t\t\trefreshCommonCaches();\n\t\t}\n\t}\n\n\t/**\n\t * Set the Caffeine CacheLoader to use for building each individual\n\t * {@link CaffeineCache} instance, turning it into a LoadingCache.\n\t * @see #createNativeCaffeineCache\n\t * @see Caffeine#build(CacheLoader)\n\t * @see com.github.benmanes.caffeine.cache.LoadingCache\n\t */\n\tpublic void setCacheLoader(CacheLoader<Object, Object> cacheLoader) {\n\t\tif (!ObjectUtils.nullSafeEquals(this.cacheLoader, cacheLoader)) {\n\t\t\tthis.cacheLoader = cacheLoader;\n\t\t\trefreshCommonCaches();\n\t\t}\n\t}\n\n\t/**\n\t * Set the Caffeine AsyncCacheLoader to use for building each individual\n\t * {@link CaffeineCache} instance, turning it into a LoadingCache.\n\t * <p>This implicitly switches the {@link #setAsyncCacheMode \"asyncCacheMode\"}\n\t * flag to {@code true}.\n\t * @since 6.1\n\t * @see #createAsyncCaffeineCache\n\t * @see Caffeine#buildAsync(AsyncCacheLoader)\n\t * @see com.github.benmanes.caffeine.cache.LoadingCache\n\t */\n\tpublic void setAsyncCacheLoader(AsyncCacheLoader<Object, Object> cacheLoader) {\n\t\tif (!ObjectUtils.nullSafeEquals(this.cacheLoader, cacheLoader)) {\n\t\t\tthis.cacheLoader = cacheLoader;\n\t\t\tthis.asyncCacheMode = true;\n\t\t\trefreshCommonCaches();\n\t\t}\n\t}\n\n\t/**\n\t * Set the common cache type that this cache manager builds to async.\n\t * This applies to {@link #setCacheNames} as well as on-demand caches.\n\t * <p>Individual cache registrations (such as {@link #registerCustomCache(String, AsyncCache)}\n\t * and {@link #registerCustomCache(String, com.github.benmanes.caffeine.cache.Cache)})\n\t * are not dependent on this setting.\n\t * <p>By default, this cache manager builds regular native Caffeine caches.\n\t * To switch to async caches which can also be used through the synchronous API\n\t * but come with support for {@code Cache#retrieve}, set this flag to {@code true}.\n\t * <p>Note that while null values in the cache are tolerated in async cache mode,\n\t * the recommendation is to disallow null values through\n\t * {@link #setAllowNullValues setAllowNullValues(false)}. This makes the semantics\n\t * of CompletableFuture-based access simpler and optimizes retrieval performance\n\t * since a Caffeine-provided CompletableFuture handle does not have to get wrapped.\n\t * <p>If you come here for the adaptation of reactive types such as a Reactor\n\t * {@code Mono} or {@code Flux} onto asynchronous caching, we recommend the standard\n\t * arrangement for caching the produced values asynchronously in 6.1 through enabling\n\t * this Caffeine mode. If this is not immediately possible/desirable for existing\n\t * apps, you may set the system property \"spring.cache.reactivestreams.ignore=true\"\n\t * to restore 6.0 behavior where reactive handles are treated as regular values.\n\t * @since 6.1\n\t * @see Caffeine#buildAsync()\n\t * @see Cache#retrieve(Object)\n\t * @see Cache#retrieve(Object, Supplier)\n\t * @see org.springframework.cache.interceptor.CacheAspectSupport#IGNORE_REACTIVESTREAMS_PROPERTY_NAME\n\t */\n\tpublic void setAsyncCacheMode(boolean asyncCacheMode) {\n\t\tif (this.asyncCacheMode != asyncCacheMode) {\n\t\t\tthis.asyncCacheMode = asyncCacheMode;\n\t\t\trefreshCommonCaches();\n\t\t}\n\t}\n\n\t/**\n\t * Specify whether to accept and convert {@code null} values for all caches\n\t * in this cache manager.\n\t * <p>Default is \"true\", despite Caffeine itself not supporting {@code null} values.\n\t * An internal holder object will be used to store user-level {@code null}s.\n\t */\n\tpublic void setAllowNullValues(boolean allowNullValues) {\n\t\tif (this.allowNullValues != allowNullValues) {\n\t\t\tthis.allowNullValues = allowNullValues;\n\t\t\trefreshCommonCaches();\n\t\t}\n\t}\n\n\t/**\n\t * Return whether this cache manager accepts and converts {@code null} values\n\t * for all of its caches.\n\t */\n\tpublic boolean isAllowNullValues() {\n\t\treturn this.allowNullValues;\n\t}\n\n\n\t@Override\n\tpublic Collection<String> getCacheNames() {\n\t\treturn Collections.unmodifiableSet(this.cacheMap.keySet());\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Cache getCache(String name) {\n\t\tCache cache = this.cacheMap.get(name);\n\t\tif (cache == null && this.dynamic) {\n\t\t\tcache = this.cacheMap.computeIfAbsent(name, this::createCaffeineCache);\n\t\t}\n\t\treturn cache;\n\t}\n\n\n\t/**\n\t * Register the given native Caffeine Cache instance with this cache manager,\n\t * adapting it to Spring's cache API for exposure through {@link #getCache}.\n\t * Any number of such custom caches may be registered side by side.\n\t * <p>This allows for custom settings per cache (as opposed to all caches\n\t * sharing the common settings in the cache manager's configuration) and\n\t * is typically used with the Caffeine builder API:\n\t * {@code registerCustomCache(\"myCache\", Caffeine.newBuilder().maximumSize(10).build())}\n\t * <p>Note that any other caches, whether statically specified through\n\t * {@link #setCacheNames} or dynamically built on demand, still operate\n\t * with the common settings in the cache manager's configuration.\n \t * @param name the name of the cache\n\t * @param cache the custom Caffeine Cache instance to register\n\t * @since 5.2.8\n\t * @see #adaptCaffeineCache(String, com.github.benmanes.caffeine.cache.Cache)\n\t */\n\tpublic void registerCustomCache(String name, com.github.benmanes.caffeine.cache.Cache<Object, Object> cache) {\n\t\tthis.customCacheNames.add(name);\n\t\tthis.cacheMap.put(name, adaptCaffeineCache(name, cache));\n\t}\n\n\t/**\n\t * Register the given Caffeine AsyncCache instance with this cache manager,\n\t * adapting it to Spring's cache API for exposure through {@link #getCache}.\n\t * Any number of such custom caches may be registered side by side.\n\t * <p>This allows for custom settings per cache (as opposed to all caches\n\t * sharing the common settings in the cache manager's configuration) and\n\t * is typically used with the Caffeine builder API:\n\t * {@code registerCustomCache(\"myCache\", Caffeine.newBuilder().maximumSize(10).buildAsync())}\n\t * <p>Note that any other caches, whether statically specified through\n\t * {@link #setCacheNames} or dynamically built on demand, still operate\n\t * with the common settings in the cache manager's configuration.\n\t * @param name the name of the cache\n\t * @param cache the custom Caffeine AsyncCache instance to register\n\t * @since 6.1\n\t * @see #adaptCaffeineCache(String, AsyncCache)\n\t */\n\tpublic void registerCustomCache(String name, AsyncCache<Object, Object> cache) {\n\t\tthis.customCacheNames.add(name);\n\t\tthis.cacheMap.put(name, adaptCaffeineCache(name, cache));\n\t}\n\n\t/**\n\t * Adapt the given new native Caffeine Cache instance to Spring's {@link Cache}\n\t * abstraction for the specified cache name.\n\t * @param name the name of the cache\n\t * @param cache the native Caffeine Cache instance\n\t * @return the Spring CaffeineCache adapter (or a decorator thereof)\n\t * @since 5.2.8\n\t * @see CaffeineCache#CaffeineCache(String, com.github.benmanes.caffeine.cache.Cache, boolean)\n\t * @see #isAllowNullValues()\n\t */\n\tprotected Cache adaptCaffeineCache(String name, com.github.benmanes.caffeine.cache.Cache<Object, Object> cache) {\n\t\treturn new CaffeineCache(name, cache, isAllowNullValues());\n\t}\n\n\t/**\n\t * Adapt the given new Caffeine AsyncCache instance to Spring's {@link Cache}\n\t * abstraction for the specified cache name.\n\t * @param name the name of the cache\n\t * @param cache the Caffeine AsyncCache instance\n\t * @return the Spring CaffeineCache adapter (or a decorator thereof)\n\t * @since 6.1\n\t * @see CaffeineCache#CaffeineCache(String, AsyncCache, boolean)\n\t * @see #isAllowNullValues()\n\t */\n\tprotected Cache adaptCaffeineCache(String name, AsyncCache<Object, Object> cache) {\n\t\treturn new CaffeineCache(name, cache, isAllowNullValues());\n\t}\n\n\t/**\n\t * Build a common {@link CaffeineCache} instance for the specified cache name,\n\t * using the common Caffeine configuration specified on this cache manager.\n\t * <p>Delegates to {@link #adaptCaffeineCache} as the adaptation method to\n\t * Spring's cache abstraction (allowing for centralized decoration etc.),\n\t * passing in a freshly built native Caffeine Cache instance.\n\t * @param name the name of the cache\n\t * @return the Spring CaffeineCache adapter (or a decorator thereof)\n\t * @see #adaptCaffeineCache\n\t * @see #createNativeCaffeineCache\n\t */\n\tprotected Cache createCaffeineCache(String name) {\n\t\treturn (this.asyncCacheMode ? adaptCaffeineCache(name, createAsyncCaffeineCache(name)) :\n\t\t\t\tadaptCaffeineCache(name, createNativeCaffeineCache(name)));\n\t}\n\n\t/**\n\t * Build a common Caffeine Cache instance for the specified cache name,\n\t * using the common Caffeine configuration specified on this cache manager.\n\t * @param name the name of the cache\n\t * @return the native Caffeine Cache instance\n\t * @see #createCaffeineCache\n\t */\n\tprotected com.github.benmanes.caffeine.cache.Cache<Object, Object> createNativeCaffeineCache(String name) {\n\t\tif (this.cacheLoader != null) {\n\t\t\tif (this.cacheLoader instanceof CacheLoader<Object, Object> regularCacheLoader) {\n\t\t\t\treturn this.cacheBuilder.build(regularCacheLoader);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Cannot create regular Caffeine Cache with async-only cache loader: \" + this.cacheLoader);\n\t\t\t}\n\t\t}\n\t\treturn this.cacheBuilder.build();\n\t}\n\n\t/**\n\t * Build a common Caffeine AsyncCache instance for the specified cache name,\n\t * using the common Caffeine configuration specified on this cache manager.\n\t * @param name the name of the cache\n\t * @return the Caffeine AsyncCache instance\n\t * @since 6.1\n\t * @see #createCaffeineCache\n\t */\n\tprotected AsyncCache<Object, Object> createAsyncCaffeineCache(String name) {\n\t\treturn (this.cacheLoader != null ? this.cacheBuilder.buildAsync(this.cacheLoader) :\n\t\t\t\tthis.cacheBuilder.buildAsync());\n\t}\n\n\t/**\n\t * Recreate the common caches with the current state of this manager.\n\t */\n\tprivate void refreshCommonCaches() {\n\t\tfor (Map.Entry<String, Cache> entry : this.cacheMap.entrySet()) {\n\t\t\tif (!this.customCacheNames.contains(entry.getKey())) {\n\t\t\t\tentry.setValue(createCaffeineCache(entry.getKey()));\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#adaptCaffeineCache(name,AsyncCache<Object,cache)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Adapt the given new Caffeine AsyncCache instance to Spring's {@link Cache}\n\t * abstraction for the specified cache name.\n\t * @param name the name of the cache\n\t * @param cache the Caffeine AsyncCache instance\n\t * @return the Spring CaffeineCache adapter (or a decorator thereof)\n\t * @since 6.1\n\t * @see CaffeineCache#CaffeineCache(String, AsyncCache, boolean)\n\t * @see #isAllowNullValues()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "AsyncCache<Object",
      "cache"
    ],
    "position": {
      "column": 1,
      "line": 330
    },
    "return": "Cache",
    "signature": "protected Cache adaptCaffeineCache(String name, AsyncCache<Object, Object> cache)",
    "source_code": "\tprotected Cache adaptCaffeineCache(String name, AsyncCache<Object, Object> cache) {\n\t\treturn new CaffeineCache(name, cache, isAllowNullValues());\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#adaptCaffeineCache(name,com.github.benmanes.caffeine.cache.Cache<Object,cache)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Adapt the given new native Caffeine Cache instance to Spring's {@link Cache}\n\t * abstraction for the specified cache name.\n\t * @param name the name of the cache\n\t * @param cache the native Caffeine Cache instance\n\t * @return the Spring CaffeineCache adapter (or a decorator thereof)\n\t * @since 5.2.8\n\t * @see CaffeineCache#CaffeineCache(String, com.github.benmanes.caffeine.cache.Cache, boolean)\n\t * @see #isAllowNullValues()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "com.github.benmanes.caffeine.cache.Cache<Object",
      "cache"
    ],
    "position": {
      "column": 1,
      "line": 316
    },
    "return": "Cache",
    "signature": "protected Cache adaptCaffeineCache(String name, com.github.benmanes.caffeine.cache.Cache<Object, Object> cache)",
    "source_code": "\tprotected Cache adaptCaffeineCache(String name, com.github.benmanes.caffeine.cache.Cache<Object, Object> cache) {\n\t\treturn new CaffeineCache(name, cache, isAllowNullValues());\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#createAsyncCaffeineCache(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a common Caffeine AsyncCache instance for the specified cache name,\n\t * using the common Caffeine configuration specified on this cache manager.\n\t * @param name the name of the cache\n\t * @return the Caffeine AsyncCache instance\n\t * @since 6.1\n\t * @see #createCaffeineCache\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 378
    },
    "return": "Object>",
    "signature": "protected Object> createAsyncCaffeineCache(String name)",
    "source_code": "\tprotected AsyncCache<Object, Object> createAsyncCaffeineCache(String name) {\n\t\treturn (this.cacheLoader != null ? this.cacheBuilder.buildAsync(this.cacheLoader) :\n\t\t\t\tthis.cacheBuilder.buildAsync());\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#createCaffeineCache(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a common {@link CaffeineCache} instance for the specified cache name,\n\t * using the common Caffeine configuration specified on this cache manager.\n\t * <p>Delegates to {@link #adaptCaffeineCache} as the adaptation method to\n\t * Spring's cache abstraction (allowing for centralized decoration etc.),\n\t * passing in a freshly built native Caffeine Cache instance.\n\t * @param name the name of the cache\n\t * @return the Spring CaffeineCache adapter (or a decorator thereof)\n\t * @see #adaptCaffeineCache\n\t * @see #createNativeCaffeineCache\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 345
    },
    "return": "Cache",
    "signature": "protected Cache createCaffeineCache(String name)",
    "source_code": "\tprotected Cache createCaffeineCache(String name) {\n\t\treturn (this.asyncCacheMode ? adaptCaffeineCache(name, createAsyncCaffeineCache(name)) :\n\t\t\t\tadaptCaffeineCache(name, createNativeCaffeineCache(name)));\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#getCache(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "Cache",
    "signature": "public Cache getCache(String name)",
    "source_code": "\tpublic Cache getCache(String name) {\n\t\tCache cache = this.cacheMap.get(name);\n\t\tif (cache == null && this.dynamic) {\n\t\t\tcache = this.cacheMap.computeIfAbsent(name, this::createCaffeineCache);\n\t\t}\n\t\treturn cache;\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#getCacheNames()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "Collection<String>",
    "signature": "public Collection<String> getCacheNames()",
    "source_code": "\tpublic Collection<String> getCacheNames() {\n\t\treturn Collections.unmodifiableSet(this.cacheMap.keySet());\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#isAllowNullValues()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether this cache manager accepts and converts {@code null} values\n\t * for all of its caches.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "boolean",
    "signature": "public boolean isAllowNullValues()",
    "source_code": "\tpublic boolean isAllowNullValues() {\n\t\treturn this.allowNullValues;\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#registerCustomCache(name,AsyncCache<Object,cache)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register the given Caffeine AsyncCache instance with this cache manager,\n\t * adapting it to Spring's cache API for exposure through {@link #getCache}.\n\t * Any number of such custom caches may be registered side by side.\n\t * <p>This allows for custom settings per cache (as opposed to all caches\n\t * sharing the common settings in the cache manager's configuration) and\n\t * is typically used with the Caffeine builder API:\n\t * {@code registerCustomCache(\"myCache\", Caffeine.newBuilder().maximumSize(10).buildAsync())}\n\t * <p>Note that any other caches, whether statically specified through\n\t * {@link #setCacheNames} or dynamically built on demand, still operate\n\t * with the common settings in the cache manager's configuration.\n\t * @param name the name of the cache\n\t * @param cache the custom Caffeine AsyncCache instance to register\n\t * @since 6.1\n\t * @see #adaptCaffeineCache(String, AsyncCache)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "AsyncCache<Object",
      "cache"
    ],
    "position": {
      "column": 1,
      "line": 301
    },
    "return": "void",
    "signature": "public void registerCustomCache(String name, AsyncCache<Object, Object> cache)",
    "source_code": "\tpublic void registerCustomCache(String name, AsyncCache<Object, Object> cache) {\n\t\tthis.customCacheNames.add(name);\n\t\tthis.cacheMap.put(name, adaptCaffeineCache(name, cache));\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#registerCustomCache(name,com.github.benmanes.caffeine.cache.Cache<Object,cache)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register the given native Caffeine Cache instance with this cache manager,\n\t * adapting it to Spring's cache API for exposure through {@link #getCache}.\n\t * Any number of such custom caches may be registered side by side.\n\t * <p>This allows for custom settings per cache (as opposed to all caches\n\t * sharing the common settings in the cache manager's configuration) and\n\t * is typically used with the Caffeine builder API:\n\t * {@code registerCustomCache(\"myCache\", Caffeine.newBuilder().maximumSize(10).build())}\n\t * <p>Note that any other caches, whether statically specified through\n\t * {@link #setCacheNames} or dynamically built on demand, still operate\n\t * with the common settings in the cache manager's configuration.\n \t * @param name the name of the cache\n\t * @param cache the custom Caffeine Cache instance to register\n\t * @since 5.2.8\n\t * @see #adaptCaffeineCache(String, com.github.benmanes.caffeine.cache.Cache)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "com.github.benmanes.caffeine.cache.Cache<Object",
      "cache"
    ],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "void",
    "signature": "public void registerCustomCache(String name, com.github.benmanes.caffeine.cache.Cache<Object, Object> cache)",
    "source_code": "\tpublic void registerCustomCache(String name, com.github.benmanes.caffeine.cache.Cache<Object, Object> cache) {\n\t\tthis.customCacheNames.add(name);\n\t\tthis.cacheMap.put(name, adaptCaffeineCache(name, cache));\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#setAllowNullValues(allowNullValues)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether to accept and convert {@code null} values for all caches\n\t * in this cache manager.\n\t * <p>Default is \"true\", despite Caffeine itself not supporting {@code null} values.\n\t * An internal holder object will be used to store user-level {@code null}s.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "allowNullValues"
    ],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "void",
    "signature": "public void setAllowNullValues(boolean allowNullValues)",
    "source_code": "\tpublic void setAllowNullValues(boolean allowNullValues) {\n\t\tif (this.allowNullValues != allowNullValues) {\n\t\t\tthis.allowNullValues = allowNullValues;\n\t\t\trefreshCommonCaches();\n\t\t}\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#setAsyncCacheLoader(AsyncCacheLoader<Object,cacheLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Caffeine AsyncCacheLoader to use for building each individual\n\t * {@link CaffeineCache} instance, turning it into a LoadingCache.\n\t * <p>This implicitly switches the {@link #setAsyncCacheMode \"asyncCacheMode\"}\n\t * flag to {@code true}.\n\t * @since 6.1\n\t * @see #createAsyncCaffeineCache\n\t * @see Caffeine#buildAsync(AsyncCacheLoader)\n\t * @see com.github.benmanes.caffeine.cache.LoadingCache\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "AsyncCacheLoader<Object",
      "cacheLoader"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "void",
    "signature": "public void setAsyncCacheLoader(AsyncCacheLoader<Object, Object> cacheLoader)",
    "source_code": "\tpublic void setAsyncCacheLoader(AsyncCacheLoader<Object, Object> cacheLoader) {\n\t\tif (!ObjectUtils.nullSafeEquals(this.cacheLoader, cacheLoader)) {\n\t\t\tthis.cacheLoader = cacheLoader;\n\t\t\tthis.asyncCacheMode = true;\n\t\t\trefreshCommonCaches();\n\t\t}\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#setAsyncCacheMode(asyncCacheMode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the common cache type that this cache manager builds to async.\n\t * This applies to {@link #setCacheNames} as well as on-demand caches.\n\t * <p>Individual cache registrations (such as {@link #registerCustomCache(String, AsyncCache)}\n\t * and {@link #registerCustomCache(String, com.github.benmanes.caffeine.cache.Cache)})\n\t * are not dependent on this setting.\n\t * <p>By default, this cache manager builds regular native Caffeine caches.\n\t * To switch to async caches which can also be used through the synchronous API\n\t * but come with support for {@code Cache#retrieve}, set this flag to {@code true}.\n\t * <p>Note that while null values in the cache are tolerated in async cache mode,\n\t * the recommendation is to disallow null values through\n\t * {@link #setAllowNullValues setAllowNullValues(false)}. This makes the semantics\n\t * of CompletableFuture-based access simpler and optimizes retrieval performance\n\t * since a Caffeine-provided CompletableFuture handle does not have to get wrapped.\n\t * <p>If you come here for the adaptation of reactive types such as a Reactor\n\t * {@code Mono} or {@code Flux} onto asynchronous caching, we recommend the standard\n\t * arrangement for caching the produced values asynchronously in 6.1 through enabling\n\t * this Caffeine mode. If this is not immediately possible/desirable for existing\n\t * apps, you may set the system property \"spring.cache.reactivestreams.ignore=true\"\n\t * to restore 6.0 behavior where reactive handles are treated as regular values.\n\t * @since 6.1\n\t * @see Caffeine#buildAsync()\n\t * @see Cache#retrieve(Object)\n\t * @see Cache#retrieve(Object, Supplier)\n\t * @see org.springframework.cache.interceptor.CacheAspectSupport#IGNORE_REACTIVESTREAMS_PROPERTY_NAME\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "asyncCacheMode"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "void",
    "signature": "public void setAsyncCacheMode(boolean asyncCacheMode)",
    "source_code": "\tpublic void setAsyncCacheMode(boolean asyncCacheMode) {\n\t\tif (this.asyncCacheMode != asyncCacheMode) {\n\t\t\tthis.asyncCacheMode = asyncCacheMode;\n\t\t\trefreshCommonCaches();\n\t\t}\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#setCacheLoader(CacheLoader<Object,cacheLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Caffeine CacheLoader to use for building each individual\n\t * {@link CaffeineCache} instance, turning it into a LoadingCache.\n\t * @see #createNativeCaffeineCache\n\t * @see Caffeine#build(CacheLoader)\n\t * @see com.github.benmanes.caffeine.cache.LoadingCache\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "CacheLoader<Object",
      "cacheLoader"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "void",
    "signature": "public void setCacheLoader(CacheLoader<Object, Object> cacheLoader)",
    "source_code": "\tpublic void setCacheLoader(CacheLoader<Object, Object> cacheLoader) {\n\t\tif (!ObjectUtils.nullSafeEquals(this.cacheLoader, cacheLoader)) {\n\t\t\tthis.cacheLoader = cacheLoader;\n\t\t\trefreshCommonCaches();\n\t\t}\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#setCacheNames(cacheNames)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the set of cache names for this CacheManager's 'static' mode.\n\t * <p>The number of caches and their names will be fixed after a call to this method,\n\t * with no creation of further cache regions at runtime.\n\t * <p>Calling this with a {@code null} collection argument resets the\n\t * mode to 'dynamic', allowing for further creation of caches again.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cacheNames"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "void",
    "signature": "public void setCacheNames(@Nullable Collection<String> cacheNames)",
    "source_code": "\tpublic void setCacheNames(@Nullable Collection<String> cacheNames) {\n\t\tif (cacheNames != null) {\n\t\t\tfor (String name : cacheNames) {\n\t\t\t\tthis.cacheMap.put(name, createCaffeineCache(name));\n\t\t\t}\n\t\t\tthis.dynamic = false;\n\t\t}\n\t\telse {\n\t\t\tthis.dynamic = true;\n\t\t}\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#setCacheSpecification(cacheSpecification)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Caffeine cache specification String to use for building each\n\t * individual {@link CaffeineCache} instance. The given value needs to\n\t * comply with Caffeine's {@link CaffeineSpec} (see its javadoc).\n\t * @see #createNativeCaffeineCache\n\t * @see Caffeine#from(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cacheSpecification"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "void",
    "signature": "public void setCacheSpecification(String cacheSpecification)",
    "source_code": "\tpublic void setCacheSpecification(String cacheSpecification) {\n\t\tdoSetCaffeine(Caffeine.from(cacheSpecification));\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#setCaffeine(Caffeine<Object,caffeine)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Caffeine to use for building each individual\n\t * {@link CaffeineCache} instance.\n\t * @see #createNativeCaffeineCache\n\t * @see Caffeine#build()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Caffeine<Object",
      "caffeine"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "void",
    "signature": "public void setCaffeine(Caffeine<Object, Object> caffeine)",
    "source_code": "\tpublic void setCaffeine(Caffeine<Object, Object> caffeine) {\n\t\tAssert.notNull(caffeine, \"Caffeine must not be null\");\n\t\tdoSetCaffeine(caffeine);\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#setCaffeineSpec(caffeineSpec)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link CaffeineSpec} to use for building each individual\n\t * {@link CaffeineCache} instance.\n\t * @see #createNativeCaffeineCache\n\t * @see Caffeine#from(CaffeineSpec)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "caffeineSpec"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "void",
    "signature": "public void setCaffeineSpec(CaffeineSpec caffeineSpec)",
    "source_code": "\tpublic void setCaffeineSpec(CaffeineSpec caffeineSpec) {\n\t\tdoSetCaffeine(Caffeine.from(caffeineSpec));\n\t}"
  },
  "org.springframework.cache.interceptor.CacheAspectSupport#apply(result)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "result"
    ],
    "position": {
      "column": 1,
      "line": 1002
    },
    "return": "Object",
    "signature": "public Object apply(@Nullable Object result)",
    "source_code": "\t\tpublic Object apply(@Nullable Object result) {\n\t\t\tif (result instanceof CompletableFuture<?> future) {\n\t\t\t\treturn future.whenComplete((value, ex) -> {\n\t\t\t\t\tif (ex == null) {\n\t\t\t\t\t\tperformCachePut(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (reactiveCachingHandler != null) {\n\t\t\t\tObject returnValue = reactiveCachingHandler.processPutRequest(this, result);\n\t\t\t\tif (returnValue != ReactiveCachingHandler.NOT_HANDLED) {\n\t\t\t\t\treturn returnValue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tperformCachePut(result);\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.cache.interceptor.CacheAspectSupport#executeSynchronized(invoker,method,cache,key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "invoker",
      "method",
      "cache",
      "key"
    ],
    "position": {
      "column": 1,
      "line": 1081
    },
    "return": "Object",
    "signature": "public Object executeSynchronized(CacheOperationInvoker invoker, Method method, Cache cache, Object key)",
    "source_code": "\t\tpublic Object executeSynchronized(CacheOperationInvoker invoker, Method method, Cache cache, Object key) {\n\t\t\tReactiveAdapter adapter = this.registry.getAdapter(method.getReturnType());\n\t\t\tif (adapter != null) {\n\t\t\t\tif (adapter.isMultiValue()) {\n\t\t\t\t\t// Flux or similar\n\t\t\t\t\treturn adapter.fromPublisher(Flux.from(Mono.fromFuture(\n\t\t\t\t\t\t\tcache.retrieve(key,\n\t\t\t\t\t\t\t\t\t() -> Flux.from(adapter.toPublisher(invokeOperation(invoker))).collectList().toFuture())))\n\t\t\t\t\t\t\t.flatMap(Flux::fromIterable));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Mono or similar\n\t\t\t\t\treturn adapter.fromPublisher(Mono.fromFuture(\n\t\t\t\t\t\t\tcache.retrieve(key,\n\t\t\t\t\t\t\t\t\t() -> Mono.from(adapter.toPublisher(invokeOperation(invoker))).toFuture())));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (KotlinDetector.isKotlinReflectPresent() && KotlinDetector.isSuspendingFunction(method)) {\n\t\t\t\treturn Mono.fromFuture(cache.retrieve(key, () -> {\n\t\t\t\t\tMono<?> mono = ((Mono<?>) invokeOperation(invoker));\n\t\t\t\t\tif (mono == null) {\n\t\t\t\t\t\tmono = Mono.empty();\n\t\t\t\t\t}\n\t\t\t\t\treturn mono.toFuture();\n\t\t\t\t}));\n\t\t\t}\n\t\t\treturn NOT_HANDLED;\n\t\t}"
  },
  "org.springframework.cache.interceptor.CacheAspectSupport#findInCaches(context,cache,key,invoker,method,contexts)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "cache",
      "key",
      "invoker",
      "method",
      "contexts"
    ],
    "position": {
      "column": 1,
      "line": 1122
    },
    "return": "Object",
    "signature": "public Object findInCaches(CacheOperationContext context, Cache cache, Object key,\n\t\t\t\tCacheOperationInvoker invoker, Method method, CacheOperationContexts contexts)",
    "source_code": "\t\tpublic Object findInCaches(CacheOperationContext context, Cache cache, Object key,"
  },
  "org.springframework.cache.interceptor.CacheAspectSupport#getGeneratedKey()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Get generated key.\n\t\t * @return generated key\n\t\t * @since 6.1.2\n\t\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 927
    },
    "return": "Object",
    "signature": "protected Object getGeneratedKey()",
    "source_code": "\t\tprotected Object getGeneratedKey() {\n\t\t\treturn this.key;\n\t\t}"
  },
  "org.springframework.cache.interceptor.CacheAspectSupport#onComplete()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1065
    },
    "return": "void",
    "signature": "public void onComplete()",
    "source_code": "\t\tpublic void onComplete() {\n\t\t\tthis.request.performCachePut(this.cacheValue);\n\t\t}"
  },
  "org.springframework.cache.interceptor.CacheAspectSupport#onError(t)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "t"
    ],
    "position": {
      "column": 1,
      "line": 1061
    },
    "return": "void",
    "signature": "public void onError(Throwable t)",
    "source_code": "\t\tpublic void onError(Throwable t) {\n\t\t\tthis.cacheValue.clear();\n\t\t}"
  },
  "org.springframework.cache.interceptor.CacheAspectSupport#onNext(o)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o"
    ],
    "position": {
      "column": 1,
      "line": 1057
    },
    "return": "void",
    "signature": "public void onNext(Object o)",
    "source_code": "\t\tpublic void onNext(Object o) {\n\t\t\tthis.cacheValue.add(o);\n\t\t}"
  },
  "org.springframework.cache.interceptor.CacheAspectSupport#onSubscribe(s)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "s"
    ],
    "position": {
      "column": 1,
      "line": 1053
    },
    "return": "void",
    "signature": "public void onSubscribe(Subscription s)",
    "source_code": "\t\tpublic void onSubscribe(Subscription s) {\n\t\t\ts.request(Integer.MAX_VALUE);\n\t\t}"
  },
  "org.springframework.cache.interceptor.CacheAspectSupport#performCachePut(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 1020
    },
    "return": "void",
    "signature": "public void performCachePut(@Nullable Object value)",
    "source_code": "\t\tpublic void performCachePut(@Nullable Object value) {\n\t\t\tif (this.context.canPutToCache(value)) {\n\t\t\t\tObject key = this.context.getGeneratedKey();\n\t\t\t\tif (key == null) {\n\t\t\t\t\tkey = generateKey(this.context, value);\n\t\t\t\t}\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Creating cache entry for key '\" + key + \"' in cache(s) \" +\n\t\t\t\t\t\t\tthis.context.getCacheNames());\n\t\t\t\t}\n\t\t\t\tfor (Cache cache : this.context.getCaches()) {\n\t\t\t\t\tdoPut(cache, key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.cache.interceptor.CacheAspectSupport#processCacheEvicts(contexts,result)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contexts",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 1111
    },
    "return": "Object",
    "signature": "public Object processCacheEvicts(List<CacheOperationContext> contexts, @Nullable Object result)",
    "source_code": "\t\tpublic Object processCacheEvicts(List<CacheOperationContext> contexts, @Nullable Object result) {\n\t\t\tReactiveAdapter adapter = (result != null ? this.registry.getAdapter(result.getClass()) : null);\n\t\t\tif (adapter != null) {\n\t\t\t\treturn adapter.fromPublisher(Mono.from(adapter.toPublisher(result))\n\t\t\t\t\t\t.doOnSuccess(value -> performCacheEvicts(contexts, result)));\n\t\t\t}\n\t\t\treturn NOT_HANDLED;\n\t\t}"
  },
  "org.springframework.cache.interceptor.CacheAspectSupport#processPutRequest(request,result)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 1152
    },
    "return": "Object",
    "signature": "public Object processPutRequest(CachePutRequest request, @Nullable Object result)",
    "source_code": "\t\tpublic Object processPutRequest(CachePutRequest request, @Nullable Object result) {\n\t\t\tReactiveAdapter adapter = (result != null ? this.registry.getAdapter(result.getClass()) : null);\n\t\t\tif (adapter != null) {\n\t\t\t\tif (adapter.isMultiValue()) {\n\t\t\t\t\tFlux<?> source = Flux.from(adapter.toPublisher(result))\n\t\t\t\t\t\t\t.publish().refCount(2);\n\t\t\t\t\tsource.subscribe(new CachePutListSubscriber(request));\n\t\t\t\t\treturn adapter.fromPublisher(source);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn adapter.fromPublisher(Mono.from(adapter.toPublisher(result))\n\t\t\t\t\t\t\t.doOnSuccess(request::performCachePut));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn NOT_HANDLED;\n\t\t}"
  },
  "org.springframework.cache.interceptor.IGNORE_REACTIVESTREAMS_PROPERTY_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * System property that instructs Spring's caching infrastructure to ignore the\n\t * presence of Reactive Streams, in particular Reactor's {@link Mono}/{@link Flux}\n\t * in {@link org.springframework.cache.annotation.Cacheable} method return type\n\t * declarations.\n\t * <p>By default, as of 6.1, Reactive Streams Publishers such as Reactor's\n\t * {@link Mono}/{@link Flux} will be specifically processed for asynchronous\n\t * caching of their produced values rather than trying to cache the returned\n\t * {@code Publisher} instances themselves.\n\t * <p>Switch this flag to \"true\" in order to ignore Reactive Streams Publishers and\n\t * process them as regular return values through synchronous caching, restoring 6.0\n\t * behavior. Note that this is not recommended and only works in very limited\n\t * scenarios, e.g. with manual {@code Mono.cache()}/{@code Flux.cache()} calls.\n\t * @since 6.1.3\n\t * @see org.reactivestreams.Publisher\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "signature": "public String IGNORE_REACTIVESTREAMS_PROPERTY_NAME",
    "source_code": "\tpublic static final String IGNORE_REACTIVESTREAMS_PROPERTY_NAME = \"spring.cache.reactivestreams.ignore\";",
    "type": "String"
  },
  "org.springframework.cache.interceptor.NOT_HANDLED": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 1076
    },
    "signature": "public Object NOT_HANDLED",
    "source_code": "\t\tpublic static final Object NOT_HANDLED = new Object();",
    "type": "Object"
  },
  "org.springframework.cache.support.SimpleValueWrapper": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Straightforward implementation of {@link org.springframework.cache.Cache.ValueWrapper},\n * simply holding the value as given at construction and returning it from {@link #get()}.\n *\n * @author Costin Leau\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 31
    },
    "signature": "public class SimpleValueWrapper",
    "source_code": "public class SimpleValueWrapper implements ValueWrapper {\n\n\t@Nullable\n\tprivate final Object value;\n\n\n\t/**\n\t * Create a new SimpleValueWrapper instance for exposing the given value.\n\t * @param value the value to expose (may be {@code null})\n\t */\n\tpublic SimpleValueWrapper(@Nullable Object value) {\n\t\tthis.value = value;\n\t}\n\n\n\t/**\n\t * Simply returns the value as given at construction time.\n\t */\n\t@Override\n\t@Nullable\n\tpublic Object get() {\n\t\treturn this.value;\n\t}\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof ValueWrapper wrapper && Objects.equals(get(), wrapper.get())));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn Objects.hashCode(this.value);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"ValueWrapper for [\" + this.value + \"]\";\n\t}\n\n}"
  },
  "org.springframework.cache.support.SimpleValueWrapper#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof ValueWrapper wrapper && Objects.equals(get(), wrapper.get())));\n\t}"
  },
  "org.springframework.cache.support.SimpleValueWrapper#get()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Simply returns the value as given at construction time.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 51
    },
    "return": "Object",
    "signature": "public Object get()",
    "source_code": "\tpublic Object get() {\n\t\treturn this.value;\n\t}"
  },
  "org.springframework.cache.support.SimpleValueWrapper#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn Objects.hashCode(this.value);\n\t}"
  },
  "org.springframework.cache.support.SimpleValueWrapper#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn \"ValueWrapper for [\" + this.value + \"]\";\n\t}"
  },
  "org.springframework.context.annotation.CommonAnnotationBeanPostProcessor#applyTo(generationContext,beanRegistrationCode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode"
    ],
    "position": {
      "column": 1,
      "line": 880
    },
    "return": "void",
    "signature": "public void applyTo(GenerationContext generationContext, BeanRegistrationCode beanRegistrationCode)",
    "source_code": "\t\tpublic void applyTo(GenerationContext generationContext, BeanRegistrationCode beanRegistrationCode) {\n\t\t\tGeneratedClass generatedClass = generationContext.getGeneratedClasses()\n\t\t\t\t\t.addForFeatureComponent(\"ResourceAutowiring\", this.target, type -> {\n\t\t\t\t\t\ttype.addJavadoc(\"Resource autowiring for {@link $T}.\", this.target);\n\t\t\t\t\t\ttype.addModifiers(javax.lang.model.element.Modifier.PUBLIC);\n\t\t\t\t\t});\n\t\t\tGeneratedMethod generateMethod = generatedClass.getMethods().add(\"apply\", method -> {\n\t\t\t\tmethod.addJavadoc(\"Apply resource autowiring.\");\n\t\t\t\tmethod.addModifiers(javax.lang.model.element.Modifier.PUBLIC,\n\t\t\t\t\t\tjavax.lang.model.element.Modifier.STATIC);\n\t\t\t\tmethod.addParameter(RegisteredBean.class, REGISTERED_BEAN_PARAMETER);\n\t\t\t\tmethod.addParameter(this.target, INSTANCE_PARAMETER);\n\t\t\t\tmethod.returns(this.target);\n\t\t\t\tmethod.addCode(generateMethodCode(generatedClass.getName(),\n\t\t\t\t\t\tgenerationContext.getRuntimeHints()));\n\t\t\t});\n\t\t\tbeanRegistrationCode.addInstancePostProcessor(generateMethod.toMethodReference());\n\n\t\t\tregisterHints(generationContext.getRuntimeHints());\n\t\t}"
  },
  "org.springframework.context.annotation.CommonAnnotationBeanPostProcessor#isStatic()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 459
    },
    "return": "boolean",
    "signature": "public boolean isStatic()",
    "source_code": "\t\t\tpublic boolean isStatic() {\n\t\t\t\treturn false;\n\t\t\t}"
  },
  "org.springframework.context.annotation.CommonAnnotationBeanPostProcessor#processAheadOfTime(registeredBean)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean"
    ],
    "position": {
      "column": 1,
      "line": 318
    },
    "return": "BeanRegistrationAotContribution",
    "signature": "public BeanRegistrationAotContribution processAheadOfTime(RegisteredBean registeredBean)",
    "source_code": "\tpublic BeanRegistrationAotContribution processAheadOfTime(RegisteredBean registeredBean) {\n\t\tBeanRegistrationAotContribution parentAotContribution = super.processAheadOfTime(registeredBean);\n\t\tClass<?> beanClass = registeredBean.getBeanClass();\n\t\tString beanName = registeredBean.getBeanName();\n\t\tRootBeanDefinition beanDefinition = registeredBean.getMergedBeanDefinition();\n\t\tInjectionMetadata metadata = findResourceMetadata(beanName, beanClass,\n\t\t\t\tbeanDefinition.getPropertyValues());\n\t\tCollection<LookupElement> injectedElements = getInjectedElements(metadata,\n\t\t\t\tbeanDefinition.getPropertyValues());\n\t\tif (!ObjectUtils.isEmpty(injectedElements)) {\n\t\t\tAotContribution aotContribution = new AotContribution(beanClass, injectedElements,\n\t\t\t\t\tgetAutowireCandidateResolver(registeredBean));\n\t\t\treturn BeanRegistrationAotContribution.concat(parentAotContribution, aotContribution);\n\t\t}\n\t\treturn parentAotContribution;\n\t}"
  },
  "org.springframework.context.annotation.CommonAnnotationBeanPostProcessor#processInjection(bean)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * <em>Native</em> processing method for direct calls with an arbitrary target\n\t * instance, resolving all of its fields and methods which are annotated with\n\t * one of the supported 'resource' annotation types.\n\t * @param bean the target instance to process\n\t * @throws BeanCreationException if resource injection failed\n\t * @since 6.1.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "void",
    "signature": "public void processInjection(Object bean)",
    "source_code": "\tpublic void processInjection(Object bean) throws BeanCreationException {\n\t\tClass<?> clazz = bean.getClass();\n\t\tInjectionMetadata metadata = findResourceMetadata(clazz.getName(), clazz, null);\n\t\ttry {\n\t\t\tmetadata.inject(bean, null, null);\n\t\t}\n\t\tcatch (BeanCreationException ex) {\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\"Injection of resource dependencies failed for class [\" + clazz + \"]\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.context.annotation.CommonAnnotationBeanPostProcessor#releaseTarget(target)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target"
    ],
    "position": {
      "column": 1,
      "line": 467
    },
    "return": "void",
    "signature": "public void releaseTarget(Object target)",
    "source_code": "\t\t\tpublic void releaseTarget(Object target) {\n\t\t\t}"
  },
  "org.springframework.context.annotation.ComponentScanBeanDefinitionParser": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Parser for the {@code <context:component-scan/>} element.\n *\n * @author Mark Fisher\n * @author Ramnivas Laddad\n * @author Juergen Hoeller\n * @since 2.5\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "signature": "public class ComponentScanBeanDefinitionParser",
    "source_code": "public class ComponentScanBeanDefinitionParser implements BeanDefinitionParser {\n\n\tprivate static final String BASE_PACKAGE_ATTRIBUTE = \"base-package\";\n\n\tprivate static final String RESOURCE_PATTERN_ATTRIBUTE = \"resource-pattern\";\n\n\tprivate static final String USE_DEFAULT_FILTERS_ATTRIBUTE = \"use-default-filters\";\n\n\tprivate static final String ANNOTATION_CONFIG_ATTRIBUTE = \"annotation-config\";\n\n\tprivate static final String NAME_GENERATOR_ATTRIBUTE = \"name-generator\";\n\n\tprivate static final String SCOPE_RESOLVER_ATTRIBUTE = \"scope-resolver\";\n\n\tprivate static final String SCOPED_PROXY_ATTRIBUTE = \"scoped-proxy\";\n\n\tprivate static final String EXCLUDE_FILTER_ELEMENT = \"exclude-filter\";\n\n\tprivate static final String INCLUDE_FILTER_ELEMENT = \"include-filter\";\n\n\tprivate static final String FILTER_TYPE_ATTRIBUTE = \"type\";\n\n\tprivate static final String FILTER_EXPRESSION_ATTRIBUTE = \"expression\";\n\n\n\t@Override\n\t@Nullable\n\tpublic BeanDefinition parse(Element element, ParserContext parserContext) {\n\t\tString basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE);\n\t\tbasePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage);\n\t\tString[] basePackages = StringUtils.tokenizeToStringArray(basePackage,\n\t\t\t\tConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);\n\n\t\t// Actually scan for bean definitions and register them.\n\t\tClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);\n\t\tSet<BeanDefinitionHolder> beanDefinitions = scanner.doScan(basePackages);\n\t\tregisterComponents(parserContext.getReaderContext(), beanDefinitions, element);\n\n\t\treturn null;\n\t}\n\n\tprotected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element) {\n\t\tboolean useDefaultFilters = true;\n\t\tif (element.hasAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)) {\n\t\t\tuseDefaultFilters = Boolean.parseBoolean(element.getAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE));\n\t\t}\n\n\t\t// Delegate bean definition registration to scanner class.\n\t\tClassPathBeanDefinitionScanner scanner = createScanner(parserContext.getReaderContext(), useDefaultFilters);\n\t\tscanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults());\n\t\tscanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns());\n\n\t\tif (element.hasAttribute(RESOURCE_PATTERN_ATTRIBUTE)) {\n\t\t\tscanner.setResourcePattern(element.getAttribute(RESOURCE_PATTERN_ATTRIBUTE));\n\t\t}\n\n\t\ttry {\n\t\t\tparseBeanNameGenerator(element, scanner);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tparserContext.getReaderContext().error(ex.getMessage(), parserContext.extractSource(element), ex.getCause());\n\t\t}\n\n\t\ttry {\n\t\t\tparseScope(element, scanner);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tparserContext.getReaderContext().error(ex.getMessage(), parserContext.extractSource(element), ex.getCause());\n\t\t}\n\n\t\tparseTypeFilters(element, scanner, parserContext);\n\n\t\treturn scanner;\n\t}\n\n\tprotected ClassPathBeanDefinitionScanner createScanner(XmlReaderContext readerContext, boolean useDefaultFilters) {\n\t\treturn new ClassPathBeanDefinitionScanner(readerContext.getRegistry(), useDefaultFilters,\n\t\t\t\treaderContext.getEnvironment(), readerContext.getResourceLoader());\n\t}\n\n\tprotected void registerComponents(\n\t\t\tXmlReaderContext readerContext, Set<BeanDefinitionHolder> beanDefinitions, Element element) {\n\n\t\tObject source = readerContext.extractSource(element);\n\t\tCompositeComponentDefinition compositeDef = new CompositeComponentDefinition(element.getTagName(), source);\n\n\t\tfor (BeanDefinitionHolder beanDefHolder : beanDefinitions) {\n\t\t\tcompositeDef.addNestedComponent(new BeanComponentDefinition(beanDefHolder));\n\t\t}\n\n\t\t// Register annotation config processors, if necessary.\n\t\tboolean annotationConfig = true;\n\t\tif (element.hasAttribute(ANNOTATION_CONFIG_ATTRIBUTE)) {\n\t\t\tannotationConfig = Boolean.parseBoolean(element.getAttribute(ANNOTATION_CONFIG_ATTRIBUTE));\n\t\t}\n\t\tif (annotationConfig) {\n\t\t\tSet<BeanDefinitionHolder> processorDefinitions =\n\t\t\t\t\tAnnotationConfigUtils.registerAnnotationConfigProcessors(readerContext.getRegistry(), source);\n\t\t\tfor (BeanDefinitionHolder processorDefinition : processorDefinitions) {\n\t\t\t\tcompositeDef.addNestedComponent(new BeanComponentDefinition(processorDefinition));\n\t\t\t}\n\t\t}\n\n\t\treaderContext.fireComponentRegistered(compositeDef);\n\t}\n\n\tprotected void parseBeanNameGenerator(Element element, ClassPathBeanDefinitionScanner scanner) {\n\t\tif (element.hasAttribute(NAME_GENERATOR_ATTRIBUTE)) {\n\t\t\tBeanNameGenerator beanNameGenerator = (BeanNameGenerator) instantiateUserDefinedStrategy(\n\t\t\t\t\telement.getAttribute(NAME_GENERATOR_ATTRIBUTE), BeanNameGenerator.class,\n\t\t\t\t\tscanner.getResourceLoader().getClassLoader());\n\t\t\tscanner.setBeanNameGenerator(beanNameGenerator);\n\t\t}\n\t}\n\n\tprotected void parseScope(Element element, ClassPathBeanDefinitionScanner scanner) {\n\t\t// Register ScopeMetadataResolver if class name provided.\n\t\tif (element.hasAttribute(SCOPE_RESOLVER_ATTRIBUTE)) {\n\t\t\tif (element.hasAttribute(SCOPED_PROXY_ATTRIBUTE)) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Cannot define both 'scope-resolver' and 'scoped-proxy' on <component-scan> tag\");\n\t\t\t}\n\t\t\tScopeMetadataResolver scopeMetadataResolver = (ScopeMetadataResolver) instantiateUserDefinedStrategy(\n\t\t\t\t\telement.getAttribute(SCOPE_RESOLVER_ATTRIBUTE), ScopeMetadataResolver.class,\n\t\t\t\t\tscanner.getResourceLoader().getClassLoader());\n\t\t\tscanner.setScopeMetadataResolver(scopeMetadataResolver);\n\t\t}\n\n\t\tif (element.hasAttribute(SCOPED_PROXY_ATTRIBUTE)) {\n\t\t\tString mode = element.getAttribute(SCOPED_PROXY_ATTRIBUTE);\n\t\t\tswitch (mode) {\n\t\t\t\tcase \"targetClass\" -> scanner.setScopedProxyMode(ScopedProxyMode.TARGET_CLASS);\n\t\t\t\tcase \"interfaces\" -> scanner.setScopedProxyMode(ScopedProxyMode.INTERFACES);\n\t\t\t\tcase \"no\" -> scanner.setScopedProxyMode(ScopedProxyMode.NO);\n\t\t\t\tdefault -> throw new IllegalArgumentException(\"scoped-proxy only supports 'no', 'interfaces' and 'targetClass'\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected void parseTypeFilters(Element element, ClassPathBeanDefinitionScanner scanner, ParserContext parserContext) {\n\t\t// Parse exclude and include filter elements.\n\t\tClassLoader classLoader = scanner.getResourceLoader().getClassLoader();\n\t\tNodeList nodeList = element.getChildNodes();\n\t\tfor (int i = 0; i < nodeList.getLength(); i++) {\n\t\t\tNode node = nodeList.item(i);\n\t\t\tif (node.getNodeType() == Node.ELEMENT_NODE) {\n\t\t\t\tString localName = parserContext.getDelegate().getLocalName(node);\n\t\t\t\ttry {\n\t\t\t\t\tif (INCLUDE_FILTER_ELEMENT.equals(localName)) {\n\t\t\t\t\t\tTypeFilter typeFilter = createTypeFilter((Element) node, classLoader, parserContext);\n\t\t\t\t\t\tscanner.addIncludeFilter(typeFilter);\n\t\t\t\t\t}\n\t\t\t\t\telse if (EXCLUDE_FILTER_ELEMENT.equals(localName)) {\n\t\t\t\t\t\tTypeFilter typeFilter = createTypeFilter((Element) node, classLoader, parserContext);\n\t\t\t\t\t\tscanner.addExcludeFilter(typeFilter);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\t\tparserContext.getReaderContext().warning(\n\t\t\t\t\t\t\t\"Ignoring non-present type filter class: \" + ex, parserContext.extractSource(element));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tparserContext.getReaderContext().error(\n\t\t\t\t\t\t\tex.getMessage(), parserContext.extractSource(element), ex.getCause());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprotected TypeFilter createTypeFilter(Element element, @Nullable ClassLoader classLoader,\n\t\t\tParserContext parserContext) throws ClassNotFoundException {\n\n\t\tString filterType = element.getAttribute(FILTER_TYPE_ATTRIBUTE);\n\t\tString expression = element.getAttribute(FILTER_EXPRESSION_ATTRIBUTE);\n\t\texpression = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(expression);\n\t\tswitch (filterType) {\n\t\t\tcase \"annotation\" -> {\n\t\t\t\treturn new AnnotationTypeFilter((Class<Annotation>) ClassUtils.forName(expression, classLoader));\n\t\t\t}\n\t\t\tcase \"assignable\" -> {\n\t\t\t\treturn new AssignableTypeFilter(ClassUtils.forName(expression, classLoader));\n\t\t\t}\n\t\t\tcase \"aspectj\" -> {\n\t\t\t\treturn new AspectJTypeFilter(expression, classLoader);\n\t\t\t}\n\t\t\tcase \"regex\" -> {\n\t\t\t\treturn new RegexPatternTypeFilter(Pattern.compile(expression));\n\t\t\t}\n\t\t\tcase \"custom\" -> {\n\t\t\t\tClass<?> filterClass = ClassUtils.forName(expression, classLoader);\n\t\t\t\tif (!TypeFilter.class.isAssignableFrom(filterClass)) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\t\"Class is not assignable to [\" + TypeFilter.class.getName() + \"]: \" + expression);\n\t\t\t\t}\n\t\t\t\treturn (TypeFilter) BeanUtils.instantiateClass(filterClass);\n\t\t\t}\n\t\t\tdefault -> throw new IllegalArgumentException(\"Unsupported filter type: \" + filterType);\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate Object instantiateUserDefinedStrategy(\n\t\t\tString className, Class<?> strategyType, @Nullable ClassLoader classLoader) {\n\n\t\tObject result;\n\t\ttry {\n\t\t\tresult = ReflectionUtils.accessibleConstructor(ClassUtils.forName(className, classLoader)).newInstance();\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\tthrow new IllegalArgumentException(\"Class [\" + className + \"] for strategy [\" +\n\t\t\t\t\tstrategyType.getName() + \"] not found\", ex);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new IllegalArgumentException(\"Unable to instantiate class [\" + className + \"] for strategy [\" +\n\t\t\t\t\tstrategyType.getName() + \"]: a zero-argument constructor is required\", ex);\n\t\t}\n\n\t\tif (!strategyType.isAssignableFrom(result.getClass())) {\n\t\t\tthrow new IllegalArgumentException(\"Provided class name must be an implementation of \" + strategyType);\n\t\t}\n\t\treturn result;\n\t}\n\n}"
  },
  "org.springframework.context.annotation.ComponentScanBeanDefinitionParser#configureScanner(parserContext,element)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parserContext",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "ClassPathBeanDefinitionScanner",
    "signature": "protected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element)",
    "source_code": "\tprotected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element) {\n\t\tboolean useDefaultFilters = true;\n\t\tif (element.hasAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)) {\n\t\t\tuseDefaultFilters = Boolean.parseBoolean(element.getAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE));\n\t\t}\n\n\t\t// Delegate bean definition registration to scanner class.\n\t\tClassPathBeanDefinitionScanner scanner = createScanner(parserContext.getReaderContext(), useDefaultFilters);\n\t\tscanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults());\n\t\tscanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns());\n\n\t\tif (element.hasAttribute(RESOURCE_PATTERN_ATTRIBUTE)) {\n\t\t\tscanner.setResourcePattern(element.getAttribute(RESOURCE_PATTERN_ATTRIBUTE));\n\t\t}\n\n\t\ttry {\n\t\t\tparseBeanNameGenerator(element, scanner);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tparserContext.getReaderContext().error(ex.getMessage(), parserContext.extractSource(element), ex.getCause());\n\t\t}\n\n\t\ttry {\n\t\t\tparseScope(element, scanner);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tparserContext.getReaderContext().error(ex.getMessage(), parserContext.extractSource(element), ex.getCause());\n\t\t}\n\n\t\tparseTypeFilters(element, scanner, parserContext);\n\n\t\treturn scanner;\n\t}"
  },
  "org.springframework.context.annotation.ComponentScanBeanDefinitionParser#createScanner(readerContext,useDefaultFilters)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "readerContext",
      "useDefaultFilters"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "ClassPathBeanDefinitionScanner",
    "signature": "protected ClassPathBeanDefinitionScanner createScanner(XmlReaderContext readerContext, boolean useDefaultFilters)",
    "source_code": "\tprotected ClassPathBeanDefinitionScanner createScanner(XmlReaderContext readerContext, boolean useDefaultFilters) {\n\t\treturn new ClassPathBeanDefinitionScanner(readerContext.getRegistry(), useDefaultFilters,\n\t\t\t\treaderContext.getEnvironment(), readerContext.getResourceLoader());\n\t}"
  },
  "org.springframework.context.annotation.ComponentScanBeanDefinitionParser#createTypeFilter(element,classLoader,parserContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "element",
      "classLoader",
      "parserContext"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "TypeFilter",
    "signature": "protected TypeFilter createTypeFilter(Element element, @Nullable ClassLoader classLoader,\n\t\t\tParserContext parserContext)",
    "source_code": "\tprotected TypeFilter createTypeFilter(Element element, @Nullable ClassLoader classLoader,"
  },
  "org.springframework.context.annotation.ComponentScanBeanDefinitionParser#parse(element,parserContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "parserContext"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "BeanDefinition",
    "signature": "public BeanDefinition parse(Element element, ParserContext parserContext)",
    "source_code": "\tpublic BeanDefinition parse(Element element, ParserContext parserContext) {\n\t\tString basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE);\n\t\tbasePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage);\n\t\tString[] basePackages = StringUtils.tokenizeToStringArray(basePackage,\n\t\t\t\tConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);\n\n\t\t// Actually scan for bean definitions and register them.\n\t\tClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);\n\t\tSet<BeanDefinitionHolder> beanDefinitions = scanner.doScan(basePackages);\n\t\tregisterComponents(parserContext.getReaderContext(), beanDefinitions, element);\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.context.annotation.ComponentScanBeanDefinitionParser#parseBeanNameGenerator(element,scanner)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "element",
      "scanner"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "void",
    "signature": "protected void parseBeanNameGenerator(Element element, ClassPathBeanDefinitionScanner scanner)",
    "source_code": "\tprotected void parseBeanNameGenerator(Element element, ClassPathBeanDefinitionScanner scanner) {\n\t\tif (element.hasAttribute(NAME_GENERATOR_ATTRIBUTE)) {\n\t\t\tBeanNameGenerator beanNameGenerator = (BeanNameGenerator) instantiateUserDefinedStrategy(\n\t\t\t\t\telement.getAttribute(NAME_GENERATOR_ATTRIBUTE), BeanNameGenerator.class,\n\t\t\t\t\tscanner.getResourceLoader().getClassLoader());\n\t\t\tscanner.setBeanNameGenerator(beanNameGenerator);\n\t\t}\n\t}"
  },
  "org.springframework.context.annotation.ComponentScanBeanDefinitionParser#parseScope(element,scanner)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "element",
      "scanner"
    ],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "void",
    "signature": "protected void parseScope(Element element, ClassPathBeanDefinitionScanner scanner)",
    "source_code": "\tprotected void parseScope(Element element, ClassPathBeanDefinitionScanner scanner) {\n\t\t// Register ScopeMetadataResolver if class name provided.\n\t\tif (element.hasAttribute(SCOPE_RESOLVER_ATTRIBUTE)) {\n\t\t\tif (element.hasAttribute(SCOPED_PROXY_ATTRIBUTE)) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Cannot define both 'scope-resolver' and 'scoped-proxy' on <component-scan> tag\");\n\t\t\t}\n\t\t\tScopeMetadataResolver scopeMetadataResolver = (ScopeMetadataResolver) instantiateUserDefinedStrategy(\n\t\t\t\t\telement.getAttribute(SCOPE_RESOLVER_ATTRIBUTE), ScopeMetadataResolver.class,\n\t\t\t\t\tscanner.getResourceLoader().getClassLoader());\n\t\t\tscanner.setScopeMetadataResolver(scopeMetadataResolver);\n\t\t}\n\n\t\tif (element.hasAttribute(SCOPED_PROXY_ATTRIBUTE)) {\n\t\t\tString mode = element.getAttribute(SCOPED_PROXY_ATTRIBUTE);\n\t\t\tswitch (mode) {\n\t\t\t\tcase \"targetClass\" -> scanner.setScopedProxyMode(ScopedProxyMode.TARGET_CLASS);\n\t\t\t\tcase \"interfaces\" -> scanner.setScopedProxyMode(ScopedProxyMode.INTERFACES);\n\t\t\t\tcase \"no\" -> scanner.setScopedProxyMode(ScopedProxyMode.NO);\n\t\t\t\tdefault -> throw new IllegalArgumentException(\"scoped-proxy only supports 'no', 'interfaces' and 'targetClass'\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.context.annotation.ComponentScanBeanDefinitionParser#parseTypeFilters(element,scanner,parserContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "element",
      "scanner",
      "parserContext"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "void",
    "signature": "protected void parseTypeFilters(Element element, ClassPathBeanDefinitionScanner scanner, ParserContext parserContext)",
    "source_code": "\tprotected void parseTypeFilters(Element element, ClassPathBeanDefinitionScanner scanner, ParserContext parserContext) {\n\t\t// Parse exclude and include filter elements.\n\t\tClassLoader classLoader = scanner.getResourceLoader().getClassLoader();\n\t\tNodeList nodeList = element.getChildNodes();\n\t\tfor (int i = 0; i < nodeList.getLength(); i++) {\n\t\t\tNode node = nodeList.item(i);\n\t\t\tif (node.getNodeType() == Node.ELEMENT_NODE) {\n\t\t\t\tString localName = parserContext.getDelegate().getLocalName(node);\n\t\t\t\ttry {\n\t\t\t\t\tif (INCLUDE_FILTER_ELEMENT.equals(localName)) {\n\t\t\t\t\t\tTypeFilter typeFilter = createTypeFilter((Element) node, classLoader, parserContext);\n\t\t\t\t\t\tscanner.addIncludeFilter(typeFilter);\n\t\t\t\t\t}\n\t\t\t\t\telse if (EXCLUDE_FILTER_ELEMENT.equals(localName)) {\n\t\t\t\t\t\tTypeFilter typeFilter = createTypeFilter((Element) node, classLoader, parserContext);\n\t\t\t\t\t\tscanner.addExcludeFilter(typeFilter);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\t\tparserContext.getReaderContext().warning(\n\t\t\t\t\t\t\t\"Ignoring non-present type filter class: \" + ex, parserContext.extractSource(element));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tparserContext.getReaderContext().error(\n\t\t\t\t\t\t\tex.getMessage(), parserContext.extractSource(element), ex.getCause());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.context.annotation.ComponentScanBeanDefinitionParser#registerComponents(readerContext,beanDefinitions,element)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "readerContext",
      "beanDefinitions",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "void",
    "signature": "protected void registerComponents(XmlReaderContext readerContext, Set<BeanDefinitionHolder> beanDefinitions, Element element)",
    "source_code": "\tprotected void registerComponents("
  },
  "org.springframework.context.annotation.ConfigurationClassPostProcessor#generateInstanceSupplierCode(generationContext,beanRegistrationCode,allowDirectSupplierShortcut)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "allowDirectSupplierShortcut"
    ],
    "position": {
      "column": 1,
      "line": 792
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\t\tBeanRegistrationCode beanRegistrationCode,\n\t\t\t\tboolean allowDirectSupplierShortcut)",
    "source_code": "\t\tpublic CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,"
  },
  "org.springframework.context.annotation.ConfigurationClassPostProcessor#generateInstanceSupplierCode(generationContext,beanRegistrationCode,constructorOrFactoryMethod,allowDirectSupplierShortcut)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "constructorOrFactoryMethod",
      "allowDirectSupplierShortcut"
    ],
    "position": {
      "column": 1,
      "line": 771
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\t\tBeanRegistrationCode beanRegistrationCode, Executable constructorOrFactoryMethod,\n\t\t\t\tboolean allowDirectSupplierShortcut)",
    "source_code": "\t\tpublic CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,"
  },
  "org.springframework.context.annotation.IGNORE_CLASSFORMAT_PROPERTY_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * System property that instructs Spring to ignore class format exceptions during\n\t * classpath scanning, in particular for unsupported class file versions.\n\t * By default, such a class format mismatch leads to a classpath scanning failure.\n\t * @since 6.1.2\n\t * @see ClassFormatException\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "signature": "public String IGNORE_CLASSFORMAT_PROPERTY_NAME",
    "source_code": "\tpublic static final String IGNORE_CLASSFORMAT_PROPERTY_NAME = \"spring.classformat.ignore\";",
    "type": "String"
  },
  "org.springframework.context.annotation.LoadTimeWeavingConfiguration": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code @Configuration} class that registers a {@link LoadTimeWeaver} bean.\n *\n * <p>This configuration class is automatically imported when using the\n * {@link EnableLoadTimeWeaving} annotation. See {@code @EnableLoadTimeWeaving}\n * javadoc for complete usage details.\n *\n * @author Chris Beams\n * @since 3.1\n * @see LoadTimeWeavingConfigurer\n * @see ConfigurableApplicationContext#LOAD_TIME_WEAVER_BEAN_NAME\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "signature": "public class LoadTimeWeavingConfiguration",
    "source_code": "public class LoadTimeWeavingConfiguration implements ImportAware, BeanClassLoaderAware {\n\n\t@Nullable\n\tprivate AnnotationAttributes enableLTW;\n\n\t@Nullable\n\tprivate LoadTimeWeavingConfigurer ltwConfigurer;\n\n\t@Nullable\n\tprivate ClassLoader beanClassLoader;\n\n\n\t@Override\n\tpublic void setImportMetadata(AnnotationMetadata importMetadata) {\n\t\tthis.enableLTW = AnnotationConfigUtils.attributesFor(importMetadata, EnableLoadTimeWeaving.class);\n\t\tif (this.enableLTW == null) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"@EnableLoadTimeWeaving is not present on importing class \" + importMetadata.getClassName());\n\t\t}\n\t}\n\n\t@Autowired(required = false)\n\tpublic void setLoadTimeWeavingConfigurer(LoadTimeWeavingConfigurer ltwConfigurer) {\n\t\tthis.ltwConfigurer = ltwConfigurer;\n\t}\n\n\t@Override\n\tpublic void setBeanClassLoader(ClassLoader beanClassLoader) {\n\t\tthis.beanClassLoader = beanClassLoader;\n\t}\n\n\n\t@Bean(name = ConfigurableApplicationContext.LOAD_TIME_WEAVER_BEAN_NAME)\n\t@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\n\tpublic LoadTimeWeaver loadTimeWeaver() {\n\t\tAssert.state(this.beanClassLoader != null, \"No ClassLoader set\");\n\t\tLoadTimeWeaver loadTimeWeaver = null;\n\n\t\tif (this.ltwConfigurer != null) {\n\t\t\t// The user has provided a custom LoadTimeWeaver instance\n\t\t\tloadTimeWeaver = this.ltwConfigurer.getLoadTimeWeaver();\n\t\t}\n\n\t\tif (loadTimeWeaver == null) {\n\t\t\t// No custom LoadTimeWeaver provided -> fall back to the default\n\t\t\tloadTimeWeaver = new DefaultContextLoadTimeWeaver(this.beanClassLoader);\n\t\t}\n\n\t\tif (this.enableLTW != null) {\n\t\t\tAspectJWeaving aspectJWeaving = this.enableLTW.getEnum(\"aspectjWeaving\");\n\t\t\tswitch (aspectJWeaving) {\n\t\t\t\tcase DISABLED -> {\n\t\t\t\t\t// AJ weaving is disabled -> do nothing\n\t\t\t\t}\n\t\t\t\tcase AUTODETECT -> {\n\t\t\t\t\tif (this.beanClassLoader.getResource(AspectJWeavingEnabler.ASPECTJ_AOP_XML_RESOURCE) == null) {\n\t\t\t\t\t\t// No aop.xml present on the classpath -> treat as 'disabled'\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// aop.xml is present on the classpath -> enable\n\t\t\t\t\tAspectJWeavingEnabler.enableAspectJWeaving(loadTimeWeaver, this.beanClassLoader);\n\t\t\t\t}\n\t\t\t\tcase ENABLED -> {\n\t\t\t\t\tAspectJWeavingEnabler.enableAspectJWeaving(loadTimeWeaver, this.beanClassLoader);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn loadTimeWeaver;\n\t}\n\n}"
  },
  "org.springframework.context.annotation.LoadTimeWeavingConfiguration#loadTimeWeaver()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "LoadTimeWeaver",
    "signature": "public LoadTimeWeaver loadTimeWeaver()",
    "source_code": "\tpublic LoadTimeWeaver loadTimeWeaver() {\n\t\tAssert.state(this.beanClassLoader != null, \"No ClassLoader set\");\n\t\tLoadTimeWeaver loadTimeWeaver = null;\n\n\t\tif (this.ltwConfigurer != null) {\n\t\t\t// The user has provided a custom LoadTimeWeaver instance\n\t\t\tloadTimeWeaver = this.ltwConfigurer.getLoadTimeWeaver();\n\t\t}\n\n\t\tif (loadTimeWeaver == null) {\n\t\t\t// No custom LoadTimeWeaver provided -> fall back to the default\n\t\t\tloadTimeWeaver = new DefaultContextLoadTimeWeaver(this.beanClassLoader);\n\t\t}\n\n\t\tif (this.enableLTW != null) {\n\t\t\tAspectJWeaving aspectJWeaving = this.enableLTW.getEnum(\"aspectjWeaving\");\n\t\t\tswitch (aspectJWeaving) {\n\t\t\t\tcase DISABLED -> {\n\t\t\t\t\t// AJ weaving is disabled -> do nothing\n\t\t\t\t}\n\t\t\t\tcase AUTODETECT -> {\n\t\t\t\t\tif (this.beanClassLoader.getResource(AspectJWeavingEnabler.ASPECTJ_AOP_XML_RESOURCE) == null) {\n\t\t\t\t\t\t// No aop.xml present on the classpath -> treat as 'disabled'\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// aop.xml is present on the classpath -> enable\n\t\t\t\t\tAspectJWeavingEnabler.enableAspectJWeaving(loadTimeWeaver, this.beanClassLoader);\n\t\t\t\t}\n\t\t\t\tcase ENABLED -> {\n\t\t\t\t\tAspectJWeavingEnabler.enableAspectJWeaving(loadTimeWeaver, this.beanClassLoader);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn loadTimeWeaver;\n\t}"
  },
  "org.springframework.context.annotation.LoadTimeWeavingConfiguration#setBeanClassLoader(beanClassLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClassLoader"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "void",
    "signature": "public void setBeanClassLoader(ClassLoader beanClassLoader)",
    "source_code": "\tpublic void setBeanClassLoader(ClassLoader beanClassLoader) {\n\t\tthis.beanClassLoader = beanClassLoader;\n\t}"
  },
  "org.springframework.context.annotation.LoadTimeWeavingConfiguration#setImportMetadata(importMetadata)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "importMetadata"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "void",
    "signature": "public void setImportMetadata(AnnotationMetadata importMetadata)",
    "source_code": "\tpublic void setImportMetadata(AnnotationMetadata importMetadata) {\n\t\tthis.enableLTW = AnnotationConfigUtils.attributesFor(importMetadata, EnableLoadTimeWeaving.class);\n\t\tif (this.enableLTW == null) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"@EnableLoadTimeWeaving is not present on importing class \" + importMetadata.getClassName());\n\t\t}\n\t}"
  },
  "org.springframework.context.annotation.LoadTimeWeavingConfiguration#setLoadTimeWeavingConfigurer(ltwConfigurer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ltwConfigurer"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "void",
    "signature": "public void setLoadTimeWeavingConfigurer(LoadTimeWeavingConfigurer ltwConfigurer)",
    "source_code": "\tpublic void setLoadTimeWeavingConfigurer(LoadTimeWeavingConfigurer ltwConfigurer) {\n\t\tthis.ltwConfigurer = ltwConfigurer;\n\t}"
  },
  "org.springframework.context.event.ApplicationListenerMethodAdapter#shouldHandle(event)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the listener method would actually handle the given\n\t * event, checking if the condition matches.\n\t * @param event the event to process through the listener method\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "event"
    ],
    "position": {
      "column": 1,
      "line": 253
    },
    "return": "boolean",
    "signature": "public boolean shouldHandle(ApplicationEvent event)",
    "source_code": "\tpublic boolean shouldHandle(ApplicationEvent event) {\n\t\treturn shouldHandle(event, resolveArguments(event));\n\t}"
  },
  "org.springframework.context.support.CHECKPOINT_PROPERTY_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Property name for a common context checkpoint: {@value}.\n\t * @since 6.1\n\t * @see #ON_REFRESH_VALUE\n\t * @see org.crac.Core#checkpointRestore()\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "signature": "public String CHECKPOINT_PROPERTY_NAME",
    "source_code": "\tpublic static final String CHECKPOINT_PROPERTY_NAME = \"spring.context.checkpoint\";",
    "type": "String"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#afterRestore(context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 579
    },
    "return": "void",
    "signature": "public void afterRestore(org.crac.Context<? extends org.crac.Resource> context)",
    "source_code": "\t\tpublic void afterRestore(org.crac.Context<? extends org.crac.Resource> context) {\n\t\t\tlogger.info(\"Restarting Spring-managed lifecycle beans after JVM restore\");\n\t\t\trestartAfterStop();\n\n\t\t\t// Barrier for prevent-shutdown thread not needed anymore\n\t\t\tthis.barrier = null;\n\n\t\t\tif (!checkpointOnRefresh) {\n\t\t\t\tlogger.info(\"Spring-managed lifecycle restart completed (restored JVM running for \" +\n\t\t\t\t\t\tCRaCMXBean.getCRaCMXBean().getUptimeSinceRestore() + \" ms)\");\n\t\t\t}\n\t\t}"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#beforeCheckpoint(context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 560
    },
    "return": "void",
    "signature": "public void beforeCheckpoint(org.crac.Context<? extends org.crac.Resource> context)",
    "source_code": "\t\tpublic void beforeCheckpoint(org.crac.Context<? extends org.crac.Resource> context) {\n\t\t\t// A non-daemon thread for preventing an accidental JVM shutdown before the checkpoint\n\t\t\tthis.barrier = new CyclicBarrier(2);\n\n\t\t\tThread thread = new Thread(() -> {\n\t\t\t\tawaitPreventShutdownBarrier();\n\t\t\t\t// Checkpoint happens here\n\t\t\t\tawaitPreventShutdownBarrier();\n\t\t\t}, \"prevent-shutdown\");\n\n\t\t\tthread.setDaemon(false);\n\t\t\tthread.start();\n\t\t\tawaitPreventShutdownBarrier();\n\n\t\t\tlogger.debug(\"Stopping Spring-managed lifecycle beans before JVM checkpoint\");\n\t\t\tstopForRestart();\n\t\t}"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#checkpointRestore()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 529
    },
    "return": "void",
    "signature": "public void checkpointRestore()",
    "source_code": "\t\tpublic void checkpointRestore() {\n\t\t\tlogger.info(\"Triggering JVM checkpoint/restore\");\n\t\t\ttry {\n\t\t\t\tCore.checkpointRestore();\n\t\t\t}\n\t\t\tcatch (UnsupportedOperationException ex) {\n\t\t\t\tthrow new ApplicationContextException(\"CRaC checkpoint not supported on current JVM\", ex);\n\t\t\t}\n\t\t\tcatch (CheckpointException ex) {\n\t\t\t\tthrow new ApplicationContextException(\"Failed to take CRaC checkpoint on refresh\", ex);\n\t\t\t}\n\t\t\tcatch (RestoreException ex) {\n\t\t\t\tthrow new ApplicationContextException(\"Failed to restore CRaC checkpoint on refresh\", ex);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#compareTo(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 417
    },
    "return": "int",
    "signature": "public int compareTo(LifecycleGroupMember other)",
    "source_code": "\t\tpublic int compareTo(LifecycleGroupMember other) {\n\t\t\tint thisPhase = getPhase(this.bean);\n\t\t\tint otherPhase = getPhase(other.bean);\n\t\t\treturn Integer.compare(thisPhase, otherPhase);\n\t\t}"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#registerResource()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 522
    },
    "return": "Object",
    "signature": "public Object registerResource()",
    "source_code": "\t\tpublic Object registerResource() {\n\t\t\tlogger.debug(\"Registering JVM checkpoint/restore callback for Spring-managed lifecycle beans\");\n\t\t\tCracResourceAdapter resourceAdapter = new CracResourceAdapter();\n\t\t\torg.crac.Core.getGlobalContext().register(resourceAdapter);\n\t\t\treturn resourceAdapter;\n\t\t}"
  },
  "org.springframework.context.support.EXIT_PROPERTY_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Property name for terminating the JVM when the context reaches a specific phase: {@value}.\n\t * @since 6.1\n\t * @see #ON_REFRESH_VALUE\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "signature": "public String EXIT_PROPERTY_NAME",
    "source_code": "\tpublic static final String EXIT_PROPERTY_NAME = \"spring.context.exit\";",
    "type": "String"
  },
  "org.springframework.context.support.GenericApplicationContext#isBeanDefinitionOverridable(beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 364
    },
    "return": "boolean",
    "signature": "public boolean isBeanDefinitionOverridable(String beanName)",
    "source_code": "\tpublic boolean isBeanDefinitionOverridable(String beanName) {\n\t\treturn this.beanFactory.isBeanDefinitionOverridable(beanName);\n\t}"
  },
  "org.springframework.context.support.ON_REFRESH_VALUE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Recognized value for the context checkpoint and exit properties: {@value}.\n\t * @since 6.1\n\t * @see #CHECKPOINT_PROPERTY_NAME\n\t * @see #EXIT_PROPERTY_NAME\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "signature": "public String ON_REFRESH_VALUE",
    "source_code": "\tpublic static final String ON_REFRESH_VALUE = \"onRefresh\";",
    "type": "String"
  },
  "org.springframework.context.support.ReloadableResourceBundleMessageSource#collectPropertiesToMerge(locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the properties to merge based on the specified basenames.\n\t * @param locale the locale\n\t * @return the list of properties holders\n\t * @since 6.1.4\n\t * @see #getBasenameSet()\n\t * @see #calculateAllFilenames\n\t * @see #mergeProperties\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "List<PropertiesHolder>",
    "signature": "protected List<PropertiesHolder> collectPropertiesToMerge(Locale locale)",
    "source_code": "\tprotected List<PropertiesHolder> collectPropertiesToMerge(Locale locale) {\n\t\tString[] basenames = StringUtils.toStringArray(getBasenameSet());\n\t\tList<PropertiesHolder> holders = new ArrayList<>(basenames.length);\n\t\tfor (int i = basenames.length - 1; i >= 0; i--) {\n\t\t\tList<String> filenames = calculateAllFilenames(basenames[i], locale);\n\t\t\tfor (int j = filenames.size() - 1; j >= 0; j--) {\n\t\t\t\tString filename = filenames.get(j);\n\t\t\t\tPropertiesHolder propHolder = getProperties(filename);\n\t\t\t\tif (propHolder.getProperties() != null) {\n\t\t\t\t\tholders.add(propHolder);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn holders;\n\t}"
  },
  "org.springframework.context.support.ReloadableResourceBundleMessageSource#mergeProperties(holders)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Merge the given properties holders into a single holder.\n\t * @param holders the list of properties holders\n\t * @return a single merged properties holder\n\t * @since 6.1.4\n\t * @see #newProperties()\n\t * @see #getMergedProperties\n\t * @see #collectPropertiesToMerge\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "holders"
    ],
    "position": {
      "column": 1,
      "line": 305
    },
    "return": "PropertiesHolder",
    "signature": "protected PropertiesHolder mergeProperties(List<PropertiesHolder> holders)",
    "source_code": "\tprotected PropertiesHolder mergeProperties(List<PropertiesHolder> holders) {\n\t\tProperties mergedProps = newProperties();\n\t\tlong latestTimestamp = -1;\n\t\tfor (PropertiesHolder holder : holders) {\n\t\t\tmergedProps.putAll(holder.getProperties());\n\t\t\tif (holder.getFileTimestamp() > latestTimestamp) {\n\t\t\t\tlatestTimestamp = holder.getFileTimestamp();\n\t\t\t}\n\t\t}\n\t\treturn new PropertiesHolder(mergedProps, latestTimestamp);\n\t}"
  },
  "org.springframework.context.support.ReloadableResourceBundleMessageSource#resolveResource(filename)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the specified bundle {@code filename} into a concrete {@link Resource},\n\t * potentially checking multiple sources or file extensions.\n\t * <p>If no suitable concrete {@code Resource} can be resolved, this method\n\t * returns a {@code Resource} for which {@link Resource#exists()} returns\n\t * {@code false}, which gets subsequently ignored.\n\t * <p>This can be leveraged to check the last modification timestamp or to load\n\t * properties from alternative sources &mdash; for example, from an XML BLOB\n\t * in a database, or from properties serialized using a custom format such as\n\t * JSON.\n\t * <p>The default implementation delegates to the configured\n\t * {@link #setResourceLoader(ResourceLoader) ResourceLoader} to resolve\n\t * resources, checking in order for existing {@code Resource} with extensions defined\n\t * by {@link #setFileExtensions(List)} ({@code .properties} and {@code .xml}\n\t * by default).\n\t * <p>When overriding this method, {@link #loadProperties(Resource, String)}\n\t * <strong>must</strong> be capable of loading properties from any type of\n\t * {@code Resource} returned by this method. As a consequence, implementors\n\t * are strongly encouraged to also override {@code loadProperties()}.\n\t * <p>As an alternative to overriding this method, you can configure a\n\t * {@link #setPropertiesPersister(PropertiesPersister) PropertiesPersister}\n\t * that is capable of dealing with all resources returned by this method.\n\t * Please note, however, that the default {@code loadProperties()} implementation\n\t * uses {@link PropertiesPersister#loadFromXml(Properties, InputStream) loadFromXml}\n\t * for XML resources and otherwise uses the two\n\t * {@link PropertiesPersister#load(Properties, InputStream) load} methods\n\t * for other types of resources.\n\t * @param filename the bundle filename (basename + Locale)\n\t * @return the {@code Resource} to use, or {@code null} if none found\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "filename"
    ],
    "position": {
      "column": 1,
      "line": 546
    },
    "return": "Resource",
    "signature": "protected Resource resolveResource(String filename)",
    "source_code": "\tprotected Resource resolveResource(String filename) {\n\t\tfor (String fileExtension : this.fileExtensions) {\n\t\t\tResource resource = this.resourceLoader.getResource(filename + fileExtension);\n\t\t\tif (resource.exists()) {\n\t\t\t\treturn resource;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.context.support.ReloadableResourceBundleMessageSource#setFileExtensions(fileExtensions)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the list of supported file extensions.\n\t * <p>The default is a list containing {@code .properties} and {@code .xml}.\n\t * @param fileExtensions the file extensions (starts with a dot)\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fileExtensions"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "void",
    "signature": "public void setFileExtensions(List<String> fileExtensions)",
    "source_code": "\tpublic void setFileExtensions(List<String> fileExtensions) {\n\t\tAssert.isTrue(!CollectionUtils.isEmpty(fileExtensions), \"At least one file extension is required\");\n\t\tfor (String extension : fileExtensions) {\n\t\t\tif (!extension.startsWith(\".\")) {\n\t\t\t\tthrow new IllegalArgumentException(\"File extension '\" + extension + \"' should start with '.'\");\n\t\t\t}\n\t\t}\n\t\tthis.fileExtensions = Collections.unmodifiableList(fileExtensions);\n\t}"
  },
  "org.springframework.core.MethodParameter#forFieldAwareConstructor(ctor,parameterIndex,fieldName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new MethodParameter for the given field-aware constructor,\n\t * e.g. on a data class or record type.\n\t * <p>A field-aware method parameter will detect field annotations as well,\n\t * as long as the field name matches the parameter name.\n\t * @param ctor the Constructor to specify a parameter for\n\t * @param parameterIndex the index of the parameter\n\t * @param fieldName the name of the underlying field,\n\t * matching the constructor's parameter name\n\t * @return the corresponding MethodParameter instance\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ctor",
      "parameterIndex",
      "fieldName"
    ],
    "position": {
      "column": 1,
      "line": 875
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter forFieldAwareConstructor(Constructor<?> ctor, int parameterIndex, String fieldName)",
    "source_code": "\tpublic static MethodParameter forFieldAwareConstructor(Constructor<?> ctor, int parameterIndex, String fieldName) {\n\t\treturn new FieldAwareConstructorParameter(ctor, parameterIndex, fieldName);\n\t}"
  },
  "org.springframework.core.ReactiveAdapterRegistry#cancel()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 415
    },
    "return": "void",
    "signature": "public void cancel()",
    "source_code": "\t\t\tpublic void cancel() {\n\t\t\t}"
  },
  "org.springframework.core.ReactiveAdapterRegistry#request(n)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "n"
    ],
    "position": {
      "column": 1,
      "line": 412
    },
    "return": "void",
    "signature": "public void request(long n)",
    "source_code": "\t\t\tpublic void request(long n) {\n\t\t\t}"
  },
  "org.springframework.core.ResolvableType#equalsType(otherType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check for type-level equality with another {@code ResolvableType}.\n\t * <p>In contrast to {@link #equals(Object)} or {@link #isAssignableFrom(ResolvableType)},\n\t * this works between different sources as well, e.g. method parameters and return types.\n\t * @param otherType the {@code ResolvableType} to match against\n\t * @return whether the declared type and type variables match\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "otherType"
    ],
    "position": {
      "column": 1,
      "line": 966
    },
    "return": "boolean",
    "signature": "public boolean equalsType(ResolvableType otherType)",
    "source_code": "\tpublic boolean equalsType(ResolvableType otherType) {\n\t\treturn (ObjectUtils.nullSafeEquals(this.type, otherType.type) &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.componentType, otherType.componentType));\n\t}"
  },
  "org.springframework.core.convert.TypeDescriptor#nested(nestingLevel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a type descriptor for a nested type declared within this descriptor.\n\t * @param nestingLevel the nesting level of the collection/array element or\n\t * map key/value declaration within the property\n\t * @return the nested type descriptor at the specified nesting level, or\n\t * {@code null} if it could not be obtained\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nestingLevel"
    ],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor nested(int nestingLevel)",
    "source_code": "\tpublic TypeDescriptor nested(int nestingLevel) {\n\t\tResolvableType nested = this.resolvableType;\n\t\tfor (int i = 0; i < nestingLevel; i++) {\n\t\t\tif (Object.class == nested.getType()) {\n\t\t\t\t// Could be a collection type but we don't know about its element type,\n\t\t\t\t// so let's just assume there is an element type of type Object...\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnested = nested.getNested(2);\n\t\t\t}\n\t\t}\n\t\tif (nested == ResolvableType.NONE) {\n\t\t\treturn null;\n\t\t}\n\t\treturn getRelatedIfResolvable(nested);\n\t}"
  },
  "org.springframework.core.convert.support.GenericConversionService#convert(source,targetType)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "T",
    "signature": "public T convert(@Nullable Object source, Class<T> targetType)",
    "source_code": "\tpublic <T> T convert(@Nullable Object source, Class<T> targetType) {\n\t\tAssert.notNull(targetType, \"Target type to convert to cannot be null\");\n\t\treturn (T) convert(source, TypeDescriptor.forObject(source), TypeDescriptor.valueOf(targetType));\n\t}"
  },
  "org.springframework.core.io.ModuleResource": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link Resource} implementation for {@link java.lang.Module} resolution,\n * performing {@link #getInputStream()} access via {@link Module#getResourceAsStream}.\n *\n * <p>Alternatively, consider accessing resources in a module path layout via\n * {@link ClassPathResource} for exported resources, or specifically relative to\n * a {@code Class} via {@link ClassPathResource#ClassPathResource(String, Class)}\n * for local resolution within the containing module of that specific class.\n * In common scenarios, module resources will simply be transparently visible as\n * classpath resources and therefore do not need any special treatment at all.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 6.1\n * @see Module#getResourceAsStream\n * @see ClassPathResource\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "signature": "public class ModuleResource",
    "source_code": "public class ModuleResource extends AbstractResource {\n\n\tprivate final Module module;\n\n\tprivate final String path;\n\n\n\t/**\n\t * Create a new {@code ModuleResource} for the given {@link Module}\n\t * and the given resource path.\n\t * @param module the runtime module to search within\n\t * @param path the resource path within the module\n\t */\n\tpublic ModuleResource(Module module, String path) {\n\t\tAssert.notNull(module, \"Module must not be null\");\n\t\tAssert.notNull(path, \"Path must not be null\");\n\t\tthis.module = module;\n\t\tthis.path = path;\n\t}\n\n\n\t/**\n\t * Return the {@link Module} for this resource.\n\t */\n\tpublic final Module getModule() {\n\t\treturn this.module;\n\t}\n\n\t/**\n\t * Return the path for this resource.\n\t */\n\tpublic final String getPath() {\n\t\treturn this.path;\n\t}\n\n\n\t@Override\n\tpublic InputStream getInputStream() throws IOException {\n\t\tInputStream is = this.module.getResourceAsStream(this.path);\n\t\tif (is == null) {\n\t\t\tthrow new FileNotFoundException(getDescription() + \" cannot be opened because it does not exist\");\n\t\t}\n\t\treturn is;\n\t}\n\n\t@Override\n\tpublic Resource createRelative(String relativePath) {\n\t\tString pathToUse = StringUtils.applyRelativePath(this.path, relativePath);\n\t\treturn new ModuleResource(this.module, pathToUse);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic String getFilename() {\n\t\treturn StringUtils.getFilename(this.path);\n\t}\n\n\t@Override\n\tpublic String getDescription() {\n\t\treturn \"module resource [\" + this.path + \"]\" +\n\t\t\t\t(this.module.isNamed() ? \" from module [\" + this.module.getName() + \"]\" : \"\");\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof ModuleResource that &&\n\t\t\t\tthis.module.equals(that.module) && this.path.equals(that.path)));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.module.hashCode() * 31 + this.path.hashCode();\n\t}\n\n}"
  },
  "org.springframework.core.io.ModuleResource#createRelative(relativePath)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "relativePath"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "Resource",
    "signature": "public Resource createRelative(String relativePath)",
    "source_code": "\tpublic Resource createRelative(String relativePath) {\n\t\tString pathToUse = StringUtils.applyRelativePath(this.path, relativePath);\n\t\treturn new ModuleResource(this.module, pathToUse);\n\t}"
  },
  "org.springframework.core.io.ModuleResource#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof ModuleResource that &&\n\t\t\t\tthis.module.equals(that.module) && this.path.equals(that.path)));\n\t}"
  },
  "org.springframework.core.io.ModuleResource#getDescription()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "String",
    "signature": "public String getDescription()",
    "source_code": "\tpublic String getDescription() {\n\t\treturn \"module resource [\" + this.path + \"]\" +\n\t\t\t\t(this.module.isNamed() ? \" from module [\" + this.module.getName() + \"]\" : \"\");\n\t}"
  },
  "org.springframework.core.io.ModuleResource#getFilename()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "String",
    "signature": "public String getFilename()",
    "source_code": "\tpublic String getFilename() {\n\t\treturn StringUtils.getFilename(this.path);\n\t}"
  },
  "org.springframework.core.io.ModuleResource#getInputStream()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "InputStream",
    "signature": "public InputStream getInputStream()",
    "source_code": "\tpublic InputStream getInputStream() throws IOException {\n\t\tInputStream is = this.module.getResourceAsStream(this.path);\n\t\tif (is == null) {\n\t\t\tthrow new FileNotFoundException(getDescription() + \" cannot be opened because it does not exist\");\n\t\t}\n\t\treturn is;\n\t}"
  },
  "org.springframework.core.io.ModuleResource#getModule()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link Module} for this resource.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "Module",
    "signature": "public Module getModule()",
    "source_code": "\tpublic final Module getModule() {\n\t\treturn this.module;\n\t}"
  },
  "org.springframework.core.io.ModuleResource#getPath()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the path for this resource.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "String",
    "signature": "public String getPath()",
    "source_code": "\tpublic final String getPath() {\n\t\treturn this.path;\n\t}"
  },
  "org.springframework.core.io.ModuleResource#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.module.hashCode() * 31 + this.path.hashCode();\n\t}"
  },
  "org.springframework.core.io.UrlResource#customizeConnection(con)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "con"
    ],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "void",
    "signature": "protected void customizeConnection(URLConnection con)",
    "source_code": "\tprotected void customizeConnection(URLConnection con) throws IOException {\n\t\tsuper.customizeConnection(con);\n\t\tString userInfo = this.url.getUserInfo();\n\t\tif (userInfo != null) {\n\t\t\tString encodedCredentials = Base64.getUrlEncoder().encodeToString(userInfo.getBytes());\n\t\t\tcon.setRequestProperty(AUTHORIZATION, \"Basic \" + encodedCredentials);\n\t\t}\n\t}"
  },
  "org.springframework.core.io.buffer.DataBufferUtils#outputStreamPublisher(outputStreamConsumer,bufferFactory,executor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@code Publisher<DataBuffer>} based on bytes written to a\n\t * {@code OutputStream}.\n\t * <ul>\n\t * <li>The parameter {@code outputStreamConsumer} is invoked once per\n\t * subscription of the returned {@code Publisher}, when the first\n\t * item is\n\t * {@linkplain Subscription#request(long) requested}.</li>\n\t * <li>{@link OutputStream#write(byte[], int, int) OutputStream.write()}\n\t * invocations made by {@code outputStreamConsumer} are buffered until they\n\t * exceed the default chunk size of 1024, or when the stream is\n\t * {@linkplain OutputStream#flush() flushed} and then result in a\n\t * {@linkplain Subscriber#onNext(Object) published} item\n\t * if there is {@linkplain Subscription#request(long) demand}.</li>\n\t * <li>If there is <em>no demand</em>, {@code OutputStream.write()} will block\n\t * until there is.</li>\n\t * <li>If the subscription is {@linkplain Subscription#cancel() cancelled},\n\t * {@code OutputStream.write()} will throw a {@code IOException}.</li>\n\t * <li>The subscription is\n\t * {@linkplain Subscriber#onComplete() completed} when\n\t * {@code outputStreamHandler} completes.</li>\n\t * <li>Any exceptions thrown from {@code outputStreamHandler} will\n\t * be dispatched to the {@linkplain Subscriber#onError(Throwable) Subscriber}.\n\t * </ul>\n\t * @param outputStreamConsumer invoked when the first buffer is requested\n\t * @param executor used to invoke the {@code outputStreamHandler}\n\t * @return a {@code Publisher<DataBuffer>} based on bytes written by\n\t * {@code outputStreamHandler}\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outputStreamConsumer",
      "bufferFactory",
      "executor"
    ],
    "position": {
      "column": 1,
      "line": 442
    },
    "return": "Publisher<DataBuffer>",
    "signature": "public Publisher<DataBuffer> outputStreamPublisher(Consumer<OutputStream> outputStreamConsumer,\n\t\t\tDataBufferFactory bufferFactory, Executor executor)",
    "source_code": "\tpublic static Publisher<DataBuffer> outputStreamPublisher(Consumer<OutputStream> outputStreamConsumer,"
  },
  "org.springframework.core.io.buffer.DataBufferUtils#outputStreamPublisher(outputStreamConsumer,bufferFactory,executor,chunkSize)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Creates a new {@code Publisher<DataBuffer>} based on bytes written to a\n\t * {@code OutputStream}.\n\t * <ul>\n\t * <li>The parameter {@code outputStreamConsumer} is invoked once per\n\t * subscription of the returned {@code Publisher}, when the first\n\t * item is\n\t * {@linkplain Subscription#request(long) requested}.</li>\n\t * <li>{@link OutputStream#write(byte[], int, int) OutputStream.write()}\n\t * invocations made by {@code outputStreamHandler} are buffered until they\n\t * reach or exceed {@code chunkSize}, or when the stream is\n\t * {@linkplain OutputStream#flush() flushed} and then result in a\n\t * {@linkplain Subscriber#onNext(Object) published} item\n\t * if there is {@linkplain Subscription#request(long) demand}.</li>\n\t * <li>If there is <em>no demand</em>, {@code OutputStream.write()} will block\n\t * until there is.</li>\n\t * <li>If the subscription is {@linkplain Subscription#cancel() cancelled},\n\t * {@code OutputStream.write()} will throw a {@code IOException}.</li>\n\t * <li>The subscription is\n\t * {@linkplain Subscriber#onComplete() completed} when\n\t * {@code outputStreamHandler} completes.</li>\n\t * <li>Any exceptions thrown from {@code outputStreamHandler} will\n\t * be dispatched to the {@linkplain Subscriber#onError(Throwable) Subscriber}.\n\t * </ul>\n\t * @param outputStreamConsumer invoked when the first buffer is requested\n\t * @param executor used to invoke the {@code outputStreamHandler}\n\t * @param chunkSize minimum size of the buffer produced by the publisher\n\t * @return a {@code Publisher<DataBuffer>} based on bytes written by\n\t * {@code outputStreamHandler}\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outputStreamConsumer",
      "bufferFactory",
      "executor",
      "chunkSize"
    ],
    "position": {
      "column": 1,
      "line": 479
    },
    "return": "Publisher<DataBuffer>",
    "signature": "public Publisher<DataBuffer> outputStreamPublisher(Consumer<OutputStream> outputStreamConsumer,\n\t\t\tDataBufferFactory bufferFactory, Executor executor, int chunkSize)",
    "source_code": "\tpublic static Publisher<DataBuffer> outputStreamPublisher(Consumer<OutputStream> outputStreamConsumer,"
  },
  "org.springframework.core.task.TaskRejectedException": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Exception thrown when a {@link TaskExecutor} rejects to accept\n * a given task for execution.\n *\n * @author Juergen Hoeller\n * @since 2.0.1\n * @see TaskExecutor#execute(Runnable)\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 32
    },
    "signature": "public class TaskRejectedException",
    "source_code": "public class TaskRejectedException extends RejectedExecutionException {\n\n\t/**\n\t * Create a new {@code TaskRejectedException}\n\t * with the specified detail message and no root cause.\n\t * @param msg the detail message\n\t */\n\tpublic TaskRejectedException(String msg) {\n\t\tsuper(msg);\n\t}\n\n\t/**\n\t * Create a new {@code TaskRejectedException}\n\t * with the specified detail message and the given root cause.\n\t * @param msg the detail message\n\t * @param cause the root cause (usually from using an underlying\n\t * API such as the {@code java.util.concurrent} package)\n\t * @see java.util.concurrent.RejectedExecutionException\n\t */\n\tpublic TaskRejectedException(String msg, Throwable cause) {\n\t\tsuper(msg, cause);\n\t}\n\n\t/**\n\t * Create a new {@code TaskRejectedException}\n\t * with a default message for the given executor and task.\n\t * @param executor the {@code Executor} that rejected the task\n\t * @param task the task object that got rejected\n\t * @param cause the original {@link RejectedExecutionException}\n\t * @since 6.1\n\t * @see ExecutorService#isShutdown()\n\t * @see java.util.concurrent.RejectedExecutionException\n\t */\n\tpublic TaskRejectedException(Executor executor, Object task, RejectedExecutionException cause) {\n\t\tsuper(executorDescription(executor) + \" did not accept task: \" + task, cause);\n\t}\n\n\n\tprivate static String executorDescription(Executor executor) {\n\t\tif (executor instanceof ExecutorService executorService) {\n\t\t\treturn \"ExecutorService in \" + (executorService.isShutdown() ? \"shutdown\" : \"active\") + \" state\";\n\t\t}\n\t\treturn executor.toString();\n\t}\n\n}"
  },
  "org.springframework.core.task.support.TaskExecutorAdapter#execute(task,startTimeout)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "startTimeout"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "void",
    "signature": "public void execute(Runnable task, long startTimeout)",
    "source_code": "\tpublic void execute(Runnable task, long startTimeout) {\n\t\texecute(task);\n\t}"
  },
  "org.springframework.dao.support.DataAccessUtils#optionalResult(results)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a single result object from the given Iterator.\n\t * <p>Returns {@code Optional.empty()} if 0 result objects found;\n\t * throws an exception if more than 1 element found.\n\t * @param results the result Iterator (can be {@code null})\n\t * @return the single optional result object, or {@code Optional.empty()} if none\n\t * @throws IncorrectResultSizeDataAccessException if more than one\n\t * element has been found in the given Iterator\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "results"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "Optional<T>",
    "signature": "public Optional<T> optionalResult(@Nullable Iterator<T> results)",
    "source_code": "\tpublic static <T> Optional<T> optionalResult(@Nullable Iterator<T> results) throws IncorrectResultSizeDataAccessException {\n\t\treturn Optional.ofNullable(singleResult(results));\n\t}"
  },
  "org.springframework.expression.common.TemplateAwareExpressionParser": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * An expression parser that understands templates. It can be subclassed by expression\n * parsers that do not offer first class support for templating.\n *\n * @author Keith Donald\n * @author Juergen Hoeller\n * @author Andy Clement\n * @author Sam Brannen\n * @since 3.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "signature": "public class TemplateAwareExpressionParser",
    "source_code": "public abstract class TemplateAwareExpressionParser implements ExpressionParser {\n\n\t@Override\n\tpublic Expression parseExpression(String expressionString) throws ParseException {\n\t\treturn parseExpression(expressionString, null);\n\t}\n\n\t@Override\n\tpublic Expression parseExpression(String expressionString, @Nullable ParserContext context) throws ParseException {\n\t\tif (context != null && context.isTemplate()) {\n\t\t\tAssert.notNull(expressionString, \"'expressionString' must not be null\");\n\t\t\treturn parseTemplate(expressionString, context);\n\t\t}\n\t\telse {\n\t\t\tAssert.hasText(expressionString, \"'expressionString' must not be null or blank\");\n\t\t\treturn doParseExpression(expressionString, context);\n\t\t}\n\t}\n\n\n\tprivate Expression parseTemplate(String expressionString, ParserContext context) throws ParseException {\n\t\tif (expressionString.isEmpty()) {\n\t\t\treturn new LiteralExpression(\"\");\n\t\t}\n\n\t\tExpression[] expressions = parseExpressions(expressionString, context);\n\t\tif (expressions.length == 1) {\n\t\t\treturn expressions[0];\n\t\t}\n\t\telse {\n\t\t\treturn new CompositeStringExpression(expressionString, expressions);\n\t\t}\n\t}\n\n\t/**\n\t * Helper that parses given expression string using the configured parser. The\n\t * expression string can contain any number of expressions all contained in \"${...}\"\n\t * markers. For instance: \"foo${expr0}bar${expr1}\". The static pieces of text will\n\t * also be returned as Expressions that just return that static piece of text. As a\n\t * result, evaluating all returned expressions and concatenating the results produces\n\t * the complete evaluated string. Unwrapping is only done of the outermost delimiters\n\t * found, so the string 'hello ${foo${abc}}' would break into the pieces 'hello ' and\n\t * 'foo${abc}'. This means that expression languages that use ${..} as part of their\n\t * functionality are supported without any problem. The parsing is aware of the\n\t * structure of an embedded expression. It assumes that parentheses '(', square\n\t * brackets '[', and curly brackets '}' must be in pairs within the expression unless"
  },
  "org.springframework.expression.common.TemplateAwareExpressionParser#doParseExpression(expressionString,context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Actually parse the expression string and return an Expression object.\n\t * @param expressionString the raw expression string to parse\n\t * @param context a context for influencing this expression parsing routine (optional)\n\t * @return an evaluator for the parsed expression\n\t * @throws ParseException an exception occurred during parsing\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "expressionString",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 234
    },
    "return": "Expression",
    "signature": "protected Expression doParseExpression(String expressionString, @Nullable ParserContext context)",
    "source_code": "\tprotected abstract Expression doParseExpression(String expressionString, @Nullable ParserContext context)"
  },
  "org.springframework.expression.common.TemplateAwareExpressionParser#parseExpression(expressionString)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expressionString"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "return": "Expression",
    "signature": "public Expression parseExpression(String expressionString)",
    "source_code": "\tpublic Expression parseExpression(String expressionString) throws ParseException {\n\t\treturn parseExpression(expressionString, null);\n\t}"
  },
  "org.springframework.expression.common.TemplateAwareExpressionParser#parseExpression(expressionString,context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expressionString",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "return": "Expression",
    "signature": "public Expression parseExpression(String expressionString, @Nullable ParserContext context)",
    "source_code": "\tpublic Expression parseExpression(String expressionString, @Nullable ParserContext context) throws ParseException {\n\t\tif (context != null && context.isTemplate()) {\n\t\t\tAssert.notNull(expressionString, \"'expressionString' must not be null\");\n\t\t\treturn parseTemplate(expressionString, context);\n\t\t}\n\t\telse {\n\t\t\tAssert.hasText(expressionString, \"'expressionString' must not be null or blank\");\n\t\t\treturn doParseExpression(expressionString, context);\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.ast.CompoundExpression": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Represents a DOT separated expression sequence, such as\n * {@code property1.property2.methodOne()} or\n * {@code property1?.property2?.methodOne()} when the null-safe navigation\n * operator is used.\n *\n * <p>May also contain array/collection/map indexers, such as\n * {@code property1[0].property2['key']}.\n *\n * @author Andy Clement\n * @author Sam Brannen\n * @since 3.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public class CompoundExpression",
    "source_code": "public class CompoundExpression extends SpelNodeImpl {\n\n\tpublic CompoundExpression(int startPos, int endPos, SpelNodeImpl... expressionComponents) {\n\t\tsuper(startPos, endPos, expressionComponents);\n\t\tif (expressionComponents.length < 2) {\n\t\t\tthrow new IllegalStateException(\"Do not build compound expressions with less than two entries: \" +\n\t\t\t\t\texpressionComponents.length);\n\t\t}\n\t}\n\n\n\t@Override\n\tprotected ValueRef getValueRef(ExpressionState state) throws EvaluationException {\n\t\tif (getChildCount() == 1) {\n\t\t\treturn this.children[0].getValueRef(state);\n\t\t}\n\n\t\tSpelNodeImpl nextNode = this.children[0];\n\t\ttry {\n\t\t\tTypedValue result = nextNode.getValueInternal(state);\n\t\t\tint cc = getChildCount();\n\t\t\tfor (int i = 1; i < cc - 1; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tstate.pushActiveContextObject(result);\n\t\t\t\t\tnextNode = this.children[i];\n\t\t\t\t\tresult = nextNode.getValueInternal(state);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tstate.popActiveContextObject();\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tstate.pushActiveContextObject(result);\n\t\t\t\tnextNode = this.children[cc - 1];\n\t\t\t\treturn nextNode.getValueRef(state);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tstate.popActiveContextObject();\n\t\t\t}\n\t\t}\n\t\tcatch (SpelEvaluationException ex) {\n\t\t\t// Correct the position for the error before re-throwing\n\t\t\tex.setPosition(nextNode.getStartPosition());\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\t/**\n\t * Evaluates a compound expression. This involves evaluating each piece in turn and the\n\t * return value from each piece is the active context object for the subsequent piece.\n\t * @param state the state in which the expression is being evaluated\n\t * @return the final value from the last piece of the compound expression\n\t */\n\t@Override\n\tpublic TypedValue getValueInternal(ExpressionState state) throws EvaluationException {\n\t\tValueRef ref = getValueRef(state);\n\t\tTypedValue result = ref.getValue();\n\t\tthis.exitTypeDescriptor = this.children[this.children.length - 1].exitTypeDescriptor;\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic TypedValue setValueInternal(ExpressionState state, Supplier<TypedValue> valueSupplier)\n\t\t\tthrows EvaluationException {\n\n\t\tTypedValue typedValue = valueSupplier.get();\n\t\tgetValueRef(state).setValue(typedValue.getValue());\n\t\treturn typedValue;\n\t}\n\n\t@Override\n\tpublic boolean isWritable(ExpressionState state) throws EvaluationException {\n\t\treturn getValueRef(state).isWritable();\n\t}\n\n\t@Override\n\tpublic String toStringAST() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < getChildCount(); i++) {\n\t\t\tsb.append(getChild(i).toStringAST());\n\t\t\tif (i < getChildCount() - 1) {\n\t\t\t\tSpelNode nextChild = getChild(i + 1);\n\t\t\t\t// Don't append a '.' if the next child is an Indexer.\n\t\t\t\t// For example, we want 'myVar[0]' instead of 'myVar.[0]'.\n\t\t\t\tif (!(nextChild instanceof Indexer)) {\n\t\t\t\t\tif ((nextChild instanceof MethodReference methodRef && methodRef.isNullSafe()) ||\n\t\t\t\t\t\t(nextChild instanceof PropertyOrFieldReference pofRef && pofRef.isNullSafe())) {\n\t\t\t\t\t\tsb.append('?');\n\t\t\t\t\t}\n\t\t\t\t\tsb.append('.');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\t@Override\n\tpublic boolean isCompilable() {\n\t\tfor (SpelNodeImpl child: this.children) {\n\t\t\tif (!child.isCompilable()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic void generateCode(MethodVisitor mv, CodeFlow cf) {\n\t\tfor (SpelNodeImpl child : this.children) {\n\t\t\tchild.generateCode(mv, cf);\n\t\t}\n\t\tcf.pushDescriptor(this.exitTypeDescriptor);\n\t}\n\n}"
  },
  "org.springframework.expression.spel.ast.CompoundExpression#generateCode(mv,cf)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "cf"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "void",
    "signature": "public void generateCode(MethodVisitor mv, CodeFlow cf)",
    "source_code": "\tpublic void generateCode(MethodVisitor mv, CodeFlow cf) {\n\t\tfor (SpelNodeImpl child : this.children) {\n\t\t\tchild.generateCode(mv, cf);\n\t\t}\n\t\tcf.pushDescriptor(this.exitTypeDescriptor);\n\t}"
  },
  "org.springframework.expression.spel.ast.CompoundExpression#getValueInternal(state)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Evaluates a compound expression. This involves evaluating each piece in turn and the\n\t * return value from each piece is the active context object for the subsequent piece.\n\t * @param state the state in which the expression is being evaluated\n\t * @return the final value from the last piece of the compound expression\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "state"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "TypedValue",
    "signature": "public TypedValue getValueInternal(ExpressionState state)",
    "source_code": "\tpublic TypedValue getValueInternal(ExpressionState state) throws EvaluationException {\n\t\tValueRef ref = getValueRef(state);\n\t\tTypedValue result = ref.getValue();\n\t\tthis.exitTypeDescriptor = this.children[this.children.length - 1].exitTypeDescriptor;\n\t\treturn result;\n\t}"
  },
  "org.springframework.expression.spel.ast.CompoundExpression#getValueRef(state)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "state"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "return": "ValueRef",
    "signature": "protected ValueRef getValueRef(ExpressionState state)",
    "source_code": "\tprotected ValueRef getValueRef(ExpressionState state) throws EvaluationException {\n\t\tif (getChildCount() == 1) {\n\t\t\treturn this.children[0].getValueRef(state);\n\t\t}\n\n\t\tSpelNodeImpl nextNode = this.children[0];\n\t\ttry {\n\t\t\tTypedValue result = nextNode.getValueInternal(state);\n\t\t\tint cc = getChildCount();\n\t\t\tfor (int i = 1; i < cc - 1; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tstate.pushActiveContextObject(result);\n\t\t\t\t\tnextNode = this.children[i];\n\t\t\t\t\tresult = nextNode.getValueInternal(state);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tstate.popActiveContextObject();\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tstate.pushActiveContextObject(result);\n\t\t\t\tnextNode = this.children[cc - 1];\n\t\t\t\treturn nextNode.getValueRef(state);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tstate.popActiveContextObject();\n\t\t\t}\n\t\t}\n\t\tcatch (SpelEvaluationException ex) {\n\t\t\t// Correct the position for the error before re-throwing\n\t\t\tex.setPosition(nextNode.getStartPosition());\n\t\t\tthrow ex;\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.ast.CompoundExpression#isCompilable()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "boolean",
    "signature": "public boolean isCompilable()",
    "source_code": "\tpublic boolean isCompilable() {\n\t\tfor (SpelNodeImpl child: this.children) {\n\t\t\tif (!child.isCompilable()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.expression.spel.ast.CompoundExpression#isWritable(state)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "state"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "boolean",
    "signature": "public boolean isWritable(ExpressionState state)",
    "source_code": "\tpublic boolean isWritable(ExpressionState state) throws EvaluationException {\n\t\treturn getValueRef(state).isWritable();\n\t}"
  },
  "org.springframework.expression.spel.ast.CompoundExpression#setValueInternal(state,valueSupplier)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "state",
      "valueSupplier"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "TypedValue",
    "signature": "public TypedValue setValueInternal(ExpressionState state, Supplier<TypedValue> valueSupplier)",
    "source_code": "\tpublic TypedValue setValueInternal(ExpressionState state, Supplier<TypedValue> valueSupplier)"
  },
  "org.springframework.expression.spel.ast.CompoundExpression#toStringAST()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "String",
    "signature": "public String toStringAST()",
    "source_code": "\tpublic String toStringAST() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < getChildCount(); i++) {\n\t\t\tsb.append(getChild(i).toStringAST());\n\t\t\tif (i < getChildCount() - 1) {\n\t\t\t\tSpelNode nextChild = getChild(i + 1);\n\t\t\t\t// Don't append a '.' if the next child is an Indexer.\n\t\t\t\t// For example, we want 'myVar[0]' instead of 'myVar.[0]'.\n\t\t\t\tif (!(nextChild instanceof Indexer)) {\n\t\t\t\t\tif ((nextChild instanceof MethodReference methodRef && methodRef.isNullSafe()) ||\n\t\t\t\t\t\t(nextChild instanceof PropertyOrFieldReference pofRef && pofRef.isNullSafe())) {\n\t\t\t\t\t\tsb.append('?');\n\t\t\t\t\t}\n\t\t\t\t\tsb.append('.');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.expression.spel.ast.OpMinus#isNegativeNumberLiteral()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if this operator is a unary minus and its child is a\n\t * {@linkplain Literal#isNumberLiteral() number literal}.\n\t * @return {@code true} if it is a negative number literal\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "boolean",
    "signature": "public boolean isNegativeNumberLiteral()",
    "source_code": "\tpublic boolean isNegativeNumberLiteral() {\n\t\treturn (this.children.length == 1 && this.children[0] instanceof Literal literal &&\n\t\t\t\tliteral.isNumberLiteral());\n\t}"
  },
  "org.springframework.expression.spel.ast.Projection#isNullSafe()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Does this node represent a null-safe projection operation?\n\t * @since 6.1.6\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "boolean",
    "signature": "public boolean isNullSafe()",
    "source_code": "\tpublic final boolean isNullSafe() {\n\t\treturn this.nullSafe;\n\t}"
  },
  "org.springframework.expression.spel.ast.Selection#isNullSafe()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Does this node represent a null-safe selection operation?\n\t * @since 6.1.6\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "boolean",
    "signature": "public boolean isNullSafe()",
    "source_code": "\tpublic final boolean isNullSafe() {\n\t\treturn this.nullSafe;\n\t}"
  },
  "org.springframework.expression.spel.ast.SpelNodeImpl#isNullSafe()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if this node is the target of a null-safe navigation operation.\n\t * <p>The default implementation returns {@code false}.\n\t * @return {@code true} if this node is the target of a null-safe operation\n\t * @since 6.1.6\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "boolean",
    "signature": "public boolean isNullSafe()",
    "source_code": "\tpublic boolean isNullSafe() {\n\t\treturn false;\n\t}"
  },
  "org.springframework.expression.spel.support.ReflectionHelper": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Utility methods used by the reflection resolver code to discover the appropriate\n * methods/constructors and fields that should be used in expressions.\n *\n * @author Andy Clement\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 3.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public class ReflectionHelper",
    "source_code": "public abstract class ReflectionHelper {\n\n\t/**\n\t * Compare argument arrays and return information about whether they match.\n\t * A supplied type converter and conversionAllowed flag allow for matches to take\n\t * into account that a type may be transformed into a different type by the converter.\n\t * @param expectedArgTypes the types the method/constructor is expecting\n\t * @param suppliedArgTypes the types that are being supplied at the point of invocation\n\t * @param typeConverter a registered type converter\n\t * @return a MatchInfo object indicating what kind of match it was,\n\t * or {@code null} if it was not a match\n\t */\n\t@Nullable\n\tstatic ArgumentsMatchInfo compareArguments(\n\t\t\tList<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {\n\n\t\tAssert.isTrue(expectedArgTypes.size() == suppliedArgTypes.size(),\n\t\t\t\t\"Expected argument types and supplied argument types should be arrays of same length\");\n\n\t\tArgumentsMatchKind match = ArgumentsMatchKind.EXACT;\n\t\tfor (int i = 0; i < expectedArgTypes.size() && match != null; i++) {\n\t\t\tTypeDescriptor suppliedArg = suppliedArgTypes.get(i);\n\t\t\tTypeDescriptor expectedArg = expectedArgTypes.get(i);\n\t\t\t// The user may supply null - and that will be ok unless a primitive is expected\n\t\t\tif (suppliedArg == null) {\n\t\t\t\tif (expectedArg.isPrimitive()) {\n\t\t\t\t\tmatch = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!expectedArg.equals(suppliedArg)) {\n\t\t\t\tif (suppliedArg.isAssignableTo(expectedArg)) {\n\t\t\t\t\tif (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {\n\t\t\t\t\t\tmatch = ArgumentsMatchKind.CLOSE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (typeConverter.canConvert(suppliedArg, expectedArg)) {\n\t\t\t\t\tmatch = ArgumentsMatchKind.REQUIRES_CONVERSION;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmatch = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (match != null ? new ArgumentsMatchInfo(match) : null);\n\t}\n\n\t/**\n\t * Based on {@link MethodInvoker#getTypeDifferenceWeight(Class[], Object[])} but operates on TypeDescriptors.\n\t */\n\tpublic static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {\n\t\tint result = 0;\n\t\tfor (int i = 0; i < paramTypes.size(); i++) {\n\t\t\tTypeDescriptor paramType = paramTypes.get(i);\n\t\t\tTypeDescriptor argType = (i < argTypes.size() ? argTypes.get(i) : null);\n\t\t\tif (argType == null) {\n\t\t\t\tif (paramType.isPrimitive()) {\n\t\t\t\t\treturn Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tClass<?> paramTypeClazz = paramType.getType();\n\t\t\t\tif (!ClassUtils.isAssignable(paramTypeClazz, argType.getType())) {\n\t\t\t\t\treturn Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t\tif (paramTypeClazz.isPrimitive()) {\n\t\t\t\t\tparamTypeClazz = Object.class;\n\t\t\t\t}\n\t\t\t\tClass<?> superClass = argType.getType().getSuperclass();\n\t\t\t\twhile (superClass != null) {\n\t\t\t\t\tif (paramTypeClazz.equals(superClass)) {\n\t\t\t\t\t\tresult = result + 2;\n\t\t\t\t\t\tsuperClass = null;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {\n\t\t\t\t\t\tresult = result + 2;\n\t\t\t\t\t\tsuperClass = superClass.getSuperclass();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsuperClass = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (paramTypeClazz.isInterface()) {\n\t\t\t\t\tresult = result + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Compare argument arrays and return information about whether they match.\n\t * A supplied type converter and conversionAllowed flag allow for matches to\n\t * take into account that a type may be transformed into a different type by the\n\t * converter. This variant of compareArguments also allows for a varargs match.\n\t * @param expectedArgTypes the types the method/constructor is expecting\n\t * @param suppliedArgTypes the types that are being supplied at the point of invocation\n\t * @param typeConverter a registered type converter\n\t * @return a MatchInfo object indicating what kind of match it was,\n\t * or {@code null} if it was not a match\n\t */\n\t@Nullable\n\tstatic ArgumentsMatchInfo compareArgumentsVarargs(\n\t\t\tList<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {\n\n\t\tAssert.isTrue(!CollectionUtils.isEmpty(expectedArgTypes),\n\t\t\t\t\"Expected arguments must at least include one array (the varargs parameter)\");\n\t\tAssert.isTrue(expectedArgTypes.get(expectedArgTypes.size() - 1).isArray(),\n\t\t\t\t\"Final expected argument should be array type (the varargs parameter)\");\n\n\t\tArgumentsMatchKind match = ArgumentsMatchKind.EXACT;\n\n\t\t// Check up until the varargs argument:\n\n\t\t// Deal with the arguments up to 'expected number' - 1 (that is everything but the varargs argument)\n\t\tint argCountUpToVarargs = expectedArgTypes.size() - 1;\n\t\tfor (int i = 0; i < argCountUpToVarargs && match != null; i++) {\n\t\t\tTypeDescriptor suppliedArg = suppliedArgTypes.get(i);\n\t\t\tTypeDescriptor expectedArg = expectedArgTypes.get(i);\n\t\t\tif (suppliedArg == null) {\n\t\t\t\tif (expectedArg.isPrimitive()) {\n\t\t\t\t\tmatch = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!expectedArg.equals(suppliedArg)) {\n\t\t\t\t\tif (suppliedArg.isAssignableTo(expectedArg)) {\n\t\t\t\t\t\tif (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {\n\t\t\t\t\t\t\tmatch = ArgumentsMatchKind.CLOSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (typeConverter.canConvert(suppliedArg, expectedArg)) {\n\t\t\t\t\t\tmatch = ArgumentsMatchKind.REQUIRES_CONVERSION;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmatch = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If already confirmed it cannot be a match, then return\n\t\tif (match == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (suppliedArgTypes.size() == expectedArgTypes.size() &&\n\t\t\t\texpectedArgTypes.get(expectedArgTypes.size() - 1).equals(\n\t\t\t\t\t\tsuppliedArgTypes.get(suppliedArgTypes.size() - 1))) {\n\t\t\t// Special case: there is one parameter left and it is an array and it matches the varargs\n\t\t\t// expected argument - that is a match, the caller has already built the array. Proceed with it.\n\t\t}\n\t\telse {\n\t\t\t// Now... we have the final argument in the method we are checking as a match and we have 0\n\t\t\t// or more other arguments left to pass to it.\n\t\t\tTypeDescriptor varargsDesc = expectedArgTypes.get(expectedArgTypes.size() - 1);\n\t\t\tTypeDescriptor elementDesc = varargsDesc.getElementTypeDescriptor();\n\t\t\tAssert.state(elementDesc != null, \"No element type\");\n\t\t\tClass<?> varargsParamType = elementDesc.getType();\n\n\t\t\t// All remaining parameters must be of this type or convertible to this type\n\t\t\tfor (int i = expectedArgTypes.size() - 1; i < suppliedArgTypes.size(); i++) {\n\t\t\t\tTypeDescriptor suppliedArg = suppliedArgTypes.get(i);\n\t\t\t\tif (suppliedArg == null) {\n\t\t\t\t\tif (varargsParamType.isPrimitive()) {\n\t\t\t\t\t\tmatch = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (varargsParamType != suppliedArg.getType()) {\n\t\t\t\t\t\tif (ClassUtils.isAssignable(varargsParamType, suppliedArg.getType())) {\n\t\t\t\t\t\t\tif (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {\n\t\t\t\t\t\t\t\tmatch = ArgumentsMatchKind.CLOSE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (typeConverter.canConvert(suppliedArg, TypeDescriptor.valueOf(varargsParamType))) {\n\t\t\t\t\t\t\tmatch = ArgumentsMatchKind.REQUIRES_CONVERSION;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tmatch = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (match != null ? new ArgumentsMatchInfo(match) : null);\n\t}\n\n\n\t// TODO could do with more refactoring around argument handling and varargs\n\t/**\n\t * Convert a supplied set of arguments into the requested types. If the parameterTypes are related to\n\t * a varargs method then the final entry in the parameterTypes array is going to be an array itself whose\n\t * component type should be used as the conversion target for extraneous arguments. (For example, if the\n\t * parameterTypes are {Integer, String[]} and the input arguments are {Integer, boolean, float} then both\n\t * the boolean and float must be converted to strings). This method does *not* repackage the arguments\n\t * into a form suitable for the varargs invocation - a subsequent call to setupArgumentsForVarargsInvocation handles that.\n\t * @param converter the converter to use for type conversions\n\t * @param arguments the arguments to convert to the requested parameter types\n\t * @param method the target Method\n\t * @return true if some kind of conversion occurred on the argument\n\t * @throws SpelEvaluationException if there is a problem with conversion\n\t */\n\tpublic static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method)\n\t\t\tthrows SpelEvaluationException {\n\n\t\tInteger varargsPosition = (method.isVarArgs() ? method.getParameterCount() - 1 : null);\n\t\treturn convertArguments(converter, arguments, method, varargsPosition);\n\t}\n\n\t/**\n\t * Takes an input set of argument values and converts them to the types specified as the\n\t * required parameter types. The arguments are converted 'in-place' in the input array.\n\t * @param converter the type converter to use for attempting conversions\n\t * @param arguments the actual arguments that need conversion\n\t * @param executable the target Method or Constructor\n\t * @param varargsPosition the known position of the varargs argument, if any\n\t * ({@code null} if not varargs)\n\t * @return {@code true} if some kind of conversion occurred on an argument\n\t * @throws EvaluationException if a problem occurs during conversion\n\t */\n\tstatic boolean convertArguments(TypeConverter converter, Object[] arguments, Executable executable,\n\t\t\t@Nullable Integer varargsPosition) throws EvaluationException {\n\n\t\tboolean conversionOccurred = false;\n\t\tif (varargsPosition == null) {\n\t\t\tfor (int i = 0; i < arguments.length; i++) {\n\t\t\t\tTypeDescriptor targetType = new TypeDescriptor(MethodParameter.forExecutable(executable, i));\n\t\t\t\tObject argument = arguments[i];\n\t\t\t\targuments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType);\n\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Convert everything up to the varargs position\n\t\t\tfor (int i = 0; i < varargsPosition; i++) {\n\t\t\t\tTypeDescriptor targetType = new TypeDescriptor(MethodParameter.forExecutable(executable, i));\n\t\t\t\tObject argument = arguments[i];\n\t\t\t\targuments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType);\n\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t\t}\n\n\t\t\tMethodParameter methodParam = MethodParameter.forExecutable(executable, varargsPosition);\n\n\t\t\t// If the target is varargs and there is just one more argument, then convert it here.\n\t\t\tif (varargsPosition == arguments.length - 1) {\n\t\t\t\tObject argument = arguments[varargsPosition];\n\t\t\t\tTypeDescriptor targetType = new TypeDescriptor(methodParam);\n\t\t\t\tTypeDescriptor sourceType = TypeDescriptor.forObject(argument);\n\t\t\t\tif (argument == null) {\n\t\t\t\t\t// Perform the equivalent of GenericConversionService.convertNullSource() for a single argument.\n\t\t\t\t\tTypeDescriptor elementDesc = targetType.getElementTypeDescriptor();\n\t\t\t\t\tif (elementDesc != null && elementDesc.getObjectType() == Optional.class) {\n\t\t\t\t\t\targuments[varargsPosition] = Optional.empty();\n\t\t\t\t\t\tconversionOccurred = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// If the argument type is equal to the varargs element type, there is no need to\n\t\t\t\t// convert it or wrap it in an array. For example, using StringToArrayConverter to\n\t\t\t\t// convert a String containing a comma would result in the String being split and\n\t\t\t\t// repackaged in an array when it should be used as-is.\n\t\t\t\telse if (!sourceType.equals(targetType.getElementTypeDescriptor())) {\n\t\t\t\t\targuments[varargsPosition] = converter.convertValue(argument, sourceType, targetType);\n\t\t\t\t}\n\t\t\t\t// Possible outcomes of the above if-else block:\n\t\t\t\t// 1) the input argument was null, and nothing was done.\n\t\t\t\t// 2) the input argument was null; the varargs element type is Optional; and the argument was converted to Optional.empty().\n\t\t\t\t// 3) the input argument was correct type but not wrapped in an array, and nothing was done.\n\t\t\t\t// 4) the input argument was already compatible (i.e., array of valid type), and nothing was done.\n\t\t\t\t// 5) the input argument was the wrong type and got converted and wrapped in an array.\n\t\t\t\tif (argument != arguments[varargsPosition] &&\n\t\t\t\t\t\t!isFirstEntryInArray(argument, arguments[varargsPosition])) {\n\t\t\t\t\tconversionOccurred = true; // case 5\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Otherwise, convert remaining arguments to the varargs element type.\n\t\t\telse {\n\t\t\t\tTypeDescriptor targetType = new TypeDescriptor(methodParam).getElementTypeDescriptor();\n\t\t\t\tAssert.state(targetType != null, \"No element type\");\n\t\t\t\tfor (int i = varargsPosition; i < arguments.length; i++) {\n\t\t\t\t\tObject argument = arguments[i];\n\t\t\t\t\targuments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType);\n\t\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn conversionOccurred;\n\t}\n\n\t/**\n\t * Takes an input set of argument values and converts them to the types specified as the\n\t * required parameter types. The arguments are converted 'in-place' in the input array.\n\t * @param converter the type converter to use for attempting conversions\n\t * @param arguments the actual arguments that need conversion\n\t * @param methodHandle the target MethodHandle\n\t * @param varargsPosition the known position of the varargs argument, if any\n\t * ({@code null} if not varargs)\n\t * @return {@code true} if some kind of conversion occurred on an argument\n\t * @throws EvaluationException if a problem occurs during conversion\n\t * @since 6.1\n\t */\n\tpublic static boolean convertAllMethodHandleArguments(TypeConverter converter, Object[] arguments,\n\t\t\tMethodHandle methodHandle, @Nullable Integer varargsPosition) throws EvaluationException {\n\n\t\tboolean conversionOccurred = false;\n\t\tfinal MethodType methodHandleArgumentTypes = methodHandle.type();\n\t\tif (varargsPosition == null) {\n\t\t\tfor (int i = 0; i < arguments.length; i++) {\n\t\t\t\tClass<?> argumentClass = methodHandleArgumentTypes.parameterType(i);\n\t\t\t\tResolvableType resolvableType = ResolvableType.forClass(argumentClass);\n\t\t\t\tTypeDescriptor targetType = new TypeDescriptor(resolvableType, argumentClass, null);\n\n\t\t\t\tObject argument = arguments[i];\n\t\t\t\targuments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType);\n\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Convert everything up to the varargs position\n\t\t\tfor (int i = 0; i < varargsPosition; i++) {\n\t\t\t\tClass<?> argumentClass = methodHandleArgumentTypes.parameterType(i);\n\t\t\t\tResolvableType resolvableType = ResolvableType.forClass(argumentClass);\n\t\t\t\tTypeDescriptor targetType = new TypeDescriptor(resolvableType, argumentClass, null);\n\n\t\t\t\tObject argument = arguments[i];\n\t\t\t\targuments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType);\n\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t\t}\n\n\t\t\tfinal Class<?> varArgClass = methodHandleArgumentTypes.lastParameterType().componentType();\n\t\t\tResolvableType varArgResolvableType = ResolvableType.forClass(varArgClass);\n\t\t\tTypeDescriptor varArgContentType = new TypeDescriptor(varArgResolvableType, varArgClass, null);\n\n\t\t\t// If the target is varargs and there is just one more argument, then convert it here.\n\t\t\tif (varargsPosition == arguments.length - 1) {\n\t\t\t\tObject argument = arguments[varargsPosition];\n\t\t\t\tTypeDescriptor sourceType = TypeDescriptor.forObject(argument);\n\t\t\t\tif (argument == null) {\n\t\t\t\t\t// Perform the equivalent of GenericConversionService.convertNullSource() for a single argument.\n\t\t\t\t\tTypeDescriptor elementDesc = varArgContentType.getElementTypeDescriptor();\n\t\t\t\t\tif (elementDesc != null && elementDesc.getObjectType() == Optional.class) {\n\t\t\t\t\t\targuments[varargsPosition] = Optional.empty();\n\t\t\t\t\t\tconversionOccurred = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// If the argument type is equal to the varargs element type, there is no need to\n\t\t\t\t// convert it or wrap it in an array. For example, using StringToArrayConverter to\n\t\t\t\t// convert a String containing a comma would result in the String being split and\n\t\t\t\t// repackaged in an array when it should be used as-is.\n\t\t\t\telse if (!sourceType.equals(varArgContentType.getElementTypeDescriptor())) {\n\t\t\t\t\targuments[varargsPosition] = converter.convertValue(argument, sourceType, varArgContentType);\n\t\t\t\t}\n\t\t\t\t// Possible outcomes of the above if-else block:\n\t\t\t\t// 1) the input argument was null, and nothing was done.\n\t\t\t\t// 2) the input argument was null; the varargs element type is Optional; and the argument was converted to Optional.empty().\n\t\t\t\t// 3) the input argument was correct type but not wrapped in an array, and nothing was done.\n\t\t\t\t// 4) the input argument was already compatible (i.e., array of valid type), and nothing was done.\n\t\t\t\t// 5) the input argument was the wrong type and got converted and wrapped in an array.\n\t\t\t\tif (argument != arguments[varargsPosition] &&\n\t\t\t\t\t\t!isFirstEntryInArray(argument, arguments[varargsPosition])) {\n\t\t\t\t\tconversionOccurred = true; // case 5\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Otherwise, convert remaining arguments to the varargs element type.\n\t\t\telse {\n\t\t\t\tfor (int i = varargsPosition; i < arguments.length; i++) {\n\t\t\t\t\tObject argument = arguments[i];\n\t\t\t\t\targuments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), varArgContentType);\n\t\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn conversionOccurred;\n\t}\n\n\t/**\n\t * Check if the supplied value is the first entry in the array represented by the possibleArray value.\n\t * @param value the value to check for in the array\n\t * @param possibleArray an array object that may have the supplied value as the first element\n\t * @return true if the supplied value is the first entry in the array\n\t */\n\tprivate static boolean isFirstEntryInArray(Object value, @Nullable Object possibleArray) {\n\t\tif (possibleArray == null) {\n\t\t\treturn false;\n\t\t}\n\t\tClass<?> type = possibleArray.getClass();\n\t\tif (!type.isArray() || Array.getLength(possibleArray) == 0 ||\n\t\t\t\t!ClassUtils.isAssignableValue(type.componentType(), value)) {\n\t\t\treturn false;\n\t\t}\n\t\tObject arrayValue = Array.get(possibleArray, 0);\n\t\treturn (type.componentType().isPrimitive() ? arrayValue.equals(value) : arrayValue == value);\n\t}\n\n\t/**\n\t * Package up the arguments so that they correctly match what is expected in requiredParameterTypes.\n\t * <p>For example, if requiredParameterTypes is {@code (int, String[])} because the second parameter\n\t * was declared {@code String...}, then if arguments is {@code [1,\"a\",\"b\"]} then it must be\n\t * repackaged as {@code [1,new String[]{\"a\",\"b\"}]} in order to match the expected types.\n\t * @param requiredParameterTypes the types of the parameters for the invocation\n\t * @param args the arguments to be setup ready for the invocation\n\t * @return a repackaged array of arguments where any varargs setup has been done\n\t */\n\tpublic static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args) {\n\t\t// Check if array already built for final argument\n\t\tint parameterCount = requiredParameterTypes.length;\n\t\tint argumentCount = args.length;\n\n\t\t// Check if repackaging is needed...\n\t\tif (parameterCount != args.length ||\n\t\t\t\trequiredParameterTypes[parameterCount - 1] !=\n\t\t\t\t\t\t(args[argumentCount - 1] != null ? args[argumentCount - 1].getClass() : null)) {\n\n\t\t\t// Create an array for the leading arguments plus the varargs array argument.\n\t\t\tObject[] newArgs = new Object[parameterCount];\n\t\t\t// Copy all leading arguments to the new array, omitting the varargs array argument.\n\t\t\tSystem.arraycopy(args, 0, newArgs, 0, newArgs.length - 1);\n\n\t\t\t// Now sort out the final argument, which is the varargs one. Before entering this method,\n\t\t\t// the arguments should have been converted to the box form of the required type.\n\t\t\tint varargsArraySize = 0;  // zero size array if nothing to pass as the varargs parameter\n\t\t\tif (argumentCount >= parameterCount) {\n\t\t\t\tvarargsArraySize = argumentCount - (parameterCount - 1);\n\t\t\t}\n\t\t\tClass<?> componentType = requiredParameterTypes[parameterCount - 1].componentType();\n\t\t\tObject varargsArray = Array.newInstance(componentType, varargsArraySize);\n\t\t\tfor (int i = 0; i < varargsArraySize; i++) {\n\t\t\t\tArray.set(varargsArray, i, args[parameterCount - 1 + i]);\n\t\t\t}\n\t\t\t// Finally, add the varargs array to the new arguments array.\n\t\t\tnewArgs[newArgs.length - 1] = varargsArray;\n\t\t\treturn newArgs;\n\t\t}\n\t\treturn args;\n\t}\n\n\n\t/**\n\t * Arguments match kinds.\n\t */\n\tenum ArgumentsMatchKind {\n\n\t\t/** An exact match is where the parameter types exactly match what the method/constructor is expecting. */\n\t\tEXACT,\n\n\t\t/** A close match is where the parameter types either exactly match or are assignment-compatible. */\n\t\tCLOSE,\n\n\t\t/** A conversion match is where the type converter must be used to transform some of the parameter types. */\n\t\tREQUIRES_CONVERSION\n\t}\n\n\n\t/**\n\t * An instance of ArgumentsMatchInfo describes what kind of match was achieved\n\t * between two sets of arguments - the set that a method/constructor is expecting\n\t * and the set that are being supplied at the point of invocation. If the kind\n\t * indicates that conversion is required for some of the arguments then the arguments\n\t * that require conversion are listed in the argsRequiringConversion array.\n\t *\n\t * @param kind the kind of match that was achieved\n\t */\n\trecord ArgumentsMatchInfo(ArgumentsMatchKind kind) {\n\n\t\tpublic boolean isExactMatch() {\n\t\t\treturn (this.kind == ArgumentsMatchKind.EXACT);\n\t\t}\n\n\t\tpublic boolean isCloseMatch() {\n\t\t\treturn (this.kind == ArgumentsMatchKind.CLOSE);\n\t\t}\n\n\t\tpublic boolean isMatchRequiringConversion() {\n\t\t\treturn (this.kind == ArgumentsMatchKind.REQUIRES_CONVERSION);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"ArgumentMatchInfo: \" + this.kind;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.expression.spel.support.ReflectionHelper#convertAllArguments(converter,arguments,method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a supplied set of arguments into the requested types. If the parameterTypes are related to\n\t * a varargs method then the final entry in the parameterTypes array is going to be an array itself whose\n\t * component type should be used as the conversion target for extraneous arguments. (For example, if the\n\t * parameterTypes are {Integer, String[]} and the input arguments are {Integer, boolean, float} then both\n\t * the boolean and float must be converted to strings). This method does *not* repackage the arguments\n\t * into a form suitable for the varargs invocation - a subsequent call to setupArgumentsForVarargsInvocation handles that.\n\t * @param converter the converter to use for type conversions\n\t * @param arguments the arguments to convert to the requested parameter types\n\t * @param method the target Method\n\t * @return true if some kind of conversion occurred on the argument\n\t * @throws SpelEvaluationException if there is a problem with conversion\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "converter",
      "arguments",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "boolean",
    "signature": "public boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method)",
    "source_code": "\tpublic static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method)"
  },
  "org.springframework.expression.spel.support.ReflectionHelper#convertAllMethodHandleArguments(converter,arguments,methodHandle,varargsPosition)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Takes an input set of argument values and converts them to the types specified as the\n\t * required parameter types. The arguments are converted 'in-place' in the input array.\n\t * @param converter the type converter to use for attempting conversions\n\t * @param arguments the actual arguments that need conversion\n\t * @param methodHandle the target MethodHandle\n\t * @param varargsPosition the known position of the varargs argument, if any\n\t * ({@code null} if not varargs)\n\t * @return {@code true} if some kind of conversion occurred on an argument\n\t * @throws EvaluationException if a problem occurs during conversion\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "converter",
      "arguments",
      "methodHandle",
      "varargsPosition"
    ],
    "position": {
      "column": 1,
      "line": 349
    },
    "return": "boolean",
    "signature": "public boolean convertAllMethodHandleArguments(TypeConverter converter, Object[] arguments,\n\t\t\tMethodHandle methodHandle, @Nullable Integer varargsPosition)",
    "source_code": "\tpublic static boolean convertAllMethodHandleArguments(TypeConverter converter, Object[] arguments,"
  },
  "org.springframework.expression.spel.support.ReflectionHelper#getTypeDifferenceWeight(paramTypes,argTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Based on {@link MethodInvoker#getTypeDifferenceWeight(Class[], Object[])} but operates on TypeDescriptors.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramTypes",
      "argTypes"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "int",
    "signature": "public int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes)",
    "source_code": "\tpublic static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {\n\t\tint result = 0;\n\t\tfor (int i = 0; i < paramTypes.size(); i++) {\n\t\t\tTypeDescriptor paramType = paramTypes.get(i);\n\t\t\tTypeDescriptor argType = (i < argTypes.size() ? argTypes.get(i) : null);\n\t\t\tif (argType == null) {\n\t\t\t\tif (paramType.isPrimitive()) {\n\t\t\t\t\treturn Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tClass<?> paramTypeClazz = paramType.getType();\n\t\t\t\tif (!ClassUtils.isAssignable(paramTypeClazz, argType.getType())) {\n\t\t\t\t\treturn Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t\tif (paramTypeClazz.isPrimitive()) {\n\t\t\t\t\tparamTypeClazz = Object.class;\n\t\t\t\t}\n\t\t\t\tClass<?> superClass = argType.getType().getSuperclass();\n\t\t\t\twhile (superClass != null) {\n\t\t\t\t\tif (paramTypeClazz.equals(superClass)) {\n\t\t\t\t\t\tresult = result + 2;\n\t\t\t\t\t\tsuperClass = null;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {\n\t\t\t\t\t\tresult = result + 2;\n\t\t\t\t\t\tsuperClass = superClass.getSuperclass();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsuperClass = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (paramTypeClazz.isInterface()) {\n\t\t\t\t\tresult = result + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.expression.spel.support.ReflectionHelper#isCloseMatch()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 516
    },
    "return": "boolean",
    "signature": "public boolean isCloseMatch()",
    "source_code": "\t\tpublic boolean isCloseMatch() {\n\t\t\treturn (this.kind == ArgumentsMatchKind.CLOSE);\n\t\t}"
  },
  "org.springframework.expression.spel.support.ReflectionHelper#isExactMatch()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 512
    },
    "return": "boolean",
    "signature": "public boolean isExactMatch()",
    "source_code": "\t\tpublic boolean isExactMatch() {\n\t\t\treturn (this.kind == ArgumentsMatchKind.EXACT);\n\t\t}"
  },
  "org.springframework.expression.spel.support.ReflectionHelper#isMatchRequiringConversion()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 520
    },
    "return": "boolean",
    "signature": "public boolean isMatchRequiringConversion()",
    "source_code": "\t\tpublic boolean isMatchRequiringConversion() {\n\t\t\treturn (this.kind == ArgumentsMatchKind.REQUIRES_CONVERSION);\n\t\t}"
  },
  "org.springframework.expression.spel.support.ReflectionHelper#setupArgumentsForVarargsInvocation(requiredParameterTypes,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Package up the arguments so that they correctly match what is expected in requiredParameterTypes.\n\t * <p>For example, if requiredParameterTypes is {@code (int, String[])} because the second parameter\n\t * was declared {@code String...}, then if arguments is {@code [1,\"a\",\"b\"]} then it must be\n\t * repackaged as {@code [1,new String[]{\"a\",\"b\"}]} in order to match the expected types.\n\t * @param requiredParameterTypes the types of the parameters for the invocation\n\t * @param args the arguments to be setup ready for the invocation\n\t * @return a repackaged array of arguments where any varargs setup has been done\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredParameterTypes",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 451
    },
    "return": "Object[]",
    "signature": "public Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args)",
    "source_code": "\tpublic static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args) {\n\t\t// Check if array already built for final argument\n\t\tint parameterCount = requiredParameterTypes.length;\n\t\tint argumentCount = args.length;\n\n\t\t// Check if repackaging is needed...\n\t\tif (parameterCount != args.length ||\n\t\t\t\trequiredParameterTypes[parameterCount - 1] !=\n\t\t\t\t\t\t(args[argumentCount - 1] != null ? args[argumentCount - 1].getClass() : null)) {\n\n\t\t\t// Create an array for the leading arguments plus the varargs array argument.\n\t\t\tObject[] newArgs = new Object[parameterCount];\n\t\t\t// Copy all leading arguments to the new array, omitting the varargs array argument.\n\t\t\tSystem.arraycopy(args, 0, newArgs, 0, newArgs.length - 1);\n\n\t\t\t// Now sort out the final argument, which is the varargs one. Before entering this method,\n\t\t\t// the arguments should have been converted to the box form of the required type.\n\t\t\tint varargsArraySize = 0;  // zero size array if nothing to pass as the varargs parameter\n\t\t\tif (argumentCount >= parameterCount) {\n\t\t\t\tvarargsArraySize = argumentCount - (parameterCount - 1);\n\t\t\t}\n\t\t\tClass<?> componentType = requiredParameterTypes[parameterCount - 1].componentType();\n\t\t\tObject varargsArray = Array.newInstance(componentType, varargsArraySize);\n\t\t\tfor (int i = 0; i < varargsArraySize; i++) {\n\t\t\t\tArray.set(varargsArray, i, args[parameterCount - 1 + i]);\n\t\t\t}\n\t\t\t// Finally, add the varargs array to the new arguments array.\n\t\t\tnewArgs[newArgs.length - 1] = varargsArray;\n\t\t\treturn newArgs;\n\t\t}\n\t\treturn args;\n\t}"
  },
  "org.springframework.expression.spel.support.ReflectionHelper#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 525
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn \"ArgumentMatchInfo: \" + this.kind;\n\t\t}"
  },
  "org.springframework.expression.spel.support.ReflectivePropertyAccessor#isKotlinProperty(method,methodSuffix)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "methodSuffix"
    ],
    "position": {
      "column": 1,
      "line": 769
    },
    "return": "boolean",
    "signature": "public boolean isKotlinProperty(Method method, String methodSuffix)",
    "source_code": "\t\tpublic static boolean isKotlinProperty(Method method, String methodSuffix) {\n\t\t\tKClass<?> kClass = JvmClassMappingKt.getKotlinClass(method.getDeclaringClass());\n\t\t\tfor (KProperty<?> property : KClasses.getMemberProperties(kClass)) {\n\t\t\t\tif (methodSuffix.equalsIgnoreCase(property.getName()) &&\n\t\t\t\t\t\t(method.equals(ReflectJvmMapping.getJavaGetter(property)) ||\n\t\t\t\t\t\t\t\tproperty instanceof KMutableProperty<?> mutableProperty &&\n\t\t\t\t\t\t\t\t\t\tmethod.equals(ReflectJvmMapping.getJavaSetter(mutableProperty)))) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.format.datetime.DateFormatter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A formatter for {@link java.util.Date} types.\n * <p>Supports the configuration of an explicit date time pattern, timezone,\n * locale, and fallback date time patterns for lenient parsing.\n *\n * @author Keith Donald\n * @author Juergen Hoeller\n * @author Phillip Webb\n * @author Sam Brannen\n * @since 3.0\n * @see SimpleDateFormat\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public class DateFormatter",
    "source_code": "public class DateFormatter implements Formatter<Date> {\n\n\tprivate static final TimeZone UTC = TimeZone.getTimeZone(\"UTC\");\n\n\t// We use an EnumMap instead of Map.of(...) since the former provides better performance.\n\tprivate static final Map<ISO, String> ISO_PATTERNS;\n\n\tstatic {\n\t\tMap<ISO, String> formats = new EnumMap<>(ISO.class);\n\t\tformats.put(ISO.DATE, \"yyyy-MM-dd\");\n\t\tformats.put(ISO.TIME, \"HH:mm:ss.SSSXXX\");\n\t\tformats.put(ISO.DATE_TIME, \"yyyy-MM-dd'T'HH:mm:ss.SSSXXX\");\n\t\tISO_PATTERNS = Collections.unmodifiableMap(formats);\n\t}\n\n\n\t@Nullable\n\tprivate Object source;\n\n\t@Nullable\n\tprivate String pattern;\n\n\t@Nullable\n\tprivate String[] fallbackPatterns;\n\n\tprivate int style = DateFormat.DEFAULT;\n\n\t@Nullable\n\tprivate String stylePattern;\n\n\t@Nullable\n\tprivate ISO iso;\n\n\t@Nullable\n\tprivate TimeZone timeZone;\n\n\tprivate boolean lenient = false;\n\n\n\t/**\n\t * Create a new default {@code DateFormatter}.\n\t */\n\tpublic DateFormatter() {\n\t}\n\n\t/**\n\t * Create a new {@code DateFormatter} for the given date time pattern.\n\t */\n\tpublic DateFormatter(String pattern) {\n\t\tthis.pattern = pattern;\n\t}\n\n\n\t/**\n\t * Set the source of the configuration for this {@code DateFormatter} &mdash;\n\t * for example, an instance of the {@link DateTimeFormat @DateTimeFormat}\n\t * annotation if such an annotation was used to configure this {@code DateFormatter}.\n\t * <p>The supplied source object will only be used for descriptive purposes\n\t * by invoking its {@code toString()} method &mdash; for example, when\n\t * generating an exception message to provide further context.\n\t * @param source the source of the configuration\n\t * @since 5.3.5\n\t */\n\tpublic void setSource(Object source) {\n\t\tthis.source = source;\n\t}\n\n\t/**\n\t * Set the pattern to use to format date values.\n\t * <p>If not specified, DateFormat's default style will be used.\n\t */\n\tpublic void setPattern(String pattern) {\n\t\tthis.pattern = pattern;\n\t}\n\n\t/**\n\t * Set additional patterns to use as a fallback in case parsing fails for the\n\t * configured {@linkplain #setPattern pattern}, {@linkplain #setIso ISO format},\n\t * {@linkplain #setStyle style}, or {@linkplain #setStylePattern style pattern}.\n\t * @param fallbackPatterns the fallback parsing patterns\n\t * @since 5.3.5\n\t * @see DateTimeFormat#fallbackPatterns()\n\t */\n\tpublic void setFallbackPatterns(String... fallbackPatterns) {\n\t\tthis.fallbackPatterns = fallbackPatterns;\n\t}\n\n\t/**\n\t * Set the ISO format to use to format date values.\n\t * @param iso the {@link ISO} format\n\t * @since 3.2\n\t */\n\tpublic void setIso(ISO iso) {\n\t\tthis.iso = iso;\n\t}\n\n\t/**\n\t * Set the {@link DateFormat} style to use to format date values.\n\t * <p>If not specified, DateFormat's default style will be used.\n\t * @see DateFormat#DEFAULT\n\t * @see DateFormat#SHORT\n\t * @see DateFormat#MEDIUM\n\t * @see DateFormat#LONG\n\t * @see DateFormat#FULL\n\t */\n\tpublic void setStyle(int style) {\n\t\tthis.style = style;\n\t}\n\n\t/**\n\t * Set the two characters to use to format date values.\n\t * <p>The first character is used for the date style; the second is used for\n\t * the time style.\n\t * <p>Supported characters:\n\t * <ul>\n\t * <li>'S' = Small</li>\n\t * <li>'M' = Medium</li>\n\t * <li>'L' = Long</li>\n\t * <li>'F' = Full</li>\n\t * <li>'-' = Omitted</li>\n\t * </ul>\n\t * This method mimics the styles supported by Joda-Time.\n\t * @param stylePattern two characters from the set {\"S\", \"M\", \"L\", \"F\", \"-\"}\n\t * @since 3.2\n\t */\n\tpublic void setStylePattern(String stylePattern) {\n\t\tthis.stylePattern = stylePattern;\n\t}\n\n\t/**\n\t * Set the {@link TimeZone} to normalize the date values into, if any.\n\t */\n\tpublic void setTimeZone(TimeZone timeZone) {\n\t\tthis.timeZone = timeZone;\n\t}\n\n\t/**\n\t * Specify whether parsing is to be lenient. Default is {@code false}.\n\t * <p>With lenient parsing, the parser may allow inputs that do not precisely match the format.\n\t * With strict parsing, inputs must match the format exactly.\n\t */\n\tpublic void setLenient(boolean lenient) {\n\t\tthis.lenient = lenient;\n\t}\n\n\n\t@Override\n\tpublic String print(Date date, Locale locale) {\n\t\treturn getDateFormat(locale).format(date);\n\t}\n\n\t@Override\n\tpublic Date parse(String text, Locale locale) throws ParseException {\n\t\ttry {\n\t\t\treturn getDateFormat(locale).parse(text);\n\t\t}\n\t\tcatch (ParseException ex) {\n\t\t\tif (!ObjectUtils.isEmpty(this.fallbackPatterns)) {\n\t\t\t\tfor (String pattern : this.fallbackPatterns) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tDateFormat dateFormat = configureDateFormat(new SimpleDateFormat(pattern, locale));\n\t\t\t\t\t\t// Align timezone for parsing format with printing format if ISO is set.\n\t\t\t\t\t\tif (this.iso != null && this.iso != ISO.NONE) {\n\t\t\t\t\t\t\tdateFormat.setTimeZone(UTC);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn dateFormat.parse(text);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (ParseException ignoredException) {\n\t\t\t\t\t\t// Ignore fallback parsing exceptions since the exception thrown below\n\t\t\t\t\t\t// will include information from the \"source\" if available -- for example,\n\t\t\t\t\t\t// the toString() of a @DateTimeFormat annotation.\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.source != null) {\n\t\t\t\tParseException parseException = new ParseException(\n\t\t\t\t\tString.format(\"Unable to parse date time value \\\"%s\\\" using configuration from %s\", text, this.source),\n\t\t\t\t\tex.getErrorOffset());\n\t\t\t\tparseException.initCause(ex);\n\t\t\t\tthrow parseException;\n\t\t\t}\n\t\t\t// else rethrow original exception\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\n\tprotected DateFormat getDateFormat(Locale locale) {\n\t\treturn configureDateFormat(createDateFormat(locale));\n\t}\n\n\tprivate DateFormat configureDateFormat(DateFormat dateFormat) {\n\t\tif (this.timeZone != null) {\n\t\t\tdateFormat.setTimeZone(this.timeZone);\n\t\t}\n\t\tdateFormat.setLenient(this.lenient);\n\t\treturn dateFormat;\n\t}\n\n\tprivate DateFormat createDateFormat(Locale locale) {\n\t\tif (StringUtils.hasLength(this.pattern)) {\n\t\t\treturn new SimpleDateFormat(this.pattern, locale);\n\t\t}\n\t\tif (this.iso != null && this.iso != ISO.NONE) {\n\t\t\tString pattern = ISO_PATTERNS.get(this.iso);\n\t\t\tif (pattern == null) {\n\t\t\t\tthrow new IllegalStateException(\"Unsupported ISO format \" + this.iso);\n\t\t\t}\n\t\t\tSimpleDateFormat format = new SimpleDateFormat(pattern);\n\t\t\tformat.setTimeZone(UTC);\n\t\t\treturn format;\n\t\t}\n\t\tif (StringUtils.hasLength(this.stylePattern)) {\n\t\t\tint dateStyle = getStylePatternForChar(0);\n\t\t\tint timeStyle = getStylePatternForChar(1);\n\t\t\tif (dateStyle != -1 && timeStyle != -1) {\n\t\t\t\treturn DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale);\n\t\t\t}\n\t\t\tif (dateStyle != -1) {\n\t\t\t\treturn DateFormat.getDateInstance(dateStyle, locale);\n\t\t\t}\n\t\t\tif (timeStyle != -1) {\n\t\t\t\treturn DateFormat.getTimeInstance(timeStyle, locale);\n\t\t\t}\n\t\t\tthrow unsupportedStylePatternException();\n\n\t\t}\n\t\treturn DateFormat.getDateInstance(this.style, locale);\n\t}\n\n\tprivate int getStylePatternForChar(int index) {\n\t\tif (this.stylePattern != null && this.stylePattern.length() > index) {\n\t\t\tchar ch = this.stylePattern.charAt(index);\n\t\t\treturn switch (ch) {\n\t\t\t\tcase 'S' -> DateFormat.SHORT;\n\t\t\t\tcase 'M' -> DateFormat.MEDIUM;\n\t\t\t\tcase 'L' -> DateFormat.LONG;\n\t\t\t\tcase 'F' -> DateFormat.FULL;\n\t\t\t\tcase '-' -> -1;\n\t\t\t\tdefault -> throw unsupportedStylePatternException();\n\t\t\t};\n\t\t}\n\t\tthrow unsupportedStylePatternException();\n\t}\n\n\tprivate IllegalStateException unsupportedStylePatternException() {\n\t\treturn new IllegalStateException(\"Unsupported style pattern '\" + this.stylePattern + \"'\");\n\t}\n\n}"
  },
  "org.springframework.format.datetime.DateFormatter#getDateFormat(locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "DateFormat",
    "signature": "protected DateFormat getDateFormat(Locale locale)",
    "source_code": "\tprotected DateFormat getDateFormat(Locale locale) {\n\t\treturn configureDateFormat(createDateFormat(locale));\n\t}"
  },
  "org.springframework.format.datetime.DateFormatter#parse(text,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "Date",
    "signature": "public Date parse(String text, Locale locale)",
    "source_code": "\tpublic Date parse(String text, Locale locale) throws ParseException {\n\t\ttry {\n\t\t\treturn getDateFormat(locale).parse(text);\n\t\t}\n\t\tcatch (ParseException ex) {\n\t\t\tif (!ObjectUtils.isEmpty(this.fallbackPatterns)) {\n\t\t\t\tfor (String pattern : this.fallbackPatterns) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tDateFormat dateFormat = configureDateFormat(new SimpleDateFormat(pattern, locale));\n\t\t\t\t\t\t// Align timezone for parsing format with printing format if ISO is set.\n\t\t\t\t\t\tif (this.iso != null && this.iso != ISO.NONE) {\n\t\t\t\t\t\t\tdateFormat.setTimeZone(UTC);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn dateFormat.parse(text);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (ParseException ignoredException) {\n\t\t\t\t\t\t// Ignore fallback parsing exceptions since the exception thrown below\n\t\t\t\t\t\t// will include information from the \"source\" if available -- for example,\n\t\t\t\t\t\t// the toString() of a @DateTimeFormat annotation.\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.source != null) {\n\t\t\t\tParseException parseException = new ParseException(\n\t\t\t\t\tString.format(\"Unable to parse date time value \\\"%s\\\" using configuration from %s\", text, this.source),\n\t\t\t\t\tex.getErrorOffset());\n\t\t\t\tparseException.initCause(ex);\n\t\t\t\tthrow parseException;\n\t\t\t}\n\t\t\t// else rethrow original exception\n\t\t\tthrow ex;\n\t\t}\n\t}"
  },
  "org.springframework.format.datetime.DateFormatter#print(date,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "date",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 195
    },
    "return": "String",
    "signature": "public String print(Date date, Locale locale)",
    "source_code": "\tpublic String print(Date date, Locale locale) {\n\t\treturn getDateFormat(locale).format(date);\n\t}"
  },
  "org.springframework.format.datetime.DateFormatter#setFallbackPatterns(fallbackPatterns)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set additional patterns to use as a fallback in case parsing fails for the\n\t * configured {@linkplain #setPattern pattern}, {@linkplain #setIso ISO format},\n\t * {@linkplain #setStyle style}, or {@linkplain #setStylePattern style pattern}.\n\t * @param fallbackPatterns the fallback parsing patterns\n\t * @since 5.3.5\n\t * @see DateTimeFormat#fallbackPatterns()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fallbackPatterns"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "void",
    "signature": "public void setFallbackPatterns(String... fallbackPatterns)",
    "source_code": "\tpublic void setFallbackPatterns(String... fallbackPatterns) {\n\t\tthis.fallbackPatterns = fallbackPatterns;\n\t}"
  },
  "org.springframework.format.datetime.DateFormatter#setIso(iso)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the ISO format to use to format date values.\n\t * @param iso the {@link ISO} format\n\t * @since 3.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "iso"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "void",
    "signature": "public void setIso(ISO iso)",
    "source_code": "\tpublic void setIso(ISO iso) {\n\t\tthis.iso = iso;\n\t}"
  },
  "org.springframework.format.datetime.DateFormatter#setLenient(lenient)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether parsing is to be lenient. Default is {@code false}.\n\t * <p>With lenient parsing, the parser may allow inputs that do not precisely match the format.\n\t * With strict parsing, inputs must match the format exactly.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lenient"
    ],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "void",
    "signature": "public void setLenient(boolean lenient)",
    "source_code": "\tpublic void setLenient(boolean lenient) {\n\t\tthis.lenient = lenient;\n\t}"
  },
  "org.springframework.format.datetime.DateFormatter#setPattern(pattern)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the pattern to use to format date values.\n\t * <p>If not specified, DateFormat's default style will be used.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pattern"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "void",
    "signature": "public void setPattern(String pattern)",
    "source_code": "\tpublic void setPattern(String pattern) {\n\t\tthis.pattern = pattern;\n\t}"
  },
  "org.springframework.format.datetime.DateFormatter#setSource(source)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the source of the configuration for this {@code DateFormatter} &mdash;\n\t * for example, an instance of the {@link DateTimeFormat @DateTimeFormat}\n\t * annotation if such an annotation was used to configure this {@code DateFormatter}.\n\t * <p>The supplied source object will only be used for descriptive purposes\n\t * by invoking its {@code toString()} method &mdash; for example, when\n\t * generating an exception message to provide further context.\n\t * @param source the source of the configuration\n\t * @since 5.3.5\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void setSource(Object source)",
    "source_code": "\tpublic void setSource(Object source) {\n\t\tthis.source = source;\n\t}"
  },
  "org.springframework.format.datetime.DateFormatter#setStyle(style)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link DateFormat} style to use to format date values.\n\t * <p>If not specified, DateFormat's default style will be used.\n\t * @see DateFormat#DEFAULT\n\t * @see DateFormat#SHORT\n\t * @see DateFormat#MEDIUM\n\t * @see DateFormat#LONG\n\t * @see DateFormat#FULL\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "style"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "void",
    "signature": "public void setStyle(int style)",
    "source_code": "\tpublic void setStyle(int style) {\n\t\tthis.style = style;\n\t}"
  },
  "org.springframework.format.datetime.DateFormatter#setStylePattern(stylePattern)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the two characters to use to format date values.\n\t * <p>The first character is used for the date style; the second is used for\n\t * the time style.\n\t * <p>Supported characters:\n\t * <ul>\n\t * <li>'S' = Small</li>\n\t * <li>'M' = Medium</li>\n\t * <li>'L' = Long</li>\n\t * <li>'F' = Full</li>\n\t * <li>'-' = Omitted</li>\n\t * </ul>\n\t * This method mimics the styles supported by Joda-Time.\n\t * @param stylePattern two characters from the set {\"S\", \"M\", \"L\", \"F\", \"-\"}\n\t * @since 3.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "stylePattern"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "void",
    "signature": "public void setStylePattern(String stylePattern)",
    "source_code": "\tpublic void setStylePattern(String stylePattern) {\n\t\tthis.stylePattern = stylePattern;\n\t}"
  },
  "org.springframework.format.datetime.DateFormatter#setTimeZone(timeZone)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link TimeZone} to normalize the date values into, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeZone"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "void",
    "signature": "public void setTimeZone(TimeZone timeZone)",
    "source_code": "\tpublic void setTimeZone(TimeZone timeZone) {\n\t\tthis.timeZone = timeZone;\n\t}"
  },
  "org.springframework.http.HttpMethod#resolve(method)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the given method value to an {@code HttpMethod}.\n\t * @param method the method value as a String\n\t * @return the corresponding {@code HttpMethod}, or {@code null} if not found\n\t * @since 4.2.4\n\t * @deprecated in favor of {@link #valueOf(String)}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "HttpMethod",
    "signature": "public HttpMethod resolve(@Nullable String method)",
    "source_code": "\tpublic static HttpMethod resolve(@Nullable String method) {\n\t\treturn (method != null ? valueOf(method) : null);\n\t}"
  },
  "org.springframework.http.client.<unknown>#close()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\tpublic void close() {\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tStreamUtils.drain(this.body);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.body.close();\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ignored) {\n\t\t}\n\t}"
  },
  "org.springframework.http.client.<unknown>#executeInternal(headers,body)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "headers",
      "body"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "ClientHttpResponse",
    "signature": "protected ClientHttpResponse executeInternal(HttpHeaders headers, @Nullable Body body)",
    "source_code": "\tprotected ClientHttpResponse executeInternal(HttpHeaders headers, @Nullable Body body) throws IOException {\n\t\ttry {\n\t\t\tHttpRequest request = buildRequest(headers, body);\n\t\t\tHttpResponse<InputStream> response;\n\t\t\tif (this.timeout != null) {\n\t\t\t\tresponse = this.httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofInputStream())\n\t\t\t\t\t\t.get(this.timeout.toMillis(), TimeUnit.MILLISECONDS);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresponse = this.httpClient.send(request, HttpResponse.BodyHandlers.ofInputStream());\n\t\t\t}\n\t\t\treturn new JdkClientHttpResponse(response);\n\t\t}\n\t\tcatch (UncheckedIOException ex) {\n\t\t\tthrow ex.getCause();\n\t\t}\n\t\tcatch (InterruptedException ex) {\n\t\t\tThread.currentThread().interrupt();\n\t\t\tthrow new IOException(\"Request was interrupted: \" + ex.getMessage(), ex);\n\t\t}\n\t\tcatch (ExecutionException ex) {\n\t\t\tThrowable cause = ex.getCause();\n\n\t\t\tif (cause instanceof UncheckedIOException uioEx) {\n\t\t\t\tthrow uioEx.getCause();\n\t\t\t}\n\t\t\tif (cause instanceof RuntimeException rtEx) {\n\t\t\t\tthrow rtEx;\n\t\t\t}\n\t\t\telse if (cause instanceof IOException ioEx) {\n\t\t\t\tthrow ioEx;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IOException(cause.getMessage(), cause);\n\t\t\t}\n\t\t}\n\t\tcatch (TimeoutException ex) {\n\t\t\tthrow new IOException(\"Request timed out: \" + ex.getMessage(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.http.client.<unknown>#getBody()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "InputStream",
    "signature": "public InputStream getBody()",
    "source_code": "\tpublic InputStream getBody() throws IOException {\n\t\treturn this.body;\n\t}"
  },
  "org.springframework.http.client.<unknown>#getHeaders()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders getHeaders()",
    "source_code": "\tpublic HttpHeaders getHeaders() {\n\t\treturn this.headers;\n\t}"
  },
  "org.springframework.http.client.<unknown>#getStatusCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "HttpStatusCode",
    "signature": "public HttpStatusCode getStatusCode()",
    "source_code": "\tpublic HttpStatusCode getStatusCode() {\n\t\treturn HttpStatusCode.valueOf(this.response.statusCode());\n\t}"
  },
  "org.springframework.http.client.<unknown>#getStatusText()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "String",
    "signature": "public String getStatusText()",
    "source_code": "\tpublic String getStatusText() {\n\t\t// HttpResponse does not expose status text\n\t\tif (getStatusCode() instanceof HttpStatus status) {\n\t\t\treturn status.getReasonPhrase();\n\t\t}\n\t\telse {\n\t\t\treturn \"\";\n\t\t}\n\t}"
  },
  "org.springframework.http.client.<unknown>#map(b)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b"
    ],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer map(int b)",
    "source_code": "\t\tpublic ByteBuffer map(int b) {\n\t\t\tByteBuffer byteBuffer = ByteBuffer.allocate(1);\n\t\t\tbyteBuffer.put((byte) b);\n\t\t\tbyteBuffer.flip();\n\t\t\treturn byteBuffer;\n\t\t}"
  },
  "org.springframework.http.client.<unknown>#map(b,off,len)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b",
      "off",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer map(byte[] b, int off, int len)",
    "source_code": "\t\tpublic ByteBuffer map(byte[] b, int off, int len) {\n\t\t\tByteBuffer byteBuffer = ByteBuffer.allocate(len);\n\t\t\tbyteBuffer.put(b, off, len);\n\t\t\tbyteBuffer.flip();\n\t\t\treturn byteBuffer;\n\t\t}"
  },
  "org.springframework.http.client.<unknown>#repeatable()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "boolean",
    "signature": "public boolean repeatable()",
    "source_code": "\t\t\t\t\tpublic boolean repeatable() {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}"
  },
  "org.springframework.http.client.<unknown>#writeTo(outputStream)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outputStream"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "void",
    "signature": "public void writeTo(OutputStream outputStream)",
    "source_code": "\t\t\t\t\tpublic void writeTo(OutputStream outputStream) throws IOException {\n\t\t\t\t\t\tStreamUtils.copy(bufferedOutput, outputStream);\n\t\t\t\t\t}"
  },
  "org.springframework.http.client.HttpComponentsClientHttpRequestFactory#setReadTimeout(timeout)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * As of version 6.0, setting this property has no effect.\n\t * <p>To change the socket read timeout, use {@link SocketConfig.Builder#setSoTimeout(Timeout)},\n\t * supply the resulting {@link SocketConfig} to\n\t * {@link org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManagerBuilder#setDefaultSocketConfig(SocketConfig)},\n\t * use the resulting connection manager for\n\t * {@link org.apache.hc.client5.http.impl.classic.HttpClientBuilder#setConnectionManager(HttpClientConnectionManager)},\n\t * and supply the built {@link HttpClient} to {@link #HttpComponentsClientHttpRequestFactory(HttpClient)}.\n\t * @deprecated as of 6.0, in favor of {@link SocketConfig.Builder#setSoTimeout(Timeout)}, see above.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "void",
    "signature": "public void setReadTimeout(int timeout)",
    "source_code": "\tpublic void setReadTimeout(int timeout) {\n\t\tlogger.warn(\"HttpComponentsClientHttpRequestFactory.setReadTimeout has no effect\");\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#add(key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "void",
    "signature": "public void add(String key, @Nullable String value)",
    "source_code": "\tpublic void add(String key, @Nullable String value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tmutableHttpFields.add(key, value);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#addAll(MultiValueMap<String,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this::addAll);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#addAll(key,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "public void addAll(String key, List<? extends String> values)",
    "source_code": "\tpublic void addAll(String key, List<? extends String> values) {\n\t\tvalues.forEach(value -> add(key, value));\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#clear()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\tpublic void clear() {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tmutableHttpFields.clear();\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#containsKey(key)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "boolean",
    "signature": "public boolean containsKey(Object key)",
    "source_code": "\tpublic boolean containsKey(Object key) {\n\t\treturn (key instanceof String headerName && this.headers.contains(headerName));\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#containsValue(value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "boolean",
    "signature": "public boolean containsValue(Object value)",
    "source_code": "\tpublic boolean containsValue(Object value) {\n\t\treturn (value instanceof String searchString &&\n\t\t\t\tthis.headers.stream().anyMatch(field -> field.contains(searchString)));\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#entrySet()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "List<String>>>",
    "signature": "public List<String>>> entrySet()",
    "source_code": "\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn new AbstractSet<>() {\n\t\t\t@Override\n\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn headers.size();\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#get(key)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "List<String>",
    "signature": "public List<String> get(Object key)",
    "source_code": "\tpublic List<String> get(Object key) {\n\t\tif (containsKey(key)) {\n\t\t\treturn this.headers.getValuesList((String) key);\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#getFirst(key)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "String",
    "signature": "public String getFirst(String key)",
    "source_code": "\tpublic String getFirst(String key) {\n\t\treturn this.headers.get(key);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#getKey()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "String",
    "signature": "public String getKey()",
    "source_code": "\t\tpublic String getKey() {\n\t\t\treturn this.key;\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#getValue()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "List<String>",
    "signature": "public List<String> getValue()",
    "source_code": "\t\tpublic List<String> getValue() {\n\t\t\treturn headers.getValuesList(this.key);\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#hasNext()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 275
    },
    "return": "boolean",
    "signature": "public boolean hasNext()",
    "source_code": "\t\tpublic boolean hasNext() {\n\t\t\treturn this.iterator.hasNext();\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#isEmpty()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "boolean",
    "signature": "public boolean isEmpty()",
    "source_code": "\tpublic boolean isEmpty() {\n\t\treturn (this.headers.size() == 0);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#iterator()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "Iterator<String>",
    "signature": "public Iterator<String> iterator()",
    "source_code": "\t\tpublic Iterator<String> iterator() {\n\t\t\treturn new HeaderNamesIterator(headers.getFieldNamesCollection().iterator());\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#keySet()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "Set<String>",
    "signature": "public Set<String> keySet()",
    "source_code": "\tpublic Set<String> keySet() {\n\t\treturn new HeaderNames();\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#next()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "String",
    "signature": "public String next()",
    "source_code": "\t\tpublic String next() {\n\t\t\tthis.currentName = this.iterator.next();\n\t\t\treturn this.currentName;\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#put(key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> value)",
    "source_code": "\tpublic List<String> put(String key, List<String> value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tList<String> oldValues = get(key);\n\t\tmutableHttpFields.put(key, value);\n\t\treturn oldValues;\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#put(key,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> values)",
    "source_code": "\tpublic List<String> put(String key, List<String> values) {\n\t\tList<String> oldValues = remove(key);\n\t\tvalues.forEach(value -> add(key, value));\n\t\treturn oldValues;\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#putAll(String,map)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this::put);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#remove()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "void",
    "signature": "public void remove()",
    "source_code": "\t\tpublic void remove() {\n\t\t\tif (!(headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t\t}\n\t\t\tif (this.currentName == null) {\n\t\t\t\tthrow new IllegalStateException(\"No current Header in iterator\");\n\t\t\t}\n\t\t\tif (!headers.contains(this.currentName)) {\n\t\t\t\tthrow new IllegalStateException(\"Header not present: \" + this.currentName);\n\t\t\t}\n\t\t\tmutableHttpFields.remove(this.currentName);\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#remove(key)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "List<String>",
    "signature": "public List<String> remove(Object key)",
    "source_code": "\tpublic List<String> remove(Object key) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tif (key instanceof String name) {\n\t\t\tList<String> oldValues = get(key);\n\t\t\tmutableHttpFields.remove(name);\n\t\t\treturn oldValues;\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#set(key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "public void set(String key, @Nullable String value)",
    "source_code": "\tpublic void set(String key, @Nullable String value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tmutableHttpFields.put(key, value);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#setAll(Map<String,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this::set);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#setValue(value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "List<String>",
    "signature": "public List<String> setValue(List<String> value)",
    "source_code": "\t\tpublic List<String> setValue(List<String> value) {\n\t\t\tif (!(headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t\t}\n\t\t\tList<String> previousValues = headers.getValuesList(this.key);\n\t\t\tmutableHttpFields.put(this.key, value);\n\t\t\treturn previousValues;\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#size()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 257
    },
    "return": "int",
    "signature": "public int size()",
    "source_code": "\t\tpublic int size() {\n\t\t\treturn headers.getFieldNamesCollection().size();\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#toSingleValueMap()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "String>",
    "signature": "public String> toSingleValueMap()",
    "source_code": "\tpublic Map<String, String> toSingleValueMap() {\n\t\tMap<String, String> singleValueMap = CollectionUtils.newLinkedHashMap(this.headers.size());\n\t\tIterator<HttpField> iterator = this.headers.iterator();\n\t\titerator.forEachRemaining(field -> {\n\t\t\tif (!singleValueMap.containsKey(field.getName())) {\n\t\t\t\tsingleValueMap.put(field.getName(), field.getValue());\n\t\t\t}\n\t\t});\n\t\treturn singleValueMap;\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#values()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "Collection<List<String>>",
    "signature": "public Collection<List<String>> values()",
    "source_code": "\tpublic Collection<List<String>> values() {\n\t\treturn this.headers.getFieldNamesCollection().stream()\n\t\t\t\t.map(this.headers::getValuesList).toList();\n\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link ClientHttpConnector} for the Jetty Reactive Streams HttpClient.\n *\n * @author Sebastien Deleuze\n * @since 5.1\n * @see <a href=\"https://github.com/jetty-project/jetty-reactive-httpclient\">Jetty ReactiveStreams HttpClient</a>\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "signature": "public class JettyClientHttpConnector",
    "source_code": "public class JettyClientHttpConnector implements ClientHttpConnector {\n\n\tprivate final HttpClient httpClient;\n\n\tprivate DataBufferFactory bufferFactory = DefaultDataBufferFactory.sharedInstance;\n\n\n\t/**\n\t * Default constructor that creates a new instance of {@link HttpClient}.\n\t */\n\tpublic JettyClientHttpConnector() {\n\t\tthis(new HttpClient());\n\t}\n\n\t/**\n\t * Constructor with an initialized {@link HttpClient}.\n\t */\n\tpublic JettyClientHttpConnector(HttpClient httpClient) {\n\t\tthis(httpClient, null);\n\t}\n\n\t/**\n\t * Constructor with an initialized {@link HttpClient} and configures it\n\t * with the given {@link JettyResourceFactory}.\n\t * @param httpClient the {@link HttpClient} to use\n\t * @param resourceFactory the {@link JettyResourceFactory} to use\n\t * @since 5.2\n\t */\n\tpublic JettyClientHttpConnector(HttpClient httpClient, @Nullable JettyResourceFactory resourceFactory) {\n\t\tAssert.notNull(httpClient, \"HttpClient is required\");\n\t\tif (resourceFactory != null) {\n\t\t\thttpClient.setExecutor(resourceFactory.getExecutor());\n\t\t\thttpClient.setByteBufferPool(resourceFactory.getByteBufferPool());\n\t\t\thttpClient.setScheduler(resourceFactory.getScheduler());\n\t\t}\n\t\tthis.httpClient = httpClient;\n\t}\n\n\t/**\n\t * Constructor with an {@link JettyResourceFactory} that will manage shared resources.\n\t * @param resourceFactory the {@link JettyResourceFactory} to use\n\t * @param customizer the lambda used to customize the {@link HttpClient}\n\t * @deprecated as of 5.2, in favor of\n\t * {@link JettyClientHttpConnector#JettyClientHttpConnector(HttpClient, JettyResourceFactory)}\n\t */\n\t@Deprecated\n\tpublic JettyClientHttpConnector(JettyResourceFactory resourceFactory, @Nullable Consumer<HttpClient> customizer) {\n\t\tthis(new HttpClient(), resourceFactory);\n\t\tif (customizer != null) {\n\t\t\tcustomizer.accept(this.httpClient);\n\t\t}\n\t}\n\n\n\t/**\n\t * Set the buffer factory to use.\n\t */\n\tpublic void setBufferFactory(DataBufferFactory bufferFactory) {\n\t\tthis.bufferFactory = bufferFactory;\n\t}\n\n\n\t@Override\n\tpublic Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,\n\t\t\tFunction<? super ClientHttpRequest, Mono<Void>> requestCallback) {\n\n\t\tif (!uri.isAbsolute()) {\n\t\t\treturn Mono.error(new IllegalArgumentException(\"URI is not absolute: \" + uri));\n\t\t}\n\n\t\tif (!this.httpClient.isStarted()) {\n\t\t\ttry {\n\t\t\t\tthis.httpClient.start();\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\treturn Mono.error(ex);\n\t\t\t}\n\t\t}\n\n\t\tRequest jettyRequest = this.httpClient.newRequest(uri).method(method.toString());\n\t\tJettyClientHttpRequest request = new JettyClientHttpRequest(jettyRequest, this.bufferFactory);\n\n\t\treturn requestCallback.apply(request).then(execute(request));\n\t}\n\n\tprivate Mono<ClientHttpResponse> execute(JettyClientHttpRequest request) {\n\t\treturn Mono.fromDirect(request.toReactiveRequest()\n\t\t\t\t.response((reactiveResponse, chunkPublisher) -> {\n\t\t\t\t\tFlux<DataBuffer> content = Flux.from(chunkPublisher).map(this::toDataBuffer);\n\t\t\t\t\treturn Mono.just(new JettyClientHttpResponse(reactiveResponse, content));\n\t\t\t\t}));\n\t}\n\n\tprivate DataBuffer toDataBuffer(Content.Chunk chunk) {\n\t\tDataBuffer delegate = this.bufferFactory.wrap(chunk.getByteBuffer());\n\t\treturn new JettyDataBuffer(delegate, chunk);\n\t}\n\n\n\tprivate static final class JettyDataBuffer implements PooledDataBuffer {\n\n\t\tprivate final DataBuffer delegate;\n\n\t\tprivate final Content.Chunk chunk;\n\n\t\tprivate final AtomicInteger refCount = new AtomicInteger(1);\n\n\n\t\tpublic JettyDataBuffer(DataBuffer delegate, Content.Chunk chunk) {\n\t\t\tAssert.notNull(delegate, \"Delegate must not be null\");\n\t\t\tAssert.notNull(chunk, \"Chunk must not be null\");\n\n\t\t\tthis.delegate = delegate;\n\t\t\tthis.chunk = chunk;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isAllocated() {\n\t\t\treturn this.refCount.get() > 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic PooledDataBuffer retain() {\n\t\t\tif (this.delegate instanceof PooledDataBuffer pooledDelegate) {\n\t\t\t\tpooledDelegate.retain();\n\t\t\t}\n\t\t\tthis.chunk.retain();\n\t\t\tthis.refCount.getAndUpdate(c -> {\n\t\t\t\tif (c != 0) {\n\t\t\t\t\treturn c + 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean release() {\n\t\t\tif (this.delegate instanceof PooledDataBuffer pooledDelegate) {\n\t\t\t\tpooledDelegate.release();\n\t\t\t}\n\t\t\tthis.chunk.release();\n\t\t\tint refCount = this.refCount.updateAndGet(c -> {\n\t\t\t\tif (c != 0) {\n\t\t\t\t\treturn c - 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalStateException(\"already released \" + this);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn refCount == 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic PooledDataBuffer touch(Object hint) {\n\t\t\tif (this.delegate instanceof TouchableDataBuffer touchableDelegate) {\n\t\t\t\ttouchableDelegate.touch(hint);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\t// delegation\n\n\t\t@Override\n\t\tpublic DataBufferFactory factory() {\n\t\t\treturn this.delegate.factory();\n\t\t}\n\n\t\t@Override\n\t\tpublic int indexOf(IntPredicate predicate, int fromIndex) {\n\t\t\treturn this.delegate.indexOf(predicate, fromIndex);\n\t\t}\n\n\t\t@Override\n\t\tpublic int lastIndexOf(IntPredicate predicate, int fromIndex) {\n\t\t\treturn this.delegate.lastIndexOf(predicate, fromIndex);\n\t\t}\n\n\t\t@Override\n\t\tpublic int readableByteCount() {\n\t\t\treturn this.delegate.readableByteCount();\n\t\t}\n\n\t\t@Override\n\t\tpublic int writableByteCount() {\n\t\t\treturn this.delegate.writableByteCount();\n\t\t}\n\n\t\t@Override\n\t\tpublic int capacity() {\n\t\t\treturn this.delegate.capacity();\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic DataBuffer capacity(int capacity) {\n\t\t\tthis.delegate.capacity(capacity);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer ensureWritable(int capacity) {\n\t\t\tthis.delegate.ensureWritable(capacity);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic int readPosition() {\n\t\t\treturn this.delegate.readPosition();\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer readPosition(int readPosition) {\n\t\t\tthis.delegate.readPosition(readPosition);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic int writePosition() {\n\t\t\treturn this.delegate.writePosition();\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer writePosition(int writePosition) {\n\t\t\tthis.delegate.writePosition(writePosition);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic byte getByte(int index) {\n\t\t\treturn this.delegate.getByte(index);\n\t\t}\n\n\t\t@Override\n\t\tpublic byte read() {\n\t\t\treturn this.delegate.read();\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer read(byte[] destination) {\n\t\t\tthis.delegate.read(destination);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer read(byte[] destination, int offset, int length) {\n\t\t\tthis.delegate.read(destination, offset, length);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer write(byte b) {\n\t\t\tthis.delegate.write(b);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer write(byte[] source) {\n\t\t\tthis.delegate.write(source);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer write(byte[] source, int offset, int length) {\n\t\t\tthis.delegate.write(source, offset, length);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer write(DataBuffer... buffers) {\n\t\t\tthis.delegate.write(buffers);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer write(ByteBuffer... buffers) {\n\t\t\tthis.delegate.write(buffers);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic DataBuffer slice(int index, int length) {\n\t\t\tDataBuffer delegateSlice = this.delegate.slice(index, length);\n\t\t\tthis.chunk.retain();\n\t\t\treturn new JettyDataBuffer(delegateSlice, this.chunk);\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer split(int index) {\n\t\t\tDataBuffer delegateSplit = this.delegate.split(index);\n\t\t\tthis.chunk.retain();\n\t\t\treturn new JettyDataBuffer(delegateSplit, this.chunk);\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic ByteBuffer asByteBuffer() {\n\t\t\treturn this.delegate.asByteBuffer();\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic ByteBuffer asByteBuffer(int index, int length) {\n\t\t\treturn this.delegate.asByteBuffer(index, length);\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic ByteBuffer toByteBuffer(int index, int length) {\n\t\t\treturn this.delegate.toByteBuffer(index, length);\n\t\t}\n\n\t\t@Override\n\t\tpublic void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length) {\n\t\t\tthis.delegate.toByteBuffer(srcPos, dest, destPos, length);\n\t\t}\n\n\t\t@Override\n\t\tpublic ByteBufferIterator readableByteBuffers() {\n\t\t\tByteBufferIterator delegateIterator = this.delegate.readableByteBuffers();\n\t\t\treturn new JettyByteBufferIterator(delegateIterator, this.chunk);\n\t\t}\n\n\t\t@Override\n\t\tpublic ByteBufferIterator writableByteBuffers() {\n\t\t\tByteBufferIterator delegateIterator = this.delegate.writableByteBuffers();\n\t\t\treturn new JettyByteBufferIterator(delegateIterator, this.chunk);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString(int index, int length, Charset charset) {\n\t\t\treturn this.delegate.toString(index, length, charset);\n\t\t}\n\n\n\t\tprivate static final class JettyByteBufferIterator implements ByteBufferIterator {\n\n\t\t\tprivate final ByteBufferIterator delegate;\n\n\t\t\tprivate final Content.Chunk chunk;\n\n\n\t\t\tpublic JettyByteBufferIterator(ByteBufferIterator delegate, Content.Chunk chunk) {\n\t\t\t\tAssert.notNull(delegate, \"Delegate must not be null\");\n\t\t\t\tAssert.notNull(chunk, \"Chunk must not be null\");\n\n\t\t\t\tthis.delegate = delegate;\n\t\t\t\tthis.chunk = chunk;\n\t\t\t\tthis.chunk.retain();\n\t\t\t}\n\n\n\t\t\t@Override\n\t\t\tpublic void close() {\n\t\t\t\tthis.delegate.close();\n\t\t\t\tthis.chunk.release();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn this.delegate.hasNext();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ByteBuffer next() {\n\t\t\t\treturn this.delegate.next();\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#asByteBuffer()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 348
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer asByteBuffer()",
    "source_code": "\t\tpublic ByteBuffer asByteBuffer() {\n\t\t\treturn this.delegate.asByteBuffer();\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#asByteBuffer(index,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 354
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer asByteBuffer(int index, int length)",
    "source_code": "\t\tpublic ByteBuffer asByteBuffer(int index, int length) {\n\t\t\treturn this.delegate.asByteBuffer(index, length);\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#capacity()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "int",
    "signature": "public int capacity()",
    "source_code": "\t\tpublic int capacity() {\n\t\t\treturn this.delegate.capacity();\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#capacity(capacity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer capacity(int capacity)",
    "source_code": "\t\tpublic DataBuffer capacity(int capacity) {\n\t\t\tthis.delegate.capacity(capacity);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#close()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 405
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\t\t\tpublic void close() {\n\t\t\t\tthis.delegate.close();\n\t\t\t\tthis.chunk.release();\n\t\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#connect(method,uri,ClientHttpRequest,requestCallback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "uri",
      "ClientHttpRequest",
      "requestCallback"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "Mono<ClientHttpResponse>",
    "signature": "public Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,\n\t\t\tFunction<? super ClientHttpRequest, Mono<Void>> requestCallback)",
    "source_code": "\tpublic Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#ensureWritable(capacity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer ensureWritable(int capacity)",
    "source_code": "\t\tpublic DataBuffer ensureWritable(int capacity) {\n\t\t\tthis.delegate.ensureWritable(capacity);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#factory()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "DataBufferFactory",
    "signature": "public DataBufferFactory factory()",
    "source_code": "\t\tpublic DataBufferFactory factory() {\n\t\t\treturn this.delegate.factory();\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#getByte(index)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index"
    ],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "byte",
    "signature": "public byte getByte(int index)",
    "source_code": "\t\tpublic byte getByte(int index) {\n\t\t\treturn this.delegate.getByte(index);\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#hasNext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 411
    },
    "return": "boolean",
    "signature": "public boolean hasNext()",
    "source_code": "\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn this.delegate.hasNext();\n\t\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#indexOf(predicate,fromIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "fromIndex"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "int",
    "signature": "public int indexOf(IntPredicate predicate, int fromIndex)",
    "source_code": "\t\tpublic int indexOf(IntPredicate predicate, int fromIndex) {\n\t\t\treturn this.delegate.indexOf(predicate, fromIndex);\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#isAllocated()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "boolean",
    "signature": "public boolean isAllocated()",
    "source_code": "\t\tpublic boolean isAllocated() {\n\t\t\treturn this.refCount.get() > 0;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#lastIndexOf(predicate,fromIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "fromIndex"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "int",
    "signature": "public int lastIndexOf(IntPredicate predicate, int fromIndex)",
    "source_code": "\t\tpublic int lastIndexOf(IntPredicate predicate, int fromIndex) {\n\t\t\treturn this.delegate.lastIndexOf(predicate, fromIndex);\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#next()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 416
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer next()",
    "source_code": "\t\t\tpublic ByteBuffer next() {\n\t\t\t\treturn this.delegate.next();\n\t\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#read()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 285
    },
    "return": "byte",
    "signature": "public byte read()",
    "source_code": "\t\tpublic byte read() {\n\t\t\treturn this.delegate.read();\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#read(destination)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer read(byte[] destination)",
    "source_code": "\t\tpublic DataBuffer read(byte[] destination) {\n\t\t\tthis.delegate.read(destination);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#read(destination,offset,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer read(byte[] destination, int offset, int length)",
    "source_code": "\t\tpublic DataBuffer read(byte[] destination, int offset, int length) {\n\t\t\tthis.delegate.read(destination, offset, length);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#readPosition()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "int",
    "signature": "public int readPosition()",
    "source_code": "\t\tpublic int readPosition() {\n\t\t\treturn this.delegate.readPosition();\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#readPosition(readPosition)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "readPosition"
    ],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer readPosition(int readPosition)",
    "source_code": "\t\tpublic DataBuffer readPosition(int readPosition) {\n\t\t\tthis.delegate.readPosition(readPosition);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#readableByteBuffers()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 370
    },
    "return": "ByteBufferIterator",
    "signature": "public ByteBufferIterator readableByteBuffers()",
    "source_code": "\t\tpublic ByteBufferIterator readableByteBuffers() {\n\t\t\tByteBufferIterator delegateIterator = this.delegate.readableByteBuffers();\n\t\t\treturn new JettyByteBufferIterator(delegateIterator, this.chunk);\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#readableByteCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "int",
    "signature": "public int readableByteCount()",
    "source_code": "\t\tpublic int readableByteCount() {\n\t\t\treturn this.delegate.readableByteCount();\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#release()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "boolean",
    "signature": "public boolean release()",
    "source_code": "\t\tpublic boolean release() {\n\t\t\tif (this.delegate instanceof PooledDataBuffer pooledDelegate) {\n\t\t\t\tpooledDelegate.release();\n\t\t\t}\n\t\t\tthis.chunk.release();\n\t\t\tint refCount = this.refCount.updateAndGet(c -> {\n\t\t\t\tif (c != 0) {\n\t\t\t\t\treturn c - 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalStateException(\"already released \" + this);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn refCount == 0;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#retain()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "PooledDataBuffer",
    "signature": "public PooledDataBuffer retain()",
    "source_code": "\t\tpublic PooledDataBuffer retain() {\n\t\t\tif (this.delegate instanceof PooledDataBuffer pooledDelegate) {\n\t\t\t\tpooledDelegate.retain();\n\t\t\t}\n\t\t\tthis.chunk.retain();\n\t\t\tthis.refCount.getAndUpdate(c -> {\n\t\t\t\tif (c != 0) {\n\t\t\t\t\treturn c + 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#setBufferFactory(bufferFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the buffer factory to use.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bufferFactory"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "void",
    "signature": "public void setBufferFactory(DataBufferFactory bufferFactory)",
    "source_code": "\tpublic void setBufferFactory(DataBufferFactory bufferFactory) {\n\t\tthis.bufferFactory = bufferFactory;\n\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#slice(index,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer slice(int index, int length)",
    "source_code": "\t\tpublic DataBuffer slice(int index, int length) {\n\t\t\tDataBuffer delegateSlice = this.delegate.slice(index, length);\n\t\t\tthis.chunk.retain();\n\t\t\treturn new JettyDataBuffer(delegateSlice, this.chunk);\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#split(index)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index"
    ],
    "position": {
      "column": 1,
      "line": 340
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer split(int index)",
    "source_code": "\t\tpublic DataBuffer split(int index) {\n\t\t\tDataBuffer delegateSplit = this.delegate.split(index);\n\t\t\tthis.chunk.retain();\n\t\t\treturn new JettyDataBuffer(delegateSplit, this.chunk);\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#toByteBuffer(index,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 360
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer toByteBuffer(int index, int length)",
    "source_code": "\t\tpublic ByteBuffer toByteBuffer(int index, int length) {\n\t\t\treturn this.delegate.toByteBuffer(index, length);\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#toByteBuffer(srcPos,dest,destPos,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "srcPos",
      "dest",
      "destPos",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 365
    },
    "return": "void",
    "signature": "public void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length)",
    "source_code": "\t\tpublic void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length) {\n\t\t\tthis.delegate.toByteBuffer(srcPos, dest, destPos, length);\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#toString(index,length,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 382
    },
    "return": "String",
    "signature": "public String toString(int index, int length, Charset charset)",
    "source_code": "\t\tpublic String toString(int index, int length, Charset charset) {\n\t\t\treturn this.delegate.toString(index, length, charset);\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#touch(hint)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hint"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "PooledDataBuffer",
    "signature": "public PooledDataBuffer touch(Object hint)",
    "source_code": "\t\tpublic PooledDataBuffer touch(Object hint) {\n\t\t\tif (this.delegate instanceof TouchableDataBuffer touchableDelegate) {\n\t\t\t\ttouchableDelegate.touch(hint);\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#writableByteBuffers()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 376
    },
    "return": "ByteBufferIterator",
    "signature": "public ByteBufferIterator writableByteBuffers()",
    "source_code": "\t\tpublic ByteBufferIterator writableByteBuffers() {\n\t\t\tByteBufferIterator delegateIterator = this.delegate.writableByteBuffers();\n\t\t\treturn new JettyByteBufferIterator(delegateIterator, this.chunk);\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#writableByteCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "int",
    "signature": "public int writableByteCount()",
    "source_code": "\t\tpublic int writableByteCount() {\n\t\t\treturn this.delegate.writableByteCount();\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#write(b)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer write(byte b)",
    "source_code": "\t\tpublic DataBuffer write(byte b) {\n\t\t\tthis.delegate.write(b);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#write(buffers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "buffers"
    ],
    "position": {
      "column": 1,
      "line": 326
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer write(ByteBuffer... buffers)",
    "source_code": "\t\tpublic DataBuffer write(ByteBuffer... buffers) {\n\t\t\tthis.delegate.write(buffers);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#write(source)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source"
    ],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer write(byte[] source)",
    "source_code": "\t\tpublic DataBuffer write(byte[] source) {\n\t\t\tthis.delegate.write(source);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#write(source,offset,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 314
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer write(byte[] source, int offset, int length)",
    "source_code": "\t\tpublic DataBuffer write(byte[] source, int offset, int length) {\n\t\t\tthis.delegate.write(source, offset, length);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#writePosition()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 269
    },
    "return": "int",
    "signature": "public int writePosition()",
    "source_code": "\t\tpublic int writePosition() {\n\t\t\treturn this.delegate.writePosition();\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#writePosition(writePosition)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "writePosition"
    ],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer writePosition(int writePosition)",
    "source_code": "\t\tpublic DataBuffer writePosition(int writePosition) {\n\t\t\tthis.delegate.writePosition(writePosition);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.codec.ResourceHttpMessageWriter#addDefaultHeaders(message,resource,contentType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Adds the default headers for the given resource to the given message.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "resource",
      "contentType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> addDefaultHeaders(ReactiveHttpOutputMessage message, Resource resource, @Nullable MediaType contentType, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<Void> addDefaultHeaders(ReactiveHttpOutputMessage message, Resource resource, @Nullable MediaType contentType, Map<String, Object> hints) {\n\t\treturn Mono.defer(() -> {\n\t\t\tHttpHeaders headers = message.getHeaders();\n\t\t\tMediaType resourceMediaType = getResourceMediaType(contentType, resource, hints);\n\t\t\theaders.setContentType(resourceMediaType);\n\t\t\tif (message instanceof ServerHttpResponse) {\n\t\t\t\t// server side\n\t\t\t\theaders.set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n\t\t\t}\n\n\t\t\tif (headers.getContentLength() < 0) {\n\t\t\t\treturn lengthOf(resource)\n\t\t\t\t\t\t.flatMap(contentLength -> {\n\t\t\t\t\t\t\theaders.setContentLength(contentLength);\n\t\t\t\t\t\t\treturn Mono.empty();\n\t\t\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn Mono.empty();\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.http.codec.xml.Jaxb2XmlEncoder": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Encode from single value to a byte stream containing XML elements.\n *\n * <p>{@link jakarta.xml.bind.annotation.XmlElements @XmlElements} and\n * {@link jakarta.xml.bind.annotation.XmlElement @XmlElement} can be used\n * to specify how collections should be marshalled.\n *\n * @author Sebastien Deleuze\n * @author Arjen Poutsma\n * @since 5.0\n * @see Jaxb2XmlDecoder\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "signature": "public class Jaxb2XmlEncoder",
    "source_code": "public class Jaxb2XmlEncoder extends AbstractSingleValueEncoder<Object> {\n\n\tprivate final JaxbContextContainer jaxbContexts = new JaxbContextContainer();\n\n\tprivate Function<Marshaller, Marshaller> marshallerProcessor = Function.identity();\n\n\n\tpublic Jaxb2XmlEncoder() {\n\t\tsuper(MimeTypeUtils.APPLICATION_XML, MimeTypeUtils.TEXT_XML, new MediaType(\"application\", \"*+xml\"));\n\t}\n\n\n\t/**\n\t * Configure a processor function to customize Marshaller instances.\n\t * @param processor the function to use\n\t * @since 5.1.3\n\t */\n\tpublic void setMarshallerProcessor(Function<Marshaller, Marshaller> processor) {\n\t\tthis.marshallerProcessor = this.marshallerProcessor.andThen(processor);\n\t}\n\n\t/**\n\t * Return the configured processor for customizing Marshaller instances.\n\t * @since 5.1.3\n\t */\n\tpublic Function<Marshaller, Marshaller> getMarshallerProcessor() {\n\t\treturn this.marshallerProcessor;\n\t}\n\n\n\t@Override\n\tpublic boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType) {\n\t\tif (super.canEncode(elementType, mimeType)) {\n\t\t\tClass<?> outputClass = elementType.toClass();\n\t\t\treturn (outputClass.isAnnotationPresent(XmlRootElement.class) ||\n\t\t\t\t\toutputClass.isAnnotationPresent(XmlType.class));\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Override\n\tprotected Flux<DataBuffer> encode(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\t// we're relying on doOnDiscard in base class\n\t\treturn Mono.fromCallable(() -> encodeValue(value, bufferFactory, valueType, mimeType, hints)).flux();\n\t}\n\n\t@Override\n\tpublic DataBuffer encodeValue(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tif (!Hints.isLoggingSuppressed(hints)) {\n\t\t\tLogFormatUtils.traceDebug(logger, traceOn -> {\n\t\t\t\tString formatted = LogFormatUtils.formatValue(value, !traceOn);\n\t\t\t\treturn Hints.getLogPrefix(hints) + \"Encoding [\" + formatted + \"]\";\n\t\t\t});\n\t\t}\n\n\t\tboolean release = true;\n\t\tDataBuffer buffer = bufferFactory.allocateBuffer(1024);\n\t\ttry {\n\t\t\tOutputStream outputStream = buffer.asOutputStream();\n\t\t\tClass<?> clazz = getMarshallerType(value);\n\t\t\tMarshaller marshaller = initMarshaller(clazz);\n\t\t\tmarshaller.marshal(value, outputStream);\n\t\t\trelease = false;\n\t\t\treturn buffer;\n\t\t}\n\t\tcatch (MarshalException ex) {\n\t\t\tthrow new EncodingException(\"Could not marshal \" + value.getClass() + \" to XML\", ex);\n\t\t}\n\t\tcatch (JAXBException ex) {\n\t\t\tthrow new CodecException(\"Invalid JAXB configuration\", ex);\n\t\t}\n\t\tfinally {\n\t\t\tif (release) {\n\t\t\t\tDataBufferUtils.release(buffer);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static Class<?> getMarshallerType(Object value) {\n\t\tif (value instanceof JAXBElement<?> jaxbElement) {\n\t\t\treturn jaxbElement.getDeclaredType();\n\t\t}\n\t\telse {\n\t\t\treturn ClassUtils.getUserClass(value);\n\t\t}\n\t}\n\n\tprivate Marshaller initMarshaller(Class<?> clazz) throws CodecException, JAXBException {\n\t\tMarshaller marshaller = this.jaxbContexts.createMarshaller(clazz);\n\t\tmarshaller.setProperty(Marshaller.JAXB_ENCODING, StandardCharsets.UTF_8.name());\n\t\tmarshaller = this.marshallerProcessor.apply(marshaller);\n\t\treturn marshaller;\n\t}\n\n}"
  },
  "org.springframework.http.codec.xml.Jaxb2XmlEncoder#canEncode(elementType,mimeType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "boolean",
    "signature": "public boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType)",
    "source_code": "\tpublic boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType) {\n\t\tif (super.canEncode(elementType, mimeType)) {\n\t\t\tClass<?> outputClass = elementType.toClass();\n\t\t\treturn (outputClass.isAnnotationPresent(XmlRootElement.class) ||\n\t\t\t\t\toutputClass.isAnnotationPresent(XmlType.class));\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.xml.Jaxb2XmlEncoder#encode(value,bufferFactory,valueType,mimeType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "bufferFactory",
      "valueType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "Flux<DataBuffer>",
    "signature": "protected Flux<DataBuffer> encode(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tprotected Flux<DataBuffer> encode(Object value, DataBufferFactory bufferFactory,"
  },
  "org.springframework.http.codec.xml.Jaxb2XmlEncoder#encodeValue(value,bufferFactory,valueType,mimeType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "bufferFactory",
      "valueType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer encodeValue(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic DataBuffer encodeValue(Object value, DataBufferFactory bufferFactory,"
  },
  "org.springframework.http.codec.xml.Jaxb2XmlEncoder#getMarshallerProcessor()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured processor for customizing Marshaller instances.\n\t * @since 5.1.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "Marshaller>",
    "signature": "public Marshaller> getMarshallerProcessor()",
    "source_code": "\tpublic Function<Marshaller, Marshaller> getMarshallerProcessor() {\n\t\treturn this.marshallerProcessor;\n\t}"
  },
  "org.springframework.http.codec.xml.Jaxb2XmlEncoder#setMarshallerProcessor(Function<Marshaller,processor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a processor function to customize Marshaller instances.\n\t * @param processor the function to use\n\t * @since 5.1.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<Marshaller",
      "processor"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "void",
    "signature": "public void setMarshallerProcessor(Function<Marshaller, Marshaller> processor)",
    "source_code": "\tpublic void setMarshallerProcessor(Function<Marshaller, Marshaller> processor) {\n\t\tthis.marshallerProcessor = this.marshallerProcessor.andThen(processor);\n\t}"
  },
  "org.springframework.http.converter.AbstractGenericHttpMessageConverter#repeatable()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "boolean",
    "signature": "public boolean repeatable()",
    "source_code": "\t\t\t\tpublic boolean repeatable() {\n\t\t\t\t\treturn supportsRepeatableWrites(t);\n\t\t\t\t}"
  },
  "org.springframework.http.converter.AbstractGenericHttpMessageConverter#writeTo(outputStream)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outputStream"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "void",
    "signature": "public void writeTo(OutputStream outputStream)",
    "source_code": "\t\t\t\tpublic void writeTo(OutputStream outputStream) throws IOException {\n\t\t\t\t\twriteInternal(t, type, new HttpOutputMessage() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic OutputStream getBody() {\n\t\t\t\t\t\t\treturn outputStream;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic HttpHeaders getHeaders() {\n\t\t\t\t\t\t\treturn headers;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}"
  },
  "org.springframework.http.converter.AbstractHttpMessageConverter#repeatable()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "boolean",
    "signature": "public boolean repeatable()",
    "source_code": "\t\t\t\tpublic boolean repeatable() {\n\t\t\t\t\treturn supportsRepeatableWrites(t);\n\t\t\t\t}"
  },
  "org.springframework.http.converter.AbstractHttpMessageConverter#supportsRepeatableWrites(t)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Indicates whether this message converter can\n\t * {@linkplain #write(Object, MediaType, HttpOutputMessage) write} the\n\t * given object multiple times.\n\t * <p>The default implementation returns {@code false}.\n\t * @param t the object t\n\t * @return {@code true} if {@code t} can be written repeatedly;\n\t * {@code false} otherwise\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "t"
    ],
    "position": {
      "column": 1,
      "line": 312
    },
    "return": "boolean",
    "signature": "protected boolean supportsRepeatableWrites(T t)",
    "source_code": "\tprotected boolean supportsRepeatableWrites(T t) {\n\t\treturn false;\n\t}"
  },
  "org.springframework.http.converter.AbstractHttpMessageConverter#writeTo(outputStream)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outputStream"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "void",
    "signature": "public void writeTo(OutputStream outputStream)",
    "source_code": "\t\t\t\tpublic void writeTo(OutputStream outputStream) throws IOException {\n\t\t\t\t\twriteInternal(t, new HttpOutputMessage() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic OutputStream getBody() {\n\t\t\t\t\t\t\treturn outputStream;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic HttpHeaders getHeaders() {\n\t\t\t\t\t\t\treturn headers;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}"
  },
  "org.springframework.http.converter.BufferedImageHttpMessageConverter#repeatable()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "boolean",
    "signature": "public boolean repeatable()",
    "source_code": "\t\t\t\tpublic boolean repeatable() {\n\t\t\t\t\treturn true;\n\t\t\t\t}"
  },
  "org.springframework.http.converter.BufferedImageHttpMessageConverter#writeTo(outputStream)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outputStream"
    ],
    "position": {
      "column": 1,
      "line": 231
    },
    "return": "void",
    "signature": "public void writeTo(OutputStream outputStream)",
    "source_code": "\t\t\t\tpublic void writeTo(OutputStream outputStream) throws IOException {\n\t\t\t\t\tBufferedImageHttpMessageConverter.this.writeInternal(image, selectedContentType, outputStream);\n\t\t\t\t}"
  },
  "org.springframework.http.converter.FormHttpMessageConverter#close()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 691
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\t\tpublic void close() {\n\t\t}"
  },
  "org.springframework.http.converter.FormHttpMessageConverter#flush()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 687
    },
    "return": "void",
    "signature": "public void flush()",
    "source_code": "\t\tpublic void flush() {\n\t\t}"
  },
  "org.springframework.http.converter.FormHttpMessageConverter#repeatable()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 410
    },
    "return": "boolean",
    "signature": "public boolean repeatable()",
    "source_code": "\t\t\t\tpublic boolean repeatable() {\n\t\t\t\t\treturn true;\n\t\t\t\t}"
  },
  "org.springframework.http.converter.FormHttpMessageConverter#write(b,off,let)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b",
      "off",
      "let"
    ],
    "position": {
      "column": 1,
      "line": 682
    },
    "return": "void",
    "signature": "public void write(byte[] b, int off, int let)",
    "source_code": "\t\tpublic void write(byte[] b, int off, int let) throws IOException {\n\t\t\tthis.out.write(b, off, let);\n\t\t}"
  },
  "org.springframework.http.converter.FormHttpMessageConverter#writeTo(outputStream)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outputStream"
    ],
    "position": {
      "column": 1,
      "line": 405
    },
    "return": "void",
    "signature": "public void writeTo(OutputStream outputStream)",
    "source_code": "\t\t\t\tpublic void writeTo(OutputStream outputStream) throws IOException {\n\t\t\t\t\tStreamUtils.copy(bytes, outputStream);\n\t\t\t\t}"
  },
  "org.springframework.http.converter.ResourceRegionHttpMessageConverter#supportsRepeatableWrites(object)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object"
    ],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "boolean",
    "signature": "protected boolean supportsRepeatableWrites(Object object)",
    "source_code": "\tprotected boolean supportsRepeatableWrites(Object object) {\n\t\tif (object instanceof ResourceRegion resourceRegion) {\n\t\t\treturn supportsRepeatableWrites(resourceRegion);\n\t\t}\n\t\telse {\n\t\t\tCollection<ResourceRegion> regions = (Collection<ResourceRegion>) object;\n\t\t\tfor (ResourceRegion region : regions) {\n\t\t\t\tif (!supportsRepeatableWrites(region)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter#supportsRepeatableWrites(o)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "o"
    ],
    "position": {
      "column": 1,
      "line": 573
    },
    "return": "boolean",
    "signature": "protected boolean supportsRepeatableWrites(Object o)",
    "source_code": "\tprotected boolean supportsRepeatableWrites(Object o) {\n\t\treturn true;\n\t}"
  },
  "org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverter#supportsRepeatableWrites(o)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "o"
    ],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "boolean",
    "signature": "protected boolean supportsRepeatableWrites(Object o)",
    "source_code": "\tprotected boolean supportsRepeatableWrites(Object o) {\n\t\treturn true;\n\t}"
  },
  "org.springframework.http.converter.xml.MarshallingHttpMessageConverter#supportsRepeatableWrites(o)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "o"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "boolean",
    "signature": "protected boolean supportsRepeatableWrites(Object o)",
    "source_code": "\tprotected boolean supportsRepeatableWrites(Object o) {\n\t\treturn true;\n\t}"
  },
  "org.springframework.http.server.ServletServerHttpRequest#initURI(servletRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize a URI from the given Servlet request.\n\t * @param servletRequest the request\n\t * @return the initialized URI\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletRequest"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "URI",
    "signature": "public URI initURI(HttpServletRequest servletRequest)",
    "source_code": "\tpublic static URI initURI(HttpServletRequest servletRequest) {\n\t\tString urlString = null;\n\t\tboolean hasQuery = false;\n\t\ttry {\n\t\t\tStringBuffer url = servletRequest.getRequestURL();\n\t\t\tString query = servletRequest.getQueryString();\n\t\t\thasQuery = StringUtils.hasText(query);\n\t\t\tif (hasQuery) {\n\t\t\t\turl.append('?').append(query);\n\t\t\t}\n\t\t\turlString = url.toString();\n\t\t\treturn new URI(urlString);\n\t\t}\n\t\tcatch (URISyntaxException ex) {\n\t\t\tif (!hasQuery) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Could not resolve HttpServletRequest as URI: \" + urlString, ex);\n\t\t\t}\n\t\t\t// Maybe a malformed query string... try plain request URL\n\t\t\ttry {\n\t\t\t\turlString = servletRequest.getRequestURL().toString();\n\t\t\t\treturn new URI(urlString);\n\t\t\t}\n\t\t\tcatch (URISyntaxException ex2) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Could not resolve HttpServletRequest as URI: \" + urlString, ex2);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.http.server.reactive.JettyHttpHandlerAdapter#applyHeaders()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "void",
    "signature": "protected void applyHeaders()",
    "source_code": "\t\tprotected void applyHeaders() {\n\t\t\tadaptHeaders(false);\n\t\t}"
  },
  "org.springframework.http.server.reactive.JettyHttpHandlerAdapter#createRequest(request,context)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "ServletServerHttpRequest",
    "signature": "protected ServletServerHttpRequest createRequest(HttpServletRequest request, AsyncContext context)",
    "source_code": "\tprotected ServletServerHttpRequest createRequest(HttpServletRequest request, AsyncContext context)"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code MultiValueMap} implementation for wrapping Apache HttpComponents\n * HttpClient headers.\n *\n * @author Rossen Stoyanchev\n * @since 6.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "signature": "public class HttpComponentsHeadersAdapter",
    "source_code": "public final class HttpComponentsHeadersAdapter implements MultiValueMap<String, String> {\n\n\tprivate final HttpMessage message;\n\n\n\t/**\n\t * Create a new {@code HttpComponentsHeadersAdapter} based on the given\n\t * {@code HttpMessage}.\n\t */\n\tpublic HttpComponentsHeadersAdapter(HttpMessage message) {\n\t\tAssert.notNull(message, \"Message must not be null\");\n\t\tthis.message = message;\n\t}\n\n\n\t@Override\n\t@Nullable\n\tpublic String getFirst(String key) {\n\t\tHeader header = this.message.getFirstHeader(key);\n\t\treturn (header != null ? header.getValue() : null);\n\t}\n\n\t@Override\n\tpublic void add(String key, @Nullable String value) {\n\t\tthis.message.addHeader(key, value);\n\t}\n\n\t@Override\n\tpublic void addAll(String key, List<? extends String> values) {\n\t\tvalues.forEach(value -> add(key, value));\n\t}\n\n\t@Override\n\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this::addAll);\n\t}\n\n\t@Override\n\tpublic void set(String key, @Nullable String value) {\n\t\tthis.message.setHeader(key, value);\n\t}\n\n\t@Override\n\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this::set);\n\t}\n\n\t@Override\n\tpublic Map<String, String> toSingleValueMap() {\n\t\tMap<String, String> map = CollectionUtils.newLinkedHashMap(size());\n\t\tthis.message.headerIterator().forEachRemaining(h -> map.putIfAbsent(h.getName(), h.getValue()));\n\t\treturn map;\n\t}\n\n\t@Override\n\tpublic int size() {\n\t\treturn this.message.getHeaders().length;\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn (this.message.getHeaders().length == 0);\n\t}\n\n\t@Override\n\tpublic boolean containsKey(Object key) {\n\t\treturn (key instanceof String headerName && this.message.containsHeader(headerName));\n\t}\n\n\t@Override\n\tpublic boolean containsValue(Object value) {\n\t\treturn (value instanceof String &&\n\t\t\t\tArrays.stream(this.message.getHeaders()).anyMatch(h -> h.getValue().equals(value)));\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> get(Object key) {\n\t\tList<String> values = null;\n\t\tif (containsKey(key)) {\n\t\t\tHeader[] headers = this.message.getHeaders((String) key);\n\t\t\tvalues = new ArrayList<>(headers.length);\n\t\t\tfor (Header header : headers) {\n\t\t\t\tvalues.add(header.getValue());\n\t\t\t}\n\t\t}\n\t\treturn values;\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> put(String key, List<String> values) {\n\t\tList<String> oldValues = remove(key);\n\t\tvalues.forEach(value -> add(key, value));\n\t\treturn oldValues;\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> remove(Object key) {\n\t\tif (key instanceof String headerName) {\n\t\t\tList<String> oldValues = get(key);\n\t\t\tthis.message.removeHeaders(headerName);\n\t\t\treturn oldValues;\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this::put);\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\tthis.message.setHeaders();\n\t}\n\n\t@Override\n\tpublic Set<String> keySet() {\n\t\tSet<String> keys = new LinkedHashSet<>(size());\n\t\tfor (Header header : this.message.getHeaders()) {\n\t\t\tkeys.add(header.getName());\n\t\t}\n\t\treturn keys;\n\t}\n\n\t@Override\n\tpublic Collection<List<String>> values() {\n\t\tCollection<List<String>> values = new ArrayList<>(size());\n\t\tfor (Header header : this.message.getHeaders()) {\n\t\t\tvalues.add(get(header.getName()));\n\t\t}\n\t\treturn values;\n\t}\n\n\t@Override\n\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn new AbstractSet<>() {\n\t\t\t@Override\n\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn HttpComponentsHeadersAdapter.this.size();\n\t\t\t}\n\t\t};\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn HttpHeaders.formatHeaders(this);\n\t}\n\n\n\tprivate class EntryIterator implements Iterator<Entry<String, List<String>>> {\n\n\t\tprivate final Iterator<Header> iterator = message.headerIterator();\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn this.iterator.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic Entry<String, List<String>> next() {\n\t\t\treturn new HeaderEntry(this.iterator.next().getName());\n\t\t}\n\t}\n\n\n\tprivate class HeaderEntry implements Entry<String, List<String>> {\n\n\t\tprivate final String key;\n\n\t\tHeaderEntry(String key) {\n\t\t\tthis.key = key;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getKey() {\n\t\t\treturn this.key;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> getValue() {\n\t\t\tList<String> values = HttpComponentsHeadersAdapter.this.get(this.key);\n\t\t\treturn values != null ? values : Collections.emptyList();\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> setValue(List<String> value) {\n\t\t\tList<String> previousValues = getValue();\n\t\t\tHttpComponentsHeadersAdapter.this.put(this.key, value);\n\t\t\treturn previousValues;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#add(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "public void add(String key, @Nullable String value)",
    "source_code": "\tpublic void add(String key, @Nullable String value) {\n\t\tthis.message.addHeader(key, value);\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#addAll(MultiValueMap<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this::addAll);\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#addAll(key,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "public void addAll(String key, List<? extends String> values)",
    "source_code": "\tpublic void addAll(String key, List<? extends String> values) {\n\t\tvalues.forEach(value -> add(key, value));\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#clear()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\tpublic void clear() {\n\t\tthis.message.setHeaders();\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#containsKey(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "boolean",
    "signature": "public boolean containsKey(Object key)",
    "source_code": "\tpublic boolean containsKey(Object key) {\n\t\treturn (key instanceof String headerName && this.message.containsHeader(headerName));\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#containsValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "boolean",
    "signature": "public boolean containsValue(Object value)",
    "source_code": "\tpublic boolean containsValue(Object value) {\n\t\treturn (value instanceof String &&\n\t\t\t\tArrays.stream(this.message.getHeaders()).anyMatch(h -> h.getValue().equals(value)));\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#entrySet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "List<String>>>",
    "signature": "public List<String>>> entrySet()",
    "source_code": "\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn new AbstractSet<>() {\n\t\t\t@Override\n\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn HttpComponentsHeadersAdapter.this.size();\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#get(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "List<String>",
    "signature": "public List<String> get(Object key)",
    "source_code": "\tpublic List<String> get(Object key) {\n\t\tList<String> values = null;\n\t\tif (containsKey(key)) {\n\t\t\tHeader[] headers = this.message.getHeaders((String) key);\n\t\t\tvalues = new ArrayList<>(headers.length);\n\t\t\tfor (Header header : headers) {\n\t\t\t\tvalues.add(header.getValue());\n\t\t\t}\n\t\t}\n\t\treturn values;\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#getFirst(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "String",
    "signature": "public String getFirst(String key)",
    "source_code": "\tpublic String getFirst(String key) {\n\t\tHeader header = this.message.getFirstHeader(key);\n\t\treturn (header != null ? header.getValue() : null);\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#getKey()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "String",
    "signature": "public String getKey()",
    "source_code": "\t\tpublic String getKey() {\n\t\t\treturn this.key;\n\t\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#getValue()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 234
    },
    "return": "List<String>",
    "signature": "public List<String> getValue()",
    "source_code": "\t\tpublic List<String> getValue() {\n\t\t\tList<String> values = HttpComponentsHeadersAdapter.this.get(this.key);\n\t\t\treturn values != null ? values : Collections.emptyList();\n\t\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#hasNext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "boolean",
    "signature": "public boolean hasNext()",
    "source_code": "\t\tpublic boolean hasNext() {\n\t\t\treturn this.iterator.hasNext();\n\t\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#isEmpty()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "boolean",
    "signature": "public boolean isEmpty()",
    "source_code": "\tpublic boolean isEmpty() {\n\t\treturn (this.message.getHeaders().length == 0);\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#iterator()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "List<String>>>",
    "signature": "public List<String>>> iterator()",
    "source_code": "\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#keySet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "Set<String>",
    "signature": "public Set<String> keySet()",
    "source_code": "\tpublic Set<String> keySet() {\n\t\tSet<String> keys = new LinkedHashSet<>(size());\n\t\tfor (Header header : this.message.getHeaders()) {\n\t\t\tkeys.add(header.getName());\n\t\t}\n\t\treturn keys;\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#next()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "List<String>>",
    "signature": "public List<String>> next()",
    "source_code": "\t\tpublic Entry<String, List<String>> next() {\n\t\t\treturn new HeaderEntry(this.iterator.next().getName());\n\t\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#put(key,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> values)",
    "source_code": "\tpublic List<String> put(String key, List<String> values) {\n\t\tList<String> oldValues = remove(key);\n\t\tvalues.forEach(value -> add(key, value));\n\t\treturn oldValues;\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#putAll(String,map)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this::put);\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#remove(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "List<String>",
    "signature": "public List<String> remove(Object key)",
    "source_code": "\tpublic List<String> remove(Object key) {\n\t\tif (key instanceof String headerName) {\n\t\t\tList<String> oldValues = get(key);\n\t\t\tthis.message.removeHeaders(headerName);\n\t\t\treturn oldValues;\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#set(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "void",
    "signature": "public void set(String key, @Nullable String value)",
    "source_code": "\tpublic void set(String key, @Nullable String value) {\n\t\tthis.message.setHeader(key, value);\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#setAll(Map<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this::set);\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#setValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "List<String>",
    "signature": "public List<String> setValue(List<String> value)",
    "source_code": "\t\tpublic List<String> setValue(List<String> value) {\n\t\t\tList<String> previousValues = getValue();\n\t\t\tHttpComponentsHeadersAdapter.this.put(this.key, value);\n\t\t\treturn previousValues;\n\t\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#size()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "int",
    "signature": "public int size()",
    "source_code": "\t\t\tpublic int size() {\n\t\t\t\treturn HttpComponentsHeadersAdapter.this.size();\n\t\t\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#toSingleValueMap()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "String>",
    "signature": "public String> toSingleValueMap()",
    "source_code": "\tpublic Map<String, String> toSingleValueMap() {\n\t\tMap<String, String> map = CollectionUtils.newLinkedHashMap(size());\n\t\tthis.message.headerIterator().forEachRemaining(h -> map.putIfAbsent(h.getName(), h.getValue()));\n\t\treturn map;\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn HttpHeaders.formatHeaders(this);\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#values()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "Collection<List<String>>",
    "signature": "public Collection<List<String>> values()",
    "source_code": "\tpublic Collection<List<String>> values() {\n\t\tCollection<List<String>> values = new ArrayList<>(size());\n\t\tfor (Header header : this.message.getHeaders()) {\n\t\t\tvalues.add(get(header.getName()));\n\t\t}\n\t\treturn values;\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code MultiValueMap} implementation for wrapping Jetty HTTP headers.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 6.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "signature": "public class JettyHeadersAdapter",
    "source_code": "public final class JettyHeadersAdapter implements MultiValueMap<String, String> {\n\n\tprivate final HttpFields headers;\n\n\n\t/**\n\t * Creates a new {@code JettyHeadersAdapter} based on the given\n\t * {@code HttpFields} instance.\n\t * @param headers the {@code HttpFields} to base this adapter on\n\t */\n\tpublic JettyHeadersAdapter(HttpFields headers) {\n\t\tAssert.notNull(headers, \"Headers must not be null\");\n\t\tthis.headers = headers;\n\t}\n\n\n\t@Override\n\tpublic String getFirst(String key) {\n\t\treturn this.headers.get(key);\n\t}\n\n\t@Override\n\tpublic void add(String key, @Nullable String value) {\n\t\tif (value != null) {\n\t\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\t\tmutableHttpFields.add(key, value);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addAll(String key, List<? extends String> values) {\n\t\tvalues.forEach(value -> add(key, value));\n\t}\n\n\t@Override\n\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this::addAll);\n\t}\n\n\t@Override\n\tpublic void set(String key, @Nullable String value) {\n\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\tif (value != null) {\n\t\t\tmutableHttpFields.put(key, value);\n\t\t}\n\t\telse {\n\t\t\tmutableHttpFields.remove(key);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this::set);\n\t}\n\n\t@Override\n\tpublic Map<String, String> toSingleValueMap() {\n\t\tMap<String, String> singleValueMap = CollectionUtils.newLinkedHashMap(this.headers.size());\n\t\tIterator<HttpField> iterator = this.headers.iterator();\n\t\titerator.forEachRemaining(field -> {\n\t\t\tif (!singleValueMap.containsKey(field.getName())) {\n\t\t\t\tsingleValueMap.put(field.getName(), field.getValue());\n\t\t\t}\n\t\t});\n\t\treturn singleValueMap;\n\t}\n\n\t@Override\n\tpublic int size() {\n\t\treturn this.headers.getFieldNamesCollection().size();\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn (this.headers.size() == 0);\n\t}\n\n\t@Override\n\tpublic boolean containsKey(Object key) {\n\t\treturn (key instanceof String headerName && this.headers.contains(headerName));\n\t}\n\n\t@Override\n\tpublic boolean containsValue(Object value) {\n\t\treturn (value instanceof String searchString &&\n\t\t\t\tthis.headers.stream().anyMatch(field -> field.contains(searchString)));\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> get(Object key) {\n\t\tif (containsKey(key)) {\n\t\t\treturn this.headers.getValuesList((String) key);\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> put(String key, List<String> value) {\n\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\tList<String> oldValues = get(key);\n\t\tmutableHttpFields.put(key, value);\n\t\treturn oldValues;\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> remove(Object key) {\n\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\tif (key instanceof String name) {\n\t\t\tList<String> oldValues = get(key);\n\t\t\tmutableHttpFields.remove(name);\n\t\t\treturn oldValues;\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this::put);\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\tmutableHttpFields.clear();\n\t}\n\n\t@Override\n\tpublic Set<String> keySet() {\n\t\treturn new HeaderNames();\n\t}\n\n\t@Override\n\tpublic Collection<List<String>> values() {\n\t\treturn this.headers.getFieldNamesCollection().stream()\n\t\t\t\t.map(this.headers::getValuesList).toList();\n\t}\n\n\t@Override\n\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn new AbstractSet<>() {\n\t\t\t@Override\n\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn headers.size();\n\t\t\t}\n\t\t};\n\t}\n\n\tprivate HttpFields.Mutable mutableFields() {\n\t\tif (this.headers instanceof HttpFields.Mutable mutableHttpFields) {\n\t\t\treturn mutableHttpFields;\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\"Immutable headers\");\n\t\t}\n\t}\n\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn HttpHeaders.formatHeaders(this);\n\t}\n\n\n\tprivate class EntryIterator implements Iterator<Entry<String, List<String>>> {\n\n\t\tprivate final Iterator<String> names = headers.getFieldNamesCollection().iterator();\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn this.names.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic Entry<String, List<String>> next() {\n\t\t\treturn new HeaderEntry(this.names.next());\n\t\t}\n\t}\n\n\n\tprivate class HeaderEntry implements Entry<String, List<String>> {\n\n\t\tprivate final String key;\n\n\t\tHeaderEntry(String key) {\n\t\t\tthis.key = key;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getKey() {\n\t\t\treturn this.key;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> getValue() {\n\t\t\treturn headers.getValuesList(this.key);\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> setValue(List<String> value) {\n\t\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\t\tList<String> previousValues = headers.getValuesList(this.key);\n\t\t\tmutableHttpFields.put(this.key, value);\n\t\t\treturn previousValues;\n\t\t}\n\t}\n\n\n\tprivate class HeaderNames extends AbstractSet<String> {\n\n\t\t@Override\n\t\tpublic Iterator<String> iterator() {\n\t\t\treturn new HeaderNamesIterator(headers.getFieldNamesCollection().iterator());\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn headers.getFieldNamesCollection().size();\n\t\t}\n\t}\n\n\n\tprivate final class HeaderNamesIterator implements Iterator<String> {\n\n\t\tprivate final Iterator<String> iterator;\n\n\t\t@Nullable\n\t\tprivate String currentName;\n\n\t\tprivate HeaderNamesIterator(Iterator<String> iterator) {\n\t\t\tthis.iterator = iterator;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn this.iterator.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic String next() {\n\t\t\tthis.currentName = this.iterator.next();\n\t\t\treturn this.currentName;\n\t\t}\n\n\t\t@Override\n\t\tpublic void remove() {\n\t\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\t\tif (this.currentName == null) {\n\t\t\t\tthrow new IllegalStateException(\"No current Header in iterator\");\n\t\t\t}\n\t\t\tif (!headers.contains(this.currentName)) {\n\t\t\t\tthrow new IllegalStateException(\"Header not present: \" + this.currentName);\n\t\t\t}\n\t\t\tmutableHttpFields.remove(this.currentName);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#add(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "void",
    "signature": "public void add(String key, @Nullable String value)",
    "source_code": "\tpublic void add(String key, @Nullable String value) {\n\t\tif (value != null) {\n\t\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\t\tmutableHttpFields.add(key, value);\n\t\t}\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#addAll(MultiValueMap<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this::addAll);\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#addAll(key,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "void",
    "signature": "public void addAll(String key, List<? extends String> values)",
    "source_code": "\tpublic void addAll(String key, List<? extends String> values) {\n\t\tvalues.forEach(value -> add(key, value));\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#clear()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\tpublic void clear() {\n\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\tmutableHttpFields.clear();\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#containsKey(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "boolean",
    "signature": "public boolean containsKey(Object key)",
    "source_code": "\tpublic boolean containsKey(Object key) {\n\t\treturn (key instanceof String headerName && this.headers.contains(headerName));\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#containsValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "boolean",
    "signature": "public boolean containsValue(Object value)",
    "source_code": "\tpublic boolean containsValue(Object value) {\n\t\treturn (value instanceof String searchString &&\n\t\t\t\tthis.headers.stream().anyMatch(field -> field.contains(searchString)));\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#entrySet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "List<String>>>",
    "signature": "public List<String>>> entrySet()",
    "source_code": "\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn new AbstractSet<>() {\n\t\t\t@Override\n\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn headers.size();\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#get(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "List<String>",
    "signature": "public List<String> get(Object key)",
    "source_code": "\tpublic List<String> get(Object key) {\n\t\tif (containsKey(key)) {\n\t\t\treturn this.headers.getValuesList((String) key);\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#getFirst(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "String",
    "signature": "public String getFirst(String key)",
    "source_code": "\tpublic String getFirst(String key) {\n\t\treturn this.headers.get(key);\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#getKey()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "String",
    "signature": "public String getKey()",
    "source_code": "\t\tpublic String getKey() {\n\t\t\treturn this.key;\n\t\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#getValue()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "List<String>",
    "signature": "public List<String> getValue()",
    "source_code": "\t\tpublic List<String> getValue() {\n\t\t\treturn headers.getValuesList(this.key);\n\t\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#hasNext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "boolean",
    "signature": "public boolean hasNext()",
    "source_code": "\t\tpublic boolean hasNext() {\n\t\t\treturn this.iterator.hasNext();\n\t\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#isEmpty()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "boolean",
    "signature": "public boolean isEmpty()",
    "source_code": "\tpublic boolean isEmpty() {\n\t\treturn (this.headers.size() == 0);\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#iterator()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "Iterator<String>",
    "signature": "public Iterator<String> iterator()",
    "source_code": "\t\tpublic Iterator<String> iterator() {\n\t\t\treturn new HeaderNamesIterator(headers.getFieldNamesCollection().iterator());\n\t\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#keySet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "Set<String>",
    "signature": "public Set<String> keySet()",
    "source_code": "\tpublic Set<String> keySet() {\n\t\treturn new HeaderNames();\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#next()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 289
    },
    "return": "String",
    "signature": "public String next()",
    "source_code": "\t\tpublic String next() {\n\t\t\tthis.currentName = this.iterator.next();\n\t\t\treturn this.currentName;\n\t\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> value)",
    "source_code": "\tpublic List<String> put(String key, List<String> value) {\n\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\tList<String> oldValues = get(key);\n\t\tmutableHttpFields.put(key, value);\n\t\treturn oldValues;\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#putAll(String,map)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this::put);\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#remove()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 295
    },
    "return": "void",
    "signature": "public void remove()",
    "source_code": "\t\tpublic void remove() {\n\t\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\t\tif (this.currentName == null) {\n\t\t\t\tthrow new IllegalStateException(\"No current Header in iterator\");\n\t\t\t}\n\t\t\tif (!headers.contains(this.currentName)) {\n\t\t\t\tthrow new IllegalStateException(\"Header not present: \" + this.currentName);\n\t\t\t}\n\t\t\tmutableHttpFields.remove(this.currentName);\n\t\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#remove(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "List<String>",
    "signature": "public List<String> remove(Object key)",
    "source_code": "\tpublic List<String> remove(Object key) {\n\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\tif (key instanceof String name) {\n\t\t\tList<String> oldValues = get(key);\n\t\t\tmutableHttpFields.remove(name);\n\t\t\treturn oldValues;\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#set(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void set(String key, @Nullable String value)",
    "source_code": "\tpublic void set(String key, @Nullable String value) {\n\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\tif (value != null) {\n\t\t\tmutableHttpFields.put(key, value);\n\t\t}\n\t\telse {\n\t\t\tmutableHttpFields.remove(key);\n\t\t}\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#setAll(Map<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this::set);\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#setValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "List<String>",
    "signature": "public List<String> setValue(List<String> value)",
    "source_code": "\t\tpublic List<String> setValue(List<String> value) {\n\t\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\t\tList<String> previousValues = headers.getValuesList(this.key);\n\t\t\tmutableHttpFields.put(this.key, value);\n\t\t\treturn previousValues;\n\t\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#size()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "int",
    "signature": "public int size()",
    "source_code": "\t\tpublic int size() {\n\t\t\treturn headers.getFieldNamesCollection().size();\n\t\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#toSingleValueMap()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "String>",
    "signature": "public String> toSingleValueMap()",
    "source_code": "\tpublic Map<String, String> toSingleValueMap() {\n\t\tMap<String, String> singleValueMap = CollectionUtils.newLinkedHashMap(this.headers.size());\n\t\tIterator<HttpField> iterator = this.headers.iterator();\n\t\titerator.forEachRemaining(field -> {\n\t\t\tif (!singleValueMap.containsKey(field.getName())) {\n\t\t\t\tsingleValueMap.put(field.getName(), field.getValue());\n\t\t\t}\n\t\t});\n\t\treturn singleValueMap;\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn HttpHeaders.formatHeaders(this);\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#values()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "Collection<List<String>>",
    "signature": "public Collection<List<String>> values()",
    "source_code": "\tpublic Collection<List<String>> values() {\n\t\treturn this.headers.getFieldNamesCollection().stream()\n\t\t\t\t.map(this.headers::getValuesList).toList();\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code MultiValueMap} implementation for wrapping Netty 4 HTTP headers.\n *\n * @author Rossen Stoyanchev\n * @author Sam Brannen\n * @since 6.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 40
    },
    "signature": "public class Netty4HeadersAdapter",
    "source_code": "public final class Netty4HeadersAdapter implements MultiValueMap<String, String> {\n\n\tprivate final HttpHeaders headers;\n\n\n\t/**\n\t * Creates a new {@code Netty4HeadersAdapter} based on the given\n\t * {@code HttpHeaders}.\n\t */\n\tpublic Netty4HeadersAdapter(HttpHeaders headers) {\n\t\tAssert.notNull(headers, \"Headers must not be null\");\n\t\tthis.headers = headers;\n\t}\n\n\n\t@Override\n\t@Nullable\n\tpublic String getFirst(String key) {\n\t\treturn this.headers.get(key);\n\t}\n\n\t@Override\n\tpublic void add(String key, @Nullable String value) {\n\t\tif (value != null) {\n\t\t\tthis.headers.add(key, value);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addAll(String key, List<? extends String> values) {\n\t\tthis.headers.add(key, values);\n\t}\n\n\t@Override\n\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this.headers::add);\n\t}\n\n\t@Override\n\tpublic void set(String key, @Nullable String value) {\n\t\tif (value != null) {\n\t\t\tthis.headers.set(key, value);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this.headers::set);\n\t}\n\n\t@Override\n\tpublic Map<String, String> toSingleValueMap() {\n\t\tMap<String, String> singleValueMap = CollectionUtils.newLinkedHashMap(this.headers.size());\n\t\tthis.headers.entries()\n\t\t\t\t.forEach(entry -> {\n\t\t\t\t\tif (!singleValueMap.containsKey(entry.getKey())) {\n\t\t\t\t\t\tsingleValueMap.put(entry.getKey(), entry.getValue());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\treturn singleValueMap;\n\t}\n\n\t@Override\n\tpublic int size() {\n\t\treturn this.headers.names().size();\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn this.headers.isEmpty();\n\t}\n\n\t@Override\n\tpublic boolean containsKey(Object key) {\n\t\treturn (key instanceof String headerName && this.headers.contains(headerName));\n\t}\n\n\t@Override\n\tpublic boolean containsValue(Object value) {\n\t\treturn (value instanceof String &&\n\t\t\t\tthis.headers.entries().stream()\n\t\t\t\t\t\t.anyMatch(entry -> value.equals(entry.getValue())));\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic List<String> get(Object key) {\n\t\tif (containsKey(key)) {\n\t\t\treturn this.headers.getAll((String) key);\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> put(String key, @Nullable List<String> value) {\n\t\tList<String> previousValues = this.headers.getAll(key);\n\t\tthis.headers.set(key, value);\n\t\treturn previousValues;\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> remove(Object key) {\n\t\tif (key instanceof String headerName) {\n\t\t\tList<String> previousValues = this.headers.getAll(headerName);\n\t\t\tthis.headers.remove(headerName);\n\t\t\treturn previousValues;\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this.headers::set);\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\tthis.headers.clear();\n\t}\n\n\t@Override\n\tpublic Set<String> keySet() {\n\t\treturn new HeaderNames();\n\t}\n\n\t@Override\n\tpublic Collection<List<String>> values() {\n\t\treturn this.headers.names().stream()\n\t\t\t\t.map(this.headers::getAll).toList();\n\t}\n\n\t@Override\n\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn new AbstractSet<>() {\n\t\t\t@Override\n\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn headers.size();\n\t\t\t}\n\t\t};\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn org.springframework.http.HttpHeaders.formatHeaders(this);\n\t}\n\n\n\tprivate class EntryIterator implements Iterator<Entry<String, List<String>>> {\n\n\t\tprivate final Iterator<String> names = headers.names().iterator();\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn this.names.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic Entry<String, List<String>> next() {\n\t\t\treturn new HeaderEntry(this.names.next());\n\t\t}\n\t}\n\n\n\tprivate class HeaderEntry implements Entry<String, List<String>> {\n\n\t\tprivate final String key;\n\n\t\tHeaderEntry(String key) {\n\t\t\tthis.key = key;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getKey() {\n\t\t\treturn this.key;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> getValue() {\n\t\t\treturn headers.getAll(this.key);\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> setValue(List<String> value) {\n\t\t\tList<String> previousValues = headers.getAll(this.key);\n\t\t\theaders.set(this.key, value);\n\t\t\treturn previousValues;\n\t\t}\n\t}\n\n\n\tprivate class HeaderNames extends AbstractSet<String> {\n\n\t\t@Override\n\t\tpublic Iterator<String> iterator() {\n\t\t\treturn new HeaderNamesIterator(headers.names().iterator());\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn headers.names().size();\n\t\t}\n\t}\n\n\tprivate final class HeaderNamesIterator implements Iterator<String> {\n\n\t\tprivate final Iterator<String> iterator;\n\n\t\t@Nullable\n\t\tprivate String currentName;\n\n\t\tprivate HeaderNamesIterator(Iterator<String> iterator) {\n\t\t\tthis.iterator = iterator;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn this.iterator.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic String next() {\n\t\t\tthis.currentName = this.iterator.next();\n\t\t\treturn this.currentName;\n\t\t}\n\n\t\t@Override\n\t\tpublic void remove() {\n\t\t\tif (this.currentName == null) {\n\t\t\t\tthrow new IllegalStateException(\"No current Header in iterator\");\n\t\t\t}\n\t\t\tif (!headers.contains(this.currentName)) {\n\t\t\t\tthrow new IllegalStateException(\"Header not present: \" + this.currentName);\n\t\t\t}\n\t\t\theaders.remove(this.currentName);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#add(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "void",
    "signature": "public void add(String key, @Nullable String value)",
    "source_code": "\tpublic void add(String key, @Nullable String value) {\n\t\tif (value != null) {\n\t\t\tthis.headers.add(key, value);\n\t\t}\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#addAll(MultiValueMap<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this.headers::add);\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#addAll(key,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "public void addAll(String key, List<? extends String> values)",
    "source_code": "\tpublic void addAll(String key, List<? extends String> values) {\n\t\tthis.headers.add(key, values);\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#clear()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\tpublic void clear() {\n\t\tthis.headers.clear();\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#containsKey(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "boolean",
    "signature": "public boolean containsKey(Object key)",
    "source_code": "\tpublic boolean containsKey(Object key) {\n\t\treturn (key instanceof String headerName && this.headers.contains(headerName));\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#containsValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "boolean",
    "signature": "public boolean containsValue(Object value)",
    "source_code": "\tpublic boolean containsValue(Object value) {\n\t\treturn (value instanceof String &&\n\t\t\t\tthis.headers.entries().stream()\n\t\t\t\t\t\t.anyMatch(entry -> value.equals(entry.getValue())));\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#entrySet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "List<String>>>",
    "signature": "public List<String>>> entrySet()",
    "source_code": "\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn new AbstractSet<>() {\n\t\t\t@Override\n\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn headers.size();\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#get(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "List<String>",
    "signature": "public List<String> get(Object key)",
    "source_code": "\tpublic List<String> get(Object key) {\n\t\tif (containsKey(key)) {\n\t\t\treturn this.headers.getAll((String) key);\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#getFirst(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "String",
    "signature": "public String getFirst(String key)",
    "source_code": "\tpublic String getFirst(String key) {\n\t\treturn this.headers.get(key);\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#getKey()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "String",
    "signature": "public String getKey()",
    "source_code": "\t\tpublic String getKey() {\n\t\t\treturn this.key;\n\t\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#getValue()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "List<String>",
    "signature": "public List<String> getValue()",
    "source_code": "\t\tpublic List<String> getValue() {\n\t\t\treturn headers.getAll(this.key);\n\t\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#hasNext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "boolean",
    "signature": "public boolean hasNext()",
    "source_code": "\t\tpublic boolean hasNext() {\n\t\t\treturn this.iterator.hasNext();\n\t\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#isEmpty()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "boolean",
    "signature": "public boolean isEmpty()",
    "source_code": "\tpublic boolean isEmpty() {\n\t\treturn this.headers.isEmpty();\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#iterator()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "Iterator<String>",
    "signature": "public Iterator<String> iterator()",
    "source_code": "\t\tpublic Iterator<String> iterator() {\n\t\t\treturn new HeaderNamesIterator(headers.names().iterator());\n\t\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#keySet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "Set<String>",
    "signature": "public Set<String> keySet()",
    "source_code": "\tpublic Set<String> keySet() {\n\t\treturn new HeaderNames();\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#next()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 268
    },
    "return": "String",
    "signature": "public String next()",
    "source_code": "\t\tpublic String next() {\n\t\t\tthis.currentName = this.iterator.next();\n\t\t\treturn this.currentName;\n\t\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, @Nullable List<String> value)",
    "source_code": "\tpublic List<String> put(String key, @Nullable List<String> value) {\n\t\tList<String> previousValues = this.headers.getAll(key);\n\t\tthis.headers.set(key, value);\n\t\treturn previousValues;\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#putAll(String,map)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this.headers::set);\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#remove()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "void",
    "signature": "public void remove()",
    "source_code": "\t\tpublic void remove() {\n\t\t\tif (this.currentName == null) {\n\t\t\t\tthrow new IllegalStateException(\"No current Header in iterator\");\n\t\t\t}\n\t\t\tif (!headers.contains(this.currentName)) {\n\t\t\t\tthrow new IllegalStateException(\"Header not present: \" + this.currentName);\n\t\t\t}\n\t\t\theaders.remove(this.currentName);\n\t\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#remove(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "List<String>",
    "signature": "public List<String> remove(Object key)",
    "source_code": "\tpublic List<String> remove(Object key) {\n\t\tif (key instanceof String headerName) {\n\t\t\tList<String> previousValues = this.headers.getAll(headerName);\n\t\t\tthis.headers.remove(headerName);\n\t\t\treturn previousValues;\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#set(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "public void set(String key, @Nullable String value)",
    "source_code": "\tpublic void set(String key, @Nullable String value) {\n\t\tif (value != null) {\n\t\t\tthis.headers.set(key, value);\n\t\t}\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#setAll(Map<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this.headers::set);\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#setValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "List<String>",
    "signature": "public List<String> setValue(List<String> value)",
    "source_code": "\t\tpublic List<String> setValue(List<String> value) {\n\t\t\tList<String> previousValues = headers.getAll(this.key);\n\t\t\theaders.set(this.key, value);\n\t\t\treturn previousValues;\n\t\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#size()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "int",
    "signature": "public int size()",
    "source_code": "\t\tpublic int size() {\n\t\t\treturn headers.names().size();\n\t\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#toSingleValueMap()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "String>",
    "signature": "public String> toSingleValueMap()",
    "source_code": "\tpublic Map<String, String> toSingleValueMap() {\n\t\tMap<String, String> singleValueMap = CollectionUtils.newLinkedHashMap(this.headers.size());\n\t\tthis.headers.entries()\n\t\t\t\t.forEach(entry -> {\n\t\t\t\t\tif (!singleValueMap.containsKey(entry.getKey())) {\n\t\t\t\t\t\tsingleValueMap.put(entry.getKey(), entry.getValue());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\treturn singleValueMap;\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn org.springframework.http.HttpHeaders.formatHeaders(this);\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#values()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "Collection<List<String>>",
    "signature": "public Collection<List<String>> values()",
    "source_code": "\tpublic Collection<List<String>> values() {\n\t\treturn this.headers.names().stream()\n\t\t\t\t.map(this.headers::getAll).toList();\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code MultiValueMap} implementation for wrapping Netty HTTP headers.\n *\n * @author Violeta Georgieva\n * @since 6.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public class Netty5HeadersAdapter",
    "source_code": "public final class Netty5HeadersAdapter implements MultiValueMap<String, String> {\n\n\tprivate final HttpHeaders headers;\n\n\n\t/**\n\t * Create a new {@code Netty5HeadersAdapter} based on the given\n\t * {@code HttpHeaders}.\n\t */\n\tpublic Netty5HeadersAdapter(HttpHeaders headers) {\n\t\tAssert.notNull(headers, \"Headers must not be null\");\n\t\tthis.headers = headers;\n\t}\n\n\n\t@Override\n\t@Nullable\n\tpublic String getFirst(String key) {\n\t\tCharSequence value = this.headers.get(key);\n\t\treturn (value != null ? value.toString() : null);\n\t}\n\n\t@Override\n\tpublic void add(String key, @Nullable String value) {\n\t\tif (value != null) {\n\t\t\tthis.headers.add(key, value);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addAll(String key, List<? extends String> values) {\n\t\tthis.headers.add(key, values);\n\t}\n\n\t@Override\n\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this.headers::add);\n\t}\n\n\t@Override\n\tpublic void set(String key, @Nullable String value) {\n\t\tif (value != null) {\n\t\t\tthis.headers.set(key, value);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this.headers::set);\n\t}\n\n\t@Override\n\tpublic Map<String, String> toSingleValueMap() {\n\t\tMap<String, String> singleValueMap = CollectionUtils.newLinkedHashMap(this.headers.size());\n\t\tthis.headers.forEach(entry -> singleValueMap.putIfAbsent(\n\t\t\t\tentry.getKey().toString(), entry.getValue().toString()));\n\t\treturn singleValueMap;\n\t}\n\n\t@Override\n\tpublic int size() {\n\t\treturn this.headers.names().size();\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn this.headers.isEmpty();\n\t}\n\n\t@Override\n\tpublic boolean containsKey(Object key) {\n\t\treturn (key instanceof String headerName && this.headers.contains(headerName));\n\t}\n\n\t@Override\n\tpublic boolean containsValue(Object value) {\n\t\treturn (value instanceof String &&\n\t\t\t\tStreamSupport.stream(this.headers.spliterator(), false)\n\t\t\t\t\t\t.anyMatch(entry -> value.equals(entry.getValue())));\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic List<String> get(Object key) {\n\t\tIterator<CharSequence> iterator = this.headers.valuesIterator((CharSequence) key);\n\t\tif (iterator.hasNext()) {\n\t\t\tList<String> result = new ArrayList<>();\n\t\t\titerator.forEachRemaining(value -> result.add(value.toString()));\n\t\t\treturn result;\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> put(String key, @Nullable List<String> value) {\n\t\tList<String> previousValues = get(key);\n\t\tthis.headers.set(key, value);\n\t\treturn previousValues;\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> remove(Object key) {\n\t\tif (key instanceof String headerName) {\n\t\t\tList<String> previousValues = get(headerName);\n\t\t\tthis.headers.remove(headerName);\n\t\t\treturn previousValues;\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this.headers::set);\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\tthis.headers.clear();\n\t}\n\n\t@Override\n\tpublic Set<String> keySet() {\n\t\treturn new HeaderNames();\n\t}\n\n\t@Override\n\tpublic Collection<List<String>> values() {\n\t\tList<List<String>> result = new ArrayList<>(this.headers.size());\n\t\tforEach((key, value) -> result.add(value));\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn new AbstractSet<>() {\n\t\t\t@Override\n\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn headers.size();\n\t\t\t}\n\t\t};\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn org.springframework.http.HttpHeaders.formatHeaders(this);\n\t}\n\n\n\tprivate class EntryIterator implements Iterator<Entry<String, List<String>>> {\n\n\t\tprivate final Iterator<CharSequence> names = headers.names().iterator();\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn this.names.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic Entry<String, List<String>> next() {\n\t\t\treturn new HeaderEntry(this.names.next());\n\t\t}\n\t}\n\n\n\tprivate class HeaderEntry implements Entry<String, List<String>> {\n\n\t\tprivate final CharSequence key;\n\n\t\tHeaderEntry(CharSequence key) {\n\t\t\tthis.key = key;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getKey() {\n\t\t\treturn this.key.toString();\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> getValue() {\n\t\t\tList<String> values = get(this.key);\n\t\t\treturn (values != null ? values : Collections.emptyList());\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> setValue(List<String> value) {\n\t\t\tList<String> previousValues = getValue();\n\t\t\theaders.set(this.key, value);\n\t\t\treturn previousValues;\n\t\t}\n\t}\n\n\tprivate class HeaderNames extends AbstractSet<String> {\n\n\t\t@Override\n\t\tpublic Iterator<String> iterator() {\n\t\t\treturn new HeaderNamesIterator(headers.names().iterator());\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn headers.names().size();\n\t\t}\n\t}\n\n\tprivate final class HeaderNamesIterator implements Iterator<String> {\n\n\t\tprivate final Iterator<CharSequence> iterator;\n\n\t\t@Nullable\n\t\tprivate CharSequence currentName;\n\n\t\tprivate HeaderNamesIterator(Iterator<CharSequence> iterator) {\n\t\t\tthis.iterator = iterator;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn this.iterator.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic String next() {\n\t\t\tthis.currentName = this.iterator.next();\n\t\t\treturn this.currentName.toString();\n\t\t}\n\n\t\t@Override\n\t\tpublic void remove() {\n\t\t\tif (this.currentName == null) {\n\t\t\t\tthrow new IllegalStateException(\"No current Header in iterator\");\n\t\t\t}\n\t\t\tif (!headers.contains(this.currentName)) {\n\t\t\t\tthrow new IllegalStateException(\"Header not present: \" + this.currentName);\n\t\t\t}\n\t\t\theaders.remove(this.currentName);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#add(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "void",
    "signature": "public void add(String key, @Nullable String value)",
    "source_code": "\tpublic void add(String key, @Nullable String value) {\n\t\tif (value != null) {\n\t\t\tthis.headers.add(key, value);\n\t\t}\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#addAll(MultiValueMap<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this.headers::add);\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#addAll(key,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "void",
    "signature": "public void addAll(String key, List<? extends String> values)",
    "source_code": "\tpublic void addAll(String key, List<? extends String> values) {\n\t\tthis.headers.add(key, values);\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#clear()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\tpublic void clear() {\n\t\tthis.headers.clear();\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#containsKey(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "boolean",
    "signature": "public boolean containsKey(Object key)",
    "source_code": "\tpublic boolean containsKey(Object key) {\n\t\treturn (key instanceof String headerName && this.headers.contains(headerName));\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#containsValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "boolean",
    "signature": "public boolean containsValue(Object value)",
    "source_code": "\tpublic boolean containsValue(Object value) {\n\t\treturn (value instanceof String &&\n\t\t\t\tStreamSupport.stream(this.headers.spliterator(), false)\n\t\t\t\t\t\t.anyMatch(entry -> value.equals(entry.getValue())));\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#entrySet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "List<String>>>",
    "signature": "public List<String>>> entrySet()",
    "source_code": "\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn new AbstractSet<>() {\n\t\t\t@Override\n\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn headers.size();\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#get(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "List<String>",
    "signature": "public List<String> get(Object key)",
    "source_code": "\tpublic List<String> get(Object key) {\n\t\tIterator<CharSequence> iterator = this.headers.valuesIterator((CharSequence) key);\n\t\tif (iterator.hasNext()) {\n\t\t\tList<String> result = new ArrayList<>();\n\t\t\titerator.forEachRemaining(value -> result.add(value.toString()));\n\t\t\treturn result;\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#getFirst(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "String",
    "signature": "public String getFirst(String key)",
    "source_code": "\tpublic String getFirst(String key) {\n\t\tCharSequence value = this.headers.get(key);\n\t\treturn (value != null ? value.toString() : null);\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#getKey()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "String",
    "signature": "public String getKey()",
    "source_code": "\t\tpublic String getKey() {\n\t\t\treturn this.key.toString();\n\t\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#getValue()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "List<String>",
    "signature": "public List<String> getValue()",
    "source_code": "\t\tpublic List<String> getValue() {\n\t\t\tList<String> values = get(this.key);\n\t\t\treturn (values != null ? values : Collections.emptyList());\n\t\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#hasNext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "boolean",
    "signature": "public boolean hasNext()",
    "source_code": "\t\tpublic boolean hasNext() {\n\t\t\treturn this.iterator.hasNext();\n\t\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#isEmpty()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "boolean",
    "signature": "public boolean isEmpty()",
    "source_code": "\tpublic boolean isEmpty() {\n\t\treturn this.headers.isEmpty();\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#iterator()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "Iterator<String>",
    "signature": "public Iterator<String> iterator()",
    "source_code": "\t\tpublic Iterator<String> iterator() {\n\t\t\treturn new HeaderNamesIterator(headers.names().iterator());\n\t\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#keySet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "Set<String>",
    "signature": "public Set<String> keySet()",
    "source_code": "\tpublic Set<String> keySet() {\n\t\treturn new HeaderNames();\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#next()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "String",
    "signature": "public String next()",
    "source_code": "\t\tpublic String next() {\n\t\t\tthis.currentName = this.iterator.next();\n\t\t\treturn this.currentName.toString();\n\t\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, @Nullable List<String> value)",
    "source_code": "\tpublic List<String> put(String key, @Nullable List<String> value) {\n\t\tList<String> previousValues = get(key);\n\t\tthis.headers.set(key, value);\n\t\treturn previousValues;\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#putAll(String,map)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this.headers::set);\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#remove()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 277
    },
    "return": "void",
    "signature": "public void remove()",
    "source_code": "\t\tpublic void remove() {\n\t\t\tif (this.currentName == null) {\n\t\t\t\tthrow new IllegalStateException(\"No current Header in iterator\");\n\t\t\t}\n\t\t\tif (!headers.contains(this.currentName)) {\n\t\t\t\tthrow new IllegalStateException(\"Header not present: \" + this.currentName);\n\t\t\t}\n\t\t\theaders.remove(this.currentName);\n\t\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#remove(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "List<String>",
    "signature": "public List<String> remove(Object key)",
    "source_code": "\tpublic List<String> remove(Object key) {\n\t\tif (key instanceof String headerName) {\n\t\t\tList<String> previousValues = get(headerName);\n\t\t\tthis.headers.remove(headerName);\n\t\t\treturn previousValues;\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#set(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "void",
    "signature": "public void set(String key, @Nullable String value)",
    "source_code": "\tpublic void set(String key, @Nullable String value) {\n\t\tif (value != null) {\n\t\t\tthis.headers.set(key, value);\n\t\t}\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#setAll(Map<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this.headers::set);\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#setValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 234
    },
    "return": "List<String>",
    "signature": "public List<String> setValue(List<String> value)",
    "source_code": "\t\tpublic List<String> setValue(List<String> value) {\n\t\t\tList<String> previousValues = getValue();\n\t\t\theaders.set(this.key, value);\n\t\t\treturn previousValues;\n\t\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#size()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "int",
    "signature": "public int size()",
    "source_code": "\t\tpublic int size() {\n\t\t\treturn headers.names().size();\n\t\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#toSingleValueMap()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "String>",
    "signature": "public String> toSingleValueMap()",
    "source_code": "\tpublic Map<String, String> toSingleValueMap() {\n\t\tMap<String, String> singleValueMap = CollectionUtils.newLinkedHashMap(this.headers.size());\n\t\tthis.headers.forEach(entry -> singleValueMap.putIfAbsent(\n\t\t\t\tentry.getKey().toString(), entry.getValue().toString()));\n\t\treturn singleValueMap;\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn org.springframework.http.HttpHeaders.formatHeaders(this);\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#values()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "Collection<List<String>>",
    "signature": "public Collection<List<String>> values()",
    "source_code": "\tpublic Collection<List<String>> values() {\n\t\tList<List<String>> result = new ArrayList<>(this.headers.size());\n\t\tforEach((key, value) -> result.add(value));\n\t\treturn result;\n\t}"
  },
  "org.springframework.jdbc.core.BeanPropertyRowMapper#mappedNames(pd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the mapped names for the given property.\n\t * <p>Subclasses may override this method to customize the mapped names,\n\t * adding to or removing from the set determined by this base method\n\t * (which returns the property name in lower-case and underscore-based\n\t * form), or replacing the set completely.\n\t * @param pd the property descriptor discovered on initialization\n\t * @return a set of mapped names\n\t * @since 6.1.4\n\t * @see #initialize\n\t * @see #lowerCaseName\n\t * @see #underscoreName\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "pd"
    ],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "Set<String>",
    "signature": "protected Set<String> mappedNames(PropertyDescriptor pd)",
    "source_code": "\tprotected Set<String> mappedNames(PropertyDescriptor pd) {\n\t\tSet<String> mappedNames = new HashSet<>(4);\n\t\tmappedNames.add(lowerCaseName(pd.getName()));\n\t\tmappedNames.add(underscoreName(pd.getName()));\n\t\treturn mappedNames;\n\t}"
  },
  "org.springframework.jdbc.core.JdbcTemplate#batchUpdate(psc,pss,generatedKeyHolder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "psc",
      "pss",
      "generatedKeyHolder"
    ],
    "position": {
      "column": 1,
      "line": 1028
    },
    "return": "int[]",
    "signature": "public int[] batchUpdate(final PreparedStatementCreator psc, final BatchPreparedStatementSetter pss,\n\t\t\tfinal KeyHolder generatedKeyHolder)",
    "source_code": "\tpublic int[] batchUpdate(final PreparedStatementCreator psc, final BatchPreparedStatementSetter pss,"
  },
  "org.springframework.jdbc.core.SimplePropertyRowMapper": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link RowMapper} implementation that converts a row into a new instance\n * of the specified mapped target class. The mapped target class must be a\n * top-level class or {@code static} nested class, and it may expose either a\n * <em>data class</em> constructor with named parameters corresponding to column\n * names or classic bean property setter methods with property names corresponding\n * to column names or fields with corresponding field names.\n *\n * <p>When combining a data class constructor with setter methods, any property\n * mapped successfully via a constructor argument will not be mapped additionally\n * via a corresponding setter method or field mapping. This means that constructor\n * arguments take precedence over property setter methods which in turn take\n * precedence over direct field mappings.\n *\n * <p>To facilitate mapping between columns and properties that don't have matching\n * names, try using underscore-separated column aliases in the SQL statement like\n * {@code \"select fname as first_name from customer\"}, where {@code first_name}\n * can be mapped to a {@code setFirstName(String)} method in the target class.\n *\n * <p>This is a flexible alternative to {@link DataClassRowMapper} and\n * {@link BeanPropertyRowMapper} for scenarios where no specific customization\n * and no pre-defined property mappings are needed.\n *\n * <p>In terms of its fallback property discovery algorithm, this class is similar to\n * {@link org.springframework.jdbc.core.namedparam.SimplePropertySqlParameterSource}\n * and is similarly used for {@link org.springframework.jdbc.core.simple.JdbcClient}.\n *\n * @author Juergen Hoeller\n * @since 6.1\n * @param <T> the result type\n * @see DataClassRowMapper\n * @see BeanPropertyRowMapper\n * @see org.springframework.jdbc.core.simple.JdbcClient.StatementSpec#query(Class)\n * @see org.springframework.jdbc.core.namedparam.SimplePropertySqlParameterSource\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "signature": "public class SimplePropertyRowMapper",
    "source_code": "public class SimplePropertyRowMapper<T> implements RowMapper<T> {\n\n\tprivate static final Object NO_DESCRIPTOR = new Object();\n\n\tprivate final Class<T> mappedClass;\n\n\tprivate final ConversionService conversionService;\n\n\tprivate final Constructor<T> mappedConstructor;\n\n\tprivate final String[] constructorParameterNames;\n\n\tprivate final TypeDescriptor[] constructorParameterTypes;\n\n\tprivate final Map<String, Object> propertyDescriptors = new ConcurrentHashMap<>();\n\n\n\t/**\n\t * Create a new {@code SimplePropertyRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t */\n\tpublic SimplePropertyRowMapper(Class<T> mappedClass) {\n\t\tthis(mappedClass, DefaultConversionService.getSharedInstance());\n\t}\n\n\t/**\n\t * Create a new {@code SimplePropertyRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t * @param conversionService a {@link ConversionService} for binding\n\t * JDBC values to bean properties\n\t */\n\tpublic SimplePropertyRowMapper(Class<T> mappedClass, ConversionService conversionService) {\n\t\tAssert.notNull(mappedClass, \"Mapped Class must not be null\");\n\t\tAssert.notNull(conversionService, \"ConversionService must not be null\");\n\t\tthis.mappedClass = mappedClass;\n\t\tthis.conversionService = conversionService;\n\n\t\tthis.mappedConstructor = BeanUtils.getResolvableConstructor(mappedClass);\n\t\tint paramCount = this.mappedConstructor.getParameterCount();\n\t\tthis.constructorParameterNames = (paramCount > 0 ?\n\t\t\t\tBeanUtils.getParameterNames(this.mappedConstructor) : new String[0]);\n\t\tthis.constructorParameterTypes = new TypeDescriptor[paramCount];\n\t\tfor (int i = 0; i < paramCount; i++) {\n\t\t\tthis.constructorParameterTypes[i] = new TypeDescriptor(new MethodParameter(this.mappedConstructor, i));\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic T mapRow(ResultSet rs, int rowNumber) throws SQLException {\n\t\tObject[] args = new Object[this.constructorParameterNames.length];\n\t\tSet<Integer> usedIndex = new HashSet<>();\n\t\tfor (int i = 0; i < args.length; i++) {\n\t\t\tString name = this.constructorParameterNames[i];\n\t\t\tint index;\n\t\t\ttry {\n\t\t\t\t// Try direct name match first\n\t\t\t\tindex = rs.findColumn(name);\n\t\t\t}\n\t\t\tcatch (SQLException ex) {\n\t\t\t\t// Try underscored name match instead\n\t\t\t\tindex = rs.findColumn(JdbcUtils.convertPropertyNameToUnderscoreName(name));\n\t\t\t}\n\t\t\tTypeDescriptor td = this.constructorParameterTypes[i];\n\t\t\tObject value = JdbcUtils.getResultSetValue(rs, index, td.getType());\n\t\t\tusedIndex.add(index);\n\t\t\targs[i] = this.conversionService.convert(value, td);\n\t\t}\n\t\tT mappedObject = BeanUtils.instantiateClass(this.mappedConstructor, args);\n\n\t\tResultSetMetaData rsmd = rs.getMetaData();\n\t\tint columnCount = rsmd.getColumnCount();\n\t\tfor (int index = 1; index <= columnCount; index++) {\n\t\t\tif (!usedIndex.contains(index)) {\n\t\t\t\tObject desc = getDescriptor(JdbcUtils.lookupColumnName(rsmd, index));\n\t\t\t\tif (desc instanceof MethodParameter mp) {\n\t\t\t\t\tMethod method = mp.getMethod();\n\t\t\t\t\tif (method != null) {\n\t\t\t\t\t\tObject value = JdbcUtils.getResultSetValue(rs, index, mp.getParameterType());\n\t\t\t\t\t\tvalue = this.conversionService.convert(value, new TypeDescriptor(mp));\n\t\t\t\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\t\t\t\tReflectionUtils.invokeMethod(method, mappedObject, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (desc instanceof Field field) {\n\t\t\t\t\tObject value = JdbcUtils.getResultSetValue(rs, index, field.getType());\n\t\t\t\t\tvalue = this.conversionService.convert(value, new TypeDescriptor(field));\n\t\t\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\t\t\tReflectionUtils.setField(field, mappedObject, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn mappedObject;\n\t}\n\n\tprivate Object getDescriptor(String column) {\n\t\treturn this.propertyDescriptors.computeIfAbsent(column, name -> {\n\n\t\t\t// Try direct match first\n\t\t\tPropertyDescriptor pd = BeanUtils.getPropertyDescriptor(this.mappedClass, name);\n\t\t\tif (pd != null && pd.getWriteMethod() != null) {\n\t\t\t\treturn BeanUtils.getWriteMethodParameter(pd);\n\t\t\t}\n\t\t\tField field = ReflectionUtils.findField(this.mappedClass, name);\n\t\t\tif (field != null) {\n\t\t\t\treturn field;\n\t\t\t}\n\n\t\t\t// Try de-underscored match instead\n\t\t\tString adaptedName = JdbcUtils.convertUnderscoreNameToPropertyName(name);\n\t\t\tif (!adaptedName.equals(name)) {\n\t\t\t\tpd = BeanUtils.getPropertyDescriptor(this.mappedClass, adaptedName);\n\t\t\t\tif (pd != null && pd.getWriteMethod() != null) {\n\t\t\t\t\treturn BeanUtils.getWriteMethodParameter(pd);\n\t\t\t\t}\n\t\t\t\tfield = ReflectionUtils.findField(this.mappedClass, adaptedName);\n\t\t\t\tif (field != null) {\n\t\t\t\t\treturn field;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fallback: case-insensitive match\n\t\t\tPropertyDescriptor[] pds = BeanUtils.getPropertyDescriptors(this.mappedClass);\n\t\t\tfor (PropertyDescriptor candidate : pds) {\n\t\t\t\tif (name.equalsIgnoreCase(candidate.getName())) {\n\t\t\t\t\treturn BeanUtils.getWriteMethodParameter(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfield = ReflectionUtils.findFieldIgnoreCase(this.mappedClass, name);\n\t\t\tif (field != null) {\n\t\t\t\treturn field;\n\t\t\t}\n\n\t\t\treturn NO_DESCRIPTOR;\n\t\t});\n\t}\n\n}"
  },
  "org.springframework.jdbc.core.SimplePropertyRowMapper#mapRow(rs,rowNumber)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "rowNumber"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "T",
    "signature": "public T mapRow(ResultSet rs, int rowNumber)",
    "source_code": "\tpublic T mapRow(ResultSet rs, int rowNumber) throws SQLException {\n\t\tObject[] args = new Object[this.constructorParameterNames.length];\n\t\tSet<Integer> usedIndex = new HashSet<>();\n\t\tfor (int i = 0; i < args.length; i++) {\n\t\t\tString name = this.constructorParameterNames[i];\n\t\t\tint index;\n\t\t\ttry {\n\t\t\t\t// Try direct name match first\n\t\t\t\tindex = rs.findColumn(name);\n\t\t\t}\n\t\t\tcatch (SQLException ex) {\n\t\t\t\t// Try underscored name match instead\n\t\t\t\tindex = rs.findColumn(JdbcUtils.convertPropertyNameToUnderscoreName(name));\n\t\t\t}\n\t\t\tTypeDescriptor td = this.constructorParameterTypes[i];\n\t\t\tObject value = JdbcUtils.getResultSetValue(rs, index, td.getType());\n\t\t\tusedIndex.add(index);\n\t\t\targs[i] = this.conversionService.convert(value, td);\n\t\t}\n\t\tT mappedObject = BeanUtils.instantiateClass(this.mappedConstructor, args);\n\n\t\tResultSetMetaData rsmd = rs.getMetaData();\n\t\tint columnCount = rsmd.getColumnCount();\n\t\tfor (int index = 1; index <= columnCount; index++) {\n\t\t\tif (!usedIndex.contains(index)) {\n\t\t\t\tObject desc = getDescriptor(JdbcUtils.lookupColumnName(rsmd, index));\n\t\t\t\tif (desc instanceof MethodParameter mp) {\n\t\t\t\t\tMethod method = mp.getMethod();\n\t\t\t\t\tif (method != null) {\n\t\t\t\t\t\tObject value = JdbcUtils.getResultSetValue(rs, index, mp.getParameterType());\n\t\t\t\t\t\tvalue = this.conversionService.convert(value, new TypeDescriptor(mp));\n\t\t\t\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\t\t\t\tReflectionUtils.invokeMethod(method, mappedObject, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (desc instanceof Field field) {\n\t\t\t\t\tObject value = JdbcUtils.getResultSetValue(rs, index, field.getType());\n\t\t\t\t\tvalue = this.conversionService.convert(value, new TypeDescriptor(field));\n\t\t\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\t\t\tReflectionUtils.setField(field, mappedObject, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn mappedObject;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataProviderFactory": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Factory used to create a {@link CallMetaDataProvider} implementation\n * based on the type of database being used.\n *\n * @author Thomas Risberg\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 2.5\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class CallMetaDataProviderFactory",
    "source_code": "public final class CallMetaDataProviderFactory {\n\n\tprivate static final String DB2 = \"DB2\";\n\tprivate static final String DERBY = \"Apache Derby\";\n\tprivate static final String HANA = \"HDB\";\n\tprivate static final String INFORMIX = \"Informix Dynamic Server\";\n\tprivate static final String MARIA = \"MariaDB\";\n\tprivate static final String MS_SQL_SERVER = \"Microsoft SQL Server\";\n\tprivate static final String MYSQL = \"MySQL\";\n\tprivate static final String ORACLE = \"Oracle\";\n\tprivate static final String POSTGRES = \"PostgreSQL\";\n\tprivate static final String SYBASE = \"Sybase\";\n\n\t/** List of supported database products for procedure calls. */\n\tpublic static final List<String> supportedDatabaseProductsForProcedures = List.of(\n\t\t\tDERBY,\n\t\t\tDB2,\n\t\t\tINFORMIX,\n\t\t\tMARIA,\n\t\t\tMS_SQL_SERVER,\n\t\t\tMYSQL,\n\t\t\tORACLE,\n\t\t\tPOSTGRES,\n\t\t\tSYBASE\n\t\t);\n\n\t/** List of supported database products for function calls. */\n\tpublic static final List<String> supportedDatabaseProductsForFunctions = List.of(\n\t\t\tMARIA,\n\t\t\tMS_SQL_SERVER,\n\t\t\tMYSQL,\n\t\t\tORACLE,\n\t\t\tPOSTGRES\n\t\t);\n\n\tprivate static final Log logger = LogFactory.getLog(CallMetaDataProviderFactory.class);\n\n\n\tprivate CallMetaDataProviderFactory() {\n\t}\n\n\n\t/**\n\t * Create a {@link CallMetaDataProvider} based on the database meta-data.\n\t * @param dataSource the JDBC DataSource to use for retrieving meta-data\n\t * @param context the class that holds configuration and meta-data\n\t * @return instance of the CallMetaDataProvider implementation to be used\n\t */\n\tpublic static CallMetaDataProvider createMetaDataProvider(DataSource dataSource, final CallMetaDataContext context) {\n\t\ttry {\n\t\t\treturn JdbcUtils.extractDatabaseMetaData(dataSource, databaseMetaData -> {\n\t\t\t\tString databaseProductName = JdbcUtils.commonDatabaseName(databaseMetaData.getDatabaseProductName());\n\t\t\t\tif (databaseProductName == null) {\n\t\t\t\t\tdatabaseProductName = \"\";\n\t\t\t\t}\n\n\t\t\t\tboolean accessProcedureColumnMetaData = context.isAccessCallParameterMetaData();\n\t\t\t\tif (context.isFunction()) {\n\t\t\t\t\tif (!supportedDatabaseProductsForFunctions.contains(databaseProductName)) {\n\t\t\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\t\t\tlogger.info(databaseProductName + \" is not one of the databases fully supported for function calls \" +\n\t\t\t\t\t\t\t\t\t\"-- supported are: \" + supportedDatabaseProductsForFunctions);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (accessProcedureColumnMetaData) {\n\t\t\t\t\t\t\tlogger.info(\"Metadata processing disabled - you must specify all parameters explicitly\");\n\t\t\t\t\t\t\taccessProcedureColumnMetaData = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!supportedDatabaseProductsForProcedures.contains(databaseProductName)) {\n\t\t\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\t\t\tlogger.info(databaseProductName + \" is not one of the databases fully supported for procedure calls \" +\n\t\t\t\t\t\t\t\t\t\"-- supported are: \" + supportedDatabaseProductsForProcedures);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (accessProcedureColumnMetaData) {\n\t\t\t\t\t\t\tlogger.info(\"Metadata processing disabled - you must specify all parameters explicitly\");\n\t\t\t\t\t\t\taccessProcedureColumnMetaData = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tCallMetaDataProvider provider = switch (databaseProductName) {\n\t\t\t\t\tcase ORACLE -> new OracleCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase POSTGRES -> new PostgresCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase DERBY -> new DerbyCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase DB2 -> new Db2CallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase HANA -> new HanaCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase MS_SQL_SERVER -> new SqlServerCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase SYBASE -> new SybaseCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tdefault -> new GenericCallMetaDataProvider(databaseMetaData);\n\t\t\t\t};\n\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Using \" + provider.getClass().getName());\n\t\t\t\t}\n\t\t\t\tprovider.initializeWithMetaData(databaseMetaData);\n\t\t\t\tif (accessProcedureColumnMetaData) {\n\t\t\t\t\tprovider.initializeWithProcedureColumnMetaData(databaseMetaData,\n\t\t\t\t\t\t\tcontext.getCatalogName(), context.getSchemaName(), context.getProcedureName());\n\t\t\t\t}\n\t\t\t\treturn provider;\n\t\t\t});\n\t\t}\n\t\tcatch (MetaDataAccessException ex) {\n\t\t\tthrow new DataAccessResourceFailureException(\"Error retrieving database meta-data\", ex);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataProviderFactory#createMetaDataProvider(dataSource,context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link CallMetaDataProvider} based on the database meta-data.\n\t * @param dataSource the JDBC DataSource to use for retrieving meta-data\n\t * @param context the class that holds configuration and meta-data\n\t * @return instance of the CallMetaDataProvider implementation to be used\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataSource",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "CallMetaDataProvider",
    "signature": "public CallMetaDataProvider createMetaDataProvider(DataSource dataSource, final CallMetaDataContext context)",
    "source_code": "\tpublic static CallMetaDataProvider createMetaDataProvider(DataSource dataSource, final CallMetaDataContext context) {\n\t\ttry {\n\t\t\treturn JdbcUtils.extractDatabaseMetaData(dataSource, databaseMetaData -> {\n\t\t\t\tString databaseProductName = JdbcUtils.commonDatabaseName(databaseMetaData.getDatabaseProductName());\n\t\t\t\tif (databaseProductName == null) {\n\t\t\t\t\tdatabaseProductName = \"\";\n\t\t\t\t}\n\n\t\t\t\tboolean accessProcedureColumnMetaData = context.isAccessCallParameterMetaData();\n\t\t\t\tif (context.isFunction()) {\n\t\t\t\t\tif (!supportedDatabaseProductsForFunctions.contains(databaseProductName)) {\n\t\t\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\t\t\tlogger.info(databaseProductName + \" is not one of the databases fully supported for function calls \" +\n\t\t\t\t\t\t\t\t\t\"-- supported are: \" + supportedDatabaseProductsForFunctions);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (accessProcedureColumnMetaData) {\n\t\t\t\t\t\t\tlogger.info(\"Metadata processing disabled - you must specify all parameters explicitly\");\n\t\t\t\t\t\t\taccessProcedureColumnMetaData = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!supportedDatabaseProductsForProcedures.contains(databaseProductName)) {\n\t\t\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\t\t\tlogger.info(databaseProductName + \" is not one of the databases fully supported for procedure calls \" +\n\t\t\t\t\t\t\t\t\t\"-- supported are: \" + supportedDatabaseProductsForProcedures);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (accessProcedureColumnMetaData) {\n\t\t\t\t\t\t\tlogger.info(\"Metadata processing disabled - you must specify all parameters explicitly\");\n\t\t\t\t\t\t\taccessProcedureColumnMetaData = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tCallMetaDataProvider provider = switch (databaseProductName) {\n\t\t\t\t\tcase ORACLE -> new OracleCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase POSTGRES -> new PostgresCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase DERBY -> new DerbyCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase DB2 -> new Db2CallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase HANA -> new HanaCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase MS_SQL_SERVER -> new SqlServerCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase SYBASE -> new SybaseCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tdefault -> new GenericCallMetaDataProvider(databaseMetaData);\n\t\t\t\t};\n\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Using \" + provider.getClass().getName());\n\t\t\t\t}\n\t\t\t\tprovider.initializeWithMetaData(databaseMetaData);\n\t\t\t\tif (accessProcedureColumnMetaData) {\n\t\t\t\t\tprovider.initializeWithProcedureColumnMetaData(databaseMetaData,\n\t\t\t\t\t\t\tcontext.getCatalogName(), context.getSchemaName(), context.getProcedureName());\n\t\t\t\t}\n\t\t\t\treturn provider;\n\t\t\t});\n\t\t}\n\t\tcatch (MetaDataAccessException ex) {\n\t\t\tthrow new DataAccessResourceFailureException(\"Error retrieving database meta-data\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A generic implementation of the {@link CallMetaDataProvider} interface.\n *\n * <p>This class can be extended to provide database specific behavior.\n *\n * @author Thomas Risberg\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Stephane Nicoll\n * @since 2.5\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "signature": "public class GenericCallMetaDataProvider",
    "source_code": "public class GenericCallMetaDataProvider implements CallMetaDataProvider {\n\n\t/** Logger available to subclasses. */\n\tprotected static final Log logger = LogFactory.getLog(CallMetaDataProvider.class);\n\n\n\tprivate final String userName;\n\n\tprivate boolean procedureColumnMetaDataUsed = false;\n\n\tprivate boolean supportsCatalogsInProcedureCalls = true;\n\n\tprivate boolean supportsSchemasInProcedureCalls = true;\n\n\tprivate boolean storesUpperCaseIdentifiers = true;\n\n\tprivate boolean storesLowerCaseIdentifiers = false;\n\n\tprivate final List<CallParameterMetaData> callParameterMetaData = new ArrayList<>();\n\n\n\t/**\n\t * Constructor used to initialize with provided database meta-data.\n\t * @param databaseMetaData meta-data to be used\n\t */\n\tprotected GenericCallMetaDataProvider(DatabaseMetaData databaseMetaData) throws SQLException {\n\t\tthis.userName = databaseMetaData.getUserName();\n\t}\n\n\n\t@Override\n\tpublic void initializeWithMetaData(DatabaseMetaData databaseMetaData) throws SQLException {\n\t\ttry {\n\t\t\tsetSupportsCatalogsInProcedureCalls(databaseMetaData.supportsCatalogsInProcedureCalls());\n\t\t}\n\t\tcatch (SQLException ex) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Error retrieving 'DatabaseMetaData.supportsCatalogsInProcedureCalls': \" + ex.getMessage());\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tsetSupportsSchemasInProcedureCalls(databaseMetaData.supportsSchemasInProcedureCalls());\n\t\t}\n\t\tcatch (SQLException ex) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Error retrieving 'DatabaseMetaData.supportsSchemasInProcedureCalls': \" + ex.getMessage());\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tsetStoresUpperCaseIdentifiers(databaseMetaData.storesUpperCaseIdentifiers());\n\t\t}\n\t\tcatch (SQLException ex) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Error retrieving 'DatabaseMetaData.storesUpperCaseIdentifiers': \" + ex.getMessage());\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tsetStoresLowerCaseIdentifiers(databaseMetaData.storesLowerCaseIdentifiers());\n\t\t}\n\t\tcatch (SQLException ex) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Error retrieving 'DatabaseMetaData.storesLowerCaseIdentifiers': \" + ex.getMessage());\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void initializeWithProcedureColumnMetaData(DatabaseMetaData databaseMetaData, @Nullable String catalogName,\n\t\t\t@Nullable String schemaName, @Nullable String procedureName) throws SQLException {\n\n\t\tthis.procedureColumnMetaDataUsed = true;\n\t\tprocessProcedureColumns(databaseMetaData, catalogName, schemaName, procedureName);\n\t}\n\n\t@Override\n\tpublic List<CallParameterMetaData> getCallParameterMetaData() {\n\t\treturn this.callParameterMetaData;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic String procedureNameToUse(@Nullable String procedureName) {\n\t\treturn identifierNameToUse(procedureName);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic String catalogNameToUse(@Nullable String catalogName) {\n\t\treturn identifierNameToUse(catalogName);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic String schemaNameToUse(@Nullable String schemaName) {\n\t\treturn identifierNameToUse(schemaName);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic String metaDataCatalogNameToUse(@Nullable String catalogName) {\n\t\tif (isSupportsCatalogsInProcedureCalls()) {\n\t\t\treturn catalogNameToUse(catalogName);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic String metaDataSchemaNameToUse(@Nullable String schemaName) {\n\t\tif (isSupportsSchemasInProcedureCalls()) {\n\t\t\treturn schemaNameToUse(schemaName);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic String parameterNameToUse(@Nullable String parameterName) {\n\t\treturn identifierNameToUse(parameterName);\n\t}\n\n\t@Override\n\tpublic String namedParameterBindingToUse(@Nullable String parameterName) {\n\t\treturn parameterName + \" => ?\";\n\t}\n\n\t@Override\n\tpublic SqlParameter createDefaultOutParameter(String parameterName, CallParameterMetaData meta) {\n\t\treturn new SqlOutParameter(parameterName, meta.getSqlType());\n\t}\n\n\t@Override\n\tpublic SqlParameter createDefaultInOutParameter(String parameterName, CallParameterMetaData meta) {\n\t\treturn new SqlInOutParameter(parameterName, meta.getSqlType());\n\t}\n\n\t@Override\n\tpublic SqlParameter createDefaultInParameter(String parameterName, CallParameterMetaData meta) {\n\t\treturn new SqlParameter(parameterName, meta.getSqlType());\n\t}\n\n\t@Override\n\tpublic String getUserName() {\n\t\treturn this.userName;\n\t}\n\n\t@Override\n\tpublic boolean isProcedureColumnMetaDataUsed() {\n\t\treturn this.procedureColumnMetaDataUsed;\n\t}\n\n\t@Override\n\tpublic boolean isReturnResultSetSupported() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean isRefCursorSupported() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic int getRefCursorSqlType() {\n\t\treturn Types.OTHER;\n\t}\n\n\t@Override\n\tpublic boolean byPassReturnParameter(String parameterName) {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Specify whether the database supports the use of catalog name in procedure calls.\n\t */\n\tprotected void setSupportsCatalogsInProcedureCalls(boolean supportsCatalogsInProcedureCalls) {\n\t\tthis.supportsCatalogsInProcedureCalls = supportsCatalogsInProcedureCalls;\n\t}\n\n\t/**\n\t * Does the database support the use of catalog name in procedure calls?\n\t */\n\t@Override\n\tpublic boolean isSupportsCatalogsInProcedureCalls() {\n\t\treturn this.supportsCatalogsInProcedureCalls;\n\t}\n\n\t/**\n\t * Specify whether the database supports the use of schema name in procedure calls.\n\t */\n\tprotected void setSupportsSchemasInProcedureCalls(boolean supportsSchemasInProcedureCalls) {\n\t\tthis.supportsSchemasInProcedureCalls = supportsSchemasInProcedureCalls;\n\t}\n\n\t/**\n\t * Does the database support the use of schema name in procedure calls?\n\t */\n\t@Override\n\tpublic boolean isSupportsSchemasInProcedureCalls() {\n\t\treturn this.supportsSchemasInProcedureCalls;\n\t}\n\n\t/**\n\t * Specify whether the database uses upper case for identifiers.\n\t */\n\tprotected void setStoresUpperCaseIdentifiers(boolean storesUpperCaseIdentifiers) {\n\t\tthis.storesUpperCaseIdentifiers = storesUpperCaseIdentifiers;\n\t}\n\n\t/**\n\t * Does the database use upper case for identifiers?\n\t */\n\tprotected boolean isStoresUpperCaseIdentifiers() {\n\t\treturn this.storesUpperCaseIdentifiers;\n\t}\n\n\t/**\n\t * Specify whether the database uses lower case for identifiers.\n\t */\n\tprotected void setStoresLowerCaseIdentifiers(boolean storesLowerCaseIdentifiers) {\n\t\tthis.storesLowerCaseIdentifiers = storesLowerCaseIdentifiers;\n\t}\n\n\t/**\n\t * Does the database use lower case for identifiers?\n\t */\n\tprotected boolean isStoresLowerCaseIdentifiers() {\n\t\treturn this.storesLowerCaseIdentifiers;\n\t}\n\n\n\t@Nullable\n\tprivate String identifierNameToUse(@Nullable String identifierName) {\n\t\tif (identifierName == null) {\n\t\t\treturn null;\n\t\t}\n\t\telse if (isStoresUpperCaseIdentifiers()) {\n\t\t\treturn identifierName.toUpperCase();\n\t\t}\n\t\telse if (isStoresLowerCaseIdentifiers()) {\n\t\t\treturn identifierName.toLowerCase();\n\t\t}\n\t\telse {\n\t\t\treturn identifierName;\n\t\t}\n\t}\n\n\t/**\n\t * Process the procedure column meta-data.\n\t */\n\tprivate void processProcedureColumns(DatabaseMetaData databaseMetaData,\n\t\t\t@Nullable String catalogName, @Nullable String schemaName, @Nullable String procedureName) {\n\n\t\tString metaDataCatalogName = metaDataCatalogNameToUse(catalogName);\n\t\tString metaDataSchemaName = metaDataSchemaNameToUse(schemaName);\n\t\tString metaDataProcedureName = procedureNameToUse(procedureName);\n\t\ttry {\n\t\t\tProcedureMetadata procedureMetadata = getProcedureMetadata(databaseMetaData,\n\t\t\t\t\tmetaDataCatalogName, metaDataSchemaName, metaDataProcedureName);\n\t\t\tif (procedureMetadata.hits() > 1) {\n\t\t\t\t// Try again with exact match in case of placeholders\n\t\t\t\tString searchStringEscape = databaseMetaData.getSearchStringEscape();\n\t\t\t\tif (searchStringEscape != null) {\n\t\t\t\t\tprocedureMetadata = getProcedureMetadata(databaseMetaData, metaDataCatalogName,\n\t\t\t\t\t\t\tescapeNamePattern(metaDataSchemaName, searchStringEscape),\n\t\t\t\t\t\t\tescapeNamePattern(metaDataProcedureName, searchStringEscape));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (procedureMetadata.hits() == 0) {\n\t\t\t\t// Functions not exposed as procedures anymore on PostgreSQL driver 42.2.11\n\t\t\t\tprocedureMetadata = getProcedureMetadataAsFunction(databaseMetaData,\n\t\t\t\t\t\tmetaDataCatalogName, metaDataSchemaName, metaDataProcedureName);\n\t\t\t\tif (procedureMetadata.hits() > 1) {\n\t\t\t\t\t// Try again with exact match in case of placeholders\n\t\t\t\t\tString searchStringEscape = databaseMetaData.getSearchStringEscape();\n\t\t\t\t\tif (searchStringEscape != null) {\n\t\t\t\t\t\tprocedureMetadata = getProcedureMetadataAsFunction(\n\t\t\t\t\t\t\t\tdatabaseMetaData, metaDataCatalogName,\n\t\t\t\t\t\t\t\tescapeNamePattern(metaDataSchemaName, searchStringEscape),\n\t\t\t\t\t\t\t\tescapeNamePattern(metaDataProcedureName, searchStringEscape));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Handling matches\n\n\t\t\tboolean isFunction = procedureMetadata.function();\n\t\t\tList<String> matches = procedureMetadata.matches;\n\t\t\tif (matches.size() > 1) {\n\t\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\t\"Unable to determine the correct call signature - multiple signatures for '\" +\n\t\t\t\t\t\tmetaDataProcedureName + \"': found \" + matches + \" \" + (isFunction ? \"functions\" : \"procedures\"));\n\t\t\t}\n\t\t\telse if (matches.isEmpty()) {\n\t\t\t\tif (metaDataProcedureName != null && metaDataProcedureName.contains(\".\") &&\n\t\t\t\t\t\t!StringUtils.hasText(metaDataCatalogName)) {\n\t\t\t\t\tString packageName = metaDataProcedureName.substring(0, metaDataProcedureName.indexOf('.'));\n\t\t\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\t\t\"Unable to determine the correct call signature for '\" + metaDataProcedureName +\n\t\t\t\t\t\t\t\"' - package name should be specified separately using '.withCatalogName(\\\"\" +\n\t\t\t\t\t\t\tpackageName + \"\\\")'\");\n\t\t\t\t}\n\t\t\t\telse if (\"Oracle\".equals(databaseMetaData.getDatabaseProductName())) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Oracle JDBC driver did not return procedure/function/signature for '\" +\n\t\t\t\t\t\t\t\tmetaDataProcedureName + \"' - assuming a non-exposed synonym\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\t\t\"Unable to determine the correct call signature - no \" +\n\t\t\t\t\t\t\t\"procedure/function/signature for '\" + metaDataProcedureName + \"'\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Retrieving column meta-data for \" + (isFunction ? \"function\" : \"procedure\") + ' ' +\n\t\t\t\t\t\tmetaDataCatalogName + '/' + procedureMetadata.schemaName + '/' + procedureMetadata.procedureName);\n\t\t\t}\n\t\t\ttry (ResultSet columns = isFunction ?\n\t\t\t\t\tdatabaseMetaData.getFunctionColumns(metaDataCatalogName, procedureMetadata.schemaName, procedureMetadata.procedureName, null) :\n\t\t\t\t\tdatabaseMetaData.getProcedureColumns(metaDataCatalogName, procedureMetadata.schemaName, procedureMetadata.procedureName, null)) {\n\t\t\t\twhile (columns.next()) {\n\t\t\t\t\tString columnName = columns.getString(\"COLUMN_NAME\");\n\t\t\t\t\tint columnType = columns.getInt(\"COLUMN_TYPE\");\n\t\t\t\t\tif (columnName == null && isInOrOutColumn(columnType, isFunction)) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Skipping meta-data for: \" + columnType + \" \" + columns.getInt(\"DATA_TYPE\") +\n\t\t\t\t\t\t\t\t\t\" \" + columns.getString(\"TYPE_NAME\") + \" \" + columns.getInt(\"NULLABLE\") +\n\t\t\t\t\t\t\t\t\t\" (probably a member of a collection)\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tint nullable = (isFunction ? DatabaseMetaData.functionNullable : DatabaseMetaData.procedureNullable);\n\t\t\t\t\t\tCallParameterMetaData meta = new CallParameterMetaData(isFunction, columnName, columnType,\n\t\t\t\t\t\t\t\tcolumns.getInt(\"DATA_TYPE\"), columns.getString(\"TYPE_NAME\"),\n\t\t\t\t\t\t\t\tcolumns.getInt(\"NULLABLE\") == nullable);\n\t\t\t\t\t\tthis.callParameterMetaData.add(meta);\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Retrieved meta-data: \" + meta.getParameterName() + \" \" +\n\t\t\t\t\t\t\t\t\tmeta.getParameterType() + \" \" + meta.getSqlType() + \" \" +\n\t\t\t\t\t\t\t\t\tmeta.getTypeName() + \" \" + meta.isNullable());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (SQLException ex) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Error while retrieving meta-data for procedure columns. \" +\n\t\t\t\t\t\t\"Consider declaring explicit parameters -- for example, via SimpleJdbcCall#addDeclaredParameter().\",\n\t\t\t\t\t\tex);\n\t\t\t}\n\t\t\t// Although we could invoke `this.callParameterMetaData.clear()` so that\n\t\t\t// we don't retain a partial list of column names (like we do in\n\t\t\t// GenericTableMetaDataProvider.processTableColumns(...)), we choose\n\t\t\t// not to do that here, since invocation of the stored procedure will\n\t\t\t// likely fail anyway with an incorrect argument list.\n\t\t}\n\t}\n\n\tprivate ProcedureMetadata getProcedureMetadata(DatabaseMetaData databaseMetaData,\n\t\t\t@Nullable String catalogName, @Nullable String schemaName, @Nullable String procedureName) throws SQLException {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Retrieving meta-data for \" + catalogName + '/' + schemaName + '/' + procedureName);\n\t\t}\n\t\tList<String> matches = new ArrayList<>();\n\t\ttry (ResultSet procedures = databaseMetaData.getProcedures(catalogName, schemaName, procedureName)) {\n\t\t\twhile (procedures.next()) {\n\t\t\t\tmatches.add(procedures.getString(\"PROCEDURE_CAT\") + '.' + procedures.getString(\"PROCEDURE_SCHEM\") +\n\t\t\t\t\t\t'.' + procedures.getString(\"PROCEDURE_NAME\"));\n\t\t\t}\n\t\t}\n\t\treturn new ProcedureMetadata(schemaName, procedureName, matches, false);\n\t}\n\n\tprivate ProcedureMetadata getProcedureMetadataAsFunction(DatabaseMetaData databaseMetaData,\n\t\t\t@Nullable String catalogName, @Nullable String schemaName, @Nullable String procedureName) throws SQLException {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Fallback on retrieving function meta-data for \" + catalogName + '/' + schemaName + '/' + procedureName);\n\t\t}\n\t\tList<String> matches = new ArrayList<>();\n\t\ttry (ResultSet functions = databaseMetaData.getFunctions(catalogName, schemaName, procedureName)) {\n\t\t\twhile (functions.next()) {\n\t\t\t\tmatches.add(functions.getString(\"FUNCTION_CAT\") + '.' + functions.getString(\"FUNCTION_SCHEM\") +\n\t\t\t\t\t\t'.' + functions.getString(\"FUNCTION_NAME\"));\n\t\t\t}\n\t\t}\n\t\treturn new ProcedureMetadata(schemaName, procedureName, matches, true);\n\t}\n\n\t@Nullable\n\tprivate static String escapeNamePattern(@Nullable String name, @Nullable String escape) {\n\t\tif (name == null || escape == null) {\n\t\t\treturn name;\n\t\t}\n\t\treturn name.replace(escape, escape + escape)\n\t\t\t\t\t.replace(\"_\", escape + \"_\")\n\t\t\t\t\t.replace(\"%\", escape + \"%\");\n\t}\n\n\tprivate static boolean isInOrOutColumn(int columnType, boolean function) {\n\t\tif (function) {\n\t\t\treturn (columnType == DatabaseMetaData.functionColumnIn ||\n\t\t\t\t\tcolumnType == DatabaseMetaData.functionColumnInOut ||\n\t\t\t\t\tcolumnType == DatabaseMetaData.functionColumnOut);\n\t\t}\n\t\telse {\n\t\t\treturn (columnType == DatabaseMetaData.procedureColumnIn ||\n\t\t\t\t\tcolumnType == DatabaseMetaData.procedureColumnInOut ||\n\t\t\t\t\tcolumnType == DatabaseMetaData.procedureColumnOut);\n\t\t}\n\t}\n\n\tprivate record ProcedureMetadata(@Nullable String schemaName, @Nullable String procedureName,\n\t\t\tList<String> matches, boolean function) {\n\n\t\tint hits() {\n\t\t\treturn this.matches.size();\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider#byPassReturnParameter(parameterName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterName"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "boolean",
    "signature": "public boolean byPassReturnParameter(String parameterName)",
    "source_code": "\tpublic boolean byPassReturnParameter(String parameterName) {\n\t\treturn false;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider#catalogNameToUse(catalogName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "catalogName"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "String",
    "signature": "public String catalogNameToUse(@Nullable String catalogName)",
    "source_code": "\tpublic String catalogNameToUse(@Nullable String catalogName) {\n\t\treturn identifierNameToUse(catalogName);\n\t}"
  },
  "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider#createDefaultInOutParameter(parameterName,meta)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterName",
      "meta"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "SqlParameter",
    "signature": "public SqlParameter createDefaultInOutParameter(String parameterName, CallParameterMetaData meta)",
    "source_code": "\tpublic SqlParameter createDefaultInOutParameter(String parameterName, CallParameterMetaData meta) {\n\t\treturn new SqlInOutParameter(parameterName, meta.getSqlType());\n\t}"
  },
  "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider#createDefaultInParameter(parameterName,meta)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterName",
      "meta"
    ],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "SqlParameter",
    "signature": "public SqlParameter createDefaultInParameter(String parameterName, CallParameterMetaData meta)",
    "source_code": "\tpublic SqlParameter createDefaultInParameter(String parameterName, CallParameterMetaData meta) {\n\t\treturn new SqlParameter(parameterName, meta.getSqlType());\n\t}"
  },
  "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider#createDefaultOutParameter(parameterName,meta)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterName",
      "meta"
    ],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "SqlParameter",
    "signature": "public SqlParameter createDefaultOutParameter(String parameterName, CallParameterMetaData meta)",
    "source_code": "\tpublic SqlParameter createDefaultOutParameter(String parameterName, CallParameterMetaData meta) {\n\t\treturn new SqlOutParameter(parameterName, meta.getSqlType());\n\t}"
  },
  "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider#getCallParameterMetaData()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "List<CallParameterMetaData>",
    "signature": "public List<CallParameterMetaData> getCallParameterMetaData()",
    "source_code": "\tpublic List<CallParameterMetaData> getCallParameterMetaData() {\n\t\treturn this.callParameterMetaData;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider#getRefCursorSqlType()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "int",
    "signature": "public int getRefCursorSqlType()",
    "source_code": "\tpublic int getRefCursorSqlType() {\n\t\treturn Types.OTHER;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider#getUserName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "String",
    "signature": "public String getUserName()",
    "source_code": "\tpublic String getUserName() {\n\t\treturn this.userName;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider#initializeWithMetaData(databaseMetaData)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "databaseMetaData"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "void",
    "signature": "public void initializeWithMetaData(DatabaseMetaData databaseMetaData)",
    "source_code": "\tpublic void initializeWithMetaData(DatabaseMetaData databaseMetaData) throws SQLException {\n\t\ttry {\n\t\t\tsetSupportsCatalogsInProcedureCalls(databaseMetaData.supportsCatalogsInProcedureCalls());\n\t\t}\n\t\tcatch (SQLException ex) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Error retrieving 'DatabaseMetaData.supportsCatalogsInProcedureCalls': \" + ex.getMessage());\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tsetSupportsSchemasInProcedureCalls(databaseMetaData.supportsSchemasInProcedureCalls());\n\t\t}\n\t\tcatch (SQLException ex) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Error retrieving 'DatabaseMetaData.supportsSchemasInProcedureCalls': \" + ex.getMessage());\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tsetStoresUpperCaseIdentifiers(databaseMetaData.storesUpperCaseIdentifiers());\n\t\t}\n\t\tcatch (SQLException ex) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Error retrieving 'DatabaseMetaData.storesUpperCaseIdentifiers': \" + ex.getMessage());\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tsetStoresLowerCaseIdentifiers(databaseMetaData.storesLowerCaseIdentifiers());\n\t\t}\n\t\tcatch (SQLException ex) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Error retrieving 'DatabaseMetaData.storesLowerCaseIdentifiers': \" + ex.getMessage());\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider#initializeWithProcedureColumnMetaData(databaseMetaData,catalogName,schemaName,procedureName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "databaseMetaData",
      "catalogName",
      "schemaName",
      "procedureName"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "void",
    "signature": "public void initializeWithProcedureColumnMetaData(DatabaseMetaData databaseMetaData, @Nullable String catalogName,\n\t\t\t@Nullable String schemaName, @Nullable String procedureName)",
    "source_code": "\tpublic void initializeWithProcedureColumnMetaData(DatabaseMetaData databaseMetaData, @Nullable String catalogName,"
  },
  "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider#isProcedureColumnMetaDataUsed()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "boolean",
    "signature": "public boolean isProcedureColumnMetaDataUsed()",
    "source_code": "\tpublic boolean isProcedureColumnMetaDataUsed() {\n\t\treturn this.procedureColumnMetaDataUsed;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider#isRefCursorSupported()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "boolean",
    "signature": "public boolean isRefCursorSupported()",
    "source_code": "\tpublic boolean isRefCursorSupported() {\n\t\treturn false;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider#isReturnResultSetSupported()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "boolean",
    "signature": "public boolean isReturnResultSetSupported()",
    "source_code": "\tpublic boolean isReturnResultSetSupported() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider#isStoresLowerCaseIdentifiers()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Does the database use lower case for identifiers?\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "boolean",
    "signature": "protected boolean isStoresLowerCaseIdentifiers()",
    "source_code": "\tprotected boolean isStoresLowerCaseIdentifiers() {\n\t\treturn this.storesLowerCaseIdentifiers;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider#isStoresUpperCaseIdentifiers()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Does the database use upper case for identifiers?\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "boolean",
    "signature": "protected boolean isStoresUpperCaseIdentifiers()",
    "source_code": "\tprotected boolean isStoresUpperCaseIdentifiers() {\n\t\treturn this.storesUpperCaseIdentifiers;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider#isSupportsCatalogsInProcedureCalls()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Does the database support the use of catalog name in procedure calls?\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "boolean",
    "signature": "public boolean isSupportsCatalogsInProcedureCalls()",
    "source_code": "\tpublic boolean isSupportsCatalogsInProcedureCalls() {\n\t\treturn this.supportsCatalogsInProcedureCalls;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider#isSupportsSchemasInProcedureCalls()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Does the database support the use of schema name in procedure calls?\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "boolean",
    "signature": "public boolean isSupportsSchemasInProcedureCalls()",
    "source_code": "\tpublic boolean isSupportsSchemasInProcedureCalls() {\n\t\treturn this.supportsSchemasInProcedureCalls;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider#metaDataCatalogNameToUse(catalogName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "catalogName"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "String",
    "signature": "public String metaDataCatalogNameToUse(@Nullable String catalogName)",
    "source_code": "\tpublic String metaDataCatalogNameToUse(@Nullable String catalogName) {\n\t\tif (isSupportsCatalogsInProcedureCalls()) {\n\t\t\treturn catalogNameToUse(catalogName);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider#metaDataSchemaNameToUse(schemaName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "schemaName"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "String",
    "signature": "public String metaDataSchemaNameToUse(@Nullable String schemaName)",
    "source_code": "\tpublic String metaDataSchemaNameToUse(@Nullable String schemaName) {\n\t\tif (isSupportsSchemasInProcedureCalls()) {\n\t\t\treturn schemaNameToUse(schemaName);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider#namedParameterBindingToUse(parameterName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterName"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "String",
    "signature": "public String namedParameterBindingToUse(@Nullable String parameterName)",
    "source_code": "\tpublic String namedParameterBindingToUse(@Nullable String parameterName) {\n\t\treturn parameterName + \" => ?\";\n\t}"
  },
  "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider#parameterNameToUse(parameterName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterName"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "String",
    "signature": "public String parameterNameToUse(@Nullable String parameterName)",
    "source_code": "\tpublic String parameterNameToUse(@Nullable String parameterName) {\n\t\treturn identifierNameToUse(parameterName);\n\t}"
  },
  "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider#procedureNameToUse(procedureName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "procedureName"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "String",
    "signature": "public String procedureNameToUse(@Nullable String procedureName)",
    "source_code": "\tpublic String procedureNameToUse(@Nullable String procedureName) {\n\t\treturn identifierNameToUse(procedureName);\n\t}"
  },
  "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider#schemaNameToUse(schemaName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "schemaName"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "String",
    "signature": "public String schemaNameToUse(@Nullable String schemaName)",
    "source_code": "\tpublic String schemaNameToUse(@Nullable String schemaName) {\n\t\treturn identifierNameToUse(schemaName);\n\t}"
  },
  "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider#setStoresLowerCaseIdentifiers(storesLowerCaseIdentifiers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether the database uses lower case for identifiers.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "storesLowerCaseIdentifiers"
    ],
    "position": {
      "column": 1,
      "line": 269
    },
    "return": "void",
    "signature": "protected void setStoresLowerCaseIdentifiers(boolean storesLowerCaseIdentifiers)",
    "source_code": "\tprotected void setStoresLowerCaseIdentifiers(boolean storesLowerCaseIdentifiers) {\n\t\tthis.storesLowerCaseIdentifiers = storesLowerCaseIdentifiers;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider#setStoresUpperCaseIdentifiers(storesUpperCaseIdentifiers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether the database uses upper case for identifiers.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "storesUpperCaseIdentifiers"
    ],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "void",
    "signature": "protected void setStoresUpperCaseIdentifiers(boolean storesUpperCaseIdentifiers)",
    "source_code": "\tprotected void setStoresUpperCaseIdentifiers(boolean storesUpperCaseIdentifiers) {\n\t\tthis.storesUpperCaseIdentifiers = storesUpperCaseIdentifiers;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider#setSupportsCatalogsInProcedureCalls(supportsCatalogsInProcedureCalls)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether the database supports the use of catalog name in procedure calls.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "supportsCatalogsInProcedureCalls"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "void",
    "signature": "protected void setSupportsCatalogsInProcedureCalls(boolean supportsCatalogsInProcedureCalls)",
    "source_code": "\tprotected void setSupportsCatalogsInProcedureCalls(boolean supportsCatalogsInProcedureCalls) {\n\t\tthis.supportsCatalogsInProcedureCalls = supportsCatalogsInProcedureCalls;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider#setSupportsSchemasInProcedureCalls(supportsSchemasInProcedureCalls)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether the database supports the use of schema name in procedure calls.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "supportsSchemasInProcedureCalls"
    ],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "void",
    "signature": "protected void setSupportsSchemasInProcedureCalls(boolean supportsSchemasInProcedureCalls)",
    "source_code": "\tprotected void setSupportsSchemasInProcedureCalls(boolean supportsSchemasInProcedureCalls) {\n\t\tthis.supportsSchemasInProcedureCalls = supportsSchemasInProcedureCalls;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.supportedDatabaseProductsForFunctions": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** List of supported database products for function calls. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "signature": "public List<String> supportedDatabaseProductsForFunctions",
    "source_code": "\tpublic static final List<String> supportedDatabaseProductsForFunctions = List.of(",
    "type": "List<String>"
  },
  "org.springframework.jdbc.core.metadata.supportedDatabaseProductsForProcedures": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** List of supported database products for procedure calls. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "signature": "public List<String> supportedDatabaseProductsForProcedures",
    "source_code": "\tpublic static final List<String> supportedDatabaseProductsForProcedures = List.of(",
    "type": "List<String>"
  },
  "org.springframework.jdbc.core.namedparam.MapSqlParameterSource#hasValues()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether this parameter source has been configured with any values.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "boolean",
    "signature": "public boolean hasValues()",
    "source_code": "\tpublic boolean hasValues() {\n\t\treturn !this.values.isEmpty();\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.SimplePropertySqlParameterSource": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link SqlParameterSource} implementation that obtains parameter values\n * from bean properties of a given JavaBean object, from component accessors\n * of a record class, or from raw field access.\n *\n * <p>This is a more flexible variant of {@link BeanPropertySqlParameterSource},\n * with the limitation that it is not able to enumerate its\n * {@link #getParameterNames() parameter names}.\n *\n * <p>In terms of its fallback property discovery algorithm, this class is\n * similar to {@link org.springframework.validation.SimpleErrors} which is\n * also just used for property retrieval purposes (rather than binding).\n *\n * @author Juergen Hoeller\n * @since 6.1\n * @see NamedParameterJdbcTemplate\n * @see BeanPropertySqlParameterSource\n * @see org.springframework.jdbc.core.simple.JdbcClient.StatementSpec#paramSource(Object)\n * @see org.springframework.jdbc.core.SimplePropertyRowMapper\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "public class SimplePropertySqlParameterSource",
    "source_code": "public class SimplePropertySqlParameterSource extends AbstractSqlParameterSource {\n\n\tprivate static final Object NO_DESCRIPTOR = new Object();\n\n\tprivate final Object paramObject;\n\n\tprivate final Map<String, Object> propertyDescriptors = new ConcurrentHashMap<>();\n\n\n\t/**\n\t * Create a new SqlParameterSource for the given bean, record or field holder.\n\t * @param paramObject the bean, record or field holder instance to wrap\n\t */\n\tpublic SimplePropertySqlParameterSource(Object paramObject) {\n\t\tAssert.notNull(paramObject, \"Parameter object must not be null\");\n\t\tthis.paramObject = paramObject;\n\t}\n\n\n\t@Override\n\tpublic boolean hasValue(String paramName) {\n\t\treturn (getDescriptor(paramName) != NO_DESCRIPTOR);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Object getValue(String paramName) throws IllegalArgumentException {\n\t\tObject desc = getDescriptor(paramName);\n\t\tif (desc instanceof PropertyDescriptor pd) {\n\t\t\tReflectionUtils.makeAccessible(pd.getReadMethod());\n\t\t\treturn ReflectionUtils.invokeMethod(pd.getReadMethod(), this.paramObject);\n\t\t}\n\t\telse if (desc instanceof Field field) {\n\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\treturn ReflectionUtils.getField(field, this.paramObject);\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Cannot retrieve value for parameter '\" + paramName +\n\t\t\t\t\"' - neither a getter method nor a raw field found\");\n\t}\n\n\t/**\n\t * Derives a default SQL type from the corresponding property type.\n\t * @see StatementCreatorUtils#javaTypeToSqlParameterType\n\t */\n\t@Override\n\tpublic int getSqlType(String paramName) {\n\t\tint sqlType = super.getSqlType(paramName);\n\t\tif (sqlType != TYPE_UNKNOWN) {\n\t\t\treturn sqlType;\n\t\t}\n\t\tObject desc = getDescriptor(paramName);\n\t\tif (desc instanceof PropertyDescriptor pd) {\n\t\t\treturn StatementCreatorUtils.javaTypeToSqlParameterType(pd.getPropertyType());\n\t\t}\n\t\telse if (desc instanceof Field field) {\n\t\t\treturn StatementCreatorUtils.javaTypeToSqlParameterType(field.getType());\n\t\t}\n\t\treturn TYPE_UNKNOWN;\n\t}\n\n\tprivate Object getDescriptor(String paramName) {\n\t\treturn this.propertyDescriptors.computeIfAbsent(paramName, name -> {\n\t\t\tPropertyDescriptor pd = BeanUtils.getPropertyDescriptor(this.paramObject.getClass(), name);\n\t\t\tif (pd != null && pd.getReadMethod() != null) {\n\t\t\t\treturn pd;\n\t\t\t}\n\t\t\tField field = ReflectionUtils.findField(this.paramObject.getClass(), name);\n\t\t\tif (field != null) {\n\t\t\t\treturn field;\n\t\t\t}\n\t\t\treturn NO_DESCRIPTOR;\n\t\t});\n\t}\n\n}"
  },
  "org.springframework.jdbc.core.namedparam.SimplePropertySqlParameterSource#getSqlType(paramName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Derives a default SQL type from the corresponding property type.\n\t * @see StatementCreatorUtils#javaTypeToSqlParameterType\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "int",
    "signature": "public int getSqlType(String paramName)",
    "source_code": "\tpublic int getSqlType(String paramName) {\n\t\tint sqlType = super.getSqlType(paramName);\n\t\tif (sqlType != TYPE_UNKNOWN) {\n\t\t\treturn sqlType;\n\t\t}\n\t\tObject desc = getDescriptor(paramName);\n\t\tif (desc instanceof PropertyDescriptor pd) {\n\t\t\treturn StatementCreatorUtils.javaTypeToSqlParameterType(pd.getPropertyType());\n\t\t}\n\t\telse if (desc instanceof Field field) {\n\t\t\treturn StatementCreatorUtils.javaTypeToSqlParameterType(field.getType());\n\t\t}\n\t\treturn TYPE_UNKNOWN;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.SimplePropertySqlParameterSource#getValue(paramName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "Object",
    "signature": "public Object getValue(String paramName)",
    "source_code": "\tpublic Object getValue(String paramName) throws IllegalArgumentException {\n\t\tObject desc = getDescriptor(paramName);\n\t\tif (desc instanceof PropertyDescriptor pd) {\n\t\t\tReflectionUtils.makeAccessible(pd.getReadMethod());\n\t\t\treturn ReflectionUtils.invokeMethod(pd.getReadMethod(), this.paramObject);\n\t\t}\n\t\telse if (desc instanceof Field field) {\n\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\treturn ReflectionUtils.getField(field, this.paramObject);\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Cannot retrieve value for parameter '\" + paramName +\n\t\t\t\t\"' - neither a getter method nor a raw field found\");\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.SimplePropertySqlParameterSource#hasValue(paramName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "boolean",
    "signature": "public boolean hasValue(String paramName)",
    "source_code": "\tpublic boolean hasValue(String paramName) {\n\t\treturn (getDescriptor(paramName) != NO_DESCRIPTOR);\n\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#list()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 365
    },
    "return": "List<T>",
    "signature": "public List<T> list()",
    "source_code": "\t\t\tpublic List<T> list() {\n\t\t\t\treturn namedParamOps.query(sql, namedParamSource, this.rowMapper);\n\t\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#listOfRows()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 315
    },
    "return": "Object>>",
    "signature": "public Object>> listOfRows()",
    "source_code": "\t\t\tpublic List<Map<String, Object>> listOfRows() {\n\t\t\t\treturn namedParamOps.queryForList(sql, namedParamSource);\n\t\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#param(jdbcIndex,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "jdbcIndex",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec param(int jdbcIndex, @Nullable Object value)",
    "source_code": "\t\tpublic StatementSpec param(int jdbcIndex, @Nullable Object value) {\n\t\t\tif (jdbcIndex < 1) {\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid JDBC index: needs to start at 1\");\n\t\t\t}\n\t\t\tvalidateIndexedParamValue(value);\n\t\t\tint index = jdbcIndex - 1;\n\t\t\tint size = this.indexedParams.size();\n\t\t\tif (index < size) {\n\t\t\t\tthis.indexedParams.set(index, value);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = size; i < index; i++) {\n\t\t\t\t\tthis.indexedParams.add(null);\n\t\t\t\t}\n\t\t\t\tthis.indexedParams.add(value);\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#param(jdbcIndex,value,sqlType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "jdbcIndex",
      "value",
      "sqlType"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec param(int jdbcIndex, @Nullable Object value, int sqlType)",
    "source_code": "\t\tpublic StatementSpec param(int jdbcIndex, @Nullable Object value, int sqlType) {\n\t\t\treturn param(jdbcIndex, new SqlParameterValue(sqlType, value));\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#param(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec param(String name, @Nullable Object value)",
    "source_code": "\t\tpublic StatementSpec param(String name, @Nullable Object value) {\n\t\t\tthis.namedParams.addValue(name, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#param(name,value,sqlType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value",
      "sqlType"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec param(String name, @Nullable Object value, int sqlType)",
    "source_code": "\t\tpublic StatementSpec param(String name, @Nullable Object value, int sqlType) {\n\t\t\tthis.namedParams.addValue(name, value, sqlType);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#param(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec param(@Nullable Object value)",
    "source_code": "\t\tpublic StatementSpec param(@Nullable Object value) {\n\t\t\tvalidateIndexedParamValue(value);\n\t\t\tthis.indexedParams.add(value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#paramSource(namedParamObject)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "namedParamObject"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec paramSource(Object namedParamObject)",
    "source_code": "\t\tpublic StatementSpec paramSource(Object namedParamObject) {\n\t\t\tthis.namedParamSource = (namedParamObject instanceof Map map ?\n\t\t\t\t\tnew MapSqlParameterSource(map) :\n\t\t\t\t\tnew SimplePropertySqlParameterSource(namedParamObject));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#paramSource(namedParamSource)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "namedParamSource"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec paramSource(SqlParameterSource namedParamSource)",
    "source_code": "\t\tpublic StatementSpec paramSource(SqlParameterSource namedParamSource) {\n\t\t\tthis.namedParamSource = namedParamSource;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#params(Map<String,paramMap)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "paramMap"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec params(Map<String, ?> paramMap)",
    "source_code": "\t\tpublic StatementSpec params(Map<String, ?> paramMap) {\n\t\t\tthis.namedParams.addValues(paramMap);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#params(values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "values"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec params(List<?> values)",
    "source_code": "\t\tpublic StatementSpec params(List<?> values) {\n\t\t\tthis.indexedParams.addAll(values);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#query()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "ResultQuerySpec",
    "signature": "public ResultQuerySpec query()",
    "source_code": "\t\tpublic ResultQuerySpec query() {\n\t\t\treturn (useNamedParams() ?\n\t\t\t\t\tnew NamedParamResultQuerySpec() :\n\t\t\t\t\tnew IndexedParamResultQuerySpec());\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#query(mappedClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedClass"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "MappedQuerySpec<T>",
    "signature": "public MappedQuerySpec<T> query(Class<T> mappedClass)",
    "source_code": "\t\tpublic <T> MappedQuerySpec<T> query(Class<T> mappedClass) {\n\t\t\tRowMapper<?> rowMapper = rowMapperCache.computeIfAbsent(mappedClass, key ->\n\t\t\t\t\tBeanUtils.isSimpleProperty(mappedClass) ? new SingleColumnRowMapper<>(mappedClass) :\n\t\t\t\t\t\t\tnew SimplePropertyRowMapper<>(mappedClass));\n\t\t\treturn query((RowMapper<T>) rowMapper);\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#query(rch)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rch"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "void",
    "signature": "public void query(RowCallbackHandler rch)",
    "source_code": "\t\tpublic void query(RowCallbackHandler rch) {\n\t\t\tif (useNamedParams()) {\n\t\t\t\tnamedParamOps.query(this.sql, this.namedParamSource, rch);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tclassicOps.query(statementCreatorForIndexedParams(), rch);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#query(rowMapper)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "MappedQuerySpec<T>",
    "signature": "public MappedQuerySpec<T> query(RowMapper<T> rowMapper)",
    "source_code": "\t\tpublic <T> MappedQuerySpec<T> query(RowMapper<T> rowMapper) {\n\t\t\treturn (useNamedParams() ?\n\t\t\t\t\tnew NamedParamMappedQuerySpec<>(rowMapper) :\n\t\t\t\t\tnew IndexedParamMappedQuerySpec<>(rowMapper));\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#query(rse)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rse"
    ],
    "position": {
      "column": 1,
      "line": 226
    },
    "return": "T",
    "signature": "public T query(ResultSetExtractor<T> rse)",
    "source_code": "\t\tpublic <T> T query(ResultSetExtractor<T> rse) {\n\t\t\tT result = (useNamedParams() ?\n\t\t\t\t\tnamedParamOps.query(this.sql, this.namedParamSource, rse) :\n\t\t\t\t\tclassicOps.query(statementCreatorForIndexedParams(), rse));\n\t\t\tAssert.state(result != null, \"No result from ResultSetExtractor\");\n\t\t\treturn result;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#rowSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 310
    },
    "return": "SqlRowSet",
    "signature": "public SqlRowSet rowSet()",
    "source_code": "\t\t\tpublic SqlRowSet rowSet() {\n\t\t\t\treturn namedParamOps.queryForRowSet(sql, namedParamSource);\n\t\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#singleColumn()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 325
    },
    "return": "List<Object>",
    "signature": "public List<Object> singleColumn()",
    "source_code": "\t\t\tpublic List<Object> singleColumn() {\n\t\t\t\treturn namedParamOps.queryForList(sql, namedParamSource, Object.class);\n\t\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#singleRow()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 320
    },
    "return": "Object>",
    "signature": "public Object> singleRow()",
    "source_code": "\t\t\tpublic Map<String, Object> singleRow() {\n\t\t\t\treturn namedParamOps.queryForMap(sql, namedParamSource);\n\t\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#sql(sql)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec sql(String sql)",
    "source_code": "\tpublic StatementSpec sql(String sql) {\n\t\treturn new DefaultStatementSpec(sql);\n\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#stream()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 360
    },
    "return": "Stream<T>",
    "signature": "public Stream<T> stream()",
    "source_code": "\t\t\tpublic Stream<T> stream() {\n\t\t\t\treturn namedParamOps.queryForStream(sql, namedParamSource, this.rowMapper);\n\t\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#update()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "int",
    "signature": "public int update()",
    "source_code": "\t\tpublic int update() {\n\t\t\treturn (useNamedParams() ?\n\t\t\t\t\tnamedParamOps.update(this.sql, this.namedParamSource) :\n\t\t\t\t\tclassicOps.update(statementCreatorForIndexedParams()));\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#update(generatedKeyHolder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generatedKeyHolder"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "int",
    "signature": "public int update(KeyHolder generatedKeyHolder)",
    "source_code": "\t\tpublic int update(KeyHolder generatedKeyHolder) {\n\t\t\treturn (useNamedParams() ?\n\t\t\t\t\tnamedParamOps.update(this.sql, this.namedParamSource, generatedKeyHolder) :\n\t\t\t\t\tclassicOps.update(statementCreatorForIndexedParamsWithKeys(null), generatedKeyHolder));\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#update(generatedKeyHolder,keyColumnNames)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generatedKeyHolder",
      "keyColumnNames"
    ],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "int",
    "signature": "public int update(KeyHolder generatedKeyHolder, String... keyColumnNames)",
    "source_code": "\t\tpublic int update(KeyHolder generatedKeyHolder, String... keyColumnNames) {\n\t\t\treturn (useNamedParams() ?\n\t\t\t\t\tnamedParamOps.update(this.sql, this.namedParamSource, generatedKeyHolder, keyColumnNames) :\n\t\t\t\t\tclassicOps.update(statementCreatorForIndexedParamsWithKeys(keyColumnNames), generatedKeyHolder));\n\t\t}"
  },
  "org.springframework.jdbc.core.support.SqlBinaryValue": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Object to represent a binary parameter value for a SQL statement, e.g.\n * a binary stream for a BLOB or a LONGVARBINARY or PostgreSQL BYTEA column.\n *\n * <p>Designed for use with {@link org.springframework.jdbc.core.JdbcTemplate}\n * as well as {@link org.springframework.jdbc.core.simple.JdbcClient}, to be\n * passed in as a parameter value wrapping the target content value. Can be\n * combined with {@link org.springframework.jdbc.core.SqlParameterValue} for\n * specifying a SQL type, e.g.\n * {@code new SqlParameterValue(Types.BLOB, new SqlBinaryValue(myContent))}.\n * With most database drivers, the type hint is not actually necessary.\n *\n * @author Juergen Hoeller\n * @since 6.1.4\n * @see SqlCharacterValue\n * @see org.springframework.jdbc.core.SqlParameterValue\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public class SqlBinaryValue",
    "source_code": "public class SqlBinaryValue implements SqlTypeValue {\n\n\tprivate final Object content;\n\n\tprivate final long length;\n\n\n\t/**\n\t * Create a new {@code SqlBinaryValue} for the given content.\n\t * @param bytes the content as a byte array\n\t */\n\tpublic SqlBinaryValue(byte[] bytes) {\n\t\tthis.content = bytes;\n\t\tthis.length = bytes.length;\n\t}\n\n\t/**\n\t * Create a new {@code SqlBinaryValue} for the given content.\n\t * @param stream the content stream\n\t * @param length the length of the content\n\t */\n\tpublic SqlBinaryValue(InputStream stream, long length) {\n\t\tthis.content = stream;\n\t\tthis.length = length;\n\t}\n\n\t/**\n\t * Create a new {@code SqlBinaryValue} for the given content.\n\t * <p>Consider specifying a {@link Resource} with content length support\n\t * when available: {@link SqlBinaryValue#SqlBinaryValue(Resource)}.\n\t * @param resource the resource to obtain a content stream from\n\t * @param length the length of the content\n\t */\n\tpublic SqlBinaryValue(InputStreamSource resource, long length) {\n\t\tthis.content = resource;\n\t\tthis.length = length;\n\t}\n\n\t/**\n\t * Create a new {@code SqlBinaryValue} for the given content.\n\t * <p>The length will get derived from {@link Resource#contentLength()}.\n\t * @param resource the resource to obtain a content stream from\n\t */\n\tpublic SqlBinaryValue(Resource resource) {\n\t\tthis.content = resource;\n\t\tthis.length = -1;\n\t}\n\n\n\t@Override\n\tpublic void setTypeValue(PreparedStatement ps, int paramIndex, int sqlType, @Nullable String typeName)\n\t\t\tthrows SQLException {\n\n\t\tif (this.content instanceof byte[] bytes) {\n\t\t\tsetByteArray(ps, paramIndex, sqlType, bytes);\n\t\t}\n\t\telse if (this.content instanceof InputStream inputStream) {\n\t\t\tsetInputStream(ps, paramIndex, sqlType, inputStream, this.length);\n\t\t}\n\t\telse if (this.content instanceof Resource resource) {\n\t\t\ttry {\n\t\t\t\tsetInputStream(ps, paramIndex, sqlType, resource.getInputStream(), resource.contentLength());\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new IllegalArgumentException(\"Cannot open binary stream for JDBC value: \" + resource, ex);\n\t\t\t}\n\t\t}\n\t\telse if (this.content instanceof InputStreamSource resource) {\n\t\t\ttry {\n\t\t\t\tsetInputStream(ps, paramIndex, sqlType, resource.getInputStream(), this.length);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new IllegalArgumentException(\"Cannot open binary stream for JDBC value: \" + resource, ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Illegal content type: \" + this.content.getClass().getName());\n\t\t}\n\t}\n\n\tprivate void setByteArray(PreparedStatement ps, int paramIndex, int sqlType, byte[] bytes)\n\t\t\tthrows SQLException {\n\n\t\tif (sqlType == Types.BLOB) {\n\t\t\tps.setBlob(paramIndex, new ByteArrayInputStream(bytes), bytes.length);\n\t\t}\n\t\telse {\n\t\t\tps.setBytes(paramIndex, bytes);\n\t\t}\n\t}\n\n\tprivate void setInputStream(PreparedStatement ps, int paramIndex, int sqlType, InputStream is, long length)\n\t\t\tthrows SQLException {\n\n\t\tif (sqlType == Types.BLOB) {\n\t\t\tps.setBlob(paramIndex, is, length);\n\t\t}\n\t\telse {\n\t\t\tps.setBinaryStream(paramIndex, is, length);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.jdbc.core.support.SqlBinaryValue#setTypeValue(ps,paramIndex,sqlType,typeName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "paramIndex",
      "sqlType",
      "typeName"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void setTypeValue(PreparedStatement ps, int paramIndex, int sqlType, @Nullable String typeName)",
    "source_code": "\tpublic void setTypeValue(PreparedStatement ps, int paramIndex, int sqlType, @Nullable String typeName)"
  },
  "org.springframework.jdbc.core.support.SqlCharacterValue": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Object to represent a character-based parameter value for a SQL statement,\n * e.g. a character stream for a CLOB/NCLOB or a LONGVARCHAR column.\n *\n * <p>Designed for use with {@link org.springframework.jdbc.core.JdbcTemplate}\n * as well as {@link org.springframework.jdbc.core.simple.JdbcClient}, to be\n * passed in as a parameter value wrapping the target content value. Can be\n * combined with {@link org.springframework.jdbc.core.SqlParameterValue} for\n * specifying a SQL type, e.g.\n * {@code new SqlParameterValue(Types.CLOB, new SqlCharacterValue(myContent))}.\n * With most database drivers, the type hint is not actually necessary.\n *\n * @author Juergen Hoeller\n * @since 6.1.4\n * @see SqlBinaryValue\n * @see org.springframework.jdbc.core.SqlParameterValue\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "signature": "public class SqlCharacterValue",
    "source_code": "public class SqlCharacterValue implements SqlTypeValue {\n\n\tprivate final Object content;\n\n\tprivate final long length;\n\n\n\t/**\n\t * Create a new CLOB value with the given content string.\n\t * @param string the content as a String or other CharSequence\n\t */\n\tpublic SqlCharacterValue(CharSequence string) {\n\t\tthis.content = string;\n\t\tthis.length = string.length();\n\t}\n\n\t/**\n\t * Create a new {@code SqlCharacterValue} for the given content.\n\t * @param characters the content as a character array\n\t */\n\tpublic SqlCharacterValue(char[] characters) {\n\t\tthis.content = characters;\n\t\tthis.length = characters.length;\n\t}\n\n\t/**\n\t * Create a new {@code SqlCharacterValue} for the given content.\n\t * @param reader the content reader\n\t * @param length the length of the content\n\t */\n\tpublic SqlCharacterValue(Reader reader, long length) {\n\t\tthis.content = reader;\n\t\tthis.length = length;\n\t}\n\n\t/**\n\t * Create a new {@code SqlCharacterValue} for the given content.\n\t * @param asciiStream the content as ASCII stream\n\t * @param length the length of the content\n\t */\n\tpublic SqlCharacterValue(InputStream asciiStream, long length) {\n\t\tthis.content = asciiStream;\n\t\tthis.length = length;\n\t}\n\n\n\t@Override\n\tpublic void setTypeValue(PreparedStatement ps, int paramIndex, int sqlType, @Nullable String typeName)\n\t\t\tthrows SQLException {\n\n\t\tif (this.content instanceof CharSequence) {\n\t\t\tsetString(ps, paramIndex, sqlType, this.content.toString());\n\t\t}\n\t\telse if (this.content instanceof char[] chars) {\n\t\t\tsetReader(ps, paramIndex, sqlType, new CharArrayReader(chars), this.length);\n\t\t}\n\t\telse if (this.content instanceof Reader reader) {\n\t\t\tsetReader(ps, paramIndex, sqlType, reader, this.length);\n\t\t}\n\t\telse if (this.content instanceof InputStream asciiStream) {\n\t\t\tps.setAsciiStream(paramIndex, asciiStream, this.length);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Illegal content type: \" + this.content.getClass().getName());\n\t\t}\n\t}\n\n\tprivate void setString(PreparedStatement ps, int paramIndex, int sqlType, String string)\n\t\t\tthrows SQLException {\n\n\t\tif (sqlType == Types.CLOB) {\n\t\t\tps.setClob(paramIndex, new StringReader(string), string.length());\n\t\t}\n\t\telse if (sqlType == Types.NCLOB) {\n\t\t\tps.setNClob(paramIndex, new StringReader(string), string.length());\n\t\t}\n\t\telse {\n\t\t\tps.setString(paramIndex, string);\n\t\t}\n\t}\n\n\tprivate void setReader(PreparedStatement ps, int paramIndex, int sqlType, Reader reader, long length)\n\t\t\tthrows SQLException {\n\n\t\tif (sqlType == Types.CLOB) {\n\t\t\tps.setClob(paramIndex, reader, length);\n\t\t}\n\t\telse if (sqlType == Types.NCLOB) {\n\t\t\tps.setNClob(paramIndex, reader, length);\n\t\t}\n\t\telse {\n\t\t\tps.setCharacterStream(paramIndex, reader, length);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.jdbc.core.support.SqlCharacterValue#setTypeValue(ps,paramIndex,sqlType,typeName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "paramIndex",
      "sqlType",
      "typeName"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "void",
    "signature": "public void setTypeValue(PreparedStatement ps, int paramIndex, int sqlType, @Nullable String typeName)",
    "source_code": "\tpublic void setTypeValue(PreparedStatement ps, int paramIndex, int sqlType, @Nullable String typeName)"
  },
  "org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Proxy for a target DataSource, fetching actual JDBC Connections lazily,\n * i.e. not until first creation of a Statement. Connection initialization\n * properties like auto-commit mode, transaction isolation and read-only mode\n * will be kept and applied to the actual JDBC Connection as soon as an actual\n * Connection is fetched (if ever). Consequently, commit and rollback calls will\n * be ignored if no Statements have been created. As of 6.1.2, there is also\n * special support for a {@link #setReadOnlyDataSource read-only DataSource} to use\n * during a read-only transaction, in addition to the regular target DataSource.\n *\n * <p>This DataSource proxy allows to avoid fetching JDBC Connections from\n * a pool unless actually necessary. JDBC transaction control can happen\n * without fetching a Connection from the pool or communicating with the\n * database; this will be done lazily on first creation of a JDBC Statement.\n * As a bonus, this allows for taking the transaction-synchronized read-only\n * flag and/or isolation level into account in a routing DataSource (e.g.\n * {@link org.springframework.jdbc.datasource.lookup.IsolationLevelDataSourceRouter}).\n *\n * <p><b>If you configure both a LazyConnectionDataSourceProxy and a\n * TransactionAwareDataSourceProxy, make sure that the latter is the outermost\n * DataSource.</b> In such a scenario, data access code will talk to the\n * transaction-aware DataSource, which will in turn work with the\n * LazyConnectionDataSourceProxy. As of 6.1.2, LazyConnectionDataSourceProxy will\n * initialize its default connection characteristics on first Connection access;\n * to enforce this on startup, call {@link #checkDefaultConnectionProperties()}.\n *\n * <p>Lazy fetching of physical JDBC Connections is particularly beneficial\n * in a generic transaction demarcation environment. It allows you to demarcate\n * transactions on all methods that could potentially perform data access,\n * without paying a performance penalty if no actual data access happens.\n *\n * <p>This DataSource proxy gives you behavior analogous to JTA and a\n * transactional JNDI DataSource (as provided by the Jakarta EE server), even\n * with a local transaction strategy like DataSourceTransactionManager or\n * HibernateTransactionManager. It does not add value with Spring's\n * JtaTransactionManager as transaction strategy.\n *\n * <p>Lazy fetching of JDBC Connections is also recommended for read-only\n * operations with Hibernate, in particular if the chances of resolving the\n * result in the second-level cache are high. This avoids the need to\n * communicate with the database at all for such read-only operations.\n * You will get the same effect with non-transactional reads, but lazy fetching\n * of JDBC Connections allows you to still perform reads in transactions.\n *\n * <p><b>NOTE:</b> This DataSource proxy needs to return wrapped Connections\n * (which implement the {@link ConnectionProxy} interface) in order to handle\n * lazy fetching of an actual JDBC Connection. Use {@link Connection#unwrap}\n * to retrieve the native JDBC Connection.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 1.1.4\n * @see DataSourceTransactionManager\n * @see #setTargetDataSource\n * @see #setReadOnlyDataSource\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "signature": "public class LazyConnectionDataSourceProxy",
    "source_code": "public class LazyConnectionDataSourceProxy extends DelegatingDataSource {\n\n\t/**\n\t * Map of constant names to constant values for the isolation constants\n\t * defined in {@link java.sql.Connection}.\n\t */\n\tstatic final Map<String, Integer> constants = Map.of(\n\t\t\t\"TRANSACTION_READ_UNCOMMITTED\", Connection.TRANSACTION_READ_UNCOMMITTED,\n\t\t\t\"TRANSACTION_READ_COMMITTED\", Connection.TRANSACTION_READ_COMMITTED,\n\t\t\t\"TRANSACTION_REPEATABLE_READ\", Connection.TRANSACTION_REPEATABLE_READ,\n\t\t\t\"TRANSACTION_SERIALIZABLE\", Connection.TRANSACTION_SERIALIZABLE\n\t\t);\n\n\tprivate static final Log logger = LogFactory.getLog(LazyConnectionDataSourceProxy.class);\n\n\t@Nullable\n\tprivate DataSource readOnlyDataSource;\n\n\t@Nullable\n\tprivate volatile Boolean defaultAutoCommit;\n\n\t@Nullable\n\tprivate volatile Integer defaultTransactionIsolation;\n\n\n\t/**\n\t * Create a new LazyConnectionDataSourceProxy.\n\t * @see #setTargetDataSource\n\t * @see #setReadOnlyDataSource\n\t */\n\tpublic LazyConnectionDataSourceProxy() {\n\t}\n\n\t/**\n\t * Create a new LazyConnectionDataSourceProxy.\n\t * @param targetDataSource the target DataSource\n\t * @see #setTargetDataSource\n\t */\n\tpublic LazyConnectionDataSourceProxy(DataSource targetDataSource) {\n\t\tsetTargetDataSource(targetDataSource);\n\t\tafterPropertiesSet();\n\t}\n\n\n\t/**\n\t * Specify a variant of the target DataSource to use for read-only transactions.\n\t * <p>If available, a Connection from such a read-only DataSource will be lazily\n\t * obtained within a Spring-managed transaction that has been marked as read-only.\n\t * The {@link Connection#setReadOnly} flag will be left untouched, expecting it\n\t * to be pre-configured as a default on the read-only DataSource, avoiding the\n\t * overhead of switching it at the beginning and end of every transaction.\n\t * Also, the default auto-commit and isolation level settings are expected to\n\t * match the default connection properties of the primary target DataSource.\n\t * @since 6.1.2\n\t * @see #setTargetDataSource\n\t * @see #setDefaultAutoCommit\n\t * @see #setDefaultTransactionIsolation\n\t * @see org.springframework.transaction.TransactionDefinition#isReadOnly()\n\t */\n\tpublic void setReadOnlyDataSource(@Nullable DataSource readOnlyDataSource) {\n\t\tthis.readOnlyDataSource = readOnlyDataSource;\n\t}\n\n\t/**\n\t * Set the default auto-commit mode to expose when no target Connection\n\t * has been fetched yet (when the actual JDBC Connection default is not known yet).\n\t * <p>If not specified, the default gets determined by checking lazily on first\n\t * access of a Connection.\n\t * @see java.sql.Connection#setAutoCommit\n\t */\n\tpublic void setDefaultAutoCommit(boolean defaultAutoCommit) {\n\t\tthis.defaultAutoCommit = defaultAutoCommit;\n\t}\n\n\t/**\n\t * Set the default transaction isolation level by the name of the corresponding\n\t * constant in {@link java.sql.Connection} &mdash; for example,\n\t * {@code \"TRANSACTION_SERIALIZABLE\"}.\n\t * @param constantName name of the constant\n\t * @see #setDefaultTransactionIsolation\n\t * @see java.sql.Connection#TRANSACTION_READ_UNCOMMITTED\n\t * @see java.sql.Connection#TRANSACTION_READ_COMMITTED\n\t * @see java.sql.Connection#TRANSACTION_REPEATABLE_READ\n\t * @see java.sql.Connection#TRANSACTION_SERIALIZABLE\n\t */\n\tpublic void setDefaultTransactionIsolationName(String constantName) {\n\t\tAssert.hasText(constantName, \"'constantName' must not be null or blank\");\n\t\tInteger defaultTransactionIsolation = constants.get(constantName);\n\t\tAssert.notNull(defaultTransactionIsolation, \"Only transaction isolation constants allowed\");\n\t\tthis.defaultTransactionIsolation = defaultTransactionIsolation;\n\t}\n\n\t/**\n\t * Set the default transaction isolation level to expose when no target Connection\n\t * has been fetched yet (when the actual JDBC Connection default is not known yet).\n\t * <p>This property accepts the int constant value (e.g. 8) as defined in the\n\t * {@link java.sql.Connection} interface; it is mainly intended for programmatic\n\t * use. Consider using the \"defaultTransactionIsolationName\" property for setting\n\t * the value by name (for example, {@code \"TRANSACTION_SERIALIZABLE\"}).\n\t * <p>If not specified, the default gets determined by checking lazily on first\n\t * access of a Connection.\n\t * @see #setDefaultTransactionIsolationName\n\t * @see java.sql.Connection#setTransactionIsolation\n\t */\n\tpublic void setDefaultTransactionIsolation(int defaultTransactionIsolation) {\n\t\tAssert.isTrue(constants.containsValue(defaultTransactionIsolation),\n\t\t\t\t\"Only values of transaction isolation constants allowed\");\n\t\tthis.defaultTransactionIsolation = defaultTransactionIsolation;\n\t}\n\n\n\t/**\n\t * Determine default auto-commit and transaction isolation\n\t * via a Connection from the target DataSource, if possible.\n\t * @since 6.1.2\n\t * @see #checkDefaultConnectionProperties(Connection)\n\t */\n\tpublic void checkDefaultConnectionProperties() {\n\t\tif (this.defaultAutoCommit == null || this.defaultTransactionIsolation == null) {\n\t\t\ttry {\n\t\t\t\ttry (Connection con = obtainTargetDataSource().getConnection()) {\n\t\t\t\t\tcheckDefaultConnectionProperties(con);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (SQLException ex) {\n\t\t\t\tlogger.debug(\"Could not retrieve default auto-commit and transaction isolation settings\", ex);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Check the default connection properties (auto-commit, transaction isolation),\n\t * keeping them to be able to expose them correctly without fetching an actual\n\t * JDBC Connection from the target DataSource later on.\n\t * @param con the Connection to use for checking\n\t * @throws SQLException if thrown by Connection methods\n\t */\n\tprotected void checkDefaultConnectionProperties(Connection con) throws SQLException {\n\t\tif (this.defaultAutoCommit == null) {\n\t\t\tthis.defaultAutoCommit = con.getAutoCommit();\n\t\t}\n\t\tif (this.defaultTransactionIsolation == null) {\n\t\t\tthis.defaultTransactionIsolation = con.getTransactionIsolation();\n\t\t}\n\t}\n\n\t/**\n\t * Expose the default auto-commit value.\n\t */\n\t@Nullable\n\tprotected Boolean defaultAutoCommit() {\n\t\treturn this.defaultAutoCommit;\n\t}\n\n\t/**\n\t * Expose the default transaction isolation value.\n\t */\n\t@Nullable\n\tprotected Integer defaultTransactionIsolation() {\n\t\treturn this.defaultTransactionIsolation;\n\t}\n\n\n\t/**\n\t * Return a Connection handle that lazily fetches an actual JDBC Connection\n\t * when asked for a Statement (or PreparedStatement or CallableStatement).\n\t * <p>The returned Connection handle implements the ConnectionProxy interface,\n\t * allowing to retrieve the underlying target Connection.\n\t * @return a lazy Connection handle\n\t * @see ConnectionProxy#getTargetConnection()\n\t */\n\t@Override\n\tpublic Connection getConnection() throws SQLException {\n\t\tcheckDefaultConnectionProperties();\n\t\treturn (Connection) Proxy.newProxyInstance(\n\t\t\t\tConnectionProxy.class.getClassLoader(),\n\t\t\t\tnew Class<?>[] {ConnectionProxy.class},\n\t\t\t\tnew LazyConnectionInvocationHandler());\n\t}\n\n\t/**\n\t * Return a Connection handle that lazily fetches an actual JDBC Connection\n\t * when asked for a Statement (or PreparedStatement or CallableStatement).\n\t * <p>The returned Connection handle implements the ConnectionProxy interface,\n\t * allowing to retrieve the underlying target Connection.\n\t * @param username the per-Connection username\n\t * @param password the per-Connection password\n\t * @return a lazy Connection handle\n\t * @see ConnectionProxy#getTargetConnection()\n\t */\n\t@Override\n\tpublic Connection getConnection(String username, String password) throws SQLException {\n\t\tcheckDefaultConnectionProperties();\n\t\treturn (Connection) Proxy.newProxyInstance(\n\t\t\t\tConnectionProxy.class.getClassLoader(),\n\t\t\t\tnew Class<?>[] {ConnectionProxy.class},\n\t\t\t\tnew LazyConnectionInvocationHandler(username, password));\n\t}\n\n\n\t/**\n\t * Invocation handler that defers fetching an actual JDBC Connection\n\t * until first creation of a Statement.\n\t */\n\tprivate class LazyConnectionInvocationHandler implements InvocationHandler {\n\n\t\t@Nullable\n\t\tprivate String username;\n\n\t\t@Nullable\n\t\tprivate String password;\n\n\t\t@Nullable\n\t\tprivate Boolean autoCommit;\n\n\t\t@Nullable\n\t\tprivate Integer transactionIsolation;\n\n\t\tprivate boolean readOnly = false;\n\n\t\tprivate int holdability = ResultSet.CLOSE_CURSORS_AT_COMMIT;\n\n\t\tprivate boolean closed = false;\n\n\t\t@Nullable\n\t\tprivate Connection target;\n\n\t\tpublic LazyConnectionInvocationHandler() {\n\t\t\tthis.autoCommit = defaultAutoCommit();\n\t\t\tthis.transactionIsolation = defaultTransactionIsolation();\n\t\t}\n\n\t\tpublic LazyConnectionInvocationHandler(String username, String password) {\n\t\t\tthis();\n\t\t\tthis.username = username;\n\t\t\tthis.password = password;\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\t// Invocation on ConnectionProxy interface coming in...\n\n\t\t\tswitch (method.getName()) {\n\t\t\t\tcase \"equals\" -> {\n\t\t\t\t\t// We must avoid fetching a target Connection for \"equals\".\n\t\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\t\treturn (proxy == args[0]);\n\t\t\t\t}\n\t\t\t\tcase \"hashCode\" -> {\n\t\t\t\t\t// We must avoid fetching a target Connection for \"hashCode\",\n\t\t\t\t\t// and we must return the same hash code even when the target\n\t\t\t\t\t// Connection has been fetched: use hashCode of Connection proxy.\n\t\t\t\t\treturn System.identityHashCode(proxy);\n\t\t\t\t}\n\t\t\t\tcase \"getTargetConnection\" -> {\n\t\t\t\t\t// Handle getTargetConnection method: return underlying connection.\n\t\t\t\t\treturn getTargetConnection(method);\n\t\t\t\t}\n\t\t\t\tcase \"unwrap\" -> {\n\t\t\t\t\tif (((Class<?>) args[0]).isInstance(proxy)) {\n\t\t\t\t\t\treturn proxy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcase \"isWrapperFor\" -> {\n\t\t\t\t\tif (((Class<?>) args[0]).isInstance(proxy)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!hasTargetConnection()) {\n\t\t\t\t// No physical target Connection kept yet ->\n\t\t\t\t// resolve transaction demarcation methods without fetching\n\t\t\t\t// a physical JDBC Connection until absolutely necessary.\n\n\t\t\t\tswitch (method.getName()) {\n\t\t\t\t\tcase \"toString\" -> {\n\t\t\t\t\t\treturn \"Lazy Connection proxy for target DataSource [\" + getTargetDataSource() + \"]\";\n\t\t\t\t\t}\n\t\t\t\t\tcase \"getAutoCommit\" -> {\n\t\t\t\t\t\tif (this.autoCommit != null) {\n\t\t\t\t\t\t\treturn this.autoCommit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Else fetch actual Connection and check there,\n\t\t\t\t\t\t// because we didn't have a default specified.\n\t\t\t\t\t}\n\t\t\t\t\tcase \"setAutoCommit\" -> {\n\t\t\t\t\t\tthis.autoCommit = (Boolean) args[0];\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"getTransactionIsolation\" -> {\n\t\t\t\t\t\tif (this.transactionIsolation != null) {\n\t\t\t\t\t\t\treturn this.transactionIsolation;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Else fetch actual Connection and check there,\n\t\t\t\t\t\t// because we didn't have a default specified.\n\t\t\t\t\t}\n\t\t\t\t\tcase \"setTransactionIsolation\" -> {\n\t\t\t\t\t\tthis.transactionIsolation = (Integer) args[0];\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"isReadOnly\" -> {\n\t\t\t\t\t\treturn this.readOnly;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"setReadOnly\" -> {\n\t\t\t\t\t\tthis.readOnly = (Boolean) args[0];\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"getHoldability\" -> {\n\t\t\t\t\t\treturn this.holdability;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"setHoldability\" -> {\n\t\t\t\t\t\tthis.holdability = (Integer) args[0];\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"commit\", \"rollback\" -> {\n\t\t\t\t\t\t// Ignore: no statements created yet.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"getWarnings\", \"clearWarnings\" -> {\n\t\t\t\t\t\t// Ignore: no warnings to expose yet.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"close\" -> {\n\t\t\t\t\t\t// Ignore: no target connection yet.\n\t\t\t\t\t\tthis.closed = true;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"isClosed\" -> {\n\t\t\t\t\t\treturn this.closed;\n\t\t\t\t\t}\n\t\t\t\t\tdefault -> {\n\t\t\t\t\t\tif (this.closed) {\n\t\t\t\t\t\t\t// Connection proxy closed, without ever having fetched a\n\t\t\t\t\t\t\t// physical JDBC Connection: throw corresponding SQLException.\n\t\t\t\t\t\t\tthrow new SQLException(\"Illegal operation: connection is closed\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (readOnlyDataSource != null && \"setReadOnly\".equals(method.getName())) {\n\t\t\t\t// Suppress setReadOnly reset call in case of dedicated read-only DataSource\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Target Connection already fetched,\n\t\t\t// or target Connection necessary for current operation ->\n\t\t\t// invoke method on target connection.\n\t\t\ttry {\n\t\t\t\treturn method.invoke(getTargetConnection(method), args);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow ex.getTargetException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Return whether the proxy currently holds a target Connection.\n\t\t */\n\t\tprivate boolean hasTargetConnection() {\n\t\t\treturn (this.target != null);\n\t\t}\n\n\t\t/**\n\t\t * Return the target Connection, fetching it and initializing it if necessary.\n\t\t */\n\t\tprivate Connection getTargetConnection(Method operation) throws SQLException {\n\t\t\tif (this.target == null) {\n\t\t\t\t// No target Connection held -> fetch one.\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Connecting to database for operation '\" + operation.getName() + \"'\");\n\t\t\t\t}\n\n\t\t\t\t// Fetch physical Connection from DataSource.\n\t\t\t\tDataSource dataSource = getDataSourceToUse();\n\t\t\t\tthis.target = (this.username != null ? dataSource.getConnection(this.username, this.password) :\n\t\t\t\t\t\tdataSource.getConnection());\n\t\t\t\tif (this.target == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"DataSource returned null from getConnection(): \" + dataSource);\n\t\t\t\t}\n\n\t\t\t\t// Apply kept transaction settings, if any.\n\t\t\t\tif (this.readOnly && readOnlyDataSource == null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.target.setReadOnly(true);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t// \"read-only not supported\" -> ignore, it's just a hint anyway\n\t\t\t\t\t\tlogger.debug(\"Could not set JDBC Connection read-only\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this.transactionIsolation != null &&\n\t\t\t\t\t\t!this.transactionIsolation.equals(defaultTransactionIsolation())) {\n\t\t\t\t\tthis.target.setTransactionIsolation(this.transactionIsolation);\n\t\t\t\t}\n\t\t\t\tif (this.autoCommit != null && this.autoCommit != defaultAutoCommit()) {\n\t\t\t\t\tthis.target.setAutoCommit(this.autoCommit);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\t// Target Connection already held -> return it.\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Using existing database connection for operation '\" + operation.getName() + \"'\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this.target;\n\t\t}\n\n\t\tprivate DataSource getDataSourceToUse() {\n\t\t\treturn (this.readOnly && readOnlyDataSource != null ? readOnlyDataSource : obtainTargetDataSource());\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy#checkDefaultConnectionProperties()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine default auto-commit and transaction isolation\n\t * via a Connection from the target DataSource, if possible.\n\t * @since 6.1.2\n\t * @see #checkDefaultConnectionProperties(Connection)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "void",
    "signature": "public void checkDefaultConnectionProperties()",
    "source_code": "\tpublic void checkDefaultConnectionProperties() {\n\t\tif (this.defaultAutoCommit == null || this.defaultTransactionIsolation == null) {\n\t\t\ttry {\n\t\t\t\ttry (Connection con = obtainTargetDataSource().getConnection()) {\n\t\t\t\t\tcheckDefaultConnectionProperties(con);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (SQLException ex) {\n\t\t\t\tlogger.debug(\"Could not retrieve default auto-commit and transaction isolation settings\", ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy#checkDefaultConnectionProperties(con)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check the default connection properties (auto-commit, transaction isolation),\n\t * keeping them to be able to expose them correctly without fetching an actual\n\t * JDBC Connection from the target DataSource later on.\n\t * @param con the Connection to use for checking\n\t * @throws SQLException if thrown by Connection methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "con"
    ],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "void",
    "signature": "protected void checkDefaultConnectionProperties(Connection con)",
    "source_code": "\tprotected void checkDefaultConnectionProperties(Connection con) throws SQLException {\n\t\tif (this.defaultAutoCommit == null) {\n\t\t\tthis.defaultAutoCommit = con.getAutoCommit();\n\t\t}\n\t\tif (this.defaultTransactionIsolation == null) {\n\t\t\tthis.defaultTransactionIsolation = con.getTransactionIsolation();\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy#defaultAutoCommit()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Expose the default auto-commit value.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "Boolean",
    "signature": "protected Boolean defaultAutoCommit()",
    "source_code": "\tprotected Boolean defaultAutoCommit() {\n\t\treturn this.defaultAutoCommit;\n\t}"
  },
  "org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy#defaultTransactionIsolation()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Expose the default transaction isolation value.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 250
    },
    "return": "Integer",
    "signature": "protected Integer defaultTransactionIsolation()",
    "source_code": "\tprotected Integer defaultTransactionIsolation() {\n\t\treturn this.defaultTransactionIsolation;\n\t}"
  },
  "org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy#getConnection()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a Connection handle that lazily fetches an actual JDBC Connection\n\t * when asked for a Statement (or PreparedStatement or CallableStatement).\n\t * <p>The returned Connection handle implements the ConnectionProxy interface,\n\t * allowing to retrieve the underlying target Connection.\n\t * @return a lazy Connection handle\n\t * @see ConnectionProxy#getTargetConnection()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "Connection",
    "signature": "public Connection getConnection()",
    "source_code": "\tpublic Connection getConnection() throws SQLException {\n\t\tcheckDefaultConnectionProperties();\n\t\treturn (Connection) Proxy.newProxyInstance(\n\t\t\t\tConnectionProxy.class.getClassLoader(),\n\t\t\t\tnew Class<?>[] {ConnectionProxy.class},\n\t\t\t\tnew LazyConnectionInvocationHandler());\n\t}"
  },
  "org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy#getConnection(username,password)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a Connection handle that lazily fetches an actual JDBC Connection\n\t * when asked for a Statement (or PreparedStatement or CallableStatement).\n\t * <p>The returned Connection handle implements the ConnectionProxy interface,\n\t * allowing to retrieve the underlying target Connection.\n\t * @param username the per-Connection username\n\t * @param password the per-Connection password\n\t * @return a lazy Connection handle\n\t * @see ConnectionProxy#getTargetConnection()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 283
    },
    "return": "Connection",
    "signature": "public Connection getConnection(String username, String password)",
    "source_code": "\tpublic Connection getConnection(String username, String password) throws SQLException {\n\t\tcheckDefaultConnectionProperties();\n\t\treturn (Connection) Proxy.newProxyInstance(\n\t\t\t\tConnectionProxy.class.getClassLoader(),\n\t\t\t\tnew Class<?>[] {ConnectionProxy.class},\n\t\t\t\tnew LazyConnectionInvocationHandler(username, password));\n\t}"
  },
  "org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy#invoke(proxy,method,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 332
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\t// Invocation on ConnectionProxy interface coming in...\n\n\t\t\tswitch (method.getName()) {\n\t\t\t\tcase \"equals\" -> {\n\t\t\t\t\t// We must avoid fetching a target Connection for \"equals\".\n\t\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\t\treturn (proxy == args[0]);\n\t\t\t\t}\n\t\t\t\tcase \"hashCode\" -> {\n\t\t\t\t\t// We must avoid fetching a target Connection for \"hashCode\",\n\t\t\t\t\t// and we must return the same hash code even when the target\n\t\t\t\t\t// Connection has been fetched: use hashCode of Connection proxy.\n\t\t\t\t\treturn System.identityHashCode(proxy);\n\t\t\t\t}\n\t\t\t\tcase \"getTargetConnection\" -> {\n\t\t\t\t\t// Handle getTargetConnection method: return underlying connection.\n\t\t\t\t\treturn getTargetConnection(method);\n\t\t\t\t}\n\t\t\t\tcase \"unwrap\" -> {\n\t\t\t\t\tif (((Class<?>) args[0]).isInstance(proxy)) {\n\t\t\t\t\t\treturn proxy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcase \"isWrapperFor\" -> {\n\t\t\t\t\tif (((Class<?>) args[0]).isInstance(proxy)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!hasTargetConnection()) {\n\t\t\t\t// No physical target Connection kept yet ->\n\t\t\t\t// resolve transaction demarcation methods without fetching\n\t\t\t\t// a physical JDBC Connection until absolutely necessary.\n\n\t\t\t\tswitch (method.getName()) {\n\t\t\t\t\tcase \"toString\" -> {\n\t\t\t\t\t\treturn \"Lazy Connection proxy for target DataSource [\" + getTargetDataSource() + \"]\";\n\t\t\t\t\t}\n\t\t\t\t\tcase \"getAutoCommit\" -> {\n\t\t\t\t\t\tif (this.autoCommit != null) {\n\t\t\t\t\t\t\treturn this.autoCommit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Else fetch actual Connection and check there,\n\t\t\t\t\t\t// because we didn't have a default specified.\n\t\t\t\t\t}\n\t\t\t\t\tcase \"setAutoCommit\" -> {\n\t\t\t\t\t\tthis.autoCommit = (Boolean) args[0];\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"getTransactionIsolation\" -> {\n\t\t\t\t\t\tif (this.transactionIsolation != null) {\n\t\t\t\t\t\t\treturn this.transactionIsolation;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Else fetch actual Connection and check there,\n\t\t\t\t\t\t// because we didn't have a default specified.\n\t\t\t\t\t}\n\t\t\t\t\tcase \"setTransactionIsolation\" -> {\n\t\t\t\t\t\tthis.transactionIsolation = (Integer) args[0];\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"isReadOnly\" -> {\n\t\t\t\t\t\treturn this.readOnly;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"setReadOnly\" -> {\n\t\t\t\t\t\tthis.readOnly = (Boolean) args[0];\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"getHoldability\" -> {\n\t\t\t\t\t\treturn this.holdability;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"setHoldability\" -> {\n\t\t\t\t\t\tthis.holdability = (Integer) args[0];\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"commit\", \"rollback\" -> {\n\t\t\t\t\t\t// Ignore: no statements created yet.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"getWarnings\", \"clearWarnings\" -> {\n\t\t\t\t\t\t// Ignore: no warnings to expose yet.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"close\" -> {\n\t\t\t\t\t\t// Ignore: no target connection yet.\n\t\t\t\t\t\tthis.closed = true;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"isClosed\" -> {\n\t\t\t\t\t\treturn this.closed;\n\t\t\t\t\t}\n\t\t\t\t\tdefault -> {\n\t\t\t\t\t\tif (this.closed) {\n\t\t\t\t\t\t\t// Connection proxy closed, without ever having fetched a\n\t\t\t\t\t\t\t// physical JDBC Connection: throw corresponding SQLException.\n\t\t\t\t\t\t\tthrow new SQLException(\"Illegal operation: connection is closed\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (readOnlyDataSource != null && \"setReadOnly\".equals(method.getName())) {\n\t\t\t\t// Suppress setReadOnly reset call in case of dedicated read-only DataSource\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Target Connection already fetched,\n\t\t\t// or target Connection necessary for current operation ->\n\t\t\t// invoke method on target connection.\n\t\t\ttry {\n\t\t\t\treturn method.invoke(getTargetConnection(method), args);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow ex.getTargetException();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy#setDefaultAutoCommit(defaultAutoCommit)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the default auto-commit mode to expose when no target Connection\n\t * has been fetched yet (when the actual JDBC Connection default is not known yet).\n\t * <p>If not specified, the default gets determined by checking lazily on first\n\t * access of a Connection.\n\t * @see java.sql.Connection#setAutoCommit\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultAutoCommit"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "void",
    "signature": "public void setDefaultAutoCommit(boolean defaultAutoCommit)",
    "source_code": "\tpublic void setDefaultAutoCommit(boolean defaultAutoCommit) {\n\t\tthis.defaultAutoCommit = defaultAutoCommit;\n\t}"
  },
  "org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy#setDefaultTransactionIsolation(defaultTransactionIsolation)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the default transaction isolation level to expose when no target Connection\n\t * has been fetched yet (when the actual JDBC Connection default is not known yet).\n\t * <p>This property accepts the int constant value (e.g. 8) as defined in the\n\t * {@link java.sql.Connection} interface; it is mainly intended for programmatic\n\t * use. Consider using the \"defaultTransactionIsolationName\" property for setting\n\t * the value by name (for example, {@code \"TRANSACTION_SERIALIZABLE\"}).\n\t * <p>If not specified, the default gets determined by checking lazily on first\n\t * access of a Connection.\n\t * @see #setDefaultTransactionIsolationName\n\t * @see java.sql.Connection#setTransactionIsolation\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultTransactionIsolation"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "void",
    "signature": "public void setDefaultTransactionIsolation(int defaultTransactionIsolation)",
    "source_code": "\tpublic void setDefaultTransactionIsolation(int defaultTransactionIsolation) {\n\t\tAssert.isTrue(constants.containsValue(defaultTransactionIsolation),\n\t\t\t\t\"Only values of transaction isolation constants allowed\");\n\t\tthis.defaultTransactionIsolation = defaultTransactionIsolation;\n\t}"
  },
  "org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy#setDefaultTransactionIsolationName(constantName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the default transaction isolation level by the name of the corresponding\n\t * constant in {@link java.sql.Connection} &mdash; for example,\n\t * {@code \"TRANSACTION_SERIALIZABLE\"}.\n\t * @param constantName name of the constant\n\t * @see #setDefaultTransactionIsolation\n\t * @see java.sql.Connection#TRANSACTION_READ_UNCOMMITTED\n\t * @see java.sql.Connection#TRANSACTION_READ_COMMITTED\n\t * @see java.sql.Connection#TRANSACTION_REPEATABLE_READ\n\t * @see java.sql.Connection#TRANSACTION_SERIALIZABLE\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "constantName"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "void",
    "signature": "public void setDefaultTransactionIsolationName(String constantName)",
    "source_code": "\tpublic void setDefaultTransactionIsolationName(String constantName) {\n\t\tAssert.hasText(constantName, \"'constantName' must not be null or blank\");\n\t\tInteger defaultTransactionIsolation = constants.get(constantName);\n\t\tAssert.notNull(defaultTransactionIsolation, \"Only transaction isolation constants allowed\");\n\t\tthis.defaultTransactionIsolation = defaultTransactionIsolation;\n\t}"
  },
  "org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy#setReadOnlyDataSource(readOnlyDataSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify a variant of the target DataSource to use for read-only transactions.\n\t * <p>If available, a Connection from such a read-only DataSource will be lazily\n\t * obtained within a Spring-managed transaction that has been marked as read-only.\n\t * The {@link Connection#setReadOnly} flag will be left untouched, expecting it\n\t * to be pre-configured as a default on the read-only DataSource, avoiding the\n\t * overhead of switching it at the beginning and end of every transaction.\n\t * Also, the default auto-commit and isolation level settings are expected to\n\t * match the default connection properties of the primary target DataSource.\n\t * @since 6.1.2\n\t * @see #setTargetDataSource\n\t * @see #setDefaultAutoCommit\n\t * @see #setDefaultTransactionIsolation\n\t * @see org.springframework.transaction.TransactionDefinition#isReadOnly()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "readOnlyDataSource"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "void",
    "signature": "public void setReadOnlyDataSource(@Nullable DataSource readOnlyDataSource)",
    "source_code": "\tpublic void setReadOnlyDataSource(@Nullable DataSource readOnlyDataSource) {\n\t\tthis.readOnlyDataSource = readOnlyDataSource;\n\t}"
  },
  "org.springframework.jdbc.datasource.SingleConnectionDataSource": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Implementation of {@link SmartDataSource} that wraps a single JDBC Connection\n * which is not closed after use. Obviously, this is not multi-threading capable.\n *\n * <p>Note that at shutdown, someone should close the underlying Connection\n * via the {@code close()} method. Client code will never call close\n * on the Connection handle if it is SmartDataSource-aware (e.g. uses\n * {@code DataSourceUtils.releaseConnection}).\n *\n * <p>If client code will call {@code close()} in the assumption of a pooled\n * Connection, like when using persistence tools, set \"suppressClose\" to \"true\".\n * This will return a close-suppressing proxy instead of the physical Connection.\n *\n * <p>This is primarily intended for testing. For example, it enables easy testing\n * outside an application server, for code that expects to work on a DataSource.\n * In contrast to {@link DriverManagerDataSource}, it reuses the same Connection\n * all the time, avoiding excessive creation of physical Connections.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @see #getConnection()\n * @see java.sql.Connection#close()\n * @see DataSourceUtils#releaseConnection\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "signature": "public class SingleConnectionDataSource",
    "source_code": "public class SingleConnectionDataSource extends DriverManagerDataSource"
  },
  "org.springframework.jdbc.datasource.SingleConnectionDataSource#close()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Close the underlying Connection.\n\t * The provider of this DataSource needs to care for proper shutdown.\n\t * <p>As this class implements {@link AutoCloseable}, it can be used\n\t * with a try-with-resource statement.\n\t * @since 6.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\tpublic void close() {\n\t\tdestroy();\n\t}"
  },
  "org.springframework.jdbc.datasource.SingleConnectionDataSource#closeConnection(con)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Close the underlying shared Connection.\n\t * @since 6.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "con"
    ],
    "position": {
      "column": 1,
      "line": 303
    },
    "return": "void",
    "signature": "protected void closeConnection(Connection con)",
    "source_code": "\tprotected void closeConnection(Connection con) {\n\t\tif (isRollbackBeforeClose()) {\n\t\t\ttry {\n\t\t\t\tif (!con.getAutoCommit()) {\n\t\t\t\t\tcon.rollback();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tlogger.info(\"Could not roll back shared JDBC Connection before close\", ex);\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tcon.close();\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tlogger.info(\"Could not close shared JDBC Connection\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.SingleConnectionDataSource#destroy()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Close the underlying Connection.\n\t * The provider of this DataSource needs to care for proper shutdown.\n\t * <p>As this bean implements {@link DisposableBean}, a bean factory\n\t * will automatically invoke this on destruction of the bean.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "void",
    "signature": "public void destroy()",
    "source_code": "\tpublic void destroy() {\n\t\tsynchronized (this.connectionMonitor) {\n\t\t\tif (this.target != null) {\n\t\t\t\tcloseConnection(this.target);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.SingleConnectionDataSource#getAutoCommitValue()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether the returned Connection's \"autoCommit\" setting should be overridden.\n\t * @return the \"autoCommit\" value, or {@code null} if none to be applied\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "Boolean",
    "signature": "protected Boolean getAutoCommitValue()",
    "source_code": "\tprotected Boolean getAutoCommitValue() {\n\t\treturn this.autoCommit;\n\t}"
  },
  "org.springframework.jdbc.datasource.SingleConnectionDataSource#getCloseSuppressingConnectionProxy(target)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Wrap the given Connection with a proxy that delegates every method call to it\n\t * but suppresses close calls.\n\t * @param target the original Connection to wrap\n\t * @return the wrapped Connection\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target"
    ],
    "position": {
      "column": 1,
      "line": 328
    },
    "return": "Connection",
    "signature": "protected Connection getCloseSuppressingConnectionProxy(Connection target)",
    "source_code": "\tprotected Connection getCloseSuppressingConnectionProxy(Connection target) {\n\t\treturn (Connection) Proxy.newProxyInstance(\n\t\t\t\tConnectionProxy.class.getClassLoader(),\n\t\t\t\tnew Class<?>[] {ConnectionProxy.class},\n\t\t\t\tnew CloseSuppressingInvocationHandler(target));\n\t}"
  },
  "org.springframework.jdbc.datasource.SingleConnectionDataSource#getConnection()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "Connection",
    "signature": "public Connection getConnection()",
    "source_code": "\tpublic Connection getConnection() throws SQLException {\n\t\tsynchronized (this.connectionMonitor) {\n\t\t\tif (this.connection == null) {\n\t\t\t\t// No underlying Connection -> lazy init via DriverManager.\n\t\t\t\tinitConnection();\n\t\t\t}\n\t\t\tif (this.connection.isClosed()) {\n\t\t\t\tthrow new SQLException(\n\t\t\t\t\t\t\"Connection was closed in SingleConnectionDataSource. Check that user code checks \" +\n\t\t\t\t\t\t\"shouldClose() before closing Connections, or set 'suppressClose' to 'true'\");\n\t\t\t}\n\t\t\treturn this.connection;\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.SingleConnectionDataSource#getConnection(username,password)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specifying a custom username and password doesn't make sense\n\t * with a single Connection. Returns the single Connection if given\n\t * the same username and password; throws an SQLException else.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "Connection",
    "signature": "public Connection getConnection(String username, String password)",
    "source_code": "\tpublic Connection getConnection(String username, String password) throws SQLException {\n\t\tif (ObjectUtils.nullSafeEquals(username, getUsername()) &&\n\t\t\t\tObjectUtils.nullSafeEquals(password, getPassword())) {\n\t\t\treturn getConnection();\n\t\t}\n\t\telse {\n\t\t\tthrow new SQLException(\"SingleConnectionDataSource does not support custom username and password\");\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.SingleConnectionDataSource#initConnection()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the underlying Connection via the DriverManager.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "void",
    "signature": "public void initConnection()",
    "source_code": "\tpublic void initConnection() throws SQLException {\n\t\tif (getUrl() == null) {\n\t\t\tthrow new IllegalStateException(\"'url' property is required for lazily initializing a Connection\");\n\t\t}\n\t\tsynchronized (this.connectionMonitor) {\n\t\t\tif (this.target != null) {\n\t\t\t\tcloseConnection(this.target);\n\t\t\t}\n\t\t\tthis.target = getConnectionFromDriver(getUsername(), getPassword());\n\t\t\tprepareConnection(this.target);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Established shared JDBC Connection: \" + this.target);\n\t\t\t}\n\t\t\tthis.connection = (isSuppressClose() ? getCloseSuppressingConnectionProxy(this.target) : this.target);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.SingleConnectionDataSource#invoke(proxy,method,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 349
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\t// Invocation on ConnectionProxy interface coming in...\n\n\t\t\treturn switch (method.getName()) {\n\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\tcase \"equals\" -> (proxy == args[0]);\n\t\t\t\t// Use hashCode of Connection proxy.\n\t\t\t\tcase \"hashCode\" -> System.identityHashCode(proxy);\n\t\t\t\t// Handle close method: don't pass the call on.\n\t\t\t\tcase \"close\" -> null;\n\t\t\t\tcase \"isClosed\" -> this.target.isClosed();\n\t\t\t\t// Handle getTargetConnection method: return underlying Connection.\n\t\t\t\tcase \"getTargetConnection\" -> this.target;\n\t\t\t\tcase \"unwrap\" -> (((Class<?>) args[0]).isInstance(proxy) ? proxy : this.target.unwrap((Class<?>) args[0]));\n\t\t\t\tcase \"isWrapperFor\" -> (((Class<?>) args[0]).isInstance(proxy) || this.target.isWrapperFor((Class<?>) args[0]));\n\t\t\t\tdefault -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Invoke method on target Connection.\n\t\t\t\t\t\tyield method.invoke(this.target, args);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\t\t\tthrow ex.getTargetException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}"
  },
  "org.springframework.jdbc.datasource.SingleConnectionDataSource#isRollbackBeforeClose()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether the shared Connection should be explicitly rolled back\n\t * before close (if not in auto-commit mode).\n\t * @since 6.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "boolean",
    "signature": "protected boolean isRollbackBeforeClose()",
    "source_code": "\tprotected boolean isRollbackBeforeClose() {\n\t\treturn this.rollbackBeforeClose;\n\t}"
  },
  "org.springframework.jdbc.datasource.SingleConnectionDataSource#isSuppressClose()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether the returned Connection will be a close-suppressing proxy\n\t * or the physical Connection.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "boolean",
    "signature": "protected boolean isSuppressClose()",
    "source_code": "\tprotected boolean isSuppressClose() {\n\t\treturn this.suppressClose;\n\t}"
  },
  "org.springframework.jdbc.datasource.SingleConnectionDataSource#prepareConnection(con)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare the given Connection before it is exposed.\n\t * <p>The default implementation applies the auto-commit flag, if necessary.\n\t * Can be overridden in subclasses.\n\t * @param con the Connection to prepare\n\t * @see #setAutoCommit\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "con"
    ],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "void",
    "signature": "protected void prepareConnection(Connection con)",
    "source_code": "\tprotected void prepareConnection(Connection con) throws SQLException {\n\t\tBoolean autoCommit = getAutoCommitValue();\n\t\tif (autoCommit != null && con.getAutoCommit() != autoCommit) {\n\t\t\tcon.setAutoCommit(autoCommit);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.SingleConnectionDataSource#resetConnection()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Reset the underlying shared Connection, to be reinitialized on next access.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 275
    },
    "return": "void",
    "signature": "public void resetConnection()",
    "source_code": "\tpublic void resetConnection() {\n\t\tsynchronized (this.connectionMonitor) {\n\t\t\tif (this.target != null) {\n\t\t\t\tcloseConnection(this.target);\n\t\t\t}\n\t\t\tthis.target = null;\n\t\t\tthis.connection = null;\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.SingleConnectionDataSource#setAutoCommit(autoCommit)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether the returned Connection's \"autoCommit\" setting should be overridden.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "autoCommit"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "void",
    "signature": "public void setAutoCommit(boolean autoCommit)",
    "source_code": "\tpublic void setAutoCommit(boolean autoCommit) {\n\t\tthis.autoCommit = autoCommit;\n\t}"
  },
  "org.springframework.jdbc.datasource.SingleConnectionDataSource#setRollbackBeforeClose(rollbackBeforeClose)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether the shared Connection should be explicitly rolled back\n\t * before close (if not in auto-commit mode).\n\t * <p>This is recommended for the Oracle JDBC driver in testing scenarios.\n\t * @since 6.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rollbackBeforeClose"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "void",
    "signature": "public void setRollbackBeforeClose(boolean rollbackBeforeClose)",
    "source_code": "\tpublic void setRollbackBeforeClose(boolean rollbackBeforeClose) {\n\t\tthis.rollbackBeforeClose = rollbackBeforeClose;\n\t}"
  },
  "org.springframework.jdbc.datasource.SingleConnectionDataSource#setSuppressClose(suppressClose)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether the returned Connection should be a close-suppressing proxy\n\t * or the physical Connection.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "suppressClose"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "void",
    "signature": "public void setSuppressClose(boolean suppressClose)",
    "source_code": "\tpublic void setSuppressClose(boolean suppressClose) {\n\t\tthis.suppressClose = suppressClose;\n\t}"
  },
  "org.springframework.jdbc.datasource.SingleConnectionDataSource#shouldClose(con)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This is a single Connection: Do not close it when returning to the \"pool\".\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "boolean",
    "signature": "public boolean shouldClose(Connection con)",
    "source_code": "\tpublic boolean shouldClose(Connection con) {\n\t\tsynchronized (this.connectionMonitor) {\n\t\t\treturn (con != this.connection && con != this.target);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy#setLazyTransactionalConnections(lazyTransactionalConnections)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether to obtain the transactional target Connection lazily on\n\t * actual data access.\n\t * <p>The default is \"true\". Specify \"false\" to immediately obtain a target\n\t * Connection when a transaction-aware Connection handle is retrieved.\n\t * @since 6.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lazyTransactionalConnections"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "void",
    "signature": "public void setLazyTransactionalConnections(boolean lazyTransactionalConnections)",
    "source_code": "\tpublic void setLazyTransactionalConnections(boolean lazyTransactionalConnections) {\n\t\tthis.lazyTransactionalConnections = lazyTransactionalConnections;\n\t}"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils#containsSqlScriptDelimiters(script,delimiter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the provided SQL script contains the specified delimiter.\n\t * <p>This method is intended to be used to find the string delimiting each\n\t * SQL statement &mdash; for example, a ';' character.\n\t * <p>Any occurrence of the delimiter within the script will be ignored if it\n\t * is within a <em>literal</em> block of text enclosed in single quotes\n\t * ({@code '}) or double quotes ({@code \"}), if it is escaped with a backslash\n\t * ({@code \\}), or if it is within a single-line comment or block comment.\n\t * @param script the SQL script to search within\n\t * @param delimiter the statement delimiter to search for\n\t * @see #DEFAULT_COMMENT_PREFIXES\n\t * @see #DEFAULT_BLOCK_COMMENT_START_DELIMITER\n\t * @see #DEFAULT_BLOCK_COMMENT_END_DELIMITER\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "script",
      "delimiter"
    ],
    "position": {
      "column": 1,
      "line": 430
    },
    "return": "boolean",
    "signature": "public boolean containsSqlScriptDelimiters(String script, String delimiter)",
    "source_code": "\tpublic static boolean containsSqlScriptDelimiters(String script, String delimiter) {\n\t\treturn containsStatementSeparator(null, script, delimiter, DEFAULT_COMMENT_PREFIXES,\n\t\t\tDEFAULT_BLOCK_COMMENT_START_DELIMITER, DEFAULT_BLOCK_COMMENT_END_DELIMITER);\n\t}"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils#readScript(lineNumberReader,commentPrefix,separator,blockCommentEndDelimiter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Read a script from the provided {@code LineNumberReader}, using the supplied\n\t * comment prefix and statement separator, and build a {@code String} containing\n\t * the lines.\n\t * <p>Lines <em>beginning</em> with the comment prefix are excluded from the\n\t * results; however, line comments anywhere else &mdash; for example, within\n\t * a statement &mdash; will be included in the results.\n\t * @param lineNumberReader the {@code LineNumberReader} containing the script\n\t * to be processed\n\t * @param commentPrefix the prefix that identifies comments in the SQL script\n\t * (typically \"--\")\n\t * @param separator the statement separator in the SQL script (typically \";\")\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter\n\t * @return a {@code String} containing the script lines\n\t * @throws IOException in case of I/O errors\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lineNumberReader",
      "commentPrefix",
      "separator",
      "blockCommentEndDelimiter"
    ],
    "position": {
      "column": 1,
      "line": 352
    },
    "return": "String",
    "signature": "public String readScript(LineNumberReader lineNumberReader, @Nullable String commentPrefix,\n\t\t\t@Nullable String separator, @Nullable String blockCommentEndDelimiter)",
    "source_code": "\tpublic static String readScript(LineNumberReader lineNumberReader, @Nullable String commentPrefix,"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils#readScript(lineNumberReader,commentPrefixes,separator,blockCommentEndDelimiter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Read a script from the provided {@code LineNumberReader}, using the supplied\n\t * comment prefixes and statement separator, and build a {@code String} containing\n\t * the lines.\n\t * <p>Lines <em>beginning</em> with one of the comment prefixes are excluded\n\t * from the results; however, line comments anywhere else &mdash; for example,\n\t * within a statement &mdash; will be included in the results.\n\t * @param lineNumberReader the {@code LineNumberReader} containing the script\n\t * to be processed\n\t * @param commentPrefixes the prefixes that identify comments in the SQL script\n\t * (typically \"--\")\n\t * @param separator the statement separator in the SQL script (typically \";\")\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter\n\t * @return a {@code String} containing the script lines\n\t * @throws IOException in case of I/O errors\n\t * @since 5.2\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lineNumberReader",
      "commentPrefixes",
      "separator",
      "blockCommentEndDelimiter"
    ],
    "position": {
      "column": 1,
      "line": 379
    },
    "return": "String",
    "signature": "public String readScript(LineNumberReader lineNumberReader, @Nullable String[] commentPrefixes,\n\t\t\t@Nullable String separator, @Nullable String blockCommentEndDelimiter)",
    "source_code": "\tpublic static String readScript(LineNumberReader lineNumberReader, @Nullable String[] commentPrefixes,"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils#splitSqlScript(resource,script,separator,commentPrefix,blockCommentStartDelimiter,blockCommentEndDelimiter,statements)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Split an SQL script into separate statements delimited by the provided\n\t * separator string. Each individual statement will be added to the provided\n\t * {@code List}.\n\t * <p>Within the script, the provided {@code commentPrefix} will be honored:\n\t * any text beginning with the comment prefix and extending to the end of the\n\t * line will be omitted from the output. Similarly, the provided\n\t * {@code blockCommentStartDelimiter} and {@code blockCommentEndDelimiter}\n\t * delimiters will be honored: any text enclosed in a block comment will be\n\t * omitted from the output. In addition, multiple adjacent whitespace characters\n\t * will be collapsed into a single space.\n\t * @param resource the resource from which the script was read\n\t * @param script the SQL script\n\t * @param separator text separating each statement\n\t * (typically a ';' or newline character)\n\t * @param commentPrefix the prefix that identifies SQL line comments\n\t * (typically \"--\")\n\t * @param blockCommentStartDelimiter the <em>start</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param statements the list that will contain the individual statements\n\t * @throws ScriptException if an error occurred while splitting the SQL script\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resource",
      "script",
      "separator",
      "commentPrefix",
      "blockCommentStartDelimiter",
      "blockCommentEndDelimiter",
      "statements"
    ],
    "position": {
      "column": 1,
      "line": 595
    },
    "return": "void",
    "signature": "public void splitSqlScript(@Nullable EncodedResource resource, String script,\n\t\t\tString separator, String commentPrefix, String blockCommentStartDelimiter,\n\t\t\tString blockCommentEndDelimiter, List<String> statements)",
    "source_code": "\tpublic static void splitSqlScript(@Nullable EncodedResource resource, String script,"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils#splitSqlScript(resource,script,separator,commentPrefixes,blockCommentStartDelimiter,blockCommentEndDelimiter,statements)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Split an SQL script into separate statements delimited by the provided\n\t * separator string. Each individual statement will be added to the provided\n\t * {@code List}.\n\t * <p>Within the script, the provided {@code commentPrefixes} will be honored:\n\t * any text beginning with one of the comment prefixes and extending to the\n\t * end of the line will be omitted from the output. Similarly, the provided\n\t * {@code blockCommentStartDelimiter} and {@code blockCommentEndDelimiter}\n\t * delimiters will be honored: any text enclosed in a block comment will be\n\t * omitted from the output. In addition, multiple adjacent whitespace characters\n\t * will be collapsed into a single space.\n\t * @param resource the resource from which the script was read\n\t * @param script the SQL script\n\t * @param separator text separating each statement\n\t * (typically a ';' or newline character)\n\t * @param commentPrefixes the prefixes that identify SQL line comments\n\t * (typically \"--\")\n\t * @param blockCommentStartDelimiter the <em>start</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param statements the list that will contain the individual statements\n\t * @throws ScriptException if an error occurred while splitting the SQL script\n\t * @since 5.2\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resource",
      "script",
      "separator",
      "commentPrefixes",
      "blockCommentStartDelimiter",
      "blockCommentEndDelimiter",
      "statements"
    ],
    "position": {
      "column": 1,
      "line": 632
    },
    "return": "void",
    "signature": "public void splitSqlScript(@Nullable EncodedResource resource, String script,\n\t\t\tString separator, String[] commentPrefixes, String blockCommentStartDelimiter,\n\t\t\tString blockCommentEndDelimiter, List<String> statements)",
    "source_code": "\tpublic static void splitSqlScript(@Nullable EncodedResource resource, String script,"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils#splitSqlScript(script,separator,statements)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Split an SQL script into separate statements delimited by the provided\n\t * separator string. Each individual statement will be added to the\n\t * provided {@code List}.\n\t * <p>Within the script, {@value #DEFAULT_COMMENT_PREFIX} will be used as the\n\t * comment prefix; any text beginning with the comment prefix and extending to\n\t * the end of the line will be omitted from the output. Similarly,\n\t * {@value #DEFAULT_BLOCK_COMMENT_START_DELIMITER} and\n\t * {@value #DEFAULT_BLOCK_COMMENT_END_DELIMITER} will be used as the\n\t * <em>start</em> and <em>end</em> block comment delimiters: any text enclosed\n\t * in a block comment will be omitted from the output. In addition, multiple\n\t * adjacent whitespace characters will be collapsed into a single space.\n\t * @param script the SQL script\n\t * @param separator text separating each statement\n\t * (typically a ';' or newline character)\n\t * @param statements the list that will contain the individual statements\n\t * @throws ScriptException if an error occurred while splitting the SQL script\n\t * @see #splitSqlScript(String, char, List)\n\t * @see #splitSqlScript(EncodedResource, String, String, String, String, String, List)\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "script",
      "separator",
      "statements"
    ],
    "position": {
      "column": 1,
      "line": 563
    },
    "return": "void",
    "signature": "public void splitSqlScript(String script, String separator, List<String> statements)",
    "source_code": "\tpublic static void splitSqlScript(String script, String separator, List<String> statements) throws ScriptException {\n\t\tsplitSqlScript(null, script, separator, DEFAULT_COMMENT_PREFIX, DEFAULT_BLOCK_COMMENT_START_DELIMITER,\n\t\t\t\tDEFAULT_BLOCK_COMMENT_END_DELIMITER, statements);\n\t}"
  },
  "org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource#createConnectionBuilder()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "ConnectionBuilder",
    "signature": "public ConnectionBuilder createConnectionBuilder()",
    "source_code": "\tpublic ConnectionBuilder createConnectionBuilder() throws SQLException {\n\t\treturn determineTargetDataSource().createConnectionBuilder();\n\t}"
  },
  "org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource#createShardingKeyBuilder()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "ShardingKeyBuilder",
    "signature": "public ShardingKeyBuilder createShardingKeyBuilder()",
    "source_code": "\tpublic ShardingKeyBuilder createShardingKeyBuilder() throws SQLException {\n\t\treturn determineTargetDataSource().createShardingKeyBuilder();\n\t}"
  },
  "org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource#initialize()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the internal state of this {@code AbstractRoutingDataSource}\n\t * by resolving the configured target DataSources.\n\t * @throws IllegalArgumentException if the target DataSources have not been configured\n\t * @since 6.1\n\t * @see #setTargetDataSources(Map)\n\t * @see #setDefaultTargetDataSource(Object)\n\t * @see #getResolvedDataSources()\n\t * @see #getResolvedDefaultDataSource()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "void",
    "signature": "public void initialize()",
    "source_code": "\tpublic void initialize() {\n\t\tif (this.targetDataSources == null) {\n\t\t\tthrow new IllegalArgumentException(\"Property 'targetDataSources' is required\");\n\t\t}\n\t\tthis.resolvedDataSources = CollectionUtils.newHashMap(this.targetDataSources.size());\n\t\tthis.targetDataSources.forEach((key, value) -> {\n\t\t\tObject lookupKey = resolveSpecifiedLookupKey(key);\n\t\t\tDataSource dataSource = resolveSpecifiedDataSource(value);\n\t\t\tthis.resolvedDataSources.put(lookupKey, dataSource);\n\t\t});\n\t\tif (this.defaultTargetDataSource != null) {\n\t\t\tthis.resolvedDefaultDataSource = resolveSpecifiedDataSource(this.defaultTargetDataSource);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.JdbcUtils#convertPropertyNameToUnderscoreName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a property name using \"camelCase\" to a corresponding column name with underscores.\n\t * A name like \"customerNumber\" would match a \"customer_number\" column name.\n\t * @param name the property name to be converted\n\t * @return the column name using underscores\n\t * @since 6.1\n\t * @see #convertUnderscoreNameToPropertyName\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 515
    },
    "return": "String",
    "signature": "public String convertPropertyNameToUnderscoreName(@Nullable String name)",
    "source_code": "\tpublic static String convertPropertyNameToUnderscoreName(@Nullable String name) {\n\t\tif (!StringUtils.hasLength(name)) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tStringBuilder result = new StringBuilder();\n\t\tresult.append(Character.toLowerCase(name.charAt(0)));\n\t\tfor (int i = 1; i < name.length(); i++) {\n\t\t\tchar c = name.charAt(i);\n\t\t\tif (Character.isUpperCase(c)) {\n\t\t\t\tresult.append('_').append(Character.toLowerCase(c));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.append(c);\n\t\t\t}\n\t\t}\n\t\treturn result.toString();\n\t}"
  },
  "org.springframework.jms.connection.ConnectionFactoryUtils#afterCompletion(status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 446
    },
    "return": "void",
    "signature": "public void afterCompletion(int status)",
    "source_code": "\t\tpublic void afterCompletion(int status) {\n\t\t\tif (status == STATUS_COMMITTED && this.transacted && !this.commitProcessed) {\n\t\t\t\t// JmsResourceSynchronization registered in afterCommit phase of other synchronization\n\t\t\t\t// -> late local JMS transaction commit here, otherwise it would silently get dropped.\n\t\t\t\tafterCommit();\n\t\t\t}\n\t\t\tsuper.afterCompletion(status);\n\t\t}"
  },
  "org.springframework.jms.connection.JmsTransactionManager#flush()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 453
    },
    "return": "void",
    "signature": "public void flush()",
    "source_code": "\t\tpublic void flush() {\n\t\t\t// no-op\n\t\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#isRunning()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether there is currently an underlying connection.\n\t * @since 6.1\n\t * @see #start()\n\t * @see #stop()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 388
    },
    "return": "boolean",
    "signature": "public boolean isRunning()",
    "source_code": "\tpublic boolean isRunning() {\n\t\tsynchronized (this.connectionMonitor) {\n\t\t\treturn (this.connection != null);\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#start()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the underlying shared connection on start.\n\t * @since 6.1\n\t * @see #initConnection()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 362
    },
    "return": "void",
    "signature": "public void start()",
    "source_code": "\tpublic void start() {\n\t\ttry {\n\t\t\tinitConnection();\n\t\t}\n\t\tcatch (JMSException ex) {\n\t\t\tlogger.info(\"Start attempt failed for shared JMS Connection\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#stop()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Reset the underlying shared connection on stop.\n\t * @since 6.1\n\t * @see #resetConnection()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 377
    },
    "return": "void",
    "signature": "public void stop()",
    "source_code": "\tpublic void stop() {\n\t\tresetConnection();\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#setObservationRegistry(observationRegistry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@link ObservationRegistry} to use for recording JMS observations.\n\t * @param observationRegistry the observation registry to use.\n\t * @since 6.1\n\t * @see io.micrometer.jakarta9.instrument.jms.JmsInstrumentation\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "observationRegistry"
    ],
    "position": {
      "column": 1,
      "line": 479
    },
    "return": "void",
    "signature": "public void setObservationRegistry(ObservationRegistry observationRegistry)",
    "source_code": "\tpublic void setObservationRegistry(ObservationRegistry observationRegistry) {\n\t\tthis.observationRegistry = observationRegistry;\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#createObservation(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 688
    },
    "return": "Observation",
    "signature": "protected Observation createObservation(Message message)",
    "source_code": "\tprotected Observation createObservation(Message message) {\n\t\tif (micrometerJakartaPresent && this.observationRegistry != null) {\n\t\t\treturn ObservationFactory.create(this.observationRegistry, message);\n\t\t}\n\t\telse {\n\t\t\treturn Observation.NOOP;\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#getObservationRegistry()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link ObservationRegistry} used for recording\n\t * {@link JmsObservationDocumentation#JMS_MESSAGE_PROCESS JMS message processing observations}.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 594
    },
    "return": "ObservationRegistry",
    "signature": "public ObservationRegistry getObservationRegistry()",
    "source_code": "\tpublic ObservationRegistry getObservationRegistry() {\n\t\treturn this.observationRegistry;\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#setObservationRegistry(observationRegistry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link ObservationRegistry} to be used for recording\n\t * {@link JmsObservationDocumentation#JMS_MESSAGE_PROCESS JMS message processing observations}.\n\t * Defaults to no-op observations if the registry is not set.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "observationRegistry"
    ],
    "position": {
      "column": 1,
      "line": 584
    },
    "return": "void",
    "signature": "public void setObservationRegistry(@Nullable ObservationRegistry observationRegistry)",
    "source_code": "\tpublic void setObservationRegistry(@Nullable ObservationRegistry observationRegistry) {\n\t\tthis.observationRegistry = observationRegistry;\n\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#clone()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 432
    },
    "return": "ReturnValueMethodParameter",
    "signature": "public ReturnValueMethodParameter clone()",
    "source_code": "\t\tpublic ReturnValueMethodParameter clone() {\n\t\t\treturn new ReturnValueMethodParameter(this);\n\t\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#findProvidedArgument(parameter,providedArgs)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 325
    },
    "return": "Object",
    "signature": "protected Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs)",
    "source_code": "\tprotected static Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs) {\n\t\tif (!ObjectUtils.isEmpty(providedArgs)) {\n\t\t\tfor (Object providedArg : providedArgs) {\n\t\t\t\tif (parameter.getParameterType().isInstance(providedArg)) {\n\t\t\t\t\treturn providedArg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#formatArgumentError(param,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "param",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 336
    },
    "return": "String",
    "signature": "protected String formatArgumentError(MethodParameter param, String message)",
    "source_code": "\tprotected static String formatArgumentError(MethodParameter param, String message) {\n\t\treturn \"Could not resolve parameter [\" + param.getParameterIndex() + \"] in \" +\n\t\t\t\tparam.getExecutable().toGenericString() + (StringUtils.hasText(message) ? \": \" + message : \"\");\n\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#getBridgedMethod()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * If the bean method is a bridge method, this method returns the bridged\n\t * (user-defined) method. Otherwise, it returns the same method as {@link #getMethod()}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "Method",
    "signature": "protected Method getBridgedMethod()",
    "source_code": "\tprotected Method getBridgedMethod() {\n\t\treturn this.bridgedMethod;\n\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#getMethod()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the method for this handler method.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "Method",
    "signature": "public Method getMethod()",
    "source_code": "\tpublic Method getMethod() {\n\t\treturn this.method;\n\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#getMethodAnnotation(annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 392
    },
    "return": "T",
    "signature": "public T getMethodAnnotation(Class<T> annotationType)",
    "source_code": "\t\tpublic <T extends Annotation> T getMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn HandlerMethod.this.getMethodAnnotation(annotationType);\n\t\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#getMethodParameters()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the method parameters for this handler method.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "MethodParameter[]",
    "signature": "public MethodParameter[] getMethodParameters()",
    "source_code": "\tpublic MethodParameter[] getMethodParameters() {\n\t\treturn this.parameters;\n\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#getReturnType()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the HandlerMethod return type.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 231
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter getReturnType()",
    "source_code": "\tpublic MethodParameter getReturnType() {\n\t\treturn new HandlerMethodParameter(-1);\n\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#getReturnValueType(returnValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the actual return value type.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue"
    ],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter getReturnValueType(@Nullable Object returnValue)",
    "source_code": "\tpublic MethodParameter getReturnValueType(@Nullable Object returnValue) {\n\t\treturn new ReturnValueMethodParameter(returnValue);\n\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#hasMethodAnnotation(annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 397
    },
    "return": "boolean",
    "signature": "public boolean hasMethodAnnotation(Class<T> annotationType)",
    "source_code": "\t\tpublic <T extends Annotation> boolean hasMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn HandlerMethod.this.hasMethodAnnotation(annotationType);\n\t\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#isVoid()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return {@code true} if the method return type is void, {@code false} otherwise.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 245
    },
    "return": "boolean",
    "signature": "public boolean isVoid()",
    "source_code": "\tpublic boolean isVoid() {\n\t\treturn Void.TYPE.equals(getReturnType().getParameterType());\n\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#toString()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 317
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn this.method.toGenericString();\n\t}"
  },
  "org.springframework.messaging.handler.HandlerMethodParameter": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * A MethodParameter with HandlerMethod-specific behavior.\n\t */",
    "kind": "class",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 376
    },
    "signature": "protected class HandlerMethodParameter",
    "source_code": "\tprotected class HandlerMethodParameter extends SynthesizingMethodParameter {\n\n\t\tpublic HandlerMethodParameter(int index) {\n\t\t\tsuper(HandlerMethod.this.bridgedMethod, index);\n\t\t}\n\n\t\tprotected HandlerMethodParameter(HandlerMethodParameter original) {\n\t\t\tsuper(original);\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<?> getContainingClass() {\n\t\t\treturn HandlerMethod.this.getBeanType();\n\t\t}\n\n\t\t@Override\n\t\tpublic <T extends Annotation> T getMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn HandlerMethod.this.getMethodAnnotation(annotationType);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T extends Annotation> boolean hasMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn HandlerMethod.this.hasMethodAnnotation(annotationType);\n\t\t}\n\n\t\t@Override\n\t\tpublic HandlerMethodParameter clone() {\n\t\t\treturn new HandlerMethodParameter(this);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.annotation.reactive.AbstractNamedValueMethodArgumentResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract base class to resolve method arguments from a named value, e.g.\n * message headers or destination variables. Named values could have one or more\n * of a name, a required flag, and a default value.\n *\n * <p>Subclasses only need to define specific steps such as how to obtain named\n * value details from a method parameter, how to resolve to argument values, or\n * how to handle missing values.\n *\n *  <p>A default value string can contain ${...} placeholders and Spring\n * Expression Language {@code #{...}} expressions which will be resolved if a\n * {@link ConfigurableBeanFactory} is supplied to the class constructor.\n *\n * <p>A {@link ConversionService} is used to convert a resolved String argument\n * value to the expected target method parameter type.\n *\n * @author Rossen Stoyanchev\n * @since 5.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "signature": "public class AbstractNamedValueMethodArgumentResolver",
    "source_code": "public abstract class AbstractNamedValueMethodArgumentResolver implements SyncHandlerMethodArgumentResolver {\n\n\tprivate final ConversionService conversionService;\n\n\t@Nullable\n\tprivate final ConfigurableBeanFactory configurableBeanFactory;\n\n\t@Nullable\n\tprivate final BeanExpressionContext expressionContext;\n\n\tprivate final Map<MethodParameter, NamedValueInfo> namedValueInfoCache = new ConcurrentHashMap<>(256);\n\n\n\t/**\n\t * Constructor with a {@link ConversionService} and a {@link BeanFactory}.\n\t * @param conversionService conversion service for converting String values\n\t * to the target method parameter type\n\t * @param beanFactory a bean factory for resolving {@code ${...}}\n\t * placeholders and {@code #{...}} SpEL expressions in default values\n\t */\n\tprotected AbstractNamedValueMethodArgumentResolver(ConversionService conversionService,\n\t\t\t@Nullable ConfigurableBeanFactory beanFactory) {\n\n\t\tthis.conversionService = conversionService;\n\t\tthis.configurableBeanFactory = beanFactory;\n\t\tthis.expressionContext = (beanFactory != null ? new BeanExpressionContext(beanFactory, null) : null);\n\t}\n\n\n\t@Override\n\t@Nullable\n\tpublic Object resolveArgumentValue(MethodParameter parameter, Message<?> message) {\n\t\tNamedValueInfo namedValueInfo = getNamedValueInfo(parameter);\n\t\tMethodParameter nestedParameter = parameter.nestedIfOptional();\n\n\t\tObject resolvedName = resolveEmbeddedValuesAndExpressions(namedValueInfo.name);\n\t\tif (resolvedName == null) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Specified name must not resolve to null: [\" + namedValueInfo.name + \"]\");\n\t\t}\n\n\t\tObject arg = resolveArgumentInternal(nestedParameter, message, resolvedName.toString());\n\t\tif (arg == null) {\n\t\t\tif (namedValueInfo.defaultValue != null) {\n\t\t\t\targ = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);\n\t\t\t}\n\t\t\telse if (namedValueInfo.required && !nestedParameter.isOptional()) {\n\t\t\t\thandleMissingValue(namedValueInfo.name, nestedParameter, message);\n\t\t\t}\n\t\t\targ = handleNullValue(namedValueInfo.name, arg, nestedParameter.getNestedParameterType());\n\t\t}\n\t\telse if (\"\".equals(arg) && namedValueInfo.defaultValue != null) {\n\t\t\targ = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);\n\t\t}\n\n\t\tif (parameter != nestedParameter || !ClassUtils.isAssignableValue(parameter.getParameterType(), arg)) {\n\t\t\targ = this.conversionService.convert(arg, new TypeDescriptor(parameter));\n\t\t\t// Check for null value after conversion of incoming argument value\n\t\t\tif (arg == null) {\n\t\t\t\tif (namedValueInfo.defaultValue != null) {\n\t\t\t\t\targ = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);\n\t\t\t\t}\n\t\t\t\telse if (namedValueInfo.required && !nestedParameter.isOptional()) {\n\t\t\t\t\thandleMissingValue(namedValueInfo.name, nestedParameter, message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn arg;\n\t}\n\n\t/**\n\t * Obtain the named value for the given method parameter.\n\t */\n\tprivate NamedValueInfo getNamedValueInfo(MethodParameter parameter) {\n\t\tNamedValueInfo namedValueInfo = this.namedValueInfoCache.get(parameter);\n\t\tif (namedValueInfo == null) {\n\t\t\tnamedValueInfo = createNamedValueInfo(parameter);\n\t\t\tnamedValueInfo = updateNamedValueInfo(parameter, namedValueInfo);\n\t\t\tthis.namedValueInfoCache.put(parameter, namedValueInfo);\n\t\t}\n\t\treturn namedValueInfo;\n\t}\n\n\t/**\n\t * Create the {@link NamedValueInfo} object for the given method parameter.\n\t * Implementations typically retrieve the method annotation by means of\n\t * {@link MethodParameter#getParameterAnnotation(Class)}.\n\t * @param parameter the method parameter\n\t * @return the named value information\n\t */\n\tprotected abstract NamedValueInfo createNamedValueInfo(MethodParameter parameter);\n\n\t/**\n\t * Fall back on the parameter name from the class file if necessary and\n\t * replace {@link ValueConstants#DEFAULT_NONE} with null.\n\t */\n\tprivate NamedValueInfo updateNamedValueInfo(MethodParameter parameter, NamedValueInfo info) {\n\t\tString name = info.name;\n\t\tif (info.name.isEmpty()) {\n\t\t\tname = parameter.getParameterName();\n\t\t\tif (name == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"\"\"\n\t\t\t\t\t\tName for argument of type [%s] not specified, and parameter name information not \\\n\t\t\t\t\t\tavailable via reflection. Ensure that the compiler uses the '-parameters' flag.\"\"\"\n\t\t\t\t\t\t\t.formatted(parameter.getNestedParameterType().getName()));\n\t\t\t}\n\t\t}\n\t\treturn new NamedValueInfo(name, info.required,\n\t\t\t\tValueConstants.DEFAULT_NONE.equals(info.defaultValue) ? null : info.defaultValue);\n\t}\n\n\t/**\n\t * Resolve the given annotation-specified value,\n\t * potentially containing placeholders and expressions.\n\t */\n\t@Nullable\n\tprivate Object resolveEmbeddedValuesAndExpressions(String value) {\n\t\tif (this.configurableBeanFactory == null || this.expressionContext == null) {\n\t\t\treturn value;\n\t\t}\n\t\tString placeholdersResolved = this.configurableBeanFactory.resolveEmbeddedValue(value);\n\t\tBeanExpressionResolver exprResolver = this.configurableBeanFactory.getBeanExpressionResolver();\n\t\tif (exprResolver == null) {\n\t\t\treturn value;\n\t\t}\n\t\treturn exprResolver.evaluate(placeholdersResolved, this.expressionContext);\n\t}\n\n\t/**\n\t * Resolves the given parameter type and value name into an argument value.\n\t * @param parameter the method parameter to resolve to an argument value\n\t * @param message the current request\n\t * @param name the name of the value being resolved\n\t * @return the resolved argument. May be {@code null}\n\t */\n\t@Nullable\n\tprotected abstract Object resolveArgumentInternal(MethodParameter parameter, Message<?> message, String name);\n\n\t/**\n\t * Invoked when a value is required, but {@link #resolveArgumentInternal}\n\t * returned {@code null} and there is no default value. Subclasses can\n\t * throw an appropriate exception for this case.\n\t * @param name the name for the value\n\t * @param parameter the target method parameter\n\t * @param message the message being processed\n\t */\n\tprotected abstract void handleMissingValue(String name, MethodParameter parameter, Message<?> message);\n\n\t/**\n\t * One last chance to handle a possible null value.\n\t * Specifically for booleans method parameters, use {@link Boolean#FALSE}.\n\t * Also raise an ISE for primitive types.\n\t */\n\t@Nullable\n\tprivate Object handleNullValue(String name, @Nullable Object value, Class<?> paramType) {\n\t\tif (value == null) {\n\t\t\tif (paramType == boolean.class) {\n\t\t\t\treturn Boolean.FALSE;\n\t\t\t}\n\t\t\telse if (paramType.isPrimitive()) {\n\t\t\t\tthrow new IllegalStateException(\"Optional \" + paramType + \" parameter '\" + name +\n\t\t\t\t\t\t\"' is present but cannot be translated into a null value due to being \" +\n\t\t\t\t\t\t\"declared as a primitive type. Consider declaring it as object wrapper \" +\n\t\t\t\t\t\t\"for the corresponding primitive type.\");\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}\n\n\n\t/**\n\t * Represents a named value declaration.\n\t */\n\tprotected static class NamedValueInfo {\n\n\t\tprivate final String name;\n\n\t\tprivate final boolean required;\n\n\t\t@Nullable\n\t\tprivate final String defaultValue;\n\n\t\tprotected NamedValueInfo(String name, boolean required, @Nullable String defaultValue) {\n\t\t\tthis.name = name;\n\t\t\tthis.required = required;\n\t\t\tthis.defaultValue = defaultValue;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.messaging.handler.annotation.reactive.AbstractNamedValueMethodArgumentResolver#createNamedValueInfo(parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the {@link NamedValueInfo} object for the given method parameter.\n\t * Implementations typically retrieve the method annotation by means of\n\t * {@link MethodParameter#getParameterAnnotation(Class)}.\n\t * @param parameter the method parameter\n\t * @return the named value information\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "NamedValueInfo",
    "signature": "protected NamedValueInfo createNamedValueInfo(MethodParameter parameter)",
    "source_code": "\tprotected abstract NamedValueInfo createNamedValueInfo(MethodParameter parameter);"
  },
  "org.springframework.messaging.handler.annotation.reactive.AbstractNamedValueMethodArgumentResolver#handleMissingValue(name,parameter,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked when a value is required, but {@link #resolveArgumentInternal}\n\t * returned {@code null} and there is no default value. Subclasses can\n\t * throw an appropriate exception for this case.\n\t * @param name the name for the value\n\t * @param parameter the target method parameter\n\t * @param message the message being processed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "void",
    "signature": "protected void handleMissingValue(String name, MethodParameter parameter, Message<?> message)",
    "source_code": "\tprotected abstract void handleMissingValue(String name, MethodParameter parameter, Message<?> message);"
  },
  "org.springframework.messaging.handler.annotation.reactive.AbstractNamedValueMethodArgumentResolver#resolveArgumentInternal(parameter,message,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolves the given parameter type and value name into an argument value.\n\t * @param parameter the method parameter to resolve to an argument value\n\t * @param message the current request\n\t * @param name the name of the value being resolved\n\t * @return the resolved argument. May be {@code null}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "message",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "Object",
    "signature": "protected Object resolveArgumentInternal(MethodParameter parameter, Message<?> message, String name)",
    "source_code": "\tprotected abstract Object resolveArgumentInternal(MethodParameter parameter, Message<?> message, String name);"
  },
  "org.springframework.messaging.handler.annotation.reactive.AbstractNamedValueMethodArgumentResolver#resolveArgumentValue(parameter,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "Object",
    "signature": "public Object resolveArgumentValue(MethodParameter parameter, Message<?> message)",
    "source_code": "\tpublic Object resolveArgumentValue(MethodParameter parameter, Message<?> message) {\n\t\tNamedValueInfo namedValueInfo = getNamedValueInfo(parameter);\n\t\tMethodParameter nestedParameter = parameter.nestedIfOptional();\n\n\t\tObject resolvedName = resolveEmbeddedValuesAndExpressions(namedValueInfo.name);\n\t\tif (resolvedName == null) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Specified name must not resolve to null: [\" + namedValueInfo.name + \"]\");\n\t\t}\n\n\t\tObject arg = resolveArgumentInternal(nestedParameter, message, resolvedName.toString());\n\t\tif (arg == null) {\n\t\t\tif (namedValueInfo.defaultValue != null) {\n\t\t\t\targ = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);\n\t\t\t}\n\t\t\telse if (namedValueInfo.required && !nestedParameter.isOptional()) {\n\t\t\t\thandleMissingValue(namedValueInfo.name, nestedParameter, message);\n\t\t\t}\n\t\t\targ = handleNullValue(namedValueInfo.name, arg, nestedParameter.getNestedParameterType());\n\t\t}\n\t\telse if (\"\".equals(arg) && namedValueInfo.defaultValue != null) {\n\t\t\targ = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);\n\t\t}\n\n\t\tif (parameter != nestedParameter || !ClassUtils.isAssignableValue(parameter.getParameterType(), arg)) {\n\t\t\targ = this.conversionService.convert(arg, new TypeDescriptor(parameter));\n\t\t\t// Check for null value after conversion of incoming argument value\n\t\t\tif (arg == null) {\n\t\t\t\tif (namedValueInfo.defaultValue != null) {\n\t\t\t\t\targ = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);\n\t\t\t\t}\n\t\t\t\telse if (namedValueInfo.required && !nestedParameter.isOptional()) {\n\t\t\t\t\thandleMissingValue(namedValueInfo.name, nestedParameter, message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn arg;\n\t}"
  },
  "org.springframework.messaging.handler.annotation.reactive.NamedValueInfo": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Represents a named value declaration.\n\t */",
    "kind": "class",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "signature": "protected class NamedValueInfo",
    "source_code": "\tprotected static class NamedValueInfo {\n\n\t\tprivate final String name;\n\n\t\tprivate final boolean required;\n\n\t\t@Nullable\n\t\tprivate final String defaultValue;\n\n\t\tprotected NamedValueInfo(String name, boolean required, @Nullable String defaultValue) {\n\t\t\tthis.name = name;\n\t\t\tthis.required = required;\n\t\t\tthis.defaultValue = defaultValue;\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.annotation.support.AbstractNamedValueMethodArgumentResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract base class to resolve method arguments from a named value, e.g.\n * message headers or destination variables. Named values could have one or more\n * of a name, a required flag, and a default value.\n *\n * <p>Subclasses only need to define specific steps such as how to obtain named\n * value details from a method parameter, how to resolve to argument values, or\n * how to handle missing values.\n *\n *  <p>A default value string can contain ${...} placeholders and Spring\n * Expression Language {@code #{...}} expressions which will be resolved if a\n * {@link ConfigurableBeanFactory} is supplied to the class constructor.\n *\n * <p>A {@link ConversionService} is used to convert a resolved String argument\n * value to the expected target method parameter type.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "signature": "public class AbstractNamedValueMethodArgumentResolver",
    "source_code": "public abstract class AbstractNamedValueMethodArgumentResolver implements HandlerMethodArgumentResolver {\n\n\tprivate final ConversionService conversionService;\n\n\t@Nullable\n\tprivate final ConfigurableBeanFactory configurableBeanFactory;\n\n\t@Nullable\n\tprivate final BeanExpressionContext expressionContext;\n\n\tprivate final Map<MethodParameter, NamedValueInfo> namedValueInfoCache = new ConcurrentHashMap<>(256);\n\n\n\t/**\n\t * Constructor with a {@link ConversionService} and a {@link BeanFactory}.\n\t * @param conversionService conversion service for converting String values\n\t * to the target method parameter type\n\t * @param beanFactory a bean factory for resolving {@code ${...}}\n\t * placeholders and {@code #{...}} SpEL expressions in default values\n\t */\n\tprotected AbstractNamedValueMethodArgumentResolver(ConversionService conversionService,\n\t\t\t@Nullable ConfigurableBeanFactory beanFactory) {\n\n\t\t// Fallback on shared ConversionService for now for historic reasons.\n\t\t// Possibly remove after discussion in gh-23882.\n\n\t\t//noinspection ConstantConditions\n\t\tthis.conversionService = (conversionService != null ?\n\t\t\t\tconversionService : DefaultConversionService.getSharedInstance());\n\n\t\tthis.configurableBeanFactory = beanFactory;\n\t\tthis.expressionContext = (beanFactory != null ? new BeanExpressionContext(beanFactory, null) : null);\n\t}\n\n\n\t@Override\n\t@Nullable\n\tpublic Object resolveArgument(MethodParameter parameter, Message<?> message) throws Exception {\n\t\tNamedValueInfo namedValueInfo = getNamedValueInfo(parameter);\n\t\tMethodParameter nestedParameter = parameter.nestedIfOptional();\n\n\t\tObject resolvedName = resolveEmbeddedValuesAndExpressions(namedValueInfo.name);\n\t\tif (resolvedName == null) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Specified name must not resolve to null: [\" + namedValueInfo.name + \"]\");\n\t\t}\n\n\t\tObject arg = resolveArgumentInternal(nestedParameter, message, resolvedName.toString());\n\t\tif (arg == null) {\n\t\t\tif (namedValueInfo.defaultValue != null) {\n\t\t\t\targ = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);\n\t\t\t}\n\t\t\telse if (namedValueInfo.required && !nestedParameter.isOptional()) {\n\t\t\t\thandleMissingValue(namedValueInfo.name, nestedParameter, message);\n\t\t\t}\n\t\t\targ = handleNullValue(namedValueInfo.name, arg, nestedParameter.getNestedParameterType());\n\t\t}\n\t\telse if (\"\".equals(arg) && namedValueInfo.defaultValue != null) {\n\t\t\targ = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);\n\t\t}\n\n\t\tif (parameter != nestedParameter || !ClassUtils.isAssignableValue(parameter.getParameterType(), arg)) {\n\t\t\targ = this.conversionService.convert(arg, new TypeDescriptor(parameter));\n\t\t\t// Check for null value after conversion of incoming argument value\n\t\t\tif (arg == null) {\n\t\t\t\tif (namedValueInfo.defaultValue != null) {\n\t\t\t\t\targ = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);\n\t\t\t\t}\n\t\t\t\telse if (namedValueInfo.required && !nestedParameter.isOptional()) {\n\t\t\t\t\thandleMissingValue(namedValueInfo.name, nestedParameter, message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\thandleResolvedValue(arg, namedValueInfo.name, parameter, message);\n\n\t\treturn arg;\n\t}\n\n\t/**\n\t * Obtain the named value for the given method parameter.\n\t */\n\tprivate NamedValueInfo getNamedValueInfo(MethodParameter parameter) {\n\t\tNamedValueInfo namedValueInfo = this.namedValueInfoCache.get(parameter);\n\t\tif (namedValueInfo == null) {\n\t\t\tnamedValueInfo = createNamedValueInfo(parameter);\n\t\t\tnamedValueInfo = updateNamedValueInfo(parameter, namedValueInfo);\n\t\t\tthis.namedValueInfoCache.put(parameter, namedValueInfo);\n\t\t}\n\t\treturn namedValueInfo;\n\t}\n\n\t/**\n\t * Create the {@link NamedValueInfo} object for the given method parameter.\n\t * Implementations typically retrieve the method annotation by means of\n\t * {@link MethodParameter#getParameterAnnotation(Class)}.\n\t * @param parameter the method parameter\n\t * @return the named value information\n\t */\n\tprotected abstract NamedValueInfo createNamedValueInfo(MethodParameter parameter);\n\n\t/**\n\t * Fall back on the parameter name from the class file if necessary and\n\t * replace {@link ValueConstants#DEFAULT_NONE} with null.\n\t */\n\tprivate NamedValueInfo updateNamedValueInfo(MethodParameter parameter, NamedValueInfo info) {\n\t\tString name = info.name;\n\t\tif (info.name.isEmpty()) {\n\t\t\tname = parameter.getParameterName();\n\t\t\tif (name == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"\"\"\n\t\t\t\t\t\tName for argument of type [%s] not specified, and parameter name information not \\\n\t\t\t\t\t\tavailable via reflection. Ensure that the compiler uses the '-parameters' flag.\"\"\"\n\t\t\t\t\t\t\t.formatted(parameter.getNestedParameterType().getName()));\n\t\t\t}\n\t\t}\n\t\treturn new NamedValueInfo(name, info.required,\n\t\t\t\tValueConstants.DEFAULT_NONE.equals(info.defaultValue) ? null : info.defaultValue);\n\t}\n\n\t/**\n\t * Resolve the given annotation-specified value,\n\t * potentially containing placeholders and expressions.\n\t */\n\t@Nullable\n\tprivate Object resolveEmbeddedValuesAndExpressions(String value) {\n\t\tif (this.configurableBeanFactory == null || this.expressionContext == null) {\n\t\t\treturn value;\n\t\t}\n\t\tString placeholdersResolved = this.configurableBeanFactory.resolveEmbeddedValue(value);\n\t\tBeanExpressionResolver exprResolver = this.configurableBeanFactory.getBeanExpressionResolver();\n\t\tif (exprResolver == null) {\n\t\t\treturn value;\n\t\t}\n\t\treturn exprResolver.evaluate(placeholdersResolved, this.expressionContext);\n\t}\n\n\t/**\n\t * Resolves the given parameter type and value name into an argument value.\n\t * @param parameter the method parameter to resolve to an argument value\n\t * @param message the current request\n\t * @param name the name of the value being resolved\n\t * @return the resolved argument. May be {@code null}\n\t * @throws Exception in case of errors\n\t */\n\t@Nullable\n\tprotected abstract Object resolveArgumentInternal(MethodParameter parameter, Message<?> message, String name)\n\t\t\tthrows Exception;\n\n\t/**\n\t * Invoked when a value is required, but {@link #resolveArgumentInternal}\n\t * returned {@code null} and there is no default value. Subclasses can\n\t * throw an appropriate exception for this case.\n\t * @param name the name for the value\n\t * @param parameter the target method parameter\n\t * @param message the message being processed\n\t */\n\tprotected abstract void handleMissingValue(String name, MethodParameter parameter, Message<?> message);\n\n\t/**\n\t * One last chance to handle a possible null value.\n\t * Specifically for booleans method parameters, use {@link Boolean#FALSE}.\n\t * Also raise an ISE for primitive types.\n\t */\n\t@Nullable\n\tprivate Object handleNullValue(String name, @Nullable Object value, Class<?> paramType) {\n\t\tif (value == null) {\n\t\t\tif (paramType == boolean.class) {\n\t\t\t\treturn Boolean.FALSE;\n\t\t\t}\n\t\t\telse if (paramType.isPrimitive()) {\n\t\t\t\tthrow new IllegalStateException(\"Optional \" + paramType + \" parameter '\" + name +\n\t\t\t\t\t\t\"' is present but cannot be translated into a null value due to being \" +\n\t\t\t\t\t\t\"declared as a primitive type. Consider declaring it as object wrapper \" +\n\t\t\t\t\t\t\"for the corresponding primitive type.\");\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}\n\n\t/**\n\t * Invoked after a value is resolved.\n\t * @param arg the resolved argument value\n\t * @param name the argument name\n\t * @param parameter the argument parameter type\n\t * @param message the message\n\t */\n\tprotected void handleResolvedValue(\n\t\t\t@Nullable Object arg, String name, MethodParameter parameter, Message<?> message) {\n\t}\n\n\n\t/**\n\t * Represents a named value declaration.\n\t */\n\tprotected static class NamedValueInfo {\n\n\t\tprivate final String name;\n\n\t\tprivate final boolean required;\n\n\t\t@Nullable\n\t\tprivate final String defaultValue;\n\n\t\tprotected NamedValueInfo(String name, boolean required, @Nullable String defaultValue) {\n\t\t\tthis.name = name;\n\t\t\tthis.required = required;\n\t\t\tthis.defaultValue = defaultValue;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.messaging.handler.annotation.support.AbstractNamedValueMethodArgumentResolver#createNamedValueInfo(parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the {@link NamedValueInfo} object for the given method parameter.\n\t * Implementations typically retrieve the method annotation by means of\n\t * {@link MethodParameter#getParameterAnnotation(Class)}.\n\t * @param parameter the method parameter\n\t * @return the named value information\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "NamedValueInfo",
    "signature": "protected NamedValueInfo createNamedValueInfo(MethodParameter parameter)",
    "source_code": "\tprotected abstract NamedValueInfo createNamedValueInfo(MethodParameter parameter);"
  },
  "org.springframework.messaging.handler.annotation.support.AbstractNamedValueMethodArgumentResolver#handleMissingValue(name,parameter,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked when a value is required, but {@link #resolveArgumentInternal}\n\t * returned {@code null} and there is no default value. Subclasses can\n\t * throw an appropriate exception for this case.\n\t * @param name the name for the value\n\t * @param parameter the target method parameter\n\t * @param message the message being processed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "void",
    "signature": "protected void handleMissingValue(String name, MethodParameter parameter, Message<?> message)",
    "source_code": "\tprotected abstract void handleMissingValue(String name, MethodParameter parameter, Message<?> message);"
  },
  "org.springframework.messaging.handler.annotation.support.AbstractNamedValueMethodArgumentResolver#handleResolvedValue(arg,name,parameter,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked after a value is resolved.\n\t * @param arg the resolved argument value\n\t * @param name the argument name\n\t * @param parameter the argument parameter type\n\t * @param message the message\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "arg",
      "name",
      "parameter",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "void",
    "signature": "protected void handleResolvedValue(@Nullable Object arg, String name, MethodParameter parameter, Message<?> message)",
    "source_code": "\tprotected void handleResolvedValue("
  },
  "org.springframework.messaging.handler.annotation.support.AbstractNamedValueMethodArgumentResolver#resolveArgument(parameter,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "Object",
    "signature": "public Object resolveArgument(MethodParameter parameter, Message<?> message)",
    "source_code": "\tpublic Object resolveArgument(MethodParameter parameter, Message<?> message) throws Exception {\n\t\tNamedValueInfo namedValueInfo = getNamedValueInfo(parameter);\n\t\tMethodParameter nestedParameter = parameter.nestedIfOptional();\n\n\t\tObject resolvedName = resolveEmbeddedValuesAndExpressions(namedValueInfo.name);\n\t\tif (resolvedName == null) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Specified name must not resolve to null: [\" + namedValueInfo.name + \"]\");\n\t\t}\n\n\t\tObject arg = resolveArgumentInternal(nestedParameter, message, resolvedName.toString());\n\t\tif (arg == null) {\n\t\t\tif (namedValueInfo.defaultValue != null) {\n\t\t\t\targ = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);\n\t\t\t}\n\t\t\telse if (namedValueInfo.required && !nestedParameter.isOptional()) {\n\t\t\t\thandleMissingValue(namedValueInfo.name, nestedParameter, message);\n\t\t\t}\n\t\t\targ = handleNullValue(namedValueInfo.name, arg, nestedParameter.getNestedParameterType());\n\t\t}\n\t\telse if (\"\".equals(arg) && namedValueInfo.defaultValue != null) {\n\t\t\targ = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);\n\t\t}\n\n\t\tif (parameter != nestedParameter || !ClassUtils.isAssignableValue(parameter.getParameterType(), arg)) {\n\t\t\targ = this.conversionService.convert(arg, new TypeDescriptor(parameter));\n\t\t\t// Check for null value after conversion of incoming argument value\n\t\t\tif (arg == null) {\n\t\t\t\tif (namedValueInfo.defaultValue != null) {\n\t\t\t\t\targ = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);\n\t\t\t\t}\n\t\t\t\telse if (namedValueInfo.required && !nestedParameter.isOptional()) {\n\t\t\t\t\thandleMissingValue(namedValueInfo.name, nestedParameter, message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\thandleResolvedValue(arg, namedValueInfo.name, parameter, message);\n\n\t\treturn arg;\n\t}"
  },
  "org.springframework.messaging.handler.annotation.support.AbstractNamedValueMethodArgumentResolver#resolveArgumentInternal(parameter,message,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolves the given parameter type and value name into an argument value.\n\t * @param parameter the method parameter to resolve to an argument value\n\t * @param message the current request\n\t * @param name the name of the value being resolved\n\t * @return the resolved argument. May be {@code null}\n\t * @throws Exception in case of errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "message",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "Object",
    "signature": "protected Object resolveArgumentInternal(MethodParameter parameter, Message<?> message, String name)",
    "source_code": "\tprotected abstract Object resolveArgumentInternal(MethodParameter parameter, Message<?> message, String name)"
  },
  "org.springframework.messaging.handler.annotation.support.NamedValueInfo": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Represents a named value declaration.\n\t */",
    "kind": "class",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "signature": "protected class NamedValueInfo",
    "source_code": "\tprotected static class NamedValueInfo {\n\n\t\tprivate final String name;\n\n\t\tprivate final boolean required;\n\n\t\t@Nullable\n\t\tprivate final String defaultValue;\n\n\t\tprotected NamedValueInfo(String name, boolean required, @Nullable String defaultValue) {\n\t\t\tthis.name = name;\n\t\t\tthis.required = required;\n\t\t\tthis.defaultValue = defaultValue;\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler#getPhase()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "int",
    "signature": "public int getPhase()",
    "source_code": "\tpublic int getPhase() {\n\t\treturn (this.phase != null ? this.phase : SmartLifecycle.super.getPhase());\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler#setPhase(phase)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the phase that this handler should run in.\n\t * <p>By default, this is {@link SmartLifecycle#DEFAULT_PHASE}.\n\t * @since 6.1.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "phase"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "void",
    "signature": "public void setPhase(int phase)",
    "source_code": "\tpublic void setPhase(int phase) {\n\t\tthis.phase = phase;\n\t}"
  },
  "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler#getPhase()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "int",
    "signature": "public int getPhase()",
    "source_code": "\tpublic int getPhase() {\n\t\treturn (this.phase != null ? this.phase : SmartLifecycle.super.getPhase());\n\t}"
  },
  "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler#setPhase(phase)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the phase that this handler should run in.\n\t * <p>By default, this is {@link SmartLifecycle#DEFAULT_PHASE}.\n\t * @since 6.1.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "phase"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "void",
    "signature": "public void setPhase(int phase)",
    "source_code": "\tpublic void setPhase(int phase) {\n\t\tthis.phase = phase;\n\t}"
  },
  "org.springframework.messaging.simp.broker.OrderedMessageChannelDecorator#run()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 197
    },
    "return": "void",
    "signature": "public void run()",
    "source_code": "\t\tpublic void run() {\n\t\t\tif (this.handledCount == null || this.handledCount.addAndGet(1) == subscriberCount) {\n\t\t\t\tif (OrderedMessageChannelDecorator.this.removeMessage(this.message)) {\n\t\t\t\t\tsendNextMessage();\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.OrderedMessageChannelDecorator#supportsOrderedMessages(channel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the channel has been {@link #configureInterceptor configured}\n\t * with an interceptor for sequential handling.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "channel"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "boolean",
    "signature": "public boolean supportsOrderedMessages(MessageChannel channel)",
    "source_code": "\tpublic static boolean supportsOrderedMessages(MessageChannel channel) {\n\t\treturn (channel instanceof ExecutorSubscribableChannel ch &&\n\t\t\t\tch.getInterceptors().stream().anyMatch(CallbackTaskInterceptor.class::isInstance));\n\t}"
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Provides essential configuration for handling messages with simple messaging\n * protocols such as STOMP.\n *\n * <p>{@link #clientInboundChannel} and {@link #clientOutboundChannel} deliver\n * messages to and from remote clients to several message handlers such as the\n * following.\n * <ul>\n * <li>{@link #simpAnnotationMethodMessageHandler}</li>\n * <li>{@link #simpleBrokerMessageHandler}</li>\n * <li>{@link #stompBrokerRelayMessageHandler}</li>\n * <li>{@link #userDestinationMessageHandler}</li>\n * </ul>\n *\n * <p>{@link #brokerChannel} delivers messages from within the application to the\n * respective message handlers. {@link #brokerMessagingTemplate} can be injected\n * into any application component to send messages.\n *\n * <p>Subclasses are responsible for the parts of the configuration that feed messages\n * to and from the client inbound/outbound channels (e.g. STOMP over WebSocket).\n *\n * @author Rossen Stoyanchev\n * @author Brian Clozel\n * @author Sebastien Deleuze\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "signature": "public class AbstractMessageBrokerConfiguration",
    "source_code": "public abstract class AbstractMessageBrokerConfiguration implements ApplicationContextAware {\n\n\tprivate static final String MVC_VALIDATOR_NAME = \"mvcValidator\";\n\n\tprivate static final boolean jackson2Present;\n\n\tprivate static final boolean gsonPresent;\n\n\tprivate static final boolean jsonbPresent;\n\n\tprivate static final boolean kotlinSerializationJsonPresent;\n\n\n\tstatic {\n\t\tClassLoader classLoader = AbstractMessageBrokerConfiguration.class.getClassLoader();\n\t\tjackson2Present = ClassUtils.isPresent(\"com.fasterxml.jackson.databind.ObjectMapper\", classLoader) &&\n\t\t\t\tClassUtils.isPresent(\"com.fasterxml.jackson.core.JsonGenerator\", classLoader);\n\t\tgsonPresent = ClassUtils.isPresent(\"com.google.gson.Gson\", classLoader);\n\t\tjsonbPresent = ClassUtils.isPresent(\"jakarta.json.bind.Jsonb\", classLoader);\n\t\tkotlinSerializationJsonPresent = ClassUtils.isPresent(\"kotlinx.serialization.json.Json\", classLoader);\n\t}\n\n\n\t@Nullable\n\tprivate ApplicationContext applicationContext;\n\n\t@Nullable\n\tprivate ChannelRegistration clientInboundChannelRegistration;\n\n\t@Nullable\n\tprivate ChannelRegistration clientOutboundChannelRegistration;\n\n\t@Nullable\n\tprivate MessageBrokerRegistry brokerRegistry;\n\n\t@Nullable\n\tprivate Integer phase;\n\n\n\t/**\n\t * Protected constructor.\n\t */\n\tprotected AbstractMessageBrokerConfiguration() {\n\t}\n\n\n\t@Override\n\tpublic void setApplicationContext(@Nullable ApplicationContext applicationContext) {\n\t\tthis.applicationContext = applicationContext;\n\t}\n\n\t@Nullable\n\tpublic ApplicationContext getApplicationContext() {\n\t\treturn this.applicationContext;\n\t}\n\n\n\t@Bean\n\tpublic AbstractSubscribableChannel clientInboundChannel(\n\t\t\t@Qualifier(\"clientInboundChannelExecutor\") TaskExecutor executor) {\n\n\t\tExecutorSubscribableChannel channel = new ExecutorSubscribableChannel(executor);\n\t\tchannel.setLogger(SimpLogging.forLog(channel.getLogger()));\n\t\tChannelRegistration reg = getClientInboundChannelRegistration();\n\t\tif (reg.hasInterceptors()) {\n\t\t\tchannel.setInterceptors(reg.getInterceptors());\n\t\t}\n\t\treturn channel;\n\t}\n\n\t@Bean\n\tpublic TaskExecutor clientInboundChannelExecutor() {\n\t\tChannelRegistration registration = getClientInboundChannelRegistration();\n\t\tTaskExecutor executor = getTaskExecutor(registration, \"clientInboundChannel-\", this::defaultTaskExecutor);\n\t\tif (executor instanceof ExecutorConfigurationSupport executorSupport) {\n\t\t\texecutorSupport.setPhase(getPhase());\n\t\t}\n\t\treturn executor;\n\t}\n\n\tprotected final ChannelRegistration getClientInboundChannelRegistration() {\n\t\tif (this.clientInboundChannelRegistration == null) {\n\t\t\tChannelRegistration registration = new ChannelRegistration();\n\t\t\tconfigureClientInboundChannel(registration);\n\t\t\tregistration.interceptors(new ImmutableMessageChannelInterceptor());\n\t\t\tthis.clientInboundChannelRegistration = registration;\n\t\t}\n\t\treturn this.clientInboundChannelRegistration;\n\t}\n\n\tprotected final int getPhase() {\n\t\tif (this.phase == null) {\n\t\t\tthis.phase = initPhase();\n\t\t}\n\t\treturn this.phase;\n\t}\n\n\tprotected int initPhase() {\n\t\treturn SmartLifecycle.DEFAULT_PHASE;\n\t}\n\n\t/**\n\t * A hook for subclasses to customize the message channel for inbound messages\n\t * from WebSocket clients.\n\t */\n\tprotected void configureClientInboundChannel(ChannelRegistration registration) {\n\t}\n\n\t@Bean\n\tpublic AbstractSubscribableChannel clientOutboundChannel(\n\t\t\t@Qualifier(\"clientOutboundChannelExecutor\") TaskExecutor executor) {\n\n\t\tExecutorSubscribableChannel channel = new ExecutorSubscribableChannel(executor);\n\t\tchannel.setLogger(SimpLogging.forLog(channel.getLogger()));\n\t\tChannelRegistration registration = getClientOutboundChannelRegistration();\n\t\tif (registration.hasInterceptors()) {\n\t\t\tchannel.setInterceptors(registration.getInterceptors());\n\t\t}\n\t\treturn channel;\n\t}\n\n\t@Bean\n\tpublic TaskExecutor clientOutboundChannelExecutor() {\n\t\tChannelRegistration registration = getClientOutboundChannelRegistration();\n\t\tTaskExecutor executor = getTaskExecutor(registration, \"clientOutboundChannel-\", this::defaultTaskExecutor);\n\t\tif (executor instanceof ExecutorConfigurationSupport executorSupport) {\n\t\t\texecutorSupport.setPhase(getPhase());\n\t\t}\n\t\treturn executor;\n\t}\n\n\tprotected final ChannelRegistration getClientOutboundChannelRegistration() {\n\t\tif (this.clientOutboundChannelRegistration == null) {\n\t\t\tChannelRegistration registration = new ChannelRegistration();\n\t\t\tconfigureClientOutboundChannel(registration);\n\t\t\tregistration.interceptors(new ImmutableMessageChannelInterceptor());\n\t\t\tthis.clientOutboundChannelRegistration = registration;\n\t\t}\n\t\treturn this.clientOutboundChannelRegistration;\n\t}\n\n\t/**\n\t * A hook for subclasses to customize the message channel for messages from\n\t * the application or message broker to WebSocket clients.\n\t */\n\tprotected void configureClientOutboundChannel(ChannelRegistration registration) {\n\t}\n\n\t@Bean\n\tpublic AbstractSubscribableChannel brokerChannel(\n\t\t\tAbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel,\n\t\t\t@Qualifier(\"brokerChannelExecutor\") TaskExecutor executor) {\n\n\t\tMessageBrokerRegistry registry = getBrokerRegistry(clientInboundChannel, clientOutboundChannel);\n\t\tChannelRegistration registration = registry.getBrokerChannelRegistration();\n\t\tExecutorSubscribableChannel channel = (registration.hasTaskExecutor() ?\n\t\t\t\tnew ExecutorSubscribableChannel(executor) : new ExecutorSubscribableChannel());\n\t\tregistration.interceptors(new ImmutableMessageChannelInterceptor());\n\t\tchannel.setLogger(SimpLogging.forLog(channel.getLogger()));\n\t\tchannel.setInterceptors(registration.getInterceptors());\n\t\treturn channel;\n\t}\n\n\t@Bean\n\tpublic TaskExecutor brokerChannelExecutor(\n\t\t\tAbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel) {\n\n\t\tMessageBrokerRegistry registry = getBrokerRegistry(clientInboundChannel, clientOutboundChannel);\n\t\tChannelRegistration registration = registry.getBrokerChannelRegistration();\n\t\tTaskExecutor executor = getTaskExecutor(registration, \"brokerChannel-\", () -> {\n\t\t\t// Should never be used\n\t\t\tThreadPoolTaskExecutor threadPoolTaskExecutor = new ThreadPoolTaskExecutor();\n\t\t\tthreadPoolTaskExecutor.setCorePoolSize(0);\n\t\t\tthreadPoolTaskExecutor.setMaxPoolSize(1);\n\t\t\tthreadPoolTaskExecutor.setQueueCapacity(0);\n\t\t\treturn threadPoolTaskExecutor;\n\t\t});\n\t\tif (executor instanceof ExecutorConfigurationSupport executorSupport) {\n\t\t\texecutorSupport.setPhase(getPhase());\n\t\t}\n\t\treturn executor;\n\t}\n\n\tprivate TaskExecutor defaultTaskExecutor() {\n\t\treturn new TaskExecutorRegistration().getTaskExecutor();\n\t}\n\n\tprivate static TaskExecutor getTaskExecutor(ChannelRegistration registration,\n\t\t\tString threadNamePrefix, Supplier<TaskExecutor> fallback) {\n\n\t\treturn registration.getTaskExecutor(fallback,\n\t\t\t\texecutor -> setThreadNamePrefix(executor, threadNamePrefix));\n\t}\n\n\tprivate static void setThreadNamePrefix(TaskExecutor taskExecutor, String name) {\n\t\tif (taskExecutor instanceof CustomizableThreadCreator ctc) {\n\t\t\tctc.setThreadNamePrefix(name);\n\t\t}\n\t}\n\n\t/**\n\t * An accessor for the {@link MessageBrokerRegistry} that ensures its one-time creation\n\t * and initialization through {@link #configureMessageBroker(MessageBrokerRegistry)}.\n\t */\n\tprotected final MessageBrokerRegistry getBrokerRegistry(\n\t\t\tAbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel) {\n\n\t\tif (this.brokerRegistry == null) {\n\t\t\tMessageBrokerRegistry registry = new MessageBrokerRegistry(clientInboundChannel, clientOutboundChannel);\n\t\t\tconfigureMessageBroker(registry);\n\t\t\tthis.brokerRegistry = registry;\n\t\t}\n\t\treturn this.brokerRegistry;\n\t}\n\n\t/**\n\t * A hook for subclasses to customize message broker configuration through the\n\t * provided {@link MessageBrokerRegistry} instance.\n\t */\n\tprotected void configureMessageBroker(MessageBrokerRegistry registry) {\n\t}\n\n\t/**\n\t * Provide access to the configured PatchMatcher for access from other\n\t * configuration classes.\n\t */\n\t@Nullable\n\tpublic final PathMatcher getPathMatcher(\n\t\t\tAbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel) {\n\n\t\treturn getBrokerRegistry(clientInboundChannel, clientOutboundChannel).getPathMatcher();\n\t}\n\n\t@Bean\n\tpublic SimpAnnotationMethodMessageHandler simpAnnotationMethodMessageHandler(\n\t\t\tAbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel,\n\t\t\tSimpMessagingTemplate brokerMessagingTemplate, CompositeMessageConverter brokerMessageConverter) {\n\n\t\tSimpAnnotationMethodMessageHandler handler = createAnnotationMethodMessageHandler(\n\t\t\t\t\t\tclientInboundChannel, clientOutboundChannel, brokerMessagingTemplate);\n\n\t\tMessageBrokerRegistry brokerRegistry = getBrokerRegistry(clientInboundChannel, clientOutboundChannel);\n\t\thandler.setDestinationPrefixes(brokerRegistry.getApplicationDestinationPrefixes());\n\t\thandler.setMessageConverter(brokerMessageConverter);\n\t\thandler.setValidator(simpValidator());\n\t\thandler.setPhase(getPhase());\n\n\t\tList<HandlerMethodArgumentResolver> argumentResolvers = new ArrayList<>();\n\t\taddArgumentResolvers(argumentResolvers);\n\t\thandler.setCustomArgumentResolvers(argumentResolvers);\n\n\t\tList<HandlerMethodReturnValueHandler> returnValueHandlers = new ArrayList<>();\n\t\taddReturnValueHandlers(returnValueHandlers);\n\t\thandler.setCustomReturnValueHandlers(returnValueHandlers);\n\n\t\tPathMatcher pathMatcher = brokerRegistry.getPathMatcher();\n\t\tif (pathMatcher != null) {\n\t\t\thandler.setPathMatcher(pathMatcher);\n\t\t}\n\n\t\treturn handler;\n\t}\n\n\t/**\n\t * Protected method for plugging in a custom subclass of\n\t * {@link org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler\n\t * SimpAnnotationMethodMessageHandler}.\n\t * @since 5.3.2\n\t */\n\tprotected SimpAnnotationMethodMessageHandler createAnnotationMethodMessageHandler(\n\t\t\tAbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel,\n\t\t\tSimpMessagingTemplate brokerMessagingTemplate) {\n\n\t\tSimpAnnotationMethodMessageHandler handler = new SimpAnnotationMethodMessageHandler(\n\t\t\t\tclientInboundChannel, clientOutboundChannel, brokerMessagingTemplate);\n\n\t\thandler.setPhase(getPhase());\n\t\treturn handler;\n\t}\n\n\tprotected void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {\n\t}\n\n\tprotected void addReturnValueHandlers(List<HandlerMethodReturnValueHandler> returnValueHandlers) {\n\t}\n\n\t@Bean\n\t@Nullable\n\tpublic AbstractBrokerMessageHandler simpleBrokerMessageHandler(\n\t\t\tAbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel,\n\t\t\tAbstractSubscribableChannel brokerChannel, UserDestinationResolver userDestinationResolver) {\n\n\t\tMessageBrokerRegistry registry = getBrokerRegistry(clientInboundChannel, clientOutboundChannel);\n\t\tSimpleBrokerMessageHandler handler = registry.getSimpleBroker(brokerChannel);\n\t\tif (handler == null) {\n\t\t\treturn null;\n\t\t}\n\t\tupdateUserDestinationResolver(handler, userDestinationResolver, registry.getUserDestinationPrefix());\n\t\thandler.setPhase(getPhase());\n\t\treturn handler;\n\t}\n\n\tprivate void updateUserDestinationResolver(\n\t\t\tAbstractBrokerMessageHandler handler, UserDestinationResolver userDestinationResolver,\n\t\t\t@Nullable String userDestinationPrefix) {\n\n\t\tCollection<String> prefixes = handler.getDestinationPrefixes();\n\t\tif (!prefixes.isEmpty() && !prefixes.iterator().next().startsWith(\"/\")) {\n\t\t\t((DefaultUserDestinationResolver) userDestinationResolver).setRemoveLeadingSlash(true);\n\t\t}\n\t\tif (StringUtils.hasText(userDestinationPrefix)) {\n\t\t\thandler.setUserDestinationPredicate(destination -> destination.startsWith(userDestinationPrefix));\n\t\t}\n\t}\n\n\t@Bean\n\t@Nullable\n\tpublic AbstractBrokerMessageHandler stompBrokerRelayMessageHandler(\n\t\t\tAbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel,\n\t\t\tAbstractSubscribableChannel brokerChannel, UserDestinationMessageHandler userDestinationMessageHandler,\n\t\t\t@Nullable MessageHandler userRegistryMessageHandler, UserDestinationResolver userDestinationResolver) {\n\n\t\tMessageBrokerRegistry registry = getBrokerRegistry(clientInboundChannel, clientOutboundChannel);\n\t\tStompBrokerRelayMessageHandler handler = registry.getStompBrokerRelay(brokerChannel);\n\t\tif (handler == null) {\n\t\t\treturn null;\n\t\t}\n\t\tMap<String, MessageHandler> subscriptions = new HashMap<>(4);\n\t\tString destination = registry.getUserDestinationBroadcast();\n\t\tif (destination != null) {\n\t\t\tsubscriptions.put(destination, userDestinationMessageHandler);\n\t\t}\n\t\tdestination = registry.getUserRegistryBroadcast();\n\t\tif (destination != null) {\n\t\t\tsubscriptions.put(destination, userRegistryMessageHandler);\n\t\t}\n\t\thandler.setSystemSubscriptions(subscriptions);\n\t\tupdateUserDestinationResolver(handler, userDestinationResolver, registry.getUserDestinationPrefix());\n\t\thandler.setPhase(getPhase());\n\t\treturn handler;\n\t}\n\n\t@Bean\n\tpublic UserDestinationMessageHandler userDestinationMessageHandler(\n\t\t\tAbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel,\n\t\t\tAbstractSubscribableChannel brokerChannel, UserDestinationResolver userDestinationResolver) {\n\n\t\tUserDestinationMessageHandler handler =\n\t\t\t\tnew UserDestinationMessageHandler(clientInboundChannel, brokerChannel, userDestinationResolver);\n\n\t\tMessageBrokerRegistry registry = getBrokerRegistry(clientInboundChannel, clientOutboundChannel);\n\t\tString destination = registry.getUserDestinationBroadcast();\n\t\tif (destination != null) {\n\t\t\thandler.setBroadcastDestination(destination);\n\t\t}\n\t\thandler.setPhase(getPhase());\n\t\treturn handler;\n\t}\n\n\t@Bean\n\t@Nullable\n\tpublic MessageHandler userRegistryMessageHandler(\n\t\t\tAbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel,\n\t\t\tSimpUserRegistry userRegistry, SimpMessagingTemplate brokerMessagingTemplate,\n\t\t\t@Qualifier(\"messageBrokerTaskScheduler\") TaskScheduler scheduler) {\n\n\t\tMessageBrokerRegistry brokerRegistry = getBrokerRegistry(clientInboundChannel, clientOutboundChannel);\n\t\tif (brokerRegistry.getUserRegistryBroadcast() == null) {\n\t\t\treturn null;\n\t\t}\n\t\tAssert.isInstanceOf(MultiServerUserRegistry.class, userRegistry, \"MultiServerUserRegistry required\");\n\t\treturn new UserRegistryMessageHandler((MultiServerUserRegistry) userRegistry,\n\t\t\t\tbrokerMessagingTemplate, brokerRegistry.getUserRegistryBroadcast(),\n\t\t\t\tscheduler);\n\t}\n\n\t// Expose alias for 4.1 compatibility\n\t@Bean(name = {\"messageBrokerTaskScheduler\", \"messageBrokerSockJsTaskScheduler\"})\n\tpublic TaskScheduler messageBrokerTaskScheduler() {\n\t\tThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler();\n\t\tscheduler.setThreadNamePrefix(\"MessageBroker-\");\n\t\tscheduler.setPoolSize(Runtime.getRuntime().availableProcessors());\n\t\tscheduler.setRemoveOnCancelPolicy(true);\n\t\tscheduler.setPhase(getPhase());\n\t\treturn scheduler;\n\t}\n\n\t@Bean\n\tpublic SimpMessagingTemplate brokerMessagingTemplate(\n\t\t\tAbstractSubscribableChannel brokerChannel, AbstractSubscribableChannel clientInboundChannel,\n\t\t\tAbstractSubscribableChannel clientOutboundChannel, CompositeMessageConverter brokerMessageConverter) {\n\n\t\tSimpMessagingTemplate template = new SimpMessagingTemplate(brokerChannel);\n\t\tMessageBrokerRegistry registry = getBrokerRegistry(clientInboundChannel, clientOutboundChannel);\n\t\tString prefix = registry.getUserDestinationPrefix();\n\t\tif (prefix != null) {\n\t\t\ttemplate.setUserDestinationPrefix(prefix);\n\t\t}\n\t\ttemplate.setMessageConverter(brokerMessageConverter);\n\t\treturn template;\n\t}\n\n\t@Bean\n\tpublic CompositeMessageConverter brokerMessageConverter() {\n\t\tList<MessageConverter> converters = new ArrayList<>();\n\t\tboolean registerDefaults = configureMessageConverters(converters);\n\t\tif (registerDefaults) {\n\t\t\tconverters.add(new StringMessageConverter());\n\t\t\tconverters.add(new ByteArrayMessageConverter());\n\t\t\tif (kotlinSerializationJsonPresent) {\n\t\t\t\tconverters.add(new KotlinSerializationJsonMessageConverter());\n\t\t\t}\n\t\t\tif (jackson2Present) {\n\t\t\t\tconverters.add(createJacksonConverter());\n\t\t\t}\n\t\t\telse if (gsonPresent) {\n\t\t\t\tconverters.add(new GsonMessageConverter());\n\t\t\t}\n\t\t\telse if (jsonbPresent) {\n\t\t\t\tconverters.add(new JsonbMessageConverter());\n\t\t\t}\n\t\t}\n\t\treturn new CompositeMessageConverter(converters);\n\t}\n\n\tprotected MappingJackson2MessageConverter createJacksonConverter() {\n\t\tDefaultContentTypeResolver resolver = new DefaultContentTypeResolver();\n\t\tresolver.setDefaultMimeType(MimeTypeUtils.APPLICATION_JSON);\n\t\tMappingJackson2MessageConverter converter = new MappingJackson2MessageConverter();\n\t\tconverter.setContentTypeResolver(resolver);\n\t\treturn converter;\n\t}\n\n\t/**\n\t * Override this method to add custom message converters.\n\t * @param messageConverters the list to add converters to, initially empty\n\t * @return {@code true} if default message converters should be added to list,\n\t * {@code false} if no more converters should be added\n\t */\n\tprotected boolean configureMessageConverters(List<MessageConverter> messageConverters) {\n\t\treturn true;\n\t}\n\n\t@Bean\n\tpublic UserDestinationResolver userDestinationResolver(\n\t\t\tSimpUserRegistry userRegistry, AbstractSubscribableChannel clientInboundChannel,\n\t\t\tAbstractSubscribableChannel clientOutboundChannel) {\n\n\t\tDefaultUserDestinationResolver resolver = new DefaultUserDestinationResolver(userRegistry);\n\t\tMessageBrokerRegistry registry = getBrokerRegistry(clientInboundChannel, clientOutboundChannel);\n\t\tString prefix = registry.getUserDestinationPrefix();\n\t\tif (prefix != null) {\n\t\t\tresolver.setUserDestinationPrefix(prefix);\n\t\t}\n\t\treturn resolver;\n\t}\n\n\t@Bean\n\tpublic SimpUserRegistry userRegistry(\n\t\t\tAbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel) {\n\n\t\tMessageBrokerRegistry brokerRegistry = getBrokerRegistry(clientInboundChannel, clientOutboundChannel);\n\t\tSimpUserRegistry userRegistry = createLocalUserRegistry(brokerRegistry.getUserRegistryOrder());\n\t\tboolean broadcast = brokerRegistry.getUserRegistryBroadcast() != null;\n\t\treturn (broadcast ? new MultiServerUserRegistry(userRegistry) : userRegistry);\n\t}\n\n\t/**\n\t * Create the user registry that provides access to local users.\n\t * @param order the order to use as a {@link SmartApplicationListener}.\n\t * @since 5.1\n\t */\n\tprotected abstract SimpUserRegistry createLocalUserRegistry(@Nullable Integer order);\n\n\t/**\n\t * Return an {@link org.springframework.validation.Validator} instance for\n\t * validating {@code @Payload} method arguments.\n\t * <p>In order, this method tries to get a Validator instance:\n\t * <ul>\n\t * <li>delegating to getValidator() first</li>\n\t * <li>if none returned, getting an existing instance with its well-known name \"mvcValidator\",\n\t * created by an MVC configuration</li>\n\t * <li>if none returned, checking the classpath for the presence of a JSR-303 implementation\n\t * before creating a {@code OptionalValidatorFactoryBean}</li>\n\t * <li>returning a no-op Validator instance</li>\n\t * </ul>\n\t */\n\tprotected Validator simpValidator() {\n\t\tValidator validator = getValidator();\n\t\tif (validator == null) {\n\t\t\tif (this.applicationContext != null && this.applicationContext.containsBean(MVC_VALIDATOR_NAME)) {\n\t\t\t\tvalidator = this.applicationContext.getBean(MVC_VALIDATOR_NAME, Validator.class);\n\t\t\t}\n\t\t\telse if (ClassUtils.isPresent(\"jakarta.validation.Validator\", getClass().getClassLoader())) {\n\t\t\t\ttry {\n\t\t\t\t\tvalidator = new OptionalValidatorFactoryBean();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tthrow new BeanInitializationException(\"Failed to create default validator\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalidator = new Validator() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean supports(Class<?> clazz) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void validate(@Nullable Object target, Errors errors) {\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\treturn validator;\n\t}\n\n\t/**\n\t * Override this method to provide a custom {@link Validator}.\n\t * @since 4.0.1\n\t */\n\t@Nullable\n\tpublic Validator getValidator() {\n\t\treturn null;\n\t}\n\n}"
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#addArgumentResolvers(argumentResolvers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "argumentResolvers"
    ],
    "position": {
      "column": 1,
      "line": 382
    },
    "return": "void",
    "signature": "protected void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers)",
    "source_code": "\tprotected void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {\n\t}"
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#addReturnValueHandlers(returnValueHandlers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "returnValueHandlers"
    ],
    "position": {
      "column": 1,
      "line": 385
    },
    "return": "void",
    "signature": "protected void addReturnValueHandlers(List<HandlerMethodReturnValueHandler> returnValueHandlers)",
    "source_code": "\tprotected void addReturnValueHandlers(List<HandlerMethodReturnValueHandler> returnValueHandlers) {\n\t}"
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#brokerChannel(clientInboundChannel,clientOutboundChannel,@Qualifier(\"brokerChannelExecutor\")": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel",
      "@Qualifier(\"brokerChannelExecutor\""
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "AbstractSubscribableChannel",
    "signature": "public AbstractSubscribableChannel brokerChannel(AbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel,\n\t\t\t@Qualifier(\"brokerChannelExecutor\")",
    "source_code": "\tpublic AbstractSubscribableChannel brokerChannel("
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#brokerChannelExecutor(clientInboundChannel,clientOutboundChannel)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel"
    ],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "TaskExecutor",
    "signature": "public TaskExecutor brokerChannelExecutor(AbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel)",
    "source_code": "\tpublic TaskExecutor brokerChannelExecutor("
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#brokerMessageConverter()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 505
    },
    "return": "CompositeMessageConverter",
    "signature": "public CompositeMessageConverter brokerMessageConverter()",
    "source_code": "\tpublic CompositeMessageConverter brokerMessageConverter() {\n\t\tList<MessageConverter> converters = new ArrayList<>();\n\t\tboolean registerDefaults = configureMessageConverters(converters);\n\t\tif (registerDefaults) {\n\t\t\tconverters.add(new StringMessageConverter());\n\t\t\tconverters.add(new ByteArrayMessageConverter());\n\t\t\tif (kotlinSerializationJsonPresent) {\n\t\t\t\tconverters.add(new KotlinSerializationJsonMessageConverter());\n\t\t\t}\n\t\t\tif (jackson2Present) {\n\t\t\t\tconverters.add(createJacksonConverter());\n\t\t\t}\n\t\t\telse if (gsonPresent) {\n\t\t\t\tconverters.add(new GsonMessageConverter());\n\t\t\t}\n\t\t\telse if (jsonbPresent) {\n\t\t\t\tconverters.add(new JsonbMessageConverter());\n\t\t\t}\n\t\t}\n\t\treturn new CompositeMessageConverter(converters);\n\t}"
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#brokerMessagingTemplate(brokerChannel,clientInboundChannel,clientOutboundChannel,brokerMessageConverter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "brokerChannel",
      "clientInboundChannel",
      "clientOutboundChannel",
      "brokerMessageConverter"
    ],
    "position": {
      "column": 1,
      "line": 490
    },
    "return": "SimpMessagingTemplate",
    "signature": "public SimpMessagingTemplate brokerMessagingTemplate(AbstractSubscribableChannel brokerChannel, AbstractSubscribableChannel clientInboundChannel,\n\t\t\tAbstractSubscribableChannel clientOutboundChannel, CompositeMessageConverter brokerMessageConverter)",
    "source_code": "\tpublic SimpMessagingTemplate brokerMessagingTemplate("
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#clientInboundChannel(@Qualifier(\"clientInboundChannelExecutor\")": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "@Qualifier(\"clientInboundChannelExecutor\""
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "AbstractSubscribableChannel",
    "signature": "public AbstractSubscribableChannel clientInboundChannel(@Qualifier(\"clientInboundChannelExecutor\")",
    "source_code": "\tpublic AbstractSubscribableChannel clientInboundChannel("
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#clientInboundChannelExecutor()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "TaskExecutor",
    "signature": "public TaskExecutor clientInboundChannelExecutor()",
    "source_code": "\tpublic TaskExecutor clientInboundChannelExecutor() {\n\t\tChannelRegistration registration = getClientInboundChannelRegistration();\n\t\tTaskExecutor executor = getTaskExecutor(registration, \"clientInboundChannel-\", this::defaultTaskExecutor);\n\t\tif (executor instanceof ExecutorConfigurationSupport executorSupport) {\n\t\t\texecutorSupport.setPhase(getPhase());\n\t\t}\n\t\treturn executor;\n\t}"
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#clientOutboundChannel(@Qualifier(\"clientOutboundChannelExecutor\")": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "@Qualifier(\"clientOutboundChannelExecutor\""
    ],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "AbstractSubscribableChannel",
    "signature": "public AbstractSubscribableChannel clientOutboundChannel(@Qualifier(\"clientOutboundChannelExecutor\")",
    "source_code": "\tpublic AbstractSubscribableChannel clientOutboundChannel("
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#clientOutboundChannelExecutor()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "TaskExecutor",
    "signature": "public TaskExecutor clientOutboundChannelExecutor()",
    "source_code": "\tpublic TaskExecutor clientOutboundChannelExecutor() {\n\t\tChannelRegistration registration = getClientOutboundChannelRegistration();\n\t\tTaskExecutor executor = getTaskExecutor(registration, \"clientOutboundChannel-\", this::defaultTaskExecutor);\n\t\tif (executor instanceof ExecutorConfigurationSupport executorSupport) {\n\t\t\texecutorSupport.setPhase(getPhase());\n\t\t}\n\t\treturn executor;\n\t}"
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#configureClientInboundChannel(registration)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A hook for subclasses to customize the message channel for inbound messages\n\t * from WebSocket clients.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "registration"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "void",
    "signature": "protected void configureClientInboundChannel(ChannelRegistration registration)",
    "source_code": "\tprotected void configureClientInboundChannel(ChannelRegistration registration) {\n\t}"
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#configureClientOutboundChannel(registration)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A hook for subclasses to customize the message channel for messages from\n\t * the application or message broker to WebSocket clients.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "registration"
    ],
    "position": {
      "column": 1,
      "line": 247
    },
    "return": "void",
    "signature": "protected void configureClientOutboundChannel(ChannelRegistration registration)",
    "source_code": "\tprotected void configureClientOutboundChannel(ChannelRegistration registration) {\n\t}"
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#configureMessageBroker(registry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A hook for subclasses to customize message broker configuration through the\n\t * provided {@link MessageBrokerRegistry} instance.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 321
    },
    "return": "void",
    "signature": "protected void configureMessageBroker(MessageBrokerRegistry registry)",
    "source_code": "\tprotected void configureMessageBroker(MessageBrokerRegistry registry) {\n\t}"
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#configureMessageConverters(messageConverters)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Override this method to add custom message converters.\n\t * @param messageConverters the list to add converters to, initially empty\n\t * @return {@code true} if default message converters should be added to list,\n\t * {@code false} if no more converters should be added\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "messageConverters"
    ],
    "position": {
      "column": 1,
      "line": 541
    },
    "return": "boolean",
    "signature": "protected boolean configureMessageConverters(List<MessageConverter> messageConverters)",
    "source_code": "\tprotected boolean configureMessageConverters(List<MessageConverter> messageConverters) {\n\t\treturn true;\n\t}"
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#createAnnotationMethodMessageHandler(clientInboundChannel,clientOutboundChannel,brokerMessagingTemplate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Protected method for plugging in a custom subclass of\n\t * {@link org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler\n\t * SimpAnnotationMethodMessageHandler}.\n\t * @since 5.3.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel",
      "brokerMessagingTemplate"
    ],
    "position": {
      "column": 1,
      "line": 371
    },
    "return": "SimpAnnotationMethodMessageHandler",
    "signature": "protected SimpAnnotationMethodMessageHandler createAnnotationMethodMessageHandler(AbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel,\n\t\t\tSimpMessagingTemplate brokerMessagingTemplate)",
    "source_code": "\tprotected SimpAnnotationMethodMessageHandler createAnnotationMethodMessageHandler("
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#createJacksonConverter()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 527
    },
    "return": "MappingJackson2MessageConverter",
    "signature": "protected MappingJackson2MessageConverter createJacksonConverter()",
    "source_code": "\tprotected MappingJackson2MessageConverter createJacksonConverter() {\n\t\tDefaultContentTypeResolver resolver = new DefaultContentTypeResolver();\n\t\tresolver.setDefaultMimeType(MimeTypeUtils.APPLICATION_JSON);\n\t\tMappingJackson2MessageConverter converter = new MappingJackson2MessageConverter();\n\t\tconverter.setContentTypeResolver(resolver);\n\t\treturn converter;\n\t}"
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#createLocalUserRegistry(order)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the user registry that provides access to local users.\n\t * @param order the order to use as a {@link SmartApplicationListener}.\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "order"
    ],
    "position": {
      "column": 1,
      "line": 574
    },
    "return": "SimpUserRegistry",
    "signature": "protected SimpUserRegistry createLocalUserRegistry(@Nullable Integer order)",
    "source_code": "\tprotected abstract SimpUserRegistry createLocalUserRegistry(@Nullable Integer order);"
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#getApplicationContext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "ApplicationContext",
    "signature": "public ApplicationContext getApplicationContext()",
    "source_code": "\tpublic ApplicationContext getApplicationContext() {\n\t\treturn this.applicationContext;\n\t}"
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#getBrokerRegistry(clientInboundChannel,clientOutboundChannel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An accessor for the {@link MessageBrokerRegistry} that ensures its one-time creation\n\t * and initialization through {@link #configureMessageBroker(MessageBrokerRegistry)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel"
    ],
    "position": {
      "column": 1,
      "line": 306
    },
    "return": "MessageBrokerRegistry",
    "signature": "protected MessageBrokerRegistry getBrokerRegistry(AbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel)",
    "source_code": "\tprotected final MessageBrokerRegistry getBrokerRegistry("
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#getClientInboundChannelRegistration()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "ChannelRegistration",
    "signature": "protected ChannelRegistration getClientInboundChannelRegistration()",
    "source_code": "\tprotected final ChannelRegistration getClientInboundChannelRegistration() {\n\t\tif (this.clientInboundChannelRegistration == null) {\n\t\t\tChannelRegistration registration = new ChannelRegistration();\n\t\t\tconfigureClientInboundChannel(registration);\n\t\t\tregistration.interceptors(new ImmutableMessageChannelInterceptor());\n\t\t\tthis.clientInboundChannelRegistration = registration;\n\t\t}\n\t\treturn this.clientInboundChannelRegistration;\n\t}"
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#getClientOutboundChannelRegistration()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "ChannelRegistration",
    "signature": "protected ChannelRegistration getClientOutboundChannelRegistration()",
    "source_code": "\tprotected final ChannelRegistration getClientOutboundChannelRegistration() {\n\t\tif (this.clientOutboundChannelRegistration == null) {\n\t\t\tChannelRegistration registration = new ChannelRegistration();\n\t\t\tconfigureClientOutboundChannel(registration);\n\t\t\tregistration.interceptors(new ImmutableMessageChannelInterceptor());\n\t\t\tthis.clientOutboundChannelRegistration = registration;\n\t\t}\n\t\treturn this.clientOutboundChannelRegistration;\n\t}"
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#getPathMatcher(clientInboundChannel,clientOutboundChannel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide access to the configured PatchMatcher for access from other\n\t * configuration classes.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel"
    ],
    "position": {
      "column": 1,
      "line": 329
    },
    "return": "PathMatcher",
    "signature": "public PathMatcher getPathMatcher(AbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel)",
    "source_code": "\tpublic final PathMatcher getPathMatcher("
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#getPhase()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "int",
    "signature": "protected int getPhase()",
    "source_code": "\tprotected final int getPhase() {\n\t\tif (this.phase == null) {\n\t\t\tthis.phase = initPhase();\n\t\t}\n\t\treturn this.phase;\n\t}"
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#getValidator()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Override this method to provide a custom {@link Validator}.\n\t * @since 4.0.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 623
    },
    "return": "Validator",
    "signature": "public Validator getValidator()",
    "source_code": "\tpublic Validator getValidator() {\n\t\treturn null;\n\t}"
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#initPhase()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "int",
    "signature": "protected int initPhase()",
    "source_code": "\tprotected int initPhase() {\n\t\treturn SmartLifecycle.DEFAULT_PHASE;\n\t}"
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#messageBrokerTaskScheduler()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 480
    },
    "return": "TaskScheduler",
    "signature": "public TaskScheduler messageBrokerTaskScheduler()",
    "source_code": "\tpublic TaskScheduler messageBrokerTaskScheduler() {\n\t\tThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler();\n\t\tscheduler.setThreadNamePrefix(\"MessageBroker-\");\n\t\tscheduler.setPoolSize(Runtime.getRuntime().availableProcessors());\n\t\tscheduler.setRemoveOnCancelPolicy(true);\n\t\tscheduler.setPhase(getPhase());\n\t\treturn scheduler;\n\t}"
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#setApplicationContext(applicationContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "applicationContext"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "void",
    "signature": "public void setApplicationContext(@Nullable ApplicationContext applicationContext)",
    "source_code": "\tpublic void setApplicationContext(@Nullable ApplicationContext applicationContext) {\n\t\tthis.applicationContext = applicationContext;\n\t}"
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#simpAnnotationMethodMessageHandler(clientInboundChannel,clientOutboundChannel,brokerMessagingTemplate,brokerMessageConverter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel",
      "brokerMessagingTemplate",
      "brokerMessageConverter"
    ],
    "position": {
      "column": 1,
      "line": 336
    },
    "return": "SimpAnnotationMethodMessageHandler",
    "signature": "public SimpAnnotationMethodMessageHandler simpAnnotationMethodMessageHandler(AbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel,\n\t\t\tSimpMessagingTemplate brokerMessagingTemplate, CompositeMessageConverter brokerMessageConverter)",
    "source_code": "\tpublic SimpAnnotationMethodMessageHandler simpAnnotationMethodMessageHandler("
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#simpValidator()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return an {@link org.springframework.validation.Validator} instance for\n\t * validating {@code @Payload} method arguments.\n\t * <p>In order, this method tries to get a Validator instance:\n\t * <ul>\n\t * <li>delegating to getValidator() first</li>\n\t * <li>if none returned, getting an existing instance with its well-known name \"mvcValidator\",\n\t * created by an MVC configuration</li>\n\t * <li>if none returned, checking the classpath for the presence of a JSR-303 implementation\n\t * before creating a {@code OptionalValidatorFactoryBean}</li>\n\t * <li>returning a no-op Validator instance</li>\n\t * </ul>\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 589
    },
    "return": "Validator",
    "signature": "protected Validator simpValidator()",
    "source_code": "\tprotected Validator simpValidator() {\n\t\tValidator validator = getValidator();\n\t\tif (validator == null) {\n\t\t\tif (this.applicationContext != null && this.applicationContext.containsBean(MVC_VALIDATOR_NAME)) {\n\t\t\t\tvalidator = this.applicationContext.getBean(MVC_VALIDATOR_NAME, Validator.class);\n\t\t\t}\n\t\t\telse if (ClassUtils.isPresent(\"jakarta.validation.Validator\", getClass().getClassLoader())) {\n\t\t\t\ttry {\n\t\t\t\t\tvalidator = new OptionalValidatorFactoryBean();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tthrow new BeanInitializationException(\"Failed to create default validator\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalidator = new Validator() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean supports(Class<?> clazz) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void validate(@Nullable Object target, Errors errors) {\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\treturn validator;\n\t}"
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#simpleBrokerMessageHandler(clientInboundChannel,clientOutboundChannel,brokerChannel,userDestinationResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel",
      "brokerChannel",
      "userDestinationResolver"
    ],
    "position": {
      "column": 1,
      "line": 390
    },
    "return": "AbstractBrokerMessageHandler",
    "signature": "public AbstractBrokerMessageHandler simpleBrokerMessageHandler(AbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel,\n\t\t\tAbstractSubscribableChannel brokerChannel, UserDestinationResolver userDestinationResolver)",
    "source_code": "\tpublic AbstractBrokerMessageHandler simpleBrokerMessageHandler("
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#stompBrokerRelayMessageHandler(clientInboundChannel,clientOutboundChannel,brokerChannel,userDestinationMessageHandler,userRegistryMessageHandler,userDestinationResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel",
      "brokerChannel",
      "userDestinationMessageHandler",
      "userRegistryMessageHandler",
      "userDestinationResolver"
    ],
    "position": {
      "column": 1,
      "line": 419
    },
    "return": "AbstractBrokerMessageHandler",
    "signature": "public AbstractBrokerMessageHandler stompBrokerRelayMessageHandler(AbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel,\n\t\t\tAbstractSubscribableChannel brokerChannel, UserDestinationMessageHandler userDestinationMessageHandler,\n\t\t\t@Nullable MessageHandler userRegistryMessageHandler, UserDestinationResolver userDestinationResolver)",
    "source_code": "\tpublic AbstractBrokerMessageHandler stompBrokerRelayMessageHandler("
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#supports(clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 606
    },
    "return": "boolean",
    "signature": "public boolean supports(Class<?> clazz)",
    "source_code": "\t\t\t\t\tpublic boolean supports(Class<?> clazz) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}"
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#userDestinationMessageHandler(clientInboundChannel,clientOutboundChannel,brokerChannel,userDestinationResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel",
      "brokerChannel",
      "userDestinationResolver"
    ],
    "position": {
      "column": 1,
      "line": 445
    },
    "return": "UserDestinationMessageHandler",
    "signature": "public UserDestinationMessageHandler userDestinationMessageHandler(AbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel,\n\t\t\tAbstractSubscribableChannel brokerChannel, UserDestinationResolver userDestinationResolver)",
    "source_code": "\tpublic UserDestinationMessageHandler userDestinationMessageHandler("
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#userDestinationResolver(userRegistry,clientInboundChannel,clientOutboundChannel)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "userRegistry",
      "clientInboundChannel",
      "clientOutboundChannel"
    ],
    "position": {
      "column": 1,
      "line": 546
    },
    "return": "UserDestinationResolver",
    "signature": "public UserDestinationResolver userDestinationResolver(SimpUserRegistry userRegistry, AbstractSubscribableChannel clientInboundChannel,\n\t\t\tAbstractSubscribableChannel clientOutboundChannel)",
    "source_code": "\tpublic UserDestinationResolver userDestinationResolver("
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#userRegistry(clientInboundChannel,clientOutboundChannel)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel"
    ],
    "position": {
      "column": 1,
      "line": 560
    },
    "return": "SimpUserRegistry",
    "signature": "public SimpUserRegistry userRegistry(AbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel)",
    "source_code": "\tpublic SimpUserRegistry userRegistry("
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#userRegistryMessageHandler(clientInboundChannel,clientOutboundChannel,userRegistry,brokerMessagingTemplate,@Qualifier(\"messageBrokerTaskScheduler\")": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel",
      "userRegistry",
      "brokerMessagingTemplate",
      "@Qualifier(\"messageBrokerTaskScheduler\""
    ],
    "position": {
      "column": 1,
      "line": 463
    },
    "return": "MessageHandler",
    "signature": "public MessageHandler userRegistryMessageHandler(AbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel,\n\t\t\tSimpUserRegistry userRegistry, SimpMessagingTemplate brokerMessagingTemplate,\n\t\t\t@Qualifier(\"messageBrokerTaskScheduler\")",
    "source_code": "\tpublic MessageHandler userRegistryMessageHandler("
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#validate(target,errors)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "errors"
    ],
    "position": {
      "column": 1,
      "line": 610
    },
    "return": "void",
    "signature": "public void validate(@Nullable Object target, Errors errors)",
    "source_code": "\t\t\t\t\tpublic void validate(@Nullable Object target, Errors errors) {\n\t\t\t\t\t}"
  },
  "org.springframework.messaging.simp.user.DefaultUserDestinationResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A default implementation of {@code UserDestinationResolver} that relies\n * on a {@link SimpUserRegistry} to find active sessions for a user.\n *\n * <p>When a user attempts to subscribe, e.g. to \"/user/queue/position-updates\",\n * the \"/user\" prefix is removed and a unique suffix added based on the session\n * id, e.g. \"/queue/position-updates-useri9oqdfzo\" to ensure different users can\n * subscribe to the same logical destination without colliding.\n *\n * <p>When sending to a user, e.g. \"/user/{username}/queue/position-updates\", the\n * \"/user/{username}\" prefix is removed and a suffix based on active session id's\n * is added, e.g. \"/queue/position-updates-useri9oqdfzo\".\n *\n * @author Rossen Stoyanchev\n * @author Brian Clozel\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "signature": "public class DefaultUserDestinationResolver",
    "source_code": "public class DefaultUserDestinationResolver implements UserDestinationResolver {\n\n\tprivate static final Log logger = SimpLogging.forLogName(DefaultUserDestinationResolver.class);\n\n\n\tprivate final SimpUserRegistry userRegistry;\n\n\tprivate String prefix = \"/user/\";\n\n\tprivate boolean removeLeadingSlash = false;\n\n\n\t/**\n\t * Create an instance that will access user session id information through\n\t * the provided registry.\n\t * @param userRegistry the registry, never {@code null}\n\t */\n\tpublic DefaultUserDestinationResolver(SimpUserRegistry userRegistry) {\n\t\tAssert.notNull(userRegistry, \"SimpUserRegistry must not be null\");\n\t\tthis.userRegistry = userRegistry;\n\t}\n\n\n\t/**\n\t * Return the configured {@link SimpUserRegistry}.\n\t */\n\tpublic SimpUserRegistry getSimpUserRegistry() {\n\t\treturn this.userRegistry;\n\t}\n\n\t/**\n\t * The prefix used to identify user destinations. Any destinations that do not\n\t * start with the given prefix are not be resolved.\n\t * <p>The default prefix is \"/user/\".\n\t * @param prefix the prefix to use\n\t */\n\tpublic void setUserDestinationPrefix(String prefix) {\n\t\tAssert.hasText(prefix, \"Prefix must not be empty\");\n\t\tthis.prefix = (prefix.endsWith(\"/\") ? prefix : prefix + \"/\");\n\t}\n\n\t/**\n\t * Return the configured prefix for user destinations.\n\t */\n\tpublic String getDestinationPrefix() {\n\t\treturn this.prefix;\n\t}\n\n\t/**\n\t * Use this property to indicate whether the leading slash from translated\n\t * user destinations should be removed or not. This depends on the\n\t * destination prefixes the message broker is configured with.\n\t * <p>By default this is set to {@code false}, i.e.\n\t * \"do not change the target destination\", although\n\t * {@link org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration\n\t * AbstractMessageBrokerConfiguration} may change that to {@code true}\n\t * if the configured destinations do not have a leading slash.\n\t * @param remove whether to remove the leading slash\n\t * @since 4.3.14\n\t */\n\tpublic void setRemoveLeadingSlash(boolean remove) {\n\t\tthis.removeLeadingSlash = remove;\n\t}\n\n\t/**\n\t * Whether to remove the leading slash from target destinations.\n\t * @since 4.3.14\n\t */\n\tpublic boolean isRemoveLeadingSlash() {\n\t\treturn this.removeLeadingSlash;\n\t}\n\n\n\t@Override\n\t@Nullable\n\tpublic UserDestinationResult resolveDestination(Message<?> message) {\n\t\tParseResult parseResult = parse(message);\n\t\tif (parseResult == null) {\n\t\t\treturn null;\n\t\t}\n\t\tString user = parseResult.getUser();\n\t\tString sourceDest = parseResult.getSourceDestination();\n\t\tSet<String> sessionIds = parseResult.getSessionIds();\n\t\tSet<String> targetSet = new HashSet<>();\n\t\tfor (String sessionId : sessionIds) {\n\t\t\tString actualDest = parseResult.getActualDestination();\n\t\t\tString targetDest = getTargetDestination(sourceDest, actualDest, sessionId, user);\n\t\t\tif (targetDest != null) {\n\t\t\t\ttargetSet.add(targetDest);\n\t\t\t}\n\t\t}\n\t\tString subscribeDest = parseResult.getSubscribeDestination();\n\t\treturn new UserDestinationResult(sourceDest, targetSet, subscribeDest, user, sessionIds);\n\t}\n\n\t@Nullable\n\tprivate ParseResult parse(Message<?> message) {\n\t\tMessageHeaders headers = message.getHeaders();\n\t\tString sourceDestination = SimpMessageHeaderAccessor.getDestination(headers);\n\t\tif (sourceDestination == null || !checkDestination(sourceDestination, this.prefix)) {\n\t\t\treturn null;\n\t\t}\n\t\tSimpMessageType messageType = SimpMessageHeaderAccessor.getMessageType(headers);\n\t\tif (messageType != null) {\n\t\t\treturn switch (messageType) {\n\t\t\t\tcase SUBSCRIBE, UNSUBSCRIBE -> parseSubscriptionMessage(message, sourceDestination);\n\t\t\t\tcase MESSAGE -> parseMessage(headers, sourceDestination);\n\t\t\t\tdefault -> null;\n\t\t\t};\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Nullable\n\tprivate ParseResult parseSubscriptionMessage(Message<?> message, String sourceDestination) {\n\t\tMessageHeaders headers = message.getHeaders();\n\t\tString sessionId = SimpMessageHeaderAccessor.getSessionId(headers);\n\t\tif (sessionId == null) {\n\t\t\tlogger.error(\"No session id. Ignoring \" + message);\n\t\t\treturn null;\n\t\t}\n\t\tint prefixEnd = this.prefix.length() - 1;\n\t\tString actualDestination = sourceDestination.substring(prefixEnd);\n\t\tif (isRemoveLeadingSlash()) {\n\t\t\tactualDestination = actualDestination.substring(1);\n\t\t}\n\t\tPrincipal principal = SimpMessageHeaderAccessor.getUser(headers);\n\t\tString user = (principal != null ? principal.getName() : null);\n\t\tAssert.isTrue(user == null || !user.contains(\"%2F\"), () -> \"Invalid sequence \\\"%2F\\\" in user name: \" + user);\n\t\tSet<String> sessionIds = Collections.singleton(sessionId);\n\t\treturn new ParseResult(sourceDestination, actualDestination, sourceDestination, sessionIds, user);\n\t}\n\n\tprivate ParseResult parseMessage(MessageHeaders headers, String sourceDest) {\n\t\tint prefixEnd = this.prefix.length();\n\t\tint userEnd = sourceDest.indexOf('/', prefixEnd);\n\t\tAssert.isTrue(userEnd > 0, \"Expected destination pattern \\\"/user/{userId}/**\\\"\");\n\t\tString actualDest = sourceDest.substring(userEnd);\n\t\tString subscribeDest = this.prefix.substring(0, prefixEnd - 1) + actualDest;\n\t\tString userName = sourceDest.substring(prefixEnd, userEnd);\n\t\tuserName = StringUtils.replace(userName, \"%2F\", \"/\");\n\n\t\tString sessionId = SimpMessageHeaderAccessor.getSessionId(headers);\n\t\tSet<String> sessionIds;\n\t\tif (userName.equals(sessionId)) {\n\t\t\tuserName = null;\n\t\t\tsessionIds = Collections.singleton(sessionId);\n\t\t}\n\t\telse {\n\t\t\tsessionIds = getSessionIdsByUser(userName, sessionId);\n\t\t}\n\n\t\tif (isRemoveLeadingSlash()) {\n\t\t\tactualDest = actualDest.substring(1);\n\t\t}\n\t\treturn new ParseResult(sourceDest, actualDest, subscribeDest, sessionIds, userName);\n\t}\n\n\tprivate Set<String> getSessionIdsByUser(String userName, @Nullable String sessionId) {\n\t\tSet<String> sessionIds;\n\t\tSimpUser user = this.userRegistry.getUser(userName);\n\t\tif (user != null) {\n\t\t\tif (sessionId != null && user.getSession(sessionId) != null) {\n\t\t\t\tsessionIds = Collections.singleton(sessionId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSet<SimpSession> sessions = user.getSessions();\n\t\t\t\tsessionIds = new HashSet<>(sessions.size());\n\t\t\t\tfor (SimpSession session : sessions) {\n\t\t\t\t\tsessionIds.add(session.getId());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tsessionIds = Collections.emptySet();\n\t\t}\n\t\treturn sessionIds;\n\t}\n\n\tprotected boolean checkDestination(String destination, String requiredPrefix) {\n\t\treturn destination.startsWith(requiredPrefix);\n\t}\n\n\t/**\n\t * This method determines how to translate the source \"user\" destination to an\n\t * actual target destination for the given active user session.\n\t * @param sourceDestination the source destination from the input message.\n\t * @param actualDestination a subset of the destination without any user prefix.\n\t * @param sessionId the id of an active user session, never {@code null}.\n\t * @param user the target user, possibly {@code null}, e.g if not authenticated.\n\t * @return a target destination, or {@code null} if none\n\t */\n\t@SuppressWarnings(\"unused\")\n\t@Nullable\n\tprotected String getTargetDestination(String sourceDestination, String actualDestination,\n\t\t\tString sessionId, @Nullable String user) {\n\n\t\treturn actualDestination + \"-user\" + sessionId;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"DefaultUserDestinationResolver[prefix=\" + this.prefix + \"]\";\n\t}\n\n\n\t/**\n\t * A temporary placeholder for a parsed source \"user\" destination.\n\t */\n\tprivate static class ParseResult {\n\n\t\tprivate final String sourceDestination;\n\n\t\tprivate final String actualDestination;\n\n\t\tprivate final String subscribeDestination;\n\n\t\tprivate final Set<String> sessionIds;\n\n\t\t@Nullable\n\t\tprivate final String user;\n\n\t\tpublic ParseResult(String sourceDest, String actualDest, String subscribeDest,\n\t\t\t\tSet<String> sessionIds, @Nullable String user) {\n\n\t\t\tthis.sourceDestination = sourceDest;\n\t\t\tthis.actualDestination = actualDest;\n\t\t\tthis.subscribeDestination = subscribeDest;\n\t\t\tthis.sessionIds = sessionIds;\n\t\t\tthis.user = user;\n\t\t}\n\n\t\t/**\n\t\t * The destination from the source message, e.g. \"/user/{user}/queue/position-updates\".\n\t\t */\n\t\tpublic String getSourceDestination() {\n\t\t\treturn this.sourceDestination;\n\t\t}\n\n\t\t/**\n\t\t * The actual destination, without any user prefix, e.g. \"/queue/position-updates\".\n\t\t */\n\t\tpublic String getActualDestination() {\n\t\t\treturn this.actualDestination;\n\t\t}\n\n\t\t/**\n\t\t * The user destination as it would be on a subscription, \"/user/queue/position-updates\".\n\t\t */\n\t\tpublic String getSubscribeDestination() {\n\t\t\treturn this.subscribeDestination;\n\t\t}\n\n\t\t/**\n\t\t * The session id or id's for the user.\n\t\t */\n\t\tpublic Set<String> getSessionIds() {\n\t\t\treturn this.sessionIds;\n\t\t}\n\n\t\t/**\n\t\t * The name of the user associated with the session.\n\t\t */\n\t\t@Nullable\n\t\tpublic String getUser() {\n\t\t\treturn this.user;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.messaging.simp.user.DefaultUserDestinationResolver#checkDestination(destination,requiredPrefix)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "destination",
      "requiredPrefix"
    ],
    "position": {
      "column": 1,
      "line": 231
    },
    "return": "boolean",
    "signature": "protected boolean checkDestination(String destination, String requiredPrefix)",
    "source_code": "\tprotected boolean checkDestination(String destination, String requiredPrefix) {\n\t\treturn destination.startsWith(requiredPrefix);\n\t}"
  },
  "org.springframework.messaging.simp.user.DefaultUserDestinationResolver#getActualDestination()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * The actual destination, without any user prefix, e.g. \"/queue/position-updates\".\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 294
    },
    "return": "String",
    "signature": "public String getActualDestination()",
    "source_code": "\t\tpublic String getActualDestination() {\n\t\t\treturn this.actualDestination;\n\t\t}"
  },
  "org.springframework.messaging.simp.user.DefaultUserDestinationResolver#getDestinationPrefix()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured prefix for user destinations.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "String",
    "signature": "public String getDestinationPrefix()",
    "source_code": "\tpublic String getDestinationPrefix() {\n\t\treturn this.prefix;\n\t}"
  },
  "org.springframework.messaging.simp.user.DefaultUserDestinationResolver#getSessionIds()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * The session id or id's for the user.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "Set<String>",
    "signature": "public Set<String> getSessionIds()",
    "source_code": "\t\tpublic Set<String> getSessionIds() {\n\t\t\treturn this.sessionIds;\n\t\t}"
  },
  "org.springframework.messaging.simp.user.DefaultUserDestinationResolver#getSimpUserRegistry()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured {@link SimpUserRegistry}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "SimpUserRegistry",
    "signature": "public SimpUserRegistry getSimpUserRegistry()",
    "source_code": "\tpublic SimpUserRegistry getSimpUserRegistry() {\n\t\treturn this.userRegistry;\n\t}"
  },
  "org.springframework.messaging.simp.user.DefaultUserDestinationResolver#getSourceDestination()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * The destination from the source message, e.g. \"/user/{user}/queue/position-updates\".\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "String",
    "signature": "public String getSourceDestination()",
    "source_code": "\t\tpublic String getSourceDestination() {\n\t\t\treturn this.sourceDestination;\n\t\t}"
  },
  "org.springframework.messaging.simp.user.DefaultUserDestinationResolver#getSubscribeDestination()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * The user destination as it would be on a subscription, \"/user/queue/position-updates\".\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 301
    },
    "return": "String",
    "signature": "public String getSubscribeDestination()",
    "source_code": "\t\tpublic String getSubscribeDestination() {\n\t\t\treturn this.subscribeDestination;\n\t\t}"
  },
  "org.springframework.messaging.simp.user.DefaultUserDestinationResolver#getTargetDestination(sourceDestination,actualDestination,sessionId,user)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This method determines how to translate the source \"user\" destination to an\n\t * actual target destination for the given active user session.\n\t * @param sourceDestination the source destination from the input message.\n\t * @param actualDestination a subset of the destination without any user prefix.\n\t * @param sessionId the id of an active user session, never {@code null}.\n\t * @param user the target user, possibly {@code null}, e.g if not authenticated.\n\t * @return a target destination, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "sourceDestination",
      "actualDestination",
      "sessionId",
      "user"
    ],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "String",
    "signature": "protected String getTargetDestination(String sourceDestination, String actualDestination,\n\t\t\tString sessionId, @Nullable String user)",
    "source_code": "\tprotected String getTargetDestination(String sourceDestination, String actualDestination,"
  },
  "org.springframework.messaging.simp.user.DefaultUserDestinationResolver#getUser()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * The name of the user associated with the session.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 316
    },
    "return": "String",
    "signature": "public String getUser()",
    "source_code": "\t\tpublic String getUser() {\n\t\t\treturn this.user;\n\t\t}"
  },
  "org.springframework.messaging.simp.user.DefaultUserDestinationResolver#isRemoveLeadingSlash()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to remove the leading slash from target destinations.\n\t * @since 4.3.14\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "boolean",
    "signature": "public boolean isRemoveLeadingSlash()",
    "source_code": "\tpublic boolean isRemoveLeadingSlash() {\n\t\treturn this.removeLeadingSlash;\n\t}"
  },
  "org.springframework.messaging.simp.user.DefaultUserDestinationResolver#resolveDestination(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "UserDestinationResult",
    "signature": "public UserDestinationResult resolveDestination(Message<?> message)",
    "source_code": "\tpublic UserDestinationResult resolveDestination(Message<?> message) {\n\t\tParseResult parseResult = parse(message);\n\t\tif (parseResult == null) {\n\t\t\treturn null;\n\t\t}\n\t\tString user = parseResult.getUser();\n\t\tString sourceDest = parseResult.getSourceDestination();\n\t\tSet<String> sessionIds = parseResult.getSessionIds();\n\t\tSet<String> targetSet = new HashSet<>();\n\t\tfor (String sessionId : sessionIds) {\n\t\t\tString actualDest = parseResult.getActualDestination();\n\t\t\tString targetDest = getTargetDestination(sourceDest, actualDest, sessionId, user);\n\t\t\tif (targetDest != null) {\n\t\t\t\ttargetSet.add(targetDest);\n\t\t\t}\n\t\t}\n\t\tString subscribeDest = parseResult.getSubscribeDestination();\n\t\treturn new UserDestinationResult(sourceDest, targetSet, subscribeDest, user, sessionIds);\n\t}"
  },
  "org.springframework.messaging.simp.user.DefaultUserDestinationResolver#setRemoveLeadingSlash(remove)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Use this property to indicate whether the leading slash from translated\n\t * user destinations should be removed or not. This depends on the\n\t * destination prefixes the message broker is configured with.\n\t * <p>By default this is set to {@code false}, i.e.\n\t * \"do not change the target destination\", although\n\t * {@link org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration\n\t * AbstractMessageBrokerConfiguration} may change that to {@code true}\n\t * if the configured destinations do not have a leading slash.\n\t * @param remove whether to remove the leading slash\n\t * @since 4.3.14\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "remove"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "public void setRemoveLeadingSlash(boolean remove)",
    "source_code": "\tpublic void setRemoveLeadingSlash(boolean remove) {\n\t\tthis.removeLeadingSlash = remove;\n\t}"
  },
  "org.springframework.messaging.simp.user.DefaultUserDestinationResolver#setUserDestinationPrefix(prefix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The prefix used to identify user destinations. Any destinations that do not\n\t * start with the given prefix are not be resolved.\n\t * <p>The default prefix is \"/user/\".\n\t * @param prefix the prefix to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "prefix"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "void",
    "signature": "public void setUserDestinationPrefix(String prefix)",
    "source_code": "\tpublic void setUserDestinationPrefix(String prefix) {\n\t\tAssert.hasText(prefix, \"Prefix must not be empty\");\n\t\tthis.prefix = (prefix.endsWith(\"/\") ? prefix : prefix + \"/\");\n\t}"
  },
  "org.springframework.messaging.simp.user.DefaultUserDestinationResolver#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 253
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn \"DefaultUserDestinationResolver[prefix=\" + this.prefix + \"]\";\n\t}"
  },
  "org.springframework.mock.http.client.MockClientHttpResponse#getRawStatusCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "int",
    "signature": "public int getRawStatusCode()",
    "source_code": "\tpublic int getRawStatusCode() {\n\t\treturn this.statusCode.value();\n\t}"
  },
  "org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean#setManagedClassNameFilter(managedClassNameFilter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link ManagedClassNameFilter} to apply on entity classes discovered\n\t * using {@linkplain #setPackagesToScan(String...) classpath scanning}.\n\t * @param managedClassNameFilter a predicate to filter entity classes\n\t * @since 6.1.4\n\t * @see DefaultPersistenceUnitManager#setManagedClassNameFilter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "managedClassNameFilter"
    ],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "void",
    "signature": "public void setManagedClassNameFilter(ManagedClassNameFilter managedClassNameFilter)",
    "source_code": "\tpublic void setManagedClassNameFilter(ManagedClassNameFilter managedClassNameFilter) {\n\t\tthis.internalPersistenceUnitManager.setManagedClassNameFilter(managedClassNameFilter);\n\t}"
  },
  "org.springframework.orm.jpa.vendor.HibernateJpaDialect#setJdbcExceptionTranslator(exceptionTranslator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the JDBC exception translator for Hibernate exception translation purposes.\n\t * <p>Applied to any detected {@link java.sql.SQLException} root cause of a Hibernate\n\t * {@link JDBCException}, overriding Hibernate's own {@code SQLException} translation\n\t * (which is based on a Hibernate Dialect for a specific target database).\n\t * <p>As of 6.1, also applied to {@link org.hibernate.TransactionException} translation\n\t * with a {@link SQLException} root cause (where Hibernate does not translate itself\n\t * at all), overriding Spring's default {@link SQLExceptionSubclassTranslator} there.\n\t * @param exceptionTranslator the {@link SQLExceptionTranslator} to delegate to, or\n\t * {@code null} for none. By default, a {@link SQLExceptionSubclassTranslator} will\n\t * be used for {@link org.hibernate.TransactionException} translation as of 6.1;\n\t * this can be reverted to pre-6.1 behavior through setting {@code null} here.\n\t * @since 5.1\n\t * @see java.sql.SQLException\n\t * @see org.hibernate.JDBCException\n\t * @see org.springframework.jdbc.support.SQLExceptionSubclassTranslator\n\t * @see org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslator\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exceptionTranslator"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "void",
    "signature": "public void setJdbcExceptionTranslator(@Nullable SQLExceptionTranslator exceptionTranslator)",
    "source_code": "\tpublic void setJdbcExceptionTranslator(@Nullable SQLExceptionTranslator exceptionTranslator) {\n\t\tthis.jdbcExceptionTranslator = exceptionTranslator;\n\t\tthis.transactionExceptionTranslator = exceptionTranslator;\n\t}"
  },
  "org.springframework.orm.jpa.vendor.HibernateJpaDialect#setJdbcExceptionTranslator(jdbcExceptionTranslator)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the JDBC exception translator for Hibernate exception translation purposes.\n\t * <p>Applied to any detected {@link java.sql.SQLException} root cause of a Hibernate\n\t * {@link JDBCException}, overriding Hibernate's own {@code SQLException} translation\n\t * (which is based on a Hibernate Dialect for a specific target database).\n\t * @since 5.1\n\t * @see java.sql.SQLException\n\t * @see org.hibernate.JDBCException\n\t * @see org.springframework.jdbc.support.SQLExceptionSubclassTranslator\n\t * @see org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslator\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "jdbcExceptionTranslator"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "void",
    "signature": "public void setJdbcExceptionTranslator(SQLExceptionTranslator jdbcExceptionTranslator)",
    "source_code": "\tpublic void setJdbcExceptionTranslator(SQLExceptionTranslator jdbcExceptionTranslator) {\n\t\tthis.jdbcExceptionTranslator = jdbcExceptionTranslator;\n\t}"
  },
  "org.springframework.r2dbc.connection.SingleConnectionFactory": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Implementation of {@link DelegatingConnectionFactory} that wraps a\n * single R2DBC {@link Connection} which is not closed after use.\n * Obviously, this is not multi-threading capable.\n *\n * <p>Note that at shutdown, someone should close the underlying\n * {@code Connection} via the {@code close()} method. Client code will\n * never call close on the {@code Connection} handle if it is\n * SmartConnectionFactory-aware (e.g. uses\n * {@link ConnectionFactoryUtils#releaseConnection(Connection, ConnectionFactory)}).\n *\n * <p>If client code will call {@link Connection#close()} in the\n * assumption of a pooled {@code Connection}, like when using persistence tools,\n * set \"suppressClose\" to {@code true}. This will return a close-suppressing\n * proxy instead of the physical Connection.\n *\n * <p>This is primarily intended for testing and pipelining usage of connections.\n * For example, it enables easy testing outside an application server for code\n * that expects to work on a {@link ConnectionFactory}.\n * Note that this implementation does not act as a connection pool-like utility.\n * Connection pooling requires a pooling {@link ConnectionFactory} such as one from\n * {@code r2dbc-pool}.\n *\n * @author Mark Paluch\n * @since 5.3\n * @see #create()\n * @see Connection#close()\n * @see ConnectionFactoryUtils#releaseConnection(Connection, ConnectionFactory)\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "signature": "public class SingleConnectionFactory",
    "source_code": "public class SingleConnectionFactory extends DelegatingConnectionFactory"
  },
  "org.springframework.r2dbc.connection.SingleConnectionFactory#destroy()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Close the underlying {@link Connection}.\n\t * The provider of this {@link ConnectionFactory} needs to care for proper shutdown.\n\t * <p>As this bean implements {@link DisposableBean}, a bean factory will automatically\n\t * invoke this on destruction of its cached singletons.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "void",
    "signature": "public void destroy()",
    "source_code": "\tpublic void destroy() {\n\t\tresetConnection().block();\n\t}"
  },
  "org.springframework.r2dbc.connection.SingleConnectionFactory#getAutoCommitValue()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether the returned {@link Connection}'s \"autoCommit\" setting should\n\t * be overridden.\n\t * @return the \"autoCommit\" value, or {@code null} if none to be applied\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "Boolean",
    "signature": "protected Boolean getAutoCommitValue()",
    "source_code": "\tprotected Boolean getAutoCommitValue() {\n\t\treturn this.autoCommit;\n\t}"
  },
  "org.springframework.r2dbc.connection.SingleConnectionFactory#getCloseSuppressingConnectionProxy(target)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Wrap the given {@link Connection} with a proxy that delegates every method call to it\n\t * but suppresses close calls.\n\t * @param target the original {@code Connection} to wrap\n\t * @return the wrapped Connection\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target"
    ],
    "position": {
      "column": 1,
      "line": 234
    },
    "return": "Connection",
    "signature": "protected Connection getCloseSuppressingConnectionProxy(Connection target)",
    "source_code": "\tprotected Connection getCloseSuppressingConnectionProxy(Connection target) {\n\t\treturn (Connection) Proxy.newProxyInstance(SingleConnectionFactory.class.getClassLoader(),\n\t\t\t\tnew Class<?>[] {Connection.class, Wrapped.class}, new CloseSuppressingInvocationHandler(target));\n\t}"
  },
  "org.springframework.r2dbc.connection.SingleConnectionFactory#getMetadata()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "ConnectionFactoryMetadata",
    "signature": "public ConnectionFactoryMetadata getMetadata()",
    "source_code": "\t\t\tpublic ConnectionFactoryMetadata getMetadata() {\n\t\t\t\treturn metadata;\n\t\t\t}"
  },
  "org.springframework.r2dbc.connection.SingleConnectionFactory#invoke(proxy,method,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\treturn switch (method.getName()) {\n\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\tcase \"equals\" -> proxy == args[0];\n\t\t\t\t// Use hashCode of Connection proxy.\n\t\t\t\tcase \"hashCode\" -> System.identityHashCode(proxy);\n\t\t\t\tcase \"unwrap\" -> this.target;\n\t\t\t\t// Handle close method: suppress, not valid.\n\t\t\t\tcase \"close\" -> Mono.empty();\n\t\t\t\tdefault -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Invoke method on target Connection.\n\t\t\t\t\t\tyield method.invoke(this.target, args);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\t\t\tthrow ex.getTargetException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}"
  },
  "org.springframework.r2dbc.connection.SingleConnectionFactory#isSuppressClose()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether the returned {@link Connection} will be a close-suppressing proxy\n\t * or the physical {@code Connection}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "boolean",
    "signature": "protected boolean isSuppressClose()",
    "source_code": "\tprotected boolean isSuppressClose() {\n\t\treturn this.suppressClose;\n\t}"
  },
  "org.springframework.r2dbc.connection.SingleConnectionFactory#prepareConnection(connection)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare the {@link Connection} before using it.\n\t * Applies {@linkplain #getAutoCommitValue() auto-commit} settings if configured.\n\t * @param connection the requested {@code Connection}\n\t * @return the prepared {@code Connection}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "connection"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "Mono<Connection>",
    "signature": "protected Mono<Connection> prepareConnection(Connection connection)",
    "source_code": "\tprotected Mono<Connection> prepareConnection(Connection connection) {\n\t\tBoolean autoCommit = getAutoCommitValue();\n\t\tif (autoCommit != null) {\n\t\t\treturn Mono.from(connection.setAutoCommit(autoCommit)).thenReturn(connection);\n\t\t}\n\t\treturn Mono.just(connection);\n\t}"
  },
  "org.springframework.r2dbc.connection.SingleConnectionFactory#resetConnection()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Reset the underlying shared Connection, to be reinitialized on next access.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> resetConnection()",
    "source_code": "\tpublic Mono<Void> resetConnection() {\n\t\tConnection connection = this.target.get();\n\t\tif (connection == null) {\n\t\t\treturn Mono.empty();\n\t\t}\n\t\treturn Mono.defer(() -> {\n\t\t\tif (this.target.compareAndSet(connection, null)) {\n\t\t\t\tthis.connection = null;\n\t\t\t\treturn Mono.from(connection.close());\n\t\t\t}\n\t\t\treturn Mono.empty();\n\t\t});\n\t}"
  },
  "org.springframework.r2dbc.connection.SingleConnectionFactory#setAutoCommit(autoCommit)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether the returned {@link Connection}'s \"autoCommit\" setting should\n\t * be overridden.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "autoCommit"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "void",
    "signature": "public void setAutoCommit(boolean autoCommit)",
    "source_code": "\tpublic void setAutoCommit(boolean autoCommit) {\n\t\tthis.autoCommit = autoCommit;\n\t}"
  },
  "org.springframework.r2dbc.connection.SingleConnectionFactory#setSuppressClose(suppressClose)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether the returned {@link Connection} should be a close-suppressing proxy\n\t * or the physical {@code Connection}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "suppressClose"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "void",
    "signature": "public void setSuppressClose(boolean suppressClose)",
    "source_code": "\tpublic void setSuppressClose(boolean suppressClose) {\n\t\tthis.suppressClose = suppressClose;\n\t}"
  },
  "org.springframework.r2dbc.connection.TransactionAwareConnectionFactoryProxy": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Proxy for a target R2DBC {@link ConnectionFactory}, adding awareness\n * of Spring-managed transactions.\n *\n * <p>Data access code that should remain unaware of Spring's data access\n * support can work with this proxy to seamlessly participate in\n * Spring-managed transactions.\n * Note that the transaction manager, for example {@link R2dbcTransactionManager},\n * still needs to work with the underlying {@link ConnectionFactory},\n * <i>not</i> with this proxy.\n *\n * <p><b>Make sure that {@link TransactionAwareConnectionFactoryProxy} is the outermost\n * {@link ConnectionFactory} of a chain of {@link ConnectionFactory} proxies/adapters.</b>\n * {@link TransactionAwareConnectionFactoryProxy} can delegate either directly to the\n * target connection pool or to some intermediary proxy/adapter.\n *\n * <p>Delegates to {@link ConnectionFactoryUtils} for automatically participating\n * in thread-bound transactions, for example managed by {@link R2dbcTransactionManager}.\n * {@link #create()} calls and {@code close} calls on returned {@link Connection}\n * will behave properly within a transaction, i.e. always operate on the\n * transactional Connection. If not within a transaction, normal {@link ConnectionFactory}\n * behavior applies.\n *\n * <p> This proxy allows data access code to work with the plain R2DBC API. However,\n * if possible, use Spring's {@link ConnectionFactoryUtils} or {@code DatabaseClient}\n * to get transaction participation even without a proxy for the target\n * {@link ConnectionFactory}, avoiding the need to define such a proxy in the first place.\n *\n * <p><b>NOTE:</b> This {@link ConnectionFactory} proxy needs to return wrapped\n * {@link Connection}s in order to handle close calls properly.\n * Use {@link Wrapped#unwrap()} to retrieve the native R2DBC Connection.\n *\n * @author Mark Paluch\n * @author Christoph Strobl\n * @since 5.3\n * @see ConnectionFactory#create\n * @see Connection#close\n * @see ConnectionFactoryUtils#doGetConnection\n * @see ConnectionFactoryUtils#doReleaseConnection\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "signature": "public class TransactionAwareConnectionFactoryProxy",
    "source_code": "public class TransactionAwareConnectionFactoryProxy extends DelegatingConnectionFactory {\n\n\t/**\n\t * Create a new {@link TransactionAwareConnectionFactoryProxy}.\n\t * @param targetConnectionFactory the target {@link ConnectionFactory}\n\t */\n\tpublic TransactionAwareConnectionFactoryProxy(ConnectionFactory targetConnectionFactory) {\n\t\tsuper(targetConnectionFactory);\n\t}\n\n\n\t/**\n\t * Delegates to {@link ConnectionFactoryUtils} for automatically participating\n\t * in Spring-managed transactions.\n\t * @return a transactional {@link Connection} if any, a new one else.\n\t * @see ConnectionFactoryUtils#doGetConnection\n\t */\n\t@Override\n\tpublic Mono<Connection> create() {\n\t\treturn getTransactionAwareConnectionProxy(getTargetConnectionFactory());\n\t}\n\n\t/**\n\t * Wraps the given {@link Connection} with a proxy that delegates every method call\n\t * to it but delegates {@code close()} calls to {@link ConnectionFactoryUtils}.\n\t * @param targetConnectionFactory the {@link ConnectionFactory} that the {@link Connection} came from\n\t * @return the wrapped {@link Connection}.\n\t * @see Connection#close()\n\t * @see ConnectionFactoryUtils#doReleaseConnection\n\t */\n\tprotected Mono<Connection> getTransactionAwareConnectionProxy(ConnectionFactory targetConnectionFactory) {\n\t\treturn ConnectionFactoryUtils.getConnection(targetConnectionFactory)\n\t\t\t\t.map(connection -> proxyConnection(connection, targetConnectionFactory));\n\t}\n\n\tprivate static Connection proxyConnection(Connection connection, ConnectionFactory targetConnectionFactory) {\n\t\treturn (Connection) Proxy.newProxyInstance(TransactionAwareConnectionFactoryProxy.class.getClassLoader(),\n\t\t\t\tnew Class<?>[] {Connection.class, Wrapped.class},\n\t\t\t\tnew TransactionAwareInvocationHandler(connection, targetConnectionFactory));\n\t}\n\n\n\t/**\n\t * Invocation handler that delegates close calls on R2DBC Connections to\n\t * {@link ConnectionFactoryUtils} for being aware of context-bound transactions.\n\t */\n\tprivate static class TransactionAwareInvocationHandler implements InvocationHandler {\n\n\t\tprivate final Connection connection;\n\n\t\tprivate final ConnectionFactory targetConnectionFactory;\n\n\t\tprivate boolean closed = false;\n\n\t\tTransactionAwareInvocationHandler(Connection connection, ConnectionFactory targetConnectionFactory) {\n\t\t\tthis.connection = connection;\n\t\t\tthis.targetConnectionFactory = targetConnectionFactory;\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\tif (ReflectionUtils.isObjectMethod(method)) {\n\t\t\t\tif (ReflectionUtils.isToStringMethod(method)) {\n\t\t\t\t\treturn proxyToString(proxy);\n\t\t\t\t}\n\t\t\t\tif (ReflectionUtils.isEqualsMethod(method)) {\n\t\t\t\t\treturn (proxy == args[0]);\n\t\t\t\t}\n\t\t\t\tif (ReflectionUtils.isHashCodeMethod(method)) {\n\t\t\t\t\treturn System.identityHashCode(proxy);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn switch (method.getName()) {\n\t\t\t\tcase \"unwrap\" -> this.connection;\n\t\t\t\t// Handle close method: only close if not within a transaction.\n\t\t\t\tcase \"close\" -> ConnectionFactoryUtils.doReleaseConnection(this.connection, this.targetConnectionFactory)\n\t\t\t\t\t\t\t.doOnSubscribe(n -> this.closed = true);\n\t\t\t\tcase \"isClosed\" -> this.closed;\n\t\t\t\tdefault -> {\n\t\t\t\t\tif (this.closed) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"Connection handle already closed\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Invoke method on target Connection.\n\t\t\t\t\t\tyield method.invoke(this.connection, args);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\t\t\tthrow ex.getTargetException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tprivate String proxyToString(@Nullable Object proxy) {\n\t\t\t// Allow for differentiating between the proxy and the raw Connection.\n\t\t\treturn \"Transaction-aware proxy for target Connection [\" + this.connection + \"]\";\n\t\t}\n\n\t}\n\n}"
  },
  "org.springframework.r2dbc.connection.TransactionAwareConnectionFactoryProxy#create()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@link ConnectionFactoryUtils} for automatically participating\n\t * in Spring-managed transactions.\n\t * @return a transactional {@link Connection} if any, a new one else.\n\t * @see ConnectionFactoryUtils#doGetConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "Mono<Connection>",
    "signature": "public Mono<Connection> create()",
    "source_code": "\tpublic Mono<Connection> create() {\n\t\treturn getTransactionAwareConnectionProxy(getTargetConnectionFactory());\n\t}"
  },
  "org.springframework.r2dbc.connection.TransactionAwareConnectionFactoryProxy#getTransactionAwareConnectionProxy(targetConnectionFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Wraps the given {@link Connection} with a proxy that delegates every method call\n\t * to it but delegates {@code close()} calls to {@link ConnectionFactoryUtils}.\n\t * @param targetConnectionFactory the {@link ConnectionFactory} that the {@link Connection} came from\n\t * @return the wrapped {@link Connection}.\n\t * @see Connection#close()\n\t * @see ConnectionFactoryUtils#doReleaseConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "targetConnectionFactory"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "Mono<Connection>",
    "signature": "protected Mono<Connection> getTransactionAwareConnectionProxy(ConnectionFactory targetConnectionFactory)",
    "source_code": "\tprotected Mono<Connection> getTransactionAwareConnectionProxy(ConnectionFactory targetConnectionFactory) {\n\t\treturn ConnectionFactoryUtils.getConnection(targetConnectionFactory)\n\t\t\t\t.map(connection -> proxyConnection(connection, targetConnectionFactory));\n\t}"
  },
  "org.springframework.r2dbc.connection.TransactionAwareConnectionFactoryProxy#invoke(proxy,method,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\tif (ReflectionUtils.isObjectMethod(method)) {\n\t\t\t\tif (ReflectionUtils.isToStringMethod(method)) {\n\t\t\t\t\treturn proxyToString(proxy);\n\t\t\t\t}\n\t\t\t\tif (ReflectionUtils.isEqualsMethod(method)) {\n\t\t\t\t\treturn (proxy == args[0]);\n\t\t\t\t}\n\t\t\t\tif (ReflectionUtils.isHashCodeMethod(method)) {\n\t\t\t\t\treturn System.identityHashCode(proxy);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn switch (method.getName()) {\n\t\t\t\tcase \"unwrap\" -> this.connection;\n\t\t\t\t// Handle close method: only close if not within a transaction.\n\t\t\t\tcase \"close\" -> ConnectionFactoryUtils.doReleaseConnection(this.connection, this.targetConnectionFactory)\n\t\t\t\t\t\t\t.doOnSubscribe(n -> this.closed = true);\n\t\t\t\tcase \"isClosed\" -> this.closed;\n\t\t\t\tdefault -> {\n\t\t\t\t\tif (this.closed) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"Connection handle already closed\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Invoke method on target Connection.\n\t\t\t\t\t\tyield method.invoke(this.connection, args);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\t\t\tthrow ex.getTargetException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}"
  },
  "org.springframework.r2dbc.connection.lookup.AbstractRoutingConnectionFactory#initialize()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the internal state of this {@code AbstractRoutingConnectionFactory}\n\t * by resolving the configured target ConnectionFactories.\n\t * @throws IllegalArgumentException if the target ConnectionFactories have not\n\t * been configured\n\t * @since 6.1\n\t * @see #setTargetConnectionFactories(Map)\n\t * @see #setDefaultTargetConnectionFactory(Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "void",
    "signature": "public void initialize()",
    "source_code": "\tpublic void initialize() {\n\t\tAssert.notNull(this.targetConnectionFactories, \"Property 'targetConnectionFactories' must not be null\");\n\n\t\tthis.resolvedConnectionFactories = CollectionUtils.newHashMap(this.targetConnectionFactories.size());\n\t\tthis.targetConnectionFactories.forEach((key, value) -> {\n\t\t\tObject lookupKey = resolveSpecifiedLookupKey(key);\n\t\t\tConnectionFactory connectionFactory = resolveSpecifiedConnectionFactory(value);\n\t\t\tthis.resolvedConnectionFactories.put(lookupKey, connectionFactory);\n\t\t});\n\n\t\tif (this.defaultTargetConnectionFactory != null) {\n\t\t\tthis.resolvedDefaultConnectionFactory = resolveSpecifiedConnectionFactory(this.defaultTargetConnectionFactory);\n\t\t}\n\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bindProperties(source)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "DefaultGenericExecuteSpec",
    "signature": "public DefaultGenericExecuteSpec bindProperties(Object source)",
    "source_code": "\t\tpublic DefaultGenericExecuteSpec bindProperties(Object source) {\n\t\t\tassertNotPreparedOperation();\n\t\t\tAssert.notNull(source, \"Parameter source must not be null\");\n\n\t\t\tMap<String, Parameter> byName = new LinkedHashMap<>(this.byName);\n\t\t\tfor (PropertyDescriptor pd : BeanUtils.getPropertyDescriptors(source.getClass())) {\n\t\t\t\tif (pd.getReadMethod() != null && pd.getReadMethod().getDeclaringClass() != Object.class) {\n\t\t\t\t\tReflectionUtils.makeAccessible(pd.getReadMethod());\n\t\t\t\t\tObject value = ReflectionUtils.invokeMethod(pd.getReadMethod(), source);\n\t\t\t\t\tbyName.put(pd.getName(), (value != null ? Parameters.in(value) : Parameters.in(pd.getPropertyType())));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new DefaultGenericExecuteSpec(this.byIndex, byName, this.sqlSupplier, this.filterFunction);\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bindValues(Map<String,source)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 312
    },
    "return": "GenericExecuteSpec",
    "signature": "public GenericExecuteSpec bindValues(Map<String, ?> source)",
    "source_code": "\t\tpublic GenericExecuteSpec bindValues(Map<String, ?> source) {\n\t\t\tassertNotPreparedOperation();\n\t\t\tAssert.notNull(source, \"Parameter source must not be null\");\n\n\t\t\tMap<String, Parameter> target = new LinkedHashMap<>(this.byName);\n\t\t\tsource.forEach((name, value) -> target.put(name, resolveParameter(value)));\n\n\t\t\treturn new DefaultGenericExecuteSpec(this.byIndex, target, this.sqlSupplier, this.filterFunction);\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#mapProperties(mappedClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedClass"
    ],
    "position": {
      "column": 1,
      "line": 365
    },
    "return": "FetchSpec<R>",
    "signature": "public FetchSpec<R> mapProperties(Class<R> mappedClass)",
    "source_code": "\t\tpublic <R> FetchSpec<R> mapProperties(Class<R> mappedClass) {\n\t\t\tAssert.notNull(mappedClass, \"Mapped class must not be null\");\n\t\t\treturn execute(this.sqlSupplier, result -> result.map(new DataClassRowMapper<>(mappedClass)));\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#mapValue(mappedClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedClass"
    ],
    "position": {
      "column": 1,
      "line": 359
    },
    "return": "RowsFetchSpec<R>",
    "signature": "public RowsFetchSpec<R> mapValue(Class<R> mappedClass)",
    "source_code": "\t\tpublic <R> RowsFetchSpec<R> mapValue(Class<R> mappedClass) {\n\t\t\tAssert.notNull(mappedClass, \"Mapped class must not be null\");\n\t\t\treturn execute(this.sqlSupplier, result -> result.map(row -> row.get(0, mappedClass)));\n\t\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Mapping {@code Function} implementation that converts an R2DBC {@link Readable}\n * (a {@link Row} or {@link OutParameters}) into a new instance of the specified mapped\n * target class. The mapped target class must be a top-level class or {@code static}\n * nested class, and it must have a default or no-arg constructor.\n *\n * <p>{@code Readable} component values are mapped based on matching the column\n * name (as obtained from R2DBC meta-data) to public setters in the target class\n * for the corresponding properties. The names are matched either directly or by\n * transforming a name separating the parts with underscores to the same name using\n * \"camel\" case.\n *\n * <p>Mapping is provided for properties in the target class for many common types &mdash;\n * for example: String, boolean, Boolean, byte, Byte, short, Short, int, Integer,\n * long, Long, float, Float, double, Double, BigDecimal, {@code java.util.Date}, etc.\n *\n * <p>To facilitate mapping between columns and properties that don't have matching\n * names, try using column aliases in the SQL statement like\n * {@code \"select fname as first_name from customer\"}, where {@code first_name}\n * can be mapped to a {@code setFirstName(String)} method in the target class.\n *\n * <p>If you need to map to a target class which has a <em>data class</em> constructor\n * &mdash; for example, a Java {@code record} or a Kotlin {@code data} class &mdash;\n * use {@link DataClassRowMapper} instead.\n *\n * <p>Please note that this class is designed to provide convenience rather than\n * high performance. For best performance, consider using a custom mapping function\n * implementation.\n *\n * @author Simon Basl\u00e9\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 6.1\n * @param <T> the result type\n * @see DataClassRowMapper\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "signature": "public class BeanPropertyRowMapper",
    "source_code": "public class BeanPropertyRowMapper<T> implements Function<Readable, T> {\n\n\t/** The class we are mapping to. */\n\tprivate final Class<T> mappedClass;\n\n\t/** ConversionService for binding result values to bean properties. */\n\tprivate final ConversionService conversionService;\n\n\t/** Map of the properties we provide mapping for. */\n\tprivate final Map<String, PropertyDescriptor> mappedProperties;\n\n\n\t/**\n\t * Create a new {@code BeanPropertyRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t */\n\tpublic BeanPropertyRowMapper(Class<T> mappedClass) {\n\t\tthis(mappedClass, DefaultConversionService.getSharedInstance());\n\t}\n\n\t/**\n\t * Create a new {@code BeanPropertyRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t * @param conversionService a {@link ConversionService} for binding\n\t * result values to bean properties\n\t */\n\tpublic BeanPropertyRowMapper(Class<T> mappedClass, ConversionService conversionService) {\n\t\tAssert.notNull(mappedClass, \"Mapped Class must not be null\");\n\t\tAssert.notNull(conversionService, \"ConversionService must not be null\");\n\t\tthis.mappedClass = mappedClass;\n\t\tthis.conversionService = conversionService;\n\t\tthis.mappedProperties = new HashMap<>();\n\n\t\tfor (PropertyDescriptor pd : BeanUtils.getPropertyDescriptors(mappedClass)) {\n\t\t\tif (pd.getWriteMethod() != null) {\n\t\t\t\tString lowerCaseName = lowerCaseName(pd.getName());\n\t\t\t\tthis.mappedProperties.put(lowerCaseName, pd);\n\t\t\t\tString underscoreName = underscoreName(pd.getName());\n\t\t\t\tif (!lowerCaseName.equals(underscoreName)) {\n\t\t\t\t\tthis.mappedProperties.put(underscoreName, pd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Remove the specified property from the mapped properties.\n\t * @param propertyName the property name (as used by property descriptors)\n\t */\n\tprotected void suppressProperty(String propertyName) {\n\t\tthis.mappedProperties.remove(lowerCaseName(propertyName));\n\t\tthis.mappedProperties.remove(underscoreName(propertyName));\n\t}\n\n\t/**\n\t * Convert the given name to lower case.\n\t * <p>By default, conversions will happen within the US locale.\n\t * @param name the original name\n\t * @return the converted name\n\t */\n\tprotected String lowerCaseName(String name) {\n\t\treturn name.toLowerCase(Locale.US);\n\t}\n\n\t/**\n\t * Convert a name in camelCase to an underscored name in lower case.\n\t * <p>Any upper case letters are converted to lower case with a preceding underscore.\n\t * @param name the original name\n\t * @return the converted name\n\t * @see #lowerCaseName\n\t */\n\tprotected String underscoreName(String name) {\n\t\tif (!StringUtils.hasLength(name)) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tStringBuilder result = new StringBuilder();\n\t\tresult.append(Character.toLowerCase(name.charAt(0)));\n\t\tfor (int i = 1; i < name.length(); i++) {\n\t\t\tchar c = name.charAt(i);\n\t\t\tif (Character.isUpperCase(c)) {\n\t\t\t\tresult.append('_').append(Character.toLowerCase(c));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.append(c);\n\t\t\t}\n\t\t}\n\t\treturn result.toString();\n\t}\n\n\t/**\n\t * Extract the values for the current {@link Readable}: all columns in case\n\t * of a {@link Row} or all parameters in case of an {@link OutParameters}.\n\t * <p>Utilizes public setters and derives meta-data from the concrete type.\n\t * @throws IllegalArgumentException in case the concrete type is neither\n\t * {@code Row} nor {@code OutParameters}\n\t * @see RowMetadata\n\t * @see OutParametersMetadata\n\t */\n\t@Override\n\tpublic T apply(Readable readable) {\n\t\tif (readable instanceof Row row) {\n\t\t\treturn mapForReadable(row, row.getMetadata().getColumnMetadatas());\n\t\t}\n\t\tif (readable instanceof OutParameters out) {\n\t\t\treturn mapForReadable(out, out.getMetadata().getParameterMetadatas());\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Can only map Readable Row or OutParameters, got \" + readable.getClass().getName());\n\t}\n\n\tprivate <R extends Readable> T mapForReadable(R readable, List<? extends ReadableMetadata> readableMetadatas) {\n\t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n\t\tbw.setConversionService(this.conversionService);\n\t\tT mappedObject = constructMappedInstance(readable, readableMetadatas, bw);\n\t\tbw.setBeanInstance(mappedObject);\n\n\t\tint readableItemCount = readableMetadatas.size();\n\t\tfor (int itemIndex = 0; itemIndex < readableItemCount; itemIndex++) {\n\t\t\tReadableMetadata itemMetadata = readableMetadatas.get(itemIndex);\n\t\t\tString itemName = itemMetadata.getName();\n\t\t\tString property = lowerCaseName(StringUtils.delete(itemName, \" \"));\n\t\t\tPropertyDescriptor pd = this.mappedProperties.get(property);\n\t\t\tif (pd != null) {\n\t\t\t\tObject value = getItemValue(readable, itemIndex, pd.getPropertyType());\n\t\t\t\tbw.setPropertyValue(pd.getName(), value);\n\t\t\t}\n\t\t}\n\n\t\treturn mappedObject;\n\t}\n\n\t/**\n\t * Construct an instance of the mapped class for the current {@code Readable}.\n\t * <p>The default implementation simply instantiates the mapped class. Can be\n\t * overridden in subclasses.\n\t * @param readable the {@code Readable} being mapped (a {@code Row} or {@code OutParameters})\n\t * @param itemMetadatas the list of item {@code ReadableMetadata} (either\n\t * {@code ColumnMetadata} or {@code OutParameterMetadata})\n\t * @param tc a TypeConverter with this row mapper's conversion service\n\t * @return a corresponding instance of the mapped class\n\t */\n\tprotected T constructMappedInstance(Readable readable, List<? extends ReadableMetadata> itemMetadatas, TypeConverter tc) {\n\t\treturn BeanUtils.instantiateClass(this.mappedClass);\n\t}\n\n\t/**\n\t * Retrieve an R2DBC object value for the specified item index (a column or\n\t * an out-parameter).\n\t * <p>The default implementation calls {@link Readable#get(int, Class)} then\n\t * falls back to {@link Readable#get(int)} in case of an exception.\n\t * Subclasses may override this to check specific value types upfront,\n\t * or to post-process values returned from {@code get}.\n\t * @param readable is the {@code Row} or {@code OutParameters} holding the data\n\t * @param itemIndex is the column index or out-parameter index\n\t * @param paramType the target parameter type\n\t * @return the Object value\n\t * @see Readable#get(int, Class)\n\t * @see Readable#get(int)\n\t */\n\t@Nullable\n\tprotected Object getItemValue(Readable readable, int itemIndex, Class<?> paramType) {\n\t\ttry {\n\t\t\treturn readable.get(itemIndex, paramType);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\treturn readable.get(itemIndex);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#apply(readable)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extract the values for the current {@link Readable}: all columns in case\n\t * of a {@link Row} or all parameters in case of an {@link OutParameters}.\n\t * <p>Utilizes public setters and derives meta-data from the concrete type.\n\t * @throws IllegalArgumentException in case the concrete type is neither\n\t * {@code Row} nor {@code OutParameters}\n\t * @see RowMetadata\n\t * @see OutParametersMetadata\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "readable"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "T",
    "signature": "public T apply(Readable readable)",
    "source_code": "\tpublic T apply(Readable readable) {\n\t\tif (readable instanceof Row row) {\n\t\t\treturn mapForReadable(row, row.getMetadata().getColumnMetadatas());\n\t\t}\n\t\tif (readable instanceof OutParameters out) {\n\t\t\treturn mapForReadable(out, out.getMetadata().getParameterMetadatas());\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Can only map Readable Row or OutParameters, got \" + readable.getClass().getName());\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#constructMappedInstance(readable,itemMetadatas,tc)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Construct an instance of the mapped class for the current {@code Readable}.\n\t * <p>The default implementation simply instantiates the mapped class. Can be\n\t * overridden in subclasses.\n\t * @param readable the {@code Readable} being mapped (a {@code Row} or {@code OutParameters})\n\t * @param itemMetadatas the list of item {@code ReadableMetadata} (either\n\t * {@code ColumnMetadata} or {@code OutParameterMetadata})\n\t * @param tc a TypeConverter with this row mapper's conversion service\n\t * @return a corresponding instance of the mapped class\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "readable",
      "itemMetadatas",
      "tc"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "T",
    "signature": "protected T constructMappedInstance(Readable readable, List<? extends ReadableMetadata> itemMetadatas, TypeConverter tc)",
    "source_code": "\tprotected T constructMappedInstance(Readable readable, List<? extends ReadableMetadata> itemMetadatas, TypeConverter tc) {\n\t\treturn BeanUtils.instantiateClass(this.mappedClass);\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#getItemValue(readable,itemIndex,paramType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve an R2DBC object value for the specified item index (a column or\n\t * an out-parameter).\n\t * <p>The default implementation calls {@link Readable#get(int, Class)} then\n\t * falls back to {@link Readable#get(int)} in case of an exception.\n\t * Subclasses may override this to check specific value types upfront,\n\t * or to post-process values returned from {@code get}.\n\t * @param readable is the {@code Row} or {@code OutParameters} holding the data\n\t * @param itemIndex is the column index or out-parameter index\n\t * @param paramType the target parameter type\n\t * @return the Object value\n\t * @see Readable#get(int, Class)\n\t * @see Readable#get(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "readable",
      "itemIndex",
      "paramType"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "Object",
    "signature": "protected Object getItemValue(Readable readable, int itemIndex, Class<?> paramType)",
    "source_code": "\tprotected Object getItemValue(Readable readable, int itemIndex, Class<?> paramType) {\n\t\ttry {\n\t\t\treturn readable.get(itemIndex, paramType);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\treturn readable.get(itemIndex);\n\t\t}\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#lowerCaseName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given name to lower case.\n\t * <p>By default, conversions will happen within the US locale.\n\t * @param name the original name\n\t * @return the converted name\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "String",
    "signature": "protected String lowerCaseName(String name)",
    "source_code": "\tprotected String lowerCaseName(String name) {\n\t\treturn name.toLowerCase(Locale.US);\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#suppressProperty(propertyName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Remove the specified property from the mapped properties.\n\t * @param propertyName the property name (as used by property descriptors)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "propertyName"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "void",
    "signature": "protected void suppressProperty(String propertyName)",
    "source_code": "\tprotected void suppressProperty(String propertyName) {\n\t\tthis.mappedProperties.remove(lowerCaseName(propertyName));\n\t\tthis.mappedProperties.remove(underscoreName(propertyName));\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#underscoreName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a name in camelCase to an underscored name in lower case.\n\t * <p>Any upper case letters are converted to lower case with a preceding underscore.\n\t * @param name the original name\n\t * @return the converted name\n\t * @see #lowerCaseName\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "String",
    "signature": "protected String underscoreName(String name)",
    "source_code": "\tprotected String underscoreName(String name) {\n\t\tif (!StringUtils.hasLength(name)) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tStringBuilder result = new StringBuilder();\n\t\tresult.append(Character.toLowerCase(name.charAt(0)));\n\t\tfor (int i = 1; i < name.length(); i++) {\n\t\t\tchar c = name.charAt(i);\n\t\t\tif (Character.isUpperCase(c)) {\n\t\t\t\tresult.append('_').append(Character.toLowerCase(c));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.append(c);\n\t\t\t}\n\t\t}\n\t\treturn result.toString();\n\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#createSubscriptionRunnable(method,targetBean,scheduled,observationRegistrySupplier,subscriptionTrackerRegistry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link Runnable} for the Scheduled infrastructure, allowing for scheduled\n\t * subscription to the publisher produced by a reactive method.\n\t * <p>Note that the reactive method is invoked once, but the resulting {@code Publisher}\n\t * is subscribed to repeatedly, once per each invocation of the {@code Runnable}.\n\t * <p>In the case of a fixed-delay configuration, the subscription inside the\n\t * {@link Runnable} is turned into a blocking call in order to maintain fixed-delay\n\t * semantics (i.e. the task blocks until completion of the Publisher, and the\n\t * delay is applied until the next iteration).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetBean",
      "scheduled",
      "observationRegistrySupplier",
      "subscriptionTrackerRegistry"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "Runnable",
    "signature": "public Runnable createSubscriptionRunnable(Method method, Object targetBean, Scheduled scheduled,\n\t\t\tSupplier<ObservationRegistry> observationRegistrySupplier, List<Runnable> subscriptionTrackerRegistry)",
    "source_code": "\tpublic static Runnable createSubscriptionRunnable(Method method, Object targetBean, Scheduled scheduled,"
  },
  "org.springframework.scheduling.annotation.<unknown>#getQualifier()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "String",
    "signature": "public String getQualifier()",
    "source_code": "\t\tpublic String getQualifier() {\n\t\t\treturn this.qualifier;\n\t\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#isReactive(method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Checks that if the method is reactive, it can be scheduled. Methods are considered\n\t * eligible for reactive scheduling if they either return an instance of a type that\n\t * can be converted to {@code Publisher} or are a Kotlin suspending function.\n\t * If the method doesn't match these criteria, this check returns {@code false}.\n\t * <p>For scheduling of Kotlin suspending functions, the Coroutine-Reactor bridge\n\t * {@code kotlinx.coroutines.reactor} must be present at runtime (in order to invoke\n\t * suspending functions as a {@code Publisher}). Provided that is the case, this\n\t * method returns {@code true}. Otherwise, it throws an {@code IllegalStateException}.\n\t * @throws IllegalStateException if the method is reactive but Reactor and/or the\n\t * Kotlin coroutines bridge are not present at runtime\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "boolean",
    "signature": "public boolean isReactive(Method method)",
    "source_code": "\tpublic static boolean isReactive(Method method) {\n\t\tif (KotlinDetector.isKotlinPresent() && KotlinDetector.isSuspendingFunction(method)) {\n\t\t\t// Note that suspending functions declared without args have a single Continuation\n\t\t\t// parameter in reflective inspection\n\t\t\tAssert.isTrue(method.getParameterCount() == 1,\n\t\t\t\t\t\"Kotlin suspending functions may only be annotated with @Scheduled if declared without arguments\");\n\t\t\tAssert.isTrue(coroutinesReactorPresent, \"Kotlin suspending functions may only be annotated with \" +\n\t\t\t\t\t\"@Scheduled if the Coroutine-Reactor bridge (kotlinx.coroutines.reactor) is present at runtime\");\n\t\t\treturn true;\n\t\t}\n\t\tReactiveAdapterRegistry registry = ReactiveAdapterRegistry.getSharedInstance();\n\t\tif (!registry.hasAdapters()) {\n\t\t\treturn false;\n\t\t}\n\t\tClass<?> returnType = method.getReturnType();\n\t\tReactiveAdapter candidateAdapter = registry.getAdapter(returnType);\n\t\tif (candidateAdapter == null) {\n\t\t\treturn false;\n\t\t}\n\t\tAssert.isTrue(method.getParameterCount() == 0,\n\t\t\t\t\"Reactive methods may only be annotated with @Scheduled if declared without arguments\");\n\t\tAssert.isTrue(candidateAdapter.getDescriptor().isDeferred(),\n\t\t\t\t\"Reactive methods may only be annotated with @Scheduled if the return type supports deferred execution\");\n\t\treturn true;\n\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#onComplete()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 324
    },
    "return": "void",
    "signature": "public void onComplete()",
    "source_code": "\t\tpublic void onComplete() {\n\t\t\tthis.subscriptionTrackerRegistry.remove(this);\n\t\t\tif (this.observation.getContext() instanceof ScheduledTaskObservationContext context) {\n\t\t\t\tcontext.setComplete(true);\n\t\t\t}\n\t\t\tthis.observation.stop();\n\t\t\tif (this.blockingLatch != null) {\n\t\t\t\tthis.blockingLatch.countDown();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#onError(ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 313
    },
    "return": "void",
    "signature": "public void onError(Throwable ex)",
    "source_code": "\t\tpublic void onError(Throwable ex) {\n\t\t\tthis.subscriptionTrackerRegistry.remove(this);\n\t\t\tlogger.warn(\"Unexpected error occurred in scheduled reactive task\", ex);\n\t\t\tthis.observation.error(ex);\n\t\t\tthis.observation.stop();\n\t\t\tif (this.blockingLatch != null) {\n\t\t\t\tthis.blockingLatch.countDown();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#onNext(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "void",
    "signature": "public void onNext(Object obj)",
    "source_code": "\t\tpublic void onNext(Object obj) {\n\t\t\t// no-op\n\t\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#onSubscribe(subscription)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "subscription"
    ],
    "position": {
      "column": 1,
      "line": 301
    },
    "return": "void",
    "signature": "public void onSubscribe(Subscription subscription)",
    "source_code": "\t\tpublic void onSubscribe(Subscription subscription) {\n\t\t\tthis.subscription = subscription;\n\t\t\tthis.observation.start();\n\t\t\tsubscription.request(Integer.MAX_VALUE);\n\t\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#run()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "void",
    "signature": "public void run()",
    "source_code": "\t\tpublic void run() {\n\t\t\tif (this.subscription != null) {\n\t\t\t\tthis.subscription.cancel();\n\t\t\t\tthis.observation.stop();\n\t\t\t}\n\t\t\tif (this.blockingLatch != null) {\n\t\t\t\tthis.blockingLatch.countDown();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor#createRunnable(target,method,qualifier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link Runnable} for the given bean instance,\n\t * calling the specified scheduled method.\n\t * <p>The default implementation creates a {@link ScheduledMethodRunnable}.\n\t * @param target the target bean instance\n\t * @param method the scheduled method to call\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target",
      "method",
      "qualifier"
    ],
    "position": {
      "column": 1,
      "line": 526
    },
    "return": "Runnable",
    "signature": "protected Runnable createRunnable(Object target, Method method, @Nullable String qualifier)",
    "source_code": "\tprotected Runnable createRunnable(Object target, Method method, @Nullable String qualifier) {\n\t\tRunnable runnable = createRunnable(target, method);\n\t\tif (runnable != null) {\n\t\t\treturn runnable;\n\t\t}\n\t\tAssert.isTrue(method.getParameterCount() == 0, \"Only no-arg methods may be annotated with @Scheduled\");\n\t\tMethod invocableMethod = AopUtils.selectInvocableMethod(method, target.getClass());\n\t\treturn new ScheduledMethodRunnable(target, invocableMethod, qualifier, this.registrar::getObservationRegistry);\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#afterExecute(task,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An after-execute callback for framework subclasses to delegate to\n\t * (for start/stop handling), and possibly also for custom subclasses\n\t * to extend (making sure to call this implementation as well).\n\t * @param task the task that has been executed\n\t * @param ex the exception thrown during execution, if any\n\t * @since 6.1\n\t * @see ThreadPoolExecutor#afterExecute(Runnable, Throwable)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 454
    },
    "return": "void",
    "signature": "protected void afterExecute(Runnable task, @Nullable Throwable ex)",
    "source_code": "\tprotected void afterExecute(Runnable task, @Nullable Throwable ex) {\n\t\tif (this.lifecycleDelegate != null) {\n\t\t\tthis.lifecycleDelegate.afterExecute();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#beforeExecute(thread,task)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A before-execute callback for framework subclasses to delegate to\n\t * (for start/stop handling), and possibly also for custom subclasses\n\t * to extend (making sure to call this implementation as well).\n\t * @param thread the thread to run the task\n\t * @param task the task to be executed\n\t * @since 6.1\n\t * @see ThreadPoolExecutor#beforeExecute(Thread, Runnable)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "thread",
      "task"
    ],
    "position": {
      "column": 1,
      "line": 439
    },
    "return": "void",
    "signature": "protected void beforeExecute(Thread thread, Runnable task)",
    "source_code": "\tprotected void beforeExecute(Thread thread, Runnable task) {\n\t\tif (this.lifecycleDelegate != null) {\n\t\t\tthis.lifecycleDelegate.beforeExecute(thread);\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#getPhase()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the lifecycle phase for pausing and resuming this executor.\n\t * @since 6.1\n\t * @see #setPhase\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "int",
    "signature": "public int getPhase()",
    "source_code": "\tpublic int getPhase() {\n\t\treturn this.phase;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#initiateEarlyShutdown()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Early shutdown signal: do not trigger further tasks, let existing tasks complete\n\t * before hitting the actual destruction step in the {@link #shutdown()} method.\n\t * This goes along with a {@link #stop(Runnable) coordinated lifecycle stop phase}.\n\t * <p>Called from {@link #onApplicationEvent(ContextClosedEvent)} if no\n\t * indications for a late shutdown have been determined, that is, if the\n\t * {@link #setAcceptTasksAfterContextClose \"acceptTasksAfterContextClose} and\n\t * {@link #setWaitForTasksToCompleteOnShutdown \"waitForTasksToCompleteOnShutdown\"}\n\t * flags have not been set.\n\t * <p>The default implementation calls {@link #initiateShutdown()}.\n\t * @since 6.1.4\n\t * @see #initiateShutdown()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 494
    },
    "return": "void",
    "signature": "protected void initiateEarlyShutdown()",
    "source_code": "\tprotected void initiateEarlyShutdown() {\n\t\tinitiateShutdown();\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#initiateShutdown()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initiate a shutdown on the underlying ExecutorService,\n\t * rejecting further task submissions.\n\t * <p>The executor will not accept further tasks and will prevent further\n\t * scheduling of periodic tasks, letting existing tasks complete still.\n\t * This step is non-blocking and can be applied as an early shutdown signal\n\t * before following up with a full {@link #shutdown()} call later on.\n\t * <p>Automatically called for early shutdown signals on\n\t * {@link #onApplicationEvent(ContextClosedEvent) context close}.\n\t * Can be manually called as well, in particular outside a container.\n\t * @since 6.1\n\t * @see #shutdown()\n\t * @see java.util.concurrent.ExecutorService#shutdown()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "void",
    "signature": "public void initiateShutdown()",
    "source_code": "\tpublic void initiateShutdown() {\n\t\tif (this.executor != null) {\n\t\t\tthis.executor.shutdown();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#isRunning()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether this executor is not paused and has not been shut down either.\n\t * @since 6.1\n\t * @see #start()\n\t * @see #stop()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 426
    },
    "return": "boolean",
    "signature": "public boolean isRunning()",
    "source_code": "\tpublic boolean isRunning() {\n\t\treturn (this.lifecycleDelegate != null && this.lifecycleDelegate.isRunning());\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#onApplicationEvent(event)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@link ContextClosedEvent} handler for initiating an early shutdown.\n\t * @since 6.1\n\t * @see #initiateShutdown()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "event"
    ],
    "position": {
      "column": 1,
      "line": 466
    },
    "return": "void",
    "signature": "public void onApplicationEvent(ContextClosedEvent event)",
    "source_code": "\tpublic void onApplicationEvent(ContextClosedEvent event) {\n\t\tif (event.getApplicationContext() == this.applicationContext) {\n\t\t\tif (this.acceptTasksAfterContextClose || this.waitForTasksToCompleteOnShutdown) {\n\t\t\t\t// Late shutdown without early stop lifecycle.\n\t\t\t\tthis.lateShutdown = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (this.lifecycleDelegate != null) {\n\t\t\t\t\tthis.lifecycleDelegate.markShutdown();\n\t\t\t\t}\n\t\t\t\tinitiateEarlyShutdown();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#setAcceptTasksAfterContextClose(acceptTasksAfterContextClose)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to accept further tasks after the application context close phase\n\t * has begun.\n\t * <p>The default is {@code false} as of 6.1, triggering an early soft shutdown of\n\t * the executor and therefore rejecting any further task submissions. Switch this\n\t * to {@code true} in order to let other components submit tasks even during their\n\t * own stop and destruction callbacks, at the expense of a longer shutdown phase.\n\t * The executor will not go through a coordinated lifecycle stop phase then\n\t * but rather only stop tasks on its own shutdown.\n\t * <p>{@code acceptTasksAfterContextClose=true} like behavior also follows from\n\t * {@link #setWaitForTasksToCompleteOnShutdown \"waitForTasksToCompleteOnShutdown\"}\n\t * which effectively is a specific variant of this flag, replacing the early soft\n\t * shutdown in the concurrent managed stop phase with a serial soft shutdown in\n\t * the executor's destruction step, with individual awaiting according to the\n\t * {@link #setAwaitTerminationSeconds \"awaitTerminationSeconds\"} property.\n\t * <p>This flag will only have effect when the executor is running in a Spring\n\t * application context and able to receive the {@link ContextClosedEvent}. Also,\n\t * note that {@link ThreadPoolTaskExecutor} effectively accepts tasks after context\n\t * close by default, in combination with a coordinated lifecycle stop, unless\n\t * {@link ThreadPoolTaskExecutor#setStrictEarlyShutdown \"strictEarlyShutdown\"}\n\t * has been specified.\n\t * @since 6.1\n\t * @see org.springframework.context.ConfigurableApplicationContext#close()\n\t * @see DisposableBean#destroy()\n\t * @see #shutdown()\n\t * @see #setAwaitTerminationSeconds\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "acceptTasksAfterContextClose"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "void",
    "signature": "public void setAcceptTasksAfterContextClose(boolean acceptTasksAfterContextClose)",
    "source_code": "\tpublic void setAcceptTasksAfterContextClose(boolean acceptTasksAfterContextClose) {\n\t\tthis.acceptTasksAfterContextClose = acceptTasksAfterContextClose;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#setApplicationContext(applicationContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "applicationContext"
    ],
    "position": {
      "column": 1,
      "line": 245
    },
    "return": "void",
    "signature": "public void setApplicationContext(ApplicationContext applicationContext)",
    "source_code": "\tpublic void setApplicationContext(ApplicationContext applicationContext) {\n\t\tthis.applicationContext = applicationContext;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#setPhase(phase)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the lifecycle phase for pausing and resuming this executor.\n\t * The default is {@link #DEFAULT_PHASE}.\n\t * @since 6.1\n\t * @see SmartLifecycle#getPhase()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "phase"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "void",
    "signature": "public void setPhase(int phase)",
    "source_code": "\tpublic void setPhase(int phase) {\n\t\tthis.phase = phase;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#start()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resume this executor if paused before (otherwise a no-op).\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 387
    },
    "return": "void",
    "signature": "public void start()",
    "source_code": "\tpublic void start() {\n\t\tif (this.lifecycleDelegate != null) {\n\t\t\tthis.lifecycleDelegate.start();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#stop()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Pause this executor, not waiting for tasks to complete.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 398
    },
    "return": "void",
    "signature": "public void stop()",
    "source_code": "\tpublic void stop() {\n\t\tif (this.lifecycleDelegate != null && !this.lateShutdown) {\n\t\t\tthis.lifecycleDelegate.stop();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#stop(callback)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Pause this executor, triggering the given callback\n\t * once all currently executing tasks have completed.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 410
    },
    "return": "void",
    "signature": "public void stop(Runnable callback)",
    "source_code": "\tpublic void stop(Runnable callback) {\n\t\tif (this.lifecycleDelegate != null && !this.lateShutdown) {\n\t\t\tthis.lifecycleDelegate.stop(callback);\n\t\t}\n\t\telse {\n\t\t\tcallback.run();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean#afterExecute(task,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "void",
    "signature": "protected void afterExecute(Runnable task, Throwable ex)",
    "source_code": "\t\t\tprotected void afterExecute(Runnable task, Throwable ex) {\n\t\t\t\tScheduledExecutorFactoryBean.this.afterExecute(task, ex);\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean#beforeExecute(thread,task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "thread",
      "task"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "void",
    "signature": "protected void beforeExecute(Thread thread, Runnable task)",
    "source_code": "\t\t\tprotected void beforeExecute(Thread thread, Runnable task) {\n\t\t\t\tScheduledExecutorFactoryBean.this.beforeExecute(thread, task);\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A simple implementation of Spring's {@link TaskScheduler} interface, using\n * a single scheduler thread and executing every scheduled task in an individual\n * separate thread. This is an attractive choice with virtual threads on JDK 21,\n * expecting common usage with {@link #setVirtualThreads setVirtualThreads(true)}.\n *\n * <p><b>NOTE: Scheduling with a fixed delay enforces execution on the single\n * scheduler thread, in order to provide traditional fixed-delay semantics!</b>\n * Prefer the use of fixed rates or cron triggers instead which are a better fit\n * with this thread-per-task scheduler variant.\n *\n * <p>Supports a graceful shutdown through {@link #setTaskTerminationTimeout},\n * at the expense of task tracking overhead per execution thread at runtime.\n * Supports limiting concurrent threads through {@link #setConcurrencyLimit}.\n * By default, the number of concurrent task executions is unlimited.\n * This allows for dynamic concurrency of scheduled task executions, in contrast\n * to {@link ThreadPoolTaskScheduler} which requires a fixed pool size.\n *\n * <p><b>NOTE: This implementation does not reuse threads!</b> Consider a\n * thread-pooling TaskScheduler implementation instead, in particular for\n * scheduling a large number of short-lived tasks. Alternatively, on JDK 21,\n * consider setting {@link #setVirtualThreads} to {@code true}.\n *\n * <p>Extends {@link SimpleAsyncTaskExecutor} and can serve as a fully capable\n * replacement for it, e.g. as a single shared instance serving as a\n * {@link org.springframework.core.task.TaskExecutor} as well as a {@link TaskScheduler}.\n * This is generally not the case with other executor/scheduler implementations\n * which tend to have specific constraints for the scheduler thread pool,\n * requiring a separate thread pool for general executor purposes in practice.\n *\n * <p><b>NOTE: This scheduler variant does not track the actual completion of tasks\n * but rather just the hand-off to an execution thread.</b> As a consequence,\n * a {@link ScheduledFuture} handle (e.g. from {@link #schedule(Runnable, Instant)})\n * represents that hand-off rather than the actual completion of the provided task\n * (or series of repeated tasks).\n *\n * <p>As an alternative to the built-in thread-per-task capability, this scheduler\n * can also be configured with a separate target executor for scheduled task\n * execution through {@link #setTargetTaskExecutor}: e.g. pointing to a shared\n * {@link ThreadPoolTaskExecutor} bean. This is still rather different from a\n * {@link ThreadPoolTaskScheduler} setup since it always uses a single scheduler\n * thread while dynamically dispatching to the target thread pool which may have\n * a dynamic core/max pool size range, participating in a shared concurrency limit.\n *\n * @author Juergen Hoeller\n * @since 6.1\n * @see #setVirtualThreads\n * @see #setTaskTerminationTimeout\n * @see #setConcurrencyLimit\n * @see SimpleAsyncTaskExecutor\n * @see ThreadPoolTaskScheduler\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "signature": "public class SimpleAsyncTaskScheduler",
    "source_code": "public class SimpleAsyncTaskScheduler extends SimpleAsyncTaskExecutor implements TaskScheduler,"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#afterExecute(task,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "void",
    "signature": "protected void afterExecute(Runnable task, Throwable ex)",
    "source_code": "\t\t\tprotected void afterExecute(Runnable task, Throwable ex) {\n\t\t\t\tlifecycleDelegate.afterExecute();\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#beforeExecute(thread,task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "thread",
      "task"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "void",
    "signature": "protected void beforeExecute(Thread thread, Runnable task)",
    "source_code": "\t\t\tprotected void beforeExecute(Thread thread, Runnable task) {\n\t\t\t\tlifecycleDelegate.beforeExecute(thread);\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#close()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 315
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\tpublic void close() {\n\t\tfor (Runnable remainingTask : this.scheduledExecutor.shutdownNow()) {\n\t\t\tif (remainingTask instanceof Future<?> future) {\n\t\t\t\tfuture.cancel(true);\n\t\t\t}\n\t\t}\n\t\tsuper.close();\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#doExecute(task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "void",
    "signature": "protected void doExecute(Runnable task)",
    "source_code": "\tprotected void doExecute(Runnable task) {\n\t\tif (this.targetTaskExecutor != null) {\n\t\t\tthis.targetTaskExecutor.execute(task);\n\t\t}\n\t\telse {\n\t\t\tsuper.doExecute(task);\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#getClock()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "Clock",
    "signature": "public Clock getClock()",
    "source_code": "\tpublic Clock getClock() {\n\t\treturn this.clock;\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#getPhase()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the lifecycle phase for pausing and resuming this executor.\n\t * @see #setPhase\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "int",
    "signature": "public int getPhase()",
    "source_code": "\tpublic int getPhase() {\n\t\treturn this.phase;\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#isRunning()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 303
    },
    "return": "boolean",
    "signature": "public boolean isRunning()",
    "source_code": "\tpublic boolean isRunning() {\n\t\treturn this.lifecycleDelegate.isRunning();\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#onApplicationEvent(event)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "event"
    ],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "void",
    "signature": "public void onApplicationEvent(ContextClosedEvent event)",
    "source_code": "\tpublic void onApplicationEvent(ContextClosedEvent event) {\n\t\tif (event.getApplicationContext() == this.applicationContext) {\n\t\t\tthis.scheduledExecutor.shutdown();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#setApplicationContext(applicationContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "applicationContext"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "void",
    "signature": "public void setApplicationContext(ApplicationContext applicationContext)",
    "source_code": "\tpublic void setApplicationContext(ApplicationContext applicationContext) {\n\t\tthis.applicationContext = applicationContext;\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#setClock(clock)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the clock to use for scheduling purposes.\n\t * <p>The default clock is the system clock for the default time zone.\n\t * @see Clock#systemDefaultZone()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clock"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void setClock(Clock clock)",
    "source_code": "\tpublic void setClock(Clock clock) {\n\t\tAssert.notNull(clock, \"Clock must not be null\");\n\t\tthis.clock = clock;\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#setPhase(phase)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the lifecycle phase for pausing and resuming this executor.\n\t * The default is {@link #DEFAULT_PHASE}.\n\t * @see SmartLifecycle#getPhase()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "phase"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "void",
    "signature": "public void setPhase(int phase)",
    "source_code": "\tpublic void setPhase(int phase) {\n\t\tthis.phase = phase;\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#setTargetTaskExecutor(targetTaskExecutor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify a custom target {@link Executor} to delegate to for\n\t * the individual execution of scheduled tasks. This can for example\n\t * be set to a separate thread pool for executing scheduled tasks,\n\t * whereas this scheduler keeps using its single scheduler thread.\n\t * <p>If not set, the regular {@link SimpleAsyncTaskExecutor}\n\t * arrangements kicks in with a new thread per task.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetTaskExecutor"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "void",
    "signature": "public void setTargetTaskExecutor(Executor targetTaskExecutor)",
    "source_code": "\tpublic void setTargetTaskExecutor(Executor targetTaskExecutor) {\n\t\tthis.targetTaskExecutor = (targetTaskExecutor == this ? null : targetTaskExecutor);\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#start()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "void",
    "signature": "public void start()",
    "source_code": "\tpublic void start() {\n\t\tthis.lifecycleDelegate.start();\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#stop()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "void",
    "signature": "public void stop()",
    "source_code": "\tpublic void stop() {\n\t\tthis.lifecycleDelegate.stop();\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#stop(callback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 298
    },
    "return": "void",
    "signature": "public void stop(Runnable callback)",
    "source_code": "\tpublic void stop(Runnable callback) {\n\t\tthis.lifecycleDelegate.stop(callback);\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#afterExecute(task,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "void",
    "signature": "protected void afterExecute(Runnable task, Throwable ex)",
    "source_code": "\t\t\tprotected void afterExecute(Runnable task, Throwable ex) {\n\t\t\t\tThreadPoolTaskExecutor.this.afterExecute(task, ex);\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#beforeExecute(thread,task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "thread",
      "task"
    ],
    "position": {
      "column": 1,
      "line": 298
    },
    "return": "void",
    "signature": "protected void beforeExecute(Thread thread, Runnable task)",
    "source_code": "\t\t\tprotected void beforeExecute(Thread thread, Runnable task) {\n\t\t\t\tThreadPoolTaskExecutor.this.beforeExecute(thread, task);\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#execute(task,startTimeout)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "startTimeout"
    ],
    "position": {
      "column": 1,
      "line": 369
    },
    "return": "void",
    "signature": "public void execute(Runnable task, long startTimeout)",
    "source_code": "\tpublic void execute(Runnable task, long startTimeout) {\n\t\texecute(task);\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#initiateEarlyShutdown()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 454
    },
    "return": "void",
    "signature": "protected void initiateEarlyShutdown()",
    "source_code": "\tprotected void initiateEarlyShutdown() {\n\t\tif (this.strictEarlyShutdown) {\n\t\t\tsuper.initiateEarlyShutdown();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#setStrictEarlyShutdown(defaultEarlyShutdown)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether to initiate an early shutdown signal on context close,\n\t * disposing all idle threads and rejecting further task submissions.\n\t * <p>By default, existing tasks will be allowed to complete within the\n\t * coordinated lifecycle stop phase in any case. This setting just controls\n\t * whether an explicit {@link ThreadPoolExecutor#shutdown()} call will be\n\t * triggered on context close, rejecting task submissions after that point.\n\t * <p>As of 6.1.4, the default is \"false\", leniently allowing for late tasks\n\t * to arrive after context close, still participating in the lifecycle stop\n\t * phase. Note that this differs from {@link #setAcceptTasksAfterContextClose}\n\t * which completely bypasses the coordinated lifecycle stop phase, with no\n\t * explicit waiting for the completion of existing tasks at all.\n\t * <p>Switch this to \"true\" for a strict early shutdown signal analogous to\n\t * the 6.1-established default behavior of {@link ThreadPoolTaskScheduler}.\n\t * Note that the related flags {@link #setAcceptTasksAfterContextClose} and\n\t * {@link #setWaitForTasksToCompleteOnShutdown} will override this setting,\n\t * leading to a late shutdown without a coordinated lifecycle stop phase.\n\t * @since 6.1.4\n\t * @see #initiateShutdown()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultEarlyShutdown"
    ],
    "position": {
      "column": 1,
      "line": 245
    },
    "return": "void",
    "signature": "public void setStrictEarlyShutdown(boolean defaultEarlyShutdown)",
    "source_code": "\tpublic void setStrictEarlyShutdown(boolean defaultEarlyShutdown) {\n\t\tthis.strictEarlyShutdown = defaultEarlyShutdown;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#afterExecute(task,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "void",
    "signature": "protected void afterExecute(Runnable task, Throwable ex)",
    "source_code": "\t\t\tprotected void afterExecute(Runnable task, Throwable ex) {\n\t\t\t\tThreadPoolTaskScheduler.this.afterExecute(task, ex);\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#beforeExecute(thread,task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "thread",
      "task"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "void",
    "signature": "protected void beforeExecute(Thread thread, Runnable task)",
    "source_code": "\t\t\tprotected void beforeExecute(Thread thread, Runnable task) {\n\t\t\t\tThreadPoolTaskScheduler.this.beforeExecute(thread, task);\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#execute(task,startTimeout)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "startTimeout"
    ],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "void",
    "signature": "public void execute(Runnable task, long startTimeout)",
    "source_code": "\tpublic void execute(Runnable task, long startTimeout) {\n\t\texecute(task);\n\t}"
  },
  "org.springframework.scheduling.config.DEFAULT_TASK_SCHEDULER_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The default name of the {@link TaskScheduler} bean to pick up: {@value}.\n\t * <p>Note that the initial lookup happens by type; this is just the fallback\n\t * in case of multiple scheduler beans found in the context.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "signature": "public String DEFAULT_TASK_SCHEDULER_BEAN_NAME",
    "source_code": "\tpublic static final String DEFAULT_TASK_SCHEDULER_BEAN_NAME = \"taskScheduler\";",
    "type": "String"
  },
  "org.springframework.scheduling.config.ExecutorBeanDefinitionParser": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Parser for the 'executor' element of the 'task' namespace.\n *\n * @author Mark Fisher\n * @author Juergen Hoeller\n * @since 3.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 34
    },
    "signature": "public class ExecutorBeanDefinitionParser",
    "source_code": "public class ExecutorBeanDefinitionParser extends AbstractSingleBeanDefinitionParser {\n\n\t@Override\n\tprotected String getBeanClassName(Element element) {\n\t\treturn \"org.springframework.scheduling.config.TaskExecutorFactoryBean\";\n\t}\n\n\t@Override\n\tprotected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {\n\t\tString keepAliveSeconds = element.getAttribute(\"keep-alive\");\n\t\tif (StringUtils.hasText(keepAliveSeconds)) {\n\t\t\tbuilder.addPropertyValue(\"keepAliveSeconds\", keepAliveSeconds);\n\t\t}\n\t\tString queueCapacity = element.getAttribute(\"queue-capacity\");\n\t\tif (StringUtils.hasText(queueCapacity)) {\n\t\t\tbuilder.addPropertyValue(\"queueCapacity\", queueCapacity);\n\t\t}\n\t\tconfigureRejectionPolicy(element, builder);\n\t\tString poolSize = element.getAttribute(\"pool-size\");\n\t\tif (StringUtils.hasText(poolSize)) {\n\t\t\tbuilder.addPropertyValue(\"poolSize\", poolSize);\n\t\t}\n\t}\n\n\tprivate void configureRejectionPolicy(Element element, BeanDefinitionBuilder builder) {\n\t\tString rejectionPolicy = element.getAttribute(\"rejection-policy\");\n\t\tif (!StringUtils.hasText(rejectionPolicy)) {\n\t\t\treturn;\n\t\t}\n\t\tString prefix = \"java.util.concurrent.ThreadPoolExecutor.\";\n\t\tString policyClassName = switch (rejectionPolicy) {\n\t\t\tcase \"ABORT\" -> prefix + \"AbortPolicy\";\n\t\t\tcase \"CALLER_RUNS\" -> prefix + \"CallerRunsPolicy\";\n\t\t\tcase \"DISCARD\" -> prefix + \"DiscardPolicy\";\n\t\t\tcase \"DISCARD_OLDEST\" -> prefix + \"DiscardOldestPolicy\";\n\t\t\tdefault -> rejectionPolicy;\n\t\t};\n\t\tbuilder.addPropertyValue(\"rejectedExecutionHandler\", new RootBeanDefinition(policyClassName));\n\t}\n\n}"
  },
  "org.springframework.scheduling.config.ExecutorBeanDefinitionParser#doParse(element,parserContext,builder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "element",
      "parserContext",
      "builder"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "return": "void",
    "signature": "protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder)",
    "source_code": "\tprotected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {\n\t\tString keepAliveSeconds = element.getAttribute(\"keep-alive\");\n\t\tif (StringUtils.hasText(keepAliveSeconds)) {\n\t\t\tbuilder.addPropertyValue(\"keepAliveSeconds\", keepAliveSeconds);\n\t\t}\n\t\tString queueCapacity = element.getAttribute(\"queue-capacity\");\n\t\tif (StringUtils.hasText(queueCapacity)) {\n\t\t\tbuilder.addPropertyValue(\"queueCapacity\", queueCapacity);\n\t\t}\n\t\tconfigureRejectionPolicy(element, builder);\n\t\tString poolSize = element.getAttribute(\"pool-size\");\n\t\tif (StringUtils.hasText(poolSize)) {\n\t\t\tbuilder.addPropertyValue(\"poolSize\", poolSize);\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.config.ExecutorBeanDefinitionParser#getBeanClassName(element)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "element"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "return": "String",
    "signature": "protected String getBeanClassName(Element element)",
    "source_code": "\tprotected String getBeanClassName(Element element) {\n\t\treturn \"org.springframework.scheduling.config.TaskExecutorFactoryBean\";\n\t}"
  },
  "org.springframework.scheduling.config.ScheduledTaskRegistrar#addFixedDelayTask(task,delay)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a Runnable task to be triggered with the given fixed delay.\n\t * @since 6.0\n\t * @see TaskScheduler#scheduleWithFixedDelay(Runnable, Duration)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "delay"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "void",
    "signature": "public void addFixedDelayTask(Runnable task, Duration delay)",
    "source_code": "\tpublic void addFixedDelayTask(Runnable task, Duration delay) {\n\t\taddFixedDelayTask(new IntervalTask(task, delay));\n\t}"
  },
  "org.springframework.scheduling.config.ScheduledTaskRegistrar#addFixedDelayTask(task,interval)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a Runnable task to be triggered with the given fixed delay.\n\t * @since 6.0\n\t * @see TaskScheduler#scheduleWithFixedDelay(Runnable, Duration)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "interval"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "void",
    "signature": "public void addFixedDelayTask(Runnable task, Duration interval)",
    "source_code": "\tpublic void addFixedDelayTask(Runnable task, Duration interval) {\n\t\taddFixedDelayTask(new IntervalTask(task, interval));\n\t}"
  },
  "org.springframework.scheduling.config.ScheduledTaskRegistrar#addOneTimeTask(task)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a one-time {@link DelayedTask}.\n\t * @since 6.1\n\t * @see TaskScheduler#schedule(Runnable, Instant)\n\t * @see OneTimeTask\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 395
    },
    "return": "void",
    "signature": "public void addOneTimeTask(DelayedTask task)",
    "source_code": "\tpublic void addOneTimeTask(DelayedTask task) {\n\t\tif (this.oneTimeTasks == null) {\n\t\t\tthis.oneTimeTasks = new ArrayList<>();\n\t\t}\n\t\tthis.oneTimeTasks.add(task);\n\t}"
  },
  "org.springframework.scheduling.config.ScheduledTaskRegistrar#addOneTimeTask(task,initialDelay)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a Runnable task to be triggered once after the given initial delay.\n\t * @since 6.1\n\t * @see TaskScheduler#schedule(Runnable, Instant)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "initialDelay"
    ],
    "position": {
      "column": 1,
      "line": 385
    },
    "return": "void",
    "signature": "public void addOneTimeTask(Runnable task, Duration initialDelay)",
    "source_code": "\tpublic void addOneTimeTask(Runnable task, Duration initialDelay) {\n\t\taddOneTimeTask(new OneTimeTask(task, initialDelay));\n\t}"
  },
  "org.springframework.scheduling.config.ScheduledTaskRegistrar#getObservationRegistry()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link ObservationRegistry} for this registrar.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "ObservationRegistry",
    "signature": "public ObservationRegistry getObservationRegistry()",
    "source_code": "\tpublic ObservationRegistry getObservationRegistry() {\n\t\treturn this.observationRegistry;\n\t}"
  },
  "org.springframework.scheduling.config.ScheduledTaskRegistrar#scheduleOneTimeTask(task)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Schedule the specified one-time task, either right away if possible\n\t * or on initialization of the scheduler.\n\t * @return a handle to the scheduled task, allowing to cancel it\n\t * (or {@code null} if processing a previously registered task)\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 607
    },
    "return": "ScheduledTask",
    "signature": "public ScheduledTask scheduleOneTimeTask(OneTimeTask task)",
    "source_code": "\tpublic ScheduledTask scheduleOneTimeTask(OneTimeTask task) {\n\t\tScheduledTask scheduledTask = this.unresolvedTasks.remove(task);\n\t\tboolean newTask = false;\n\t\tif (scheduledTask == null) {\n\t\t\tscheduledTask = new ScheduledTask(task);\n\t\t\tnewTask = true;\n\t\t}\n\t\tif (this.taskScheduler != null) {\n\t\t\tInstant startTime = this.taskScheduler.getClock().instant().plus(task.getInitialDelayDuration());\n\t\t\tscheduledTask.future = this.taskScheduler.schedule(task.getRunnable(), startTime);\n\t\t}\n\t\telse {\n\t\t\taddOneTimeTask(task);\n\t\t\tthis.unresolvedTasks.put(task, scheduledTask);\n\t\t}\n\t\treturn (newTask ? scheduledTask : null);\n\t}"
  },
  "org.springframework.scheduling.config.ScheduledTaskRegistrar#setObservationRegistry(observationRegistry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure an {@link ObservationRegistry} to record observations for scheduled tasks.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "observationRegistry"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "void",
    "signature": "public void setObservationRegistry(@Nullable ObservationRegistry observationRegistry)",
    "source_code": "\tpublic void setObservationRegistry(@Nullable ObservationRegistry observationRegistry) {\n\t\tthis.observationRegistry = observationRegistry;\n\t}"
  },
  "org.springframework.scheduling.config.TaskSchedulerRouter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A routing implementation of the {@link TaskScheduler} interface,\n * delegating to a target scheduler based on an identified qualifier\n * or using a default scheduler otherwise.\n *\n * @author Juergen Hoeller\n * @since 6.1\n * @see SchedulingAwareRunnable#getQualifier()\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "signature": "public class TaskSchedulerRouter",
    "source_code": "public class TaskSchedulerRouter implements TaskScheduler, BeanNameAware, BeanFactoryAware, DisposableBean {\n\n\t/**\n\t * The default name of the {@link TaskScheduler} bean to pick up: {@value}.\n\t * <p>Note that the initial lookup happens by type; this is just the fallback\n\t * in case of multiple scheduler beans found in the context.\n\t */\n\tpublic static final String DEFAULT_TASK_SCHEDULER_BEAN_NAME = \"taskScheduler\";\n\n\n\tprotected static final Log logger = LogFactory.getLog(TaskSchedulerRouter.class);\n\n\t@Nullable\n\tprivate String beanName;\n\n\t@Nullable\n\tprivate BeanFactory beanFactory;\n\n\t@Nullable\n\tprivate StringValueResolver embeddedValueResolver;\n\n\tprivate final Supplier<TaskScheduler> defaultScheduler = SingletonSupplier.of(this::determineDefaultScheduler);\n\n\t@Nullable\n\tprivate volatile ScheduledExecutorService localExecutor;\n\n\n\t/**\n\t * The bean name for this router, or the bean name of the containing\n\t * bean if the router instance is internally held.\n\t */\n\t@Override\n\tpublic void setBeanName(@Nullable String name) {\n\t\tthis.beanName = name;\n\t}\n\n\t/**\n\t * The bean factory for scheduler lookups.\n\t */\n\t@Override\n\tpublic void setBeanFactory(@Nullable BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t\tif (beanFactory instanceof ConfigurableBeanFactory configurableBeanFactory) {\n\t\t\tthis.embeddedValueResolver = new EmbeddedValueResolver(configurableBeanFactory);\n\t\t}\n\t}\n\n\n\t@Override\n\t@Nullable\n\tpublic ScheduledFuture<?> schedule(Runnable task, Trigger trigger) {\n\t\treturn determineTargetScheduler(task).schedule(task, trigger);\n\t}\n\n\t@Override\n\tpublic ScheduledFuture<?> schedule(Runnable task, Instant startTime) {\n\t\treturn determineTargetScheduler(task).schedule(task, startTime);\n\t}\n\n\t@Override\n\tpublic ScheduledFuture<?> scheduleAtFixedRate(Runnable task, Instant startTime, Duration period) {\n\t\treturn determineTargetScheduler(task).scheduleAtFixedRate(task, startTime, period);\n\t}\n\n\t@Override\n\tpublic ScheduledFuture<?> scheduleAtFixedRate(Runnable task, Duration period) {\n\t\treturn determineTargetScheduler(task).scheduleAtFixedRate(task, period);\n\t}\n\n\t@Override\n\tpublic ScheduledFuture<?> scheduleWithFixedDelay(Runnable task, Instant startTime, Duration delay) {\n\t\treturn determineTargetScheduler(task).scheduleWithFixedDelay(task, startTime, delay);\n\t}\n\n\t@Override\n\tpublic ScheduledFuture<?> scheduleWithFixedDelay(Runnable task, Duration delay) {\n\t\treturn determineTargetScheduler(task).scheduleWithFixedDelay(task, delay);\n\t}\n\n\n\tprotected TaskScheduler determineTargetScheduler(Runnable task) {\n\t\tString qualifier = determineQualifier(task);\n\t\tif (this.embeddedValueResolver != null && StringUtils.hasLength(qualifier)) {\n\t\t\tqualifier = this.embeddedValueResolver.resolveStringValue(qualifier);\n\t\t}\n\t\tif (StringUtils.hasLength(qualifier)) {\n\t\t\treturn determineQualifiedScheduler(qualifier);\n\t\t}\n\t\telse {\n\t\t\treturn this.defaultScheduler.get();\n\t\t}\n\t}\n\n\t@Nullable\n\tprotected String determineQualifier(Runnable task) {\n\t\treturn (task instanceof SchedulingAwareRunnable sar ? sar.getQualifier() : null);\n\t}\n\n\tprotected TaskScheduler determineQualifiedScheduler(String qualifier) {\n\t\tAssert.state(this.beanFactory != null, \"BeanFactory must be set to find qualified scheduler\");\n\t\ttry {\n\t\t\treturn BeanFactoryAnnotationUtils.qualifiedBeanOfType(this.beanFactory, TaskScheduler.class, qualifier);\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException | BeanNotOfRequiredTypeException ex) {\n\t\t\treturn new ConcurrentTaskScheduler(BeanFactoryAnnotationUtils.qualifiedBeanOfType(\n\t\t\t\t\tthis.beanFactory, ScheduledExecutorService.class, qualifier));\n\t\t}\n\t}\n\n\tprotected TaskScheduler determineDefaultScheduler() {\n\t\tAssert.state(this.beanFactory != null, \"BeanFactory must be set to find default scheduler\");\n\t\ttry {\n\t\t\t// Search for TaskScheduler bean...\n\t\t\treturn resolveSchedulerBean(this.beanFactory, TaskScheduler.class, false);\n\t\t}\n\t\tcatch (NoUniqueBeanDefinitionException ex) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Could not find unique TaskScheduler bean - attempting to resolve by name: \" +\n\t\t\t\t\t\tex.getMessage());\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn resolveSchedulerBean(this.beanFactory, TaskScheduler.class, true);\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex2) {\n\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\tlogger.info(\"More than one TaskScheduler bean exists within the context, and \" +\n\t\t\t\t\t\t\t\"none is named 'taskScheduler'. Mark one of them as primary or name it 'taskScheduler' \" +\n\t\t\t\t\t\t\t\"(possibly as an alias); or implement the SchedulingConfigurer interface and call \" +\n\t\t\t\t\t\t\t\"ScheduledTaskRegistrar#setScheduler explicitly within the configureTasks() callback: \" +\n\t\t\t\t\t\t\tex.getBeanNamesFound());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Could not find default TaskScheduler bean - attempting to find ScheduledExecutorService: \" +\n\t\t\t\t\t\tex.getMessage());\n\t\t\t}\n\t\t\t// Search for ScheduledExecutorService bean next...\n\t\t\ttry {\n\t\t\t\treturn new ConcurrentTaskScheduler(resolveSchedulerBean(this.beanFactory, ScheduledExecutorService.class, false));\n\t\t\t}\n\t\t\tcatch (NoUniqueBeanDefinitionException ex2) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Could not find unique ScheduledExecutorService bean - attempting to resolve by name: \" +\n\t\t\t\t\t\t\tex2.getMessage());\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\treturn new ConcurrentTaskScheduler(resolveSchedulerBean(this.beanFactory, ScheduledExecutorService.class, true));\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchBeanDefinitionException ex3) {\n\t\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\t\tlogger.info(\"More than one ScheduledExecutorService bean exists within the context, and \" +\n\t\t\t\t\t\t\t\t\"none is named 'taskScheduler'. Mark one of them as primary or name it 'taskScheduler' \" +\n\t\t\t\t\t\t\t\t\"(possibly as an alias); or implement the SchedulingConfigurer interface and call \" +\n\t\t\t\t\t\t\t\t\"ScheduledTaskRegistrar#setScheduler explicitly within the configureTasks() callback: \" +\n\t\t\t\t\t\t\t\tex2.getBeanNamesFound());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex2) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Could not find default ScheduledExecutorService bean - falling back to default: \" +\n\t\t\t\t\t\t\tex2.getMessage());\n\t\t\t\t}\n\t\t\t\tlogger.info(\"No TaskScheduler/ScheduledExecutorService bean found for scheduled processing\");\n\t\t\t}\n\t\t}\n\t\tScheduledExecutorService localExecutor = Executors.newSingleThreadScheduledExecutor();\n\t\tthis.localExecutor = localExecutor;\n\t\treturn new ConcurrentTaskScheduler(localExecutor);\n\t}\n\n\tprivate <T> T resolveSchedulerBean(BeanFactory beanFactory, Class<T> schedulerType, boolean byName) {\n\t\tif (byName) {\n\t\t\tT scheduler = beanFactory.getBean(DEFAULT_TASK_SCHEDULER_BEAN_NAME, schedulerType);\n\t\t\tif (this.beanName != null && this.beanFactory instanceof ConfigurableBeanFactory cbf) {\n\t\t\t\tcbf.registerDependentBean(DEFAULT_TASK_SCHEDULER_BEAN_NAME, this.beanName);\n\t\t\t}\n\t\t\treturn scheduler;\n\t\t}\n\t\telse if (beanFactory instanceof AutowireCapableBeanFactory acbf) {\n\t\t\tNamedBeanHolder<T> holder = acbf.resolveNamedBean(schedulerType);\n\t\t\tif (this.beanName != null && beanFactory instanceof ConfigurableBeanFactory cbf) {\n\t\t\t\tcbf.registerDependentBean(holder.getBeanName(), this.beanName);\n\t\t\t}\n\t\t\treturn holder.getBeanInstance();\n\t\t}\n\t\telse {\n\t\t\treturn beanFactory.getBean(schedulerType);\n\t\t}\n\t}\n\n\n\t/**\n\t * Destroy the local default executor, if any.\n\t */\n\t@Override\n\tpublic void destroy() {\n\t\tScheduledExecutorService localExecutor = this.localExecutor;\n\t\tif (localExecutor != null) {\n\t\t\tlocalExecutor.shutdownNow();\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.scheduling.config.TaskSchedulerRouter#destroy()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Destroy the local default executor, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "void",
    "signature": "public void destroy()",
    "source_code": "\tpublic void destroy() {\n\t\tScheduledExecutorService localExecutor = this.localExecutor;\n\t\tif (localExecutor != null) {\n\t\t\tlocalExecutor.shutdownNow();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.config.TaskSchedulerRouter#determineDefaultScheduler()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "TaskScheduler",
    "signature": "protected TaskScheduler determineDefaultScheduler()",
    "source_code": "\tprotected TaskScheduler determineDefaultScheduler() {\n\t\tAssert.state(this.beanFactory != null, \"BeanFactory must be set to find default scheduler\");\n\t\ttry {\n\t\t\t// Search for TaskScheduler bean...\n\t\t\treturn resolveSchedulerBean(this.beanFactory, TaskScheduler.class, false);\n\t\t}\n\t\tcatch (NoUniqueBeanDefinitionException ex) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Could not find unique TaskScheduler bean - attempting to resolve by name: \" +\n\t\t\t\t\t\tex.getMessage());\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn resolveSchedulerBean(this.beanFactory, TaskScheduler.class, true);\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex2) {\n\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\tlogger.info(\"More than one TaskScheduler bean exists within the context, and \" +\n\t\t\t\t\t\t\t\"none is named 'taskScheduler'. Mark one of them as primary or name it 'taskScheduler' \" +\n\t\t\t\t\t\t\t\"(possibly as an alias); or implement the SchedulingConfigurer interface and call \" +\n\t\t\t\t\t\t\t\"ScheduledTaskRegistrar#setScheduler explicitly within the configureTasks() callback: \" +\n\t\t\t\t\t\t\tex.getBeanNamesFound());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Could not find default TaskScheduler bean - attempting to find ScheduledExecutorService: \" +\n\t\t\t\t\t\tex.getMessage());\n\t\t\t}\n\t\t\t// Search for ScheduledExecutorService bean next...\n\t\t\ttry {\n\t\t\t\treturn new ConcurrentTaskScheduler(resolveSchedulerBean(this.beanFactory, ScheduledExecutorService.class, false));\n\t\t\t}\n\t\t\tcatch (NoUniqueBeanDefinitionException ex2) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Could not find unique ScheduledExecutorService bean - attempting to resolve by name: \" +\n\t\t\t\t\t\t\tex2.getMessage());\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\treturn new ConcurrentTaskScheduler(resolveSchedulerBean(this.beanFactory, ScheduledExecutorService.class, true));\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchBeanDefinitionException ex3) {\n\t\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\t\tlogger.info(\"More than one ScheduledExecutorService bean exists within the context, and \" +\n\t\t\t\t\t\t\t\t\"none is named 'taskScheduler'. Mark one of them as primary or name it 'taskScheduler' \" +\n\t\t\t\t\t\t\t\t\"(possibly as an alias); or implement the SchedulingConfigurer interface and call \" +\n\t\t\t\t\t\t\t\t\"ScheduledTaskRegistrar#setScheduler explicitly within the configureTasks() callback: \" +\n\t\t\t\t\t\t\t\tex2.getBeanNamesFound());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex2) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Could not find default ScheduledExecutorService bean - falling back to default: \" +\n\t\t\t\t\t\t\tex2.getMessage());\n\t\t\t\t}\n\t\t\t\tlogger.info(\"No TaskScheduler/ScheduledExecutorService bean found for scheduled processing\");\n\t\t\t}\n\t\t}\n\t\tScheduledExecutorService localExecutor = Executors.newSingleThreadScheduledExecutor();\n\t\tthis.localExecutor = localExecutor;\n\t\treturn new ConcurrentTaskScheduler(localExecutor);\n\t}"
  },
  "org.springframework.scheduling.config.TaskSchedulerRouter#determineQualifiedScheduler(qualifier)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "qualifier"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "TaskScheduler",
    "signature": "protected TaskScheduler determineQualifiedScheduler(String qualifier)",
    "source_code": "\tprotected TaskScheduler determineQualifiedScheduler(String qualifier) {\n\t\tAssert.state(this.beanFactory != null, \"BeanFactory must be set to find qualified scheduler\");\n\t\ttry {\n\t\t\treturn BeanFactoryAnnotationUtils.qualifiedBeanOfType(this.beanFactory, TaskScheduler.class, qualifier);\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException | BeanNotOfRequiredTypeException ex) {\n\t\t\treturn new ConcurrentTaskScheduler(BeanFactoryAnnotationUtils.qualifiedBeanOfType(\n\t\t\t\t\tthis.beanFactory, ScheduledExecutorService.class, qualifier));\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.config.TaskSchedulerRouter#determineQualifier(task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "String",
    "signature": "protected String determineQualifier(Runnable task)",
    "source_code": "\tprotected String determineQualifier(Runnable task) {\n\t\treturn (task instanceof SchedulingAwareRunnable sar ? sar.getQualifier() : null);\n\t}"
  },
  "org.springframework.scheduling.config.TaskSchedulerRouter#determineTargetScheduler(task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "TaskScheduler",
    "signature": "protected TaskScheduler determineTargetScheduler(Runnable task)",
    "source_code": "\tprotected TaskScheduler determineTargetScheduler(Runnable task) {\n\t\tString qualifier = determineQualifier(task);\n\t\tif (this.embeddedValueResolver != null && StringUtils.hasLength(qualifier)) {\n\t\t\tqualifier = this.embeddedValueResolver.resolveStringValue(qualifier);\n\t\t}\n\t\tif (StringUtils.hasLength(qualifier)) {\n\t\t\treturn determineQualifiedScheduler(qualifier);\n\t\t}\n\t\telse {\n\t\t\treturn this.defaultScheduler.get();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.config.TaskSchedulerRouter#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The bean factory for scheduler lookups.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "public void setBeanFactory(@Nullable BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(@Nullable BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t\tif (beanFactory instanceof ConfigurableBeanFactory configurableBeanFactory) {\n\t\t\tthis.embeddedValueResolver = new EmbeddedValueResolver(configurableBeanFactory);\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.config.TaskSchedulerRouter#setBeanName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The bean name for this router, or the bean name of the containing\n\t * bean if the router instance is internally held.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "void",
    "signature": "public void setBeanName(@Nullable String name)",
    "source_code": "\tpublic void setBeanName(@Nullable String name) {\n\t\tthis.beanName = name;\n\t}"
  },
  "org.springframework.scheduling.config.logger": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected static final Log logger = LogFactory.getLog(TaskSchedulerRouter.class);",
    "type": "Log"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#run()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 741
    },
    "return": "void",
    "signature": "public void run()",
    "source_code": "\t\t\t\tpublic void run() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tTimeUnit.SECONDS.sleep(startupDelay);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InterruptedException ex) {\n\t\t\t\t\t\tThread.currentThread().interrupt();\n\t\t\t\t\t\t// simply proceed\n\t\t\t\t\t}\n\t\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\t\tlogger.info(\"Starting Quartz Scheduler now, after delay of \" + startupDelay + \" seconds\");\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tscheduler.start();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SchedulerException ex) {\n\t\t\t\t\t\tthrow new SchedulingException(\"Could not start Quartz Scheduler after delay\", ex);\n\t\t\t\t\t}\n\t\t\t\t}"
  },
  "org.springframework.scheduling.support.CronSequenceGenerator": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Date sequence generator for a\n * <a href=\"https://www.manpagez.com/man/5/crontab/\">Crontab pattern</a>,\n * allowing clients to specify a pattern that the sequence matches.\n *\n * <p>The pattern is a list of six single space-separated fields: representing\n * second, minute, hour, day, month, weekday. Month and weekday names can be\n * given as the first three letters of the English names.\n *\n * <p>Example patterns:\n * <ul>\n * <li>\"0 0 * * * *\" = the top of every hour of every day.</li>\n * <li>\"*&#47;10 * * * * *\" = every ten seconds.</li>\n * <li>\"0 0 8-10 * * *\" = 8, 9 and 10 o'clock of every day.</li>\n * <li>\"0 0 6,19 * * *\" = 6:00 AM and 7:00 PM every day.</li>\n * <li>\"0 0/30 8-10 * * *\" = 8:00, 8:30, 9:00, 9:30, 10:00 and 10:30 every day.</li>\n * <li>\"0 0 9-17 * * MON-FRI\" = on the hour nine-to-five weekdays</li>\n * <li>\"0 0 0 25 12 ?\" = every Christmas Day at midnight</li>\n * </ul>\n *\n * @author Dave Syer\n * @author Juergen Hoeller\n * @author Ruslan Sibgatullin\n * @since 3.0\n * @see CronTrigger\n * @deprecated as of 5.3, in favor of {@link CronExpression}\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "signature": "public class CronSequenceGenerator",
    "source_code": "public class CronSequenceGenerator {\n\n\tprivate final String expression;\n\n\t@Nullable\n\tprivate final TimeZone timeZone;\n\n\tprivate final BitSet months = new BitSet(12);\n\n\tprivate final BitSet daysOfMonth = new BitSet(31);\n\n\tprivate final BitSet daysOfWeek = new BitSet(7);\n\n\tprivate final BitSet hours = new BitSet(24);\n\n\tprivate final BitSet minutes = new BitSet(60);\n\n\tprivate final BitSet seconds = new BitSet(60);\n\n\n\t/**\n\t * Construct a {@code CronSequenceGenerator} from the pattern provided,\n\t * using the default {@link TimeZone}.\n\t * @param expression a space-separated list of time fields\n\t * @throws IllegalArgumentException if the pattern cannot be parsed\n\t * @see java.util.TimeZone#getDefault()\n\t * @deprecated as of 5.3, in favor of {@link CronExpression#parse(String)}\n\t */\n\t@Deprecated(since = \"5.3\", forRemoval = true)\n\tpublic CronSequenceGenerator(String expression) {\n\t\tthis(expression, TimeZone.getDefault());\n\t}\n\n\t/**\n\t * Construct a {@code CronSequenceGenerator} from the pattern provided,\n\t * using the specified {@link TimeZone}.\n\t * @param expression a space-separated list of time fields\n\t * @param timeZone the TimeZone to use for generated trigger times\n\t * @throws IllegalArgumentException if the pattern cannot be parsed\n\t * @deprecated as of 5.3, in favor of {@link CronExpression#parse(String)}\n\t */\n\t@Deprecated\n\tpublic CronSequenceGenerator(String expression, TimeZone timeZone) {\n\t\tthis.expression = expression;\n\t\tthis.timeZone = timeZone;\n\t\tparse(expression);\n\t}\n\n\tprivate CronSequenceGenerator(String expression, String[] fields) {\n\t\tthis.expression = expression;\n\t\tthis.timeZone = null;\n\t\tdoParse(fields);\n\t}\n\n\n\t/**\n\t * Return the cron pattern that this sequence generator has been built for.\n\t */\n\tString getExpression() {\n\t\treturn this.expression;\n\t}\n\n\n\t/**\n\t * Get the next {@link Date} in the sequence matching the Cron pattern and\n\t * after the value provided. The return value will have a whole number of\n\t * seconds, and will be after the input value.\n\t * @param date a seed value\n\t * @return the next value matching the pattern\n\t */\n\tpublic Date next(Date date) {\n\t\t/*\n\t\tThe plan:\n\n\t\t1 Start with whole second (rounding up if necessary)\n\n\t\t2 If seconds match move on, otherwise find the next match:\n\t\t2.1 If next match is in the next minute then roll forwards\n\n\t\t3 If minute matches move on, otherwise find the next match\n\t\t3.1 If next match is in the next hour then roll forwards\n\t\t3.2 Reset the seconds and go to 2\n\n\t\t4 If hour matches move on, otherwise find the next match\n\t\t4.1 If next match is in the next day then roll forwards,\n\t\t4.2 Reset the minutes and seconds and go to 2\n\t\t*/\n\n\t\tCalendar calendar = new GregorianCalendar();\n\t\tcalendar.setTimeZone(this.timeZone);\n\t\tcalendar.setTime(date);\n\n\t\t// First, just reset the milliseconds and try to calculate from there...\n\t\tcalendar.set(Calendar.MILLISECOND, 0);\n\t\tlong originalTimestamp = calendar.getTimeInMillis();\n\t\tdoNext(calendar, calendar.get(Calendar.YEAR));\n\n\t\tif (calendar.getTimeInMillis() == originalTimestamp) {\n\t\t\t// We arrived at the original timestamp - round up to the next whole second and try again...\n\t\t\tcalendar.add(Calendar.SECOND, 1);\n\t\t\tdoNext(calendar, calendar.get(Calendar.YEAR));\n\t\t}\n\n\t\treturn calendar.getTime();\n\t}\n\n\tprivate void doNext(Calendar calendar, int dot) {\n\t\tList<Integer> resets = new ArrayList<>();\n\n\t\tint second = calendar.get(Calendar.SECOND);\n\t\tList<Integer> emptyList = Collections.emptyList();\n\t\tint updateSecond = findNext(this.seconds, second, calendar, Calendar.SECOND, Calendar.MINUTE, emptyList);\n\t\tif (second == updateSecond) {\n\t\t\tresets.add(Calendar.SECOND);\n\t\t}\n\n\t\tint minute = calendar.get(Calendar.MINUTE);\n\t\tint updateMinute = findNext(this.minutes, minute, calendar, Calendar.MINUTE, Calendar.HOUR_OF_DAY, resets);\n\t\tif (minute == updateMinute) {\n\t\t\tresets.add(Calendar.MINUTE);\n\t\t}\n\t\telse {\n\t\t\tdoNext(calendar, dot);\n\t\t}\n\n\t\tint hour = calendar.get(Calendar.HOUR_OF_DAY);\n\t\tint updateHour = findNext(this.hours, hour, calendar, Calendar.HOUR_OF_DAY, Calendar.DAY_OF_WEEK, resets);\n\t\tif (hour == updateHour) {\n\t\t\tresets.add(Calendar.HOUR_OF_DAY);\n\t\t}\n\t\telse {\n\t\t\tdoNext(calendar, dot);\n\t\t}\n\n\t\tint dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);\n\t\tint dayOfMonth = calendar.get(Calendar.DAY_OF_MONTH);\n\t\tint updateDayOfMonth = findNextDay(calendar, this.daysOfMonth, dayOfMonth, this.daysOfWeek, dayOfWeek, resets);\n\t\tif (dayOfMonth == updateDayOfMonth) {\n\t\t\tresets.add(Calendar.DAY_OF_MONTH);\n\t\t}\n\t\telse {\n\t\t\tdoNext(calendar, dot);\n\t\t}\n\n\t\tint month = calendar.get(Calendar.MONTH);\n\t\tint updateMonth = findNext(this.months, month, calendar, Calendar.MONTH, Calendar.YEAR, resets);\n\t\tif (month != updateMonth) {\n\t\t\tif (calendar.get(Calendar.YEAR) - dot > 4) {\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid cron expression \\\"\" + this.expression +\n\t\t\t\t\t\t\"\\\" led to runaway search for next trigger\");\n\t\t\t}\n\t\t\tdoNext(calendar, dot);\n\t\t}\n\n\t}\n\n\tprivate int findNextDay(Calendar calendar, BitSet daysOfMonth, int dayOfMonth, BitSet daysOfWeek, int dayOfWeek,\n\t\t\tList<Integer> resets) {\n\n\t\tint count = 0;\n\t\tint max = 366;\n\t\t// the DAY_OF_WEEK values in java.util.Calendar start with 1 (Sunday),\n\t\t// but in the cron pattern, they start with 0, so we subtract 1 here\n\t\twhile ((!daysOfMonth.get(dayOfMonth) || !daysOfWeek.get(dayOfWeek - 1)) && count++ < max) {\n\t\t\tcalendar.add(Calendar.DAY_OF_MONTH, 1);\n\t\t\tdayOfMonth = calendar.get(Calendar.DAY_OF_MONTH);\n\t\t\tdayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);\n\t\t\treset(calendar, resets);\n\t\t}\n\t\tif (count >= max) {\n\t\t\tthrow new IllegalArgumentException(\"Overflow in day for expression \\\"\" + this.expression + \"\\\"\");\n\t\t}\n\t\treturn dayOfMonth;\n\t}\n\n\t/**\n\t * Search the bits provided for the next set bit after the value provided,\n\t * and reset the calendar.\n\t * @param bits a {@link BitSet} representing the allowed values of the field\n\t * @param value the current value of the field\n\t * @param calendar the calendar to increment as we move through the bits\n\t * @param field the field to increment in the calendar (@see\n\t * {@link Calendar} for the static constants defining valid fields)\n\t * @param lowerOrders the Calendar field ids that should be reset (i.e. the\n\t * ones of lower significance than the field of interest)\n\t * @return the value of the calendar field that is next in the sequence\n\t */\n\tprivate int findNext(BitSet bits, int value, Calendar calendar, int field, int nextField, List<Integer> lowerOrders) {\n\t\tint nextValue = bits.nextSetBit(value);\n\t\t// roll over if needed\n\t\tif (nextValue == -1) {\n\t\t\tcalendar.add(nextField, 1);\n\t\t\treset(calendar, Collections.singletonList(field));\n\t\t\tnextValue = bits.nextSetBit(0);\n\t\t}\n\t\tif (nextValue != value) {\n\t\t\tcalendar.set(field, nextValue);\n\t\t\treset(calendar, lowerOrders);\n\t\t}\n\t\treturn nextValue;\n\t}\n\n\t/**\n\t * Reset the calendar setting all the fields provided to zero.\n\t */\n\tprivate void reset(Calendar calendar, List<Integer> fields) {\n\t\tfor (int field : fields) {\n\t\t\tcalendar.set(field, field == Calendar.DAY_OF_MONTH ? 1 : 0);\n\t\t}\n\t}\n\n\n\t// Parsing logic invoked by the constructor\n\n\t/**\n\t * Parse the given pattern expression.\n\t */\n\tprivate void parse(String expression) throws IllegalArgumentException {\n\t\tString[] fields = StringUtils.tokenizeToStringArray(expression, \" \");\n\t\tif (!areValidCronFields(fields)) {\n\t\t\tthrow new IllegalArgumentException(String.format(\n\t\t\t\t\t\"Cron expression must consist of 6 fields (found %d in \\\"%s\\\")\", fields.length, expression));\n\t\t}\n\t\tdoParse(fields);\n\t}\n\n\tprivate void doParse(String[] fields) {\n\t\tsetNumberHits(this.seconds, fields[0], 0, 60);\n\t\tsetNumberHits(this.minutes, fields[1], 0, 60);\n\t\tsetNumberHits(this.hours, fields[2], 0, 24);\n\t\tsetDaysOfMonth(this.daysOfMonth, fields[3]);\n\t\tsetMonths(this.months, fields[4]);\n\t\tsetDays(this.daysOfWeek, replaceOrdinals(fields[5], \"SUN,MON,TUE,WED,THU,FRI,SAT\"), 8);\n\n\t\tif (this.daysOfWeek.get(7)) {\n\t\t\t// Sunday can be represented as 0 or 7\n\t\t\tthis.daysOfWeek.set(0);\n\t\t\tthis.daysOfWeek.clear(7);\n\t\t}\n\t}\n\n\t/**\n\t * Replace the values in the comma-separated list (case-insensitive)\n\t * with their index in the list.\n\t * @return a new String with the values from the list replaced\n\t */\n\tprivate String replaceOrdinals(String value, String commaSeparatedList) {\n\t\tString[] list = StringUtils.commaDelimitedListToStringArray(commaSeparatedList);\n\t\tfor (int i = 0; i < list.length; i++) {\n\t\t\tString item = list[i].toUpperCase();\n\t\t\tvalue = StringUtils.replace(value.toUpperCase(), item, \"\" + i);\n\t\t}\n\t\treturn value;\n\t}\n\n\tprivate void setDaysOfMonth(BitSet bits, String field) {\n\t\tint max = 31;\n\t\t// Days of month start with 1 (in Cron and Calendar) so add one\n\t\tsetDays(bits, field, max + 1);\n\t\t// ... and remove it from the front\n\t\tbits.clear(0);\n\t}\n\n\tprivate void setDays(BitSet bits, String field, int max) {\n\t\tif (field.contains(\"?\")) {\n\t\t\tfield = \"*\";\n\t\t}\n\t\tsetNumberHits(bits, field, 0, max);\n\t}\n\n\tprivate void setMonths(BitSet bits, String value) {\n\t\tint max = 12;\n\t\tvalue = replaceOrdinals(value, \"FOO,JAN,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC\");\n\t\tBitSet months = new BitSet(13);\n\t\t// Months start with 1 in Cron and 0 in Calendar, so push the values first into a longer bit set\n\t\tsetNumberHits(months, value, 1, max + 1);\n\t\t// ... and then rotate it to the front of the months\n\t\tfor (int i = 1; i <= max; i++) {\n\t\t\tif (months.get(i)) {\n\t\t\t\tbits.set(i - 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void setNumberHits(BitSet bits, String value, int min, int max) {\n\t\tString[] fields = StringUtils.delimitedListToStringArray(value, \",\");\n\t\tfor (String field : fields) {\n\t\t\tif (!field.contains(\"/\")) {\n\t\t\t\t// Not an incrementer so it must be a range (possibly empty)\n\t\t\t\tint[] range = getRange(field, min, max);\n\t\t\t\tbits.set(range[0], range[1] + 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString[] split = StringUtils.delimitedListToStringArray(field, \"/\");\n\t\t\t\tif (split.length > 2) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Incrementer has more than two fields: '\" +\n\t\t\t\t\t\t\tfield + \"' in expression \\\"\" + this.expression + \"\\\"\");\n\t\t\t\t}\n\t\t\t\tint[] range = getRange(split[0], min, max);\n\t\t\t\tif (!split[0].contains(\"-\")) {\n\t\t\t\t\trange[1] = max - 1;\n\t\t\t\t}\n\t\t\t\tint delta = Integer.parseInt(split[1]);\n\t\t\t\tif (delta <= 0) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Incrementer delta must be 1 or higher: '\" +\n\t\t\t\t\t\t\tfield + \"' in expression \\\"\" + this.expression + \"\\\"\");\n\t\t\t\t}\n\t\t\t\tfor (int i = range[0]; i <= range[1]; i += delta) {\n\t\t\t\t\tbits.set(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int[] getRange(String field, int min, int max) {\n\t\tint[] result = new int[2];\n\t\tif (field.contains(\"*\")) {\n\t\t\tresult[0] = min;\n\t\t\tresult[1] = max - 1;\n\t\t\treturn result;\n\t\t}\n\t\tif (!field.contains(\"-\")) {\n\t\t\tresult[0] = result[1] = Integer.parseInt(field);\n\t\t}\n\t\telse {\n\t\t\tString[] split = StringUtils.delimitedListToStringArray(field, \"-\");\n\t\t\tif (split.length > 2) {\n\t\t\t\tthrow new IllegalArgumentException(\"Range has more than two fields: '\" +\n\t\t\t\t\t\tfield + \"' in expression \\\"\" + this.expression + \"\\\"\");\n\t\t\t}\n\t\t\tresult[0] = Integer.parseInt(split[0]);\n\t\t\tresult[1] = Integer.parseInt(split[1]);\n\t\t}\n\t\tif (result[0] >= max || result[1] >= max) {\n\t\t\tthrow new IllegalArgumentException(\"Range exceeds maximum (\" + max + \"): '\" +\n\t\t\t\t\tfield + \"' in expression \\\"\" + this.expression + \"\\\"\");\n\t\t}\n\t\tif (result[0] < min || result[1] < min) {\n\t\t\tthrow new IllegalArgumentException(\"Range less than minimum (\" + min + \"): '\" +\n\t\t\t\t\tfield + \"' in expression \\\"\" + this.expression + \"\\\"\");\n\t\t}\n\t\tif (result[0] > result[1]) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid inverted range: '\" + field +\n\t\t\t\t\t\"' in expression \\\"\" + this.expression + \"\\\"\");\n\t\t}\n\t\treturn result;\n\t}\n\n\n\t/**\n\t * Determine whether the specified expression represents a valid cron pattern.\n\t * @param expression the expression to evaluate\n\t * @return {@code true} if the given expression is a valid cron expression\n\t * @since 4.3\n\t */\n\tpublic static boolean isValidExpression(@Nullable String expression) {\n\t\tif (expression == null) {\n\t\t\treturn false;\n\t\t}\n\t\tString[] fields = StringUtils.tokenizeToStringArray(expression, \" \");\n\t\tif (!areValidCronFields(fields)) {\n\t\t\treturn false;\n\t\t}\n\t\ttry {\n\t\t\tnew CronSequenceGenerator(expression, fields);\n\t\t\treturn true;\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate static boolean areValidCronFields(@Nullable String[] fields) {\n\t\treturn (fields != null && fields.length == 6);\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof CronSequenceGenerator that &&\n\t\t\t\tthis.months.equals(that.months) && this.daysOfMonth.equals(that.daysOfMonth) &&\n\t\t\t\tthis.daysOfWeek.equals(that.daysOfWeek) && this.hours.equals(that.hours) &&\n\t\t\t\tthis.minutes.equals(that.minutes) && this.seconds.equals(that.seconds)));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn (17 * this.months.hashCode() + 29 * this.daysOfMonth.hashCode() + 37 * this.daysOfWeek.hashCode() +\n\t\t\t\t41 * this.hours.hashCode() + 53 * this.minutes.hashCode() + 61 * this.seconds.hashCode());\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \": \" + this.expression;\n\t}\n\n}"
  },
  "org.springframework.scheduling.support.CronSequenceGenerator#equals(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 437
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof CronSequenceGenerator that &&\n\t\t\t\tthis.months.equals(that.months) && this.daysOfMonth.equals(that.daysOfMonth) &&\n\t\t\t\tthis.daysOfWeek.equals(that.daysOfWeek) && this.hours.equals(that.hours) &&\n\t\t\t\tthis.minutes.equals(that.minutes) && this.seconds.equals(that.seconds)));\n\t}"
  },
  "org.springframework.scheduling.support.CronSequenceGenerator#hashCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 445
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn (17 * this.months.hashCode() + 29 * this.daysOfMonth.hashCode() + 37 * this.daysOfWeek.hashCode() +\n\t\t\t\t41 * this.hours.hashCode() + 53 * this.minutes.hashCode() + 61 * this.seconds.hashCode());\n\t}"
  },
  "org.springframework.scheduling.support.CronSequenceGenerator#isValidExpression(expression)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the specified expression represents a valid cron pattern.\n\t * @param expression the expression to evaluate\n\t * @return {@code true} if the given expression is a valid cron expression\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expression"
    ],
    "position": {
      "column": 1,
      "line": 414
    },
    "return": "boolean",
    "signature": "public boolean isValidExpression(@Nullable String expression)",
    "source_code": "\tpublic static boolean isValidExpression(@Nullable String expression) {\n\t\tif (expression == null) {\n\t\t\treturn false;\n\t\t}\n\t\tString[] fields = StringUtils.tokenizeToStringArray(expression, \" \");\n\t\tif (!areValidCronFields(fields)) {\n\t\t\treturn false;\n\t\t}\n\t\ttry {\n\t\t\tnew CronSequenceGenerator(expression, fields);\n\t\t\treturn true;\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\treturn false;\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.support.CronSequenceGenerator#next(date)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the next {@link Date} in the sequence matching the Cron pattern and\n\t * after the value provided. The return value will have a whole number of\n\t * seconds, and will be after the input value.\n\t * @param date a seed value\n\t * @return the next value matching the pattern\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "date"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "Date",
    "signature": "public Date next(Date date)",
    "source_code": "\tpublic Date next(Date date) {\n\t\t/*\n\t\tThe plan:\n\n\t\t1 Start with whole second (rounding up if necessary)\n\n\t\t2 If seconds match move on, otherwise find the next match:\n\t\t2.1 If next match is in the next minute then roll forwards\n\n\t\t3 If minute matches move on, otherwise find the next match\n\t\t3.1 If next match is in the next hour then roll forwards\n\t\t3.2 Reset the seconds and go to 2\n\n\t\t4 If hour matches move on, otherwise find the next match\n\t\t4.1 If next match is in the next day then roll forwards,\n\t\t4.2 Reset the minutes and seconds and go to 2\n\t\t*/\n\n\t\tCalendar calendar = new GregorianCalendar();\n\t\tcalendar.setTimeZone(this.timeZone);\n\t\tcalendar.setTime(date);\n\n\t\t// First, just reset the milliseconds and try to calculate from there...\n\t\tcalendar.set(Calendar.MILLISECOND, 0);\n\t\tlong originalTimestamp = calendar.getTimeInMillis();\n\t\tdoNext(calendar, calendar.get(Calendar.YEAR));\n\n\t\tif (calendar.getTimeInMillis() == originalTimestamp) {\n\t\t\t// We arrived at the original timestamp - round up to the next whole second and try again...\n\t\t\tcalendar.add(Calendar.SECOND, 1);\n\t\t\tdoNext(calendar, calendar.get(Calendar.YEAR));\n\t\t}\n\n\t\treturn calendar.getTime();\n\t}"
  },
  "org.springframework.scheduling.support.CronSequenceGenerator#toString()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 451
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \": \" + this.expression;\n\t}"
  },
  "org.springframework.scheduling.support.CronTrigger#determineLatestTimestamp(triggerContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "triggerContext"
    ],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "Instant",
    "signature": "protected Instant determineLatestTimestamp(TriggerContext triggerContext)",
    "source_code": "\t\t\tprotected Instant determineLatestTimestamp(TriggerContext triggerContext) {\n\t\t\t\tInstant scheduled = triggerContext.lastScheduledExecution();\n\t\t\t\treturn (scheduled != null ? scheduled : super.determineLatestTimestamp(triggerContext));\n\t\t\t}"
  },
  "org.springframework.scheduling.support.CronTrigger#forFixedExecution(expression)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link CronTrigger} for fixed execution, to be rescheduled\n\t * after every task based on the last scheduled time.\n\t * <p>This variant makes up for missed trigger firings if the associated task\n\t * has taken too long, scheduling a task for every original trigger firing.\n\t * Such follow-up tasks may execute late but will never be skipped.\n\t * <p>Immediate versus late execution in case of long-running tasks may\n\t * be scheduler-dependent but the guarantee to never skip a task is portable.\n\t * @param expression a space-separated list of time fields, following cron\n\t * expression conventions\n\t * @since 6.1.3\n\t * @see #resumeFixedExecution\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expression"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "CronTrigger",
    "signature": "public CronTrigger forFixedExecution(String expression)",
    "source_code": "\tpublic static CronTrigger forFixedExecution(String expression) {\n\t\treturn new CronTrigger(expression) {\n\t\t\t@Override\n\t\t\tprotected Instant determineLatestTimestamp(TriggerContext triggerContext) {\n\t\t\t\tInstant scheduled = triggerContext.lastScheduledExecution();\n\t\t\t\treturn (scheduled != null ? scheduled : super.determineInitialTimestamp(triggerContext));\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.scheduling.support.CronTrigger#forLenientExecution(expression)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link CronTrigger} for lenient execution, to be rescheduled\n\t * after every task based on the completion time.\n\t * <p>This variant does not make up for missed trigger firings if the\n\t * associated task has taken too long. As a consequence, original trigger\n\t * firings may be skipped if the previous task is still running.\n\t * <p>This is equivalent to the regular {@link CronTrigger} constructor.\n\t * Note that lenient execution is scheduler-dependent: it may skip trigger\n\t * firings with long-running tasks on a thread pool while executing at\n\t * {@link #forFixedExecution}-like precision with new threads per task.\n\t * @param expression a space-separated list of time fields, following cron\n\t * expression conventions\n\t * @since 6.1.3\n\t * @see #resumeLenientExecution\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expression"
    ],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "CronTrigger",
    "signature": "public CronTrigger forLenientExecution(String expression)",
    "source_code": "\tpublic static CronTrigger forLenientExecution(String expression) {\n\t\treturn new CronTrigger(expression);\n\t}"
  },
  "org.springframework.scheduling.support.CronTrigger#resumeFixedExecution(expression,resumptionTimestamp)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link CronTrigger} for fixed execution, to be rescheduled\n\t * after every task based on the last scheduled time.\n\t * <p>This variant makes up for missed trigger firings if the associated task\n\t * has taken too long, scheduling a task for every original trigger firing.\n\t * Such follow-up tasks may execute late but will never be skipped.\n\t * @param expression a space-separated list of time fields, following cron\n\t * expression conventions\n\t * @param resumptionTimestamp the timestamp to resume from (the last-known\n\t * scheduled timestamp), with every trigger in-between immediately firing\n\t * to make up for every execution that would have happened in the meantime\n\t * @since 6.1.3\n\t * @see #forFixedExecution\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expression",
      "resumptionTimestamp"
    ],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "CronTrigger",
    "signature": "public CronTrigger resumeFixedExecution(String expression, Instant resumptionTimestamp)",
    "source_code": "\tpublic static CronTrigger resumeFixedExecution(String expression, Instant resumptionTimestamp) {\n\t\treturn new CronTrigger(expression) {\n\t\t\t@Override\n\t\t\tprotected Instant determineLatestTimestamp(TriggerContext triggerContext) {\n\t\t\t\tInstant scheduled = triggerContext.lastScheduledExecution();\n\t\t\t\treturn (scheduled != null ? scheduled : super.determineLatestTimestamp(triggerContext));\n\t\t\t}\n\t\t\t@Override\n\t\t\tInstant determineInitialTimestamp(TriggerContext triggerContext) {\n\t\t\t\treturn resumptionTimestamp;\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.scheduling.support.CronTrigger#resumeLenientExecution(expression,resumptionTimestamp)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link CronTrigger} for lenient execution, to be rescheduled\n\t * after every task based on the completion time.\n\t * <p>This variant does not make up for missed trigger firings if the\n\t * associated task has taken too long. As a consequence, original trigger\n\t * firings may be skipped if the previous task is still running.\n\t * @param expression a space-separated list of time fields, following cron\n\t * expression conventions\n\t * @param resumptionTimestamp the timestamp to resume from (the last-known\n\t * completion timestamp), with the new trigger calculated from there and\n\t * possibly immediately firing (but only once, every subsequent calculation\n\t * will start from the completion time of that first resumed trigger)\n\t * @since 6.1.3\n\t * @see #forLenientExecution\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expression",
      "resumptionTimestamp"
    ],
    "position": {
      "column": 1,
      "line": 197
    },
    "return": "CronTrigger",
    "signature": "public CronTrigger resumeLenientExecution(String expression, Instant resumptionTimestamp)",
    "source_code": "\tpublic static CronTrigger resumeLenientExecution(String expression, Instant resumptionTimestamp) {\n\t\treturn new CronTrigger(expression) {\n\t\t\t@Override\n\t\t\tInstant determineInitialTimestamp(TriggerContext triggerContext) {\n\t\t\t\treturn resumptionTimestamp;\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code MergedContextConfiguration} encapsulates the <em>merged</em> context\n * configuration declared on a test class and all of its superclasses and\n * enclosing classes via {@link ContextConfiguration @ContextConfiguration},\n * {@link ActiveProfiles @ActiveProfiles}, and\n * {@link TestPropertySource @TestPropertySource}.\n *\n * <p>Merged context resource locations, annotated classes, active profiles,\n * property resource locations, and in-lined properties represent all declared\n * values in the test class hierarchy and enclosing class hierarchy taking into\n * consideration the semantics of the {@link ContextConfiguration#inheritLocations},\n * {@link ActiveProfiles#inheritProfiles},\n * {@link TestPropertySource#inheritLocations}, and\n * {@link TestPropertySource#inheritProperties} flags.\n *\n * <p>A {@link SmartContextLoader} uses {@code MergedContextConfiguration}\n * to load an {@link org.springframework.context.ApplicationContext ApplicationContext}.\n *\n * <p>{@code MergedContextConfiguration} is also used by the\n * {@link org.springframework.test.context.cache.ContextCache ContextCache}\n * as the key for caching an\n * {@link org.springframework.context.ApplicationContext ApplicationContext}\n * that was loaded using properties of this {@code MergedContextConfiguration}.\n *\n * @author Sam Brannen\n * @author Phillip Webb\n * @since 3.1\n * @see ContextConfiguration\n * @see ContextHierarchy\n * @see ActiveProfiles\n * @see TestPropertySource\n * @see ContextConfigurationAttributes\n * @see SmartContextLoader#loadContext(MergedContextConfiguration)\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "signature": "public class MergedContextConfiguration",
    "source_code": "public class MergedContextConfiguration implements Serializable {\n\n\tprivate static final long serialVersionUID = -3290560718464957422L;\n\n\tprivate static final String[] EMPTY_STRING_ARRAY = new String[0];\n\n\tprivate static final Class<?>[] EMPTY_CLASS_ARRAY = new Class<?>[0];\n\n\tprivate static final Set<Class<? extends ApplicationContextInitializer<?>>> EMPTY_INITIALIZER_CLASSES =\n\t\t\tCollections.emptySet();\n\n\tprivate static final Set<ContextCustomizer> EMPTY_CONTEXT_CUSTOMIZERS = Collections.emptySet();\n\n\n\tprivate final Class<?> testClass;\n\n\tprivate final String[] locations;\n\n\tprivate final Class<?>[] classes;\n\n\tprivate final Set<Class<? extends ApplicationContextInitializer<?>>> contextInitializerClasses;\n\n\tprivate final String[] activeProfiles;\n\n\tprivate final List<PropertySourceDescriptor> propertySourceDescriptors;\n\n\tprivate final String[] propertySourceLocations;\n\n\tprivate final String[] propertySourceProperties;\n\n\tprivate final Set<ContextCustomizer> contextCustomizers;\n\n\tprivate final ContextLoader contextLoader;\n\n\t@Nullable\n\tprivate final CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate;\n\n\t@Nullable\n\tprivate final MergedContextConfiguration parent;\n\n\n\t/**\n\t * Create a new {@code MergedContextConfiguration} instance for the\n\t * supplied parameters.\n\t * @param testClass the test class for which the configuration was merged\n\t * @param locations the merged context resource locations\n\t * @param classes the merged annotated classes\n\t * @param activeProfiles the merged active bean definition profiles\n\t * @param contextLoader the resolved {@code ContextLoader}\n\t */\n\tpublic MergedContextConfiguration(Class<?> testClass, @Nullable String[] locations, @Nullable Class<?>[] classes,\n\t\t\t@Nullable String[] activeProfiles, ContextLoader contextLoader) {\n\n\t\tthis(testClass, locations, classes, null, activeProfiles, contextLoader);\n\t}\n\n\t/**\n\t * Create a new {@code MergedContextConfiguration} instance for the\n\t * supplied parameters.\n\t * @param testClass the test class for which the configuration was merged\n\t * @param locations the merged context resource locations\n\t * @param classes the merged annotated classes\n\t * @param contextInitializerClasses the merged context initializer classes\n\t * @param activeProfiles the merged active bean definition profiles\n\t * @param contextLoader the resolved {@code ContextLoader}\n\t */\n\tpublic MergedContextConfiguration(Class<?> testClass, @Nullable String[] locations, @Nullable Class<?>[] classes,\n\t\t\t@Nullable Set<Class<? extends ApplicationContextInitializer<?>>> contextInitializerClasses,\n\t\t\t@Nullable String[] activeProfiles, ContextLoader contextLoader) {\n\n\t\tthis(testClass, locations, classes, contextInitializerClasses, activeProfiles, contextLoader, null, null);\n\t}\n\n\t/**\n\t * Create a new {@code MergedContextConfiguration} instance for the\n\t * supplied parameters.\n\t * @param testClass the test class for which the configuration was merged\n\t * @param locations the merged context resource locations\n\t * @param classes the merged annotated classes\n\t * @param contextInitializerClasses the merged context initializer classes\n\t * @param activeProfiles the merged active bean definition profiles\n\t * @param contextLoader the resolved {@code ContextLoader}\n\t * @param cacheAwareContextLoaderDelegate a cache-aware context loader\n\t * delegate with which to retrieve the parent {@code ApplicationContext}\n\t * @param parent the parent configuration or {@code null} if there is no parent\n\t * @since 3.2.2\n\t */\n\tpublic MergedContextConfiguration(Class<?> testClass, @Nullable String[] locations, @Nullable Class<?>[] classes,\n\t\t\t@Nullable Set<Class<? extends ApplicationContextInitializer<?>>> contextInitializerClasses,\n\t\t\t@Nullable String[] activeProfiles, ContextLoader contextLoader,\n\t\t\t@Nullable CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate,\n\t\t\t@Nullable MergedContextConfiguration parent) {\n\n\t\tthis(testClass, locations, classes, contextInitializerClasses, activeProfiles, null, null,\n\t\t\t\tcontextLoader, cacheAwareContextLoaderDelegate, parent);\n\t}\n\n\t/**\n\t * Create a new {@code MergedContextConfiguration} instance by copying\n\t * all fields from the supplied {@code MergedContextConfiguration}.\n\t * @since 4.1\n\t */\n\tpublic MergedContextConfiguration(MergedContextConfiguration mergedConfig) {\n\t\tthis(mergedConfig.testClass, mergedConfig.locations, mergedConfig.classes,\n\t\t\t\tmergedConfig.contextInitializerClasses, mergedConfig.activeProfiles,\n\t\t\t\tmergedConfig.propertySourceDescriptors, mergedConfig.propertySourceProperties,\n\t\t\t\tmergedConfig.contextCustomizers, mergedConfig.contextLoader,\n\t\t\t\tmergedConfig.cacheAwareContextLoaderDelegate, mergedConfig.parent);\n\t}\n\n\t/**\n\t * Create a new {@code MergedContextConfiguration} instance for the\n\t * supplied parameters.\n\t * <p>If a {@code null} value is supplied for {@code locations},\n\t * {@code classes}, {@code activeProfiles}, {@code propertySourceLocations},\n\t * or {@code propertySourceProperties} an empty array will be stored instead.\n\t * If a {@code null} value is supplied for the\n\t * {@code contextInitializerClasses} an empty set will be stored instead.\n\t * Furthermore, active profiles will be sorted, and duplicate profiles\n\t * will be removed.\n\t * @param testClass the test class for which the configuration was merged\n\t * @param locations the merged context resource locations\n\t * @param classes the merged annotated classes\n\t * @param contextInitializerClasses the merged context initializer classes\n\t * @param activeProfiles the merged active bean definition profiles\n\t * @param propertySourceLocations the merged {@code PropertySource} locations\n\t * @param propertySourceProperties the merged {@code PropertySource} properties\n\t * @param contextLoader the resolved {@code ContextLoader}\n\t * @param cacheAwareContextLoaderDelegate a cache-aware context loader\n\t * delegate with which to retrieve the parent {@code ApplicationContext}\n\t * @param parent the parent configuration or {@code null} if there is no parent\n\t * @since 4.1\n\t * @deprecated since 6.1 in favor of\n\t * {@link #MergedContextConfiguration(Class, String[], Class[], Set, String[], List, String[], Set, ContextLoader, CacheAwareContextLoaderDelegate, MergedContextConfiguration)}\n\t */\n\t@Deprecated(since = \"6.1\")\n\tpublic MergedContextConfiguration(Class<?> testClass, @Nullable String[] locations, @Nullable Class<?>[] classes,\n\t\t\t@Nullable Set<Class<? extends ApplicationContextInitializer<?>>> contextInitializerClasses,\n\t\t\t@Nullable String[] activeProfiles, @Nullable String[] propertySourceLocations,\n\t\t\t@Nullable String[] propertySourceProperties, ContextLoader contextLoader,\n\t\t\t@Nullable CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate,\n\t\t\t@Nullable MergedContextConfiguration parent) {\n\n\t\tthis(testClass, locations, classes, contextInitializerClasses, activeProfiles,\n\t\t\t\tpropertySourceLocations, propertySourceProperties,\n\t\t\t\tEMPTY_CONTEXT_CUSTOMIZERS, contextLoader,\n\t\t\t\tcacheAwareContextLoaderDelegate, parent);\n\t}\n\n\t/**\n\t * Create a new {@code MergedContextConfiguration} instance for the\n\t * supplied parameters.\n\t * <p>If a {@code null} value is supplied for {@code locations},\n\t * {@code classes}, {@code activeProfiles}, {@code propertySourceLocations},\n\t * or {@code propertySourceProperties} an empty array will be stored instead.\n\t * If a {@code null} value is supplied for {@code contextInitializerClasses}\n\t * or {@code contextCustomizers}, an empty set will be stored instead.\n\t * Furthermore, active profiles will be sorted, and duplicate profiles\n\t * will be removed.\n\t * @param testClass the test class for which the configuration was merged\n\t * @param locations the merged context resource locations\n\t * @param classes the merged annotated classes\n\t * @param contextInitializerClasses the merged context initializer classes\n\t * @param activeProfiles the merged active bean definition profiles\n\t * @param propertySourceLocations the merged {@code PropertySource} locations\n\t * @param propertySourceProperties the merged {@code PropertySource} properties\n\t * @param contextCustomizers the context customizers\n\t * @param contextLoader the resolved {@code ContextLoader}\n\t * @param cacheAwareContextLoaderDelegate a cache-aware context loader\n\t * delegate with which to retrieve the parent {@code ApplicationContext}\n\t * @param parent the parent configuration or {@code null} if there is no parent\n\t * @since 4.3\n\t * @deprecated since 6.1 in favor of\n\t * {@link #MergedContextConfiguration(Class, String[], Class[], Set, String[], List, String[], Set, ContextLoader, CacheAwareContextLoaderDelegate, MergedContextConfiguration)}\n\t */\n\t@Deprecated(since = \"6.1\")\n\tpublic MergedContextConfiguration(Class<?> testClass, @Nullable String[] locations, @Nullable Class<?>[] classes,\n\t\t\t@Nullable Set<Class<? extends ApplicationContextInitializer<?>>> contextInitializerClasses,\n\t\t\t@Nullable String[] activeProfiles, @Nullable String[] propertySourceLocations,\n\t\t\t@Nullable String[] propertySourceProperties, @Nullable Set<ContextCustomizer> contextCustomizers,\n\t\t\tContextLoader contextLoader, @Nullable CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate,\n\t\t\t@Nullable MergedContextConfiguration parent) {\n\n\t\tthis(testClass, locations, classes, contextInitializerClasses, activeProfiles,\n\t\t\tList.of(new PropertySourceDescriptor(processStrings(propertySourceLocations))),\n\t\t\tpropertySourceProperties, contextCustomizers, contextLoader, cacheAwareContextLoaderDelegate,\n\t\t\tparent);\n\t}\n\n\t/**\n\t * Create a new {@code MergedContextConfiguration} instance for the supplied\n\t * parameters.\n\t * <p>If a {@code null} value is supplied for {@code locations}, {@code classes},\n\t * {@code activeProfiles}, or {@code propertySourceProperties} an empty array\n\t * will be stored instead. If a {@code null} value is supplied for\n\t * {@code contextInitializerClasses} or {@code contextCustomizers}, an empty\n\t * set will be stored instead. Furthermore, active profiles will be sorted,\n\t * and duplicate profiles will be removed.\n\t * @param testClass the test class for which the configuration was merged\n\t * @param locations the merged context resource locations\n\t * @param classes the merged annotated classes\n\t * @param contextInitializerClasses the merged context initializer classes\n\t * @param activeProfiles the merged active bean definition profiles\n\t * @param propertySourceDescriptors the merged property source descriptors\n\t * @param propertySourceProperties the merged inlined properties\n\t * @param contextCustomizers the context customizers\n\t * @param contextLoader the resolved {@code ContextLoader}\n\t * @param cacheAwareContextLoaderDelegate a cache-aware context loader\n\t * delegate with which to retrieve the parent {@code ApplicationContext}\n\t * @param parent the parent configuration or {@code null} if there is no parent\n\t * @since 6.1\n\t */\n\tpublic MergedContextConfiguration(Class<?> testClass, @Nullable String[] locations, @Nullable Class<?>[] classes,\n\t\t\t@Nullable Set<Class<? extends ApplicationContextInitializer<?>>> contextInitializerClasses,\n\t\t\t@Nullable String[] activeProfiles, List<PropertySourceDescriptor> propertySourceDescriptors,\n\t\t\t@Nullable String[] propertySourceProperties, @Nullable Set<ContextCustomizer> contextCustomizers,\n\t\t\tContextLoader contextLoader, @Nullable CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate,\n\t\t\t@Nullable MergedContextConfiguration parent) {\n\n\t\tthis.testClass = testClass;\n\t\tthis.locations = processStrings(locations);\n\t\tthis.classes = processClasses(classes);\n\t\tthis.contextInitializerClasses = processContextInitializerClasses(contextInitializerClasses);\n\t\tthis.activeProfiles = processActiveProfiles(activeProfiles);\n\t\tthis.propertySourceDescriptors = Collections.unmodifiableList(propertySourceDescriptors);\n\t\tthis.propertySourceLocations = this.propertySourceDescriptors.stream()\n\t\t\t\t.map(PropertySourceDescriptor::locations)\n\t\t\t\t.flatMap(List::stream)\n\t\t\t\t.toArray(String[]::new);\n\t\tthis.propertySourceProperties = processStrings(propertySourceProperties);\n\t\tthis.contextCustomizers = processContextCustomizers(contextCustomizers);\n\t\tthis.contextLoader = contextLoader;\n\t\tthis.cacheAwareContextLoaderDelegate = cacheAwareContextLoaderDelegate;\n\t\tthis.parent = parent;\n\t}\n\n\n\t/**\n\t * Get the {@linkplain Class test class} associated with this\n\t * {@code MergedContextConfiguration}.\n\t */\n\tpublic Class<?> getTestClass() {\n\t\treturn this.testClass;\n\t}\n\n\t/**\n\t * Get the merged resource locations for {@code ApplicationContext}\n\t * configuration files for the {@linkplain #getTestClass() test class}.\n\t * <p>Context resource locations typically represent XML configuration\n\t * files or Groovy scripts.\n\t */\n\tpublic String[] getLocations() {\n\t\treturn this.locations;\n\t}\n\n\t/**\n\t * Get the merged annotated classes for the {@linkplain #getTestClass() test class}.\n\t */\n\tpublic Class<?>[] getClasses() {\n\t\treturn this.classes;\n\t}\n\n\t/**\n\t * Determine if this {@code MergedContextConfiguration} instance has\n\t * path-based context resource locations.\n\t * @return {@code true} if the {@link #getLocations() locations} array is not empty\n\t * @since 4.0.4\n\t * @see #hasResources()\n\t * @see #hasClasses()\n\t */\n\tpublic boolean hasLocations() {\n\t\treturn !ObjectUtils.isEmpty(getLocations());\n\t}\n\n\t/**\n\t * Determine if this {@code MergedContextConfiguration} instance has\n\t * class-based resources.\n\t * @return {@code true} if the {@link #getClasses() classes} array is not empty\n\t * @since 4.0.4\n\t * @see #hasResources()\n\t * @see #hasLocations()\n\t */\n\tpublic boolean hasClasses() {\n\t\treturn !ObjectUtils.isEmpty(getClasses());\n\t}\n\n\t/**\n\t * Determine if this {@code MergedContextConfiguration} instance has\n\t * either path-based context resource locations or class-based resources.\n\t * @return {@code true} if either the {@link #getLocations() locations}\n\t * or the {@link #getClasses() classes} array is not empty\n\t * @since 4.0.4\n\t * @see #hasLocations()\n\t * @see #hasClasses()\n\t */\n\tpublic boolean hasResources() {\n\t\treturn (hasLocations() || hasClasses());\n\t}\n\n\t/**\n\t * Get the merged {@code ApplicationContextInitializer} classes for the\n\t * {@linkplain #getTestClass() test class}.\n\t */\n\tpublic Set<Class<? extends ApplicationContextInitializer<?>>> getContextInitializerClasses() {\n\t\treturn this.contextInitializerClasses;\n\t}\n\n\t/**\n\t * Get the merged active bean definition profiles for the\n\t * {@linkplain #getTestClass() test class}.\n\t * @see ActiveProfiles\n\t */\n\tpublic String[] getActiveProfiles() {\n\t\treturn this.activeProfiles;\n\t}\n\n\t/**\n\t * Get the merged descriptors for resource locations for test {@code PropertySources}\n\t * for the {@linkplain #getTestClass() test class}.\n\t * <p>Properties will be loaded into the {@code Environment}'s set of\n\t * {@code PropertySources}.\n\t * @since 6.1\n\t * @see TestPropertySource#locations\n\t * @see TestPropertySource#encoding\n\t * @see TestPropertySource#factory\n\t */\n\tpublic List<PropertySourceDescriptor> getPropertySourceDescriptors() {\n\t\treturn this.propertySourceDescriptors;\n\t}\n\n\t/**\n\t * Get the merged resource locations of properties files for the\n\t * {@linkplain #getTestClass() test class}.\n\t * @see TestPropertySource#locations\n\t * @see java.util.Properties\n\t * @deprecated since 6.1 in favor of {@link #getPropertySourceDescriptors()}\n\t */\n\t@Deprecated(since = \"6.1\")\n\tpublic String[] getPropertySourceLocations() {\n\t\treturn this.propertySourceLocations;\n\t}\n\n\t/**\n\t * Get the merged inlined properties for the {@linkplain #getTestClass() test class}.\n\t * <p>Properties will be loaded into the {@code Environment}'s set of\n\t * {@code PropertySources}.\n\t * @see TestPropertySource#properties\n\t * @see java.util.Properties\n\t */\n\tpublic String[] getPropertySourceProperties() {\n\t\treturn this.propertySourceProperties;\n\t}\n\n\t/**\n\t * Get the merged {@link ContextCustomizer ContextCustomizers} that will be applied\n\t * when the application context is loaded.\n\t */\n\tpublic Set<ContextCustomizer> getContextCustomizers() {\n\t\treturn this.contextCustomizers;\n\t}\n\n\t/**\n\t * Get the resolved {@link ContextLoader} for the {@linkplain #getTestClass() test class}.\n\t */\n\tpublic ContextLoader getContextLoader() {\n\t\treturn this.contextLoader;\n\t}\n\n\t/**\n\t * Get the {@link MergedContextConfiguration} for the parent application context\n\t * in a context hierarchy.\n\t * @return the parent configuration or {@code null} if there is no parent\n\t * @since 3.2.2\n\t * @see #getParentApplicationContext()\n\t */\n\t@Nullable\n\tpublic MergedContextConfiguration getParent() {\n\t\treturn this.parent;\n\t}\n\n\t/**\n\t * Get the parent {@link ApplicationContext} for the context defined by this\n\t * {@code MergedContextConfiguration} from the context cache.\n\t * <p>If the parent context has not yet been loaded, it will be loaded, stored\n\t * in the cache, and then returned.\n\t * @return the parent {@code ApplicationContext} or {@code null} if there is no parent\n\t * @since 3.2.2\n\t * @see #getParent()\n\t */\n\t@Nullable\n\tpublic ApplicationContext getParentApplicationContext() {\n\t\tif (this.parent == null) {\n\t\t\treturn null;\n\t\t}\n\t\tAssert.state(this.cacheAwareContextLoaderDelegate != null,\n\t\t\t\t\"Cannot retrieve a parent application context without access to the CacheAwareContextLoaderDelegate\");\n\t\treturn this.cacheAwareContextLoaderDelegate.loadContext(this.parent);\n\t}\n\n\n\t/**\n\t * Determine if the supplied object is equal to this {@code MergedContextConfiguration}\n\t * instance by comparing both objects' {@linkplain #getLocations() locations},\n\t * {@linkplain #getClasses() annotated classes},\n\t * {@linkplain #getContextInitializerClasses() context initializer classes},\n\t * {@linkplain #getActiveProfiles() active profiles},\n\t * {@linkplain #getPropertySourceDescriptors() property source descriptors},\n\t * {@linkplain #getPropertySourceProperties() property source properties},\n\t * {@linkplain #getContextCustomizers() context customizers},\n\t * {@linkplain #getParent() parents}, and the fully qualified names of their\n\t * {@link #getContextLoader() ContextLoaders}.\n\t */\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (other == null || other.getClass() != getClass()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tMergedContextConfiguration otherConfig = (MergedContextConfiguration) other;\n\t\tif (!Arrays.equals(this.locations, otherConfig.locations)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!Arrays.equals(this.classes, otherConfig.classes)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!this.contextInitializerClasses.equals(otherConfig.contextInitializerClasses)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!Arrays.equals(this.activeProfiles, otherConfig.activeProfiles)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!this.propertySourceDescriptors.equals(otherConfig.propertySourceDescriptors)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!Arrays.equals(this.propertySourceProperties, otherConfig.propertySourceProperties)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!this.contextCustomizers.equals(otherConfig.contextCustomizers)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.parent == null) {\n\t\t\tif (otherConfig.parent != null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (!this.parent.equals(otherConfig.parent)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!nullSafeClassName(this.contextLoader).equals(nullSafeClassName(otherConfig.contextLoader))) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Generate a unique hash code for all properties of this\n\t * {@code MergedContextConfiguration} excluding the\n\t * {@linkplain #getTestClass() test class}.\n\t */\n\t@Override\n\tpublic int hashCode() {\n\t\tint result = Arrays.hashCode(this.locations);\n\t\tresult = 31 * result + Arrays.hashCode(this.classes);\n\t\tresult = 31 * result + this.contextInitializerClasses.hashCode();\n\t\tresult = 31 * result + Arrays.hashCode(this.activeProfiles);\n\t\tresult = 31 * result + this.propertySourceDescriptors.hashCode();\n\t\tresult = 31 * result + Arrays.hashCode(this.propertySourceProperties);\n\t\tresult = 31 * result + this.contextCustomizers.hashCode();\n\t\tresult = 31 * result + (this.parent != null ? this.parent.hashCode() : 0);\n\t\tresult = 31 * result + nullSafeClassName(this.contextLoader).hashCode();\n\t\treturn result;\n\t}\n\n\t/**\n\t * Provide a String representation of the {@linkplain #getTestClass() test class},\n\t * {@linkplain #getLocations() locations}, {@linkplain #getClasses() annotated classes},\n\t * {@linkplain #getContextInitializerClasses() context initializer classes},\n\t * {@linkplain #getActiveProfiles() active profiles},\n\t * {@linkplain #getPropertySourceDescriptors() property source descriptors},\n\t * {@linkplain #getPropertySourceProperties() property source properties},\n\t * {@linkplain #getContextCustomizers() context customizers},\n\t * the name of the {@link #getContextLoader() ContextLoader}, and the\n\t * {@linkplain #getParent() parent configuration}.\n\t */\n\t@Override\n\tpublic String toString() {\n\t\treturn new ToStringCreator(this, new DefaultToStringStyler(new SimpleValueStyler()))\n\t\t\t\t.append(\"testClass\", this.testClass)\n\t\t\t\t.append(\"locations\", this.locations)\n\t\t\t\t.append(\"classes\", this.classes)\n\t\t\t\t.append(\"contextInitializerClasses\", this.contextInitializerClasses)\n\t\t\t\t.append(\"activeProfiles\", this.activeProfiles)\n\t\t\t\t.append(\"propertySourceDescriptors\", this.propertySourceDescriptors)\n\t\t\t\t.append(\"propertySourceProperties\", this.propertySourceProperties)\n\t\t\t\t.append(\"contextCustomizers\", this.contextCustomizers)\n\t\t\t\t.append(\"contextLoader\", (this.contextLoader != null ? this.contextLoader.getClass() : null))\n\t\t\t\t.append(\"parent\", this.parent)\n\t\t\t\t.toString();\n\t}\n\n\n\tprotected static String[] processStrings(@Nullable String[] array) {\n\t\treturn (array != null ? array : EMPTY_STRING_ARRAY);\n\t}\n\n\tprivate static Class<?>[] processClasses(@Nullable Class<?>[] classes) {\n\t\treturn (classes != null ? classes : EMPTY_CLASS_ARRAY);\n\t}\n\n\tprivate static Set<Class<? extends ApplicationContextInitializer<?>>> processContextInitializerClasses(\n\t\t\t@Nullable Set<Class<? extends ApplicationContextInitializer<?>>> contextInitializerClasses) {\n\n\t\treturn (contextInitializerClasses != null ?\n\t\t\t\tCollections.unmodifiableSet(contextInitializerClasses) : EMPTY_INITIALIZER_CLASSES);\n\t}\n\n\tprivate static Set<ContextCustomizer> processContextCustomizers(\n\t\t\t@Nullable Set<ContextCustomizer> contextCustomizers) {\n\n\t\treturn (contextCustomizers != null ?\n\t\t\t\tCollections.unmodifiableSet(contextCustomizers) : EMPTY_CONTEXT_CUSTOMIZERS);\n\t}\n\n\tprivate static String[] processActiveProfiles(@Nullable String[] activeProfiles) {\n\t\tif (activeProfiles == null) {\n\t\t\treturn EMPTY_STRING_ARRAY;\n\t\t}\n\n\t\t// Active profiles must be unique\n\t\tSet<String> profilesSet = new LinkedHashSet<>(Arrays.asList(activeProfiles));\n\t\treturn StringUtils.toStringArray(profilesSet);\n\t}\n\n\t/**\n\t * Generate a null-safe {@link String} representation of the supplied\n\t * {@link ContextLoader} based solely on the fully qualified name of the\n\t * loader or &quot;null&quot; if the supplied loader is {@code null}.\n\t */\n\tprotected static String nullSafeClassName(@Nullable ContextLoader contextLoader) {\n\t\treturn (contextLoader != null ? contextLoader.getClass().getName() : \"null\");\n\t}\n\n}"
  },
  "org.springframework.test.context.MergedContextConfiguration#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied object is equal to this {@code MergedContextConfiguration}\n\t * instance by comparing both objects' {@linkplain #getLocations() locations},\n\t * {@linkplain #getClasses() annotated classes},\n\t * {@linkplain #getContextInitializerClasses() context initializer classes},\n\t * {@linkplain #getActiveProfiles() active profiles},\n\t * {@linkplain #getPropertySourceDescriptors() property source descriptors},\n\t * {@linkplain #getPropertySourceProperties() property source properties},\n\t * {@linkplain #getContextCustomizers() context customizers},\n\t * {@linkplain #getParent() parents}, and the fully qualified names of their\n\t * {@link #getContextLoader() ContextLoaders}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 484
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (other == null || other.getClass() != getClass()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tMergedContextConfiguration otherConfig = (MergedContextConfiguration) other;\n\t\tif (!Arrays.equals(this.locations, otherConfig.locations)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!Arrays.equals(this.classes, otherConfig.classes)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!this.contextInitializerClasses.equals(otherConfig.contextInitializerClasses)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!Arrays.equals(this.activeProfiles, otherConfig.activeProfiles)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!this.propertySourceDescriptors.equals(otherConfig.propertySourceDescriptors)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!Arrays.equals(this.propertySourceProperties, otherConfig.propertySourceProperties)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!this.contextCustomizers.equals(otherConfig.contextCustomizers)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.parent == null) {\n\t\t\tif (otherConfig.parent != null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (!this.parent.equals(otherConfig.parent)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!nullSafeClassName(this.contextLoader).equals(nullSafeClassName(otherConfig.contextLoader))) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#getActiveProfiles()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the merged active bean definition profiles for the\n\t * {@linkplain #getTestClass() test class}.\n\t * @see ActiveProfiles\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 383
    },
    "return": "String[]",
    "signature": "public String[] getActiveProfiles()",
    "source_code": "\tpublic String[] getActiveProfiles() {\n\t\treturn this.activeProfiles;\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#getContextCustomizers()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the merged {@link ContextCustomizer ContextCustomizers} that will be applied\n\t * when the application context is loaded.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 428
    },
    "return": "Set<ContextCustomizer>",
    "signature": "public Set<ContextCustomizer> getContextCustomizers()",
    "source_code": "\tpublic Set<ContextCustomizer> getContextCustomizers() {\n\t\treturn this.contextCustomizers;\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#getContextLoader()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the resolved {@link ContextLoader} for the {@linkplain #getTestClass() test class}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 435
    },
    "return": "ContextLoader",
    "signature": "public ContextLoader getContextLoader()",
    "source_code": "\tpublic ContextLoader getContextLoader() {\n\t\treturn this.contextLoader;\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#getLocations()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the merged resource locations for {@code ApplicationContext}\n\t * configuration files for the {@linkplain #getTestClass() test class}.\n\t * <p>Context resource locations typically represent XML configuration\n\t * files or Groovy scripts.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 322
    },
    "return": "String[]",
    "signature": "public String[] getLocations()",
    "source_code": "\tpublic String[] getLocations() {\n\t\treturn this.locations;\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#getParent()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the {@link MergedContextConfiguration} for the parent application context\n\t * in a context hierarchy.\n\t * @return the parent configuration or {@code null} if there is no parent\n\t * @since 3.2.2\n\t * @see #getParentApplicationContext()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 447
    },
    "return": "MergedContextConfiguration",
    "signature": "public MergedContextConfiguration getParent()",
    "source_code": "\tpublic MergedContextConfiguration getParent() {\n\t\treturn this.parent;\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#getParentApplicationContext()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the parent {@link ApplicationContext} for the context defined by this\n\t * {@code MergedContextConfiguration} from the context cache.\n\t * <p>If the parent context has not yet been loaded, it will be loaded, stored\n\t * in the cache, and then returned.\n\t * @return the parent {@code ApplicationContext} or {@code null} if there is no parent\n\t * @since 3.2.2\n\t * @see #getParent()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 461
    },
    "return": "ApplicationContext",
    "signature": "public ApplicationContext getParentApplicationContext()",
    "source_code": "\tpublic ApplicationContext getParentApplicationContext() {\n\t\tif (this.parent == null) {\n\t\t\treturn null;\n\t\t}\n\t\tAssert.state(this.cacheAwareContextLoaderDelegate != null,\n\t\t\t\t\"Cannot retrieve a parent application context without access to the CacheAwareContextLoaderDelegate\");\n\t\treturn this.cacheAwareContextLoaderDelegate.loadContext(this.parent);\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#getPropertySourceDescriptors()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the merged descriptors for resource locations for test {@code PropertySources}\n\t * for the {@linkplain #getTestClass() test class}.\n\t * <p>Properties will be loaded into the {@code Environment}'s set of\n\t * {@code PropertySources}.\n\t * @since 6.1\n\t * @see TestPropertySource#locations\n\t * @see TestPropertySource#encoding\n\t * @see TestPropertySource#factory\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 397
    },
    "return": "List<PropertySourceDescriptor>",
    "signature": "public List<PropertySourceDescriptor> getPropertySourceDescriptors()",
    "source_code": "\tpublic List<PropertySourceDescriptor> getPropertySourceDescriptors() {\n\t\treturn this.propertySourceDescriptors;\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#getPropertySourceLocations()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the merged resource locations of properties files for the\n\t * {@linkplain #getTestClass() test class}.\n\t * @see TestPropertySource#locations\n\t * @see java.util.Properties\n\t * @deprecated since 6.1 in favor of {@link #getPropertySourceDescriptors()}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 409
    },
    "return": "String[]",
    "signature": "public String[] getPropertySourceLocations()",
    "source_code": "\tpublic String[] getPropertySourceLocations() {\n\t\treturn this.propertySourceLocations;\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#getPropertySourceProperties()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the merged inlined properties for the {@linkplain #getTestClass() test class}.\n\t * <p>Properties will be loaded into the {@code Environment}'s set of\n\t * {@code PropertySources}.\n\t * @see TestPropertySource#properties\n\t * @see java.util.Properties\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 420
    },
    "return": "String[]",
    "signature": "public String[] getPropertySourceProperties()",
    "source_code": "\tpublic String[] getPropertySourceProperties() {\n\t\treturn this.propertySourceProperties;\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#hasClasses()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if this {@code MergedContextConfiguration} instance has\n\t * class-based resources.\n\t * @return {@code true} if the {@link #getClasses() classes} array is not empty\n\t * @since 4.0.4\n\t * @see #hasResources()\n\t * @see #hasLocations()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 353
    },
    "return": "boolean",
    "signature": "public boolean hasClasses()",
    "source_code": "\tpublic boolean hasClasses() {\n\t\treturn !ObjectUtils.isEmpty(getClasses());\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#hasLocations()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if this {@code MergedContextConfiguration} instance has\n\t * path-based context resource locations.\n\t * @return {@code true} if the {@link #getLocations() locations} array is not empty\n\t * @since 4.0.4\n\t * @see #hasResources()\n\t * @see #hasClasses()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "boolean",
    "signature": "public boolean hasLocations()",
    "source_code": "\tpublic boolean hasLocations() {\n\t\treturn !ObjectUtils.isEmpty(getLocations());\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#hasResources()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if this {@code MergedContextConfiguration} instance has\n\t * either path-based context resource locations or class-based resources.\n\t * @return {@code true} if either the {@link #getLocations() locations}\n\t * or the {@link #getClasses() classes} array is not empty\n\t * @since 4.0.4\n\t * @see #hasLocations()\n\t * @see #hasClasses()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 366
    },
    "return": "boolean",
    "signature": "public boolean hasResources()",
    "source_code": "\tpublic boolean hasResources() {\n\t\treturn (hasLocations() || hasClasses());\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate a unique hash code for all properties of this\n\t * {@code MergedContextConfiguration} excluding the\n\t * {@linkplain #getTestClass() test class}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 537
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\tint result = Arrays.hashCode(this.locations);\n\t\tresult = 31 * result + Arrays.hashCode(this.classes);\n\t\tresult = 31 * result + this.contextInitializerClasses.hashCode();\n\t\tresult = 31 * result + Arrays.hashCode(this.activeProfiles);\n\t\tresult = 31 * result + this.propertySourceDescriptors.hashCode();\n\t\tresult = 31 * result + Arrays.hashCode(this.propertySourceProperties);\n\t\tresult = 31 * result + this.contextCustomizers.hashCode();\n\t\tresult = 31 * result + (this.parent != null ? this.parent.hashCode() : 0);\n\t\tresult = 31 * result + nullSafeClassName(this.contextLoader).hashCode();\n\t\treturn result;\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#nullSafeClassName(contextLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate a null-safe {@link String} representation of the supplied\n\t * {@link ContextLoader} based solely on the fully qualified name of the\n\t * loader or &quot;null&quot; if the supplied loader is {@code null}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "contextLoader"
    ],
    "position": {
      "column": 1,
      "line": 615
    },
    "return": "String",
    "signature": "protected String nullSafeClassName(@Nullable ContextLoader contextLoader)",
    "source_code": "\tprotected static String nullSafeClassName(@Nullable ContextLoader contextLoader) {\n\t\treturn (contextLoader != null ? contextLoader.getClass().getName() : \"null\");\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#processStrings(array)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "array"
    ],
    "position": {
      "column": 1,
      "line": 578
    },
    "return": "String[]",
    "signature": "protected String[] processStrings(@Nullable String[] array)",
    "source_code": "\tprotected static String[] processStrings(@Nullable String[] array) {\n\t\treturn (array != null ? array : EMPTY_STRING_ARRAY);\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide a String representation of the {@linkplain #getTestClass() test class},\n\t * {@linkplain #getLocations() locations}, {@linkplain #getClasses() annotated classes},\n\t * {@linkplain #getContextInitializerClasses() context initializer classes},\n\t * {@linkplain #getActiveProfiles() active profiles},\n\t * {@linkplain #getPropertySourceDescriptors() property source descriptors},\n\t * {@linkplain #getPropertySourceProperties() property source properties},\n\t * {@linkplain #getContextCustomizers() context customizers},\n\t * the name of the {@link #getContextLoader() ContextLoader}, and the\n\t * {@linkplain #getParent() parent configuration}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 562
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn new ToStringCreator(this, new DefaultToStringStyler(new SimpleValueStyler()))\n\t\t\t\t.append(\"testClass\", this.testClass)\n\t\t\t\t.append(\"locations\", this.locations)\n\t\t\t\t.append(\"classes\", this.classes)\n\t\t\t\t.append(\"contextInitializerClasses\", this.contextInitializerClasses)\n\t\t\t\t.append(\"activeProfiles\", this.activeProfiles)\n\t\t\t\t.append(\"propertySourceDescriptors\", this.propertySourceDescriptors)\n\t\t\t\t.append(\"propertySourceProperties\", this.propertySourceProperties)\n\t\t\t\t.append(\"contextCustomizers\", this.contextCustomizers)\n\t\t\t\t.append(\"contextLoader\", (this.contextLoader != null ? this.contextLoader.getClass() : null))\n\t\t\t\t.append(\"parent\", this.parent)\n\t\t\t\t.toString();\n\t}"
  },
  "org.springframework.test.context.aot.<unknown>#registerHints(runtimeHints,mergedConfig,classLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runtimeHints",
      "mergedConfig",
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "void",
    "signature": "public void registerHints(RuntimeHints runtimeHints, MergedContextConfiguration mergedConfig, ClassLoader classLoader)",
    "source_code": "\tpublic void registerHints(RuntimeHints runtimeHints, MergedContextConfiguration mergedConfig, ClassLoader classLoader) {\n\t\t// @ContextConfiguration(loader = ...)\n\t\tContextLoader contextLoader = mergedConfig.getContextLoader();\n\t\tif (contextLoader != null) {\n\t\t\tregisterDeclaredConstructors(contextLoader.getClass(), runtimeHints);\n\t\t}\n\n\t\t// @ContextConfiguration(initializers = ...)\n\t\tmergedConfig.getContextInitializerClasses()\n\t\t\t\t.forEach(clazz -> registerDeclaredConstructors(clazz, runtimeHints));\n\n\t\t// @ContextConfiguration(locations = ...)\n\t\tregisterClasspathResources(\"@ContextConfiguration\", mergedConfig.getLocations(), runtimeHints, classLoader);\n\n\t\tfor (PropertySourceDescriptor descriptor : mergedConfig.getPropertySourceDescriptors()) {\n\t\t\t// @TestPropertySource(locations = ...)\n\t\t\tregisterClasspathResources(\"@TestPropertySource\", descriptor.locations(), runtimeHints, classLoader);\n\n\t\t\t// @TestPropertySource(factory = ...)\n\t\t\tClass<?> factoryClass = descriptor.propertySourceFactory();\n\t\t\tif (factoryClass != null) {\n\t\t\t\tregisterDeclaredConstructors(factoryClass, runtimeHints);\n\t\t\t}\n\t\t}\n\n\t\t// @WebAppConfiguration(value = ...)\n\t\tif (webMergedContextConfigurationClass.isInstance(mergedConfig)) {\n\t\t\tString resourceBasePath;\n\t\t\ttry {\n\t\t\t\tresourceBasePath = (String) getResourceBasePathMethod.invoke(mergedConfig);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Failed to invoke WebMergedContextConfiguration#getResourceBasePath()\", ex);\n\t\t\t}\n\t\t\tregisterClasspathResourceDirectoryStructure(resourceBasePath, runtimeHints);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.aot.FAIL_ON_ERROR_PROPERTY_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * JVM system property used to set the {@code failOnError} flag: {@value}.\n\t * <p>The {@code failOnError} flag controls whether errors encountered during\n\t * AOT processing in the <em>Spring TestContext Framework</em> should result\n\t * in an exception that fails the overall process.\n\t * <p>Defaults to {@code true}.\n\t * <p>Supported values include {@code true} or {@code false}, ignoring case.\n\t * For example, the default may be changed to {@code false} by supplying\n\t * the following JVM system property via the command line.\n\t * <pre style=\"code\">-Dspring.test.aot.processing.failOnError=false</pre>\n\t * <p>May alternatively be configured via the\n\t * {@link org.springframework.core.SpringProperties SpringProperties}\n\t * mechanism.\n\t * @since 6.1\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "signature": "public String FAIL_ON_ERROR_PROPERTY_NAME",
    "source_code": "\tpublic static final String FAIL_ON_ERROR_PROPERTY_NAME = \"spring.test.aot.processing.failOnError\";",
    "type": "String"
  },
  "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#closeContext(mergedConfig,hierarchyMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedConfig",
      "hierarchyMode"
    ],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "void",
    "signature": "public void closeContext(MergedContextConfiguration mergedConfig, @Nullable HierarchyMode hierarchyMode)",
    "source_code": "\tpublic void closeContext(MergedContextConfiguration mergedConfig, @Nullable HierarchyMode hierarchyMode) {\n\t\tmergedConfig = replaceIfNecessary(mergedConfig);\n\t\tsynchronized (this.contextCache) {\n\t\t\tthis.contextCache.remove(mergedConfig, hierarchyMode);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#closeContext(mergedContextConfiguration,hierarchyMode)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedContextConfiguration",
      "hierarchyMode"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "void",
    "signature": "public void closeContext(MergedContextConfiguration mergedContextConfiguration, @Nullable HierarchyMode hierarchyMode)",
    "source_code": "\tpublic void closeContext(MergedContextConfiguration mergedContextConfiguration, @Nullable HierarchyMode hierarchyMode) {\n\t\tsynchronized (this.contextCache) {\n\t\t\tthis.contextCache.remove(replaceIfNecessary(mergedContextConfiguration), hierarchyMode);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#isContextLoaded(mergedConfig)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedConfig"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "boolean",
    "signature": "public boolean isContextLoaded(MergedContextConfiguration mergedConfig)",
    "source_code": "\tpublic boolean isContextLoaded(MergedContextConfiguration mergedConfig) {\n\t\tmergedConfig = replaceIfNecessary(mergedConfig);\n\t\tsynchronized (this.contextCache) {\n\t\t\treturn this.contextCache.contains(mergedConfig);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#isContextLoaded(mergedContextConfiguration)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedContextConfiguration"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "boolean",
    "signature": "public boolean isContextLoaded(MergedContextConfiguration mergedContextConfiguration)",
    "source_code": "\tpublic boolean isContextLoaded(MergedContextConfiguration mergedContextConfiguration) {\n\t\tsynchronized (this.contextCache) {\n\t\t\treturn this.contextCache.contains(replaceIfNecessary(mergedContextConfiguration));\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#loadContext(mergedConfig)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedConfig"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "ApplicationContext",
    "signature": "public ApplicationContext loadContext(MergedContextConfiguration mergedConfig)",
    "source_code": "\tpublic ApplicationContext loadContext(MergedContextConfiguration mergedConfig) {\n\t\tmergedConfig = replaceIfNecessary(mergedConfig);\n\t\tsynchronized (this.contextCache) {\n\t\t\tApplicationContext context = this.contextCache.get(mergedConfig);\n\t\t\ttry {\n\t\t\t\tif (context == null) {\n\t\t\t\t\tint failureCount = this.contextCache.getFailureCount(mergedConfig);\n\t\t\t\t\tif (failureCount >= this.failureThreshold) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\t\t\t\t\tApplicationContext failure threshold (%d) exceeded: \\\n\t\t\t\t\t\t\t\tskipping repeated attempt to load context for %s\"\"\"\n\t\t\t\t\t\t\t\t\t.formatted(this.failureThreshold, mergedConfig));\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (mergedConfig instanceof AotMergedContextConfiguration aotMergedConfig) {\n\t\t\t\t\t\t\tcontext = loadContextInAotMode(aotMergedConfig);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcontext = loadContextInternal(mergedConfig);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Storing ApplicationContext [%s] in cache under key %s\".formatted(\n\t\t\t\t\t\t\t\t\tSystem.identityHashCode(context), mergedConfig));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.contextCache.put(mergedConfig, context);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Incrementing ApplicationContext failure count for \" + mergedConfig);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.contextCache.incrementFailureCount(mergedConfig);\n\t\t\t\t\t\tThrowable cause = ex;\n\t\t\t\t\t\tif (ex instanceof ContextLoadException cle) {\n\t\t\t\t\t\t\tcause = cle.getCause();\n\t\t\t\t\t\t\tfor (ApplicationContextFailureProcessor contextFailureProcessor : this.contextFailureProcessors) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tcontextFailureProcessor.processLoadFailure(cle.getApplicationContext(), cause);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch (Throwable throwable) {\n\t\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\t\tlogger.debug(\"Ignoring exception thrown from ApplicationContextFailureProcessor [%s]: %s\"\n\t\t\t\t\t\t\t\t\t\t\t\t.formatted(contextFailureProcessor, throwable));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\t\"Failed to load ApplicationContext for \" + mergedConfig, cause);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Retrieved ApplicationContext [%s] from cache with key %s\".formatted(\n\t\t\t\t\t\t\t\tSystem.identityHashCode(context), mergedConfig));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.contextCache.logStatistics();\n\t\t\t}\n\n\t\t\treturn context;\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#loadContext(mergedContextConfiguration)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedContextConfiguration"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "ApplicationContext",
    "signature": "public ApplicationContext loadContext(MergedContextConfiguration mergedContextConfiguration)",
    "source_code": "\tpublic ApplicationContext loadContext(MergedContextConfiguration mergedContextConfiguration) {\n\t\tmergedContextConfiguration = replaceIfNecessary(mergedContextConfiguration);\n\t\tsynchronized (this.contextCache) {\n\t\t\tApplicationContext context = this.contextCache.get(mergedContextConfiguration);\n\t\t\ttry {\n\t\t\t\tif (context == null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (mergedContextConfiguration instanceof AotMergedContextConfiguration aotMergedConfig) {\n\t\t\t\t\t\t\tcontext = loadContextInAotMode(aotMergedConfig);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcontext = loadContextInternal(mergedContextConfiguration);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Storing ApplicationContext [%s] in cache under key %s\".formatted(\n\t\t\t\t\t\t\t\t\tSystem.identityHashCode(context), mergedContextConfiguration));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.contextCache.put(mergedContextConfiguration, context);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\tThrowable cause = ex;\n\t\t\t\t\t\tif (ex instanceof ContextLoadException cle) {\n\t\t\t\t\t\t\tcause = cle.getCause();\n\t\t\t\t\t\t\tfor (ApplicationContextFailureProcessor contextFailureProcessor : this.contextFailureProcessors) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tcontextFailureProcessor.processLoadFailure(cle.getApplicationContext(), cause);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch (Throwable throwable) {\n\t\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\t\tlogger.debug(\"Ignoring exception thrown from ApplicationContextFailureProcessor [%s]: %s\"\n\t\t\t\t\t\t\t\t\t\t\t\t.formatted(contextFailureProcessor, throwable));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\t\"Failed to load ApplicationContext for \" + mergedContextConfiguration, cause);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Retrieved ApplicationContext [%s] from cache with key %s\".formatted(\n\t\t\t\t\t\t\t\tSystem.identityHashCode(context), mergedContextConfiguration));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.contextCache.logStatistics();\n\t\t\t}\n\n\t\t\treturn context;\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#loadContextInternal(mergedConfig)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Load the {@code ApplicationContext} for the supplied merged context configuration.\n\t * <p>Supports both the {@link SmartContextLoader} and {@link ContextLoader} SPIs.\n\t * @throws Exception if an error occurs while loading the application context\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mergedConfig"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "ApplicationContext",
    "signature": "protected ApplicationContext loadContextInternal(MergedContextConfiguration mergedConfig)",
    "source_code": "\tprotected ApplicationContext loadContextInternal(MergedContextConfiguration mergedConfig)"
  },
  "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#loadContextInternal(mergedContextConfiguration)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Load the {@code ApplicationContext} for the supplied merged context configuration.\n\t * <p>Supports both the {@link SmartContextLoader} and {@link ContextLoader} SPIs.\n\t * @throws Exception if an error occurs while loading the application context\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mergedContextConfiguration"
    ],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "ApplicationContext",
    "signature": "protected ApplicationContext loadContextInternal(MergedContextConfiguration mergedContextConfiguration)",
    "source_code": "\tprotected ApplicationContext loadContextInternal(MergedContextConfiguration mergedContextConfiguration)"
  },
  "org.springframework.test.context.cache.DefaultContextCache#getFailureCount(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "int",
    "signature": "public int getFailureCount(MergedContextConfiguration key)",
    "source_code": "\tpublic int getFailureCount(MergedContextConfiguration key) {\n\t\treturn this.failureCounts.getOrDefault(key, 0);\n\t}"
  },
  "org.springframework.test.context.cache.DefaultContextCache#incrementFailureCount(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "void",
    "signature": "public void incrementFailureCount(MergedContextConfiguration key)",
    "source_code": "\tpublic void incrementFailureCount(MergedContextConfiguration key) {\n\t\tthis.totalFailureCount.incrementAndGet();\n\t\tthis.failureCounts.merge(key, 1, Integer::sum);\n\t}"
  },
  "org.springframework.test.context.jdbc.SqlScriptsTestExecutionListener#afterTestClass(testContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute SQL scripts configured via {@link Sql @Sql} for the supplied\n\t * {@link TestContext} once per test class <em>after</em> all test methods\n\t * have been run.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "void",
    "signature": "public void afterTestClass(TestContext testContext)",
    "source_code": "\tpublic void afterTestClass(TestContext testContext) throws Exception {\n\t\texecuteClassLevelSqlScripts(testContext, ExecutionPhase.AFTER_TEST_CLASS);\n\t}"
  },
  "org.springframework.test.context.jdbc.SqlScriptsTestExecutionListener#beforeTestClass(testContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute SQL scripts configured via {@link Sql @Sql} for the supplied\n\t * {@link TestContext} once per test class <em>before</em> any test method\n\t * is run.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "void",
    "signature": "public void beforeTestClass(TestContext testContext)",
    "source_code": "\tpublic void beforeTestClass(TestContext testContext) throws Exception {\n\t\texecuteClassLevelSqlScripts(testContext, ExecutionPhase.BEFORE_TEST_CLASS);\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code SpringExtension} integrates the <em>Spring TestContext Framework</em>\n * into JUnit 5's <em>Jupiter</em> programming model.\n *\n * <p>To use this extension, simply annotate a JUnit Jupiter based test class with\n * {@code @ExtendWith(SpringExtension.class)}, {@code @SpringJUnitConfig}, or\n * {@code @SpringJUnitWebConfig}.\n *\n * @author Sam Brannen\n * @author Simon Basl\u00e9\n * @since 5.0\n * @see org.springframework.test.context.junit.jupiter.EnabledIf\n * @see org.springframework.test.context.junit.jupiter.DisabledIf\n * @see org.springframework.test.context.junit.jupiter.SpringJUnitConfig\n * @see org.springframework.test.context.junit.jupiter.web.SpringJUnitWebConfig\n * @see org.springframework.test.context.TestContextManager\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "signature": "public class SpringExtension",
    "source_code": "public class SpringExtension implements BeforeAllCallback, AfterAllCallback, TestInstancePostProcessor,"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#afterAll(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@link TestContextManager#afterTestClass}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "void",
    "signature": "public void afterAll(ExtensionContext context)",
    "source_code": "\tpublic void afterAll(ExtensionContext context) throws Exception {\n\t\ttry {\n\t\t\tTestContextManager testContextManager = getTestContextManager(context);\n\t\t\tregisterMethodInvoker(testContextManager, context);\n\t\t\ttestContextManager.afterTestClass();\n\t\t}\n\t\tfinally {\n\t\t\tgetStore(context).remove(context.getRequiredTestClass());\n\t\t}\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#afterEach(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@link TestContextManager#afterTestMethod}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "void",
    "signature": "public void afterEach(ExtensionContext context)",
    "source_code": "\tpublic void afterEach(ExtensionContext context) throws Exception {\n\t\tObject testInstance = context.getRequiredTestInstance();\n\t\tMethod testMethod = context.getRequiredTestMethod();\n\t\tThrowable testException = context.getExecutionException().orElse(null);\n\t\tTestContextManager testContextManager = getTestContextManager(context);\n\t\tregisterMethodInvoker(testContextManager, context);\n\t\ttestContextManager.afterTestMethod(testInstance, testMethod, testException);\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#afterTestExecution(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@link TestContextManager#afterTestExecution}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 259
    },
    "return": "void",
    "signature": "public void afterTestExecution(ExtensionContext context)",
    "source_code": "\tpublic void afterTestExecution(ExtensionContext context) throws Exception {\n\t\tObject testInstance = context.getRequiredTestInstance();\n\t\tMethod testMethod = context.getRequiredTestMethod();\n\t\tThrowable testException = context.getExecutionException().orElse(null);\n\t\tTestContextManager testContextManager = getTestContextManager(context);\n\t\tregisterMethodInvoker(testContextManager, context);\n\t\ttestContextManager.afterTestExecution(testInstance, testMethod, testException);\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#beforeAll(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@link TestContextManager#beforeTestClass}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "void",
    "signature": "public void beforeAll(ExtensionContext context)",
    "source_code": "\tpublic void beforeAll(ExtensionContext context) throws Exception {\n\t\tTestContextManager testContextManager = getTestContextManager(context);\n\t\tregisterMethodInvoker(testContextManager, context);\n\t\ttestContextManager.beforeTestClass();\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#beforeEach(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@link TestContextManager#beforeTestMethod}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "void",
    "signature": "public void beforeEach(ExtensionContext context)",
    "source_code": "\tpublic void beforeEach(ExtensionContext context) throws Exception {\n\t\tObject testInstance = context.getRequiredTestInstance();\n\t\tMethod testMethod = context.getRequiredTestMethod();\n\t\tTestContextManager testContextManager = getTestContextManager(context);\n\t\tregisterMethodInvoker(testContextManager, context);\n\t\ttestContextManager.beforeTestMethod(testInstance, testMethod);\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#beforeTestExecution(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@link TestContextManager#beforeTestExecution}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 247
    },
    "return": "void",
    "signature": "public void beforeTestExecution(ExtensionContext context)",
    "source_code": "\tpublic void beforeTestExecution(ExtensionContext context) throws Exception {\n\t\tObject testInstance = context.getRequiredTestInstance();\n\t\tMethod testMethod = context.getRequiredTestMethod();\n\t\tTestContextManager testContextManager = getTestContextManager(context);\n\t\tregisterMethodInvoker(testContextManager, context);\n\t\ttestContextManager.beforeTestExecution(testInstance, testMethod);\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#getApplicationContext(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the {@link ApplicationContext} associated with the supplied {@code ExtensionContext}.\n\t * @param context the current {@code ExtensionContext} (never {@code null})\n\t * @return the application context\n\t * @throws IllegalStateException if an error occurs while retrieving the application context\n\t * @see org.springframework.test.context.TestContext#getApplicationContext()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 354
    },
    "return": "ApplicationContext",
    "signature": "public ApplicationContext getApplicationContext(ExtensionContext context)",
    "source_code": "\tpublic static ApplicationContext getApplicationContext(ExtensionContext context) {\n\t\treturn getTestContextManager(context).getTestContext().getApplicationContext();\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#postProcessTestInstance(testInstance,context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@link TestContextManager#prepareTestInstance}.\n\t * <p>As of Spring Framework 5.3.2, this method also validates that test\n\t * methods and test lifecycle methods are not annotated with\n\t * {@link Autowired @Autowired}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testInstance",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "void",
    "signature": "public void postProcessTestInstance(Object testInstance, ExtensionContext context)",
    "source_code": "\tpublic void postProcessTestInstance(Object testInstance, ExtensionContext context) throws Exception {\n\t\tvalidateAutowiredConfig(context);\n\t\tvalidateRecordApplicationEventsConfig(context);\n\t\tTestContextManager testContextManager = getTestContextManager(context);\n\t\tregisterMethodInvoker(testContextManager, context);\n\t\ttestContextManager.prepareTestInstance(testInstance);\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#resolveParameter(parameterContext,extensionContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve a value for the {@link Parameter} in the supplied {@link ParameterContext} by\n\t * retrieving the corresponding dependency from the test's {@link ApplicationContext}.\n\t * <p>Delegates to {@link ParameterResolutionDelegate#resolveDependency}.\n\t * @see #supportsParameter\n\t * @see ParameterResolutionDelegate#resolveDependency\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterContext",
      "extensionContext"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "Object",
    "signature": "public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext)",
    "source_code": "\tpublic Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {\n\t\tParameter parameter = parameterContext.getParameter();\n\t\tint index = parameterContext.getIndex();\n\t\tClass<?> testClass = extensionContext.getRequiredTestClass();\n\t\tApplicationContext applicationContext = getApplicationContext(extensionContext);\n\t\treturn ParameterResolutionDelegate.resolveDependency(parameter, index, testClass,\n\t\t\t\tapplicationContext.getAutowireCapableBeanFactory());\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#supportsParameter(parameterContext,extensionContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the value for the {@link Parameter} in the supplied {@link ParameterContext}\n\t * should be autowired from the test's {@link ApplicationContext}.\n\t * <p>A parameter is considered to be autowirable if one of the following\n\t * conditions is {@code true}.\n\t * <ol>\n\t * <li>The {@linkplain ParameterContext#getDeclaringExecutable() declaring\n\t * executable} is a {@link Constructor} and\n\t * {@link TestConstructorUtils#isAutowirableConstructor(Constructor, Class, PropertyProvider)}\n\t * returns {@code true}. Note that {@code isAutowirableConstructor()} will be\n\t * invoked with a fallback {@link PropertyProvider} that delegates its lookup\n\t * to {@link ExtensionContext#getConfigurationParameter(String)}.</li>\n\t * <li>The parameter is of type {@link ApplicationContext} or a sub-type thereof.</li>\n\t * <li>The parameter is of type {@link ApplicationEvents} or a sub-type thereof.</li>\n\t * <li>{@link ParameterResolutionDelegate#isAutowirable} returns {@code true}.</li>\n\t * </ol>\n\t * <p><strong>WARNING</strong>: If a test class {@code Constructor} is annotated\n\t * with {@code @Autowired} or automatically autowirable (see {@link TestConstructor}),\n\t * Spring will assume the responsibility for resolving all parameters in the\n\t * constructor. Consequently, no other registered {@link ParameterResolver}\n\t * will be able to resolve parameters.\n\t * @see #resolveParameter\n\t * @see TestConstructorUtils#isAutowirableConstructor(Constructor, Class)\n\t * @see ParameterResolutionDelegate#isAutowirable\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterContext",
      "extensionContext"
    ],
    "position": {
      "column": 1,
      "line": 307
    },
    "return": "boolean",
    "signature": "public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext)",
    "source_code": "\tpublic boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {\n\t\tParameter parameter = parameterContext.getParameter();\n\t\tExecutable executable = parameter.getDeclaringExecutable();\n\t\tClass<?> testClass = extensionContext.getRequiredTestClass();\n\t\tPropertyProvider junitPropertyProvider = propertyName ->\n\t\t\t\textensionContext.getConfigurationParameter(propertyName).orElse(null);\n\t\treturn (TestConstructorUtils.isAutowirableConstructor(executable, testClass, junitPropertyProvider) ||\n\t\t\t\tApplicationContext.class.isAssignableFrom(parameter.getType()) ||\n\t\t\t\tsupportsApplicationEvents(parameterContext) ||\n\t\t\t\tParameterResolutionDelegate.isAutowirable(parameter, parameterContext.getIndex()));\n\t}"
  },
  "org.springframework.test.context.support.DefaultTestContext#getMethodInvoker()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "MethodInvoker",
    "signature": "public MethodInvoker getMethodInvoker()",
    "source_code": "\tpublic final MethodInvoker getMethodInvoker() {\n\t\treturn this.methodInvoker;\n\t}"
  },
  "org.springframework.test.context.support.DefaultTestContext#setMethodInvoker(methodInvoker)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodInvoker"
    ],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "void",
    "signature": "public void setMethodInvoker(MethodInvoker methodInvoker)",
    "source_code": "\tpublic final void setMethodInvoker(MethodInvoker methodInvoker) {\n\t\tAssert.notNull(methodInvoker, \"MethodInvoker must not be null\");\n\t\tthis.methodInvoker = methodInvoker;\n\t}"
  },
  "org.springframework.test.context.support.INLINED_PROPERTIES_PROPERTY_SOURCE_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The name of the {@link MapPropertySource} created from <em>inlined properties</em>.\n\t * @since 4.1.5\n\t * @see #addInlinedPropertiesToEnvironment\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "signature": "public String INLINED_PROPERTIES_PROPERTY_SOURCE_NAME",
    "source_code": "\tpublic static final String INLINED_PROPERTIES_PROPERTY_SOURCE_NAME = \"Inlined Test Properties\";",
    "type": "String"
  },
  "org.springframework.test.context.support.TestPropertySourceUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Utility methods for working with {@link TestPropertySource @TestPropertySource}\n * and adding test {@link PropertySource PropertySources} to the {@code Environment}.\n *\n * <p>Primarily intended for use within the framework.\n *\n * @author Sam Brannen\n * @author Anatoliy Korovin\n * @author Phillip Webb\n * @since 4.1\n * @see TestPropertySource\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "signature": "public class TestPropertySourceUtils",
    "source_code": "public abstract class TestPropertySourceUtils {\n\n\t/**\n\t * The name of the {@link MapPropertySource} created from <em>inlined properties</em>.\n\t * @since 4.1.5\n\t * @see #addInlinedPropertiesToEnvironment\n\t */\n\tpublic static final String INLINED_PROPERTIES_PROPERTY_SOURCE_NAME = \"Inlined Test Properties\";\n\n\tprivate static final PropertySourceFactory defaultPropertySourceFactory = new DefaultPropertySourceFactory();\n\n\tprivate static final Comparator<MergedAnnotation<? extends Annotation>> reversedMetaDistance =\n\t\t\tComparator.<MergedAnnotation<? extends Annotation>> comparingInt(MergedAnnotation::getDistance).reversed();\n\n\tprivate static final Log logger = LogFactory.getLog(TestPropertySourceUtils.class);\n\n\n\tstatic MergedTestPropertySources buildMergedTestPropertySources(Class<?> testClass) {\n\t\tList<TestPropertySourceAttributes> attributesList = new ArrayList<>();\n\n\t\tTestPropertySourceAttributes previousAttributes = null;\n\t\t// Iterate over all aggregate levels, where each level is represented by\n\t\t// a list of merged annotations found at that level (e.g., on a test\n\t\t// class in the class hierarchy).\n\t\tfor (List<MergedAnnotation<TestPropertySource>> aggregatedAnnotations :\n\t\t\t\tfindRepeatableAnnotations(testClass, TestPropertySource.class)) {\n\n\t\t\t// Convert all the merged annotations for the current aggregate\n\t\t\t// level to a list of TestPropertySourceAttributes.\n\t\t\tList<TestPropertySourceAttributes> aggregatedAttributesList =\n\t\t\t\t\taggregatedAnnotations.stream().map(TestPropertySourceAttributes::new).toList();\n\t\t\t// Merge all TestPropertySourceAttributes instances for the current\n\t\t\t// aggregate level into a single TestPropertySourceAttributes instance.\n\t\t\tTestPropertySourceAttributes mergedAttributes = mergeTestPropertySourceAttributes(aggregatedAttributesList);\n\t\t\tif (mergedAttributes != null) {\n\t\t\t\tif (!duplicationDetected(mergedAttributes, previousAttributes)) {\n\t\t\t\t\tattributesList.add(mergedAttributes);\n\t\t\t\t}\n\t\t\t\tpreviousAttributes = mergedAttributes;\n\t\t\t}\n\t\t}\n\n\t\tif (attributesList.isEmpty()) {\n\t\t\treturn MergedTestPropertySources.empty();\n\t\t}\n\t\treturn new MergedTestPropertySources(mergeLocations(attributesList), mergeProperties(attributesList));\n\t}\n\n\t@Nullable\n\tprivate static TestPropertySourceAttributes mergeTestPropertySourceAttributes(\n\t\t\tList<TestPropertySourceAttributes> aggregatedAttributesList) {\n\n\t\tTestPropertySourceAttributes mergedAttributes = null;\n\t\tTestPropertySourceAttributes previousAttributes = null;\n\t\tfor (TestPropertySourceAttributes currentAttributes : aggregatedAttributesList) {\n\t\t\tif (mergedAttributes == null) {\n\t\t\t\tmergedAttributes = currentAttributes;\n\t\t\t}\n\t\t\telse if (!duplicationDetected(currentAttributes, previousAttributes)) {\n\t\t\t\tmergedAttributes.mergeWith(currentAttributes);\n\t\t\t}\n\t\t\tpreviousAttributes = currentAttributes;\n\t\t}\n\n\t\treturn mergedAttributes;\n\t}\n\n\tprivate static boolean duplicationDetected(TestPropertySourceAttributes currentAttributes,\n\t\t\t@Nullable TestPropertySourceAttributes previousAttributes) {\n\n\t\tboolean duplicationDetected =\n\t\t\t\t(currentAttributes.equals(previousAttributes) && !currentAttributes.isEmpty());\n\n\t\tif (duplicationDetected && logger.isTraceEnabled()) {\n\t\t\tlogger.trace(String.format(\"Ignoring duplicate %s declaration on %s since it is also declared on %s\",\n\t\t\t\t\tcurrentAttributes, currentAttributes.getDeclaringClass().getName(),\n\t\t\t\t\tpreviousAttributes.getDeclaringClass().getName()));\n\t\t}\n\n\t\treturn duplicationDetected;\n\t}\n\n\tprivate static List<PropertySourceDescriptor> mergeLocations(List<TestPropertySourceAttributes> attributesList) {\n\t\tList<PropertySourceDescriptor> descriptors = new ArrayList<>();\n\t\tfor (TestPropertySourceAttributes attrs : attributesList) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Processing locations for \" + attrs);\n\t\t\t}\n\t\t\tdescriptors.addAll(0, attrs.getPropertySourceDescriptors());\n\t\t\tif (!attrs.isInheritLocations()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn descriptors;\n\t}\n\n\tprivate static String[] mergeProperties(List<TestPropertySourceAttributes> attributesList) {\n\t\tList<String> properties = new ArrayList<>();\n\t\tfor (TestPropertySourceAttributes attrs : attributesList) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Processing inlined properties for \" + attrs);\n\t\t\t}\n\t\t\tString[] attrProps = attrs.getProperties();\n\t\t\tproperties.addAll(0, Arrays.asList(attrProps));\n\t\t\tif (!attrs.isInheritProperties()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn StringUtils.toStringArray(properties);\n\t}\n\n\t/**\n\t * Add the {@link Properties} files from the given resource {@code locations}\n\t * to the {@link Environment} of the supplied {@code context}.\n\t * <p>This method delegates to\n\t * {@link #addPropertiesFilesToEnvironment(ConfigurableEnvironment, ResourceLoader, String...)}.\n\t * @param context the application context whose environment should be updated;\n\t * never {@code null}\n\t * @param locations the resource locations of {@code Properties} files to add\n\t * to the environment; potentially empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing a properties file\n\t * @since 4.1.5\n\t * @see org.springframework.core.io.support.ResourcePropertySource\n\t * @see TestPropertySource#locations\n\t * @see #addPropertiesFilesToEnvironment(ConfigurableEnvironment, ResourceLoader, String...)\n\t * @see #addPropertySourcesToEnvironment(ConfigurableApplicationContext, List)\n\t */\n\tpublic static void addPropertiesFilesToEnvironment(ConfigurableApplicationContext context, String... locations) {\n\t\tAssert.notNull(context, \"'context' must not be null\");\n\t\tAssert.notNull(locations, \"'locations' must not be null\");\n\t\taddPropertiesFilesToEnvironment(context.getEnvironment(), context, locations);\n\t}\n\n\t/**\n\t * Add the {@link Properties} files from the given resource {@code locations}\n\t * to the supplied {@link ConfigurableEnvironment environment}.\n\t * <p>Property placeholders in resource locations (i.e., <code>${...}</code>)\n\t * will be {@linkplain Environment#resolveRequiredPlaceholders(String) resolved}\n\t * against the {@code Environment}.\n\t * <p>A {@link ResourcePatternResolver} will be used to resolve resource\n\t * location patterns into multiple resource locations.\n\t * <p>Each properties file will be converted to a\n\t * {@link org.springframework.core.io.support.ResourcePropertySource ResourcePropertySource}\n\t * that will be added to the {@link PropertySources} of the environment with\n\t * the highest precedence.\n\t * @param environment the environment to update; never {@code null}\n\t * @param resourceLoader the {@code ResourceLoader} to use to load each resource;\n\t * never {@code null}\n\t * @param locations the resource locations of {@code Properties} files to add\n\t * to the environment; potentially empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing a properties file\n\t * @since 4.3\n\t * @see org.springframework.core.io.support.ResourcePropertySource\n\t * @see TestPropertySource#locations\n\t * @see #addPropertiesFilesToEnvironment(ConfigurableApplicationContext, String...)\n\t * @see #addPropertySourcesToEnvironment(ConfigurableApplicationContext, List)\n\t */\n\tpublic static void addPropertiesFilesToEnvironment(ConfigurableEnvironment environment,\n\t\t\tResourceLoader resourceLoader, String... locations) {\n\n\t\tAssert.notNull(locations, \"'locations' must not be null\");\n\t\taddPropertySourcesToEnvironment(environment, resourceLoader,\n\t\t\t\tList.of(new PropertySourceDescriptor(locations)));\n\t}\n\n\t/**\n\t * Add property sources for the given {@code descriptors} to the\n\t * {@link Environment} of the supplied {@code context}.\n\t * <p>This method delegates to\n\t * {@link #addPropertySourcesToEnvironment(ConfigurableEnvironment, ResourceLoader, List)}.\n\t * @param context the application context whose environment should be updated;\n\t * never {@code null}\n\t * @param descriptors the property source descriptors to process; potentially\n\t * empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing the\n\t * descriptors and registering property sources\n\t * @since 6.1\n\t * @see TestPropertySource#locations\n\t * @see TestPropertySource#encoding\n\t * @see TestPropertySource#factory\n\t * @see PropertySourceFactory\n\t * @see #addPropertySourcesToEnvironment(ConfigurableEnvironment, ResourceLoader, List)\n\t */\n\tpublic static void addPropertySourcesToEnvironment(ConfigurableApplicationContext context,\n\t\t\tList<PropertySourceDescriptor> descriptors) {\n\n\t\tAssert.notNull(context, \"'context' must not be null\");\n\t\tAssert.notNull(descriptors, \"'descriptors' must not be null\");\n\t\taddPropertySourcesToEnvironment(context.getEnvironment(), context, descriptors);\n\t}\n\n\t/**\n\t * Add property sources for the given {@code descriptors} to the supplied\n\t * {@link ConfigurableEnvironment environment}.\n\t * <p>Property placeholders in resource locations (i.e., <code>${...}</code>)\n\t * will be {@linkplain Environment#resolveRequiredPlaceholders(String) resolved}\n\t * against the {@code Environment}.\n\t * <p>A {@link ResourcePatternResolver} will be used to resolve resource\n\t * location patterns into multiple resource locations.\n\t * <p>Each {@link PropertySource} will be created via the configured\n\t * {@link PropertySourceDescriptor#propertySourceFactory() PropertySourceFactory}\n\t * (or the {@link DefaultPropertySourceFactory} if no factory is configured)\n\t * and added to the {@link PropertySources} of the environment with the highest\n\t * precedence.\n\t * @param environment the environment to update; never {@code null}\n\t * @param resourceLoader the {@code ResourceLoader} to use to load resources;\n\t * never {@code null}\n\t * @param descriptors the property source descriptors to process; potentially\n\t * empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing the\n\t * descriptors and registering property sources\n\t * @since 6.1\n\t * @see TestPropertySource#locations\n\t * @see TestPropertySource#encoding\n\t * @see TestPropertySource#factory\n\t * @see PropertySourceFactory\n\t */\n\tpublic static void addPropertySourcesToEnvironment(ConfigurableEnvironment environment,\n\t\t\tResourceLoader resourceLoader, List<PropertySourceDescriptor> descriptors) {\n\n\t\tAssert.notNull(environment, \"'environment' must not be null\");\n\t\tAssert.notNull(resourceLoader, \"'resourceLoader' must not be null\");\n\t\tAssert.notNull(descriptors, \"'descriptors' must not be null\");\n\t\tResourcePatternResolver resourcePatternResolver =\n\t\t\t\tResourcePatternUtils.getResourcePatternResolver(resourceLoader);\n\t\tMutablePropertySources propertySources = environment.getPropertySources();\n\t\ttry {\n\t\t\tfor (PropertySourceDescriptor descriptor : descriptors) {\n\t\t\t\tif (!descriptor.locations().isEmpty()) {\n\t\t\t\t\tClass<? extends PropertySourceFactory> factoryClass = descriptor.propertySourceFactory();\n\t\t\t\t\tPropertySourceFactory factory = (factoryClass != null ?\n\t\t\t\t\t\t\tBeanUtils.instantiateClass(factoryClass) : defaultPropertySourceFactory);\n\n\t\t\t\t\tfor (String location : descriptor.locations()) {\n\t\t\t\t\t\tString resolvedLocation = environment.resolveRequiredPlaceholders(location);\n\t\t\t\t\t\tfor (Resource resource : resourcePatternResolver.getResources(resolvedLocation)) {\n\t\t\t\t\t\t\tPropertySource<?> propertySource = factory.createPropertySource(descriptor.name(),\n\t\t\t\t\t\t\t\t\tnew EncodedResource(resource, descriptor.encoding()));\n\t\t\t\t\t\t\tpropertySources.addFirst(propertySource);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new IllegalStateException(\"Failed to add PropertySource to Environment\", ex);\n\t\t}\n\t}\n\n\t/**\n\t * Add the given <em>inlined properties</em> to the {@link Environment} of the\n\t * supplied {@code context}.\n\t * <p>This method simply delegates to\n\t * {@link #addInlinedPropertiesToEnvironment(ConfigurableEnvironment, String[])}.\n\t * @param context the application context whose environment should be updated;\n\t * never {@code null}\n\t * @param inlinedProperties the inlined properties to add to the environment;\n\t * potentially empty but never {@code null}\n\t * @since 4.1.5\n\t * @see TestPropertySource#properties\n\t * @see #addInlinedPropertiesToEnvironment(ConfigurableEnvironment, String[])\n\t */\n\tpublic static void addInlinedPropertiesToEnvironment(ConfigurableApplicationContext context, String... inlinedProperties) {\n\t\tAssert.notNull(context, \"'context' must not be null\");\n\t\tAssert.notNull(inlinedProperties, \"'inlinedProperties' must not be null\");\n\t\taddInlinedPropertiesToEnvironment(context.getEnvironment(), inlinedProperties);\n\t}\n\n\t/**\n\t * Add the given <em>inlined properties</em> (in the form of <em>key-value</em>\n\t * pairs) to the supplied {@link ConfigurableEnvironment environment}.\n\t * <p>All key-value pairs will be added to the {@code Environment} as a\n\t * single {@link MapPropertySource} with the highest precedence.\n\t * <p>For details on the parsing of <em>inlined properties</em>, consult the\n\t * Javadoc for {@link #convertInlinedPropertiesToMap}.\n\t * @param environment the environment to update; never {@code null}\n\t * @param inlinedProperties the inlined properties to add to the environment;\n\t * potentially empty but never {@code null}\n\t * @since 4.1.5\n\t * @see MapPropertySource\n\t * @see #INLINED_PROPERTIES_PROPERTY_SOURCE_NAME\n\t * @see TestPropertySource#properties\n\t * @see #convertInlinedPropertiesToMap\n\t */\n\tpublic static void addInlinedPropertiesToEnvironment(ConfigurableEnvironment environment, String... inlinedProperties) {\n\t\tAssert.notNull(environment, \"'environment' must not be null\");\n\t\tAssert.notNull(inlinedProperties, \"'inlinedProperties' must not be null\");\n\t\tif (!ObjectUtils.isEmpty(inlinedProperties)) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Adding inlined properties to environment: \" +\n\t\t\t\t\t\tObjectUtils.nullSafeToString(inlinedProperties));\n\t\t\t}\n\t\t\tMapPropertySource ps = (MapPropertySource)\n\t\t\t\t\tenvironment.getPropertySources().get(INLINED_PROPERTIES_PROPERTY_SOURCE_NAME);\n\t\t\tif (ps == null) {\n\t\t\t\tps = new MapPropertySource(INLINED_PROPERTIES_PROPERTY_SOURCE_NAME, new LinkedHashMap<>());\n\t\t\t\tenvironment.getPropertySources().addFirst(ps);\n\t\t\t}\n\t\t\tps.getSource().putAll(convertInlinedPropertiesToMap(inlinedProperties));\n\t\t}\n\t}\n\n\t/**\n\t * Convert the supplied <em>inlined properties</em> (in the form of <em>key-value</em>\n\t * pairs) into a map keyed by property name.\n\t * <p>Parsing of the key-value pairs is achieved by converting all supplied\n\t * strings into <em>virtual</em> properties files in memory and delegating to\n\t * {@link Properties#load(java.io.Reader)} to parse each virtual file.\n\t * <p>The ordering of property names will be preserved in the returned map,\n\t * analogous to the order in which the key-value pairs are supplied to this\n\t * method. This also applies if a single string contains multiple key-value\n\t * pairs separated by newlines &mdash; for example, when supplied by a user\n\t * via a <em>text block</em>.\n\t * <p>For a full discussion of <em>inlined properties</em>, consult the Javadoc\n\t * for {@link TestPropertySource#properties}.\n\t * @param inlinedProperties the inlined properties to convert; potentially empty\n\t * but never {@code null}\n\t * @return a new, ordered map containing the converted properties\n\t * @throws IllegalStateException if a given key-value pair cannot be parsed\n\t * @since 4.1.5\n\t * @see #addInlinedPropertiesToEnvironment(ConfigurableEnvironment, String[])\n\t */\n\tpublic static Map<String, Object> convertInlinedPropertiesToMap(String... inlinedProperties) {\n\t\tAssert.notNull(inlinedProperties, \"'inlinedProperties' must not be null\");\n\n\t\tSequencedProperties sequencedProperties = new SequencedProperties();\n\t\tfor (String input : inlinedProperties) {\n\t\t\tif (!StringUtils.hasText(input)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tsequencedProperties.load(new StringReader(input));\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new IllegalStateException(\"Failed to load test environment properties from [\" + input + \"]\", ex);\n\t\t\t}\n\t\t}\n\t\treturn sequencedProperties.getSequencedMap();\n\t}\n\n\tprivate static <T extends Annotation> List<List<MergedAnnotation<T>>> findRepeatableAnnotations(\n\t\t\tClass<?> clazz, Class<T> annotationType) {\n\n\t\tList<List<MergedAnnotation<T>>> listOfLists = new ArrayList<>();\n\t\tfindRepeatableAnnotations(clazz, annotationType, listOfLists, new int[] {0});\n\t\treturn listOfLists;\n\t}\n\n\tprivate static <T extends Annotation> void findRepeatableAnnotations(\n\t\t\tClass<?> clazz, Class<T> annotationType, List<List<MergedAnnotation<T>>> listOfLists, int[] aggregateIndex) {\n\n\t\t// Ensure we have a list for the current aggregate index.\n\t\tif (listOfLists.size() < aggregateIndex[0] + 1) {\n\t\t\tlistOfLists.add(new ArrayList<>());\n\t\t}\n\n\t\tMergedAnnotations.from(clazz, SearchStrategy.DIRECT)\n\t\t\t.stream(annotationType)\n\t\t\t.sorted(reversedMetaDistance)\n\t\t\t.forEach(annotation -> listOfLists.get(aggregateIndex[0]).add(0, annotation));\n\n\t\taggregateIndex[0]++;\n\n\t\t// Declared on an interface?\n\t\tfor (Class<?> ifc : clazz.getInterfaces()) {\n\t\t\tfindRepeatableAnnotations(ifc, annotationType, listOfLists, aggregateIndex);\n\t\t}\n\n\t\t// Declared on a superclass?\n\t\tClass<?> superclass = clazz.getSuperclass();\n\t\tif (superclass != null & superclass != Object.class) {\n\t\t\tfindRepeatableAnnotations(superclass, annotationType, listOfLists, aggregateIndex);\n\t\t}\n\n\t\t// Declared on an enclosing class of an inner class?\n\t\tif (TestContextAnnotationUtils.searchEnclosingClass(clazz)) {\n\t\t\tfindRepeatableAnnotations(clazz.getEnclosingClass(), annotationType, listOfLists, aggregateIndex);\n\t\t}\n\t}\n\n\t/**\n\t * Extension of {@link Properties} that mimics a {@code SequencedMap} by tracking\n\t * all added properties with a {@link String} key in a {@link LinkedHashMap}.\n\t * @since 6.1\n\t */\n\t@SuppressWarnings(\"serial\")\n\tprivate static class SequencedProperties extends Properties {\n\n\t\tprivate final LinkedHashMap<String, Object> map = new LinkedHashMap<>();\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Object put(Object key, Object value) {\n\t\t\tif (key instanceof String str) {\n\t\t\t\treturn this.map.put(str, value);\n\t\t\t}\n\t\t\t// No need to invoke super.put(key, value);\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic Map<String, Object> getSequencedMap() {\n\t\t\treturn this.map;\n\t\t}\n\n\t}\n\n}"
  },
  "org.springframework.test.context.support.TestPropertySourceUtils#addInlinedPropertiesToEnvironment(context,inlinedProperties)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given <em>inlined properties</em> to the {@link Environment} of the\n\t * supplied {@code context}.\n\t * <p>This method simply delegates to\n\t * {@link #addInlinedPropertiesToEnvironment(ConfigurableEnvironment, String[])}.\n\t * @param context the application context whose environment should be updated;\n\t * never {@code null}\n\t * @param inlinedProperties the inlined properties to add to the environment;\n\t * potentially empty but never {@code null}\n\t * @since 4.1.5\n\t * @see TestPropertySource#properties\n\t * @see #addInlinedPropertiesToEnvironment(ConfigurableEnvironment, String[])\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "inlinedProperties"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "void",
    "signature": "public void addInlinedPropertiesToEnvironment(ConfigurableApplicationContext context, String... inlinedProperties)",
    "source_code": "\tpublic static void addInlinedPropertiesToEnvironment(ConfigurableApplicationContext context, String... inlinedProperties) {\n\t\tAssert.notNull(context, \"'context' must not be null\");\n\t\tAssert.notNull(inlinedProperties, \"'inlinedProperties' must not be null\");\n\t\taddInlinedPropertiesToEnvironment(context.getEnvironment(), inlinedProperties);\n\t}"
  },
  "org.springframework.test.context.support.TestPropertySourceUtils#addInlinedPropertiesToEnvironment(environment,inlinedProperties)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given <em>inlined properties</em> (in the form of <em>key-value</em>\n\t * pairs) to the supplied {@link ConfigurableEnvironment environment}.\n\t * <p>All key-value pairs will be added to the {@code Environment} as a\n\t * single {@link MapPropertySource} with the highest precedence.\n\t * <p>For details on the parsing of <em>inlined properties</em>, consult the\n\t * Javadoc for {@link #convertInlinedPropertiesToMap}.\n\t * @param environment the environment to update; never {@code null}\n\t * @param inlinedProperties the inlined properties to add to the environment;\n\t * potentially empty but never {@code null}\n\t * @since 4.1.5\n\t * @see MapPropertySource\n\t * @see #INLINED_PROPERTIES_PROPERTY_SOURCE_NAME\n\t * @see TestPropertySource#properties\n\t * @see #convertInlinedPropertiesToMap\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "environment",
      "inlinedProperties"
    ],
    "position": {
      "column": 1,
      "line": 355
    },
    "return": "void",
    "signature": "public void addInlinedPropertiesToEnvironment(ConfigurableEnvironment environment, String... inlinedProperties)",
    "source_code": "\tpublic static void addInlinedPropertiesToEnvironment(ConfigurableEnvironment environment, String... inlinedProperties) {\n\t\tAssert.notNull(environment, \"'environment' must not be null\");\n\t\tAssert.notNull(inlinedProperties, \"'inlinedProperties' must not be null\");\n\t\tif (!ObjectUtils.isEmpty(inlinedProperties)) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Adding inlined properties to environment: \" +\n\t\t\t\t\t\tObjectUtils.nullSafeToString(inlinedProperties));\n\t\t\t}\n\t\t\tMapPropertySource ps = (MapPropertySource)\n\t\t\t\t\tenvironment.getPropertySources().get(INLINED_PROPERTIES_PROPERTY_SOURCE_NAME);\n\t\t\tif (ps == null) {\n\t\t\t\tps = new MapPropertySource(INLINED_PROPERTIES_PROPERTY_SOURCE_NAME, new LinkedHashMap<>());\n\t\t\t\tenvironment.getPropertySources().addFirst(ps);\n\t\t\t}\n\t\t\tps.getSource().putAll(convertInlinedPropertiesToMap(inlinedProperties));\n\t\t}\n\t}"
  },
  "org.springframework.test.context.support.TestPropertySourceUtils#addPropertiesFilesToEnvironment(context,locations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the {@link Properties} files from the given resource {@code locations}\n\t * to the {@link Environment} of the supplied {@code context}.\n\t * <p>This method delegates to\n\t * {@link #addPropertiesFilesToEnvironment(ConfigurableEnvironment, ResourceLoader, String...)}.\n\t * @param context the application context whose environment should be updated;\n\t * never {@code null}\n\t * @param locations the resource locations of {@code Properties} files to add\n\t * to the environment; potentially empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing a properties file\n\t * @since 4.1.5\n\t * @see org.springframework.core.io.support.ResourcePropertySource\n\t * @see TestPropertySource#locations\n\t * @see #addPropertiesFilesToEnvironment(ConfigurableEnvironment, ResourceLoader, String...)\n\t * @see #addPropertySourcesToEnvironment(ConfigurableApplicationContext, List)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "locations"
    ],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "void",
    "signature": "public void addPropertiesFilesToEnvironment(ConfigurableApplicationContext context, String... locations)",
    "source_code": "\tpublic static void addPropertiesFilesToEnvironment(ConfigurableApplicationContext context, String... locations) {\n\t\tAssert.notNull(context, \"'context' must not be null\");\n\t\tAssert.notNull(locations, \"'locations' must not be null\");\n\t\taddPropertiesFilesToEnvironment(context.getEnvironment(), context, locations);\n\t}"
  },
  "org.springframework.test.context.support.TestPropertySourceUtils#addPropertiesFilesToEnvironment(environment,resourceLoader,locations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the {@link Properties} files from the given resource {@code locations}\n\t * to the supplied {@link ConfigurableEnvironment environment}.\n\t * <p>Property placeholders in resource locations (i.e., <code>${...}</code>)\n\t * will be {@linkplain Environment#resolveRequiredPlaceholders(String) resolved}\n\t * against the {@code Environment}.\n\t * <p>A {@link ResourcePatternResolver} will be used to resolve resource\n\t * location patterns into multiple resource locations.\n\t * <p>Each properties file will be converted to a\n\t * {@link org.springframework.core.io.support.ResourcePropertySource ResourcePropertySource}\n\t * that will be added to the {@link PropertySources} of the environment with\n\t * the highest precedence.\n\t * @param environment the environment to update; never {@code null}\n\t * @param resourceLoader the {@code ResourceLoader} to use to load each resource;\n\t * never {@code null}\n\t * @param locations the resource locations of {@code Properties} files to add\n\t * to the environment; potentially empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing a properties file\n\t * @since 4.3\n\t * @see org.springframework.core.io.support.ResourcePropertySource\n\t * @see TestPropertySource#locations\n\t * @see #addPropertiesFilesToEnvironment(ConfigurableApplicationContext, String...)\n\t * @see #addPropertySourcesToEnvironment(ConfigurableApplicationContext, List)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "environment",
      "resourceLoader",
      "locations"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "void",
    "signature": "public void addPropertiesFilesToEnvironment(ConfigurableEnvironment environment,\n\t\t\tResourceLoader resourceLoader, String... locations)",
    "source_code": "\tpublic static void addPropertiesFilesToEnvironment(ConfigurableEnvironment environment,"
  },
  "org.springframework.test.context.support.TestPropertySourceUtils#addPropertySourcesToEnvironment(context,descriptors)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add property sources for the given {@code descriptors} to the\n\t * {@link Environment} of the supplied {@code context}.\n\t * <p>This method delegates to\n\t * {@link #addPropertySourcesToEnvironment(ConfigurableEnvironment, ResourceLoader, List)}.\n\t * @param context the application context whose environment should be updated;\n\t * never {@code null}\n\t * @param descriptors the property source descriptors to process; potentially\n\t * empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing the\n\t * descriptors and registering property sources\n\t * @since 6.1\n\t * @see TestPropertySource#locations\n\t * @see TestPropertySource#encoding\n\t * @see TestPropertySource#factory\n\t * @see PropertySourceFactory\n\t * @see #addPropertySourcesToEnvironment(ConfigurableEnvironment, ResourceLoader, List)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "descriptors"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "void",
    "signature": "public void addPropertySourcesToEnvironment(ConfigurableApplicationContext context,\n\t\t\tList<PropertySourceDescriptor> descriptors)",
    "source_code": "\tpublic static void addPropertySourcesToEnvironment(ConfigurableApplicationContext context,"
  },
  "org.springframework.test.context.support.TestPropertySourceUtils#addPropertySourcesToEnvironment(environment,resourceLoader,descriptors)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add property sources for the given {@code descriptors} to the supplied\n\t * {@link ConfigurableEnvironment environment}.\n\t * <p>Property placeholders in resource locations (i.e., <code>${...}</code>)\n\t * will be {@linkplain Environment#resolveRequiredPlaceholders(String) resolved}\n\t * against the {@code Environment}.\n\t * <p>A {@link ResourcePatternResolver} will be used to resolve resource\n\t * location patterns into multiple resource locations.\n\t * <p>Each {@link PropertySource} will be created via the configured\n\t * {@link PropertySourceDescriptor#propertySourceFactory() PropertySourceFactory}\n\t * (or the {@link DefaultPropertySourceFactory} if no factory is configured)\n\t * and added to the {@link PropertySources} of the environment with the highest\n\t * precedence.\n\t * @param environment the environment to update; never {@code null}\n\t * @param resourceLoader the {@code ResourceLoader} to use to load resources;\n\t * never {@code null}\n\t * @param descriptors the property source descriptors to process; potentially\n\t * empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing the\n\t * descriptors and registering property sources\n\t * @since 6.1\n\t * @see TestPropertySource#locations\n\t * @see TestPropertySource#encoding\n\t * @see TestPropertySource#factory\n\t * @see PropertySourceFactory\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "environment",
      "resourceLoader",
      "descriptors"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "void",
    "signature": "public void addPropertySourcesToEnvironment(ConfigurableEnvironment environment,\n\t\t\tResourceLoader resourceLoader, List<PropertySourceDescriptor> descriptors)",
    "source_code": "\tpublic static void addPropertySourcesToEnvironment(ConfigurableEnvironment environment,"
  },
  "org.springframework.test.context.support.TestPropertySourceUtils#convertInlinedPropertiesToMap(inlinedProperties)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the supplied <em>inlined properties</em> (in the form of <em>key-value</em>\n\t * pairs) into a map keyed by property name.\n\t * <p>Parsing of the key-value pairs is achieved by converting all supplied\n\t * strings into <em>virtual</em> properties files in memory and delegating to\n\t * {@link Properties#load(java.io.Reader)} to parse each virtual file.\n\t * <p>The ordering of property names will be preserved in the returned map,\n\t * analogous to the order in which the key-value pairs are supplied to this\n\t * method. This also applies if a single string contains multiple key-value\n\t * pairs separated by newlines &mdash; for example, when supplied by a user\n\t * via a <em>text block</em>.\n\t * <p>For a full discussion of <em>inlined properties</em>, consult the Javadoc\n\t * for {@link TestPropertySource#properties}.\n\t * @param inlinedProperties the inlined properties to convert; potentially empty\n\t * but never {@code null}\n\t * @return a new, ordered map containing the converted properties\n\t * @throws IllegalStateException if a given key-value pair cannot be parsed\n\t * @since 4.1.5\n\t * @see #addInlinedPropertiesToEnvironment(ConfigurableEnvironment, String[])\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inlinedProperties"
    ],
    "position": {
      "column": 1,
      "line": 393
    },
    "return": "Object>",
    "signature": "public Object> convertInlinedPropertiesToMap(String... inlinedProperties)",
    "source_code": "\tpublic static Map<String, Object> convertInlinedPropertiesToMap(String... inlinedProperties) {\n\t\tAssert.notNull(inlinedProperties, \"'inlinedProperties' must not be null\");\n\n\t\tSequencedProperties sequencedProperties = new SequencedProperties();\n\t\tfor (String input : inlinedProperties) {\n\t\t\tif (!StringUtils.hasText(input)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tsequencedProperties.load(new StringReader(input));\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new IllegalStateException(\"Failed to load test environment properties from [\" + input + \"]\", ex);\n\t\t\t}\n\t\t}\n\t\treturn sequencedProperties.getSequencedMap();\n\t}"
  },
  "org.springframework.test.context.support.TestPropertySourceUtils#getSequencedMap()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 471
    },
    "return": "Object>",
    "signature": "public Object> getSequencedMap()",
    "source_code": "\t\tpublic Map<String, Object> getSequencedMap() {\n\t\t\treturn this.map;\n\t\t}"
  },
  "org.springframework.test.context.support.TestPropertySourceUtils#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 463
    },
    "return": "Object",
    "signature": "public Object put(Object key, Object value)",
    "source_code": "\t\tpublic Object put(Object key, Object value) {\n\t\t\tif (key instanceof String str) {\n\t\t\t\treturn this.map.put(str, value);\n\t\t\t}\n\t\t\t// No need to invoke super.put(key, value);\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.test.context.transaction.TestContextTransactionUtils#createDelegatingTransactionAttribute(testContext,targetAttribute,includeMethodName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a delegating {@link TransactionAttribute} for the supplied target\n\t * {@link TransactionAttribute} and {@link TestContext}, using the names of\n\t * the test class and test method (if requested) to build the name of the\n\t * transaction.\n\t * @param testContext the {@code TestContext} upon which to base the name\n\t * @param targetAttribute the {@code TransactionAttribute} to delegate to\n\t * @param includeMethodName {@code true} if the test method's name should be\n\t * included in the name of the transaction\n\t * @return the delegating {@code TransactionAttribute}\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext",
      "targetAttribute",
      "includeMethodName"
    ],
    "position": {
      "column": 1,
      "line": 253
    },
    "return": "TransactionAttribute",
    "signature": "public TransactionAttribute createDelegatingTransactionAttribute(TestContext testContext, TransactionAttribute targetAttribute, boolean includeMethodName)",
    "source_code": "\tpublic static TransactionAttribute createDelegatingTransactionAttribute("
  },
  "org.springframework.test.web.reactive.server.<unknown>#configureBlockingExecution(configurer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "configurer"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "void",
    "signature": "public void configureBlockingExecution(BlockingExecutionConfigurer configurer)",
    "source_code": "\t\tpublic void configureBlockingExecution(BlockingExecutionConfigurer configurer) {\n\t\t\tif (this.executionConsumer != null) {\n\t\t\t\tthis.executionConsumer.accept(configurer);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.ExchangeResult#getRawStatusCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the HTTP status code as an integer.\n\t * @since 5.1.10\n\t * @deprecated as of 6.0, in favor of {@link #getStatus()}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "int",
    "signature": "public int getRawStatusCode()",
    "source_code": "\tpublic int getRawStatusCode() {\n\t\treturn getStatus().value();\n\t}"
  },
  "org.springframework.test.web.servlet.client.MockMvcHttpConnector#with(postProcessors)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new instance that applies the given {@link RequestPostProcessor}s\n\t * to performed requests.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "postProcessors"
    ],
    "position": {
      "column": 1,
      "line": 226
    },
    "return": "MockMvcHttpConnector",
    "signature": "public MockMvcHttpConnector with(List<RequestPostProcessor> postProcessors)",
    "source_code": "\tpublic MockMvcHttpConnector with(List<RequestPostProcessor> postProcessors) {\n\t\treturn new MockMvcHttpConnector(this.mockMvc, postProcessors);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.AbstractMockMvcBuilder#addFilter(filter,filterName,Map<String,initParams,dispatcherTypes,urlPatterns)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "filter",
      "filterName",
      "Map<String",
      "initParams",
      "dispatcherTypes",
      "urlPatterns"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "T",
    "signature": "public T addFilter(Filter filter, @Nullable String filterName, Map<String, String> initParams,\n\t\t\tEnumSet<DispatcherType> dispatcherTypes, String... urlPatterns)",
    "source_code": "\tpublic <T extends B> T addFilter("
  },
  "org.springframework.transaction.event.<unknown>#afterCompletion(status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> afterCompletion(int status)",
    "source_code": "\t\tpublic Mono<Void> afterCompletion(int status) {\n\t\t\tTransactionPhase phase = getTransactionPhase();\n\t\t\tif (phase == TransactionPhase.AFTER_COMMIT && status == STATUS_COMMITTED) {\n\t\t\t\treturn Mono.fromRunnable(this::processEventWithCallbacks);\n\t\t\t}\n\t\t\telse if (phase == TransactionPhase.AFTER_ROLLBACK && status == STATUS_ROLLED_BACK) {\n\t\t\t\treturn Mono.fromRunnable(this::processEventWithCallbacks);\n\t\t\t}\n\t\t\telse if (phase == TransactionPhase.AFTER_COMPLETION) {\n\t\t\t\treturn Mono.fromRunnable(this::processEventWithCallbacks);\n\t\t\t}\n\t\t\treturn Mono.empty();\n\t\t}"
  },
  "org.springframework.transaction.event.<unknown>#beforeCommit(readOnly)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "readOnly"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> beforeCommit(boolean readOnly)",
    "source_code": "\t\tpublic Mono<Void> beforeCommit(boolean readOnly) {\n\t\t\tif (getTransactionPhase() == TransactionPhase.BEFORE_COMMIT) {\n\t\t\t\treturn Mono.fromRunnable(this::processEventWithCallbacks);\n\t\t\t}\n\t\t\treturn Mono.empty();\n\t\t}"
  },
  "org.springframework.transaction.event.<unknown>#getOrder()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 54
    },
    "return": "int",
    "signature": "public int getOrder()",
    "source_code": "\tpublic int getOrder() {\n\t\treturn this.listener.getOrder();\n\t}"
  },
  "org.springframework.transaction.event.<unknown>#getTransactionPhase()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "TransactionPhase",
    "signature": "public TransactionPhase getTransactionPhase()",
    "source_code": "\tpublic TransactionPhase getTransactionPhase() {\n\t\treturn this.listener.getTransactionPhase();\n\t}"
  },
  "org.springframework.transaction.event.<unknown>#processEventWithCallbacks()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "void",
    "signature": "public void processEventWithCallbacks()",
    "source_code": "\tpublic void processEventWithCallbacks() {\n\t\tthis.callbacks.forEach(callback -> callback.preProcessEvent(this.event));\n\t\ttry {\n\t\t\tthis.listener.processEvent(this.event);\n\t\t}\n\t\tcatch (RuntimeException | Error ex) {\n\t\t\tthis.callbacks.forEach(callback -> callback.postProcessEvent(this.event, ex));\n\t\t\tthrow ex;\n\t\t}\n\t\tthis.callbacks.forEach(callback -> callback.postProcessEvent(this.event, null));\n\t}"
  },
  "org.springframework.transaction.event.<unknown>#register(event,listener,callbacks)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "event",
      "listener",
      "callbacks"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "boolean",
    "signature": "public boolean register(E event, TransactionalApplicationListener<E> listener,\n\t\t\tList<TransactionalApplicationListener.SynchronizationCallback> callbacks)",
    "source_code": "\tpublic static <E extends ApplicationEvent> boolean register("
  },
  "org.springframework.transaction.jta.JtaAfterCompletionSynchronization": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Adapter for a JTA Synchronization, invoking the {@code afterCommit} /\n * {@code afterCompletion} callbacks of Spring {@link TransactionSynchronization}\n * objects callbacks after the outer JTA transaction has completed.\n * Applied when participating in an existing (non-Spring) JTA transaction.\n *\n * @author Juergen Hoeller\n * @since 2.0\n * @see TransactionSynchronization#afterCommit\n * @see TransactionSynchronization#afterCompletion\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "signature": "public class JtaAfterCompletionSynchronization",
    "source_code": "public class JtaAfterCompletionSynchronization implements Synchronization {\n\n\tprivate final List<TransactionSynchronization> synchronizations;\n\n\n\t/**\n\t * Create a new JtaAfterCompletionSynchronization for the given synchronization objects.\n\t * @param synchronizations the List of TransactionSynchronization objects\n\t * @see org.springframework.transaction.support.TransactionSynchronization\n\t */\n\tpublic JtaAfterCompletionSynchronization(List<TransactionSynchronization> synchronizations) {\n\t\tthis.synchronizations = synchronizations;\n\t}\n\n\n\t@Override\n\tpublic void beforeCompletion() {\n\t}\n\n\t@Override\n\tpublic void afterCompletion(int status) {\n\t\tswitch (status) {\n\t\t\tcase Status.STATUS_COMMITTED -> {\n\t\t\t\ttry {\n\t\t\t\t\tTransactionSynchronizationUtils.invokeAfterCommit(this.synchronizations);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tTransactionSynchronizationUtils.invokeAfterCompletion(\n\t\t\t\t\t\t\tthis.synchronizations, TransactionSynchronization.STATUS_COMMITTED);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase Status.STATUS_ROLLEDBACK -> {\n\t\t\t\tTransactionSynchronizationUtils.invokeAfterCompletion(\n\t\t\t\t\t\tthis.synchronizations, TransactionSynchronization.STATUS_ROLLED_BACK);\n\t\t\t}\n\t\t\tdefault -> {\n\t\t\t\tTransactionSynchronizationUtils.invokeAfterCompletion(\n\t\t\t\t\t\tthis.synchronizations, TransactionSynchronization.STATUS_UNKNOWN);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  "org.springframework.transaction.jta.JtaAfterCompletionSynchronization#afterCompletion(status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "void",
    "signature": "public void afterCompletion(int status)",
    "source_code": "\tpublic void afterCompletion(int status) {\n\t\tswitch (status) {\n\t\t\tcase Status.STATUS_COMMITTED -> {\n\t\t\t\ttry {\n\t\t\t\t\tTransactionSynchronizationUtils.invokeAfterCommit(this.synchronizations);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tTransactionSynchronizationUtils.invokeAfterCompletion(\n\t\t\t\t\t\t\tthis.synchronizations, TransactionSynchronization.STATUS_COMMITTED);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase Status.STATUS_ROLLEDBACK -> {\n\t\t\t\tTransactionSynchronizationUtils.invokeAfterCompletion(\n\t\t\t\t\t\tthis.synchronizations, TransactionSynchronization.STATUS_ROLLED_BACK);\n\t\t\t}\n\t\t\tdefault -> {\n\t\t\t\tTransactionSynchronizationUtils.invokeAfterCompletion(\n\t\t\t\t\t\tthis.synchronizations, TransactionSynchronization.STATUS_UNKNOWN);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.transaction.jta.JtaAfterCompletionSynchronization#beforeCompletion()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 54
    },
    "return": "void",
    "signature": "public void beforeCompletion()",
    "source_code": "\tpublic void beforeCompletion() {\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Default implementation of the {@link TransactionDefinition} interface,\n * offering bean-style configuration and sensible default values\n * (PROPAGATION_REQUIRED, ISOLATION_DEFAULT, TIMEOUT_DEFAULT, readOnly=false).\n *\n * <p>Base class for both {@link TransactionTemplate} and\n * {@link org.springframework.transaction.interceptor.DefaultTransactionAttribute}.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 08.05.2003\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class DefaultTransactionDefinition",
    "source_code": "public class DefaultTransactionDefinition implements TransactionDefinition, Serializable {\n\n\t/** Prefix for the propagation constants defined in TransactionDefinition. */\n\tpublic static final String PREFIX_PROPAGATION = \"PROPAGATION_\";\n\n\t/** Prefix for the isolation constants defined in TransactionDefinition. */\n\tpublic static final String PREFIX_ISOLATION = \"ISOLATION_\";\n\n\t/** Prefix for transaction timeout values in description strings. */\n\tpublic static final String PREFIX_TIMEOUT = \"timeout_\";\n\n\t/** Marker for read-only transactions in description strings. */\n\tpublic static final String READ_ONLY_MARKER = \"readOnly\";\n\n\n\t/**\n\t * Map of constant names to constant values for the propagation constants\n\t * defined in {@link TransactionDefinition}.\n\t */\n\tstatic final Map<String, Integer> propagationConstants = Map.of(\n\t\t\t\"PROPAGATION_REQUIRED\", TransactionDefinition.PROPAGATION_REQUIRED,\n\t\t\t\"PROPAGATION_SUPPORTS\", TransactionDefinition.PROPAGATION_SUPPORTS,\n\t\t\t\"PROPAGATION_MANDATORY\", TransactionDefinition.PROPAGATION_MANDATORY,\n\t\t\t\"PROPAGATION_REQUIRES_NEW\", TransactionDefinition.PROPAGATION_REQUIRES_NEW,\n\t\t\t\"PROPAGATION_NOT_SUPPORTED\", TransactionDefinition.PROPAGATION_NOT_SUPPORTED,\n\t\t\t\"PROPAGATION_NEVER\", TransactionDefinition.PROPAGATION_NEVER,\n\t\t\t\"PROPAGATION_NESTED\", TransactionDefinition.PROPAGATION_NESTED\n\t\t);\n\n\t/**\n\t * Map of constant names to constant values for the isolation constants\n\t * defined in {@link TransactionDefinition}.\n\t */\n\tstatic final Map<String, Integer> isolationConstants = Map.of(\n\t\t\t\"ISOLATION_DEFAULT\", TransactionDefinition.ISOLATION_DEFAULT,\n\t\t\t\"ISOLATION_READ_UNCOMMITTED\", TransactionDefinition.ISOLATION_READ_UNCOMMITTED,\n\t\t\t\"ISOLATION_READ_COMMITTED\", TransactionDefinition.ISOLATION_READ_COMMITTED,\n\t\t\t\"ISOLATION_REPEATABLE_READ\", TransactionDefinition.ISOLATION_REPEATABLE_READ,\n\t\t\t\"ISOLATION_SERIALIZABLE\", TransactionDefinition.ISOLATION_SERIALIZABLE\n\t\t);\n\n\tprivate int propagationBehavior = PROPAGATION_REQUIRED;\n\n\tprivate int isolationLevel = ISOLATION_DEFAULT;\n\n\tprivate int timeout = TIMEOUT_DEFAULT;\n\n\tprivate boolean readOnly = false;\n\n\t@Nullable\n\tprivate String name;\n\n\n\t/**\n\t * Create a new DefaultTransactionDefinition, with default settings.\n\t * Can be modified through bean property setters.\n\t * @see #setPropagationBehavior\n\t * @see #setIsolationLevel\n\t * @see #setTimeout\n\t * @see #setReadOnly\n\t * @see #setName\n\t */\n\tpublic DefaultTransactionDefinition() {\n\t}\n\n\t/**\n\t * Copy constructor. Definition can be modified through bean property setters.\n\t * @see #setPropagationBehavior\n\t * @see #setIsolationLevel\n\t * @see #setTimeout\n\t * @see #setReadOnly\n\t * @see #setName\n\t */\n\tpublic DefaultTransactionDefinition(TransactionDefinition other) {\n\t\tthis.propagationBehavior = other.getPropagationBehavior();\n\t\tthis.isolationLevel = other.getIsolationLevel();\n\t\tthis.timeout = other.getTimeout();\n\t\tthis.readOnly = other.isReadOnly();\n\t\tthis.name = other.getName();\n\t}\n\n\t/**\n\t * Create a new DefaultTransactionDefinition with the given\n\t * propagation behavior. Can be modified through bean property setters.\n\t * @param propagationBehavior one of the propagation constants in the\n\t * TransactionDefinition interface\n\t * @see #setIsolationLevel\n\t * @see #setTimeout\n\t * @see #setReadOnly\n\t */\n\tpublic DefaultTransactionDefinition(int propagationBehavior) {\n\t\tthis.propagationBehavior = propagationBehavior;\n\t}\n\n\n\t/**\n\t * Set the propagation behavior by the name of the corresponding constant in\n\t * {@link TransactionDefinition} &mdash; for example, {@code \"PROPAGATION_REQUIRED\"}.\n\t * @param constantName name of the constant\n\t * @throws IllegalArgumentException if the supplied value is not resolvable\n\t * to one of the {@code PROPAGATION_} constants or is {@code null}\n\t * @see #setPropagationBehavior\n\t * @see #PROPAGATION_REQUIRED\n\t */\n\tpublic final void setPropagationBehaviorName(String constantName) throws IllegalArgumentException {\n\t\tAssert.hasText(constantName, \"'constantName' must not be null or blank\");\n\t\tInteger propagationBehavior = propagationConstants.get(constantName);\n\t\tAssert.notNull(propagationBehavior, \"Only propagation behavior constants allowed\");\n\t\tthis.propagationBehavior = propagationBehavior;\n\t}\n\n\t/**\n\t * Set the propagation behavior. Must be one of the propagation constants\n\t * in the TransactionDefinition interface. Default is PROPAGATION_REQUIRED.\n\t * <p>Exclusively designed for use with {@link #PROPAGATION_REQUIRED} or\n\t * {@link #PROPAGATION_REQUIRES_NEW} since it only applies to newly started\n\t * transactions. Consider switching the \"validateExistingTransactions\" flag to\n\t * \"true\" on your transaction manager if you'd like isolation level declarations\n\t * to get rejected when participating in an existing transaction with a different\n\t * isolation level.\n\t * <p>Note that a transaction manager that does not support custom isolation levels\n\t * will throw an exception when given any other level than {@link #ISOLATION_DEFAULT}.\n\t * @throws IllegalArgumentException if the supplied value is not one of the\n\t * {@code PROPAGATION_} constants\n\t * @see #PROPAGATION_REQUIRED\n\t */\n\tpublic final void setPropagationBehavior(int propagationBehavior) {\n\t\tAssert.isTrue(propagationConstants.containsValue(propagationBehavior),\n\t\t\t\t\"Only values of propagation constants allowed\");\n\t\tthis.propagationBehavior = propagationBehavior;\n\t}\n\n\t@Override\n\tpublic final int getPropagationBehavior() {\n\t\treturn this.propagationBehavior;\n\t}\n\n\t/**\n\t * Set the isolation level by the name of the corresponding constant in\n\t * {@link TransactionDefinition} &mdash; for example, {@code \"ISOLATION_DEFAULT\"}.\n\t * @param constantName name of the constant\n\t * @throws IllegalArgumentException if the supplied value is not resolvable\n\t * to one of the {@code ISOLATION_} constants or is {@code null}\n\t * @see #setIsolationLevel\n\t * @see #ISOLATION_DEFAULT\n\t */\n\tpublic final void setIsolationLevelName(String constantName) throws IllegalArgumentException {\n\t\tAssert.hasText(constantName, \"'constantName' must not be null or blank\");\n\t\tInteger isolationLevel = isolationConstants.get(constantName);\n\t\tAssert.notNull(isolationLevel, \"Only isolation constants allowed\");\n\t\tthis.isolationLevel = isolationLevel;\n\t}\n\n\t/**\n\t * Set the isolation level. Must be one of the isolation constants\n\t * in the TransactionDefinition interface. Default is ISOLATION_DEFAULT.\n\t * <p>Exclusively designed for use with {@link #PROPAGATION_REQUIRED} or\n\t * {@link #PROPAGATION_REQUIRES_NEW} since it only applies to newly started\n\t * transactions. Consider switching the \"validateExistingTransactions\" flag to\n\t * \"true\" on your transaction manager if you'd like isolation level declarations\n\t * to get rejected when participating in an existing transaction with a different\n\t * isolation level.\n\t * <p>Note that a transaction manager that does not support custom isolation levels\n\t * will throw an exception when given any other level than {@link #ISOLATION_DEFAULT}.\n\t * @throws IllegalArgumentException if the supplied value is not one of the\n\t * {@code ISOLATION_} constants\n\t * @see #ISOLATION_DEFAULT\n\t */\n\tpublic final void setIsolationLevel(int isolationLevel) {\n\t\tAssert.isTrue(isolationConstants.containsValue(isolationLevel),\n\t\t\t\t\"Only values of isolation constants allowed\");\n\t\tthis.isolationLevel = isolationLevel;\n\t}\n\n\t@Override\n\tpublic final int getIsolationLevel() {\n\t\treturn this.isolationLevel;\n\t}\n\n\t/**\n\t * Set the timeout to apply, as number of seconds.\n\t * Default is TIMEOUT_DEFAULT (-1).\n\t * <p>Exclusively designed for use with {@link #PROPAGATION_REQUIRED} or\n\t * {@link #PROPAGATION_REQUIRES_NEW} since it only applies to newly started\n\t * transactions.\n\t * <p>Note that a transaction manager that does not support timeouts will throw\n\t * an exception when given any other timeout than {@link #TIMEOUT_DEFAULT}.\n\t * @see #TIMEOUT_DEFAULT\n\t */\n\tpublic final void setTimeout(int timeout) {\n\t\tif (timeout < TIMEOUT_DEFAULT) {\n\t\t\tthrow new IllegalArgumentException(\"Timeout must be a positive integer or TIMEOUT_DEFAULT\");\n\t\t}\n\t\tthis.timeout = timeout;\n\t}\n\n\t@Override\n\tpublic final int getTimeout() {\n\t\treturn this.timeout;\n\t}\n\n\t/**\n\t * Set whether to optimize as read-only transaction.\n\t * Default is \"false\".\n\t * <p>The read-only flag applies to any transaction context, whether backed\n\t * by an actual resource transaction ({@link #PROPAGATION_REQUIRED}/\n\t * {@link #PROPAGATION_REQUIRES_NEW}) or operating non-transactionally at\n\t * the resource level ({@link #PROPAGATION_SUPPORTS}). In the latter case,\n\t * the flag will only apply to managed resources within the application,\n\t * such as a Hibernate {@code Session}.\n\t * <p>This just serves as a hint for the actual transaction subsystem;\n\t * it will <i>not necessarily</i> cause failure of write access attempts.\n\t * A transaction manager which cannot interpret the read-only hint will\n\t * <i>not</i> throw an exception when asked for a read-only transaction.\n\t */\n\tpublic final void setReadOnly(boolean readOnly) {\n\t\tthis.readOnly = readOnly;\n\t}\n\n\t@Override\n\tpublic final boolean isReadOnly() {\n\t\treturn this.readOnly;\n\t}\n\n\t/**\n\t * Set the name of this transaction. Default is none.\n\t * <p>This will be used as transaction name to be shown in a\n\t * transaction monitor, if applicable (for example, WebLogic's).\n\t */\n\tpublic final void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic final String getName() {\n\t\treturn this.name;\n\t}\n\n\n\t/**\n\t * This implementation compares the {@code toString()} results.\n\t * @see #toString()\n\t */\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof TransactionDefinition && toString().equals(other.toString())));\n\t}\n\n\t/**\n\t * This implementation returns {@code toString()}'s hash code.\n\t * @see #toString()\n\t */\n\t@Override\n\tpublic int hashCode() {\n\t\treturn toString().hashCode();\n\t}\n\n\t/**\n\t * Return an identifying description for this transaction definition.\n\t * <p>The format matches the one used by\n\t * {@link org.springframework.transaction.interceptor.TransactionAttributeEditor},\n\t * to be able to feed {@code toString} results into bean properties of type\n\t * {@link org.springframework.transaction.interceptor.TransactionAttribute}.\n\t * <p>Has to be overridden in subclasses for correct {@code equals}\n\t * and {@code hashCode} behavior. Alternatively, {@link #equals}\n\t * and {@link #hashCode} can be overridden themselves.\n\t * @see #getDefinitionDescription()\n\t * @see org.springframework.transaction.interceptor.TransactionAttributeEditor\n\t */\n\t@Override\n\tpublic String toString() {\n\t\treturn getDefinitionDescription().toString();\n\t}\n\n\t/**\n\t * Return an identifying description for this transaction definition.\n\t * <p>Available to subclasses, for inclusion in their {@code toString()} result.\n\t */\n\tprotected final StringBuilder getDefinitionDescription() {\n\t\tStringBuilder result = new StringBuilder();\n\t\tresult.append(getPropagationBehaviorName(this.propagationBehavior));\n\t\tresult.append(',');\n\t\tresult.append(getIsolationLevelName(this.isolationLevel));\n\t\tif (this.timeout != TIMEOUT_DEFAULT) {\n\t\t\tresult.append(',');\n\t\t\tresult.append(PREFIX_TIMEOUT).append(this.timeout);\n\t\t}\n\t\tif (this.readOnly) {\n\t\t\tresult.append(',');\n\t\t\tresult.append(READ_ONLY_MARKER);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static String getPropagationBehaviorName(int propagationBehavior) {\n\t\treturn switch(propagationBehavior) {\n\t\t\tcase TransactionDefinition.PROPAGATION_REQUIRED -> \"PROPAGATION_REQUIRED\";\n\t\t\tcase TransactionDefinition.PROPAGATION_SUPPORTS -> \"PROPAGATION_SUPPORTS\";\n\t\t\tcase TransactionDefinition.PROPAGATION_MANDATORY -> \"PROPAGATION_MANDATORY\";\n\t\t\tcase TransactionDefinition.PROPAGATION_REQUIRES_NEW -> \"PROPAGATION_REQUIRES_NEW\";\n\t\t\tcase TransactionDefinition.PROPAGATION_NOT_SUPPORTED -> \"PROPAGATION_NOT_SUPPORTED\";\n\t\t\tcase TransactionDefinition.PROPAGATION_NEVER -> \"PROPAGATION_NEVER\";\n\t\t\tcase TransactionDefinition.PROPAGATION_NESTED -> \"PROPAGATION_NESTED\";\n\t\t\tdefault -> throw new IllegalArgumentException(\"Unsupported propagation behavior: \" + propagationBehavior);\n\t\t};\n\t}\n\n\tstatic String getIsolationLevelName(int isolationLevel) {\n\t\treturn switch(isolationLevel) {\n\t\t\tcase TransactionDefinition.ISOLATION_DEFAULT -> \"ISOLATION_DEFAULT\";\n\t\t\tcase TransactionDefinition.ISOLATION_READ_UNCOMMITTED -> \"ISOLATION_READ_UNCOMMITTED\";\n\t\t\tcase TransactionDefinition.ISOLATION_READ_COMMITTED -> \"ISOLATION_READ_COMMITTED\";\n\t\t\tcase TransactionDefinition.ISOLATION_REPEATABLE_READ -> \"ISOLATION_REPEATABLE_READ\";\n\t\t\tcase TransactionDefinition.ISOLATION_SERIALIZABLE -> \"ISOLATION_SERIALIZABLE\";\n\t\t\tdefault -> throw new IllegalArgumentException(\"Unsupported isolation level: \" + isolationLevel);\n\t\t};\n\t}\n\n}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation compares the {@code toString()} results.\n\t * @see #toString()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof TransactionDefinition && toString().equals(other.toString())));\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#getDefinitionDescription()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return an identifying description for this transaction definition.\n\t * <p>Available to subclasses, for inclusion in their {@code toString()} result.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 318
    },
    "return": "StringBuilder",
    "signature": "protected StringBuilder getDefinitionDescription()",
    "source_code": "\tprotected final StringBuilder getDefinitionDescription() {\n\t\tStringBuilder result = new StringBuilder();\n\t\tresult.append(getPropagationBehaviorName(this.propagationBehavior));\n\t\tresult.append(',');\n\t\tresult.append(getIsolationLevelName(this.isolationLevel));\n\t\tif (this.timeout != TIMEOUT_DEFAULT) {\n\t\t\tresult.append(',');\n\t\t\tresult.append(PREFIX_TIMEOUT).append(this.timeout);\n\t\t}\n\t\tif (this.readOnly) {\n\t\t\tresult.append(',');\n\t\t\tresult.append(READ_ONLY_MARKER);\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#getIsolationLevel()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "int",
    "signature": "public int getIsolationLevel()",
    "source_code": "\tpublic final int getIsolationLevel() {\n\t\treturn this.isolationLevel;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#getName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "String",
    "signature": "public String getName()",
    "source_code": "\tpublic final String getName() {\n\t\treturn this.name;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#getPropagationBehavior()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "int",
    "signature": "public int getPropagationBehavior()",
    "source_code": "\tpublic final int getPropagationBehavior() {\n\t\treturn this.propagationBehavior;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#getTimeout()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "int",
    "signature": "public int getTimeout()",
    "source_code": "\tpublic final int getTimeout() {\n\t\treturn this.timeout;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns {@code toString()}'s hash code.\n\t * @see #toString()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn toString().hashCode();\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#isReadOnly()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 259
    },
    "return": "boolean",
    "signature": "public boolean isReadOnly()",
    "source_code": "\tpublic final boolean isReadOnly() {\n\t\treturn this.readOnly;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#setIsolationLevel(isolationLevel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the isolation level. Must be one of the isolation constants\n\t * in the TransactionDefinition interface. Default is ISOLATION_DEFAULT.\n\t * <p>Exclusively designed for use with {@link #PROPAGATION_REQUIRED} or\n\t * {@link #PROPAGATION_REQUIRES_NEW} since it only applies to newly started\n\t * transactions. Consider switching the \"validateExistingTransactions\" flag to\n\t * \"true\" on your transaction manager if you'd like isolation level declarations\n\t * to get rejected when participating in an existing transaction with a different\n\t * isolation level.\n\t * <p>Note that a transaction manager that does not support custom isolation levels\n\t * will throw an exception when given any other level than {@link #ISOLATION_DEFAULT}.\n\t * @throws IllegalArgumentException if the supplied value is not one of the\n\t * {@code ISOLATION_} constants\n\t * @see #ISOLATION_DEFAULT\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "isolationLevel"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "void",
    "signature": "public void setIsolationLevel(int isolationLevel)",
    "source_code": "\tpublic final void setIsolationLevel(int isolationLevel) {\n\t\tAssert.isTrue(isolationConstants.containsValue(isolationLevel),\n\t\t\t\t\"Only values of isolation constants allowed\");\n\t\tthis.isolationLevel = isolationLevel;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#setIsolationLevelName(constantName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the isolation level by the name of the corresponding constant in\n\t * {@link TransactionDefinition} &mdash; for example, {@code \"ISOLATION_DEFAULT\"}.\n\t * @param constantName name of the constant\n\t * @throws IllegalArgumentException if the supplied value is not resolvable\n\t * to one of the {@code ISOLATION_} constants or is {@code null}\n\t * @see #setIsolationLevel\n\t * @see #ISOLATION_DEFAULT\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "constantName"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "void",
    "signature": "public void setIsolationLevelName(String constantName)",
    "source_code": "\tpublic final void setIsolationLevelName(String constantName) throws IllegalArgumentException {\n\t\tAssert.hasText(constantName, \"'constantName' must not be null or blank\");\n\t\tInteger isolationLevel = isolationConstants.get(constantName);\n\t\tAssert.notNull(isolationLevel, \"Only isolation constants allowed\");\n\t\tthis.isolationLevel = isolationLevel;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#setName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of this transaction. Default is none.\n\t * <p>This will be used as transaction name to be shown in a\n\t * transaction monitor, if applicable (for example, WebLogic's).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 268
    },
    "return": "void",
    "signature": "public void setName(String name)",
    "source_code": "\tpublic final void setName(String name) {\n\t\tthis.name = name;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#setPropagationBehavior(propagationBehavior)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the propagation behavior. Must be one of the propagation constants\n\t * in the TransactionDefinition interface. Default is PROPAGATION_REQUIRED.\n\t * <p>Exclusively designed for use with {@link #PROPAGATION_REQUIRED} or\n\t * {@link #PROPAGATION_REQUIRES_NEW} since it only applies to newly started\n\t * transactions. Consider switching the \"validateExistingTransactions\" flag to\n\t * \"true\" on your transaction manager if you'd like isolation level declarations\n\t * to get rejected when participating in an existing transaction with a different\n\t * isolation level.\n\t * <p>Note that a transaction manager that does not support custom isolation levels\n\t * will throw an exception when given any other level than {@link #ISOLATION_DEFAULT}.\n\t * @throws IllegalArgumentException if the supplied value is not one of the\n\t * {@code PROPAGATION_} constants\n\t * @see #PROPAGATION_REQUIRED\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propagationBehavior"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "void",
    "signature": "public void setPropagationBehavior(int propagationBehavior)",
    "source_code": "\tpublic final void setPropagationBehavior(int propagationBehavior) {\n\t\tAssert.isTrue(propagationConstants.containsValue(propagationBehavior),\n\t\t\t\t\"Only values of propagation constants allowed\");\n\t\tthis.propagationBehavior = propagationBehavior;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#setPropagationBehaviorName(constantName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the propagation behavior by the name of the corresponding constant in\n\t * {@link TransactionDefinition} &mdash; for example, {@code \"PROPAGATION_REQUIRED\"}.\n\t * @param constantName name of the constant\n\t * @throws IllegalArgumentException if the supplied value is not resolvable\n\t * to one of the {@code PROPAGATION_} constants or is {@code null}\n\t * @see #setPropagationBehavior\n\t * @see #PROPAGATION_REQUIRED\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "constantName"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "void",
    "signature": "public void setPropagationBehaviorName(String constantName)",
    "source_code": "\tpublic final void setPropagationBehaviorName(String constantName) throws IllegalArgumentException {\n\t\tAssert.hasText(constantName, \"'constantName' must not be null or blank\");\n\t\tInteger propagationBehavior = propagationConstants.get(constantName);\n\t\tAssert.notNull(propagationBehavior, \"Only propagation behavior constants allowed\");\n\t\tthis.propagationBehavior = propagationBehavior;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#setReadOnly(readOnly)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to optimize as read-only transaction.\n\t * Default is \"false\".\n\t * <p>The read-only flag applies to any transaction context, whether backed\n\t * by an actual resource transaction ({@link #PROPAGATION_REQUIRED}/\n\t * {@link #PROPAGATION_REQUIRES_NEW}) or operating non-transactionally at\n\t * the resource level ({@link #PROPAGATION_SUPPORTS}). In the latter case,\n\t * the flag will only apply to managed resources within the application,\n\t * such as a Hibernate {@code Session}.\n\t * <p>This just serves as a hint for the actual transaction subsystem;\n\t * it will <i>not necessarily</i> cause failure of write access attempts.\n\t * A transaction manager which cannot interpret the read-only hint will\n\t * <i>not</i> throw an exception when asked for a read-only transaction.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "readOnly"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "void",
    "signature": "public void setReadOnly(boolean readOnly)",
    "source_code": "\tpublic final void setReadOnly(boolean readOnly) {\n\t\tthis.readOnly = readOnly;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#setTimeout(timeout)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the timeout to apply, as number of seconds.\n\t * Default is TIMEOUT_DEFAULT (-1).\n\t * <p>Exclusively designed for use with {@link #PROPAGATION_REQUIRED} or\n\t * {@link #PROPAGATION_REQUIRES_NEW} since it only applies to newly started\n\t * transactions.\n\t * <p>Note that a transaction manager that does not support timeouts will throw\n\t * an exception when given any other timeout than {@link #TIMEOUT_DEFAULT}.\n\t * @see #TIMEOUT_DEFAULT\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "void",
    "signature": "public void setTimeout(int timeout)",
    "source_code": "\tpublic final void setTimeout(int timeout) {\n\t\tif (timeout < TIMEOUT_DEFAULT) {\n\t\t\tthrow new IllegalArgumentException(\"Timeout must be a positive integer or TIMEOUT_DEFAULT\");\n\t\t}\n\t\tthis.timeout = timeout;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return an identifying description for this transaction definition.\n\t * <p>The format matches the one used by\n\t * {@link org.springframework.transaction.interceptor.TransactionAttributeEditor},\n\t * to be able to feed {@code toString} results into bean properties of type\n\t * {@link org.springframework.transaction.interceptor.TransactionAttribute}.\n\t * <p>Has to be overridden in subclasses for correct {@code equals}\n\t * and {@code hashCode} behavior. Alternatively, {@link #equals}\n\t * and {@link #hashCode} can be overridden themselves.\n\t * @see #getDefinitionDescription()\n\t * @see org.springframework.transaction.interceptor.TransactionAttributeEditor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 310
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn getDefinitionDescription().toString();\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionStatus#getTransactionName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "String",
    "signature": "public String getTransactionName()",
    "source_code": "\tpublic String getTransactionName() {\n\t\treturn (this.transactionName != null ? this.transactionName : \"\");\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionStatus#isNested()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "boolean",
    "signature": "public boolean isNested()",
    "source_code": "\tpublic boolean isNested() {\n\t\treturn this.nested;\n\t}"
  },
  "org.springframework.transaction.support.PREFIX_ISOLATION": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Prefix for the isolation constants defined in TransactionDefinition. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "signature": "public String PREFIX_ISOLATION",
    "source_code": "\tpublic static final String PREFIX_ISOLATION = \"ISOLATION_\";",
    "type": "String"
  },
  "org.springframework.transaction.support.PREFIX_PROPAGATION": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Prefix for the propagation constants defined in TransactionDefinition. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public String PREFIX_PROPAGATION",
    "source_code": "\tpublic static final String PREFIX_PROPAGATION = \"PROPAGATION_\";",
    "type": "String"
  },
  "org.springframework.transaction.support.PREFIX_TIMEOUT": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Prefix for transaction timeout values in description strings. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public String PREFIX_TIMEOUT",
    "source_code": "\tpublic static final String PREFIX_TIMEOUT = \"timeout_\";",
    "type": "String"
  },
  "org.springframework.transaction.support.READ_ONLY_MARKER": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Marker for read-only transactions in description strings. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "public String READ_ONLY_MARKER",
    "source_code": "\tpublic static final String READ_ONLY_MARKER = \"readOnly\";",
    "type": "String"
  },
  "org.springframework.util.ObjectUtils#nullSafeHash(elements)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a hash code for the given elements, delegating to\n\t * {@link #nullSafeHashCode(Object)} for each element. Contrary\n\t * to {@link Objects#hash(Object...)}, this method can handle an\n\t * element that is an array.\n\t * @param elements the elements to be hashed\n\t * @return a hash value of the elements\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elements"
    ],
    "position": {
      "column": 1,
      "line": 399
    },
    "return": "int",
    "signature": "public int nullSafeHash(@Nullable Object... elements)",
    "source_code": "\tpublic static int nullSafeHash(@Nullable Object... elements) {\n\t\tif (elements == null) {\n\t\t\treturn 0;\n\t\t}\n\t\tint result = 1;\n\t\tfor (Object element : elements) {\n\t\t\tresult = 31 * result + nullSafeHashCode(element);\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.util.ReflectionUtils#findFieldIgnoreCase(clazz,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to find a {@link Field field} on the supplied {@link Class} with the\n\t * supplied {@code name}. Searches all superclasses up to {@link Object}.\n\t * @param clazz the class to introspect\n\t * @param name the name of the field (with upper/lower case to be ignored)\n\t * @return the corresponding Field object, or {@code null} if not found\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 621
    },
    "return": "Field",
    "signature": "public Field findFieldIgnoreCase(Class<?> clazz, String name)",
    "source_code": "\tpublic static Field findFieldIgnoreCase(Class<?> clazz, String name) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tClass<?> searchType = clazz;\n\t\twhile (Object.class != searchType && searchType != null) {\n\t\t\tField[] fields = getDeclaredFields(searchType);\n\t\t\tfor (Field field : fields) {\n\t\t\t\tif (name.equalsIgnoreCase(field.getName())) {\n\t\t\t\t\treturn field;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsearchType = searchType.getSuperclass();\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.util.comparator.BooleanComparator#compare(left,right)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "left",
      "right"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "int",
    "signature": "public int compare(Boolean left, Boolean right)",
    "source_code": "\tpublic int compare(Boolean left, Boolean right) {\n\t\tint multiplier = this.trueLow ? -1 : 1;\n\t\treturn multiplier * Boolean.compare(left, right);\n\t}"
  },
  "org.springframework.util.comparator.BooleanComparator#compare(v1,v2)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "v1",
      "v2"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "int",
    "signature": "public int compare(Boolean v1, Boolean v2)",
    "source_code": "\tpublic int compare(Boolean v1, Boolean v2) {\n\t\treturn (v1 ^ v2) ? ((v1 ^ this.trueLow) ? 1 : -1) : 0;\n\t}"
  },
  "org.springframework.util.comparator.NullSafeComparator#compare(left,right)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "left",
      "right"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "int",
    "signature": "public int compare(@Nullable T left, @Nullable T right)",
    "source_code": "\tpublic int compare(@Nullable T left, @Nullable T right) {\n\t\tComparator<T> comparator = this.nullsLow ? Comparator.nullsFirst(this.nonNullComparator) : Comparator.nullsLast(this.nonNullComparator);\n\t\treturn comparator.compare(left, right);\n\t}"
  },
  "org.springframework.util.comparator.NullSafeComparator#compare(o1,o2)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o1",
      "o2"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "int",
    "signature": "public int compare(@Nullable T o1, @Nullable T o2)",
    "source_code": "\tpublic int compare(@Nullable T o1, @Nullable T o2) {\n\t\tif (o1 == o2) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (o1 == null) {\n\t\t\treturn (this.nullsLow ? -1 : 1);\n\t\t}\n\t\tif (o2 == null) {\n\t\t\treturn (this.nullsLow ? 1 : -1);\n\t\t}\n\t\treturn this.nonNullComparator.compare(o1, o2);\n\t}"
  },
  "org.springframework.util.function.SupplierUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Convenience utilities for {@link java.util.function.Supplier} handling.\n *\n * @author Juergen Hoeller\n * @since 5.1\n * @see SingletonSupplier\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 30
    },
    "signature": "public class SupplierUtils",
    "source_code": "public abstract class SupplierUtils {\n\n\t/**\n\t * Resolve the given {@code Supplier}, getting its result or immediately\n\t * returning {@code null} if the supplier itself was {@code null}.\n\t * @param supplier the supplier to resolve\n\t * @return the supplier's result, or {@code null} if none\n\t */\n\t@Nullable\n\tpublic static <T> T resolve(@Nullable Supplier<T> supplier) {\n\t\treturn (supplier != null ? supplier.get() : null);\n\t}\n\n\t/**\n\t * Resolve a given {@code Supplier}, getting its result or immediately\n\t * returning the given Object as-is if not a {@code Supplier}.\n\t * @param candidate the candidate to resolve (potentially a {@code Supplier})\n\t * @return a supplier's result or the given Object as-is\n\t * @since 6.1.4\n\t */\n\t@Nullable\n\tpublic static Object resolve(@Nullable Object candidate) {\n\t\treturn (candidate instanceof Supplier<?> supplier ? supplier.get() : candidate);\n\t}\n\n}"
  },
  "org.springframework.util.function.SupplierUtils#resolve(candidate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve a given {@code Supplier}, getting its result or immediately\n\t * returning the given Object as-is if not a {@code Supplier}.\n\t * @param candidate the candidate to resolve (potentially a {@code Supplier})\n\t * @return a supplier's result or the given Object as-is\n\t * @since 6.1.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "candidate"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "return": "Object",
    "signature": "public Object resolve(@Nullable Object candidate)",
    "source_code": "\tpublic static Object resolve(@Nullable Object candidate) {\n\t\treturn (candidate instanceof Supplier<?> supplier ? supplier.get() : candidate);\n\t}"
  },
  "org.springframework.util.function.SupplierUtils#resolve(supplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the given {@code Supplier}, getting its result or immediately\n\t * returning {@code null} if the supplier itself was {@code null}.\n\t * @param supplier the supplier to resolve\n\t * @return the supplier's result, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "supplier"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "return": "T",
    "signature": "public T resolve(@Nullable Supplier<T> supplier)",
    "source_code": "\tpublic static <T> T resolve(@Nullable Supplier<T> supplier) {\n\t\treturn (supplier != null ? supplier.get() : null);\n\t}"
  },
  "org.springframework.util.xml.<unknown>#close()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\tpublic void close() {\n\t\tsuper.close();\n\t\tthis.events.clear();\n\t}"
  },
  "org.springframework.util.xml.<unknown>#getElementText()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "String",
    "signature": "public String getElementText()",
    "source_code": "\tpublic String getElementText() throws XMLStreamException {\n\t\tcheckIfClosed();\n\t\tif (this.currentEvent == null || !this.currentEvent.isStartElement()) {\n\t\t\tthrow new XMLStreamException(\"Not at START_ELEMENT: \" + this.currentEvent);\n\t\t}\n\n\t\tStringBuilder builder = new StringBuilder();\n\t\twhile (true) {\n\t\t\tXMLEvent event = nextEvent();\n\t\t\tif (event.isEndElement()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (!event.isCharacters()) {\n\t\t\t\tthrow new XMLStreamException(\"Unexpected non-text event: \" + event);\n\t\t\t}\n\t\t\tCharacters characters = event.asCharacters();\n\t\t\tif (!characters.isIgnorableWhiteSpace()) {\n\t\t\t\tbuilder.append(event.asCharacters().getData());\n\t\t\t}\n\t\t}\n\t\treturn builder.toString();\n\t}"
  },
  "org.springframework.util.xml.<unknown>#hasNext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "boolean",
    "signature": "public boolean hasNext()",
    "source_code": "\tpublic boolean hasNext() {\n\t\treturn (this.cursor < this.events.size());\n\t}"
  },
  "org.springframework.util.xml.<unknown>#nextEvent()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "XMLEvent",
    "signature": "public XMLEvent nextEvent()",
    "source_code": "\tpublic XMLEvent nextEvent() {\n\t\tif (hasNext()) {\n\t\t\tthis.currentEvent = this.events.get(this.cursor);\n\t\t\tthis.cursor++;\n\t\t\treturn this.currentEvent;\n\t\t}\n\t\telse {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t}"
  },
  "org.springframework.util.xml.<unknown>#nextTag()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "XMLEvent",
    "signature": "public XMLEvent nextTag()",
    "source_code": "\tpublic XMLEvent nextTag() throws XMLStreamException {\n\t\tcheckIfClosed();\n\n\t\twhile (true) {\n\t\t\tXMLEvent event = nextEvent();\n\t\t\tswitch (event.getEventType()) {\n\t\t\t\tcase XMLStreamConstants.START_ELEMENT, XMLStreamConstants.END_ELEMENT -> {\n\t\t\t\t\treturn event;\n\t\t\t\t}\n\t\t\t\tcase XMLStreamConstants.END_DOCUMENT -> {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tcase XMLStreamConstants.SPACE, XMLStreamConstants.COMMENT, XMLStreamConstants.PROCESSING_INSTRUCTION -> {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcase XMLStreamConstants.CDATA, XMLStreamConstants.CHARACTERS -> {\n\t\t\t\t\tif (!event.asCharacters().isWhiteSpace()) {\n\t\t\t\t\t\tthrow new XMLStreamException(\n\t\t\t\t\t\t\t\t\"Non-ignorable whitespace CDATA or CHARACTERS event: \" + event);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdefault -> throw new XMLStreamException(\"Expected START_ELEMENT or END_ELEMENT: \" + event);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.xml.<unknown>#peek()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "XMLEvent",
    "signature": "public XMLEvent peek()",
    "source_code": "\tpublic XMLEvent peek() {\n\t\tif (hasNext()) {\n\t\t\treturn this.events.get(this.cursor);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.validation.DataBinder#construct(valueResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the target with constructor injection of values. It is expected that\n\t * {@link #setTargetType(ResolvableType)} was previously called and that\n\t * {@link #getTarget()} is {@code null}.\n\t * <p>Uses a public, no-arg constructor if available in the target object type,\n\t * also supporting a \"primary constructor\" approach for data classes as follows:\n\t * It understands the JavaBeans {@code ConstructorProperties} annotation as\n\t * well as runtime-retained parameter names in the bytecode, associating\n\t * input values with constructor arguments by name. If no such constructor is\n\t * found, the default constructor will be used (even if not public), assuming\n\t * subsequent bean property bindings through setter methods.\n\t * <p>After the call, use {@link #getBindingResult()} to check for failures\n\t * to bind to, and/or validate constructor arguments. If there are no errors,\n\t * the target is set, and {@link #doBind(MutablePropertyValues)} can be used\n\t * for further initialization via setters.\n\t * @param valueResolver to resolve constructor argument values with\n\t * @throws BeanInstantiationException in case of constructor failure\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "valueResolver"
    ],
    "position": {
      "column": 1,
      "line": 899
    },
    "return": "void",
    "signature": "public void construct(ValueResolver valueResolver)",
    "source_code": "\tpublic void construct(ValueResolver valueResolver) {\n\t\tAssert.state(this.target == null, \"Target instance already available\");\n\t\tAssert.state(this.targetType != null, \"Target type not set\");\n\n\t\tthis.target = createObject(this.targetType, \"\", valueResolver);\n\n\t\tif (!getBindingResult().hasErrors()) {\n\t\t\tthis.bindingResult = null;\n\t\t\tif (this.typeConverter != null) {\n\t\t\t\tthis.typeConverter.registerCustomEditors(getPropertyAccessor());\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.validation.DataBinder#getNameResolver()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link #setNameResolver configured} name resolver for\n\t * constructor parameters.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 635
    },
    "return": "NameResolver",
    "signature": "public NameResolver getNameResolver()",
    "source_code": "\tpublic NameResolver getNameResolver() {\n\t\treturn this.nameResolver;\n\t}"
  },
  "org.springframework.validation.DataBinder#getTargetType()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link #setTargetType configured} type for the target object.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType getTargetType()",
    "source_code": "\tpublic ResolvableType getTargetType() {\n\t\treturn this.targetType;\n\t}"
  },
  "org.springframework.validation.DataBinder#getValidatorsToApply()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the Validators to apply after data binding. This includes the\n\t * configured {@link #getValidators() validators} filtered by the\n\t * {@link #setExcludedValidators(Predicate) exclude predicate}.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 744
    },
    "return": "List<Validator>",
    "signature": "public List<Validator> getValidatorsToApply()",
    "source_code": "\tpublic List<Validator> getValidatorsToApply() {\n\t\treturn (this.excludedValidators != null ?\n\t\t\t\tthis.validators.stream().filter(validator -> !this.excludedValidators.test(validator)).toList() :\n\t\t\t\tCollections.unmodifiableList(this.validators));\n\t}"
  },
  "org.springframework.validation.DataBinder#isDeclarativeBinding()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether to bind only fields intended for binding.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 450
    },
    "return": "boolean",
    "signature": "public boolean isDeclarativeBinding()",
    "source_code": "\tpublic boolean isDeclarativeBinding() {\n\t\treturn this.declarativeBinding;\n\t}"
  },
  "org.springframework.validation.DataBinder#registerCustomEditors(registry)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 1333
    },
    "return": "void",
    "signature": "public void registerCustomEditors(PropertyEditorRegistry registry)",
    "source_code": "\t\tpublic void registerCustomEditors(PropertyEditorRegistry registry) {\n\t\t\tcopyCustomEditorsTo(registry, null);\n\t\t}"
  },
  "org.springframework.validation.DataBinder#setDeclarativeBinding(declarativeBinding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to bind only fields explicitly intended for binding including:\n\t * <ul>\n\t * <li>Constructor binding via {@link #construct}.\n\t * <li>Property binding with configured\n\t * {@link #setAllowedFields(String...) allowedFields}.\n\t * </ul>\n\t * <p>Default is \"false\". Turn this on to limit binding to constructor\n\t * parameters and allowed fields.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "declarativeBinding"
    ],
    "position": {
      "column": 1,
      "line": 442
    },
    "return": "void",
    "signature": "public void setDeclarativeBinding(boolean declarativeBinding)",
    "source_code": "\tpublic void setDeclarativeBinding(boolean declarativeBinding) {\n\t\tthis.declarativeBinding = declarativeBinding;\n\t}"
  },
  "org.springframework.validation.DataBinder#setExcludedValidators(predicate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a predicate to exclude validators.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate"
    ],
    "position": {
      "column": 1,
      "line": 698
    },
    "return": "void",
    "signature": "public void setExcludedValidators(Predicate<Validator> predicate)",
    "source_code": "\tpublic void setExcludedValidators(Predicate<Validator> predicate) {\n\t\tthis.excludedValidators = predicate;\n\t}"
  },
  "org.springframework.validation.DataBinder#setNameResolver(nameResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a resolver to determine the name of the value to bind to a\n\t * constructor parameter in {@link #construct}.\n\t * <p>If not configured, or if the name cannot be resolved, by default\n\t * {@link org.springframework.core.DefaultParameterNameDiscoverer} is used.\n\t * @param nameResolver the resolver to use\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nameResolver"
    ],
    "position": {
      "column": 1,
      "line": 625
    },
    "return": "void",
    "signature": "public void setNameResolver(NameResolver nameResolver)",
    "source_code": "\tpublic void setNameResolver(NameResolver nameResolver) {\n\t\tthis.nameResolver = nameResolver;\n\t}"
  },
  "org.springframework.validation.DataBinder#setTargetType(targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the type for the target object. When the target is {@code null},\n\t * setting the targetType allows using {@link #construct} to create the target.\n\t * @param targetType the type of the target object\n\t * @since 6.1\n\t * @see #construct\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "void",
    "signature": "public void setTargetType(ResolvableType targetType)",
    "source_code": "\tpublic void setTargetType(ResolvableType targetType) {\n\t\tAssert.state(this.target == null, \"targetType is used to for target creation but target is already set\");\n\t\tthis.targetType = targetType;\n\t}"
  },
  "org.springframework.validation.DataBinder#shouldConstructArgument(param)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to instantiate the constructor argument of the given type,\n\t * matching its own constructor arguments to bind values.\n\t * <p>By default, simple value types, maps, collections, and arrays are\n\t * excluded from nested constructor binding initialization.\n\t * @since 6.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "param"
    ],
    "position": {
      "column": 1,
      "line": 1018
    },
    "return": "boolean",
    "signature": "protected boolean shouldConstructArgument(MethodParameter param)",
    "source_code": "\tprotected boolean shouldConstructArgument(MethodParameter param) {\n\t\tClass<?> type = param.nestedIfOptional().getNestedParameterType();\n\t\treturn !(BeanUtils.isSimpleValueType(type) ||\n\t\t\t\tCollection.class.isAssignableFrom(type) || Map.class.isAssignableFrom(type) || type.isArray() ||\n\t\t\t\ttype.getPackageName().startsWith(\"java.\"));\n\t}"
  },
  "org.springframework.validation.DataBinder#shouldNotBindPropertyValues()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to not bind parameters to properties. Returns \"true\" if\n\t * {@link #isDeclarativeBinding()} is on, and\n\t * {@link #setAllowedFields(String...) allowedFields} are not configured.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1096
    },
    "return": "boolean",
    "signature": "protected boolean shouldNotBindPropertyValues()",
    "source_code": "\tprotected boolean shouldNotBindPropertyValues() {\n\t\treturn (isDeclarativeBinding() && ObjectUtils.isEmpty(this.allowedFields));\n\t}"
  },
  "org.springframework.validation.NameResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Strategy to determine the name of the value to bind to a method parameter.\n\t * Supported on constructor parameters with {@link #construct constructor binding}\n\t * which performs lookups via {@link ValueResolver#resolveValue}.\n\t */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 1289
    },
    "signature": "public interface NameResolver",
    "source_code": "\tpublic interface NameResolver {\n\n\t\t/**\n\t\t * Return the name to use for the given method parameter, or {@code null}\n\t\t * if unresolved. For constructor parameters, the name is determined via\n\t\t * {@link org.springframework.core.DefaultParameterNameDiscoverer} if unresolved.\n\t\t */\n\t\t@Nullable\n\t\tString resolveName(MethodParameter parameter);\n\t}"
  },
  "org.springframework.validation.SimpleErrors": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A simple implementation of the {@link Errors} interface, managing global\n * errors and field errors for a top-level target object. Flexibly retrieves\n * field values through bean property getter methods, and automatically\n * falls back to raw field access if necessary.\n *\n * <p>Note that this {@link Errors} implementation comes without support for\n * nested paths. It is exclusively designed for the validation of individual\n * top-level objects, not aggregating errors from multiple sources.\n * If this is insufficient for your purposes, use a binding-capable\n * {@link Errors} implementation such as {@link BeanPropertyBindingResult}.\n *\n * @author Juergen Hoeller\n * @since 6.1\n * @see Validator#validateObject(Object)\n * @see BeanPropertyBindingResult\n * @see DirectFieldBindingResult\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "public class SimpleErrors",
    "source_code": "public class SimpleErrors implements Errors, Serializable {\n\n\tprivate final Object target;\n\n\tprivate final String objectName;\n\n\tprivate final List<ObjectError> globalErrors = new ArrayList<>();\n\n\tprivate final List<FieldError> fieldErrors = new ArrayList<>();\n\n\n\t/**\n\t * Create a new {@link SimpleErrors} holder for the given target,\n\t * using the simple name of the target class as the object name.\n\t * @param target the target to wrap\n\t */\n\tpublic SimpleErrors(Object target) {\n\t\tAssert.notNull(target, \"Target must not be null\");\n\t\tthis.target = target;\n\t\tthis.objectName = this.target.getClass().getSimpleName();\n\t}\n\n\t/**\n\t * Create a new {@link SimpleErrors} holder for the given target.\n\t * @param target the target to wrap\n\t * @param objectName the name of the target object for error reporting\n\t */\n\tpublic SimpleErrors(Object target, String objectName) {\n\t\tAssert.notNull(target, \"Target must not be null\");\n\t\tthis.target = target;\n\t\tthis.objectName = objectName;\n\t}\n\n\n\t@Override\n\tpublic String getObjectName() {\n\t\treturn this.objectName;\n\t}\n\n\t@Override\n\tpublic void reject(String errorCode, @Nullable Object[] errorArgs, @Nullable String defaultMessage) {\n\t\tthis.globalErrors.add(new ObjectError(getObjectName(), new String[] {errorCode}, errorArgs, defaultMessage));\n\t}\n\n\t@Override\n\tpublic void rejectValue(@Nullable String field, String errorCode,\n\t\t\t@Nullable Object[] errorArgs, @Nullable String defaultMessage) {\n\n\t\tif (!StringUtils.hasLength(field)) {\n\t\t\treject(errorCode, errorArgs, defaultMessage);\n\t\t\treturn;\n\t\t}\n\n\t\tObject newVal = getFieldValue(field);\n\t\tthis.fieldErrors.add(new FieldError(getObjectName(), field, newVal, false,\n\t\t\t\tnew String[] {errorCode}, errorArgs, defaultMessage));\n\t}\n\n\t@Override\n\tpublic void addAllErrors(Errors errors) {\n\t\tthis.globalErrors.addAll(errors.getGlobalErrors());\n\t\tthis.fieldErrors.addAll(errors.getFieldErrors());\n\t}\n\n\t@Override\n\tpublic List<ObjectError> getGlobalErrors() {\n\t\treturn this.globalErrors;\n\t}\n\n\t@Override\n\tpublic List<FieldError> getFieldErrors() {\n\t\treturn this.fieldErrors;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Object getFieldValue(String field) {\n\t\tFieldError fieldError = getFieldError(field);\n\t\tif (fieldError != null) {\n\t\t\treturn fieldError.getRejectedValue();\n\t\t}\n\n\t\tPropertyDescriptor pd = BeanUtils.getPropertyDescriptor(this.target.getClass(), field);\n\t\tif (pd != null && pd.getReadMethod() != null) {\n\t\t\tReflectionUtils.makeAccessible(pd.getReadMethod());\n\t\t\treturn ReflectionUtils.invokeMethod(pd.getReadMethod(), this.target);\n\t\t}\n\n\t\tField rawField = ReflectionUtils.findField(this.target.getClass(), field);\n\t\tif (rawField != null) {\n\t\t\tReflectionUtils.makeAccessible(rawField);\n\t\t\treturn ReflectionUtils.getField(rawField, this.target);\n\t\t}\n\n\t\tthrow new IllegalArgumentException(\"Cannot retrieve value for field '\" + field +\n\t\t\t\t\"' - neither a getter method nor a raw field found\");\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Class<?> getFieldType(String field) {\n\t\tPropertyDescriptor pd = BeanUtils.getPropertyDescriptor(this.target.getClass(), field);\n\t\tif (pd != null) {\n\t\t\treturn pd.getPropertyType();\n\t\t}\n\t\tField rawField = ReflectionUtils.findField(this.target.getClass(), field);\n\t\tif (rawField != null) {\n\t\t\treturn rawField.getType();\n\t\t}\n\t\treturn null;\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof SimpleErrors that &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.target, that.target) &&\n\t\t\t\tthis.globalErrors.equals(that.globalErrors) &&\n\t\t\t\tthis.fieldErrors.equals(that.fieldErrors)));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.target.hashCode();\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (ObjectError error : this.globalErrors) {\n\t\t\tsb.append('\\n').append(error);\n\t\t}\n\t\tfor (ObjectError error : this.fieldErrors) {\n\t\t\tsb.append('\\n').append(error);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n}"
  },
  "org.springframework.validation.SimpleErrors#addAllErrors(errors)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "void",
    "signature": "public void addAllErrors(Errors errors)",
    "source_code": "\tpublic void addAllErrors(Errors errors) {\n\t\tthis.globalErrors.addAll(errors.getGlobalErrors());\n\t\tthis.fieldErrors.addAll(errors.getFieldErrors());\n\t}"
  },
  "org.springframework.validation.SimpleErrors#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof SimpleErrors that &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.target, that.target) &&\n\t\t\t\tthis.globalErrors.equals(that.globalErrors) &&\n\t\t\t\tthis.fieldErrors.equals(that.fieldErrors)));\n\t}"
  },
  "org.springframework.validation.SimpleErrors#getFieldErrors()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "List<FieldError>",
    "signature": "public List<FieldError> getFieldErrors()",
    "source_code": "\tpublic List<FieldError> getFieldErrors() {\n\t\treturn this.fieldErrors;\n\t}"
  },
  "org.springframework.validation.SimpleErrors#getFieldValue(field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "Object",
    "signature": "public Object getFieldValue(String field)",
    "source_code": "\tpublic Object getFieldValue(String field) {\n\t\tFieldError fieldError = getFieldError(field);\n\t\tif (fieldError != null) {\n\t\t\treturn fieldError.getRejectedValue();\n\t\t}\n\n\t\tPropertyDescriptor pd = BeanUtils.getPropertyDescriptor(this.target.getClass(), field);\n\t\tif (pd != null && pd.getReadMethod() != null) {\n\t\t\tReflectionUtils.makeAccessible(pd.getReadMethod());\n\t\t\treturn ReflectionUtils.invokeMethod(pd.getReadMethod(), this.target);\n\t\t}\n\n\t\tField rawField = ReflectionUtils.findField(this.target.getClass(), field);\n\t\tif (rawField != null) {\n\t\t\tReflectionUtils.makeAccessible(rawField);\n\t\t\treturn ReflectionUtils.getField(rawField, this.target);\n\t\t}\n\n\t\tthrow new IllegalArgumentException(\"Cannot retrieve value for field '\" + field +\n\t\t\t\t\"' - neither a getter method nor a raw field found\");\n\t}"
  },
  "org.springframework.validation.SimpleErrors#getGlobalErrors()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "List<ObjectError>",
    "signature": "public List<ObjectError> getGlobalErrors()",
    "source_code": "\tpublic List<ObjectError> getGlobalErrors() {\n\t\treturn this.globalErrors;\n\t}"
  },
  "org.springframework.validation.SimpleErrors#getObjectName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "String",
    "signature": "public String getObjectName()",
    "source_code": "\tpublic String getObjectName() {\n\t\treturn this.objectName;\n\t}"
  },
  "org.springframework.validation.SimpleErrors#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.target.hashCode();\n\t}"
  },
  "org.springframework.validation.SimpleErrors#reject(errorCode,errorArgs,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "void",
    "signature": "public void reject(String errorCode, @Nullable Object[] errorArgs, @Nullable String defaultMessage)",
    "source_code": "\tpublic void reject(String errorCode, @Nullable Object[] errorArgs, @Nullable String defaultMessage) {\n\t\tthis.globalErrors.add(new ObjectError(getObjectName(), new String[] {errorCode}, errorArgs, defaultMessage));\n\t}"
  },
  "org.springframework.validation.SimpleErrors#rejectValue(field,errorCode,errorArgs,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode,\n\t\t\t@Nullable Object[] errorArgs, @Nullable String defaultMessage)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode,"
  },
  "org.springframework.validation.SimpleErrors#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (ObjectError error : this.globalErrors) {\n\t\t\tsb.append('\\n').append(error);\n\t\t}\n\t\tfor (ObjectError error : this.fieldErrors) {\n\t\t\tsb.append('\\n').append(error);\n\t\t}\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.validation.ValueResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Strategy for {@link #construct constructor binding} to look up the values\n\t * to bind to a given constructor parameter.\n\t */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 1305
    },
    "signature": "public interface ValueResolver",
    "source_code": "\tpublic interface ValueResolver {\n\n\t\t/**\n\t\t * Resolve the value for the given name and target parameter type.\n\t\t * @param name the name to use for the lookup, possibly a nested path\n\t\t * for constructor parameters on nested objects\n\t\t * @param type the target type, based on the constructor parameter type\n\t\t * @return the resolved value, possibly {@code null} if none found\n\t\t */\n\t\t@Nullable\n\t\tObject resolveValue(String name, Class<?> type);\n\n\t\t/**\n\t\t * Return the names of all property values.\n\t\t * @since 6.1.2\n\t\t */\n\t\tSet<String> getNames();\n\n\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link MethodValidator} that uses a Bean Validation\n * {@link jakarta.validation.Validator} for validation, and adapts\n * {@link ConstraintViolation}s to {@link MethodValidationResult}.\n *\n * @author Rossen Stoyanchev\n * @since 6.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "signature": "public class MethodValidationAdapter",
    "source_code": "public class MethodValidationAdapter implements MethodValidator {\n\n\tprivate static final MethodValidationResult emptyValidationResult = MethodValidationResult.emptyResult();\n\n\tprivate static final ObjectNameResolver defaultObjectNameResolver = new DefaultObjectNameResolver();\n\n\tprivate static final Comparator<ParameterValidationResult> resultComparator = new ResultComparator();\n\n\n\tprivate final Supplier<Validator> validator;\n\n\tprivate final Supplier<SpringValidatorAdapter> validatorAdapter;\n\n\tprivate MessageCodesResolver messageCodesResolver = new DefaultMessageCodesResolver();\n\n\tprivate ParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer();\n\n\tprivate ObjectNameResolver objectNameResolver = defaultObjectNameResolver;\n\n\n\t/**\n\t * Create an instance using a default JSR-303 validator underneath.\n\t */\n\tpublic MethodValidationAdapter() {\n\t\tthis.validator = SingletonSupplier.of(() -> Validation.buildDefaultValidatorFactory().getValidator());\n\t\tthis.validatorAdapter = initValidatorAdapter(this.validator);\n\t}\n\n\t/**\n\t * Create an instance using the given JSR-303 ValidatorFactory.\n\t * @param validatorFactory the JSR-303 ValidatorFactory to use\n\t */\n\t@SuppressWarnings(\"DataFlowIssue\")\n\tpublic MethodValidationAdapter(ValidatorFactory validatorFactory) {\n\t\tif (validatorFactory instanceof SpringValidatorAdapter adapter) {\n\t\t\tthis.validator = () -> adapter;\n\t\t\tthis.validatorAdapter = () -> adapter;\n\t\t}\n\t\telse {\n\t\t\tthis.validator = SingletonSupplier.of(validatorFactory::getValidator);\n\t\t\tthis.validatorAdapter = SingletonSupplier.of(() -> new SpringValidatorAdapter(this.validator.get()));\n\t\t}\n\t}\n\n\t/**\n\t * Create an instance using the given JSR-303 Validator.\n\t * @param validator the JSR-303 Validator to use\n\t */\n\tpublic MethodValidationAdapter(Validator validator) {\n\t\tthis.validator = () -> validator;\n\t\tthis.validatorAdapter = initValidatorAdapter(this.validator);\n\t}\n\n\t/**\n\t * Create an instance for the supplied (potentially lazily initialized) Validator.\n\t * @param validator a Supplier for the Validator to use\n\t */\n\tpublic MethodValidationAdapter(Supplier<Validator> validator) {\n\t\tthis.validator = validator;\n\t\tthis.validatorAdapter = initValidatorAdapter(validator);\n\t}\n\n\tprivate static Supplier<SpringValidatorAdapter> initValidatorAdapter(Supplier<Validator> validatorSupplier) {\n\t\treturn SingletonSupplier.of(() -> {\n\t\t\tValidator validator = validatorSupplier.get();\n\t\t\treturn (validator instanceof SpringValidatorAdapter sva ? sva : new SpringValidatorAdapter(validator));\n\t\t});\n\t}\n\n\n\t/**\n\t * Return the {@link SpringValidatorAdapter} configured for use.\n\t */\n\tpublic Supplier<SpringValidatorAdapter> getSpringValidatorAdapter() {\n\t\treturn this.validatorAdapter;\n\t}\n\n\t/**\n\t * Set the strategy to use to determine message codes for violations.\n\t * <p>Default is a DefaultMessageCodesResolver.\n\t */\n\tpublic void setMessageCodesResolver(MessageCodesResolver messageCodesResolver) {\n\t\tthis.messageCodesResolver = messageCodesResolver;\n\t}\n\n\t/**\n\t * Return the {@link #setMessageCodesResolver(MessageCodesResolver) configured}\n\t * {@code MessageCodesResolver}.\n\t */\n\tpublic MessageCodesResolver getMessageCodesResolver() {\n\t\treturn this.messageCodesResolver;\n\t}\n\n\t/**\n\t * Set the {@code ParameterNameDiscoverer} to discover method parameter names\n\t * with to create error codes for {@link MessageSourceResolvable}. Used only\n\t * when {@link MethodParameter}s are not passed into\n\t * {@link #validateArguments} or {@link #validateReturnValue}.\n\t * <p>Default is {@link org.springframework.core.DefaultParameterNameDiscoverer}.\n\t */\n\tpublic void setParameterNameDiscoverer(ParameterNameDiscoverer parameterNameDiscoverer) {\n\t\tthis.parameterNameDiscoverer = parameterNameDiscoverer;\n\t}\n\n\t/**\n\t * Return the {@link #setParameterNameDiscoverer configured}\n\t * {@code ParameterNameDiscoverer}.\n\t */\n\tpublic ParameterNameDiscoverer getParameterNameDiscoverer() {\n\t\treturn this.parameterNameDiscoverer;\n\t}\n\n\t/**\n\t * Configure a resolver to determine the name of an {@code @Valid} method\n\t * parameter to use for its {@link BindingResult}. This allows aligning with\n\t * a higher level programming model such as to resolve the name of an\n\t * {@code @ModelAttribute} method parameter in Spring MVC.\n\t * <p>By default, the object name is resolved through:\n\t * <ul>\n\t * <li>{@link MethodParameter#getParameterName()} for input parameters\n\t * <li>{@link Conventions#getVariableNameForReturnType(Method, Class, Object)}\n\t * for a return type\n\t * </ul>\n\t * If a name cannot be determined, e.g. a return value with insufficient\n\t * type information, then it defaults to one of:\n\t * <ul>\n\t * <li>{@code \"{methodName}.arg{index}\"} for input parameters\n\t * <li>{@code \"{methodName}.returnValue\"} for a return type\n\t * </ul>\n\t */\n\tpublic void setObjectNameResolver(ObjectNameResolver nameResolver) {\n\t\tthis.objectNameResolver = nameResolver;\n\t}\n\n\n\t/**\n\t * {@inheritDoc}.\n\t * <p>Default are the validation groups as specified in the {@link Validated}\n\t * annotation on the method, or on the containing target class of the method,\n\t * or for an AOP proxy without a target (with all behavior in advisors), also\n\t * check on proxied interfaces.\n\t */\n\t@Override\n\tpublic Class<?>[] determineValidationGroups(Object target, Method method) {\n\t\tValidated validatedAnn = AnnotationUtils.findAnnotation(method, Validated.class);\n\t\tif (validatedAnn == null) {\n\t\t\tif (AopUtils.isAopProxy(target)) {\n\t\t\t\tfor (Class<?> type : AopProxyUtils.proxiedUserInterfaces(target)) {\n\t\t\t\t\tvalidatedAnn = AnnotationUtils.findAnnotation(type, Validated.class);\n\t\t\t\t\tif (validatedAnn != null) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalidatedAnn = AnnotationUtils.findAnnotation(target.getClass(), Validated.class);\n\t\t\t}\n\t\t}\n\t\treturn (validatedAnn != null ? validatedAnn.value() : new Class<?>[0]);\n\t}\n\n\t@Override\n\tpublic final MethodValidationResult validateArguments(\n\t\t\tObject target, Method method, @Nullable MethodParameter[] parameters, Object[] arguments,\n\t\t\tClass<?>[] groups) {\n\n\t\tSet<ConstraintViolation<Object>> violations =\n\t\t\t\tinvokeValidatorForArguments(target, method, arguments, groups);\n\n\t\tif (violations.isEmpty()) {\n\t\t\treturn emptyValidationResult;\n\t\t}\n\n\t\treturn adaptViolations(target, method, violations,\n\t\t\t\ti -> (parameters != null ? parameters[i] : initMethodParameter(method, i)),\n\t\t\t\ti -> arguments[i]);\n\t}\n\n\t/**\n\t * Invoke the validator, and return the resulting violations.\n\t */\n\tpublic final Set<ConstraintViolation<Object>> invokeValidatorForArguments(\n\t\t\tObject target, Method method, Object[] arguments, Class<?>[] groups) {\n\n\t\tExecutableValidator execVal = this.validator.get().forExecutables();\n\t\tSet<ConstraintViolation<Object>> violations;\n\t\ttry {\n\t\t\tviolations = execVal.validateParameters(target, method, arguments, groups);\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\t// Probably a generic type mismatch between interface and impl as reported in SPR-12237 / HV-1011\n\t\t\t// Let's try to find the bridged method on the implementation class...\n\t\t\tMethod bridgedMethod = BridgeMethodResolver.getMostSpecificMethod(method, target.getClass());\n\t\t\tviolations = execVal.validateParameters(target, bridgedMethod, arguments, groups);\n\t\t}\n\t\treturn violations;\n\t}\n\n\t@Override\n\tpublic final MethodValidationResult validateReturnValue(\n\t\t\tObject target, Method method, @Nullable MethodParameter returnType, @Nullable Object returnValue,\n\t\t\tClass<?>[] groups) {\n\n\t\tSet<ConstraintViolation<Object>> violations =\n\t\t\t\tinvokeValidatorForReturnValue(target, method, returnValue, groups);\n\n\t\tif (violations.isEmpty()) {\n\t\t\treturn emptyValidationResult;\n\t\t}\n\n\t\treturn adaptViolations(target, method, violations,\n\t\t\t\ti -> (returnType != null ? returnType : initMethodParameter(method, -1)),\n\t\t\t\ti -> returnValue);\n\t}\n\n\t/**\n\t * Invoke the validator, and return the resulting violations.\n\t */\n\tpublic final Set<ConstraintViolation<Object>> invokeValidatorForReturnValue(\n\t\t\tObject target, Method method, @Nullable Object returnValue, Class<?>[] groups) {\n\n\t\tExecutableValidator execVal = this.validator.get().forExecutables();\n\t\treturn execVal.validateReturnValue(target, method, returnValue, groups);\n\t}\n\n\tprivate MethodValidationResult adaptViolations(\n\t\t\tObject target, Method method, Set<ConstraintViolation<Object>> violations,\n\t\t\tFunction<Integer, MethodParameter> parameterFunction,\n\t\t\tFunction<Integer, Object> argumentFunction) {\n\n\t\tMap<Path.Node, ParamValidationResultBuilder> paramViolations = new LinkedHashMap<>();\n\t\tMap<Path.Node, ParamErrorsBuilder> nestedViolations = new LinkedHashMap<>();\n\n\t\tfor (ConstraintViolation<Object> violation : violations) {\n\t\t\tIterator<Path.Node> itr = violation.getPropertyPath().iterator();\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tPath.Node node = itr.next();\n\n\t\t\t\tMethodParameter parameter;\n\t\t\t\tif (node.getKind().equals(ElementKind.PARAMETER)) {\n\t\t\t\t\tint index = node.as(Path.ParameterNode.class).getParameterIndex();\n\t\t\t\t\tparameter = parameterFunction.apply(index);\n\t\t\t\t}\n\t\t\t\telse if (node.getKind().equals(ElementKind.RETURN_VALUE)) {\n\t\t\t\t\tparameter = parameterFunction.apply(-1);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tObject arg = argumentFunction.apply(parameter.getParameterIndex());\n\n\t\t\t\t// If the arg is a container, we need to element, but the only way to extract it\n\t\t\t\t// is to check for and use a container index or key on the next node:\n\t\t\t\t// https://github.com/jakartaee/validation/issues/194\n\n\t\t\t\tPath.Node parameterNode = node;\n\t\t\t\tif (itr.hasNext()) {\n\t\t\t\t\tnode = itr.next();\n\t\t\t\t}\n\n\t\t\t\tObject value;\n\t\t\t\tObject container;\n\t\t\t\tInteger index = node.getIndex();\n\t\t\t\tObject key = node.getKey();\n\t\t\t\tif (index != null && arg instanceof List<?> list) {\n\t\t\t\t\tvalue = list.get(index);\n\t\t\t\t\tcontainer = list;\n\t\t\t\t}\n\t\t\t\telse if (index != null && arg instanceof Object[] array) {\n\t\t\t\t\tvalue = array[index];\n\t\t\t\t\tcontainer = array;\n\t\t\t\t}\n\t\t\t\telse if (key != null && arg instanceof Map<?, ?> map) {\n\t\t\t\t\tvalue = map.get(key);\n\t\t\t\t\tcontainer = map;\n\t\t\t\t}\n\t\t\t\telse if (arg instanceof Optional<?> optional) {\n\t\t\t\t\tvalue = optional.orElse(null);\n\t\t\t\t\tcontainer = optional;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tAssert.state(!node.isInIterable(), \"No way to unwrap Iterable without index\");\n\t\t\t\t\tvalue = arg;\n\t\t\t\t\tcontainer = null;\n\t\t\t\t}\n\n\t\t\t\tif (node.getKind().equals(ElementKind.PROPERTY)) {\n\t\t\t\t\tnestedViolations\n\t\t\t\t\t\t\t.computeIfAbsent(parameterNode, k ->\n\t\t\t\t\t\t\t\t\tnew ParamErrorsBuilder(parameter, value, container, index, key))\n\t\t\t\t\t\t\t.addViolation(violation);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparamViolations\n\t\t\t\t\t\t\t.computeIfAbsent(parameterNode, p ->\n\t\t\t\t\t\t\t\t\tnew ParamValidationResultBuilder(target, parameter, value, container, index, key))\n\t\t\t\t\t\t\t.addViolation(violation);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tList<ParameterValidationResult> resultList = new ArrayList<>();\n\t\tparamViolations.forEach((param, builder) -> resultList.add(builder.build()));\n\t\tnestedViolations.forEach((key, builder) -> resultList.add(builder.build()));\n\t\tresultList.sort(resultComparator);\n\n\t\treturn MethodValidationResult.create(target, method, resultList);\n\t}\n\n\tprivate MethodParameter initMethodParameter(Method method, int index) {\n\t\tMethodParameter parameter = new MethodParameter(method, index);\n\t\tparameter.initParameterNameDiscovery(this.parameterNameDiscoverer);\n\t\treturn parameter;\n\t}\n\n\tprivate MessageSourceResolvable createMessageSourceResolvable(\n\t\t\tObject target, MethodParameter parameter, ConstraintViolation<Object> violation) {\n\n\t\tString objectName = Conventions.getVariableName(target) + \"#\" + parameter.getExecutable().getName();\n\t\tString paramName = (parameter.getParameterName() != null ? parameter.getParameterName() : \"\");\n\t\tClass<?> parameterType = parameter.getParameterType();\n\n\t\tConstraintDescriptor<?> descriptor = violation.getConstraintDescriptor();\n\t\tString code = descriptor.getAnnotation().annotationType().getSimpleName();\n\t\tString[] codes = this.messageCodesResolver.resolveMessageCodes(code, objectName, paramName, parameterType);\n\t\tObject[] arguments = this.validatorAdapter.get().getArgumentsForConstraint(objectName, paramName, descriptor);\n\n\t\treturn new DefaultMessageSourceResolvable(codes, arguments, violation.getMessage());\n\t}\n\n\tprivate BindingResult createBindingResult(MethodParameter parameter, @Nullable Object argument) {\n\t\tString objectName = this.objectNameResolver.resolveName(parameter, argument);\n\t\tBeanPropertyBindingResult result = new BeanPropertyBindingResult(argument, objectName);\n\t\tresult.setMessageCodesResolver(this.messageCodesResolver);\n\t\treturn result;\n\t}\n\n\n\t/**\n\t * Strategy to resolve the name of an {@code @Valid} method parameter to\n\t * use for its {@link BindingResult}.\n\t */\n\tpublic interface ObjectNameResolver {\n\n\t\t/**\n\t\t * Determine the name for the given method argument.\n\t\t * @param parameter the method parameter\n\t\t * @param value the argument value or return value\n\t\t * @return the name to use\n\t\t */\n\t\tString resolveName(MethodParameter parameter, @Nullable Object value);\n\n\t}\n\n\n\t/**\n\t * Builds a validation result for a value method parameter with constraints\n\t * declared directly on it.\n\t */\n\tprivate final class ParamValidationResultBuilder {\n\n\t\tprivate final Object target;\n\n\t\tprivate final MethodParameter parameter;\n\n\t\t@Nullable\n\t\tprivate final Object value;\n\n\t\t@Nullable\n\t\tprivate final Object container;\n\n\t\t@Nullable\n\t\tprivate final Integer containerIndex;\n\n\t\t@Nullable\n\t\tprivate final Object containerKey;\n\n\t\tprivate final List<MessageSourceResolvable> resolvableErrors = new ArrayList<>();\n\n\t\tpublic ParamValidationResultBuilder(\n\t\t\t\tObject target, MethodParameter parameter, @Nullable Object value, @Nullable Object container,\n\t\t\t\t@Nullable Integer containerIndex, @Nullable Object containerKey) {\n\t\t\tthis.target = target;\n\t\t\tthis.parameter = parameter;\n\t\t\tthis.value = value;\n\t\t\tthis.container = container;\n\t\t\tthis.containerIndex = containerIndex;\n\t\t\tthis.containerKey = containerKey;\n\t\t}\n\n\t\tpublic void addViolation(ConstraintViolation<Object> violation) {\n\t\t\tthis.resolvableErrors.add(createMessageSourceResolvable(this.target, this.parameter, violation));\n\t\t}\n\n\t\tpublic ParameterValidationResult build() {\n\t\t\treturn new ParameterValidationResult(\n\t\t\t\t\tthis.parameter, this.value, this.resolvableErrors, this.container,\n\t\t\t\t\tthis.containerIndex, this.containerKey);\n\t\t}\n\n\t}\n\n\n\t/**\n\t * Builds a validation result for an {@link jakarta.validation.Valid @Valid}\n\t * annotated bean method parameter with cascaded constraints.\n\t */\n\tprivate final class ParamErrorsBuilder {\n\n\t\tprivate final MethodParameter parameter;\n\n\t\t@Nullable\n\t\tprivate final Object bean;\n\n\t\t@Nullable\n\t\tprivate final Object container;\n\n\t\t@Nullable\n\t\tprivate final Integer containerIndex;\n\n\t\t@Nullable\n\t\tprivate final Object containerKey;\n\n\t\tprivate final Errors errors;\n\n\t\tprivate final Set<ConstraintViolation<Object>> violations = new LinkedHashSet<>();\n\n\t\tpublic ParamErrorsBuilder(\n\t\t\t\tMethodParameter param, @Nullable Object bean, @Nullable Object container,\n\t\t\t\t@Nullable Integer containerIndex, @Nullable Object containerKey) {\n\n\t\t\tthis.parameter = param;\n\t\t\tthis.bean = bean;\n\t\t\tthis.container = container;\n\t\t\tthis.containerIndex = containerIndex;\n\t\t\tthis.containerKey = containerKey;\n\t\t\tthis.errors = createBindingResult(param, this.bean);\n\t\t}\n\n\t\tpublic void addViolation(ConstraintViolation<Object> violation) {\n\t\t\tthis.violations.add(violation);\n\t\t}\n\n\t\tpublic ParameterErrors build() {\n\t\t\tvalidatorAdapter.get().processConstraintViolations(this.violations, this.errors);\n\t\t\treturn new ParameterErrors(\n\t\t\t\t\tthis.parameter, this.bean, this.errors, this.container,\n\t\t\t\t\tthis.containerIndex, this.containerKey);\n\t\t}\n\t}\n\n\n\t/**\n\t * Default algorithm to select an object name, as described in\n\t * {@link #setObjectNameResolver(ObjectNameResolver)}.\n\t */\n\tprivate static class DefaultObjectNameResolver implements ObjectNameResolver {\n\n\t\t@Override\n\t\tpublic String resolveName(MethodParameter parameter, @Nullable Object value) {\n\t\t\tString objectName = null;\n\t\t\tif (parameter.getParameterIndex() != -1) {\n\t\t\t\tobjectName = parameter.getParameterName();\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\tMethod method = parameter.getMethod();\n\t\t\t\t\tif (method != null) {\n\t\t\t\t\t\tClass<?> containingClass = parameter.getContainingClass();\n\t\t\t\t\t\tClass<?> resolvedType = GenericTypeResolver.resolveReturnType(method, containingClass);\n\t\t\t\t\t\tobjectName = Conventions.getVariableNameForReturnType(method, resolvedType, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\t// insufficient type information\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (objectName == null) {\n\t\t\t\tint index = parameter.getParameterIndex();\n\t\t\t\tobjectName = (parameter.getExecutable().getName() + (index != -1 ? \".arg\" + index : \".returnValue\"));\n\t\t\t}\n\t\t\treturn objectName;\n\t\t}\n\t}\n\n\n\t/**\n\t * Comparator for validation results, sorted by method parameter index first,\n\t * also falling back on container indexes if necessary for cascaded\n\t * constraints on a List container.\n\t */\n\tprivate static final class ResultComparator implements Comparator<ParameterValidationResult> {\n\n\t\t@Override\n\t\tpublic int compare(ParameterValidationResult result1, ParameterValidationResult result2) {\n\t\t\tint index1 = result1.getMethodParameter().getParameterIndex();\n\t\t\tint index2 = result2.getMethodParameter().getParameterIndex();\n\t\t\tint i = Integer.compare(index1, index2);\n\t\t\tif (i != 0) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\tif (result1 instanceof ParameterErrors errors1 && result2 instanceof ParameterErrors errors2) {\n\t\t\t\tInteger containerIndex1 = errors1.getContainerIndex();\n\t\t\t\tInteger containerIndex2 = errors2.getContainerIndex();\n\t\t\t\tif (containerIndex1 != null && containerIndex2 != null) {\n\t\t\t\t\ti = Integer.compare(containerIndex1, containerIndex2);\n\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti = compareKeys(errors1, errors2);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tprivate <E> int compareKeys(ParameterErrors errors1, ParameterErrors errors2) {\n\t\t\tObject key1 = errors1.getContainerKey();\n\t\t\tObject key2 = errors2.getContainerKey();\n\t\t\tif (key1 instanceof Comparable<?> && key2 instanceof Comparable<?>) {\n\t\t\t\treturn ((Comparable<E>) key1).compareTo((E) key2);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#addViolation(violation)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "violation"
    ],
    "position": {
      "column": 1,
      "line": 516
    },
    "return": "void",
    "signature": "public void addViolation(ConstraintViolation<Object> violation)",
    "source_code": "\t\tpublic void addViolation(ConstraintViolation<Object> violation) {\n\t\t\tthis.violations.add(violation);\n\t\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#build()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 520
    },
    "return": "ParameterErrors",
    "signature": "public ParameterErrors build()",
    "source_code": "\t\tpublic ParameterErrors build() {\n\t\t\tvalidatorAdapter.get().processConstraintViolations(this.violations, this.errors);\n\t\t\treturn new ParameterErrors(\n\t\t\t\t\tthis.parameter, this.bean, this.errors, this.container,\n\t\t\t\t\tthis.containerIndex, this.containerKey);\n\t\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#compare(result1,result2)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "result1",
      "result2"
    ],
    "position": {
      "column": 1,
      "line": 571
    },
    "return": "int",
    "signature": "public int compare(ParameterValidationResult result1, ParameterValidationResult result2)",
    "source_code": "\t\tpublic int compare(ParameterValidationResult result1, ParameterValidationResult result2) {\n\t\t\tint index1 = result1.getMethodParameter().getParameterIndex();\n\t\t\tint index2 = result2.getMethodParameter().getParameterIndex();\n\t\t\tint i = Integer.compare(index1, index2);\n\t\t\tif (i != 0) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\tif (result1 instanceof ParameterErrors errors1 && result2 instanceof ParameterErrors errors2) {\n\t\t\t\tInteger containerIndex1 = errors1.getContainerIndex();\n\t\t\t\tInteger containerIndex2 = errors2.getContainerIndex();\n\t\t\t\tif (containerIndex1 != null && containerIndex2 != null) {\n\t\t\t\t\ti = Integer.compare(containerIndex1, containerIndex2);\n\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti = compareKeys(errors1, errors2);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#getMessageCodesResolver()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link #setMessageCodesResolver(MessageCodesResolver) configured}\n\t * {@code MessageCodesResolver}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "MessageCodesResolver",
    "signature": "public MessageCodesResolver getMessageCodesResolver()",
    "source_code": "\tpublic MessageCodesResolver getMessageCodesResolver() {\n\t\treturn this.messageCodesResolver;\n\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#getParameterNameDiscoverer()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link #setParameterNameDiscoverer configured}\n\t * {@code ParameterNameDiscoverer}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "ParameterNameDiscoverer",
    "signature": "public ParameterNameDiscoverer getParameterNameDiscoverer()",
    "source_code": "\tpublic ParameterNameDiscoverer getParameterNameDiscoverer() {\n\t\treturn this.parameterNameDiscoverer;\n\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#getSpringValidatorAdapter()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link SpringValidatorAdapter} configured for use.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "Supplier<SpringValidatorAdapter>",
    "signature": "public Supplier<SpringValidatorAdapter> getSpringValidatorAdapter()",
    "source_code": "\tpublic Supplier<SpringValidatorAdapter> getSpringValidatorAdapter() {\n\t\treturn this.validatorAdapter;\n\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#invokeValidatorForArguments(target,method,arguments,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the validator, and return the resulting violations.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "arguments",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "Set<ConstraintViolation<Object>>",
    "signature": "public Set<ConstraintViolation<Object>> invokeValidatorForArguments(Object target, Method method, Object[] arguments, Class<?>[] groups)",
    "source_code": "\tpublic final Set<ConstraintViolation<Object>> invokeValidatorForArguments("
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#invokeValidatorForReturnValue(target,method,returnValue,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the validator, and return the resulting violations.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "returnValue",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "Set<ConstraintViolation<Object>>",
    "signature": "public Set<ConstraintViolation<Object>> invokeValidatorForReturnValue(Object target, Method method, @Nullable Object returnValue, Class<?>[] groups)",
    "source_code": "\tpublic final Set<ConstraintViolation<Object>> invokeValidatorForReturnValue("
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#resolveName(parameter,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 536
    },
    "return": "String",
    "signature": "public String resolveName(MethodParameter parameter, @Nullable Object value)",
    "source_code": "\t\tpublic String resolveName(MethodParameter parameter, @Nullable Object value) {\n\t\t\tString objectName = null;\n\t\t\tif (parameter.getParameterIndex() != -1) {\n\t\t\t\tobjectName = parameter.getParameterName();\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\tMethod method = parameter.getMethod();\n\t\t\t\t\tif (method != null) {\n\t\t\t\t\t\tClass<?> containingClass = parameter.getContainingClass();\n\t\t\t\t\t\tClass<?> resolvedType = GenericTypeResolver.resolveReturnType(method, containingClass);\n\t\t\t\t\t\tobjectName = Conventions.getVariableNameForReturnType(method, resolvedType, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\t// insufficient type information\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (objectName == null) {\n\t\t\t\tint index = parameter.getParameterIndex();\n\t\t\t\tobjectName = (parameter.getExecutable().getName() + (index != -1 ? \".arg\" + index : \".returnValue\"));\n\t\t\t}\n\t\t\treturn objectName;\n\t\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#setMessageCodesResolver(messageCodesResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the strategy to use to determine message codes for violations.\n\t * <p>Default is a DefaultMessageCodesResolver.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageCodesResolver"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "void",
    "signature": "public void setMessageCodesResolver(MessageCodesResolver messageCodesResolver)",
    "source_code": "\tpublic void setMessageCodesResolver(MessageCodesResolver messageCodesResolver) {\n\t\tthis.messageCodesResolver = messageCodesResolver;\n\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#setObjectNameResolver(nameResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a resolver to determine the name of an {@code @Valid} method\n\t * parameter to use for its {@link BindingResult}. This allows aligning with\n\t * a higher level programming model such as to resolve the name of an\n\t * {@code @ModelAttribute} method parameter in Spring MVC.\n\t * <p>By default, the object name is resolved through:\n\t * <ul>\n\t * <li>{@link MethodParameter#getParameterName()} for input parameters\n\t * <li>{@link Conventions#getVariableNameForReturnType(Method, Class, Object)}\n\t * for a return type\n\t * </ul>\n\t * If a name cannot be determined, e.g. a return value with insufficient\n\t * type information, then it defaults to one of:\n\t * <ul>\n\t * <li>{@code \"{methodName}.arg{index}\"} for input parameters\n\t * <li>{@code \"{methodName}.returnValue\"} for a return type\n\t * </ul>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nameResolver"
    ],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "void",
    "signature": "public void setObjectNameResolver(ObjectNameResolver nameResolver)",
    "source_code": "\tpublic void setObjectNameResolver(ObjectNameResolver nameResolver) {\n\t\tthis.objectNameResolver = nameResolver;\n\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#setParameterNameDiscoverer(parameterNameDiscoverer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@code ParameterNameDiscoverer} to discover method parameter names\n\t * with to create error codes for {@link MessageSourceResolvable}. Used only\n\t * when {@link MethodParameter}s are not passed into\n\t * {@link #validateArguments} or {@link #validateReturnValue}.\n\t * <p>Default is {@link org.springframework.core.DefaultParameterNameDiscoverer}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterNameDiscoverer"
    ],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "void",
    "signature": "public void setParameterNameDiscoverer(ParameterNameDiscoverer parameterNameDiscoverer)",
    "source_code": "\tpublic void setParameterNameDiscoverer(ParameterNameDiscoverer parameterNameDiscoverer) {\n\t\tthis.parameterNameDiscoverer = parameterNameDiscoverer;\n\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#validateArguments(target,method,parameters,arguments,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "parameters",
      "arguments",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "MethodValidationResult",
    "signature": "public MethodValidationResult validateArguments(Object target, Method method, @Nullable MethodParameter[] parameters, Object[] arguments,\n\t\t\tClass<?>[] groups)",
    "source_code": "\tpublic final MethodValidationResult validateArguments("
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#validateReturnValue(target,method,returnType,returnValue,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "returnType",
      "returnValue",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "MethodValidationResult",
    "signature": "public MethodValidationResult validateReturnValue(Object target, Method method, @Nullable MethodParameter returnType, @Nullable Object returnValue,\n\t\t\tClass<?>[] groups)",
    "source_code": "\tpublic final MethodValidationResult validateReturnValue("
  },
  "org.springframework.validation.beanvalidation.ObjectNameResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Strategy to resolve the name of an {@code @Valid} method parameter to\n\t * use for its {@link BindingResult}.\n\t */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 419
    },
    "signature": "public interface ObjectNameResolver",
    "source_code": "\tpublic interface ObjectNameResolver {\n\n\t\t/**\n\t\t * Determine the name for the given method argument.\n\t\t * @param parameter the method parameter\n\t\t * @param value the argument value or return value\n\t\t * @return the name to use\n\t\t */\n\t\tString resolveName(MethodParameter parameter, @Nullable Object value);\n\n\t}"
  },
  "org.springframework.web.bind.MethodArgumentNotValidException": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Exception to be thrown when validation on an argument annotated with {@code @Valid} fails.\n * Extends {@link BindException} as of 5.3.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Sebastien Deleuze\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "public class MethodArgumentNotValidException",
    "source_code": "public class MethodArgumentNotValidException extends BindException implements ErrorResponse {\n\n\t@Nullable\n\tprivate final MethodParameter parameter;\n\n\t@Nullable\n\tprivate final Executable executable;\n\n\tprivate final ProblemDetail body;\n\n\n\t/**\n\t * Constructor for {@link MethodArgumentNotValidException}.\n\t * @param parameter the parameter that failed validation\n\t * @param bindingResult the results of the validation\n\t */\n\tpublic MethodArgumentNotValidException(MethodParameter parameter, BindingResult bindingResult) {\n\t\tsuper(bindingResult);\n\t\tthis.parameter = parameter;\n\t\tthis.executable = null;\n\t\tthis.body = ProblemDetail.forStatusAndDetail(getStatusCode(), \"Invalid request content.\");\n\t}\n\n\t/**\n\t * Constructor for {@link MethodArgumentNotValidException}.\n\t * @param executable the executable that failed validation\n\t * @param bindingResult the results of the validation\n\t * @since 6.0.5\n\t * @deprecated in favor of {@link #MethodArgumentNotValidException(MethodParameter, BindingResult)}\n\t */\n\t@Deprecated(since = \"6.0.10\", forRemoval = true)\n\tpublic MethodArgumentNotValidException(Executable executable, BindingResult bindingResult) {\n\t\tsuper(bindingResult);\n\t\tthis.parameter = null;\n\t\tthis.executable = executable;\n\t\tthis.body = ProblemDetail.forStatusAndDetail(getStatusCode(), \"Invalid request content.\");\n\t}\n\n\n\t@Override\n\tpublic HttpStatusCode getStatusCode() {\n\t\treturn HttpStatus.BAD_REQUEST;\n\t}\n\n\t@Override\n\tpublic ProblemDetail getBody() {\n\t\treturn this.body;\n\t}\n\n\t/**\n\t * Return the method parameter that failed validation.\n\t */\n\tpublic final MethodParameter getParameter() {\n\t\treturn this.parameter;\n\t}\n\n\t@Override\n\tpublic String getMessage() {\n\t\tStringBuilder sb = new StringBuilder(\"Validation failed \");\n\t\tif (this.parameter != null) {\n\t\t\tsb.append(\"for argument [\")\n\t\t\t\t\t.append(this.parameter.getParameterIndex()).append(\"] in \")\n\t\t\t\t\t.append(this.parameter.getExecutable().toGenericString());\n\t\t}\n\t\telse {\n\t\t\tsb.append(\"in \")\n\t\t\t\t\t.append(this.executable.toGenericString());\n\t\t}\n\t\tBindingResult bindingResult = getBindingResult();\n\t\tif (bindingResult.getErrorCount() > 1) {\n\t\t\tsb.append(\" with \").append(bindingResult.getErrorCount()).append(\" errors\");\n\t\t}\n\t\tsb.append(\": \");\n\t\tfor (ObjectError error : bindingResult.getAllErrors()) {\n\t\t\tsb.append('[').append(error).append(\"] \");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\t@Override\n\tpublic Object[] getDetailMessageArguments() {\n\t\treturn new Object[] {errorsToStringList(getGlobalErrors()), errorsToStringList(getFieldErrors())};\n\t}\n\n\t@Override\n\tpublic Object[] getDetailMessageArguments(MessageSource messageSource, Locale locale) {\n\t\treturn new Object[] {\n\t\t\t\terrorsToStringList(getGlobalErrors(), messageSource, locale),\n\t\t\t\terrorsToStringList(getFieldErrors(), messageSource, locale)\n\t\t};\n\t}\n\n\t/**\n\t * Resolve global and field errors to messages with the given\n\t * {@link MessageSource} and {@link Locale}.\n\t * @return a Map with errors as key and resolved messages as value\n\t * @since 6.0.3\n\t */\n\tpublic Map<ObjectError, String> resolveErrorMessages(MessageSource messageSource, Locale locale) {\n\t\tMap<ObjectError, String> map = new LinkedHashMap<>();\n\t\taddMessages(map, getGlobalErrors(), messageSource, locale);\n\t\taddMessages(map, getFieldErrors(), messageSource, locale);\n\t\treturn map;\n\t}\n\n\tprivate static void addMessages(\n\t\t\tMap<ObjectError, String> map, List<? extends ObjectError> errors,\n\t\t\tMessageSource messageSource, Locale locale) {\n\n\t\tList<String> messages = errorsToStringList(errors, messageSource, locale);\n\t\tfor (int i = 0; i < errors.size(); i++) {\n\t\t\tmap.put(errors.get(i), messages.get(i));\n\t\t}\n\t}\n\n\n\t/**\n\t * Convert each given {@link ObjectError} to a String in single quotes, taking\n\t * either the error's default message, or its error code.\n\t * @since 6.0\n\t */\n\tpublic static List<String> errorsToStringList(List<? extends ObjectError> errors) {\n\t\treturn errorsToStringList(errors, error ->\n\t\t\t\terror.getDefaultMessage() != null ? error.getDefaultMessage() : error.getCode());\n\t}\n\n\t/**\n\t * Variant of {@link #errorsToStringList(List)} that uses a\n\t * {@link MessageSource} to resolve the message code of the error, or fall\n\t * back on the error's default message.\n\t * @since 6.0\n\t */\n\tpublic static List<String> errorsToStringList(\n\t\t\tList<? extends ObjectError> errors, @Nullable MessageSource source, Locale locale) {\n\n\t\treturn (source != null ?\n\t\t\t\terrorsToStringList(errors, error -> source.getMessage(error, locale)) :\n\t\t\t\terrorsToStringList(errors));\n\t}\n\n\tprivate static List<String> errorsToStringList(\n\t\t\tList<? extends ObjectError> errors, Function<ObjectError, String> formatter) {\n\n\t\tList<String> result = new ArrayList<>(errors.size());\n\t\tfor (ObjectError error : errors) {\n\t\t\tString value = formatter.apply(error);\n\t\t\tif (StringUtils.hasText(value)) {\n\t\t\t\tresult.add(error instanceof FieldError fieldError ?\n\t\t\t\t\t\tfieldError.getField() + \": '\" + value + \"'\" : \"'\" + value + \"'\");\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n}"
  },
  "org.springframework.web.bind.MethodArgumentNotValidException#errorsToStringList(errors)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert each given {@link ObjectError} to a String in single quotes, taking\n\t * either the error's default message, or its error code.\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "List<String>",
    "signature": "public List<String> errorsToStringList(List<? extends ObjectError> errors)",
    "source_code": "\tpublic static List<String> errorsToStringList(List<? extends ObjectError> errors) {\n\t\treturn errorsToStringList(errors, error ->\n\t\t\t\terror.getDefaultMessage() != null ? error.getDefaultMessage() : error.getCode());\n\t}"
  },
  "org.springframework.web.bind.MethodArgumentNotValidException#errorsToStringList(errors,source,locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #errorsToStringList(List)} that uses a\n\t * {@link MessageSource} to resolve the message code of the error, or fall\n\t * back on the error's default message.\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors",
      "source",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "List<String>",
    "signature": "public List<String> errorsToStringList(List<? extends ObjectError> errors, @Nullable MessageSource source, Locale locale)",
    "source_code": "\tpublic static List<String> errorsToStringList("
  },
  "org.springframework.web.bind.MethodArgumentNotValidException#getBody()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "ProblemDetail",
    "signature": "public ProblemDetail getBody()",
    "source_code": "\tpublic ProblemDetail getBody() {\n\t\treturn this.body;\n\t}"
  },
  "org.springframework.web.bind.MethodArgumentNotValidException#getDetailMessageArguments()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "Object[]",
    "signature": "public Object[] getDetailMessageArguments()",
    "source_code": "\tpublic Object[] getDetailMessageArguments() {\n\t\treturn new Object[] {errorsToStringList(getGlobalErrors()), errorsToStringList(getFieldErrors())};\n\t}"
  },
  "org.springframework.web.bind.MethodArgumentNotValidException#getDetailMessageArguments(messageSource,locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSource",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "Object[]",
    "signature": "public Object[] getDetailMessageArguments(MessageSource messageSource, Locale locale)",
    "source_code": "\tpublic Object[] getDetailMessageArguments(MessageSource messageSource, Locale locale) {\n\t\treturn new Object[] {\n\t\t\t\terrorsToStringList(getGlobalErrors(), messageSource, locale),\n\t\t\t\terrorsToStringList(getFieldErrors(), messageSource, locale)\n\t\t};\n\t}"
  },
  "org.springframework.web.bind.MethodArgumentNotValidException#getMessage()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "String",
    "signature": "public String getMessage()",
    "source_code": "\tpublic String getMessage() {\n\t\tStringBuilder sb = new StringBuilder(\"Validation failed \");\n\t\tif (this.parameter != null) {\n\t\t\tsb.append(\"for argument [\")\n\t\t\t\t\t.append(this.parameter.getParameterIndex()).append(\"] in \")\n\t\t\t\t\t.append(this.parameter.getExecutable().toGenericString());\n\t\t}\n\t\telse {\n\t\t\tsb.append(\"in \")\n\t\t\t\t\t.append(this.executable.toGenericString());\n\t\t}\n\t\tBindingResult bindingResult = getBindingResult();\n\t\tif (bindingResult.getErrorCount() > 1) {\n\t\t\tsb.append(\" with \").append(bindingResult.getErrorCount()).append(\" errors\");\n\t\t}\n\t\tsb.append(\": \");\n\t\tfor (ObjectError error : bindingResult.getAllErrors()) {\n\t\t\tsb.append('[').append(error).append(\"] \");\n\t\t}\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.web.bind.MethodArgumentNotValidException#getParameter()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the method parameter that failed validation.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter getParameter()",
    "source_code": "\tpublic final MethodParameter getParameter() {\n\t\treturn this.parameter;\n\t}"
  },
  "org.springframework.web.bind.MethodArgumentNotValidException#getStatusCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "HttpStatusCode",
    "signature": "public HttpStatusCode getStatusCode()",
    "source_code": "\tpublic HttpStatusCode getStatusCode() {\n\t\treturn HttpStatus.BAD_REQUEST;\n\t}"
  },
  "org.springframework.web.bind.MethodArgumentNotValidException#resolveErrorMessages(messageSource,locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve global and field errors to messages with the given\n\t * {@link MessageSource} and {@link Locale}.\n\t * @return a Map with errors as key and resolved messages as value\n\t * @since 6.0.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSource",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "String>",
    "signature": "public String> resolveErrorMessages(MessageSource messageSource, Locale locale)",
    "source_code": "\tpublic Map<ObjectError, String> resolveErrorMessages(MessageSource messageSource, Locale locale) {\n\t\tMap<ObjectError, String> map = new LinkedHashMap<>();\n\t\taddMessages(map, getGlobalErrors(), messageSource, locale);\n\t\taddMessages(map, getFieldErrors(), messageSource, locale);\n\t\treturn map;\n\t}"
  },
  "org.springframework.web.bind.support.DefaultDataBinderFactory": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Create a {@link WebRequestDataBinder} instance and initialize it with a\n * {@link WebBindingInitializer}.\n *\n * @author Rossen Stoyanchev\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 36
    },
    "signature": "public class DefaultDataBinderFactory",
    "source_code": "public class DefaultDataBinderFactory implements WebDataBinderFactory {\n\n\t@Nullable\n\tprivate final WebBindingInitializer initializer;\n\n\tprivate boolean methodValidationApplicable;\n\n\n\t/**\n\t * Create a new {@code DefaultDataBinderFactory} instance.\n\t * @param initializer for global data binder initialization\n\t * (or {@code null} if none)\n\t */\n\tpublic DefaultDataBinderFactory(@Nullable WebBindingInitializer initializer) {\n\t\tthis.initializer = initializer;\n\t}\n\n\n\t/**\n\t * Configure flag to signal whether validation will be applied to handler\n\t * method arguments, which is the case if Bean Validation is enabled in\n\t * Spring MVC, and method parameters have {@code @Constraint} annotations.\n\t * @since 6.1\n\t */\n\tpublic void setMethodValidationApplicable(boolean methodValidationApplicable) {\n\t\tthis.methodValidationApplicable = methodValidationApplicable;\n\t}\n\n\n\t/**\n\t * Create a new {@link WebDataBinder} for the given target object and\n\t * initialize it through a {@link WebBindingInitializer}.\n\t * @throws Exception in case of invalid state or arguments\n\t */\n\t@Override\n\tpublic final WebDataBinder createBinder(\n\t\t\tNativeWebRequest webRequest, @Nullable Object target, String objectName) throws Exception {\n\n\t\treturn createBinderInternal(webRequest, target, objectName, null);\n\t}\n\n\t/**\n\t * {@inheritDoc}.\n\t * <p>By default, if the parameter has {@code @Valid}, Bean Validation is\n\t * excluded, deferring to method validation.\n\t */\n\t@Override\n\tpublic final WebDataBinder createBinder(\n\t\t\tNativeWebRequest webRequest, @Nullable Object target, String objectName,\n\t\t\tResolvableType type) throws Exception {\n\n\t\treturn createBinderInternal(webRequest, target, objectName, type);\n\t}\n\n\tprivate WebDataBinder createBinderInternal(\n\t\t\tNativeWebRequest webRequest, @Nullable Object target, String objectName,\n\t\t\t@Nullable ResolvableType type) throws Exception {\n\n\t\tWebDataBinder dataBinder = createBinderInstance(target, objectName, webRequest);\n\t\tdataBinder.setNameResolver(new BindParamNameResolver());\n\n\t\tif (target == null && type != null) {\n\t\t\tdataBinder.setTargetType(type);\n\t\t}\n\n\t\tif (this.initializer != null) {\n\t\t\tthis.initializer.initBinder(dataBinder);\n\t\t}\n\n\t\tinitBinder(dataBinder, webRequest);\n\n\t\tif (this.methodValidationApplicable && type != null) {\n\t\t\tif (type.getSource() instanceof MethodParameter parameter) {\n\t\t\t\tMethodValidationInitializer.initBinder(dataBinder, parameter);\n\t\t\t}\n\t\t}\n\n\t\treturn dataBinder;\n\t}\n\n\t/**\n\t * Extension point to create the WebDataBinder instance.\n\t * By default, this is {@code WebRequestDataBinder}.\n\t * @param target the binding target or {@code null} for type conversion only\n\t * @param objectName the binding target object name\n\t * @param webRequest the current request\n\t * @throws Exception in case of invalid state or arguments\n\t */\n\tprotected WebDataBinder createBinderInstance(\n\t\t\t@Nullable Object target, String objectName, NativeWebRequest webRequest) throws Exception {\n\n\t\treturn new WebRequestDataBinder(target, objectName);\n\t}\n\n\t/**\n\t * Extension point to further initialize the created data binder instance\n\t * (e.g. with {@code @InitBinder} methods) after \"global\" initialization\n\t * via {@link WebBindingInitializer}.\n\t * @param dataBinder the data binder instance to customize\n\t * @param webRequest the current request\n\t * @throws Exception if initialization fails\n\t */\n\tprotected void initBinder(WebDataBinder dataBinder, NativeWebRequest webRequest)\n\t\t\tthrows Exception {\n\n\t}\n\n\n\t/**\n\t * Excludes Bean Validation if the method parameter has {@code @Valid}.\n\t */\n\tprivate static class MethodValidationInitializer {\n\n\t\tpublic static void initBinder(DataBinder binder, MethodParameter parameter) {\n\t\t\tfor (Annotation annotation : parameter.getParameterAnnotations()) {\n\t\t\t\tif (annotation.annotationType().getName().equals(\"jakarta.validation.Valid\")) {\n\t\t\t\t\tbinder.setExcludedValidators(v -> v instanceof jakarta.validation.Validator ||\n\t\t\t\t\t\t\tv instanceof SmartValidator sv && sv.unwrap(jakarta.validation.Validator.class) != null);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.bind.support.DefaultDataBinderFactory#createBinder(webRequest,target,objectName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link WebDataBinder} for the given target object and\n\t * initialize it through a {@link WebBindingInitializer}.\n\t * @throws Exception in case of invalid state or arguments\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webRequest",
      "target",
      "objectName"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "WebDataBinder",
    "signature": "public WebDataBinder createBinder(NativeWebRequest webRequest, @Nullable Object target, String objectName)",
    "source_code": "\tpublic final WebDataBinder createBinder("
  },
  "org.springframework.web.bind.support.DefaultDataBinderFactory#createBinder(webRequest,target,objectName,type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}.\n\t * <p>By default, if the parameter has {@code @Valid}, Bean Validation is\n\t * excluded, deferring to method validation.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webRequest",
      "target",
      "objectName",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "WebDataBinder",
    "signature": "public WebDataBinder createBinder(NativeWebRequest webRequest, @Nullable Object target, String objectName,\n\t\t\tResolvableType type)",
    "source_code": "\tpublic final WebDataBinder createBinder("
  },
  "org.springframework.web.bind.support.DefaultDataBinderFactory#createBinderInstance(target,objectName,webRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extension point to create the WebDataBinder instance.\n\t * By default, this is {@code WebRequestDataBinder}.\n\t * @param target the binding target or {@code null} for type conversion only\n\t * @param objectName the binding target object name\n\t * @param webRequest the current request\n\t * @throws Exception in case of invalid state or arguments\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target",
      "objectName",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "WebDataBinder",
    "signature": "protected WebDataBinder createBinderInstance(@Nullable Object target, String objectName, NativeWebRequest webRequest)",
    "source_code": "\tprotected WebDataBinder createBinderInstance("
  },
  "org.springframework.web.bind.support.DefaultDataBinderFactory#initBinder(binder,parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "binder",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "void",
    "signature": "public void initBinder(DataBinder binder, MethodParameter parameter)",
    "source_code": "\t\tpublic static void initBinder(DataBinder binder, MethodParameter parameter) {\n\t\t\tfor (Annotation annotation : parameter.getParameterAnnotations()) {\n\t\t\t\tif (annotation.annotationType().getName().equals(\"jakarta.validation.Valid\")) {\n\t\t\t\t\tbinder.setExcludedValidators(v -> v instanceof jakarta.validation.Validator ||\n\t\t\t\t\t\t\tv instanceof SmartValidator sv && sv.unwrap(jakarta.validation.Validator.class) != null);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.bind.support.DefaultDataBinderFactory#initBinder(dataBinder,webRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extension point to further initialize the created data binder instance\n\t * (e.g. with {@code @InitBinder} methods) after \"global\" initialization\n\t * via {@link WebBindingInitializer}.\n\t * @param dataBinder the data binder instance to customize\n\t * @param webRequest the current request\n\t * @throws Exception if initialization fails\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "dataBinder",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "void",
    "signature": "protected void initBinder(WebDataBinder dataBinder, NativeWebRequest webRequest)",
    "source_code": "\tprotected void initBinder(WebDataBinder dataBinder, NativeWebRequest webRequest)"
  },
  "org.springframework.web.bind.support.DefaultDataBinderFactory#setMethodValidationApplicable(methodValidationApplicable)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure flag to signal whether validation will be applied to handler\n\t * method arguments, which is the case if Bean Validation is enabled in\n\t * Spring MVC, and method parameters have {@code @Constraint} annotations.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodValidationApplicable"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "void",
    "signature": "public void setMethodValidationApplicable(boolean methodValidationApplicable)",
    "source_code": "\tpublic void setMethodValidationApplicable(boolean methodValidationApplicable) {\n\t\tthis.methodValidationApplicable = methodValidationApplicable;\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeDataBinder#construct(exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Use a default or single data constructor to create the target by\n\t * binding request parameters, multipart files, or parts to constructor args.\n\t * <p>After the call, use {@link #getBindingResult()} to check for bind errors.\n\t * If there are none, the target is set, and {@link #bind} can be called for\n\t * further initialization via setters.\n\t * @param exchange the request to bind\n\t * @return a {@code Mono<Void>} that completes when the target is created\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> construct(ServerWebExchange exchange)",
    "source_code": "\tpublic Mono<Void> construct(ServerWebExchange exchange) {\n\t\treturn getValuesToBind(exchange)\n\t\t\t\t.doOnNext(map -> construct(new MapValueResolver(map)))\n\t\t\t\t.then();\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeDataBinder#getNames()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "Set<String>",
    "signature": "public Set<String> getNames()",
    "source_code": "\t\tpublic Set<String> getNames() {\n\t\t\treturn this.map.keySet();\n\t\t}"
  },
  "org.springframework.web.bind.support.WebExchangeDataBinder#resolveValue(name,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "Object",
    "signature": "public Object resolveValue(String name, Class<?> type)",
    "source_code": "\t\tpublic Object resolveValue(String name, Class<?> type) {\n\t\t\treturn this.map.get(name);\n\t\t}"
  },
  "org.springframework.web.bind.support.WebExchangeDataBinder#shouldConstructArgument(param)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "param"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "boolean",
    "signature": "protected boolean shouldConstructArgument(MethodParameter param)",
    "source_code": "\tprotected boolean shouldConstructArgument(MethodParameter param) {\n\t\tClass<?> type = param.nestedIfOptional().getNestedParameterType();\n\t\treturn (super.shouldConstructArgument(param) && !Part.class.isAssignableFrom(type));\n\t}"
  },
  "org.springframework.web.bind.support.WebRequestDataBinder#construct(request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Use a default or single data constructor to create the target by\n\t * binding request parameters, multipart files, or parts to constructor args.\n\t * <p>After the call, use {@link #getBindingResult()} to check for bind errors.\n\t * If there are none, the target is set, and {@link #bind(WebRequest)}\n\t * can be called for further initialization via setters.\n\t * @param request the request to bind\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "void",
    "signature": "public void construct(WebRequest request)",
    "source_code": "\tpublic void construct(WebRequest request) {\n\t\tif (request instanceof NativeWebRequest nativeRequest) {\n\t\t\tServletRequest servletRequest = nativeRequest.getNativeRequest(ServletRequest.class);\n\t\t\tif (servletRequest != null) {\n\t\t\t\tconstruct(ServletRequestDataBinder.valueResolver(servletRequest, this));\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.bind.support.WebRequestDataBinder#shouldConstructArgument(param)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "param"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "boolean",
    "signature": "protected boolean shouldConstructArgument(MethodParameter param)",
    "source_code": "\tprotected boolean shouldConstructArgument(MethodParameter param) {\n\t\tClass<?> type = param.nestedIfOptional().getNestedParameterType();\n\t\treturn (super.shouldConstructArgument(param) &&\n\t\t\t\t!MultipartFile.class.isAssignableFrom(type) && !Part.class.isAssignableFrom(type));\n\t}"
  },
  "org.springframework.web.client.<unknown>#accept(acceptableMediaTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "acceptableMediaTypes"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec accept(MediaType... acceptableMediaTypes)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec accept(MediaType... acceptableMediaTypes) {\n\t\t\tgetHeaders().setAccept(Arrays.asList(acceptableMediaTypes));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#acceptCharset(acceptableCharsets)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "acceptableCharsets"
    ],
    "position": {
      "column": 1,
      "line": 343
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec acceptCharset(Charset... acceptableCharsets)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec acceptCharset(Charset... acceptableCharsets) {\n\t\t\tgetHeaders().setAcceptCharset(Arrays.asList(acceptableCharsets));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#body(body)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body"
    ],
    "position": {
      "column": 1,
      "line": 392
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec body(StreamingHttpOutputMessage.Body body)",
    "source_code": "\t\tpublic RequestBodySpec body(StreamingHttpOutputMessage.Body body) {\n\t\t\tthis.body = request -> body.writeTo(request.getBody());\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#body(body,bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 386
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec body(T body, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\t\tpublic <T> RequestBodySpec body(T body, ParameterizedTypeReference<T> bodyType) {\n\t\t\tthis.body = clientHttpRequest -> writeWithMessageConverters(body, bodyType.getType(), clientHttpRequest);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#body(bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 618
    },
    "return": "T",
    "signature": "public T body(ParameterizedTypeReference<T> bodyType)",
    "source_code": "\t\tpublic <T> T body(ParameterizedTypeReference<T> bodyType) {\n\t\t\tType type = bodyType.getType();\n\t\t\tClass<T> bodyClass = bodyClass(type);\n\t\t\treturn readBody(type, bodyClass);\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#bodyTo(bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 710
    },
    "return": "T",
    "signature": "public T bodyTo(ParameterizedTypeReference<T> bodyType)",
    "source_code": "\t\tpublic <T> T bodyTo(ParameterizedTypeReference<T> bodyType) {\n\t\t\tType type = bodyType.getType();\n\t\t\tClass<T> bodyClass = bodyClass(type);\n\t\t\treturn readWithMessageConverters(this.delegate, () -> {} , type, bodyClass);\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#build()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 408
    },
    "return": "RestClient",
    "signature": "public RestClient build()",
    "source_code": "\tpublic RestClient build() {\n\t\tClientHttpRequestFactory requestFactory = initRequestFactory();\n\t\tUriBuilderFactory uriBuilderFactory = initUriBuilderFactory();\n\t\tHttpHeaders defaultHeaders = copyDefaultHeaders();\n\t\tList<HttpMessageConverter<?>> messageConverters = (this.messageConverters != null ?\n\t\t\t\tthis.messageConverters : initMessageConverters());\n\t\treturn new DefaultRestClient(requestFactory,\n\t\t\t\tthis.interceptors, this.initializers, uriBuilderFactory,\n\t\t\t\tdefaultHeaders,\n\t\t\t\tthis.defaultRequest,\n\t\t\t\tthis.statusHandlers,\n\t\t\t\tmessageConverters,\n\t\t\t\tthis.observationRegistry,\n\t\t\t\tthis.observationConvention,\n\t\t\t\tnew DefaultRestClientBuilder(this)\n\t\t\t\t);\n\t}"
  },
  "org.springframework.web.client.<unknown>#close()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 737
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\t\tpublic void close() {\n\t\t\tthis.delegate.close();\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#contentLength(contentLength)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentLength"
    ],
    "position": {
      "column": 1,
      "line": 355
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec contentLength(long contentLength)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec contentLength(long contentLength) {\n\t\t\tgetHeaders().setContentLength(contentLength);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#contentType(contentType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 349
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec contentType(MediaType contentType)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec contentType(MediaType contentType) {\n\t\t\tgetHeaders().setContentType(contentType);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#exchange(exchangeFunction,close)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchangeFunction",
      "close"
    ],
    "position": {
      "column": 1,
      "line": 448
    },
    "return": "T",
    "signature": "public T exchange(ExchangeFunction<T> exchangeFunction, boolean close)",
    "source_code": "\t\tpublic <T> T exchange(ExchangeFunction<T> exchangeFunction, boolean close) {\n\t\t\treturn exchangeInternal(exchangeFunction, close);\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#getBody()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 717
    },
    "return": "InputStream",
    "signature": "public InputStream getBody()",
    "source_code": "\t\tpublic InputStream getBody() throws IOException {\n\t\t\treturn this.delegate.getBody();\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#getHeaders()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 722
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders getHeaders()",
    "source_code": "\t\tpublic HttpHeaders getHeaders() {\n\t\t\treturn this.delegate.getHeaders();\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#getStatusCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 727
    },
    "return": "HttpStatusCode",
    "signature": "public HttpStatusCode getStatusCode()",
    "source_code": "\t\tpublic HttpStatusCode getStatusCode() throws IOException {\n\t\t\treturn this.delegate.getStatusCode();\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#getStatusText()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 732
    },
    "return": "String",
    "signature": "public String getStatusText()",
    "source_code": "\t\tpublic String getStatusText() throws IOException {\n\t\t\treturn this.delegate.getStatusText();\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#header(headerName,headerValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec header(String headerName, String... headerValues)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec header(String headerName, String... headerValues) {\n\t\t\tfor (String headerValue : headerValues) {\n\t\t\t\tgetHeaders().add(headerName, headerValue);\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#headers(headersConsumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headersConsumer"
    ],
    "position": {
      "column": 1,
      "line": 331
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec headers(Consumer<HttpHeaders> headersConsumer)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec headers(Consumer<HttpHeaders> headersConsumer) {\n\t\t\theadersConsumer.accept(getHeaders());\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#httpRequest(requestConsumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestConsumer"
    ],
    "position": {
      "column": 1,
      "line": 373
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec httpRequest(Consumer<ClientHttpRequest> requestConsumer)",
    "source_code": "\t\tpublic RequestBodySpec httpRequest(Consumer<ClientHttpRequest> requestConsumer) {\n\t\t\tthis.httpRequestConsumer = (this.httpRequestConsumer != null ?\n\t\t\t\t\tthis.httpRequestConsumer.andThen(requestConsumer) : requestConsumer);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#ifModifiedSince(ifModifiedSince)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ifModifiedSince"
    ],
    "position": {
      "column": 1,
      "line": 361
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec ifModifiedSince(ZonedDateTime ifModifiedSince)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec ifModifiedSince(ZonedDateTime ifModifiedSince) {\n\t\t\tgetHeaders().setIfModifiedSince(ifModifiedSince);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#ifNoneMatch(ifNoneMatches)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ifNoneMatches"
    ],
    "position": {
      "column": 1,
      "line": 367
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec ifNoneMatch(String... ifNoneMatches)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec ifNoneMatch(String... ifNoneMatches) {\n\t\t\tgetHeaders().setIfNoneMatch(Arrays.asList(ifNoneMatches));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#method(method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "RequestBodyUriSpec",
    "signature": "public RequestBodyUriSpec method(HttpMethod method)",
    "source_code": "\tpublic RequestBodyUriSpec method(HttpMethod method) {\n\t\tAssert.notNull(method, \"HttpMethod must not be null\");\n\t\treturn methodInternal(method);\n\t}"
  },
  "org.springframework.web.client.<unknown>#mutate()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "Builder",
    "signature": "public Builder mutate()",
    "source_code": "\tpublic Builder mutate() {\n\t\treturn new DefaultRestClientBuilder(this.builder);\n\t}"
  },
  "org.springframework.web.client.<unknown>#onStatus(errorHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorHandler"
    ],
    "position": {
      "column": 1,
      "line": 596
    },
    "return": "ResponseSpec",
    "signature": "public ResponseSpec onStatus(ResponseErrorHandler errorHandler)",
    "source_code": "\t\tpublic ResponseSpec onStatus(ResponseErrorHandler errorHandler) {\n\t\t\tAssert.notNull(errorHandler, \"ResponseErrorHandler must not be null\");\n\n\t\t\treturn onStatusInternal(StatusHandler.fromErrorHandler(errorHandler));\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#onStatus(statusPredicate,errorHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusPredicate",
      "errorHandler"
    ],
    "position": {
      "column": 1,
      "line": 588
    },
    "return": "ResponseSpec",
    "signature": "public ResponseSpec onStatus(Predicate<HttpStatusCode> statusPredicate, ErrorHandler errorHandler)",
    "source_code": "\t\tpublic ResponseSpec onStatus(Predicate<HttpStatusCode> statusPredicate, ErrorHandler errorHandler) {\n\t\t\tAssert.notNull(statusPredicate, \"StatusPredicate must not be null\");\n\t\t\tAssert.notNull(errorHandler, \"ErrorHandler must not be null\");\n\n\t\t\treturn onStatusInternal(StatusHandler.of(statusPredicate, errorHandler));\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#patch()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "RequestBodyUriSpec",
    "signature": "public RequestBodyUriSpec patch()",
    "source_code": "\tpublic RequestBodyUriSpec patch() {\n\t\treturn methodInternal(HttpMethod.PATCH);\n\t}"
  },
  "org.springframework.web.client.<unknown>#post()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "RequestBodyUriSpec",
    "signature": "public RequestBodyUriSpec post()",
    "source_code": "\tpublic RequestBodyUriSpec post() {\n\t\treturn methodInternal(HttpMethod.POST);\n\t}"
  },
  "org.springframework.web.client.<unknown>#put()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "RequestBodyUriSpec",
    "signature": "public RequestBodyUriSpec put()",
    "source_code": "\tpublic RequestBodyUriSpec put() {\n\t\treturn methodInternal(HttpMethod.PUT);\n\t}"
  },
  "org.springframework.web.client.<unknown>#retrieve()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 443
    },
    "return": "ResponseSpec",
    "signature": "public ResponseSpec retrieve()",
    "source_code": "\t\tpublic ResponseSpec retrieve() {\n\t\t\treturn exchangeInternal(DefaultResponseSpec::new, false);\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#toBodilessEntity()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 649
    },
    "return": "ResponseEntity<Void>",
    "signature": "public ResponseEntity<Void> toBodilessEntity()",
    "source_code": "\t\tpublic ResponseEntity<Void> toBodilessEntity() {\n\t\t\ttry (this.clientResponse) {\n\t\t\t\tapplyStatusHandlers();\n\t\t\t\treturn ResponseEntity.status(this.clientResponse.getStatusCode())\n\t\t\t\t\t\t.headers(this.clientResponse.getHeaders())\n\t\t\t\t\t\t.build();\n\t\t\t}\n\t\t\tcatch (UncheckedIOException ex) {\n\t\t\t\tthrow new ResourceAccessException(\"Could not retrieve response status code: \" + ex.getMessage(), ex.getCause());\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new ResourceAccessException(\"Could not retrieve response status code: \" + ex.getMessage(), ex);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#toEntity(bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 630
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> toEntity(ParameterizedTypeReference<T> bodyType)",
    "source_code": "\t\tpublic <T> ResponseEntity<T> toEntity(ParameterizedTypeReference<T> bodyType) {\n\t\t\tType type = bodyType.getType();\n\t\t\tClass<T> bodyClass = bodyClass(type);\n\t\t\treturn toEntityInternal(type, bodyClass);\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#uri(Function<UriBuilder,uriFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<UriBuilder",
      "uriFunction"
    ],
    "position": {
      "column": 1,
      "line": 305
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(Function<UriBuilder, URI> uriFunction)",
    "source_code": "\t\tpublic RequestBodySpec uri(Function<UriBuilder, URI> uriFunction) {\n\t\t\treturn uri(uriFunction.apply(DefaultRestClient.this.uriBuilderFactory.builder()));\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#uri(uri)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uri"
    ],
    "position": {
      "column": 1,
      "line": 310
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(URI uri)",
    "source_code": "\t\tpublic RequestBodySpec uri(URI uri) {\n\t\t\tthis.uri = uri;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#uri(uriTemplate,Function<UriBuilder,uriFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "Function<UriBuilder",
      "uriFunction"
    ],
    "position": {
      "column": 1,
      "line": 299
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, Function<UriBuilder, URI> uriFunction)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, Function<UriBuilder, URI> uriFunction) {\n\t\t\tthis.uriTemplate = uriTemplate;\n\t\t\treturn uri(uriFunction.apply(DefaultRestClient.this.uriBuilderFactory.uriString(uriTemplate)));\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#uri(uriTemplate,Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, Map<String, ?> uriVariables)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, Map<String, ?> uriVariables) {\n\t\t\tthis.uriTemplate = uriTemplate;\n\t\t\treturn uri(DefaultRestClient.this.uriBuilderFactory.expand(uriTemplate, uriVariables));\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#uri(uriTemplate,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, Object... uriVariables)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, Object... uriVariables) {\n\t\t\tthis.uriTemplate = uriTemplate;\n\t\t\treturn uri(DefaultRestClient.this.uriBuilderFactory.expand(uriTemplate, uriVariables));\n\t\t}"
  },
  "org.springframework.web.client.RestTemplate#getObservationConvention()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured {@link ClientRequestObservationConvention}, or {@code null} if not set.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 391
    },
    "return": "ClientRequestObservationConvention",
    "signature": "public ClientRequestObservationConvention getObservationConvention()",
    "source_code": "\tpublic ClientRequestObservationConvention getObservationConvention() {\n\t\treturn this.observationConvention;\n\t}"
  },
  "org.springframework.web.client.RestTemplate#getObservationRegistry()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured {@link ObservationRegistry}.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 368
    },
    "return": "ObservationRegistry",
    "signature": "public ObservationRegistry getObservationRegistry()",
    "source_code": "\tpublic ObservationRegistry getObservationRegistry() {\n\t\treturn this.observationRegistry;\n\t}"
  },
  "org.springframework.web.context.request.FacesRequestAttributes": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link RequestAttributes} adapter for a JSF {@link jakarta.faces.context.FacesContext}.\n * Used as default in a JSF environment, wrapping the current FacesContext.\n *\n * <p><b>NOTE:</b> In contrast to {@link ServletRequestAttributes}, this variant does\n * <i>not</i> support destruction callbacks for scoped attributes, neither for the\n * request scope nor for the session scope. If you rely on such implicit destruction\n * callbacks, consider defining a Spring {@link RequestContextListener} in your\n * {@code web.xml}.\n *\n * <p>Requires JSF 2.0 or higher, as of Spring 4.0.\n *\n * @author Juergen Hoeller\n * @since 2.5.2\n * @see jakarta.faces.context.FacesContext#getExternalContext()\n * @see jakarta.faces.context.ExternalContext#getRequestMap()\n * @see jakarta.faces.context.ExternalContext#getSessionMap()\n * @see RequestContextHolder#currentRequestAttributes()\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "signature": "public class FacesRequestAttributes",
    "source_code": "public class FacesRequestAttributes implements RequestAttributes {\n\n\t/**\n\t * We'll create a lot of these objects, so we don't want a new logger every time.\n\t */\n\tprivate static final Log logger = LogFactory.getLog(FacesRequestAttributes.class);\n\n\tprivate final FacesContext facesContext;\n\n\n\t/**\n\t * Create a new FacesRequestAttributes adapter for the given FacesContext.\n\t * @param facesContext the current FacesContext\n\t * @see jakarta.faces.context.FacesContext#getCurrentInstance()\n\t */\n\tpublic FacesRequestAttributes(FacesContext facesContext) {\n\t\tAssert.notNull(facesContext, \"FacesContext must not be null\");\n\t\tthis.facesContext = facesContext;\n\t}\n\n\n\t/**\n\t * Return the JSF FacesContext that this adapter operates on.\n\t */\n\tprotected final FacesContext getFacesContext() {\n\t\treturn this.facesContext;\n\t}\n\n\t/**\n\t * Return the JSF ExternalContext that this adapter operates on.\n\t * @see jakarta.faces.context.FacesContext#getExternalContext()\n\t */\n\tprotected final ExternalContext getExternalContext() {\n\t\treturn getFacesContext().getExternalContext();\n\t}\n\n\t/**\n\t * Return the JSF attribute Map for the specified scope.\n\t * @param scope constant indicating request or session scope\n\t * @return the Map representation of the attributes in the specified scope\n\t * @see #SCOPE_REQUEST\n\t * @see #SCOPE_SESSION\n\t */\n\tprotected Map<String, Object> getAttributeMap(int scope) {\n\t\tif (scope == SCOPE_REQUEST) {\n\t\t\treturn getExternalContext().getRequestMap();\n\t\t}\n\t\telse {\n\t\t\treturn getExternalContext().getSessionMap();\n\t\t}\n\t}\n\n\n\t@Override\n\t@Nullable\n\tpublic Object getAttribute(String name, int scope) {\n\t\treturn getAttributeMap(scope).get(name);\n\t}\n\n\t@Override\n\tpublic void setAttribute(String name, Object value, int scope) {\n\t\tgetAttributeMap(scope).put(name, value);\n\t}\n\n\t@Override\n\tpublic void removeAttribute(String name, int scope) {\n\t\tgetAttributeMap(scope).remove(name);\n\t}\n\n\t@Override\n\tpublic String[] getAttributeNames(int scope) {\n\t\treturn StringUtils.toStringArray(getAttributeMap(scope).keySet());\n\t}\n\n\t@Override\n\tpublic void registerDestructionCallback(String name, Runnable callback, int scope) {\n\t\tif (logger.isWarnEnabled()) {\n\t\t\tlogger.warn(\"Could not register destruction callback [\" + callback + \"] for attribute '\" + name +\n\t\t\t\t\t\"' because FacesRequestAttributes does not support such callbacks\");\n\t\t}\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Object resolveReference(String key) {\n\t\treturn switch (key) {\n\t\t\tcase REFERENCE_REQUEST -> getExternalContext().getRequest();\n\t\t\tcase REFERENCE_SESSION -> getExternalContext().getSession(true);\n\t\t\tcase \"application\" -> getExternalContext().getContext();\n\t\t\tcase \"requestScope\" -> getExternalContext().getRequestMap();\n\t\t\tcase \"sessionScope\" -> getExternalContext().getSessionMap();\n\t\t\tcase \"applicationScope\" -> getExternalContext().getApplicationMap();\n\t\t\tcase \"facesContext\" -> getFacesContext();\n\t\t\tcase \"cookie\" -> getExternalContext().getRequestCookieMap();\n\t\t\tcase \"header\" -> getExternalContext().getRequestHeaderMap();\n\t\t\tcase \"headerValues\" -> getExternalContext().getRequestHeaderValuesMap();\n\t\t\tcase \"param\" -> getExternalContext().getRequestParameterMap();\n\t\t\tcase \"paramValues\" -> getExternalContext().getRequestParameterValuesMap();\n\t\t\tcase \"initParam\" -> getExternalContext().getInitParameterMap();\n\t\t\tcase \"view\" -> getFacesContext().getViewRoot();\n\t\t\tcase \"viewScope\" -> getFacesContext().getViewRoot().getViewMap();\n\t\t\tcase \"flash\" -> getExternalContext().getFlash();\n\t\t\tcase \"resource\" -> getFacesContext().getApplication().getResourceHandler();\n\t\t\tdefault -> null;\n\t\t};\n\t}\n\n\t@Override\n\tpublic String getSessionId() {\n\t\tObject session = getExternalContext().getSession(true);\n\t\ttry {\n\t\t\t// HttpSession has a getId() method.\n\t\t\tMethod getIdMethod = session.getClass().getMethod(\"getId\");\n\t\t\treturn String.valueOf(ReflectionUtils.invokeMethod(getIdMethod, session));\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\tthrow new IllegalStateException(\"Session object [\" + session + \"] does not have a getId() method\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic Object getSessionMutex() {\n\t\t// Enforce presence of a session first to allow listeners to create the mutex attribute\n\t\tExternalContext externalContext = getExternalContext();\n\t\tObject session = externalContext.getSession(true);\n\t\tObject mutex = externalContext.getSessionMap().get(WebUtils.SESSION_MUTEX_ATTRIBUTE);\n\t\tif (mutex == null) {\n\t\t\tmutex = (session != null ? session : externalContext);\n\t\t}\n\t\treturn mutex;\n\t}\n\n}"
  },
  "org.springframework.web.context.request.FacesRequestAttributes#getAttribute(name,scope)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "Object",
    "signature": "public Object getAttribute(String name, int scope)",
    "source_code": "\tpublic Object getAttribute(String name, int scope) {\n\t\treturn getAttributeMap(scope).get(name);\n\t}"
  },
  "org.springframework.web.context.request.FacesRequestAttributes#getAttributeMap(scope)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the JSF attribute Map for the specified scope.\n\t * @param scope constant indicating request or session scope\n\t * @return the Map representation of the attributes in the specified scope\n\t * @see #SCOPE_REQUEST\n\t * @see #SCOPE_SESSION\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "Object>",
    "signature": "protected Object> getAttributeMap(int scope)",
    "source_code": "\tprotected Map<String, Object> getAttributeMap(int scope) {\n\t\tif (scope == SCOPE_REQUEST) {\n\t\t\treturn getExternalContext().getRequestMap();\n\t\t}\n\t\telse {\n\t\t\treturn getExternalContext().getSessionMap();\n\t\t}\n\t}"
  },
  "org.springframework.web.context.request.FacesRequestAttributes#getAttributeNames(scope)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "String[]",
    "signature": "public String[] getAttributeNames(int scope)",
    "source_code": "\tpublic String[] getAttributeNames(int scope) {\n\t\treturn StringUtils.toStringArray(getAttributeMap(scope).keySet());\n\t}"
  },
  "org.springframework.web.context.request.FacesRequestAttributes#getExternalContext()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the JSF ExternalContext that this adapter operates on.\n\t * @see jakarta.faces.context.FacesContext#getExternalContext()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "ExternalContext",
    "signature": "protected ExternalContext getExternalContext()",
    "source_code": "\tprotected final ExternalContext getExternalContext() {\n\t\treturn getFacesContext().getExternalContext();\n\t}"
  },
  "org.springframework.web.context.request.FacesRequestAttributes#getFacesContext()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the JSF FacesContext that this adapter operates on.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "FacesContext",
    "signature": "protected FacesContext getFacesContext()",
    "source_code": "\tprotected final FacesContext getFacesContext() {\n\t\treturn this.facesContext;\n\t}"
  },
  "org.springframework.web.context.request.FacesRequestAttributes#getSessionId()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "String",
    "signature": "public String getSessionId()",
    "source_code": "\tpublic String getSessionId() {\n\t\tObject session = getExternalContext().getSession(true);\n\t\ttry {\n\t\t\t// HttpSession has a getId() method.\n\t\t\tMethod getIdMethod = session.getClass().getMethod(\"getId\");\n\t\t\treturn String.valueOf(ReflectionUtils.invokeMethod(getIdMethod, session));\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\tthrow new IllegalStateException(\"Session object [\" + session + \"] does not have a getId() method\");\n\t\t}\n\t}"
  },
  "org.springframework.web.context.request.FacesRequestAttributes#getSessionMutex()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "Object",
    "signature": "public Object getSessionMutex()",
    "source_code": "\tpublic Object getSessionMutex() {\n\t\t// Enforce presence of a session first to allow listeners to create the mutex attribute\n\t\tExternalContext externalContext = getExternalContext();\n\t\tObject session = externalContext.getSession(true);\n\t\tObject mutex = externalContext.getSessionMap().get(WebUtils.SESSION_MUTEX_ATTRIBUTE);\n\t\tif (mutex == null) {\n\t\t\tmutex = (session != null ? session : externalContext);\n\t\t}\n\t\treturn mutex;\n\t}"
  },
  "org.springframework.web.context.request.FacesRequestAttributes#registerDestructionCallback(name,callback,scope)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "callback",
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void registerDestructionCallback(String name, Runnable callback, int scope)",
    "source_code": "\tpublic void registerDestructionCallback(String name, Runnable callback, int scope) {\n\t\tif (logger.isWarnEnabled()) {\n\t\t\tlogger.warn(\"Could not register destruction callback [\" + callback + \"] for attribute '\" + name +\n\t\t\t\t\t\"' because FacesRequestAttributes does not support such callbacks\");\n\t\t}\n\t}"
  },
  "org.springframework.web.context.request.FacesRequestAttributes#removeAttribute(name,scope)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "void",
    "signature": "public void removeAttribute(String name, int scope)",
    "source_code": "\tpublic void removeAttribute(String name, int scope) {\n\t\tgetAttributeMap(scope).remove(name);\n\t}"
  },
  "org.springframework.web.context.request.FacesRequestAttributes#resolveReference(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "Object",
    "signature": "public Object resolveReference(String key)",
    "source_code": "\tpublic Object resolveReference(String key) {\n\t\treturn switch (key) {\n\t\t\tcase REFERENCE_REQUEST -> getExternalContext().getRequest();\n\t\t\tcase REFERENCE_SESSION -> getExternalContext().getSession(true);\n\t\t\tcase \"application\" -> getExternalContext().getContext();\n\t\t\tcase \"requestScope\" -> getExternalContext().getRequestMap();\n\t\t\tcase \"sessionScope\" -> getExternalContext().getSessionMap();\n\t\t\tcase \"applicationScope\" -> getExternalContext().getApplicationMap();\n\t\t\tcase \"facesContext\" -> getFacesContext();\n\t\t\tcase \"cookie\" -> getExternalContext().getRequestCookieMap();\n\t\t\tcase \"header\" -> getExternalContext().getRequestHeaderMap();\n\t\t\tcase \"headerValues\" -> getExternalContext().getRequestHeaderValuesMap();\n\t\t\tcase \"param\" -> getExternalContext().getRequestParameterMap();\n\t\t\tcase \"paramValues\" -> getExternalContext().getRequestParameterValuesMap();\n\t\t\tcase \"initParam\" -> getExternalContext().getInitParameterMap();\n\t\t\tcase \"view\" -> getFacesContext().getViewRoot();\n\t\t\tcase \"viewScope\" -> getFacesContext().getViewRoot().getViewMap();\n\t\t\tcase \"flash\" -> getExternalContext().getFlash();\n\t\t\tcase \"resource\" -> getFacesContext().getApplication().getResourceHandler();\n\t\t\tdefault -> null;\n\t\t};\n\t}"
  },
  "org.springframework.web.context.request.FacesRequestAttributes#setAttribute(name,value,scope)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value",
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "public void setAttribute(String name, Object value, int scope)",
    "source_code": "\tpublic void setAttribute(String name, Object value, int scope) {\n\t\tgetAttributeMap(scope).put(name, value);\n\t}"
  },
  "org.springframework.web.method.HandlerMethod#checkArguments(beanType,parameters)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanType",
      "parameters"
    ],
    "position": {
      "column": 1,
      "line": 408
    },
    "return": "boolean",
    "signature": "public boolean checkArguments(Class<?> beanType, MethodParameter[] parameters)",
    "source_code": "\t\tpublic static boolean checkArguments(Class<?> beanType, MethodParameter[] parameters) {\n\t\t\tif (BEAN_VALIDATION_PRESENT && AnnotationUtils.findAnnotation(beanType, Validated.class) == null) {\n\t\t\t\tfor (MethodParameter param : parameters) {\n\t\t\t\t\tMergedAnnotations merged = MergedAnnotations.from(param.getParameterAnnotations());\n\t\t\t\t\tif (merged.stream().anyMatch(CONSTRAINT_PREDICATE)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tClass<?> type = param.getParameterType();\n\t\t\t\t\tif (merged.stream().anyMatch(VALID_PREDICATE) && isIndexOrKeyBasedContainer(type)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tmerged = MergedAnnotations.from(getContainerElementAnnotations(param));\n\t\t\t\t\tif (merged.stream().anyMatch(CONSTRAINT_PREDICATE)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.web.method.HandlerMethod#checkReturnValue(beanType,method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanType",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 428
    },
    "return": "boolean",
    "signature": "public boolean checkReturnValue(Class<?> beanType, Method method)",
    "source_code": "\t\tpublic static boolean checkReturnValue(Class<?> beanType, Method method) {\n\t\t\tif (BEAN_VALIDATION_PRESENT && AnnotationUtils.findAnnotation(beanType, Validated.class) == null) {\n\t\t\t\tMergedAnnotations merged = MergedAnnotations.from(method, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY);\n\t\t\t\treturn merged.stream().anyMatch(CONSTRAINT_PREDICATE.or(VALID_PREDICATE));\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.web.method.HandlerMethod#clone()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 597
    },
    "return": "ReturnValueMethodParameter",
    "signature": "public ReturnValueMethodParameter clone()",
    "source_code": "\t\tpublic ReturnValueMethodParameter clone() {\n\t\t\treturn new ReturnValueMethodParameter(this);\n\t\t}"
  },
  "org.springframework.web.method.HandlerMethod#createWithValidateFlags()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Re-create the HandlerMethod and initialize\n\t * {@link #shouldValidateArguments()} and {@link #shouldValidateReturnValue()}.\n\t * @since 6.1.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 315
    },
    "return": "HandlerMethod",
    "signature": "public HandlerMethod createWithValidateFlags()",
    "source_code": "\tpublic HandlerMethod createWithValidateFlags() {\n\t\treturn new HandlerMethod(this, null, true);\n\t}"
  },
  "org.springframework.web.method.HandlerMethod#findProvidedArgument(parameter,providedArgs)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 446
    },
    "return": "Object",
    "signature": "protected Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs)",
    "source_code": "\tprotected static Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs) {\n\t\tif (!ObjectUtils.isEmpty(providedArgs)) {\n\t\t\tfor (Object providedArg : providedArgs) {\n\t\t\t\tif (parameter.getParameterType().isInstance(providedArg)) {\n\t\t\t\t\treturn providedArg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.method.HandlerMethod#formatArgumentError(param,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "param",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 457
    },
    "return": "String",
    "signature": "protected String formatArgumentError(MethodParameter param, String message)",
    "source_code": "\tprotected static String formatArgumentError(MethodParameter param, String message) {\n\t\treturn \"Could not resolve parameter [\" + param.getParameterIndex() + \"] in \" +\n\t\t\t\tparam.getExecutable().toGenericString() + (StringUtils.hasText(message) ? \": \" + message : \"\");\n\t}"
  },
  "org.springframework.web.method.HandlerMethod#getBridgedMethod()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * If the bean method is a bridge method, this method returns the bridged\n\t * (user-defined) method. Otherwise, it returns the same method as {@link #getMethod()}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 283
    },
    "return": "Method",
    "signature": "protected Method getBridgedMethod()",
    "source_code": "\tprotected Method getBridgedMethod() {\n\t\treturn this.bridgedMethod;\n\t}"
  },
  "org.springframework.web.method.HandlerMethod#getMethod()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 512
    },
    "return": "Method",
    "signature": "public Method getMethod()",
    "source_code": "\t\tpublic Method getMethod() {\n\t\t\treturn HandlerMethod.this.bridgedMethod;\n\t\t}"
  },
  "org.springframework.web.method.HandlerMethod#getMethodAnnotation(annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 522
    },
    "return": "T",
    "signature": "public T getMethodAnnotation(Class<T> annotationType)",
    "source_code": "\t\tpublic <T extends Annotation> T getMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn HandlerMethod.this.getMethodAnnotation(annotationType);\n\t\t}"
  },
  "org.springframework.web.method.HandlerMethod#getMethodParameters()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the method parameters for this handler method.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "MethodParameter[]",
    "signature": "public MethodParameter[] getMethodParameters()",
    "source_code": "\tpublic MethodParameter[] getMethodParameters() {\n\t\treturn this.parameters;\n\t}"
  },
  "org.springframework.web.method.HandlerMethod#getParameterAnnotations()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 532
    },
    "return": "Annotation[]",
    "signature": "public Annotation[] getParameterAnnotations()",
    "source_code": "\t\tpublic Annotation[] getParameterAnnotations() {\n\t\t\tAnnotation[] anns = this.combinedAnnotations;\n\t\t\tif (anns == null) {\n\t\t\t\tanns = super.getParameterAnnotations();\n\t\t\t\tint index = getParameterIndex();\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tfor (Annotation[][] ifcAnns : getInterfaceParameterAnnotations()) {\n\t\t\t\t\t\tif (index < ifcAnns.length) {\n\t\t\t\t\t\t\tAnnotation[] paramAnns = ifcAnns[index];\n\t\t\t\t\t\t\tif (paramAnns.length > 0) {\n\t\t\t\t\t\t\t\tList<Annotation> merged = new ArrayList<>(anns.length + paramAnns.length);\n\t\t\t\t\t\t\t\tmerged.addAll(Arrays.asList(anns));\n\t\t\t\t\t\t\t\tfor (Annotation paramAnn : paramAnns) {\n\t\t\t\t\t\t\t\t\tboolean existingType = false;\n\t\t\t\t\t\t\t\t\tfor (Annotation ann : anns) {\n\t\t\t\t\t\t\t\t\t\tif (ann.annotationType() == paramAnn.annotationType()) {\n\t\t\t\t\t\t\t\t\t\t\texistingType = true;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!existingType) {\n\t\t\t\t\t\t\t\t\t\tmerged.add(adaptAnnotation(paramAnn));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tanns = merged.toArray(new Annotation[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.combinedAnnotations = anns;\n\t\t\t}\n\t\t\treturn anns;\n\t\t}"
  },
  "org.springframework.web.method.HandlerMethod#getReturnType()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the HandlerMethod return type.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 317
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter getReturnType()",
    "source_code": "\tpublic MethodParameter getReturnType() {\n\t\treturn new HandlerMethodParameter(-1);\n\t}"
  },
  "org.springframework.web.method.HandlerMethod#getReturnValueType(returnValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the actual return value type.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue"
    ],
    "position": {
      "column": 1,
      "line": 324
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter getReturnValueType(@Nullable Object returnValue)",
    "source_code": "\tpublic MethodParameter getReturnValueType(@Nullable Object returnValue) {\n\t\treturn new ReturnValueMethodParameter(returnValue);\n\t}"
  },
  "org.springframework.web.method.HandlerMethod#hasMethodAnnotation(annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 527
    },
    "return": "boolean",
    "signature": "public boolean hasMethodAnnotation(Class<T> annotationType)",
    "source_code": "\t\tpublic <T extends Annotation> boolean hasMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn HandlerMethod.this.hasMethodAnnotation(annotationType);\n\t\t}"
  },
  "org.springframework.web.method.HandlerMethod#isVoid()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return {@code true} if the method return type is void, {@code false} otherwise.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 331
    },
    "return": "boolean",
    "signature": "public boolean isVoid()",
    "source_code": "\tpublic boolean isVoid() {\n\t\treturn Void.TYPE.equals(getReturnType().getParameterType());\n\t}"
  },
  "org.springframework.web.method.HandlerMethod#shouldValidateArguments()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the method arguments are a candidate for method validation, which\n\t * is the case when there are parameter {@code jakarta.validation.Constraint}\n\t * annotations.\n\t * <p>The presence of {@code jakarta.validation.Valid} by itself does not\n\t * trigger method validation since such parameters are already validated at\n\t * the level of argument resolvers.\n\t * <p><strong>Note:</strong> if the class is annotated with {@link Validated},\n\t * this method returns false, deferring to method validation via AOP proxy.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 265
    },
    "return": "boolean",
    "signature": "public boolean shouldValidateArguments()",
    "source_code": "\tpublic boolean shouldValidateArguments() {\n\t\treturn this.validateArguments;\n\t}"
  },
  "org.springframework.web.method.HandlerMethod#shouldValidateReturnValue()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the method return value is a candidate for method validation, which\n\t * is the case when there are method {@code jakarta.validation.Constraint}\n\t * or {@code jakarta.validation.Valid} annotations.\n\t * <p><strong>Note:</strong> if the class is annotated with {@link Validated},\n\t * this method returns false, deferring to method validation via AOP proxy.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 277
    },
    "return": "boolean",
    "signature": "public boolean shouldValidateReturnValue()",
    "source_code": "\tpublic boolean shouldValidateReturnValue() {\n\t\treturn this.validateReturnValue;\n\t}"
  },
  "org.springframework.web.method.HandlerMethodParameter": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * A MethodParameter with HandlerMethod-specific behavior.\n\t */",
    "kind": "class",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 497
    },
    "signature": "protected class HandlerMethodParameter",
    "source_code": "\tprotected class HandlerMethodParameter extends SynthesizingMethodParameter {\n\n\t\t@Nullable\n\t\tprivate volatile Annotation[] combinedAnnotations;\n\n\t\tpublic HandlerMethodParameter(int index) {\n\t\t\tsuper(HandlerMethod.this.bridgedMethod, index);\n\t\t}\n\n\t\tprotected HandlerMethodParameter(HandlerMethodParameter original) {\n\t\t\tsuper(original);\n\t\t}\n\n\t\t@Override\n\t\t@NonNull\n\t\tpublic Method getMethod() {\n\t\t\treturn HandlerMethod.this.bridgedMethod;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<?> getContainingClass() {\n\t\t\treturn HandlerMethod.this.getBeanType();\n\t\t}\n\n\t\t@Override\n\t\tpublic <T extends Annotation> T getMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn HandlerMethod.this.getMethodAnnotation(annotationType);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T extends Annotation> boolean hasMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn HandlerMethod.this.hasMethodAnnotation(annotationType);\n\t\t}\n\n\t\t@Override\n\t\tpublic Annotation[] getParameterAnnotations() {\n\t\t\tAnnotation[] anns = this.combinedAnnotations;\n\t\t\tif (anns == null) {\n\t\t\t\tanns = super.getParameterAnnotations();\n\t\t\t\tint index = getParameterIndex();\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tfor (Annotation[][] ifcAnns : getInterfaceParameterAnnotations()) {\n\t\t\t\t\t\tif (index < ifcAnns.length) {\n\t\t\t\t\t\t\tAnnotation[] paramAnns = ifcAnns[index];\n\t\t\t\t\t\t\tif (paramAnns.length > 0) {\n\t\t\t\t\t\t\t\tList<Annotation> merged = new ArrayList<>(anns.length + paramAnns.length);\n\t\t\t\t\t\t\t\tmerged.addAll(Arrays.asList(anns));\n\t\t\t\t\t\t\t\tfor (Annotation paramAnn : paramAnns) {\n\t\t\t\t\t\t\t\t\tboolean existingType = false;\n\t\t\t\t\t\t\t\t\tfor (Annotation ann : anns) {\n\t\t\t\t\t\t\t\t\t\tif (ann.annotationType() == paramAnn.annotationType()) {\n\t\t\t\t\t\t\t\t\t\t\texistingType = true;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!existingType) {\n\t\t\t\t\t\t\t\t\t\tmerged.add(adaptAnnotation(paramAnn));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tanns = merged.toArray(new Annotation[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.combinedAnnotations = anns;\n\t\t\t}\n\t\t\treturn anns;\n\t\t}\n\n\t\t@Override\n\t\tpublic HandlerMethodParameter clone() {\n\t\t\treturn new HandlerMethodParameter(this);\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract base class for resolving method arguments from a named value.\n * Request parameters, request headers, and path variables are examples of named\n * values. Each may have a name, a required flag, and a default value.\n *\n * <p>Subclasses define how to do the following:\n * <ul>\n * <li>Obtain named value information for a method parameter\n * <li>Resolve names into argument values\n * <li>Handle missing argument values when argument values are required\n * <li>Optionally handle a resolved value\n * </ul>\n *\n * <p>A default value string can contain ${...} placeholders and Spring Expression\n * Language #{...} expressions. For this to work a\n * {@link ConfigurableBeanFactory} must be supplied to the class constructor.\n *\n * <p>A {@link WebDataBinder} is created to apply type conversion to the resolved\n * argument value if it doesn't match the method parameter type.\n *\n * @author Arjen Poutsma\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Sebastien Deleuze\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "signature": "public class AbstractNamedValueMethodArgumentResolver",
    "source_code": "public abstract class AbstractNamedValueMethodArgumentResolver implements HandlerMethodArgumentResolver {\n\n\t@Nullable\n\tprivate final ConfigurableBeanFactory configurableBeanFactory;\n\n\t@Nullable\n\tprivate final BeanExpressionContext expressionContext;\n\n\tprivate final Map<MethodParameter, NamedValueInfo> namedValueInfoCache = new ConcurrentHashMap<>(256);\n\n\n\tpublic AbstractNamedValueMethodArgumentResolver() {\n\t\tthis.configurableBeanFactory = null;\n\t\tthis.expressionContext = null;\n\t}\n\n\t/**\n\t * Create a new {@link AbstractNamedValueMethodArgumentResolver} instance.\n\t * @param beanFactory a bean factory to use for resolving ${...} placeholder\n\t * and #{...} SpEL expressions in default values, or {@code null} if default\n\t * values are not expected to contain expressions\n\t */\n\tpublic AbstractNamedValueMethodArgumentResolver(@Nullable ConfigurableBeanFactory beanFactory) {\n\t\tthis.configurableBeanFactory = beanFactory;\n\t\tthis.expressionContext =\n\t\t\t\t(beanFactory != null ? new BeanExpressionContext(beanFactory, new RequestScope()) : null);\n\t}\n\n\n\t@Override\n\t@Nullable\n\tpublic final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {\n\n\t\tNamedValueInfo namedValueInfo = getNamedValueInfo(parameter);\n\t\tMethodParameter nestedParameter = parameter.nestedIfOptional();\n\t\tboolean hasDefaultValue = KotlinDetector.isKotlinReflectPresent()\n\t\t\t\t&& KotlinDetector.isKotlinType(parameter.getDeclaringClass())\n\t\t\t\t&& KotlinDelegate.hasDefaultValue(nestedParameter);\n\n\t\tObject resolvedName = resolveEmbeddedValuesAndExpressions(namedValueInfo.name);\n\t\tif (resolvedName == null) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Specified name must not resolve to null: [\" + namedValueInfo.name + \"]\");\n\t\t}\n\n\t\tObject arg = resolveName(resolvedName.toString(), nestedParameter, webRequest);\n\t\tif (arg == null) {\n\t\t\tif (namedValueInfo.defaultValue != null) {\n\t\t\t\targ = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);\n\t\t\t}\n\t\t\telse if (namedValueInfo.required && !nestedParameter.isOptional()) {\n\t\t\t\thandleMissingValue(namedValueInfo.name, nestedParameter, webRequest);\n\t\t\t}\n\t\t\tif (!hasDefaultValue) {\n\t\t\t\targ = handleNullValue(namedValueInfo.name, arg, nestedParameter.getNestedParameterType());\n\t\t\t}\n\t\t}\n\t\telse if (\"\".equals(arg) && namedValueInfo.defaultValue != null) {\n\t\t\targ = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);\n\t\t}\n\n\t\tif (binderFactory != null && (arg != null || !hasDefaultValue)) {\n\t\t\targ = convertIfNecessary(parameter, webRequest, binderFactory, namedValueInfo, arg);\n\t\t\t// Check for null value after conversion of incoming argument value\n\t\t\tif (arg == null) {\n\t\t\t\tif (namedValueInfo.defaultValue != null) {\n\t\t\t\t\targ = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);\n\t\t\t\t\targ = convertIfNecessary(parameter, webRequest, binderFactory, namedValueInfo, arg);\n\t\t\t\t}\n\t\t\t\telse if (namedValueInfo.required && !nestedParameter.isOptional()) {\n\t\t\t\t\thandleMissingValueAfterConversion(namedValueInfo.name, nestedParameter, webRequest);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\thandleResolvedValue(arg, namedValueInfo.name, parameter, mavContainer, webRequest);\n\n\t\treturn arg;\n\t}\n\n\t/**\n\t * Obtain the named value for the given method parameter.\n\t */\n\tprivate NamedValueInfo getNamedValueInfo(MethodParameter parameter) {\n\t\tNamedValueInfo namedValueInfo = this.namedValueInfoCache.get(parameter);\n\t\tif (namedValueInfo == null) {\n\t\t\tnamedValueInfo = createNamedValueInfo(parameter);\n\t\t\tnamedValueInfo = updateNamedValueInfo(parameter, namedValueInfo);\n\t\t\tthis.namedValueInfoCache.put(parameter, namedValueInfo);\n\t\t}\n\t\treturn namedValueInfo;\n\t}\n\n\t/**\n\t * Create the {@link NamedValueInfo} object for the given method parameter. Implementations typically\n\t * retrieve the method annotation by means of {@link MethodParameter#getParameterAnnotation(Class)}.\n\t * @param parameter the method parameter\n\t * @return the named value information\n\t */\n\tprotected abstract NamedValueInfo createNamedValueInfo(MethodParameter parameter);\n\n\t/**\n\t * Create a new NamedValueInfo based on the given NamedValueInfo with sanitized values.\n\t */\n\tprivate NamedValueInfo updateNamedValueInfo(MethodParameter parameter, NamedValueInfo info) {\n\t\tString name = info.name;\n\t\tif (info.name.isEmpty()) {\n\t\t\tname = parameter.getParameterName();\n\t\t\tif (name == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"\"\"\n\t\t\t\t\t\tName for argument of type [%s] not specified, and parameter name information not \\\n\t\t\t\t\t\tavailable via reflection. Ensure that the compiler uses the '-parameters' flag.\"\"\"\n\t\t\t\t\t\t\t.formatted(parameter.getNestedParameterType().getName()));\n\t\t\t}\n\t\t}\n\t\tString defaultValue = (ValueConstants.DEFAULT_NONE.equals(info.defaultValue) ? null : info.defaultValue);\n\t\treturn new NamedValueInfo(name, info.required, defaultValue);\n\t}\n\n\t/**\n\t * Resolve the given annotation-specified value,\n\t * potentially containing placeholders and expressions.\n\t */\n\t@Nullable\n\tprivate Object resolveEmbeddedValuesAndExpressions(String value) {\n\t\tif (this.configurableBeanFactory == null || this.expressionContext == null) {\n\t\t\treturn value;\n\t\t}\n\t\tString placeholdersResolved = this.configurableBeanFactory.resolveEmbeddedValue(value);\n\t\tBeanExpressionResolver exprResolver = this.configurableBeanFactory.getBeanExpressionResolver();\n\t\tif (exprResolver == null) {\n\t\t\treturn value;\n\t\t}\n\t\treturn exprResolver.evaluate(placeholdersResolved, this.expressionContext);\n\t}\n\n\t/**\n\t * Resolve the given parameter type and value name into an argument value.\n\t * @param name the name of the value being resolved\n\t * @param parameter the method parameter to resolve to an argument value\n\t * (pre-nested in case of a {@link java.util.Optional} declaration)\n\t * @param request the current request\n\t * @return the resolved argument (may be {@code null})\n\t * @throws Exception in case of errors\n\t */\n\t@Nullable\n\tprotected abstract Object resolveName(String name, MethodParameter parameter, NativeWebRequest request)\n\t\t\tthrows Exception;\n\n\t/**\n\t * Invoked when a named value is required, but {@link #resolveName(String, MethodParameter, NativeWebRequest)}\n\t * returned {@code null} and there is no default value. Subclasses typically throw an exception in this case.\n\t * @param name the name for the value\n\t * @param parameter the method parameter\n\t * @param request the current request\n\t * @since 4.3\n\t */\n\tprotected void handleMissingValue(String name, MethodParameter parameter, NativeWebRequest request)\n\t\t\tthrows Exception {\n\n\t\thandleMissingValue(name, parameter);\n\t}\n\n\t/**\n\t * Invoked when a named value is required, but {@link #resolveName(String, MethodParameter, NativeWebRequest)}\n\t * returned {@code null} and there is no default value. Subclasses typically throw an exception in this case.\n\t * @param name the name for the value\n\t * @param parameter the method parameter\n\t */\n\tprotected void handleMissingValue(String name, MethodParameter parameter) throws ServletException {\n\t\tthrow new ServletRequestBindingException(\"Missing argument '\" + name +\n\t\t\t\t\"' for method parameter of type \" + parameter.getNestedParameterType().getSimpleName());\n\t}\n\n\t/**\n\t * Invoked when a named value is present but becomes {@code null} after conversion.\n\t * @param name the name for the value\n\t * @param parameter the method parameter\n\t * @param request the current request\n\t * @since 5.3.6\n\t */\n\tprotected void handleMissingValueAfterConversion(String name, MethodParameter parameter, NativeWebRequest request)\n\t\t\tthrows Exception {\n\n\t\thandleMissingValue(name, parameter, request);\n\t}\n\n\t/**\n\t * A {@code null} results in a {@code false} value for {@code boolean}s or an exception for other primitives.\n\t */\n\t@Nullable\n\tprivate Object handleNullValue(String name, @Nullable Object value, Class<?> paramType) {\n\t\tif (value == null) {\n\t\t\tif (paramType == boolean.class) {\n\t\t\t\treturn Boolean.FALSE;\n\t\t\t}\n\t\t\telse if (paramType.isPrimitive()) {\n\t\t\t\tthrow new IllegalStateException(\"Optional \" + paramType.getSimpleName() + \" parameter '\" + name +\n\t\t\t\t\t\t\"' is present but cannot be translated into a null value due to being declared as a \" +\n\t\t\t\t\t\t\"primitive type. Consider declaring it as object wrapper for the corresponding primitive type.\");\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}\n\n\t@Nullable\n\tprivate static Object convertIfNecessary(\n\t\t\tMethodParameter parameter, NativeWebRequest webRequest, WebDataBinderFactory binderFactory,\n\t\t\tNamedValueInfo namedValueInfo, @Nullable Object arg) throws Exception {\n\n\t\tWebDataBinder binder = binderFactory.createBinder(webRequest, null, namedValueInfo.name);\n\t\tClass<?> parameterType = parameter.getParameterType();\n\t\tif (KotlinDetector.isKotlinPresent() && KotlinDetector.isInlineClass(parameterType)) {\n\t\t\tConstructor<?> ctor = BeanUtils.findPrimaryConstructor(parameterType);\n\t\t\tif (ctor != null) {\n\t\t\t\tparameterType = ctor.getParameterTypes()[0];\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\targ = binder.convertIfNecessary(arg, parameterType, parameter);\n\t\t}\n\t\tcatch (ConversionNotSupportedException ex) {\n\t\t\tthrow new MethodArgumentConversionNotSupportedException(arg, ex.getRequiredType(),\n\t\t\t\t\tnamedValueInfo.name, parameter, ex.getCause());\n\t\t}\n\t\tcatch (TypeMismatchException ex) {\n\t\t\tthrow new MethodArgumentTypeMismatchException(arg, ex.getRequiredType(),\n\t\t\t\t\tnamedValueInfo.name, parameter, ex.getCause());\n\t\t}\n\t\treturn arg;\n\t}\n\n\t/**\n\t * Invoked after a value is resolved.\n\t * @param arg the resolved argument value\n\t * @param name the argument name\n\t * @param parameter the argument parameter type\n\t * @param mavContainer the {@link ModelAndViewContainer} (may be {@code null})\n\t * @param webRequest the current request\n\t */\n\tprotected void handleResolvedValue(@Nullable Object arg, String name, MethodParameter parameter,\n\t\t\t@Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest) {\n\t}\n\n\n\t/**\n\t * Represents the information about a named value, including name, whether it's required and a default value.\n\t */\n\tprotected static class NamedValueInfo {\n\n\t\tprivate final String name;\n\n\t\tprivate final boolean required;\n\n\t\t@Nullable\n\t\tprivate final String defaultValue;\n\n\t\tpublic NamedValueInfo(String name, boolean required, @Nullable String defaultValue) {\n\t\t\tthis.name = name;\n\t\t\tthis.required = required;\n\t\t\tthis.defaultValue = defaultValue;\n\t\t}\n\t}\n\n\t/**\n\t * Inner class to avoid a hard dependency on Kotlin at runtime.\n\t */\n\tprivate static class KotlinDelegate {\n\n\t\t/**\n\t\t * Check whether the specified {@link MethodParameter} represents a nullable Kotlin type\n\t\t * or an optional parameter (with a default value in the Kotlin declaration).\n\t\t */\n\t\tpublic static boolean hasDefaultValue(MethodParameter parameter) {\n\t\t\tMethod method = Objects.requireNonNull(parameter.getMethod());\n\t\t\tKFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);\n\t\t\tif (function != null) {\n\t\t\t\tint index = 0;\n\t\t\t\tfor (KParameter kParameter : function.getParameters()) {\n\t\t\t\t\tif (KParameter.Kind.VALUE.equals(kParameter.getKind()) && parameter.getParameterIndex() == index++) {\n\t\t\t\t\t\treturn kParameter.isOptional();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n}"
  },
  "org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver#createNamedValueInfo(parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the {@link NamedValueInfo} object for the given method parameter. Implementations typically\n\t * retrieve the method annotation by means of {@link MethodParameter#getParameterAnnotation(Class)}.\n\t * @param parameter the method parameter\n\t * @return the named value information\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "NamedValueInfo",
    "signature": "protected NamedValueInfo createNamedValueInfo(MethodParameter parameter)",
    "source_code": "\tprotected abstract NamedValueInfo createNamedValueInfo(MethodParameter parameter);"
  },
  "org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver#handleMissingValue(name,parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked when a named value is required, but {@link #resolveName(String, MethodParameter, NativeWebRequest)}\n\t * returned {@code null} and there is no default value. Subclasses typically throw an exception in this case.\n\t * @param name the name for the value\n\t * @param parameter the method parameter\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "void",
    "signature": "protected void handleMissingValue(String name, MethodParameter parameter)",
    "source_code": "\tprotected void handleMissingValue(String name, MethodParameter parameter) throws ServletException {\n\t\tthrow new ServletRequestBindingException(\"Missing argument '\" + name +\n\t\t\t\t\"' for method parameter of type \" + parameter.getNestedParameterType().getSimpleName());\n\t}"
  },
  "org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver#handleMissingValue(name,parameter,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked when a named value is required, but {@link #resolveName(String, MethodParameter, NativeWebRequest)}\n\t * returned {@code null} and there is no default value. Subclasses typically throw an exception in this case.\n\t * @param name the name for the value\n\t * @param parameter the method parameter\n\t * @param request the current request\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "void",
    "signature": "protected void handleMissingValue(String name, MethodParameter parameter, NativeWebRequest request)",
    "source_code": "\tprotected void handleMissingValue(String name, MethodParameter parameter, NativeWebRequest request)"
  },
  "org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver#handleMissingValueAfterConversion(name,parameter,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked when a named value is present but becomes {@code null} after conversion.\n\t * @param name the name for the value\n\t * @param parameter the method parameter\n\t * @param request the current request\n\t * @since 5.3.6\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "void",
    "signature": "protected void handleMissingValueAfterConversion(String name, MethodParameter parameter, NativeWebRequest request)",
    "source_code": "\tprotected void handleMissingValueAfterConversion(String name, MethodParameter parameter, NativeWebRequest request)"
  },
  "org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver#handleResolvedValue(arg,name,parameter,mavContainer,webRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked after a value is resolved.\n\t * @param arg the resolved argument value\n\t * @param name the argument name\n\t * @param parameter the argument parameter type\n\t * @param mavContainer the {@link ModelAndViewContainer} (may be {@code null})\n\t * @param webRequest the current request\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "arg",
      "name",
      "parameter",
      "mavContainer",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 315
    },
    "return": "void",
    "signature": "protected void handleResolvedValue(@Nullable Object arg, String name, MethodParameter parameter,\n\t\t\t@Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest)",
    "source_code": "\tprotected void handleResolvedValue(@Nullable Object arg, String name, MethodParameter parameter,"
  },
  "org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver#hasDefaultValue(parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Check whether the specified {@link MethodParameter} represents a nullable Kotlin type\n\t\t * or an optional parameter (with a default value in the Kotlin declaration).\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 348
    },
    "return": "boolean",
    "signature": "public boolean hasDefaultValue(MethodParameter parameter)",
    "source_code": "\t\tpublic static boolean hasDefaultValue(MethodParameter parameter) {\n\t\t\tMethod method = Objects.requireNonNull(parameter.getMethod());\n\t\t\tKFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);\n\t\t\tif (function != null) {\n\t\t\t\tint index = 0;\n\t\t\t\tfor (KParameter kParameter : function.getParameters()) {\n\t\t\t\t\tif (KParameter.Kind.VALUE.equals(kParameter.getKind()) && parameter.getParameterIndex() == index++) {\n\t\t\t\t\t\treturn kParameter.isOptional();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver#resolveArgument(parameter,mavContainer,webRequest,binderFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "mavContainer",
      "webRequest",
      "binderFactory"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "Object",
    "signature": "public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)",
    "source_code": "\tpublic final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,"
  },
  "org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver#resolveName(name,parameter,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the given parameter type and value name into an argument value.\n\t * @param name the name of the value being resolved\n\t * @param parameter the method parameter to resolve to an argument value\n\t * (pre-nested in case of a {@link java.util.Optional} declaration)\n\t * @param request the current request\n\t * @return the resolved argument (may be {@code null})\n\t * @throws Exception in case of errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "Object",
    "signature": "protected Object resolveName(String name, MethodParameter parameter, NativeWebRequest request)",
    "source_code": "\tprotected abstract Object resolveName(String name, MethodParameter parameter, NativeWebRequest request)"
  },
  "org.springframework.web.method.annotation.HandlerMethodValidator": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link MethodValidator} that\n * uses Bean Validation to validate {@code @RequestMapping} method arguments.\n *\n * <p>Handles validation results by populating {@link BindingResult} method\n * arguments with errors from {@link MethodValidationResult#getBeanResults()\n * beanResults}. Also, helps to determine parameter names for\n * {@code @ModelAttribute} and {@code @RequestBody} parameters.\n *\n * @author Rossen Stoyanchev\n * @since 6.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "signature": "public class HandlerMethodValidator",
    "source_code": "public final class HandlerMethodValidator implements MethodValidator {\n\n\tprivate static final MethodValidationAdapter.ObjectNameResolver objectNameResolver = new WebObjectNameResolver();\n\n\n\tprivate final MethodValidationAdapter validationAdapter;\n\n\tprivate final Predicate<MethodParameter> modelAttributePredicate;\n\n\tprivate final Predicate<MethodParameter> requestParamPredicate;\n\n\n\tprivate HandlerMethodValidator(MethodValidationAdapter validationAdapter,\n\t\t\tPredicate<MethodParameter> modelAttributePredicate, Predicate<MethodParameter> requestParamPredicate) {\n\n\t\tthis.validationAdapter = validationAdapter;\n\t\tthis.modelAttributePredicate = modelAttributePredicate;\n\t\tthis.requestParamPredicate = requestParamPredicate;\n\t}\n\n\n\t@Override\n\tpublic Class<?>[] determineValidationGroups(Object target, Method method) {\n\t\treturn this.validationAdapter.determineValidationGroups(target, method);\n\t}\n\n\t@Override\n\tpublic void applyArgumentValidation(\n\t\t\tObject target, Method method, @Nullable MethodParameter[] parameters,\n\t\t\tObject[] arguments, Class<?>[] groups) {\n\n\t\tMethodValidationResult result = validateArguments(target, method, parameters, arguments, groups);\n\t\tif (!result.hasErrors()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!result.getBeanResults().isEmpty()) {\n\t\t\tint bindingResultCount = 0;\n\t\t\tfor (ParameterErrors errors : result.getBeanResults()) {\n\t\t\t\tfor (Object arg : arguments) {\n\t\t\t\t\tif (arg instanceof BindingResult bindingResult) {\n\t\t\t\t\t\tif (bindingResult.getObjectName().equals(errors.getObjectName())) {\n\t\t\t\t\t\t\tbindingResult.addAllErrors(errors);\n\t\t\t\t\t\t\tbindingResultCount++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result.getAllValidationResults().size() == bindingResultCount) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthrow new HandlerMethodValidationException(\n\t\t\t\tresult, this.modelAttributePredicate, this.requestParamPredicate);\n\t}\n\n\t@Override\n\tpublic MethodValidationResult validateArguments(\n\t\t\tObject target, Method method, @Nullable MethodParameter[] parameters,\n\t\t\tObject[] arguments, Class<?>[] groups) {\n\n\t\treturn this.validationAdapter.validateArguments(target, method, parameters, arguments, groups);\n\t}\n\n\t@Override\n\tpublic void applyReturnValueValidation(\n\t\t\tObject target, Method method, @Nullable MethodParameter returnType,\n\t\t\t@Nullable Object returnValue, Class<?>[] groups) {\n\n\t\tMethodValidationResult result = validateReturnValue(target, method, returnType, returnValue, groups);\n\t\tif (result.hasErrors()) {\n\t\t\tthrow new HandlerMethodValidationException(result);\n\t\t}\n\t}\n\n\t@Override\n\tpublic MethodValidationResult validateReturnValue(Object target, Method method,\n\t\t\t@Nullable MethodParameter returnType, @Nullable Object returnValue, Class<?>[] groups) {\n\n\t\treturn this.validationAdapter.validateReturnValue(target, method, returnType, returnValue, groups);\n\t}\n\n\n\t/**\n\t * Static factory method to create a {@link HandlerMethodValidator} when Bean\n\t * Validation is enabled for use via {@link ConfigurableWebBindingInitializer},\n\t * for example in Spring MVC or WebFlux config.\n\t */\n\t@Nullable\n\tpublic static MethodValidator from(\n\t\t\t@Nullable WebBindingInitializer initializer, @Nullable ParameterNameDiscoverer paramNameDiscoverer,\n\t\t\tPredicate<MethodParameter> modelAttributePredicate, Predicate<MethodParameter> requestParamPredicate) {\n\n\t\tif (initializer instanceof ConfigurableWebBindingInitializer configurableInitializer) {\n\t\t\tValidator validator = getValidator(configurableInitializer);\n\t\t\tif (validator != null) {\n\t\t\t\tMethodValidationAdapter adapter = new MethodValidationAdapter(validator);\n\t\t\t\tadapter.setObjectNameResolver(objectNameResolver);\n\t\t\t\tif (paramNameDiscoverer != null) {\n\t\t\t\t\tadapter.setParameterNameDiscoverer(paramNameDiscoverer);\n\t\t\t\t}\n\t\t\t\tMessageCodesResolver codesResolver = configurableInitializer.getMessageCodesResolver();\n\t\t\t\tif (codesResolver != null) {\n\t\t\t\t\tadapter.setMessageCodesResolver(codesResolver);\n\t\t\t\t}\n\t\t\t\treturn new HandlerMethodValidator(adapter, modelAttributePredicate, requestParamPredicate);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Nullable\n\tprivate static Validator getValidator(ConfigurableWebBindingInitializer initializer) {\n\t\tif (initializer.getValidator() instanceof Validator validator) {\n\t\t\treturn validator;\n\t\t}\n\t\tif (initializer.getValidator() instanceof SmartValidator smartValidator) {\n\t\t\treturn smartValidator.unwrap(Validator.class);\n\t\t}\n\t\treturn null;\n\t}\n\n\n\t/**\n\t * ObjectNameResolver for web controller methods.\n\t */\n\tprivate static class WebObjectNameResolver implements MethodValidationAdapter.ObjectNameResolver {\n\n\t\t@Override\n\t\tpublic String resolveName(MethodParameter param, @Nullable Object value) {\n\t\t\tif (param.hasParameterAnnotation(RequestBody.class) || param.hasParameterAnnotation(RequestPart.class)) {\n\t\t\t\treturn Conventions.getVariableNameForParameter(param);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn (param.getParameterIndex() != -1 ?\n\t\t\t\t\t\tModelFactory.getNameForParameter(param) :\n\t\t\t\t\t\tModelFactory.getNameForReturnValue(value, param));\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.method.annotation.HandlerMethodValidator#applyArgumentValidation(target,method,parameters,arguments,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "parameters",
      "arguments",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "public void applyArgumentValidation(Object target, Method method, @Nullable MethodParameter[] parameters,\n\t\t\tObject[] arguments, Class<?>[] groups)",
    "source_code": "\tpublic void applyArgumentValidation("
  },
  "org.springframework.web.method.annotation.HandlerMethodValidator#applyReturnValueValidation(target,method,returnType,returnValue,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "returnType",
      "returnValue",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "void",
    "signature": "public void applyReturnValueValidation(Object target, Method method, @Nullable MethodParameter returnType,\n\t\t\t@Nullable Object returnValue, Class<?>[] groups)",
    "source_code": "\tpublic void applyReturnValueValidation("
  },
  "org.springframework.web.method.annotation.HandlerMethodValidator#from(initializer,paramNameDiscoverer,modelAttributePredicate,requestParamPredicate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create a {@link HandlerMethodValidator} when Bean\n\t * Validation is enabled for use via {@link ConfigurableWebBindingInitializer},\n\t * for example in Spring MVC or WebFlux config.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "initializer",
      "paramNameDiscoverer",
      "modelAttributePredicate",
      "requestParamPredicate"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "MethodValidator",
    "signature": "public MethodValidator from(@Nullable WebBindingInitializer initializer, @Nullable ParameterNameDiscoverer paramNameDiscoverer,\n\t\t\tPredicate<MethodParameter> modelAttributePredicate, Predicate<MethodParameter> requestParamPredicate)",
    "source_code": "\tpublic static MethodValidator from("
  },
  "org.springframework.web.method.annotation.HandlerMethodValidator#resolveName(param,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "param",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "String",
    "signature": "public String resolveName(MethodParameter param, @Nullable Object value)",
    "source_code": "\t\tpublic String resolveName(MethodParameter param, @Nullable Object value) {\n\t\t\tif (param.hasParameterAnnotation(RequestBody.class) || param.hasParameterAnnotation(RequestPart.class)) {\n\t\t\t\treturn Conventions.getVariableNameForParameter(param);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn (param.getParameterIndex() != -1 ?\n\t\t\t\t\t\tModelFactory.getNameForParameter(param) :\n\t\t\t\t\t\tModelFactory.getNameForReturnValue(value, param));\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.method.annotation.HandlerMethodValidator#validateArguments(target,method,parameters,arguments,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "parameters",
      "arguments",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "MethodValidationResult",
    "signature": "public MethodValidationResult validateArguments(Object target, Method method, @Nullable MethodParameter[] parameters,\n\t\t\tObject[] arguments, Class<?>[] groups)",
    "source_code": "\tpublic MethodValidationResult validateArguments("
  },
  "org.springframework.web.method.annotation.HandlerMethodValidator#validateReturnValue(target,method,returnType,returnValue,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "returnType",
      "returnValue",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "MethodValidationResult",
    "signature": "public MethodValidationResult validateReturnValue(Object target, Method method,\n\t\t\t@Nullable MethodParameter returnType, @Nullable Object returnValue, Class<?>[] groups)",
    "source_code": "\tpublic MethodValidationResult validateReturnValue(Object target, Method method,"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Resolve {@code @ModelAttribute} annotated method arguments and handle\n * return values from {@code @ModelAttribute} annotated methods.\n *\n * <p>Model attributes are obtained from the model or created with a default\n * constructor (and then added to the model). Once created the attribute is\n * populated via data binding to Servlet request parameters. Validation may be\n * applied if the argument is annotated with {@code @jakarta.validation.Valid}.\n * or Spring's own {@code @org.springframework.validation.annotation.Validated}.\n *\n * <p>When this handler is created with {@code annotationNotRequired=true}\n * any non-simple type argument and return value is regarded as a model\n * attribute with or without the presence of an {@code @ModelAttribute}.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Sebastien Deleuze\n * @author Vladislav Kisel\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "signature": "public class ModelAttributeMethodProcessor",
    "source_code": "public class ModelAttributeMethodProcessor implements HandlerMethodArgumentResolver, HandlerMethodReturnValueHandler {\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\tprivate final boolean annotationNotRequired;\n\n\n\t/**\n\t * Class constructor.\n\t * @param annotationNotRequired if \"true\", non-simple method arguments and\n\t * return values are considered model attributes with or without a\n\t * {@code @ModelAttribute} annotation\n\t */\n\tpublic ModelAttributeMethodProcessor(boolean annotationNotRequired) {\n\t\tthis.annotationNotRequired = annotationNotRequired;\n\t}\n\n\n\t/**\n\t * Returns {@code true} if the parameter is annotated with\n\t * {@link ModelAttribute} or, if in default resolution mode, for any\n\t * method parameter that is not a simple type.\n\t */\n\t@Override\n\tpublic boolean supportsParameter(MethodParameter parameter) {\n\t\treturn (parameter.hasParameterAnnotation(ModelAttribute.class) ||\n\t\t\t\t(this.annotationNotRequired && !BeanUtils.isSimpleProperty(parameter.getParameterType())));\n\t}\n\n\t/**\n\t * Resolve the argument from the model or if not found instantiate it with\n\t * its default if it is available. The model attribute is then populated\n\t * with request values via data binding and optionally validated\n\t * if {@code @java.validation.Valid} is present on the argument.\n\t * @throws BindException if data binding and validation result in an error\n\t * and the next method parameter is not of type {@link Errors}\n\t * @throws Exception if WebDataBinder initialization fails\n\t */\n\t@Override\n\t@Nullable\n\tpublic final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {\n\n\t\tAssert.state(mavContainer != null, \"ModelAttributeMethodProcessor requires ModelAndViewContainer\");\n\t\tAssert.state(binderFactory != null, \"ModelAttributeMethodProcessor requires WebDataBinderFactory\");\n\n\t\tString name = ModelFactory.getNameForParameter(parameter);\n\t\tModelAttribute ann = parameter.getParameterAnnotation(ModelAttribute.class);\n\t\tif (ann != null) {\n\t\t\tmavContainer.setBinding(name, ann.binding());\n\t\t}\n\n\t\tObject attribute = null;\n\t\tBindingResult bindingResult = null;\n\n\t\tif (mavContainer.containsAttribute(name)) {\n\t\t\tattribute = mavContainer.getModel().get(name);\n\t\t}\n\t\telse {\n\t\t\t// Create attribute instance\n\t\t\ttry {\n\t\t\t\tattribute = createAttribute(name, parameter, binderFactory, webRequest);\n\t\t\t}\n\t\t\tcatch (MethodArgumentNotValidException ex) {\n\t\t\t\tif (isBindExceptionRequired(parameter)) {\n\t\t\t\t\t// No BindingResult parameter -> fail with BindException\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\t// Otherwise, expose null/empty value and associated BindingResult\n\t\t\t\tif (parameter.getParameterType() == Optional.class) {\n\t\t\t\t\tattribute = Optional.empty();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tattribute = ex.getTarget();\n\t\t\t\t}\n\t\t\t\tbindingResult = ex.getBindingResult();\n\t\t\t}\n\t\t}\n\n\t\tif (bindingResult == null) {\n\t\t\t// Bean property binding and validation;\n\t\t\t// skipped in case of binding failure on construction.\n\t\t\tWebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);\n\t\t\tif (binder.getTarget() != null) {\n\t\t\t\tif (!mavContainer.isBindingDisabled(name)) {\n\t\t\t\t\tbindRequestParameters(binder, webRequest);\n\t\t\t\t}\n\t\t\t\tvalidateIfApplicable(binder, parameter);\n\t\t\t\tif (binder.getBindingResult().hasErrors() && isBindExceptionRequired(binder, parameter)) {\n\t\t\t\t\tthrow new MethodArgumentNotValidException(parameter, binder.getBindingResult());\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Value type adaptation, also covering java.util.Optional\n\t\t\tif (!parameter.getParameterType().isInstance(attribute)) {\n\t\t\t\tattribute = binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);\n\t\t\t}\n\t\t\tbindingResult = binder.getBindingResult();\n\t\t}\n\n\t\t// Add resolved attribute and BindingResult at the end of the model\n\t\tMap<String, Object> bindingResultModel = bindingResult.getModel();\n\t\tmavContainer.removeAttributes(bindingResultModel);\n\t\tmavContainer.addAllAttributes(bindingResultModel);\n\n\t\treturn attribute;\n\t}\n\n\t/**\n\t * Extension point to create the model attribute if not found in the model,\n\t * with subsequent parameter binding through bean properties (unless suppressed).\n\t * <p>The default implementation typically uses the unique public no-arg constructor\n\t * if available but also handles a \"primary constructor\" approach for data classes:\n\t * It understands the JavaBeans {@code ConstructorProperties} annotation as well as\n\t * runtime-retained parameter names in the bytecode, associating request parameters\n\t * with constructor arguments by name. If no such constructor is found, the default\n\t * constructor will be used (even if not public), assuming subsequent bean property\n\t * bindings through setter methods.\n\t * @param attributeName the name of the attribute (never {@code null})\n\t * @param parameter the method parameter declaration\n\t * @param binderFactory for creating WebDataBinder instance\n\t * @param webRequest the current request\n\t * @return the created model attribute (never {@code null})\n\t * @throws BindException in case of constructor argument binding failure\n\t * @throws Exception in case of constructor invocation failure\n\t * @see #constructAttribute(Constructor, String, MethodParameter, WebDataBinderFactory, NativeWebRequest)\n\t * @see BeanUtils#findPrimaryConstructor(Class)\n\t */\n\tprotected Object createAttribute(String attributeName, MethodParameter parameter,\n\t\t\tWebDataBinderFactory binderFactory, NativeWebRequest webRequest) throws Exception {\n\n\t\tMethodParameter nestedParameter = parameter.nestedIfOptional();\n\t\tClass<?> clazz = nestedParameter.getNestedParameterType();\n\n\t\tConstructor<?> ctor = BeanUtils.getResolvableConstructor(clazz);\n\t\tObject attribute = constructAttribute(ctor, attributeName, parameter, binderFactory, webRequest);\n\t\tif (parameter != nestedParameter) {\n\t\t\tattribute = Optional.of(attribute);\n\t\t}\n\t\treturn attribute;\n\t}\n\n\t/**\n\t * Construct a new attribute instance with the given constructor.\n\t * <p>Called from\n\t * {@link #createAttribute(String, MethodParameter, WebDataBinderFactory, NativeWebRequest)}\n\t * after constructor resolution.\n\t * @param ctor the constructor to use\n\t * @param attributeName the name of the attribute (never {@code null})\n\t * @param parameter the method parameter declaration\n\t * @param binderFactory for creating WebDataBinder instance\n\t * @param webRequest the current request\n\t * @return the created model attribute (never {@code null})\n\t * @throws BindException in case of constructor argument binding failure\n\t * @throws Exception in case of constructor invocation failure\n\t * @since 5.1\n\t */\n\t@SuppressWarnings(\"serial\")\n\tprotected Object constructAttribute(Constructor<?> ctor, String attributeName, MethodParameter parameter,\n\t\t\tWebDataBinderFactory binderFactory, NativeWebRequest webRequest) throws Exception {\n\n\t\tif (ctor.getParameterCount() == 0) {\n\t\t\t// A single default constructor -> clearly a standard JavaBeans arrangement.\n\t\t\treturn BeanUtils.instantiateClass(ctor);\n\t\t}\n\n\t\t// A single data class constructor -> resolve constructor arguments from request parameters.\n\t\tString[] paramNames = BeanUtils.getParameterNames(ctor);\n\t\tClass<?>[] paramTypes = ctor.getParameterTypes();\n\t\tObject[] args = new Object[paramTypes.length];\n\t\tWebDataBinder binder = binderFactory.createBinder(webRequest, null, attributeName);\n\t\tString fieldDefaultPrefix = binder.getFieldDefaultPrefix();\n\t\tString fieldMarkerPrefix = binder.getFieldMarkerPrefix();\n\t\tboolean bindingFailure = false;\n\t\tSet<String> failedParams = new HashSet<>(4);\n\n\t\tfor (int i = 0; i < paramNames.length; i++) {\n\t\t\tString paramName = paramNames[i];\n\t\t\tClass<?> paramType = paramTypes[i];\n\t\t\tObject value = webRequest.getParameterValues(paramName);\n\n\t\t\t// Since WebRequest#getParameter exposes a single-value parameter as an array\n\t\t\t// with a single element, we unwrap the single value in such cases, analogous\n\t\t\t// to WebExchangeDataBinder.addBindValue(Map<String, Object>, String, List<?>).\n\t\t\tif (ObjectUtils.isArray(value) && Array.getLength(value) == 1) {\n\t\t\t\tvalue = Array.get(value, 0);\n\t\t\t}\n\n\t\t\tif (value == null) {\n\t\t\t\tif (fieldDefaultPrefix != null) {\n\t\t\t\t\tvalue = webRequest.getParameter(fieldDefaultPrefix + paramName);\n\t\t\t\t}\n\t\t\t\tif (value == null) {\n\t\t\t\t\tif (fieldMarkerPrefix != null && webRequest.getParameter(fieldMarkerPrefix + paramName) != null) {\n\t\t\t\t\t\tvalue = binder.getEmptyValue(paramType);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvalue = resolveConstructorArgument(paramName, paramType, webRequest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tMethodParameter methodParam = new FieldAwareConstructorParameter(ctor, i, paramName);\n\t\t\t\tif (value == null && methodParam.isOptional()) {\n\t\t\t\t\targs[i] = (methodParam.getParameterType() == Optional.class ? Optional.empty() : null);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\targs[i] = binder.convertIfNecessary(value, paramType, methodParam);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tex.initPropertyName(paramName);\n\t\t\t\targs[i] = null;\n\t\t\t\tfailedParams.add(paramName);\n\t\t\t\tbinder.getBindingResult().recordFieldValue(paramName, paramType, value);\n\t\t\t\tbinder.getBindingErrorProcessor().processPropertyAccessException(ex, binder.getBindingResult());\n\t\t\t\tbindingFailure = true;\n\t\t\t}\n\t\t}\n\n\t\tif (bindingFailure) {\n\t\t\tBindingResult result = binder.getBindingResult();\n\t\t\tfor (int i = 0; i < paramNames.length; i++) {\n\t\t\t\tString paramName = paramNames[i];\n\t\t\t\tif (!failedParams.contains(paramName)) {\n\t\t\t\t\tObject value = args[i];\n\t\t\t\t\tresult.recordFieldValue(paramName, paramTypes[i], value);\n\t\t\t\t\tvalidateValueIfApplicable(binder, parameter, ctor.getDeclaringClass(), paramName, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!parameter.isOptional()) {\n\t\t\t\ttry {\n\t\t\t\t\tObject target = BeanUtils.instantiateClass(ctor, args);\n\t\t\t\t\tthrow new MethodArgumentNotValidException(parameter, result) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic Object getTarget() {\n\t\t\t\t\t\t\treturn target;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcatch (BeanInstantiationException ex) {\n\t\t\t\t\t// swallow and proceed without target instance\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new MethodArgumentNotValidException(parameter, result);\n\t\t}\n\n\t\ttry {\n\t\t\treturn BeanUtils.instantiateClass(ctor, args);\n\t\t}\n\t\tcatch (BeanInstantiationException ex) {\n\t\t\tif (KotlinDetector.isKotlinType(ctor.getDeclaringClass()) &&\n\t\t\t\t\tex.getCause() instanceof NullPointerException cause) {\n\t\t\t\tBindingResult result = binder.getBindingResult();\n\t\t\t\tObjectError error = new ObjectError(ctor.getName(), cause.getMessage());\n\t\t\t\tresult.addError(error);\n\t\t\t\tthrow new MethodArgumentNotValidException(parameter, result);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Extension point to bind the request to the target object.\n\t * @param binder the data binder instance to use for the binding\n\t * @param request the current request\n\t */\n\tprotected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) {\n\t\t((WebRequestDataBinder) binder).bind(request);\n\t}\n\n\t@Nullable\n\tpublic Object resolveConstructorArgument(String paramName, Class<?> paramType, NativeWebRequest request)\n\t\t\tthrows Exception {\n\n\t\tMultipartRequest multipartRequest = request.getNativeRequest(MultipartRequest.class);\n\t\tif (multipartRequest != null) {\n\t\t\tList<MultipartFile> files = multipartRequest.getFiles(paramName);\n\t\t\tif (!files.isEmpty()) {\n\t\t\t\treturn (files.size() == 1 ? files.get(0) : files);\n\t\t\t}\n\t\t}\n\t\telse if (StringUtils.startsWithIgnoreCase(\n\t\t\t\trequest.getHeader(HttpHeaders.CONTENT_TYPE), MediaType.MULTIPART_FORM_DATA_VALUE)) {\n\t\t\tHttpServletRequest servletRequest = request.getNativeRequest(HttpServletRequest.class);\n\t\t\tif (servletRequest != null && HttpMethod.POST.matches(servletRequest.getMethod())) {\n\t\t\t\tList<Part> parts = StandardServletPartUtils.getParts(servletRequest, paramName);\n\t\t\t\tif (!parts.isEmpty()) {\n\t\t\t\t\treturn (parts.size() == 1 ? parts.get(0) : parts);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Validate the model attribute if applicable.\n\t * <p>The default implementation checks for {@code @jakarta.validation.Valid},\n\t * Spring's {@link org.springframework.validation.annotation.Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param binder the DataBinder to be used\n\t * @param parameter the method parameter declaration\n\t * @see WebDataBinder#validate(Object...)\n\t * @see SmartValidator#validate(Object, Errors, Object...)\n\t */\n\tprotected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter) {\n\t\tfor (Annotation ann : parameter.getParameterAnnotations()) {\n\t\t\tObject[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);\n\t\t\tif (validationHints != null) {\n\t\t\t\tbinder.validate(validationHints);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Validate the specified candidate value if applicable.\n\t * <p>The default implementation checks for {@code @jakarta.validation.Valid},\n\t * Spring's {@link org.springframework.validation.annotation.Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param binder the DataBinder to be used\n\t * @param parameter the method parameter declaration\n\t * @param targetType the target type\n\t * @param fieldName the name of the field\n\t * @param value the candidate value\n\t * @since 5.1\n\t * @see #validateIfApplicable(WebDataBinder, MethodParameter)\n\t * @see SmartValidator#validateValue(Class, String, Object, Errors, Object...)\n\t */\n\tprotected void validateValueIfApplicable(WebDataBinder binder, MethodParameter parameter,\n\t\t\tClass<?> targetType, String fieldName, @Nullable Object value) {\n\n\t\tfor (Annotation ann : parameter.getParameterAnnotations()) {\n\t\t\tObject[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);\n\t\t\tif (validationHints != null) {\n\t\t\t\tfor (Validator validator : binder.getValidators()) {\n\t\t\t\t\tif (validator instanceof SmartValidator smartValidator) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tsmartValidator.validateValue(targetType, fieldName, value,\n\t\t\t\t\t\t\t\t\tbinder.getBindingResult(), validationHints);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\t\t\t// No corresponding field on the target class...\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Whether to raise a fatal bind exception on validation errors.\n\t * <p>The default implementation delegates to {@link #isBindExceptionRequired(MethodParameter)}.\n\t * @param binder the data binder used to perform data binding\n\t * @param parameter the method parameter declaration\n\t * @return {@code true} if the next method parameter is not of type {@link Errors}\n\t * @see #isBindExceptionRequired(MethodParameter)\n\t */\n\tprotected boolean isBindExceptionRequired(WebDataBinder binder, MethodParameter parameter) {\n\t\treturn isBindExceptionRequired(parameter);\n\t}\n\n\t/**\n\t * Whether to raise a fatal bind exception on validation errors.\n\t * @param parameter the method parameter declaration\n\t * @return {@code true} if the next method parameter is not of type {@link Errors}\n\t * @since 5.0\n\t */\n\tprotected boolean isBindExceptionRequired(MethodParameter parameter) {\n\t\tint i = parameter.getParameterIndex();\n\t\tClass<?>[] paramTypes = parameter.getExecutable().getParameterTypes();\n\t\tboolean hasBindingResult = (paramTypes.length > (i + 1) && Errors.class.isAssignableFrom(paramTypes[i + 1]));\n\t\treturn !hasBindingResult;\n\t}\n\n\t/**\n\t * Return {@code true} if there is a method-level {@code @ModelAttribute}\n\t * or, in default resolution mode, for any return value type that is not\n\t * a simple type.\n\t */\n\t@Override\n\tpublic boolean supportsReturnType(MethodParameter returnType) {\n\t\treturn (returnType.hasMethodAnnotation(ModelAttribute.class) ||\n\t\t\t\t(this.annotationNotRequired && !BeanUtils.isSimpleProperty(returnType.getParameterType())));\n\t}\n\n\t/**\n\t * Add non-null return values to the {@link ModelAndViewContainer}.\n\t */\n\t@Override\n\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {\n\n\t\tif (returnValue != null) {\n\t\t\tString name = ModelFactory.getNameForReturnValue(returnValue, returnType);\n\t\t\tmavContainer.addAttribute(name, returnValue);\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link MethodParameter} subclass which detects field annotations as well.\n\t * @since 5.1\n\t */\n\tprivate static class FieldAwareConstructorParameter extends MethodParameter {\n\n\t\tprivate final String parameterName;\n\n\t\t@Nullable\n\t\tprivate volatile Annotation[] combinedAnnotations;\n\n\t\tpublic FieldAwareConstructorParameter(Constructor<?> constructor, int parameterIndex, String parameterName) {\n\t\t\tsuper(constructor, parameterIndex);\n\t\t\tthis.parameterName = parameterName;\n\t\t}\n\n\t\t@Override\n\t\tpublic Annotation[] getParameterAnnotations() {\n\t\t\tAnnotation[] anns = this.combinedAnnotations;\n\t\t\tif (anns == null) {\n\t\t\t\tanns = super.getParameterAnnotations();\n\t\t\t\ttry {\n\t\t\t\t\tField field = getDeclaringClass().getDeclaredField(this.parameterName);\n\t\t\t\t\tAnnotation[] fieldAnns = field.getAnnotations();\n\t\t\t\t\tif (fieldAnns.length > 0) {\n\t\t\t\t\t\tList<Annotation> merged = new ArrayList<>(anns.length + fieldAnns.length);\n\t\t\t\t\t\tmerged.addAll(Arrays.asList(anns));\n\t\t\t\t\t\tfor (Annotation fieldAnn : fieldAnns) {\n\t\t\t\t\t\t\tboolean existingType = false;\n\t\t\t\t\t\t\tfor (Annotation ann : anns) {\n\t\t\t\t\t\t\t\tif (ann.annotationType() == fieldAnn.annotationType()) {\n\t\t\t\t\t\t\t\t\texistingType = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!existingType) {\n\t\t\t\t\t\t\t\tmerged.add(fieldAnn);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tanns = merged.toArray(new Annotation[0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchFieldException | SecurityException ex) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t\tthis.combinedAnnotations = anns;\n\t\t\t}\n\t\t\treturn anns;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getParameterName() {\n\t\t\treturn this.parameterName;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#bindRequestParameters(binder,request)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Extension point to bind the request to the target object.\n\t * @param binder the data binder instance to use for the binding\n\t * @param request the current request\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 357
    },
    "return": "void",
    "signature": "protected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request)",
    "source_code": "\tprotected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) {\n\t\t((WebRequestDataBinder) binder).bind(request);\n\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#constructAttribute(ctor,attributeName,parameter,binderFactory,webRequest)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Construct a new attribute instance with the given constructor.\n\t * <p>Called from\n\t * {@link #createAttribute(String, MethodParameter, WebDataBinderFactory, NativeWebRequest)}\n\t * after constructor resolution.\n\t * @param ctor the constructor to use\n\t * @param attributeName the name of the attribute (never {@code null})\n\t * @param parameter the method parameter declaration\n\t * @param binderFactory for creating WebDataBinder instance\n\t * @param webRequest the current request\n\t * @return the created model attribute (never {@code null})\n\t * @throws BindException in case of constructor argument binding failure\n\t * @throws Exception in case of constructor invocation failure\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ctor",
      "attributeName",
      "parameter",
      "binderFactory",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 245
    },
    "return": "Object",
    "signature": "protected Object constructAttribute(Constructor<?> ctor, String attributeName, MethodParameter parameter,\n\t\t\tWebDataBinderFactory binderFactory, NativeWebRequest webRequest)",
    "source_code": "\tprotected Object constructAttribute(Constructor<?> ctor, String attributeName, MethodParameter parameter,"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#createAttribute(attributeName,parameter,binderFactory,webRequest)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Extension point to create the model attribute if not found in the model,\n\t * with subsequent parameter binding through bean properties (unless suppressed).\n\t * <p>The default implementation typically uses the unique public no-arg constructor\n\t * if available but also handles a \"primary constructor\" approach for data classes:\n\t * It understands the JavaBeans {@code ConstructorProperties} annotation as well as\n\t * runtime-retained parameter names in the bytecode, associating request parameters\n\t * with constructor arguments by name. If no such constructor is found, the default\n\t * constructor will be used (even if not public), assuming subsequent bean property\n\t * bindings through setter methods.\n\t * @param attributeName the name of the attribute (never {@code null})\n\t * @param parameter the method parameter declaration\n\t * @param binderFactory for creating WebDataBinder instance\n\t * @param webRequest the current request\n\t * @return the created model attribute (never {@code null})\n\t * @throws BindException in case of constructor argument binding failure\n\t * @throws Exception in case of constructor invocation failure\n\t * @see #constructAttribute(Constructor, String, MethodParameter, WebDataBinderFactory, NativeWebRequest)\n\t * @see BeanUtils#findPrimaryConstructor(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "attributeName",
      "parameter",
      "binderFactory",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "Object",
    "signature": "protected Object createAttribute(String attributeName, MethodParameter parameter,\n\t\t\tWebDataBinderFactory binderFactory, NativeWebRequest webRequest)",
    "source_code": "\tprotected Object createAttribute(String attributeName, MethodParameter parameter,"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#getParameterAnnotations()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 508
    },
    "return": "Annotation[]",
    "signature": "public Annotation[] getParameterAnnotations()",
    "source_code": "\t\tpublic Annotation[] getParameterAnnotations() {\n\t\t\tAnnotation[] anns = this.combinedAnnotations;\n\t\t\tif (anns == null) {\n\t\t\t\tanns = super.getParameterAnnotations();\n\t\t\t\ttry {\n\t\t\t\t\tField field = getDeclaringClass().getDeclaredField(this.parameterName);\n\t\t\t\t\tAnnotation[] fieldAnns = field.getAnnotations();\n\t\t\t\t\tif (fieldAnns.length > 0) {\n\t\t\t\t\t\tList<Annotation> merged = new ArrayList<>(anns.length + fieldAnns.length);\n\t\t\t\t\t\tmerged.addAll(Arrays.asList(anns));\n\t\t\t\t\t\tfor (Annotation fieldAnn : fieldAnns) {\n\t\t\t\t\t\t\tboolean existingType = false;\n\t\t\t\t\t\t\tfor (Annotation ann : anns) {\n\t\t\t\t\t\t\t\tif (ann.annotationType() == fieldAnn.annotationType()) {\n\t\t\t\t\t\t\t\t\texistingType = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!existingType) {\n\t\t\t\t\t\t\t\tmerged.add(fieldAnn);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tanns = merged.toArray(new Annotation[0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchFieldException | SecurityException ex) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t\tthis.combinedAnnotations = anns;\n\t\t\t}\n\t\t\treturn anns;\n\t\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#getParameterName()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 542
    },
    "return": "String",
    "signature": "public String getParameterName()",
    "source_code": "\t\tpublic String getParameterName() {\n\t\t\treturn this.parameterName;\n\t\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#getTarget()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "Object",
    "signature": "public Object getTarget()",
    "source_code": "\t\t\t\t\t\tpublic Object getTarget() {\n\t\t\t\t\t\t\treturn target;\n\t\t\t\t\t\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#handleReturnValue(returnValue,returnType,mavContainer,webRequest)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add non-null return values to the {@link ModelAndViewContainer}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "mavContainer",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 481
    },
    "return": "void",
    "signature": "public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest)",
    "source_code": "\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#isBindExceptionRequired(binder,parameter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to raise a fatal bind exception on validation errors.\n\t * <p>The default implementation delegates to {@link #isBindExceptionRequired(MethodParameter)}.\n\t * @param binder the data binder used to perform data binding\n\t * @param parameter the method parameter declaration\n\t * @return {@code true} if the next method parameter is not of type {@link Errors}\n\t * @see #isBindExceptionRequired(MethodParameter)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 449
    },
    "return": "boolean",
    "signature": "protected boolean isBindExceptionRequired(WebDataBinder binder, MethodParameter parameter)",
    "source_code": "\tprotected boolean isBindExceptionRequired(WebDataBinder binder, MethodParameter parameter) {\n\t\treturn isBindExceptionRequired(parameter);\n\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#isBindExceptionRequired(parameter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to raise a fatal bind exception on validation errors.\n\t * @param parameter the method parameter declaration\n\t * @return {@code true} if the next method parameter is not of type {@link Errors}\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 459
    },
    "return": "boolean",
    "signature": "protected boolean isBindExceptionRequired(MethodParameter parameter)",
    "source_code": "\tprotected boolean isBindExceptionRequired(MethodParameter parameter) {\n\t\tint i = parameter.getParameterIndex();\n\t\tClass<?>[] paramTypes = parameter.getExecutable().getParameterTypes();\n\t\tboolean hasBindingResult = (paramTypes.length > (i + 1) && Errors.class.isAssignableFrom(paramTypes[i + 1]));\n\t\treturn !hasBindingResult;\n\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#resolveArgument(parameter,mavContainer,webRequest,binderFactory)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the argument from the model or if not found instantiate it with\n\t * its default if it is available. The model attribute is then populated\n\t * with request values via data binding and optionally validated\n\t * if {@code @java.validation.Valid} is present on the argument.\n\t * @throws BindException if data binding and validation result in an error\n\t * and the next method parameter is not of type {@link Errors}\n\t * @throws Exception if WebDataBinder initialization fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "mavContainer",
      "webRequest",
      "binderFactory"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "Object",
    "signature": "public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)",
    "source_code": "\tpublic final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#resolveConstructorArgument(paramName,paramType,request)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName",
      "paramType",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 362
    },
    "return": "Object",
    "signature": "public Object resolveConstructorArgument(String paramName, Class<?> paramType, NativeWebRequest request)",
    "source_code": "\tpublic Object resolveConstructorArgument(String paramName, Class<?> paramType, NativeWebRequest request)"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#supportsParameter(parameter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns {@code true} if the parameter is annotated with\n\t * {@link ModelAttribute} or, if in default resolution mode, for any\n\t * method parameter that is not a simple type.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "boolean",
    "signature": "public boolean supportsParameter(MethodParameter parameter)",
    "source_code": "\tpublic boolean supportsParameter(MethodParameter parameter) {\n\t\treturn (parameter.hasParameterAnnotation(ModelAttribute.class) ||\n\t\t\t\t(this.annotationNotRequired && !BeanUtils.isSimpleProperty(parameter.getParameterType())));\n\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#supportsReturnType(returnType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return {@code true} if there is a method-level {@code @ModelAttribute}\n\t * or, in default resolution mode, for any return value type that is not\n\t * a simple type.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnType"
    ],
    "position": {
      "column": 1,
      "line": 472
    },
    "return": "boolean",
    "signature": "public boolean supportsReturnType(MethodParameter returnType)",
    "source_code": "\tpublic boolean supportsReturnType(MethodParameter returnType) {\n\t\treturn (returnType.hasMethodAnnotation(ModelAttribute.class) ||\n\t\t\t\t(this.annotationNotRequired && !BeanUtils.isSimpleProperty(returnType.getParameterType())));\n\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#validateIfApplicable(binder,parameter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Validate the model attribute if applicable.\n\t * <p>The default implementation checks for {@code @jakarta.validation.Valid},\n\t * Spring's {@link org.springframework.validation.annotation.Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param binder the DataBinder to be used\n\t * @param parameter the method parameter declaration\n\t * @see WebDataBinder#validate(Object...)\n\t * @see SmartValidator#validate(Object, Errors, Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 395
    },
    "return": "void",
    "signature": "protected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter)",
    "source_code": "\tprotected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter) {\n\t\tfor (Annotation ann : parameter.getParameterAnnotations()) {\n\t\t\tObject[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);\n\t\t\tif (validationHints != null) {\n\t\t\t\tbinder.validate(validationHints);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#validateValueIfApplicable(binder,parameter,targetType,fieldName,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Validate the specified candidate value if applicable.\n\t * <p>The default implementation checks for {@code @jakarta.validation.Valid},\n\t * Spring's {@link org.springframework.validation.annotation.Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param binder the DataBinder to be used\n\t * @param parameter the method parameter declaration\n\t * @param targetType the target type\n\t * @param fieldName the name of the field\n\t * @param value the candidate value\n\t * @since 5.1\n\t * @see #validateIfApplicable(WebDataBinder, MethodParameter)\n\t * @see SmartValidator#validateValue(Class, String, Object, Errors, Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "parameter",
      "targetType",
      "fieldName",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 419
    },
    "return": "void",
    "signature": "protected void validateValueIfApplicable(WebDataBinder binder, MethodParameter parameter,\n\t\t\tClass<?> targetType, String fieldName, @Nullable Object value)",
    "source_code": "\tprotected void validateValueIfApplicable(WebDataBinder binder, MethodParameter parameter,"
  },
  "org.springframework.web.method.annotation.NamedValueInfo": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Represents the information about a named value, including name, whether it's required and a default value.\n\t */",
    "kind": "class",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "signature": "protected class NamedValueInfo",
    "source_code": "\tprotected static class NamedValueInfo {\n\n\t\tprivate final String name;\n\n\t\tprivate final boolean required;\n\n\t\t@Nullable\n\t\tprivate final String defaultValue;\n\n\t\tpublic NamedValueInfo(String name, boolean required, @Nullable String defaultValue) {\n\t\t\tthis.name = name;\n\t\t\tthis.required = required;\n\t\t\tthis.defaultValue = defaultValue;\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.SESSION_KNOWN_ATTRIBUTE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Key for known-attribute-names storage (a String array) as a session attribute.\n\t * <p>This is necessary for consistent handling of type-based session attributes\n\t * in distributed session scenarios where handler methods from the same class\n\t * may get invoked on different servers.\n\t * @since 6.1.4\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "signature": "public String SESSION_KNOWN_ATTRIBUTE",
    "source_code": "\tpublic static final String SESSION_KNOWN_ATTRIBUTE = SessionAttributesHandler.class.getName() + \".KNOWN\";",
    "type": "String"
  },
  "org.springframework.web.method.annotation.SessionAttributesHandler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Manages controller-specific session attributes declared via\n * {@link SessionAttributes @SessionAttributes}. Actual storage is\n * delegated to a {@link SessionAttributeStore} instance.\n *\n * <p>When a controller annotated with {@code @SessionAttributes} adds\n * attributes to its model, those attributes are checked against names and\n * types specified via {@code @SessionAttributes}. Matching model attributes\n * are saved in the HTTP session and remain there until the controller calls\n * {@link SessionStatus#setComplete()}.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "public class SessionAttributesHandler",
    "source_code": "public class SessionAttributesHandler {\n\n\t/**\n\t * Key for known-attribute-names storage (a String array) as a session attribute.\n\t * <p>This is necessary for consistent handling of type-based session attributes\n\t * in distributed session scenarios where handler methods from the same class\n\t * may get invoked on different servers.\n\t * @since 6.1.4\n\t */\n\tpublic static final String SESSION_KNOWN_ATTRIBUTE = SessionAttributesHandler.class.getName() + \".KNOWN\";\n\n\n\tprivate final Set<String> attributeNames = new HashSet<>();\n\n\tprivate final Set<Class<?>> attributeTypes = new HashSet<>();\n\n\tprivate final Set<String> knownAttributeNames = Collections.newSetFromMap(new ConcurrentHashMap<>(4));\n\n\tprivate final SessionAttributeStore sessionAttributeStore;\n\n\n\t/**\n\t * Create a new session attributes handler. Session attribute names and types\n\t * are extracted from the {@code @SessionAttributes} annotation, if present,\n\t * on the given type.\n\t * @param handlerType the controller type\n\t * @param sessionAttributeStore used for session access\n\t */\n\tpublic SessionAttributesHandler(Class<?> handlerType, SessionAttributeStore sessionAttributeStore) {\n\t\tAssert.notNull(sessionAttributeStore, \"SessionAttributeStore may not be null\");\n\t\tthis.sessionAttributeStore = sessionAttributeStore;\n\n\t\tSessionAttributes ann = AnnotatedElementUtils.findMergedAnnotation(handlerType, SessionAttributes.class);\n\t\tif (ann != null) {\n\t\t\tCollections.addAll(this.attributeNames, ann.names());\n\t\t\tCollections.addAll(this.attributeTypes, ann.types());\n\t\t}\n\t\tthis.knownAttributeNames.addAll(this.attributeNames);\n\t}\n\n\n\t/**\n\t * Whether the controller represented by this instance has declared any\n\t * session attributes through an {@link SessionAttributes} annotation.\n\t */\n\tpublic boolean hasSessionAttributes() {\n\t\treturn (!this.attributeNames.isEmpty() || !this.attributeTypes.isEmpty());\n\t}\n\n\t/**\n\t * Whether the attribute name or type match the names and types specified\n\t * via {@code @SessionAttributes} on the underlying controller.\n\t * <p>Attributes successfully resolved through this method are \"remembered\"\n\t * and subsequently used in {@link #retrieveAttributes(WebRequest)} and\n\t * {@link #cleanupAttributes(WebRequest)}.\n\t * @param attributeName the attribute name to check\n\t * @param attributeType the type for the attribute\n\t */\n\tpublic boolean isHandlerSessionAttribute(String attributeName, Class<?> attributeType) {\n\t\tAssert.notNull(attributeName, \"Attribute name must not be null\");\n\t\tif (this.attributeTypes.contains(attributeType)) {\n\t\t\tthis.knownAttributeNames.add(attributeName);\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn this.attributeNames.contains(attributeName);\n\t\t}\n\t}\n\n\t/**\n\t * Store a subset of the given attributes in the session. Attributes not\n\t * declared as session attributes via {@code @SessionAttributes} are ignored.\n\t * @param request the current request\n\t * @param attributes candidate attributes for session storage\n\t */\n\tpublic void storeAttributes(WebRequest request, Map<String, ?> attributes) {\n\t\tattributes.forEach((name, value) -> {\n\t\t\tif (value != null && isHandlerSessionAttribute(name, value.getClass())) {\n\t\t\t\tthis.sessionAttributeStore.storeAttribute(request, name, value);\n\t\t\t}\n\t\t});\n\n\t\t// Store known attribute names in session (for distributed sessions)\n\t\t// Only necessary for type-based attributes which get added to knownAttributeNames when touched.\n\t\tif (!this.attributeTypes.isEmpty()) {\n\t\t\tthis.sessionAttributeStore.storeAttribute(request,\n\t\t\t\t\tSESSION_KNOWN_ATTRIBUTE, StringUtils.toStringArray(this.knownAttributeNames));\n\t\t}\n\t}\n\n\t/**\n\t * Retrieve \"known\" attributes from the session, i.e. attributes listed\n\t * by name in {@code @SessionAttributes} or attributes previously stored\n\t * in the model that matched by type.\n\t * @param request the current request\n\t * @return a map with handler session attributes, possibly empty\n\t */\n\tpublic Map<String, Object> retrieveAttributes(WebRequest request) {\n\t\t// Restore known attribute names from session (for distributed sessions)\n\t\t// Only necessary for type-based attributes which get added to knownAttributeNames when touched.\n\t\tif (!this.attributeTypes.isEmpty()) {\n\t\t\tObject known = this.sessionAttributeStore.retrieveAttribute(request, SESSION_KNOWN_ATTRIBUTE);\n\t\t\tif (known instanceof String[] retrievedAttributeNames) {\n\t\t\t\tthis.knownAttributeNames.addAll(Arrays.asList(retrievedAttributeNames));\n\t\t\t}\n\t\t}\n\n\t\tMap<String, Object> attributes = new HashMap<>();\n\t\tfor (String name : this.knownAttributeNames) {\n\t\t\tObject value = this.sessionAttributeStore.retrieveAttribute(request, name);\n\t\t\tif (value != null) {\n\t\t\t\tattributes.put(name, value);\n\t\t\t}\n\t\t}\n\t\treturn attributes;\n\t}\n\n\t/**\n\t * Remove \"known\" attributes from the session, i.e. attributes listed\n\t * by name in {@code @SessionAttributes} or attributes previously stored\n\t * in the model that matched by type.\n\t * @param request the current request\n\t */\n\tpublic void cleanupAttributes(WebRequest request) {\n\t\tfor (String attributeName : this.knownAttributeNames) {\n\t\t\tthis.sessionAttributeStore.cleanupAttribute(request, attributeName);\n\t\t}\n\t}\n\n\t/**\n\t * A pass-through call to the underlying {@link SessionAttributeStore}.\n\t * @param request the current request\n\t * @param attributeName the name of the attribute of interest\n\t * @return the attribute value, or {@code null} if none\n\t */\n\t@Nullable\n\tObject retrieveAttribute(WebRequest request, String attributeName) {\n\t\treturn this.sessionAttributeStore.retrieveAttribute(request, attributeName);\n\t}\n\n}"
  },
  "org.springframework.web.method.annotation.SessionAttributesHandler#cleanupAttributes(request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Remove \"known\" attributes from the session, i.e. attributes listed\n\t * by name in {@code @SessionAttributes} or attributes previously stored\n\t * in the model that matched by type.\n\t * @param request the current request\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "void",
    "signature": "public void cleanupAttributes(WebRequest request)",
    "source_code": "\tpublic void cleanupAttributes(WebRequest request) {\n\t\tfor (String attributeName : this.knownAttributeNames) {\n\t\t\tthis.sessionAttributeStore.cleanupAttribute(request, attributeName);\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.SessionAttributesHandler#hasSessionAttributes()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the controller represented by this instance has declared any\n\t * session attributes through an {@link SessionAttributes} annotation.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "boolean",
    "signature": "public boolean hasSessionAttributes()",
    "source_code": "\tpublic boolean hasSessionAttributes() {\n\t\treturn (!this.attributeNames.isEmpty() || !this.attributeTypes.isEmpty());\n\t}"
  },
  "org.springframework.web.method.annotation.SessionAttributesHandler#isHandlerSessionAttribute(attributeName,attributeType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the attribute name or type match the names and types specified\n\t * via {@code @SessionAttributes} on the underlying controller.\n\t * <p>Attributes successfully resolved through this method are \"remembered\"\n\t * and subsequently used in {@link #retrieveAttributes(WebRequest)} and\n\t * {@link #cleanupAttributes(WebRequest)}.\n\t * @param attributeName the attribute name to check\n\t * @param attributeType the type for the attribute\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "attributeType"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "boolean",
    "signature": "public boolean isHandlerSessionAttribute(String attributeName, Class<?> attributeType)",
    "source_code": "\tpublic boolean isHandlerSessionAttribute(String attributeName, Class<?> attributeType) {\n\t\tAssert.notNull(attributeName, \"Attribute name must not be null\");\n\t\tif (this.attributeTypes.contains(attributeType)) {\n\t\t\tthis.knownAttributeNames.add(attributeName);\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn this.attributeNames.contains(attributeName);\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.SessionAttributesHandler#retrieveAttributes(request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve \"known\" attributes from the session, i.e. attributes listed\n\t * by name in {@code @SessionAttributes} or attributes previously stored\n\t * in the model that matched by type.\n\t * @param request the current request\n\t * @return a map with handler session attributes, possibly empty\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "Object>",
    "signature": "public Object> retrieveAttributes(WebRequest request)",
    "source_code": "\tpublic Map<String, Object> retrieveAttributes(WebRequest request) {\n\t\t// Restore known attribute names from session (for distributed sessions)\n\t\t// Only necessary for type-based attributes which get added to knownAttributeNames when touched.\n\t\tif (!this.attributeTypes.isEmpty()) {\n\t\t\tObject known = this.sessionAttributeStore.retrieveAttribute(request, SESSION_KNOWN_ATTRIBUTE);\n\t\t\tif (known instanceof String[] retrievedAttributeNames) {\n\t\t\t\tthis.knownAttributeNames.addAll(Arrays.asList(retrievedAttributeNames));\n\t\t\t}\n\t\t}\n\n\t\tMap<String, Object> attributes = new HashMap<>();\n\t\tfor (String name : this.knownAttributeNames) {\n\t\t\tObject value = this.sessionAttributeStore.retrieveAttribute(request, name);\n\t\t\tif (value != null) {\n\t\t\t\tattributes.put(name, value);\n\t\t\t}\n\t\t}\n\t\treturn attributes;\n\t}"
  },
  "org.springframework.web.method.annotation.SessionAttributesHandler#storeAttributes(request,Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Store a subset of the given attributes in the session. Attributes not\n\t * declared as session attributes via {@code @SessionAttributes} are ignored.\n\t * @param request the current request\n\t * @param attributes candidate attributes for session storage\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void storeAttributes(WebRequest request, Map<String, ?> attributes)",
    "source_code": "\tpublic void storeAttributes(WebRequest request, Map<String, ?> attributes) {\n\t\tattributes.forEach((name, value) -> {\n\t\t\tif (value != null && isHandlerSessionAttribute(name, value.getClass())) {\n\t\t\t\tthis.sessionAttributeStore.storeAttribute(request, name, value);\n\t\t\t}\n\t\t});\n\n\t\t// Store known attribute names in session (for distributed sessions)\n\t\t// Only necessary for type-based attributes which get added to knownAttributeNames when touched.\n\t\tif (!this.attributeTypes.isEmpty()) {\n\t\t\tthis.sessionAttributeStore.storeAttribute(request,\n\t\t\t\t\tSESSION_KNOWN_ATTRIBUTE, StringUtils.toStringArray(this.knownAttributeNames));\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.logger": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.web.method.support.InvocableHandlerMethod#invokeFunction(method,target,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "target",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "Object",
    "signature": "public Object invokeFunction(Method method, Object target, Object[] args)",
    "source_code": "\t\tpublic static Object invokeFunction(Method method, Object target, Object[] args) throws InvocationTargetException, IllegalAccessException {\n\t\t\tKFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);\n\t\t\t// For property accessors\n\t\t\tif (function == null) {\n\t\t\t\treturn method.invoke(target, args);\n\t\t\t}\n\t\t\tif (method.isAccessible() && !KCallablesJvm.isAccessible(function)) {\n\t\t\t\tKCallablesJvm.setAccessible(function, true);\n\t\t\t}\n\t\t\tMap<KParameter, Object> argMap = CollectionUtils.newHashMap(args.length + 1);\n\t\t\tint index = 0;\n\t\t\tfor (KParameter parameter : function.getParameters()) {\n\t\t\t\tswitch (parameter.getKind()) {\n\t\t\t\t\tcase INSTANCE -> argMap.put(parameter, target);\n\t\t\t\t\tcase VALUE, EXTENSION_RECEIVER -> {\n\t\t\t\t\t\tObject arg = args[index];\n\t\t\t\t\t\tif (!(parameter.isOptional() && arg == null)) {\n\t\t\t\t\t\t\tKType type = parameter.getType();\n\t\t\t\t\t\t\tif (!(type.isMarkedNullable() && arg == null) && type.getClassifier() instanceof KClass<?> kClass\n\t\t\t\t\t\t\t\t\t&& KotlinDetector.isInlineClass(JvmClassMappingKt.getJavaClass(kClass))) {\n\t\t\t\t\t\t\t\tKFunction<?> constructor = KClasses.getPrimaryConstructor(kClass);\n\t\t\t\t\t\t\t\tif (!KCallablesJvm.isAccessible(constructor)) {\n\t\t\t\t\t\t\t\t\tKCallablesJvm.setAccessible(constructor, true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\targ = constructor.call(arg);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targMap.put(parameter, arg);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tObject result = function.callBy(argMap);\n\t\t\treturn (result == Unit.INSTANCE ? null : result);\n\t\t}"
  },
  "org.springframework.web.method.support.InvocableHandlerMethod#setMethodValidator(methodValidator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link MethodValidator} to perform method validation with if the\n\t * controller method {@link #shouldValidateArguments()} or\n\t * {@link #shouldValidateReturnValue()}.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodValidator"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "public void setMethodValidator(@Nullable MethodValidator methodValidator)",
    "source_code": "\tpublic void setMethodValidator(@Nullable MethodValidator methodValidator) {\n\t\tthis.methodValidator = methodValidator;\n\t\tthis.validationGroups = (methodValidator != null ?\n\t\t\t\tmethodValidator.determineValidationGroups(getBean(), getBridgedMethod()) : EMPTY_GROUPS);\n\t}"
  },
  "org.springframework.web.reactive.BindingContext": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Context to assist with binding request data onto Objects and provide access\n * to a shared {@link Model} with controller-specific attributes.\n *\n * <p>Provides  methods to create a {@link WebExchangeDataBinder} for a specific\n * target, command Object to apply data binding and validation to, or without a\n * target Object for simple type conversion from request values.\n *\n * <p>Container for the default model for the request.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "signature": "public class BindingContext",
    "source_code": "public class BindingContext {\n\n\t@Nullable\n\tprivate final WebBindingInitializer initializer;\n\n\tprivate final Model model = new BindingAwareConcurrentModel();\n\n\tprivate boolean methodValidationApplicable;\n\n\tprivate final ReactiveAdapterRegistry reactiveAdapterRegistry;\n\n\n\t/**\n\t * Create an instance without an initializer.\n\t */\n\tpublic BindingContext() {\n\t\tthis(null);\n\t}\n\n\t/**\n\t * Create an instance with the given initializer, which may be {@code null}.\n\t */\n\tpublic BindingContext(@Nullable WebBindingInitializer initializer) {\n\t\tthis(initializer, ReactiveAdapterRegistry.getSharedInstance());\n\t}\n\n\t/**\n\t * Create an instance with the given initializer and {@code ReactiveAdapterRegistry}.\n\t * @since 6.1\n\t */\n\tpublic BindingContext(@Nullable WebBindingInitializer initializer, ReactiveAdapterRegistry registry) {\n\t\tthis.initializer = initializer;\n\t\tthis.reactiveAdapterRegistry = new ReactiveAdapterRegistry();\n\t}\n\n\n\t/**\n\t * Return the default model.\n\t */\n\tpublic Model getModel() {\n\t\treturn this.model;\n\t}\n\n\t/**\n\t * Configure flag to signal whether validation will be applied to handler\n\t * method arguments, which is the case if Bean Validation is enabled in\n\t * Spring MVC, and method parameters have {@code @Constraint} annotations.\n\t * @since 6.1\n\t */\n\tpublic void setMethodValidationApplicable(boolean methodValidationApplicable) {\n\t\tthis.methodValidationApplicable = methodValidationApplicable;\n\t}\n\n\n\t/**\n\t * Create a binder with a target object.\n\t * @param exchange the current exchange\n\t * @param target the object to create a data binder for\n\t * @param name the name of the target object\n\t * @return the created data binder\n\t * @throws ServerErrorException if {@code @InitBinder} method invocation fails\n\t */\n\tpublic WebExchangeDataBinder createDataBinder(ServerWebExchange exchange, @Nullable Object target, String name) {\n\t\treturn createDataBinder(exchange, target, name, null);\n\t}\n\n\t/**\n\t * Shortcut method to create a binder without a target object.\n\t * @param exchange the current exchange\n\t * @param name the name of the target object\n\t * @return the created data binder\n\t * @throws ServerErrorException if {@code @InitBinder} method invocation fails\n\t */\n\tpublic WebExchangeDataBinder createDataBinder(ServerWebExchange exchange, String name) {\n\t\treturn createDataBinder(exchange, null, name, null);\n\t}\n\n\t/**\n\t * Create a binder with a target object and a {@link ResolvableType targetType}.\n\t * If the target is {@code null}, then\n\t * {@link WebExchangeDataBinder#setTargetType targetType} is set.\n\t * @since 6.1\n\t */\n\tpublic WebExchangeDataBinder createDataBinder(\n\t\t\tServerWebExchange exchange, @Nullable Object target, String name, @Nullable ResolvableType targetType) {\n\n\t\tWebExchangeDataBinder dataBinder = new ExtendedWebExchangeDataBinder(target, name);\n\t\tdataBinder.setNameResolver(new BindParamNameResolver());\n\n\t\tif (target == null && targetType != null) {\n\t\t\tdataBinder.setTargetType(targetType);\n\t\t}\n\n\t\tif (this.initializer != null) {\n\t\t\tthis.initializer.initBinder(dataBinder);\n\t\t}\n\n\t\tdataBinder = initDataBinder(dataBinder, exchange);\n\n\t\tif (this.methodValidationApplicable && targetType != null) {\n\t\t\tif (targetType.getSource() instanceof MethodParameter parameter) {\n\t\t\t\tMethodValidationInitializer.initBinder(dataBinder, parameter);\n\t\t\t}\n\t\t}\n\n\t\treturn dataBinder;\n\t}\n\n\t/**\n\t * Initialize the data binder instance for the given exchange.\n\t * @throws ServerErrorException if {@code @InitBinder} method invocation fails\n\t */\n\tprotected WebExchangeDataBinder initDataBinder(WebExchangeDataBinder binder, ServerWebExchange exchange) {\n\t\treturn binder;\n\t}\n\n\t/**\n\t * Invoked before rendering to add {@link BindingResult} attributes where\n\t * necessary, and also to promote model attributes listed as\n\t * {@code @SessionAttributes} to the session.\n\t * @param exchange the current exchange\n\t * @since 6.1\n\t */\n\tpublic void updateModel(ServerWebExchange exchange) {\n\t\tMap<String, Object> model = getModel().asMap();\n\t\tfor (Map.Entry<String, Object> entry : model.entrySet()) {\n\t\t\tString name = entry.getKey();\n\t\t\tObject value = entry.getValue();\n\t\t\tif (isBindingCandidate(name, value)) {\n\t\t\t\tif (!model.containsKey(BindingResult.MODEL_KEY_PREFIX + name)) {\n\t\t\t\t\tWebExchangeDataBinder binder = createDataBinder(exchange, value, name);\n\t\t\t\t\tmodel.put(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean isBindingCandidate(String name, @Nullable Object value) {\n\t\treturn (!name.startsWith(BindingResult.MODEL_KEY_PREFIX) && value != null &&\n\t\t\t\t!value.getClass().isArray() && !(value instanceof Collection) && !(value instanceof Map) &&\n\t\t\t\tthis.reactiveAdapterRegistry.getAdapter(null, value) == null &&\n\t\t\t\t!BeanUtils.isSimpleValueType(value.getClass()));\n\t}\n\n\n\t/**\n\t * Extended variant of {@link WebExchangeDataBinder}, adding path variables.\n\t */\n\tprivate static class ExtendedWebExchangeDataBinder extends WebExchangeDataBinder {\n\n\t\tpublic ExtendedWebExchangeDataBinder(@Nullable Object target, String objectName) {\n\t\t\tsuper(target, objectName);\n\t\t}\n\n\t\t@Override\n\t\tpublic Mono<Map<String, Object>> getValuesToBind(ServerWebExchange exchange) {\n\t\t\treturn super.getValuesToBind(exchange).doOnNext(map ->\n\t\t\t\t\tmap.putAll(exchange.<Map<String, String>>getAttributeOrDefault(\n\t\t\t\t\t\t\tHandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE, Collections.emptyMap())));\n\t\t}\n\t}\n\n\n\t/**\n\t * Excludes Bean Validation if the method parameter has {@code @Valid}.\n\t */\n\tprivate static class MethodValidationInitializer {\n\n\t\tpublic static void initBinder(DataBinder binder, MethodParameter parameter) {\n\t\t\tif (ReactiveAdapterRegistry.getSharedInstance().getAdapter(parameter.getParameterType()) == null) {\n\t\t\t\tfor (Annotation annotation : parameter.getParameterAnnotations()) {\n\t\t\t\t\tif (annotation.annotationType().getName().equals(\"jakarta.validation.Valid\")) {\n\t\t\t\t\t\tbinder.setExcludedValidators(v -> v instanceof jakarta.validation.Validator ||\n\t\t\t\t\t\t\t\tv instanceof SmartValidator sv && sv.unwrap(jakarta.validation.Validator.class) != null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.reactive.BindingContext#createDataBinder(exchange,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Shortcut method to create a binder without a target object.\n\t * @param exchange the current exchange\n\t * @param name the name of the target object\n\t * @return the created data binder\n\t * @throws ServerErrorException if {@code @InitBinder} method invocation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "WebExchangeDataBinder",
    "signature": "public WebExchangeDataBinder createDataBinder(ServerWebExchange exchange, String name)",
    "source_code": "\tpublic WebExchangeDataBinder createDataBinder(ServerWebExchange exchange, String name) {\n\t\treturn createDataBinder(exchange, null, name, null);\n\t}"
  },
  "org.springframework.web.reactive.BindingContext#createDataBinder(exchange,target,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a binder with a target object.\n\t * @param exchange the current exchange\n\t * @param target the object to create a data binder for\n\t * @param name the name of the target object\n\t * @return the created data binder\n\t * @throws ServerErrorException if {@code @InitBinder} method invocation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "WebExchangeDataBinder",
    "signature": "public WebExchangeDataBinder createDataBinder(ServerWebExchange exchange, @Nullable Object target, String name)",
    "source_code": "\tpublic WebExchangeDataBinder createDataBinder(ServerWebExchange exchange, @Nullable Object target, String name) {\n\t\treturn createDataBinder(exchange, target, name, null);\n\t}"
  },
  "org.springframework.web.reactive.BindingContext#createDataBinder(exchange,target,name,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a binder with a target object and a {@link ResolvableType targetType}.\n\t * If the target is {@code null}, then\n\t * {@link WebExchangeDataBinder#setTargetType targetType} is set.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "target",
      "name",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "WebExchangeDataBinder",
    "signature": "public WebExchangeDataBinder createDataBinder(ServerWebExchange exchange, @Nullable Object target, String name, @Nullable ResolvableType targetType)",
    "source_code": "\tpublic WebExchangeDataBinder createDataBinder("
  },
  "org.springframework.web.reactive.BindingContext#getModel()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the default model.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "Model",
    "signature": "public Model getModel()",
    "source_code": "\tpublic Model getModel() {\n\t\treturn this.model;\n\t}"
  },
  "org.springframework.web.reactive.BindingContext#getValuesToBind(exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "Object>>",
    "signature": "public Object>> getValuesToBind(ServerWebExchange exchange)",
    "source_code": "\t\tpublic Mono<Map<String, Object>> getValuesToBind(ServerWebExchange exchange) {\n\t\t\treturn super.getValuesToBind(exchange).doOnNext(map ->\n\t\t\t\t\tmap.putAll(exchange.<Map<String, String>>getAttributeOrDefault(\n\t\t\t\t\t\t\tHandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE, Collections.emptyMap())));\n\t\t}"
  },
  "org.springframework.web.reactive.BindingContext#initBinder(binder,parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "binder",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "void",
    "signature": "public void initBinder(DataBinder binder, MethodParameter parameter)",
    "source_code": "\t\tpublic static void initBinder(DataBinder binder, MethodParameter parameter) {\n\t\t\tif (ReactiveAdapterRegistry.getSharedInstance().getAdapter(parameter.getParameterType()) == null) {\n\t\t\t\tfor (Annotation annotation : parameter.getParameterAnnotations()) {\n\t\t\t\t\tif (annotation.annotationType().getName().equals(\"jakarta.validation.Valid\")) {\n\t\t\t\t\t\tbinder.setExcludedValidators(v -> v instanceof jakarta.validation.Validator ||\n\t\t\t\t\t\t\t\tv instanceof SmartValidator sv && sv.unwrap(jakarta.validation.Validator.class) != null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.reactive.BindingContext#initDataBinder(binder,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the data binder instance for the given exchange.\n\t * @throws ServerErrorException if {@code @InitBinder} method invocation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "WebExchangeDataBinder",
    "signature": "protected WebExchangeDataBinder initDataBinder(WebExchangeDataBinder binder, ServerWebExchange exchange)",
    "source_code": "\tprotected WebExchangeDataBinder initDataBinder(WebExchangeDataBinder binder, ServerWebExchange exchange) {\n\t\treturn binder;\n\t}"
  },
  "org.springframework.web.reactive.BindingContext#setMethodValidationApplicable(methodValidationApplicable)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure flag to signal whether validation will be applied to handler\n\t * method arguments, which is the case if Bean Validation is enabled in\n\t * Spring MVC, and method parameters have {@code @Constraint} annotations.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodValidationApplicable"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "void",
    "signature": "public void setMethodValidationApplicable(boolean methodValidationApplicable)",
    "source_code": "\tpublic void setMethodValidationApplicable(boolean methodValidationApplicable) {\n\t\tthis.methodValidationApplicable = methodValidationApplicable;\n\t}"
  },
  "org.springframework.web.reactive.BindingContext#updateModel(exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked before rendering to add {@link BindingResult} attributes where\n\t * necessary, and also to promote model attributes listed as\n\t * {@code @SessionAttributes} to the session.\n\t * @param exchange the current exchange\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "void",
    "signature": "public void updateModel(ServerWebExchange exchange)",
    "source_code": "\tpublic void updateModel(ServerWebExchange exchange) {\n\t\tMap<String, Object> model = getModel().asMap();\n\t\tfor (Map.Entry<String, Object> entry : model.entrySet()) {\n\t\t\tString name = entry.getKey();\n\t\t\tObject value = entry.getValue();\n\t\t\tif (isBindingCandidate(name, value)) {\n\t\t\t\tif (!model.containsKey(BindingResult.MODEL_KEY_PREFIX + name)) {\n\t\t\t\t\tWebExchangeDataBinder binder = createDataBinder(exchange, value, name);\n\t\t\t\t\tmodel.put(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.function.BodyInserters#fromOutputStream(outputStreamConsumer,executor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter based on bytes written to a {@code OutputStream}.\n\t * @param outputStreamConsumer invoked with an {@link OutputStream} that\n\t * writes to the output message\n\t * @param executor used to invoke the {@code outputStreamHandler} on a\n\t * separate thread\n\t * @return an inserter that writes what is written to the output stream\n\t * @since 6.1\n\t * @see DataBufferUtils#outputStreamPublisher(Consumer, DataBufferFactory, Executor)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outputStreamConsumer",
      "executor"
    ],
    "position": {
      "column": 1,
      "line": 376
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> fromOutputStream(Consumer<OutputStream> outputStreamConsumer, Executor executor)",
    "source_code": "\tpublic static <T extends Publisher<DataBuffer>> BodyInserter<T, ReactiveHttpOutputMessage> fromOutputStream("
  },
  "org.springframework.web.reactive.function.BodyInserters#fromOutputStream(outputStreamConsumer,executor,chunkSize)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter based on bytes written to a {@code OutputStream}.\n\t * @param outputStreamConsumer invoked with an {@link OutputStream} that\n\t * writes to the output message\n\t * @param executor used to invoke the {@code outputStreamHandler} on a\n\t * separate thread\n\t * @param chunkSize minimum size of the buffer produced by the publisher\n\t * @return an inserter that writes what is written to the output stream\n\t * @since 6.1\n\t * @see DataBufferUtils#outputStreamPublisher(Consumer, DataBufferFactory, Executor, int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outputStreamConsumer",
      "executor",
      "chunkSize"
    ],
    "position": {
      "column": 1,
      "line": 397
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> fromOutputStream(Consumer<OutputStream> outputStreamConsumer, Executor executor, int chunkSize)",
    "source_code": "\tpublic static <T extends Publisher<DataBuffer>> BodyInserter<T, ReactiveHttpOutputMessage> fromOutputStream("
  },
  "org.springframework.web.reactive.function.client.<unknown>#request()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "HttpRequest",
    "signature": "public HttpRequest request()",
    "source_code": "\tpublic HttpRequest request() {\n\t\treturn this.requestSupplier.get();\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.WebClientAdapter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link ReactorHttpExchangeAdapter} that enables an {@link HttpServiceProxyFactory}\n * to use {@link WebClient} for request execution.\n *\n * <p>Use static factory methods in this class to create an\n * {@code HttpServiceProxyFactory} configured with a given {@code WebClient}.\n *\n * @author Rossen Stoyanchev\n * @since 6.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public class WebClientAdapter",
    "source_code": "public final class WebClientAdapter extends AbstractReactorHttpExchangeAdapter {\n\n\tprivate final WebClient webClient;\n\n\n\t/**\n\t * Package private constructor. See static factory methods.\n\t */\n\tprivate WebClientAdapter(WebClient webClient) {\n\t\tthis.webClient = webClient;\n\t}\n\n\n\t@Override\n\tpublic boolean supportsRequestAttributes() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic Mono<Void> exchangeForMono(HttpRequestValues requestValues) {\n\t\treturn newRequest(requestValues).retrieve().toBodilessEntity().then();\n\t}\n\n\t@Override\n\tpublic Mono<HttpHeaders> exchangeForHeadersMono(HttpRequestValues requestValues) {\n\t\treturn newRequest(requestValues).retrieve().toBodilessEntity().map(ResponseEntity::getHeaders);\n\t}\n\n\t@Override\n\tpublic <T> Mono<T> exchangeForBodyMono(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(requestValues).retrieve().bodyToMono(bodyType);\n\t}\n\n\t@Override\n\tpublic <T> Flux<T> exchangeForBodyFlux(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(requestValues).retrieve().bodyToFlux(bodyType);\n\t}\n\n\t@Override\n\tpublic Mono<ResponseEntity<Void>> exchangeForBodilessEntityMono(HttpRequestValues requestValues) {\n\t\treturn newRequest(requestValues).retrieve().toBodilessEntity();\n\t}\n\n\t@Override\n\tpublic <T> Mono<ResponseEntity<T>> exchangeForEntityMono(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(requestValues).retrieve().toEntity(bodyType);\n\t}\n\n\t@Override\n\tpublic <T> Mono<ResponseEntity<Flux<T>>> exchangeForEntityFlux(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(requestValues).retrieve().toEntityFlux(bodyType);\n\t}\n\n\t@SuppressWarnings(\"ReactiveStreamsUnusedPublisher\")\n\tprivate WebClient.RequestBodySpec newRequest(HttpRequestValues values) {\n\n\t\tHttpMethod httpMethod = values.getHttpMethod();\n\t\tAssert.notNull(httpMethod, \"HttpMethod is required\");\n\n\t\tWebClient.RequestBodyUriSpec uriSpec = this.webClient.method(httpMethod);\n\n\t\tWebClient.RequestBodySpec bodySpec;\n\t\tif (values.getUri() != null) {\n\t\t\tbodySpec = uriSpec.uri(values.getUri());\n\t\t}\n\n\t\telse if (values.getUriTemplate() != null) {\n\t\t\tUriBuilderFactory uriBuilderFactory = values.getUriBuilderFactory();\n\t\t\tif(uriBuilderFactory != null){\n\t\t\t\tURI uri = uriBuilderFactory.expand(values.getUriTemplate(), values.getUriVariables());\n\t\t\t\tbodySpec = uriSpec.uri(uri);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbodySpec = uriSpec.uri(values.getUriTemplate(), values.getUriVariables());\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\"Neither full URL nor URI template\");\n\t\t}\n\n\t\tbodySpec.headers(headers -> headers.putAll(values.getHeaders()));\n\t\tbodySpec.cookies(cookies -> cookies.putAll(values.getCookies()));\n\t\tbodySpec.attributes(attributes -> attributes.putAll(values.getAttributes()));\n\n\t\tif (values.getBodyValue() != null) {\n\t\t\tbodySpec.bodyValue(values.getBodyValue());\n\t\t}\n\t\telse if (values instanceof ReactiveHttpRequestValues reactiveRequestValues) {\n\t\t\tPublisher<?> body = reactiveRequestValues.getBodyPublisher();\n\t\t\tif (body != null) {\n\t\t\t\tParameterizedTypeReference<?> elementType = reactiveRequestValues.getBodyPublisherElementType();\n\t\t\t\tAssert.notNull(elementType, \"Publisher body element type is required\");\n\t\t\t\tbodySpec.body(body, elementType);\n\t\t\t}\n\t\t}\n\n\t\treturn bodySpec;\n\t}\n\n\n\t/**\n\t * Create a {@link WebClientAdapter} for the given {@code WebClient} instance.\n\t * @param webClient the client to use\n\t * @return the created adapter instance\n\t * @since 6.1\n\t */\n\tpublic static WebClientAdapter create(WebClient webClient) {\n\t\treturn new WebClientAdapter(webClient);\n\t}\n\n\t/**\n\t * Create a {@link WebClientAdapter} for the given {@code WebClient} instance.\n\t * @param webClient the client to use\n\t * @return the created adapter instance\n\t * @deprecated in favor of {@link #create(WebClient)} aligning with other adapter\n\t * implementations; to be removed in 6.2.\n\t */\n\t@Deprecated(since = \"6.1\", forRemoval = true)\n\tpublic static WebClientAdapter forClient(WebClient webClient) {\n\t\treturn new WebClientAdapter(webClient);\n\t}\n\n}"
  },
  "org.springframework.web.reactive.function.client.support.WebClientAdapter#create(webClient)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link WebClientAdapter} for the given {@code WebClient} instance.\n\t * @param webClient the client to use\n\t * @return the created adapter instance\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webClient"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "WebClientAdapter",
    "signature": "public WebClientAdapter create(WebClient webClient)",
    "source_code": "\tpublic static WebClientAdapter create(WebClient webClient) {\n\t\treturn new WebClientAdapter(webClient);\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.WebClientAdapter#exchangeForBodilessEntityMono(requestValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "Mono<ResponseEntity<Void>>",
    "signature": "public Mono<ResponseEntity<Void>> exchangeForBodilessEntityMono(HttpRequestValues requestValues)",
    "source_code": "\tpublic Mono<ResponseEntity<Void>> exchangeForBodilessEntityMono(HttpRequestValues requestValues) {\n\t\treturn newRequest(requestValues).retrieve().toBodilessEntity();\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.WebClientAdapter#exchangeForBodyFlux(requestValues,bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestValues",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "Flux<T>",
    "signature": "public Flux<T> exchangeForBodyFlux(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic <T> Flux<T> exchangeForBodyFlux(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(requestValues).retrieve().bodyToFlux(bodyType);\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.WebClientAdapter#exchangeForBodyMono(requestValues,bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestValues",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> exchangeForBodyMono(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic <T> Mono<T> exchangeForBodyMono(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(requestValues).retrieve().bodyToMono(bodyType);\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.WebClientAdapter#exchangeForEntityFlux(requestValues,bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestValues",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "Mono<ResponseEntity<Flux<T>>>",
    "signature": "public Mono<ResponseEntity<Flux<T>>> exchangeForEntityFlux(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic <T> Mono<ResponseEntity<Flux<T>>> exchangeForEntityFlux(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(requestValues).retrieve().toEntityFlux(bodyType);\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.WebClientAdapter#exchangeForEntityMono(requestValues,bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestValues",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "Mono<ResponseEntity<T>>",
    "signature": "public Mono<ResponseEntity<T>> exchangeForEntityMono(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic <T> Mono<ResponseEntity<T>> exchangeForEntityMono(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(requestValues).retrieve().toEntity(bodyType);\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.WebClientAdapter#exchangeForHeadersMono(requestValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "Mono<HttpHeaders>",
    "signature": "public Mono<HttpHeaders> exchangeForHeadersMono(HttpRequestValues requestValues)",
    "source_code": "\tpublic Mono<HttpHeaders> exchangeForHeadersMono(HttpRequestValues requestValues) {\n\t\treturn newRequest(requestValues).retrieve().toBodilessEntity().map(ResponseEntity::getHeaders);\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.WebClientAdapter#exchangeForMono(requestValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> exchangeForMono(HttpRequestValues requestValues)",
    "source_code": "\tpublic Mono<Void> exchangeForMono(HttpRequestValues requestValues) {\n\t\treturn newRequest(requestValues).retrieve().toBodilessEntity().then();\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.WebClientAdapter#forClient(webClient)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link WebClientAdapter} for the given {@code WebClient} instance.\n\t * @param webClient the client to use\n\t * @return the created adapter instance\n\t * @deprecated in favor of {@link #create(WebClient)} aligning with other adapter\n\t * implementations; to be removed in 6.2.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webClient"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "WebClientAdapter",
    "signature": "public WebClientAdapter forClient(WebClient webClient)",
    "source_code": "\tpublic static WebClientAdapter forClient(WebClient webClient) {\n\t\treturn new WebClientAdapter(webClient);\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.WebClientAdapter#supportsRequestAttributes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "boolean",
    "signature": "public boolean supportsRequestAttributes()",
    "source_code": "\tpublic boolean supportsRequestAttributes() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#attribute(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 1341
    },
    "return": "Optional<Object>",
    "signature": "public Optional<Object> attribute(String name)",
    "source_code": "\t\tpublic Optional<Object> attribute(String name) {\n\t\t\treturn Optional.ofNullable(this.attributes.get(name));\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#bind(bindType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bindType"
    ],
    "position": {
      "column": 1,
      "line": 1243
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> bind(Class<T> bindType)",
    "source_code": "\t\tpublic <T> Mono<T> bind(Class<T> bindType) {\n\t\t\treturn this.delegate.bind(bindType);\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#bind(bindType,dataBinderCustomizer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bindType",
      "dataBinderCustomizer"
    ],
    "position": {
      "column": 1,
      "line": 1248
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> bind(Class<T> bindType, Consumer<WebDataBinder> dataBinderCustomizer)",
    "source_code": "\t\tpublic <T> Mono<T> bind(Class<T> bindType, Consumer<WebDataBinder> dataBinderCustomizer) {\n\t\t\treturn this.delegate.bind(bindType, dataBinderCustomizer);\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#checkNotModified(etag)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "etag"
    ],
    "position": {
      "column": 1,
      "line": 1313
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> checkNotModified(String etag)",
    "source_code": "\t\tpublic Mono<ServerResponse> checkNotModified(String etag) {\n\t\t\treturn this.delegate.checkNotModified(etag);\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#checkNotModified(lastModified)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lastModified"
    ],
    "position": {
      "column": 1,
      "line": 1308
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> checkNotModified(Instant lastModified)",
    "source_code": "\t\tpublic Mono<ServerResponse> checkNotModified(Instant lastModified) {\n\t\t\treturn this.delegate.checkNotModified(lastModified);\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#checkNotModified(lastModified,etag)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lastModified",
      "etag"
    ],
    "position": {
      "column": 1,
      "line": 1318
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> checkNotModified(Instant lastModified, String etag)",
    "source_code": "\t\tpublic Mono<ServerResponse> checkNotModified(Instant lastModified, String etag) {\n\t\t\treturn this.delegate.checkNotModified(lastModified, etag);\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#modifiesAttributes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 540
    },
    "return": "boolean",
    "signature": "public boolean modifiesAttributes()",
    "source_code": "\t\t\tpublic boolean modifiesAttributes() {\n\t\t\t\treturn this.modifyAttributes != null;\n\t\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#modifyAttributes(Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 534
    },
    "return": "void",
    "signature": "public void modifyAttributes(Map<String, Object> attributes)",
    "source_code": "\t\t\tpublic void modifyAttributes(Map<String, Object> attributes) {\n\t\t\t\tif (this.modifyAttributes != null) {\n\t\t\t\t\tthis.modifyAttributes.accept(attributes);\n\t\t\t\t}\n\t\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#of(requestPredicate)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestPredicate"
    ],
    "position": {
      "column": 1,
      "line": 469
    },
    "return": "RequestModifyingPredicate",
    "signature": "public RequestModifyingPredicate of(RequestPredicate requestPredicate)",
    "source_code": "\t\tpublic static RequestModifyingPredicate of(RequestPredicate requestPredicate) {\n\t\t\tif (requestPredicate instanceof RequestModifyingPredicate modifyingPredicate) {\n\t\t\t\treturn modifyingPredicate;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new RequestModifyingPredicate() {\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected Result testInternal(ServerRequest request) {\n\t\t\t\t\t\treturn Result.of(requestPredicate.test(request));\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#of(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 516
    },
    "return": "Result",
    "signature": "public Result of(boolean value)",
    "source_code": "\t\t\tpublic static Result of(boolean value) {\n\t\t\t\treturn of(value, null);\n\t\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#of(value,Consumer<Map<String,modifyAttributes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "Consumer<Map<String",
      "modifyAttributes"
    ],
    "position": {
      "column": 1,
      "line": 520
    },
    "return": "Result",
    "signature": "public Result of(boolean value, @Nullable Consumer<Map<String, Object>> modifyAttributes)",
    "source_code": "\t\t\tpublic static Result of(boolean value, @Nullable Consumer<Map<String, Object>> modifyAttributes) {\n\t\t\t\tif (modifyAttributes == null) {\n\t\t\t\t\treturn value ? TRUE : FALSE;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new Result(value, modifyAttributes);\n\t\t\t\t}\n\t\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#path()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1412
    },
    "return": "String",
    "signature": "public String path()",
    "source_code": "\t\tpublic String path() {\n\t\t\treturn this.requestPath.pathWithinApplication().value();\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#pathContainer()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1418
    },
    "return": "PathContainer",
    "signature": "public PathContainer pathContainer()",
    "source_code": "\t\tpublic PathContainer pathContainer() {\n\t\t\treturn this.requestPath;\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#pathVariable(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 1351
    },
    "return": "String",
    "signature": "public String pathVariable(String name)",
    "source_code": "\t\tpublic String pathVariable(String name) {\n\t\t\tMap<String, String> pathVariables = pathVariables();\n\t\t\tif (pathVariables.containsKey(name)) {\n\t\t\t\treturn pathVariables.get(name);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"No path variable with name \\\"\" + name + \"\\\" available\");\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#testInternal(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 1092
    },
    "return": "Result",
    "signature": "protected Result testInternal(ServerRequest request)",
    "source_code": "\t\tprotected Result testInternal(ServerRequest request) {\n\t\t\tResult leftResult = this.leftModifying.testInternal(request);\n\t\t\tif (leftResult.value()) {\n\t\t\t\treturn leftResult;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn this.rightModifying.testInternal(request);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#value()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 530
    },
    "return": "boolean",
    "signature": "public boolean value()",
    "source_code": "\t\t\tpublic boolean value() {\n\t\t\t\treturn this.value;\n\t\t\t}"
  },
  "org.springframework.web.reactive.function.server.Result": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "class",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 497
    },
    "signature": "protected class Result",
    "source_code": "\t\tprotected static final class Result {\n\n\t\t\tprivate static final Result TRUE = new Result(true, null);\n\n\t\t\tprivate static final Result FALSE = new Result(false, null);\n\n\n\t\t\tprivate final boolean value;\n\n\t\t\t@Nullable\n\t\t\tprivate final Consumer<Map<String, Object>> modifyAttributes;\n\n\n\t\t\tprivate Result(boolean value, @Nullable Consumer<Map<String, Object>> modifyAttributes) {\n\t\t\t\tthis.value = value;\n\t\t\t\tthis.modifyAttributes = modifyAttributes;\n\t\t\t}\n\n\n\t\t\tpublic static Result of(boolean value) {\n\t\t\t\treturn of(value, null);\n\t\t\t}\n\n\t\t\tpublic static Result of(boolean value, @Nullable Consumer<Map<String, Object>> modifyAttributes) {\n\t\t\t\tif (modifyAttributes == null) {\n\t\t\t\t\treturn value ? TRUE : FALSE;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new Result(value, modifyAttributes);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tpublic boolean value() {\n\t\t\t\treturn this.value;\n\t\t\t}\n\n\t\t\tpublic void modifyAttributes(Map<String, Object> attributes) {\n\t\t\t\tif (this.modifyAttributes != null) {\n\t\t\t\t\tthis.modifyAttributes.accept(attributes);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpublic boolean modifiesAttributes() {\n\t\t\t\treturn this.modifyAttributes != null;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.reactive.resource.ResourceWebHandler#getEtagGenerator()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the HTTP ETag generator function to be used when serving resources.\n\t * @return the HTTP ETag generator function\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 301
    },
    "return": "String>",
    "signature": "public String> getEtagGenerator()",
    "source_code": "\tpublic Function<Resource, String> getEtagGenerator() {\n\t\treturn this.etagGenerator;\n\t}"
  },
  "org.springframework.web.reactive.resource.ResourceWebHandler#setEtagGenerator(Function<Resource,etagGenerator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a generator function that will be used to create the ETag information,\n\t * given a {@link Resource} that is about to be written to the response.\n\t * <p>This function should return a String that will be used as an argument in\n\t * {@link ServerWebExchange#checkNotModified(String)}, or {@code null} if no value\n\t * can be generated for the given resource.\n\t * @param etagGenerator the HTTP ETag generator function to use.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<Resource",
      "etagGenerator"
    ],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "void",
    "signature": "public void setEtagGenerator(@Nullable Function<Resource, String> etagGenerator)",
    "source_code": "\tpublic void setEtagGenerator(@Nullable Function<Resource, String> etagGenerator) {\n\t\tthis.etagGenerator = etagGenerator;\n\t}"
  },
  "org.springframework.web.reactive.result.method.InvocableHandlerMethod#invokeFunction(method,target,args,isSuspendingFunction,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "target",
      "args",
      "isSuspendingFunction",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 324
    },
    "return": "Object",
    "signature": "public Object invokeFunction(Method method, Object target, Object[] args, boolean isSuspendingFunction,\n\t\t\t\tServerWebExchange exchange)",
    "source_code": "\t\tpublic static Object invokeFunction(Method method, Object target, Object[] args, boolean isSuspendingFunction,"
  },
  "org.springframework.web.reactive.result.method.InvocableHandlerMethod#setInvocationScheduler(invocationScheduler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link Scheduler} on which to perform the method invocation.\n\t * @since 6.1.6\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "invocationScheduler"
    ],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "void",
    "signature": "public void setInvocationScheduler(@Nullable Scheduler invocationScheduler)",
    "source_code": "\tpublic void setInvocationScheduler(@Nullable Scheduler invocationScheduler) {\n\t\tthis.invocationScheduler = invocationScheduler;\n\t}"
  },
  "org.springframework.web.reactive.result.method.InvocableHandlerMethod#setMethodValidator(methodValidator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link MethodValidator} to perform method validation with if the\n\t * controller method {@link #shouldValidateArguments()} or\n\t * {@link #shouldValidateReturnValue()}.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodValidator"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "void",
    "signature": "public void setMethodValidator(@Nullable MethodValidator methodValidator)",
    "source_code": "\tpublic void setMethodValidator(@Nullable MethodValidator methodValidator) {\n\t\tthis.methodValidator = methodValidator;\n\t\tthis.validationGroups = (methodValidator != null ?\n\t\t\t\tmethodValidator.determineValidationGroups(getBean(), getBridgedMethod()) : EMPTY_GROUPS);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.AbstractNamedValueArgumentResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract base class for resolving method arguments from a named value.\n * Request parameters, request headers, and path variables are examples of named\n * values. Each may have a name, a required flag, and a default value.\n *\n * <p>Subclasses define how to do the following:\n * <ul>\n * <li>Obtain named value information for a method parameter\n * <li>Resolve names into argument values\n * <li>Handle missing argument values when argument values are required\n * <li>Optionally handle a resolved value\n * </ul>\n *\n * <p>A default value string can contain ${...} placeholders and Spring Expression\n * Language #{...} expressions. For this to work a\n * {@link ConfigurableBeanFactory} must be supplied to the class constructor.\n *\n * @author Rossen Stoyanchev\n * @author Sebastien Deleuze\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "signature": "public class AbstractNamedValueArgumentResolver",
    "source_code": "public abstract class AbstractNamedValueArgumentResolver extends HandlerMethodArgumentResolverSupport {\n\n\t@Nullable\n\tprivate final ConfigurableBeanFactory configurableBeanFactory;\n\n\t@Nullable\n\tprivate final BeanExpressionContext expressionContext;\n\n\tprivate final Map<MethodParameter, NamedValueInfo> namedValueInfoCache = new ConcurrentHashMap<>(256);\n\n\n\t/**\n\t * Create a new {@link AbstractNamedValueArgumentResolver} instance.\n\t * @param factory a bean factory to use for resolving {@code ${...}} placeholder\n\t * and {@code #{...}} SpEL expressions in default values, or {@code null} if default\n\t * values are not expected to contain expressions\n\t * @param registry for checking reactive type wrappers\n\t */\n\tpublic AbstractNamedValueArgumentResolver(@Nullable ConfigurableBeanFactory factory,\n\t\t\tReactiveAdapterRegistry registry) {\n\n\t\tsuper(registry);\n\t\tthis.configurableBeanFactory = factory;\n\t\tthis.expressionContext = (factory != null ? new BeanExpressionContext(factory, null) : null);\n\t}\n\n\n\t@Override\n\tpublic Mono<Object> resolveArgument(\n\t\t\tMethodParameter parameter, BindingContext bindingContext, ServerWebExchange exchange) {\n\n\t\tNamedValueInfo namedValueInfo = getNamedValueInfo(parameter);\n\t\tMethodParameter nestedParameter = parameter.nestedIfOptional();\n\n\t\tObject resolvedName = resolveEmbeddedValuesAndExpressions(namedValueInfo.name);\n\t\tif (resolvedName == null) {\n\t\t\treturn Mono.error(new IllegalArgumentException(\n\t\t\t\t\t\"Specified name must not resolve to null: [\" + namedValueInfo.name + \"]\"));\n\t\t}\n\n\t\tModel model = bindingContext.getModel();\n\n\t\treturn resolveName(resolvedName.toString(), nestedParameter, exchange)\n\t\t\t\t.flatMap(arg -> {\n\t\t\t\t\tif (\"\".equals(arg) && namedValueInfo.defaultValue != null) {\n\t\t\t\t\t\targ = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);\n\t\t\t\t\t}\n\t\t\t\t\targ = applyConversion(arg, namedValueInfo, parameter, bindingContext, exchange);\n\t\t\t\t\thandleResolvedValue(arg, namedValueInfo.name, parameter, model, exchange);\n\t\t\t\t\treturn Mono.justOrEmpty(arg);\n\t\t\t\t})\n\t\t\t\t.switchIfEmpty(getDefaultValue(\n\t\t\t\t\t\tnamedValueInfo, parameter, bindingContext, model, exchange));\n\t}\n\n\t/**\n\t * Obtain the named value for the given method parameter.\n\t */\n\tprivate NamedValueInfo getNamedValueInfo(MethodParameter parameter) {\n\t\tNamedValueInfo namedValueInfo = this.namedValueInfoCache.get(parameter);\n\t\tif (namedValueInfo == null) {\n\t\t\tnamedValueInfo = createNamedValueInfo(parameter);\n\t\t\tnamedValueInfo = updateNamedValueInfo(parameter, namedValueInfo);\n\t\t\tthis.namedValueInfoCache.put(parameter, namedValueInfo);\n\t\t}\n\t\treturn namedValueInfo;\n\t}\n\n\t/**\n\t * Create the {@link NamedValueInfo} object for the given method parameter.\n\t * Implementations typically retrieve the method annotation by means of\n\t * {@link MethodParameter#getParameterAnnotation(Class)}.\n\t * @param parameter the method parameter\n\t * @return the named value information\n\t */\n\tprotected abstract NamedValueInfo createNamedValueInfo(MethodParameter parameter);\n\n\t/**\n\t * Create a new NamedValueInfo based on the given NamedValueInfo with\n\t * sanitized values.\n\t */\n\tprivate NamedValueInfo updateNamedValueInfo(MethodParameter parameter, NamedValueInfo info) {\n\t\tString name = info.name;\n\t\tif (info.name.isEmpty()) {\n\t\t\tname = parameter.getParameterName();\n\t\t\tif (name == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"\"\"\n\t\t\t\t\t\tName for argument of type [%s] not specified, and parameter name information not \\\n\t\t\t\t\t\tavailable via reflection. Ensure that the compiler uses the '-parameters' flag.\"\"\"\n\t\t\t\t\t\t\t.formatted(parameter.getNestedParameterType().getName()));\n\t\t\t}\n\t\t}\n\t\tString defaultValue = (ValueConstants.DEFAULT_NONE.equals(info.defaultValue) ? null : info.defaultValue);\n\t\treturn new NamedValueInfo(name, info.required, defaultValue);\n\t}\n\n\t/**\n\t * Resolve the given annotation-specified value,\n\t * potentially containing placeholders and expressions.\n\t */\n\t@Nullable\n\tprivate Object resolveEmbeddedValuesAndExpressions(String value) {\n\t\tif (this.configurableBeanFactory == null || this.expressionContext == null) {\n\t\t\treturn value;\n\t\t}\n\t\tString placeholdersResolved = this.configurableBeanFactory.resolveEmbeddedValue(value);\n\t\tBeanExpressionResolver exprResolver = this.configurableBeanFactory.getBeanExpressionResolver();\n\t\tif (exprResolver == null) {\n\t\t\treturn value;\n\t\t}\n\t\treturn exprResolver.evaluate(placeholdersResolved, this.expressionContext);\n\t}\n\n\t/**\n\t * Resolve the given parameter type and value name into an argument value.\n\t * @param name the name of the value being resolved\n\t * @param parameter the method parameter to resolve to an argument value\n\t * (pre-nested in case of a {@link java.util.Optional} declaration)\n\t * @param exchange the current exchange\n\t * @return the resolved argument (may be empty {@link Mono})\n\t */\n\tprotected abstract Mono<Object> resolveName(String name, MethodParameter parameter, ServerWebExchange exchange);\n\n\t/**\n\t * Apply type conversion if necessary.\n\t */\n\t@Nullable\n\tprivate Object applyConversion(@Nullable Object value, NamedValueInfo namedValueInfo, MethodParameter parameter,\n\t\t\tBindingContext bindingContext, ServerWebExchange exchange) {\n\n\t\tWebDataBinder binder = bindingContext.createDataBinder(exchange, namedValueInfo.name);\n\t\tClass<?> parameterType = parameter.getParameterType();\n\t\tif (KotlinDetector.isKotlinPresent() && KotlinDetector.isInlineClass(parameterType)) {\n\t\t\tConstructor<?> ctor = BeanUtils.findPrimaryConstructor(parameterType);\n\t\t\tif (ctor != null) {\n\t\t\t\tparameterType = ctor.getParameterTypes()[0];\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tvalue = binder.convertIfNecessary(value, parameterType, parameter);\n\t\t}\n\t\tcatch (ConversionNotSupportedException ex) {\n\t\t\tthrow new ServerErrorException(\"Conversion not supported.\", parameter, ex);\n\t\t}\n\t\tcatch (TypeMismatchException ex) {\n\t\t\tex.initPropertyName(namedValueInfo.name);\n\t\t\tthrow new ServerWebInputException(\"Type mismatch.\", parameter, ex);\n\t\t}\n\t\treturn value;\n\t}\n\n\t/**\n\t * Resolve the default value, if any.\n\t */\n\tprivate Mono<Object> getDefaultValue(NamedValueInfo namedValueInfo, MethodParameter parameter,\n\t\t\tBindingContext bindingContext, Model model, ServerWebExchange exchange) {\n\n\t\treturn Mono.fromSupplier(() -> {\n\t\t\tObject value = null;\n\t\t\tboolean hasDefaultValue = KotlinDetector.isKotlinReflectPresent()\n\t\t\t\t\t&& KotlinDetector.isKotlinType(parameter.getDeclaringClass())\n\t\t\t\t\t&& KotlinDelegate.hasDefaultValue(parameter);\n\t\t\tif (namedValueInfo.defaultValue != null) {\n\t\t\t\tvalue = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);\n\t\t\t}\n\t\t\telse if (namedValueInfo.required && !parameter.isOptional()) {\n\t\t\t\thandleMissingValue(namedValueInfo.name, parameter, exchange);\n\t\t\t}\n\t\t\tif (!hasDefaultValue) {\n\t\t\t\tvalue = handleNullValue(namedValueInfo.name, value, parameter.getNestedParameterType());\n\t\t\t}\n\t\t\tif (value != null || !hasDefaultValue) {\n\t\t\t\tvalue = applyConversion(value, namedValueInfo, parameter, bindingContext, exchange);\n\t\t\t}\n\t\t\thandleResolvedValue(value, namedValueInfo.name, parameter, model, exchange);\n\t\t\treturn value;\n\t\t});\n\t}\n\n\t/**\n\t * Invoked when a named value is required, but\n\t * {@link #resolveName(String, MethodParameter, ServerWebExchange)} returned\n\t * {@code null} and there is no default value. Subclasses typically throw an\n\t * exception in this case.\n\t * @param name the name for the value\n\t * @param parameter the method parameter\n\t * @param exchange the current exchange\n\t */\n\t@SuppressWarnings(\"UnusedParameters\")\n\tprotected void handleMissingValue(String name, MethodParameter parameter, ServerWebExchange exchange) {\n\t\thandleMissingValue(name, parameter);\n\t}\n\n\t/**\n\t * Invoked when a named value is required, but\n\t * {@link #resolveName(String, MethodParameter, ServerWebExchange)} returned\n\t * {@code null} and there is no default value. Subclasses typically throw an\n\t * exception in this case.\n\t * @param name the name for the value\n\t * @param parameter the method parameter\n\t */\n\tprotected void handleMissingValue(String name, MethodParameter parameter) {\n\t\tthrow new MissingRequestValueException(\n\t\t\t\tname, parameter.getNestedParameterType(), \"request value\", parameter);\n\t}\n\n\t/**\n\t * A {@code null} results in a {@code false} value for {@code boolean}s or\n\t * an exception for other primitives.\n\t */\n\t@Nullable\n\tprivate Object handleNullValue(String name, @Nullable Object value, Class<?> paramType) {\n\t\tif (value == null) {\n\t\t\tif (paramType == boolean.class) {\n\t\t\t\treturn Boolean.FALSE;\n\t\t\t}\n\t\t\telse if (paramType.isPrimitive()) {\n\t\t\t\tthrow new IllegalStateException(\"Optional \" + paramType.getSimpleName() +\n\t\t\t\t\t\t\" parameter '\" + name + \"' is present but cannot be translated into a\" +\n\t\t\t\t\t\t\" null value due to being declared as a primitive type. \" +\n\t\t\t\t\t\t\"Consider declaring it as object wrapper for the corresponding primitive type.\");\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}\n\n\t/**\n\t * Invoked after a value is resolved.\n\t * @param arg the resolved argument value\n\t * @param name the argument name\n\t * @param parameter the argument parameter type\n\t * @param model the model\n\t * @param exchange the current exchange\n\t */\n\t@SuppressWarnings(\"UnusedParameters\")\n\tprotected void handleResolvedValue(\n\t\t\t@Nullable Object arg, String name, MethodParameter parameter, Model model, ServerWebExchange exchange) {\n\t}\n\n\n\t/**\n\t * Represents the information about a named value, including name, whether\n\t * it's required and a default value.\n\t */\n\tprotected static class NamedValueInfo {\n\n\t\tprivate final String name;\n\n\t\tprivate final boolean required;\n\n\t\t@Nullable\n\t\tprivate final String defaultValue;\n\n\t\tpublic NamedValueInfo(String name, boolean required, @Nullable String defaultValue) {\n\t\t\tthis.name = name;\n\t\t\tthis.required = required;\n\t\t\tthis.defaultValue = defaultValue;\n\t\t}\n\t}\n\n\t/**\n\t * Inner class to avoid a hard dependency on Kotlin at runtime.\n\t */\n\tprivate static class KotlinDelegate {\n\n\t\t/**\n\t\t * Check whether the specified {@link MethodParameter} represents a nullable Kotlin type\n\t\t * or an optional parameter (with a default value in the Kotlin declaration).\n\t\t */\n\t\tpublic static boolean hasDefaultValue(MethodParameter parameter) {\n\t\t\tMethod method = Objects.requireNonNull(parameter.getMethod());\n\t\t\tKFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);\n\t\t\tif (function != null) {\n\t\t\t\tint index = 0;\n\t\t\t\tfor (KParameter kParameter : function.getParameters()) {\n\t\t\t\t\tif (KParameter.Kind.VALUE.equals(kParameter.getKind()) && parameter.getParameterIndex() == index++) {\n\t\t\t\t\t\treturn kParameter.isOptional();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.reactive.result.method.annotation.AbstractNamedValueArgumentResolver#createNamedValueInfo(parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the {@link NamedValueInfo} object for the given method parameter.\n\t * Implementations typically retrieve the method annotation by means of\n\t * {@link MethodParameter#getParameterAnnotation(Class)}.\n\t * @param parameter the method parameter\n\t * @return the named value information\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "NamedValueInfo",
    "signature": "protected NamedValueInfo createNamedValueInfo(MethodParameter parameter)",
    "source_code": "\tprotected abstract NamedValueInfo createNamedValueInfo(MethodParameter parameter);"
  },
  "org.springframework.web.reactive.result.method.annotation.AbstractNamedValueArgumentResolver#handleMissingValue(name,parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked when a named value is required, but\n\t * {@link #resolveName(String, MethodParameter, ServerWebExchange)} returned\n\t * {@code null} and there is no default value. Subclasses typically throw an\n\t * exception in this case.\n\t * @param name the name for the value\n\t * @param parameter the method parameter\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "void",
    "signature": "protected void handleMissingValue(String name, MethodParameter parameter)",
    "source_code": "\tprotected void handleMissingValue(String name, MethodParameter parameter) {\n\t\tthrow new MissingRequestValueException(\n\t\t\t\tname, parameter.getNestedParameterType(), \"request value\", parameter);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.AbstractNamedValueArgumentResolver#handleMissingValue(name,parameter,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked when a named value is required, but\n\t * {@link #resolveName(String, MethodParameter, ServerWebExchange)} returned\n\t * {@code null} and there is no default value. Subclasses typically throw an\n\t * exception in this case.\n\t * @param name the name for the value\n\t * @param parameter the method parameter\n\t * @param exchange the current exchange\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "void",
    "signature": "protected void handleMissingValue(String name, MethodParameter parameter, ServerWebExchange exchange)",
    "source_code": "\tprotected void handleMissingValue(String name, MethodParameter parameter, ServerWebExchange exchange) {\n\t\thandleMissingValue(name, parameter);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.AbstractNamedValueArgumentResolver#handleResolvedValue(arg,name,parameter,model,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked after a value is resolved.\n\t * @param arg the resolved argument value\n\t * @param name the argument name\n\t * @param parameter the argument parameter type\n\t * @param model the model\n\t * @param exchange the current exchange\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "arg",
      "name",
      "parameter",
      "model",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 306
    },
    "return": "void",
    "signature": "protected void handleResolvedValue(@Nullable Object arg, String name, MethodParameter parameter, Model model, ServerWebExchange exchange)",
    "source_code": "\tprotected void handleResolvedValue("
  },
  "org.springframework.web.reactive.result.method.annotation.AbstractNamedValueArgumentResolver#hasDefaultValue(parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Check whether the specified {@link MethodParameter} represents a nullable Kotlin type\n\t\t * or an optional parameter (with a default value in the Kotlin declaration).\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 340
    },
    "return": "boolean",
    "signature": "public boolean hasDefaultValue(MethodParameter parameter)",
    "source_code": "\t\tpublic static boolean hasDefaultValue(MethodParameter parameter) {\n\t\t\tMethod method = Objects.requireNonNull(parameter.getMethod());\n\t\t\tKFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);\n\t\t\tif (function != null) {\n\t\t\t\tint index = 0;\n\t\t\t\tfor (KParameter kParameter : function.getParameters()) {\n\t\t\t\t\tif (KParameter.Kind.VALUE.equals(kParameter.getKind()) && parameter.getParameterIndex() == index++) {\n\t\t\t\t\t\treturn kParameter.isOptional();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.AbstractNamedValueArgumentResolver#resolveArgument(parameter,bindingContext,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "bindingContext",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "Mono<Object>",
    "signature": "public Mono<Object> resolveArgument(MethodParameter parameter, BindingContext bindingContext, ServerWebExchange exchange)",
    "source_code": "\tpublic Mono<Object> resolveArgument("
  },
  "org.springframework.web.reactive.result.method.annotation.AbstractNamedValueArgumentResolver#resolveName(name,parameter,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the given parameter type and value name into an argument value.\n\t * @param name the name of the value being resolved\n\t * @param parameter the method parameter to resolve to an argument value\n\t * (pre-nested in case of a {@link java.util.Optional} declaration)\n\t * @param exchange the current exchange\n\t * @return the resolved argument (may be empty {@link Mono})\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "Mono<Object>",
    "signature": "protected Mono<Object> resolveName(String name, MethodParameter parameter, ServerWebExchange exchange)",
    "source_code": "\tprotected abstract Mono<Object> resolveName(String name, MethodParameter parameter, ServerWebExchange exchange);"
  },
  "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolver": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Resolve {@code @ModelAttribute} annotated method arguments.\n *\n * <p>Model attributes are sourced from the model, or created using a default\n * constructor and then added to the model. Once created the attribute is\n * populated via data binding to the request (form data, query params).\n * Validation also may be applied if the argument is annotated with\n * {@code @jakarta.validation.Valid} or Spring's own\n * {@code @org.springframework.validation.annotation.Validated}.\n *\n * <p>When this handler is created with {@code useDefaultResolution=true}\n * any non-simple type argument and return value is regarded as a model\n * attribute with or without the presence of an {@code @ModelAttribute}.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Sebastien Deleuze\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "signature": "public class ModelAttributeMethodArgumentResolver",
    "source_code": "public class ModelAttributeMethodArgumentResolver extends HandlerMethodArgumentResolverSupport {\n\n\tprivate final boolean useDefaultResolution;\n\n\n\t/**\n\t * Class constructor with a default resolution mode flag.\n\t * @param adapterRegistry for adapting to other reactive types from and to Mono\n\t * @param useDefaultResolution if \"true\", non-simple method arguments and\n\t * return values are considered model attributes with or without a\n\t * {@code @ModelAttribute} annotation present.\n\t */\n\tpublic ModelAttributeMethodArgumentResolver(ReactiveAdapterRegistry adapterRegistry,\n\t\t\tboolean useDefaultResolution) {\n\n\t\tsuper(adapterRegistry);\n\t\tthis.useDefaultResolution = useDefaultResolution;\n\t}\n\n\n\t@Override\n\tpublic boolean supportsParameter(MethodParameter parameter) {\n\t\tif (parameter.hasParameterAnnotation(ModelAttribute.class)) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (this.useDefaultResolution) {\n\t\t\treturn checkParameterType(parameter, type -> !BeanUtils.isSimpleProperty(type));\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Mono<Object> resolveArgument(\n\t\t\tMethodParameter parameter, BindingContext context, ServerWebExchange exchange) {\n\n\t\tResolvableType type = ResolvableType.forMethodParameter(parameter);\n\t\tClass<?> resolvedType = type.resolve();\n\t\tReactiveAdapter adapter = (resolvedType != null ? getAdapterRegistry().getAdapter(resolvedType) : null);\n\t\tResolvableType valueType = (adapter != null ? type.getGeneric() : type);\n\n\t\tAssert.state(adapter == null || !adapter.isMultiValue(),\n\t\t\t\t() -> getClass().getSimpleName() + \" does not support multi-value reactive type wrapper: \" +\n\t\t\t\t\t\tparameter.getGenericParameterType());\n\n\t\tString name = ModelInitializer.getNameForParameter(parameter);\n\t\tMono<?> valueMono = prepareAttributeMono(name, valueType, context, exchange);\n\n\t\t// unsafe(): we're intercepting, already serialized Publisher signals\n\t\tSinks.One<BindingResult> bindingResultSink = Sinks.unsafe().one();\n\n\t\tMap<String, Object> model = context.getModel().asMap();\n\t\tmodel.put(BindingResult.MODEL_KEY_PREFIX + name, bindingResultSink.asMono());\n\n\t\treturn valueMono.flatMap(value -> {\n\t\t\tWebExchangeDataBinder binder = context.createDataBinder(exchange, value, name);\n\t\t\treturn (bindingDisabled(parameter) ? Mono.empty() : bindRequestParameters(binder, exchange))\n\t\t\t\t\t.doOnError(bindingResultSink::tryEmitError)\n\t\t\t\t\t.doOnSuccess(aVoid -> {\n\t\t\t\t\t\tvalidateIfApplicable(binder, parameter, exchange);\n\t\t\t\t\t\tBindingResult bindingResult = binder.getBindingResult();\n\t\t\t\t\t\tmodel.put(BindingResult.MODEL_KEY_PREFIX + name, bindingResult);\n\t\t\t\t\t\tmodel.put(name, value);\n\t\t\t\t\t\t// Ignore result: serialized and buffered (should never fail)\n\t\t\t\t\t\tbindingResultSink.tryEmitValue(bindingResult);\n\t\t\t\t\t})\n\t\t\t\t\t.then(Mono.fromCallable(() -> {\n\t\t\t\t\t\tBindingResult errors = binder.getBindingResult();\n\t\t\t\t\t\tif (adapter != null) {\n\t\t\t\t\t\t\treturn adapter.fromPublisher(errors.hasErrors() ?\n\t\t\t\t\t\t\t\t\tMono.error(new WebExchangeBindException(parameter, errors)) : valueMono);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (errors.hasErrors() && !hasErrorsArgument(parameter)) {\n\t\t\t\t\t\t\t\tthrow new WebExchangeBindException(parameter, errors);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t});\n\t}\n\n\t/**\n\t * Determine if binding should be disabled for the supplied {@link MethodParameter},\n\t * based on the {@link ModelAttribute#binding} annotation attribute.\n\t * @since 5.2.15\n\t */\n\tprivate boolean bindingDisabled(MethodParameter parameter) {\n\t\tModelAttribute modelAttribute = parameter.getParameterAnnotation(ModelAttribute.class);\n\t\treturn (modelAttribute != null && !modelAttribute.binding());\n\t}\n\n\t/**\n\t * Extension point to bind the request to the target object.\n\t * @param binder the data binder instance to use for the binding\n\t * @param exchange the current request\n\t * @since 5.2.6\n\t */\n\tprotected Mono<Void> bindRequestParameters(WebExchangeDataBinder binder, ServerWebExchange exchange) {\n\t\treturn binder.bind(exchange);\n\t}\n\n\tprivate Mono<?> prepareAttributeMono(String attributeName, ResolvableType attributeType,\n\t\t\tBindingContext context, ServerWebExchange exchange) {\n\n\t\tObject attribute = context.getModel().asMap().get(attributeName);\n\n\t\tif (attribute == null) {\n\t\t\tattribute = findAndRemoveReactiveAttribute(context.getModel(), attributeName);\n\t\t}\n\n\t\tif (attribute == null) {\n\t\t\treturn createAttribute(attributeName, attributeType.toClass(), context, exchange);\n\t\t}\n\n\t\tReactiveAdapter adapter = getAdapterRegistry().getAdapter(null, attribute);\n\t\tif (adapter != null) {\n\t\t\tAssert.isTrue(!adapter.isMultiValue(), \"Data binding only supports single-value async types\");\n\t\t\treturn Mono.from(adapter.toPublisher(attribute));\n\t\t}\n\t\telse {\n\t\t\treturn Mono.justOrEmpty(attribute);\n\t\t}\n\t}\n\n\t@Nullable\n\tprivate Object findAndRemoveReactiveAttribute(Model model, String attributeName) {\n\t\treturn model.asMap().entrySet().stream()\n\t\t\t\t.filter(entry -> {\n\t\t\t\t\tif (!entry.getKey().startsWith(attributeName)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tReactiveAdapter adapter = getAdapterRegistry().getAdapter(null, entry.getValue());\n\t\t\t\t\tif (adapter == null) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tString name = attributeName + ClassUtils.getShortName(adapter.getReactiveType());\n\t\t\t\t\treturn entry.getKey().equals(name);\n\t\t\t\t})\n\t\t\t\t.findFirst()\n\t\t\t\t.map(entry -> {\n\t\t\t\t\t// Remove since we will be re-inserting the resolved attribute value\n\t\t\t\t\tmodel.asMap().remove(entry.getKey());\n\t\t\t\t\treturn entry.getValue();\n\t\t\t\t})\n\t\t\t\t.orElse(null);\n\t}\n\n\tprivate Mono<?> createAttribute(\n\t\t\tString attributeName, Class<?> clazz, BindingContext context, ServerWebExchange exchange) {\n\n\t\tConstructor<?> ctor = BeanUtils.getResolvableConstructor(clazz);\n\t\treturn constructAttribute(ctor, attributeName, context, exchange);\n\t}\n\n\tprivate Mono<?> constructAttribute(Constructor<?> ctor, String attributeName,\n\t\t\tBindingContext context, ServerWebExchange exchange) {\n\n\t\tif (ctor.getParameterCount() == 0) {\n\t\t\t// A single default constructor -> clearly a standard JavaBeans arrangement.\n\t\t\treturn Mono.just(BeanUtils.instantiateClass(ctor));\n\t\t}\n\n\t\t// A single data class constructor -> resolve constructor arguments from request parameters.\n\t\tWebExchangeDataBinder binder = context.createDataBinder(exchange, null, attributeName);\n\t\treturn getValuesToBind(binder, exchange).map(bindValues -> {\n\t\t\tString[] paramNames = BeanUtils.getParameterNames(ctor);\n\t\t\tClass<?>[] paramTypes = ctor.getParameterTypes();\n\t\t\tObject[] args = new Object[paramTypes.length];\n\t\t\tString fieldDefaultPrefix = binder.getFieldDefaultPrefix();\n\t\t\tString fieldMarkerPrefix = binder.getFieldMarkerPrefix();\n\t\t\tfor (int i = 0; i < paramNames.length; i++) {\n\t\t\t\tString paramName = paramNames[i];\n\t\t\t\tClass<?> paramType = paramTypes[i];\n\t\t\t\tObject value = bindValues.get(paramName);\n\t\t\t\tif (value == null) {\n\t\t\t\t\tif (fieldDefaultPrefix != null) {\n\t\t\t\t\t\tvalue = bindValues.get(fieldDefaultPrefix + paramName);\n\t\t\t\t\t}\n\t\t\t\t\tif (value == null && fieldMarkerPrefix != null) {\n\t\t\t\t\t\tif (bindValues.get(fieldMarkerPrefix + paramName) != null) {\n\t\t\t\t\t\t\tvalue = binder.getEmptyValue(paramType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvalue = (value instanceof List<?> list ? list.toArray() : value);\n\t\t\t\tMethodParameter methodParam = new MethodParameter(ctor, i);\n\t\t\t\tif (value == null && methodParam.isOptional()) {\n\t\t\t\t\targs[i] = (methodParam.getParameterType() == Optional.class ? Optional.empty() : null);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\targs[i] = binder.convertIfNecessary(value, paramTypes[i], methodParam);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\t\t\tthrow new ServerWebInputException(\"Type mismatch.\", methodParam, ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn BeanUtils.instantiateClass(ctor, args);\n\t\t});\n\t}\n\n\t/**\n\t * Protected method to obtain the values for data binding. By default this\n\t * method delegates to {@link WebExchangeDataBinder#getValuesToBind}.\n\t * @param binder the data binder in use\n\t * @param exchange the current exchange\n\t * @return a map of bind values\n\t * @since 5.3\n\t */\n\tpublic Mono<Map<String, Object>> getValuesToBind(WebExchangeDataBinder binder, ServerWebExchange exchange) {\n\t\treturn binder.getValuesToBind(exchange);\n\t}\n\n\tprivate boolean hasErrorsArgument(MethodParameter parameter) {\n\t\tint i = parameter.getParameterIndex();\n\t\tClass<?>[] paramTypes = parameter.getExecutable().getParameterTypes();\n\t\treturn (paramTypes.length > i + 1 && Errors.class.isAssignableFrom(paramTypes[i + 1]));\n\t}\n\n\tprivate void validateIfApplicable(WebExchangeDataBinder binder, MethodParameter parameter, ServerWebExchange exchange) {\n\t\tLocaleContext localeContext = null;\n\t\ttry {\n\t\t\tfor (Annotation ann : parameter.getParameterAnnotations()) {\n\t\t\t\tObject[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);\n\t\t\t\tif (validationHints != null) {\n\t\t\t\t\tif (localeContext == null) {\n\t\t\t\t\t\tlocaleContext = exchange.getLocaleContext();\n\t\t\t\t\t\tLocaleContextHolder.setLocaleContext(localeContext);\n\t\t\t\t\t}\n\t\t\t\t\tbinder.validate(validationHints);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (localeContext != null) {\n\t\t\t\tLocaleContextHolder.resetLocaleContext();\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolver#bindRequestParameters(binder,exchange)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Extension point to bind the request to the target object.\n\t * @param binder the data binder instance to use for the binding\n\t * @param exchange the current request\n\t * @since 5.2.6\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> bindRequestParameters(WebExchangeDataBinder binder, ServerWebExchange exchange)",
    "source_code": "\tprotected Mono<Void> bindRequestParameters(WebExchangeDataBinder binder, ServerWebExchange exchange) {\n\t\treturn binder.bind(exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolver#getValuesToBind(binder,exchange)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Protected method to obtain the values for data binding. By default this\n\t * method delegates to {@link WebExchangeDataBinder#getValuesToBind}.\n\t * @param binder the data binder in use\n\t * @param exchange the current exchange\n\t * @return a map of bind values\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "binder",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "Object>>",
    "signature": "public Object>> getValuesToBind(WebExchangeDataBinder binder, ServerWebExchange exchange)",
    "source_code": "\tpublic Mono<Map<String, Object>> getValuesToBind(WebExchangeDataBinder binder, ServerWebExchange exchange) {\n\t\treturn binder.getValuesToBind(exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolver#resolveArgument(parameter,context,exchange)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "context",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "Mono<Object>",
    "signature": "public Mono<Object> resolveArgument(MethodParameter parameter, BindingContext context, ServerWebExchange exchange)",
    "source_code": "\tpublic Mono<Object> resolveArgument("
  },
  "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolver#supportsParameter(parameter)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "boolean",
    "signature": "public boolean supportsParameter(MethodParameter parameter)",
    "source_code": "\tpublic boolean supportsParameter(MethodParameter parameter) {\n\t\tif (parameter.hasParameterAnnotation(ModelAttribute.class)) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (this.useDefaultResolution) {\n\t\t\treturn checkParameterType(parameter, type -> !BeanUtils.isSimpleProperty(type));\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.NamedValueInfo": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Represents the information about a named value, including name, whether\n\t * it's required and a default value.\n\t */",
    "kind": "class",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 315
    },
    "signature": "protected class NamedValueInfo",
    "source_code": "\tprotected static class NamedValueInfo {\n\n\t\tprivate final String name;\n\n\t\tprivate final boolean required;\n\n\t\t@Nullable\n\t\tprivate final String defaultValue;\n\n\t\tpublic NamedValueInfo(String name, boolean required, @Nullable String defaultValue) {\n\t\t\tthis.name = name;\n\t\t\tthis.required = required;\n\t\t\tthis.defaultValue = defaultValue;\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter#setBlockingExecutor(executor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure an executor to invoke blocking controller methods with.\n\t * <p>By default, this is not set in which case controller methods are\n\t * invoked without the use of an Executor.\n\t * @param executor the task executor to use\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "executor"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "void",
    "signature": "public void setBlockingExecutor(@Nullable Executor executor)",
    "source_code": "\tpublic void setBlockingExecutor(@Nullable Executor executor) {\n\t\tthis.scheduler = (executor != null ? Schedulers.fromExecutor(executor) : null);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter#setBlockingMethodPredicate(predicate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide a predicate to decide which controller methods to invoke through\n\t * the configured {@link #setBlockingExecutor blockingExecutor}.\n\t * <p>If an executor is configured, the default predicate matches controller\n\t * methods whose return type is not recognized by the configured\n\t * {@link org.springframework.core.ReactiveAdapterRegistry}.\n\t * @param predicate the predicate to use\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "void",
    "signature": "public void setBlockingMethodPredicate(Predicate<HandlerMethod> predicate)",
    "source_code": "\tpublic void setBlockingMethodPredicate(Predicate<HandlerMethod> predicate) {\n\t\tthis.blockingMethodPredicate = predicate;\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter#test(handlerMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 351
    },
    "return": "boolean",
    "signature": "public boolean test(HandlerMethod handlerMethod)",
    "source_code": "\t\tpublic boolean test(HandlerMethod handlerMethod) {\n\t\t\tClass<?> returnType = handlerMethod.getReturnType().getParameterType();\n\t\t\treturn (this.adapterRegistry.getAdapter(returnType) == null\n\t\t\t\t\t&& !KotlinDetector.isSuspendingFunction(handlerMethod.getMethod()));\n\t\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMapping#createRequestMappingInfo(httpExchange,customCondition)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link RequestMappingInfo} from the supplied\n\t * {@link HttpExchange @HttpExchange} annotation, meta-annotation,\n\t * or synthesized result of merging annotation attributes within an\n\t * annotation hierarchy.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "httpExchange",
      "customCondition"
    ],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "RequestMappingInfo",
    "signature": "protected RequestMappingInfo createRequestMappingInfo(HttpExchange httpExchange, @Nullable RequestCondition<?> customCondition)",
    "source_code": "\tprotected RequestMappingInfo createRequestMappingInfo("
  },
  "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMapping#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 462
    },
    "return": "boolean",
    "signature": "public boolean equals(Object obj)",
    "source_code": "\t\tpublic boolean equals(Object obj) {\n\t\t\treturn (obj instanceof AnnotationDescriptor that && this.annotation.equals(that.annotation));\n\t\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMapping#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 467
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\t\tpublic int hashCode() {\n\t\t\treturn this.annotation.hashCode();\n\t\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMapping#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 472
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn this.root.synthesize().toString();\n\t\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.ResponseEntityExceptionHandler#handleHandlerMethodValidationException(ex,headers,status,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link HandlerMethodValidationException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the {@code ResponseEntity} for the response\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> handleHandlerMethodValidationException(HandlerMethodValidationException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> handleHandlerMethodValidationException("
  },
  "org.springframework.web.reactive.result.method.annotation.ResponseEntityExceptionHandler#handleMethodValidationException(ex,status,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link MethodValidationException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the {@code ResponseEntity} for the response\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> handleMethodValidationException(MethodValidationException ex, HttpStatus status, ServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> handleMethodValidationException("
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Jetty {@link WebSocket @WebSocket} handler that delegates events to a\n * reactive {@link WebSocketHandler} and its session.\n *\n * @author Violeta Georgieva\n * @author Rossen Stoyanchev\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "signature": "public class JettyWebSocketHandlerAdapter",
    "source_code": "public class JettyWebSocketHandlerAdapter {\n\n\tprivate static final ByteBuffer EMPTY_PAYLOAD = ByteBuffer.wrap(new byte[0]);\n\n\n\tprivate final WebSocketHandler delegateHandler;\n\n\tprivate final Function<Session, JettyWebSocketSession> sessionFactory;\n\n\t@Nullable\n\tprivate JettyWebSocketSession delegateSession;\n\n\n\tpublic JettyWebSocketHandlerAdapter(WebSocketHandler handler,\n\t\t\tFunction<Session, JettyWebSocketSession> sessionFactory) {\n\n\t\tAssert.notNull(handler, \"WebSocketHandler is required\");\n\t\tAssert.notNull(sessionFactory, \"'sessionFactory' is required\");\n\t\tthis.delegateHandler = handler;\n\t\tthis.sessionFactory = sessionFactory;\n\t}\n\n\n\t@OnWebSocketOpen\n\tpublic void onWebSocketOpen(Session session) {\n\t\tthis.delegateSession = this.sessionFactory.apply(session);\n\t\tthis.delegateHandler.handle(this.delegateSession)\n\t\t\t\t.checkpoint(session.getUpgradeRequest().getRequestURI() + \" [JettyWebSocketHandlerAdapter]\")\n\t\t\t\t.subscribe(this.delegateSession);\n\t}\n\n\t@OnWebSocketMessage\n\tpublic void onWebSocketText(String message) {\n\t\tif (this.delegateSession != null) {\n\t\t\tbyte[] bytes = message.getBytes(StandardCharsets.UTF_8);\n\t\t\tDataBuffer buffer = this.delegateSession.bufferFactory().wrap(bytes);\n\t\t\tWebSocketMessage webSocketMessage = new WebSocketMessage(Type.TEXT, buffer);\n\t\t\tthis.delegateSession.handleMessage(webSocketMessage.getType(), webSocketMessage);\n\t\t}\n\t}\n\n\t@OnWebSocketMessage\n\tpublic void onWebSocketBinary(ByteBuffer byteBuffer, Callback callback) {\n\t\tif (this.delegateSession != null) {\n\t\t\tDataBuffer buffer = this.delegateSession.bufferFactory().wrap(byteBuffer);\n\t\t\tbuffer = new JettyDataBuffer(buffer, callback);\n\t\t\tWebSocketMessage webSocketMessage = new WebSocketMessage(Type.BINARY, buffer);\n\t\t\tthis.delegateSession.handleMessage(webSocketMessage.getType(), webSocketMessage);\n\t\t}\n\t}\n\n\t@OnWebSocketFrame\n\tpublic void onWebSocketFrame(Frame frame, Callback callback) {\n\t\tif (this.delegateSession != null) {\n\t\t\tif (OpCode.PONG == frame.getOpCode()) {\n\t\t\t\tByteBuffer byteBuffer = (frame.getPayload() != null ? frame.getPayload() : EMPTY_PAYLOAD);\n\t\t\t\tDataBuffer buffer = this.delegateSession.bufferFactory().wrap(byteBuffer);\n\t\t\t\tbuffer = new JettyDataBuffer(buffer, callback);\n\t\t\t\tWebSocketMessage webSocketMessage = new WebSocketMessage(Type.PONG, buffer);\n\t\t\t\tthis.delegateSession.handleMessage(webSocketMessage.getType(), webSocketMessage);\n\t\t\t}\n\t\t}\n\t}\n\n\t@OnWebSocketClose\n\tpublic void onWebSocketClose(int statusCode, String reason) {\n\t\tif (this.delegateSession != null) {\n\t\t\tthis.delegateSession.handleClose(CloseStatus.create(statusCode, reason));\n\t\t}\n\t}\n\n\t@OnWebSocketError\n\tpublic void onWebSocketError(Throwable cause) {\n\t\tif (this.delegateSession != null) {\n\t\t\tthis.delegateSession.handleError(cause);\n\t\t}\n\t}\n\n\n\tprivate static final class JettyDataBuffer implements CloseableDataBuffer {\n\n\t\tprivate final DataBuffer delegate;\n\n\t\tprivate final Callback callback;\n\n\t\tpublic JettyDataBuffer(DataBuffer delegate, Callback callback) {\n\t\t\tAssert.notNull(delegate, \"'delegate` must not be null\");\n\t\t\tAssert.notNull(callback, \"Callback must not be null\");\n\t\t\tthis.delegate = delegate;\n\t\t\tthis.callback = callback;\n\t\t}\n\n\t\t@Override\n\t\tpublic void close() {\n\t\t\tthis.callback.succeed();\n\t\t}\n\n\t\t// delegation\n\n\t\t@Override\n\t\tpublic DataBufferFactory factory() {\n\t\t\treturn this.delegate.factory();\n\t\t}\n\n\t\t@Override\n\t\tpublic int indexOf(IntPredicate predicate, int fromIndex) {\n\t\t\treturn this.delegate.indexOf(predicate, fromIndex);\n\t\t}\n\n\t\t@Override\n\t\tpublic int lastIndexOf(IntPredicate predicate, int fromIndex) {\n\t\t\treturn this.delegate.lastIndexOf(predicate, fromIndex);\n\t\t}\n\n\t\t@Override\n\t\tpublic int readableByteCount() {\n\t\t\treturn this.delegate.readableByteCount();\n\t\t}\n\n\t\t@Override\n\t\tpublic int writableByteCount() {\n\t\t\treturn this.delegate.writableByteCount();\n\t\t}\n\n\t\t@Override\n\t\tpublic int capacity() {\n\t\t\treturn this.delegate.capacity();\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic DataBuffer capacity(int capacity) {\n\t\t\tthis.delegate.capacity(capacity);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer ensureWritable(int capacity) {\n\t\t\tthis.delegate.ensureWritable(capacity);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic int readPosition() {\n\t\t\treturn this.delegate.readPosition();\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer readPosition(int readPosition) {\n\t\t\tthis.delegate.readPosition(readPosition);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic int writePosition() {\n\t\t\treturn this.delegate.writePosition();\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer writePosition(int writePosition) {\n\t\t\tthis.delegate.writePosition(writePosition);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic byte getByte(int index) {\n\t\t\treturn this.delegate.getByte(index);\n\t\t}\n\n\t\t@Override\n\t\tpublic byte read() {\n\t\t\treturn this.delegate.read();\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer read(byte[] destination) {\n\t\t\tthis.delegate.read(destination);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer read(byte[] destination, int offset, int length) {\n\t\t\tthis.delegate.read(destination, offset, length);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer write(byte b) {\n\t\t\tthis.delegate.write(b);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer write(byte[] source) {\n\t\t\tthis.delegate.write(source);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer write(byte[] source, int offset, int length) {\n\t\t\tthis.delegate.write(source, offset, length);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer write(DataBuffer... buffers) {\n\t\t\tthis.delegate.write(buffers);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer write(ByteBuffer... buffers) {\n\t\t\tthis.delegate.write(buffers);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic DataBuffer slice(int index, int length) {\n\t\t\tDataBuffer delegateSlice = this.delegate.slice(index, length);\n\t\t\treturn new JettyDataBuffer(delegateSlice, this.callback);\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer split(int index) {\n\t\t\tDataBuffer delegateSplit = this.delegate.split(index);\n\t\t\treturn new JettyDataBuffer(delegateSplit, this.callback);\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic ByteBuffer asByteBuffer() {\n\t\t\treturn this.delegate.asByteBuffer();\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic ByteBuffer asByteBuffer(int index, int length) {\n\t\t\treturn this.delegate.asByteBuffer(index, length);\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic ByteBuffer toByteBuffer(int index, int length) {\n\t\t\treturn this.delegate.toByteBuffer(index, length);\n\t\t}\n\n\t\t@Override\n\t\tpublic void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length) {\n\t\t\tthis.delegate.toByteBuffer(srcPos, dest, destPos, length);\n\t\t}\n\n\t\t@Override\n\t\tpublic ByteBufferIterator readableByteBuffers() {\n\t\t\tByteBufferIterator delegateIterator = this.delegate.readableByteBuffers();\n\t\t\treturn new JettyByteBufferIterator(delegateIterator);\n\t\t}\n\n\t\t@Override\n\t\tpublic ByteBufferIterator writableByteBuffers() {\n\t\t\tByteBufferIterator delegateIterator = this.delegate.writableByteBuffers();\n\t\t\treturn new JettyByteBufferIterator(delegateIterator);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString(int index, int length, Charset charset) {\n\t\t\treturn this.delegate.toString(index, length, charset);\n\t\t}\n\n\n\t\tprivate record JettyByteBufferIterator(ByteBufferIterator delegate) implements ByteBufferIterator {\n\n\t\t\t@Override\n\t\t\tpublic void close() {\n\t\t\t\tthis.delegate.close();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn this.delegate.hasNext();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ByteBuffer next() {\n\t\t\t\treturn this.delegate.next();\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#asByteBuffer()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer asByteBuffer()",
    "source_code": "\t\tpublic ByteBuffer asByteBuffer() {\n\t\t\treturn this.delegate.asByteBuffer();\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#asByteBuffer(index,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer asByteBuffer(int index, int length)",
    "source_code": "\t\tpublic ByteBuffer asByteBuffer(int index, int length) {\n\t\t\treturn this.delegate.asByteBuffer(index, length);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#capacity()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "int",
    "signature": "public int capacity()",
    "source_code": "\t\tpublic int capacity() {\n\t\t\treturn this.delegate.capacity();\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#capacity(capacity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer capacity(int capacity)",
    "source_code": "\t\tpublic DataBuffer capacity(int capacity) {\n\t\t\tthis.delegate.capacity(capacity);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#close()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 328
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\t\t\tpublic void close() {\n\t\t\t\tthis.delegate.close();\n\t\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#ensureWritable(capacity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer ensureWritable(int capacity)",
    "source_code": "\t\tpublic DataBuffer ensureWritable(int capacity) {\n\t\t\tthis.delegate.ensureWritable(capacity);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#factory()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "DataBufferFactory",
    "signature": "public DataBufferFactory factory()",
    "source_code": "\t\tpublic DataBufferFactory factory() {\n\t\t\treturn this.delegate.factory();\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#getByte(index)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "byte",
    "signature": "public byte getByte(int index)",
    "source_code": "\t\tpublic byte getByte(int index) {\n\t\t\treturn this.delegate.getByte(index);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#hasNext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "boolean",
    "signature": "public boolean hasNext()",
    "source_code": "\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn this.delegate.hasNext();\n\t\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#indexOf(predicate,fromIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "fromIndex"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "int",
    "signature": "public int indexOf(IntPredicate predicate, int fromIndex)",
    "source_code": "\t\tpublic int indexOf(IntPredicate predicate, int fromIndex) {\n\t\t\treturn this.delegate.indexOf(predicate, fromIndex);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#lastIndexOf(predicate,fromIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "fromIndex"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "int",
    "signature": "public int lastIndexOf(IntPredicate predicate, int fromIndex)",
    "source_code": "\t\tpublic int lastIndexOf(IntPredicate predicate, int fromIndex) {\n\t\t\treturn this.delegate.lastIndexOf(predicate, fromIndex);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#next()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 338
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer next()",
    "source_code": "\t\t\tpublic ByteBuffer next() {\n\t\t\t\treturn this.delegate.next();\n\t\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#onWebSocketBinary(byteBuffer,callback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "byteBuffer",
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "void",
    "signature": "public void onWebSocketBinary(ByteBuffer byteBuffer, Callback callback)",
    "source_code": "\tpublic void onWebSocketBinary(ByteBuffer byteBuffer, Callback callback) {\n\t\tif (this.delegateSession != null) {\n\t\t\tDataBuffer buffer = this.delegateSession.bufferFactory().wrap(byteBuffer);\n\t\t\tbuffer = new JettyDataBuffer(buffer, callback);\n\t\t\tWebSocketMessage webSocketMessage = new WebSocketMessage(Type.BINARY, buffer);\n\t\t\tthis.delegateSession.handleMessage(webSocketMessage.getType(), webSocketMessage);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#onWebSocketClose(statusCode,reason)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusCode",
      "reason"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "void",
    "signature": "public void onWebSocketClose(int statusCode, String reason)",
    "source_code": "\tpublic void onWebSocketClose(int statusCode, String reason) {\n\t\tif (this.delegateSession != null) {\n\t\t\tthis.delegateSession.handleClose(CloseStatus.create(statusCode, reason));\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#onWebSocketError(cause)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cause"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void onWebSocketError(Throwable cause)",
    "source_code": "\tpublic void onWebSocketError(Throwable cause) {\n\t\tif (this.delegateSession != null) {\n\t\t\tthis.delegateSession.handleError(cause);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#onWebSocketFrame(frame,callback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "frame",
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "void",
    "signature": "public void onWebSocketFrame(Frame frame, Callback callback)",
    "source_code": "\tpublic void onWebSocketFrame(Frame frame, Callback callback) {\n\t\tif (this.delegateSession != null) {\n\t\t\tif (OpCode.PONG == frame.getOpCode()) {\n\t\t\t\tByteBuffer byteBuffer = (frame.getPayload() != null ? frame.getPayload() : EMPTY_PAYLOAD);\n\t\t\t\tDataBuffer buffer = this.delegateSession.bufferFactory().wrap(byteBuffer);\n\t\t\t\tbuffer = new JettyDataBuffer(buffer, callback);\n\t\t\t\tWebSocketMessage webSocketMessage = new WebSocketMessage(Type.PONG, buffer);\n\t\t\t\tthis.delegateSession.handleMessage(webSocketMessage.getType(), webSocketMessage);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#onWebSocketOpen(session)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "public void onWebSocketOpen(Session session)",
    "source_code": "\tpublic void onWebSocketOpen(Session session) {\n\t\tthis.delegateSession = this.sessionFactory.apply(session);\n\t\tthis.delegateHandler.handle(this.delegateSession)\n\t\t\t\t.checkpoint(session.getUpgradeRequest().getRequestURI() + \" [JettyWebSocketHandlerAdapter]\")\n\t\t\t\t.subscribe(this.delegateSession);\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#onWebSocketText(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "void",
    "signature": "public void onWebSocketText(String message)",
    "source_code": "\tpublic void onWebSocketText(String message) {\n\t\tif (this.delegateSession != null) {\n\t\t\tbyte[] bytes = message.getBytes(StandardCharsets.UTF_8);\n\t\t\tDataBuffer buffer = this.delegateSession.bufferFactory().wrap(bytes);\n\t\t\tWebSocketMessage webSocketMessage = new WebSocketMessage(Type.TEXT, buffer);\n\t\t\tthis.delegateSession.handleMessage(webSocketMessage.getType(), webSocketMessage);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#read()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "byte",
    "signature": "public byte read()",
    "source_code": "\t\tpublic byte read() {\n\t\t\treturn this.delegate.read();\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#read(destination)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer read(byte[] destination)",
    "source_code": "\t\tpublic DataBuffer read(byte[] destination) {\n\t\t\tthis.delegate.read(destination);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#read(destination,offset,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer read(byte[] destination, int offset, int length)",
    "source_code": "\t\tpublic DataBuffer read(byte[] destination, int offset, int length) {\n\t\t\tthis.delegate.read(destination, offset, length);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#readPosition()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "int",
    "signature": "public int readPosition()",
    "source_code": "\t\tpublic int readPosition() {\n\t\t\treturn this.delegate.readPosition();\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#readPosition(readPosition)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "readPosition"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer readPosition(int readPosition)",
    "source_code": "\t\tpublic DataBuffer readPosition(int readPosition) {\n\t\t\tthis.delegate.readPosition(readPosition);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#readableByteBuffers()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "ByteBufferIterator",
    "signature": "public ByteBufferIterator readableByteBuffers()",
    "source_code": "\t\tpublic ByteBufferIterator readableByteBuffers() {\n\t\t\tByteBufferIterator delegateIterator = this.delegate.readableByteBuffers();\n\t\t\treturn new JettyByteBufferIterator(delegateIterator);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#readableByteCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "int",
    "signature": "public int readableByteCount()",
    "source_code": "\t\tpublic int readableByteCount() {\n\t\t\treturn this.delegate.readableByteCount();\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#slice(index,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer slice(int index, int length)",
    "source_code": "\t\tpublic DataBuffer slice(int index, int length) {\n\t\t\tDataBuffer delegateSlice = this.delegate.slice(index, length);\n\t\t\treturn new JettyDataBuffer(delegateSlice, this.callback);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#split(index)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index"
    ],
    "position": {
      "column": 1,
      "line": 279
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer split(int index)",
    "source_code": "\t\tpublic DataBuffer split(int index) {\n\t\t\tDataBuffer delegateSplit = this.delegate.split(index);\n\t\t\treturn new JettyDataBuffer(delegateSplit, this.callback);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#toByteBuffer(index,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 298
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer toByteBuffer(int index, int length)",
    "source_code": "\t\tpublic ByteBuffer toByteBuffer(int index, int length) {\n\t\t\treturn this.delegate.toByteBuffer(index, length);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#toByteBuffer(srcPos,dest,destPos,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "srcPos",
      "dest",
      "destPos",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 303
    },
    "return": "void",
    "signature": "public void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length)",
    "source_code": "\t\tpublic void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length) {\n\t\t\tthis.delegate.toByteBuffer(srcPos, dest, destPos, length);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#toString(index,length,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 320
    },
    "return": "String",
    "signature": "public String toString(int index, int length, Charset charset)",
    "source_code": "\t\tpublic String toString(int index, int length, Charset charset) {\n\t\t\treturn this.delegate.toString(index, length, charset);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#writableByteBuffers()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 314
    },
    "return": "ByteBufferIterator",
    "signature": "public ByteBufferIterator writableByteBuffers()",
    "source_code": "\t\tpublic ByteBufferIterator writableByteBuffers() {\n\t\t\tByteBufferIterator delegateIterator = this.delegate.writableByteBuffers();\n\t\t\treturn new JettyByteBufferIterator(delegateIterator);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#writableByteCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "int",
    "signature": "public int writableByteCount()",
    "source_code": "\t\tpublic int writableByteCount() {\n\t\t\treturn this.delegate.writableByteCount();\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#write(b)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer write(byte b)",
    "source_code": "\t\tpublic DataBuffer write(byte b) {\n\t\t\tthis.delegate.write(b);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#write(buffers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "buffers"
    ],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer write(ByteBuffer... buffers)",
    "source_code": "\t\tpublic DataBuffer write(ByteBuffer... buffers) {\n\t\t\tthis.delegate.write(buffers);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#write(source)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source"
    ],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer write(byte[] source)",
    "source_code": "\t\tpublic DataBuffer write(byte[] source) {\n\t\t\tthis.delegate.write(source);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#write(source,offset,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer write(byte[] source, int offset, int length)",
    "source_code": "\t\tpublic DataBuffer write(byte[] source, int offset, int length) {\n\t\t\tthis.delegate.write(source, offset, length);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#writePosition()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "int",
    "signature": "public int writePosition()",
    "source_code": "\t\tpublic int writePosition() {\n\t\t\treturn this.delegate.writePosition();\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#writePosition(writePosition)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "writePosition"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer writePosition(int writePosition)",
    "source_code": "\t\tpublic DataBuffer writePosition(int writePosition) {\n\t\t\tthis.delegate.writePosition(writePosition);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketSession#fail(x)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "x"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "void",
    "signature": "public void fail(Throwable x)",
    "source_code": "\t\tpublic void fail(Throwable x) {\n\t\t\tgetSendProcessor().cancel();\n\t\t\tgetSendProcessor().onError(x);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketSession#succeed()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "void",
    "signature": "public void succeed()",
    "source_code": "\t\tpublic void succeed() {\n\t\t\tgetSendProcessor().setReadyToSend(true);\n\t\t\tgetSendProcessor().onWritePossible();\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketSession#writeFailed(x)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "x"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "void",
    "signature": "public void writeFailed(Throwable x)",
    "source_code": "\t\tpublic void writeFailed(Throwable x) {\n\t\t\tgetSendProcessor().cancel();\n\t\t\tgetSendProcessor().onError(x);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketSession#writeSuccess()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "void",
    "signature": "public void writeSuccess()",
    "source_code": "\t\tpublic void writeSuccess() {\n\t\t\tgetSendProcessor().setReadyToSend(true);\n\t\t\tgetSendProcessor().onWritePossible();\n\t\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#observationConvention(observationConvention)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a {@link ServerRequestObservationConvention} to use for server observations.\n\t * By default, a {@link DefaultServerRequestObservationConvention} will be used.\n\t * @param observationConvention the convention to use for all recorded observations\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "observationConvention"
    ],
    "position": {
      "column": 1,
      "line": 397
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder observationConvention(ServerRequestObservationConvention observationConvention)",
    "source_code": "\tpublic WebHttpHandlerBuilder observationConvention(ServerRequestObservationConvention observationConvention) {\n\t\tthis.observationConvention = observationConvention;\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#observationRegistry(observationRegistry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure an {@link ObservationRegistry} for recording server exchange observations.\n\t * By default, a {@link ObservationRegistry#NOOP no-op} registry will be configured.\n\t * @param observationRegistry the observation registry\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "observationRegistry"
    ],
    "position": {
      "column": 1,
      "line": 386
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder observationRegistry(ObservationRegistry observationRegistry)",
    "source_code": "\tpublic WebHttpHandlerBuilder observationRegistry(ObservationRegistry observationRegistry) {\n\t\tthis.observationRegistry = observationRegistry;\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#create(client,method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Create the {@code ResponseFunction} that matches the method return type.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "client",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 425
    },
    "return": "ResponseFunction",
    "signature": "public ResponseFunction create(ReactorHttpExchangeAdapter client, Method method)",
    "source_code": "\t\tpublic static ResponseFunction create(ReactorHttpExchangeAdapter client, Method method) {\n\t\t\tMethodParameter returnParam = new MethodParameter(method, -1);\n\t\t\tClass<?> returnType = returnParam.getParameterType();\n\t\t\tboolean isSuspending = KotlinDetector.isSuspendingFunction(method);\n\t\t\tif (isSuspending) {\n\t\t\t\treturnType = Mono.class;\n\t\t\t}\n\n\t\t\tReactiveAdapter reactiveAdapter = client.getReactiveAdapterRegistry().getAdapter(returnType);\n\n\t\t\tMethodParameter actualParam = (reactiveAdapter != null ? returnParam.nested() : returnParam.nestedIfOptional());\n\t\t\tClass<?> actualType = isSuspending ? actualParam.getParameterType() : actualParam.getNestedParameterType();\n\n\t\t\tFunction<HttpRequestValues, Publisher<?>> responseFunction;\n\t\t\tif (ClassUtils.isVoidType(actualType)) {\n\t\t\t\tresponseFunction = client::exchangeForMono;\n\t\t\t}\n\t\t\telse if (reactiveAdapter != null && reactiveAdapter.isNoValue()) {\n\t\t\t\tresponseFunction = client::exchangeForMono;\n\t\t\t}\n\t\t\telse if (actualType.equals(HttpHeaders.class)) {\n\t\t\t\tresponseFunction = client::exchangeForHeadersMono;\n\t\t\t}\n\t\t\telse if (actualType.equals(ResponseEntity.class)) {\n\t\t\t\tMethodParameter bodyParam = isSuspending ? actualParam : actualParam.nested();\n\t\t\t\tClass<?> bodyType = bodyParam.getNestedParameterType();\n\t\t\t\tif (bodyType.equals(Void.class)) {\n\t\t\t\t\tresponseFunction = client::exchangeForBodilessEntityMono;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tReactiveAdapter bodyAdapter = client.getReactiveAdapterRegistry().getAdapter(bodyType);\n\t\t\t\t\tresponseFunction = initResponseEntityFunction(client, bodyParam, bodyAdapter, isSuspending);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresponseFunction = initBodyFunction(client, actualParam, reactiveAdapter, isSuspending);\n\t\t\t}\n\n\t\t\treturn new ReactorExchangeResponseFunction(\n\t\t\t\t\tresponseFunction, reactiveAdapter, returnType.equals(Optional.class), client.getBlockTimeout());\n\t\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#create(client,method,reactiveRegistry,blockTimeout)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Create the {@code ResponseFunction} that matches the method's return type.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "client",
      "method",
      "reactiveRegistry",
      "blockTimeout"
    ],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "ResponseFunction",
    "signature": "public ResponseFunction create(HttpClientAdapter client, Method method, ReactiveAdapterRegistry reactiveRegistry,\n\t\t\t\tDuration blockTimeout)",
    "source_code": "\t\tpublic static ResponseFunction create("
  },
  "org.springframework.web.service.invoker.<unknown>#create(method,containingClass,embeddedValueResolver)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Introspect the method and create the request factory for it.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "containingClass",
      "embeddedValueResolver"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "HttpRequestValuesInitializer",
    "signature": "public HttpRequestValuesInitializer create(Method method, Class<?> containingClass, @Nullable StringValueResolver embeddedValueResolver)",
    "source_code": "\t\tpublic static HttpRequestValuesInitializer create("
  },
  "org.springframework.web.service.invoker.<unknown>#create(method,containingClass,embeddedValueResolver,requestValuesSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Introspect the method and create the request factory for it.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "containingClass",
      "embeddedValueResolver",
      "requestValuesSupplier"
    ],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "HttpRequestValuesInitializer",
    "signature": "public HttpRequestValuesInitializer create(Method method, Class<?> containingClass, @Nullable StringValueResolver embeddedValueResolver,\n\t\t\t\tSupplier<HttpRequestValues.Builder> requestValuesSupplier)",
    "source_code": "\t\tpublic static HttpRequestValuesInitializer create("
  },
  "org.springframework.web.service.invoker.<unknown>#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 303
    },
    "return": "boolean",
    "signature": "public boolean equals(Object obj)",
    "source_code": "\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\treturn (obj instanceof AnnotationDescriptor that && this.httpExchange.equals(that.httpExchange));\n\t\t\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\t\t\tpublic int hashCode() {\n\t\t\t\treturn this.httpExchange.hashCode();\n\t\t\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 313
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\t\tpublic String toString() {\n\t\t\t\treturn this.root.synthesize().toString();\n\t\t\t}"
  },
  "org.springframework.web.service.invoker.HttpServiceProxyFactory#builderFor(exchangeAdapter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a builder that's initialized with the given client.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchangeAdapter"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "Builder",
    "signature": "public Builder builderFor(HttpExchangeAdapter exchangeAdapter)",
    "source_code": "\tpublic static Builder builderFor(HttpExchangeAdapter exchangeAdapter) {\n\t\treturn new Builder().exchangeAdapter(exchangeAdapter);\n\t}"
  },
  "org.springframework.web.service.invoker.HttpServiceProxyFactory#exchangeAdapter(adapter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Provide the HTTP client to perform requests through.\n\t\t * @param adapter a client adapted to {@link HttpExchangeAdapter}\n\t\t * @return this same builder instance\n\t\t * @since 6.1\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "adapter"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "Builder",
    "signature": "public Builder exchangeAdapter(HttpExchangeAdapter adapter)",
    "source_code": "\t\tpublic Builder exchangeAdapter(HttpExchangeAdapter adapter) {\n\t\t\tthis.exchangeAdapter = adapter;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.service.invoker.HttpServiceProxyFactory#invokeSuspendingFunction(invocation,httpServiceMethod)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "invocation",
      "httpServiceMethod"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "Object",
    "signature": "public Object invokeSuspendingFunction(MethodInvocation invocation, HttpServiceMethod httpServiceMethod)",
    "source_code": "\t\tpublic static Object invokeSuspendingFunction(MethodInvocation invocation, HttpServiceMethod httpServiceMethod) {\n\t\t\tObject[] rawArguments = invocation.getArguments();\n\t\t\tObject[] arguments = resolveArguments(rawArguments);\n\t\t\tContinuation<Object> continuation = (Continuation<Object>) rawArguments[rawArguments.length - 1];\n\t\t\tMono<Object> wrapped = (Mono<Object>) httpServiceMethod.invoke(arguments);\n\t\t\treturn MonoKt.awaitSingleOrNull(wrapped, continuation);\n\t\t}"
  },
  "org.springframework.web.service.invoker.RequestBodyArgumentResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link HttpServiceArgumentResolver} for {@link RequestBody @RequestBody}\n * annotated arguments.\n *\n * @author Rossen Stoyanchev\n * @since 6.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 35
    },
    "signature": "public class RequestBodyArgumentResolver",
    "source_code": "public class RequestBodyArgumentResolver implements HttpServiceArgumentResolver {\n\n\tprivate static final boolean REACTOR_PRESENT =\n\t\t\tClassUtils.isPresent(\"reactor.core.publisher.Mono\", RequestBodyArgumentResolver.class.getClassLoader());\n\n\n\t@Nullable\n\tprivate final ReactiveAdapterRegistry reactiveAdapterRegistry;\n\n\n\t/**\n\t * Constructor with a {@link HttpExchangeAdapter}, for access to config settings.\n\t * @since 6.1\n\t */\n\tpublic RequestBodyArgumentResolver(HttpExchangeAdapter exchangeAdapter) {\n\t\tif (REACTOR_PRESENT) {\n\t\t\tthis.reactiveAdapterRegistry =\n\t\t\t\t\t(exchangeAdapter instanceof ReactorHttpExchangeAdapter reactorAdapter ?\n\t\t\t\t\t\t\treactorAdapter.getReactiveAdapterRegistry() :\n\t\t\t\t\t\t\tReactiveAdapterRegistry.getSharedInstance());\n\t\t}\n\t\telse {\n\t\t\tthis.reactiveAdapterRegistry = null;\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic boolean resolve(\n\t\t\t@Nullable Object argument, MethodParameter parameter, HttpRequestValues.Builder requestValues) {\n\n\t\tRequestBody annot = parameter.getParameterAnnotation(RequestBody.class);\n\t\tif (annot == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (argument != null) {\n\t\t\tif (this.reactiveAdapterRegistry != null) {\n\t\t\t\tReactiveAdapter adapter = this.reactiveAdapterRegistry.getAdapter(parameter.getParameterType());\n\t\t\t\tif (adapter != null) {\n\t\t\t\t\tMethodParameter nestedParameter = parameter.nested();\n\n\t\t\t\t\tString message = \"Async type for @RequestBody should produce value(s)\";\n\t\t\t\t\tAssert.isTrue(!adapter.isNoValue(), message);\n\t\t\t\t\tAssert.isTrue(nestedParameter.getNestedParameterType() != Void.class, message);\n\n\t\t\t\t\tif (requestValues instanceof ReactiveHttpRequestValues.Builder reactiveRequestValues) {\n\t\t\t\t\t\treactiveRequestValues.setBodyPublisher(\n\t\t\t\t\t\t\t\tadapter.toPublisher(argument), asParameterizedTypeRef(nestedParameter));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\t\"RequestBody with a reactive type is only supported with reactive client\");\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Not a reactive type\n\t\t\trequestValues.setBodyValue(argument);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate static ParameterizedTypeReference<Object> asParameterizedTypeRef(MethodParameter nestedParam) {\n\t\treturn ParameterizedTypeReference.forType(nestedParam.getNestedGenericParameterType());\n\t}\n\n}"
  },
  "org.springframework.web.service.invoker.RequestBodyArgumentResolver#resolve(argument,parameter,requestValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argument",
      "parameter",
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "boolean",
    "signature": "public boolean resolve(@Nullable Object argument, MethodParameter parameter, HttpRequestValues.Builder requestValues)",
    "source_code": "\tpublic boolean resolve("
  },
  "org.springframework.web.service.invoker.RequestPartArgumentResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link HttpServiceArgumentResolver} for {@link RequestPart @RequestPart}\n * annotated arguments.\n *\n * <p>The argument may be:\n * <ul>\n * <li>String -- form field\n * <li>{@link org.springframework.core.io.Resource Resource} -- file part\n * <li>{@link MultipartFile} -- uploaded file\n * <li>Object -- content to be encoded (e.g. to JSON)\n * <li>{@link HttpEntity} -- part content and headers although generally it's\n * easier to add headers through the returned builder\n * <li>{@link Part} -- a part from a server request\n * <li>{@link Publisher} of any of the above\n * </ul>\n *\n * @author Rossen Stoyanchev\n * @since 6.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "signature": "public class RequestPartArgumentResolver",
    "source_code": "public class RequestPartArgumentResolver extends AbstractNamedValueArgumentResolver {\n\n\tprivate static final boolean REACTOR_PRESENT =\n\t\t\tClassUtils.isPresent(\"reactor.core.publisher.Mono\", RequestPartArgumentResolver.class.getClassLoader());\n\n\n\t@Nullable\n\tprivate final ReactiveAdapterRegistry reactiveAdapterRegistry;\n\n\n\t/**\n\t * Constructor with a {@link HttpExchangeAdapter}, for access to config settings.\n\t * @since 6.1\n\t */\n\tpublic RequestPartArgumentResolver(HttpExchangeAdapter exchangeAdapter) {\n\t\tif (REACTOR_PRESENT) {\n\t\t\tthis.reactiveAdapterRegistry =\n\t\t\t\t\t(exchangeAdapter instanceof ReactorHttpExchangeAdapter reactorAdapter ?\n\t\t\t\t\t\t\treactorAdapter.getReactiveAdapterRegistry() :\n\t\t\t\t\t\t\tReactiveAdapterRegistry.getSharedInstance());\n\t\t}\n\t\telse {\n\t\t\tthis.reactiveAdapterRegistry = null;\n\t\t}\n\t}\n\n\n\t@Override\n\t@Nullable\n\tprotected NamedValueInfo createNamedValueInfo(MethodParameter parameter) {\n\t\tRequestPart annot = parameter.getParameterAnnotation(RequestPart.class);\n\t\tboolean isMultiPartFile = parameter.nestedIfOptional().getNestedParameterType().equals(MultipartFile.class);\n\t\tString label = (isMultiPartFile ? \"MultipartFile\" : \"request part\");\n\n\t\tif (annot != null) {\n\t\t\treturn new NamedValueInfo(annot.name(), annot.required(), null, label, true);\n\t\t}\n\t\telse if (isMultiPartFile) {\n\t\t\treturn new NamedValueInfo(\"\", true, null, label, true);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t@Override\n\tprotected void addRequestValue(\n\t\t\tString name, Object value, MethodParameter parameter, HttpRequestValues.Builder requestValues) {\n\n\t\tif (this.reactiveAdapterRegistry != null) {\n\t\t\tClass<?> type = parameter.getParameterType();\n\t\t\tReactiveAdapter adapter = this.reactiveAdapterRegistry.getAdapter(type);\n\t\t\tif (adapter != null) {\n\t\t\t\tMethodParameter nestedParameter = parameter.nested();\n\n\t\t\t\tString message = \"Async type for @RequestPart should produce value(s)\";\n\t\t\t\tAssert.isTrue(!adapter.isNoValue(), message);\n\t\t\t\tAssert.isTrue(nestedParameter.getNestedParameterType() != Void.class, message);\n\n\t\t\t\tif (requestValues instanceof ReactiveHttpRequestValues.Builder reactiveValues) {\n\t\t\t\t\treactiveValues.addRequestPartPublisher(\n\t\t\t\t\t\t\tname, adapter.toPublisher(value), asParameterizedTypeRef(nestedParameter));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\"RequestPart with a reactive type is only supported with reactive client\");\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (value instanceof MultipartFile multipartFile) {\n\t\t\tvalue = toHttpEntity(name, multipartFile);\n\t\t}\n\n\t\trequestValues.addRequestPart(name, value);\n\t}\n\n\tprivate static ParameterizedTypeReference<Object> asParameterizedTypeRef(MethodParameter nestedParam) {\n\t\treturn ParameterizedTypeReference.forType(nestedParam.getNestedGenericParameterType());\n\t}\n\n\tprivate static Object toHttpEntity(String name, MultipartFile multipartFile) {\n\t\tHttpHeaders headers = new HttpHeaders();\n\t\tif (multipartFile.getOriginalFilename() != null) {\n\t\t\theaders.setContentDispositionFormData(name, multipartFile.getOriginalFilename());\n\t\t}\n\t\tif (multipartFile.getContentType() != null) {\n\t\t\theaders.add(HttpHeaders.CONTENT_TYPE, multipartFile.getContentType());\n\t\t}\n\t\treturn new HttpEntity<>(multipartFile.getResource(), headers);\n\t}\n\n}"
  },
  "org.springframework.web.service.invoker.RequestPartArgumentResolver#addRequestValue(name,value,parameter,requestValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "value",
      "parameter",
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "protected void addRequestValue(String name, Object value, MethodParameter parameter, HttpRequestValues.Builder requestValues)",
    "source_code": "\tprotected void addRequestValue("
  },
  "org.springframework.web.service.invoker.RequestPartArgumentResolver#createNamedValueInfo(parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "NamedValueInfo",
    "signature": "protected NamedValueInfo createNamedValueInfo(MethodParameter parameter)",
    "source_code": "\tprotected NamedValueInfo createNamedValueInfo(MethodParameter parameter) {\n\t\tRequestPart annot = parameter.getParameterAnnotation(RequestPart.class);\n\t\tboolean isMultiPartFile = parameter.nestedIfOptional().getNestedParameterType().equals(MultipartFile.class);\n\t\tString label = (isMultiPartFile ? \"MultipartFile\" : \"request part\");\n\n\t\tif (annot != null) {\n\t\t\treturn new NamedValueInfo(annot.name(), annot.required(), null, label, true);\n\t\t}\n\t\telse if (isMultiPartFile) {\n\t\t\treturn new NamedValueInfo(\"\", true, null, label, true);\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#bind(bindType,dataBinderCustomizer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bindType",
      "dataBinderCustomizer"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "T",
    "signature": "public T bind(Class<T> bindType, Consumer<WebDataBinder> dataBinderCustomizer)",
    "source_code": "\t\tpublic <T> T bind(Class<T> bindType, Consumer<WebDataBinder> dataBinderCustomizer) throws BindException {\n\t\t\tAssert.notNull(bindType, \"BindType must not be null\");\n\t\t\tAssert.notNull(dataBinderCustomizer, \"DataBinderCustomizer must not be null\");\n\n\t\t\tServletRequestDataBinder dataBinder = new ServletRequestDataBinder(null);\n\t\t\tdataBinder.setTargetType(ResolvableType.forClass(bindType));\n\t\t\tdataBinderCustomizer.accept(dataBinder);\n\n\t\t\tHttpServletRequest servletRequest = servletRequest();\n\t\t\tdataBinder.construct(servletRequest);\n\t\t\tdataBinder.bind(servletRequest);\n\n\t\t\tBindingResult bindingResult = dataBinder.getBindingResult();\n\t\t\tif (bindingResult.hasErrors()) {\n\t\t\t\tthrow new BindException(bindingResult);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tT result = (T) bindingResult.getTarget();\n\t\t\t\tif (result != null) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalStateException(\"Binding result has neither target nor errors\");\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#headers()": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders headers()",
    "source_code": "\tpublic HttpHeaders headers() {\n\t\treturn delegate(ServerResponse::headers);\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#send()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "void",
    "signature": "public void send()",
    "source_code": "\t\tpublic void send() throws IOException {\n\t\t\tthis.builder.append('\\n');\n\t\t\ttry {\n\t\t\t\tOutputStream body = this.outputMessage.getBody();\n\t\t\t\tbody.write(builderBytes());\n\t\t\t\tbody.flush();\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthis.sendFailed = true;\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.builder.setLength(0);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.function.RequestPredicates#bind(bindType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bindType"
    ],
    "position": {
      "column": 1,
      "line": 1216
    },
    "return": "T",
    "signature": "public T bind(Class<T> bindType)",
    "source_code": "\t\tpublic <T> T bind(Class<T> bindType) throws BindException {\n\t\t\treturn this.delegate.bind(bindType);\n\t\t}"
  },
  "org.springframework.web.servlet.function.RequestPredicates#bind(bindType,dataBinderCustomizer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bindType",
      "dataBinderCustomizer"
    ],
    "position": {
      "column": 1,
      "line": 1221
    },
    "return": "T",
    "signature": "public T bind(Class<T> bindType, Consumer<WebDataBinder> dataBinderCustomizer)",
    "source_code": "\t\tpublic <T> T bind(Class<T> bindType, Consumer<WebDataBinder> dataBinderCustomizer) throws BindException {\n\t\t\treturn this.delegate.bind(bindType, dataBinderCustomizer);\n\t\t}"
  },
  "org.springframework.web.servlet.function.RequestPredicates#modifiesAttributes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 538
    },
    "return": "boolean",
    "signature": "public boolean modifiesAttributes()",
    "source_code": "\t\t\tpublic boolean modifiesAttributes() {\n\t\t\t\treturn this.modifyAttributes != null;\n\t\t\t}"
  },
  "org.springframework.web.servlet.function.RequestPredicates#modifyAttributes(Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 532
    },
    "return": "void",
    "signature": "public void modifyAttributes(Map<String, Object> attributes)",
    "source_code": "\t\t\tpublic void modifyAttributes(Map<String, Object> attributes) {\n\t\t\t\tif (this.modifyAttributes != null) {\n\t\t\t\t\tthis.modifyAttributes.accept(attributes);\n\t\t\t\t}\n\t\t\t}"
  },
  "org.springframework.web.servlet.function.RequestPredicates#of(requestPredicate)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestPredicate"
    ],
    "position": {
      "column": 1,
      "line": 467
    },
    "return": "RequestModifyingPredicate",
    "signature": "public RequestModifyingPredicate of(RequestPredicate requestPredicate)",
    "source_code": "\t\tpublic static RequestModifyingPredicate of(RequestPredicate requestPredicate) {\n\t\t\tif (requestPredicate instanceof RequestModifyingPredicate modifyingPredicate) {\n\t\t\t\treturn modifyingPredicate;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new RequestModifyingPredicate() {\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected Result testInternal(ServerRequest request) {\n\t\t\t\t\t\treturn Result.of(requestPredicate.test(request));\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.function.RequestPredicates#of(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 514
    },
    "return": "Result",
    "signature": "public Result of(boolean value)",
    "source_code": "\t\t\tpublic static Result of(boolean value) {\n\t\t\t\treturn of(value, null);\n\t\t\t}"
  },
  "org.springframework.web.servlet.function.RequestPredicates#of(value,Consumer<Map<String,modifyAttributes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "Consumer<Map<String",
      "modifyAttributes"
    ],
    "position": {
      "column": 1,
      "line": 518
    },
    "return": "Result",
    "signature": "public Result of(boolean value, @Nullable Consumer<Map<String, Object>> modifyAttributes)",
    "source_code": "\t\t\tpublic static Result of(boolean value, @Nullable Consumer<Map<String, Object>> modifyAttributes) {\n\t\t\t\tif (modifyAttributes == null) {\n\t\t\t\t\treturn value ? TRUE : FALSE;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new Result(value, modifyAttributes);\n\t\t\t\t}\n\t\t\t}"
  },
  "org.springframework.web.servlet.function.RequestPredicates#path()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1380
    },
    "return": "String",
    "signature": "public String path()",
    "source_code": "\t\tpublic String path() {\n\t\t\treturn this.requestPath.pathWithinApplication().value();\n\t\t}"
  },
  "org.springframework.web.servlet.function.RequestPredicates#pathContainer()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1386
    },
    "return": "PathContainer",
    "signature": "public PathContainer pathContainer()",
    "source_code": "\t\tpublic PathContainer pathContainer() {\n\t\t\treturn this.requestPath;\n\t\t}"
  },
  "org.springframework.web.servlet.function.RequestPredicates#pathVariable(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 1319
    },
    "return": "String",
    "signature": "public String pathVariable(String name)",
    "source_code": "\t\tpublic String pathVariable(String name) {\n\t\t\tMap<String, String> pathVariables = pathVariables();\n\t\t\tif (pathVariables.containsKey(name)) {\n\t\t\t\treturn pathVariables.get(name);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"No path variable with name \\\"\" + name + \"\\\" available\");\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.function.RequestPredicates#testInternal(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 1090
    },
    "return": "Result",
    "signature": "protected Result testInternal(ServerRequest request)",
    "source_code": "\t\tprotected Result testInternal(ServerRequest request) {\n\t\t\tResult leftResult = this.leftModifying.testInternal(request);\n\t\t\tif (leftResult.value()) {\n\t\t\t\treturn leftResult;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn this.rightModifying.testInternal(request);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.function.RequestPredicates#value()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 528
    },
    "return": "boolean",
    "signature": "public boolean value()",
    "source_code": "\t\t\tpublic boolean value() {\n\t\t\t\treturn this.value;\n\t\t\t}"
  },
  "org.springframework.web.servlet.function.Result": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "class",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 495
    },
    "signature": "protected class Result",
    "source_code": "\t\tprotected static final class Result {\n\n\t\t\tprivate static final Result TRUE = new Result(true, null);\n\n\t\t\tprivate static final Result FALSE = new Result(false, null);\n\n\n\t\t\tprivate final boolean value;\n\n\t\t\t@Nullable\n\t\t\tprivate final Consumer<Map<String, Object>> modifyAttributes;\n\n\n\t\t\tprivate Result(boolean value, @Nullable Consumer<Map<String, Object>> modifyAttributes) {\n\t\t\t\tthis.value = value;\n\t\t\t\tthis.modifyAttributes = modifyAttributes;\n\t\t\t}\n\n\n\t\t\tpublic static Result of(boolean value) {\n\t\t\t\treturn of(value, null);\n\t\t\t}\n\n\t\t\tpublic static Result of(boolean value, @Nullable Consumer<Map<String, Object>> modifyAttributes) {\n\t\t\t\tif (modifyAttributes == null) {\n\t\t\t\t\treturn value ? TRUE : FALSE;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new Result(value, modifyAttributes);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tpublic boolean value() {\n\t\t\t\treturn this.value;\n\t\t\t}\n\n\t\t\tpublic void modifyAttributes(Map<String, Object> attributes) {\n\t\t\t\tif (this.modifyAttributes != null) {\n\t\t\t\t\tthis.modifyAttributes.accept(attributes);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpublic boolean modifiesAttributes() {\n\t\t\t\treturn this.modifyAttributes != null;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.handler.MappedInterceptor#getExcludePathPatterns()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the exclude path patterns this interceptor is mapped to.\n\t * @since 6.1\n\t * @see #getIncludePathPatterns()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "String[]",
    "signature": "public String[] getExcludePathPatterns()",
    "source_code": "\tpublic String[] getExcludePathPatterns() {\n\t\treturn (!ObjectUtils.isEmpty(this.excludePatterns) ?\n\t\t\t\tArrays.stream(this.excludePatterns).map(PatternAdapter::getPatternString).toArray(String[]::new) :\n\t\t\t\tnull);\n\t}"
  },
  "org.springframework.web.servlet.handler.MappedInterceptor#getIncludePathPatterns()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the include path patterns this interceptor is mapped to.\n\t * @since 6.1\n\t * @see #getExcludePathPatterns()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "String[]",
    "signature": "public String[] getIncludePathPatterns()",
    "source_code": "\tpublic String[] getIncludePathPatterns() {\n\t\treturn (!ObjectUtils.isEmpty(this.includePatterns) ?\n\t\t\t\tArrays.stream(this.includePatterns).map(PatternAdapter::getPatternString).toArray(String[]::new) :\n\t\t\t\tnull);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfo#getPatternParserToUse()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return the {@code PathPatternParser} to use, the one set explicitly\n\t\t * or falling back on a default instance if both {@code PathPatternParser}\n\t\t * and {@code PathMatcher} are not set.\n\t\t * @since 6.1.2\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 970
    },
    "return": "PathPatternParser",
    "signature": "public PathPatternParser getPatternParserToUse()",
    "source_code": "\t\tpublic PathPatternParser getPatternParserToUse() {\n\t\t\tif (this.patternParser == null && this.pathMatcher == null) {\n\t\t\t\treturn defaultPatternParser;\n\t\t\t}\n\t\t\treturn this.patternParser;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver#canRead(clazz,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 370
    },
    "return": "boolean",
    "signature": "public boolean canRead(Class<?> clazz, @Nullable MediaType mediaType)",
    "source_code": "\t\tpublic boolean canRead(Class<?> clazz, @Nullable MediaType mediaType) {\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver#canWrite(clazz,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 375
    },
    "return": "boolean",
    "signature": "public boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType)",
    "source_code": "\t\tpublic boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType) {\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver#getSupportedMediaTypes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 380
    },
    "return": "List<MediaType>",
    "signature": "public List<MediaType> getSupportedMediaTypes()",
    "source_code": "\t\tpublic List<MediaType> getSupportedMediaTypes() {\n\t\t\treturn Collections.emptyList();\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver#read(clazz,inputMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 385
    },
    "return": "String",
    "signature": "public String read(Class<? extends String> clazz, HttpInputMessage inputMessage)",
    "source_code": "\t\tpublic String read(Class<? extends String> clazz, HttpInputMessage inputMessage) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver#write(s,contentType,outputMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "s",
      "contentType",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 390
    },
    "return": "void",
    "signature": "public void write(String s, @Nullable MediaType contentType, HttpOutputMessage outputMessage)",
    "source_code": "\t\tpublic void write(String s, @Nullable MediaType contentType, HttpOutputMessage outputMessage) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#shouldApplyTo(request,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 389
    },
    "return": "boolean",
    "signature": "protected boolean shouldApplyTo(HttpServletRequest request, @Nullable Object handler)",
    "source_code": "\tprotected boolean shouldApplyTo(HttpServletRequest request, @Nullable Object handler) {\n\t\treturn (handler instanceof ResourceHttpRequestHandler ?\n\t\t\t\thasGlobalExceptionHandlers() : super.shouldApplyTo(request, handler));\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.MVC_URI_COMPONENTS_CONTRIBUTOR_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Well-known name for the {@link CompositeUriComponentsContributor} object in the bean factory.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "signature": "public String MVC_URI_COMPONENTS_CONTRIBUTOR_BEAN_NAME",
    "source_code": "\tpublic static final String MVC_URI_COMPONENTS_CONTRIBUTOR_BEAN_NAME = \"mvcUriComponentsContributor\";",
    "type": "String"
  },
  "org.springframework.web.servlet.mvc.method.annotation.MethodArgumentBuilder": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Builder class to create URLs for method arguments.\n\t */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 865
    },
    "signature": "public class MethodArgumentBuilder",
    "source_code": "\tpublic static class MethodArgumentBuilder {\n\n\t\tprivate final Class<?> controllerType;\n\n\t\tprivate final Method method;\n\n\t\tprivate final Object[] argumentValues;\n\n\t\tprivate final UriComponentsBuilder baseUrl;\n\n\t\t/**\n\t\t * Create a new {@link MethodArgumentBuilder} instance.\n\t\t * @since 4.2\n\t\t */\n\t\tpublic MethodArgumentBuilder(Class<?> controllerType, Method method) {\n\t\t\tthis(null, controllerType, method);\n\t\t}\n\n\t\t/**\n\t\t * Create a new {@link MethodArgumentBuilder} instance.\n\t\t * @since 4.2\n\t\t */\n\t\tpublic MethodArgumentBuilder(@Nullable UriComponentsBuilder baseUrl, Class<?> controllerType, Method method) {\n\t\t\tAssert.notNull(controllerType, \"'controllerType' is required\");\n\t\t\tAssert.notNull(method, \"'method' is required\");\n\t\t\tthis.baseUrl = (baseUrl != null ? baseUrl : UriComponentsBuilder.fromPath(getPath()));\n\t\t\tthis.controllerType = controllerType;\n\t\t\tthis.method = method;\n\t\t\tthis.argumentValues = new Object[method.getParameterCount()];\n\t\t}\n\n\t\tprivate static String getPath() {\n\t\t\tUriComponentsBuilder builder = ServletUriComponentsBuilder.fromCurrentServletMapping();\n\t\t\tString path = builder.build().getPath();\n\t\t\treturn (path != null ? path : \"\");\n\t\t}\n\n\t\tpublic MethodArgumentBuilder arg(int index, Object value) {\n\t\t\tthis.argumentValues[index] = value;\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Use this method only if you need to apply strong encoding to expanded\n\t\t * URI variables by quoting all characters with reserved meaning.\n\t\t * @since 5.0.8\n\t\t */\n\t\tpublic MethodArgumentBuilder encode() {\n\t\t\tthis.baseUrl.encode();\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic String build() {\n\t\t\treturn fromMethodInternal(this.baseUrl, this.controllerType, this.method, this.argumentValues)\n\t\t\t\t\t.build().encode().toUriString();\n\t\t}\n\n\t\tpublic String buildAndExpand(Object... uriVars) {\n\t\t\treturn fromMethodInternal(this.baseUrl, this.controllerType, this.method, this.argumentValues)\n\t\t\t\t\t.buildAndExpand(uriVars).encode().toString();\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.MethodInvocationInfo": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Method invocation information.\n\t */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 699
    },
    "signature": "public interface MethodInvocationInfo",
    "source_code": "\tpublic interface MethodInvocationInfo {\n\n\t\t/**\n\t\t * Return the controller types.\n\t\t */\n\t\tClass<?> getControllerType();\n\n\t\t/**\n\t\t * Return the controller method.\n\t\t */\n\t\tMethod getControllerMethod();\n\n\t\t/**\n\t\t * Return the argument values.\n\t\t */\n\t\tObject[] getArgumentValues();\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Creates instances of {@link org.springframework.web.util.UriComponentsBuilder}\n * by pointing to {@code @RequestMapping} methods on Spring MVC controllers.\n *\n * <p>There are several groups of methods:\n * <ul>\n * <li>Static {@code fromXxx(...)} methods to prepare links using information\n * from the current request as determined by a call to\n * {@link org.springframework.web.servlet.support.ServletUriComponentsBuilder#fromCurrentServletMapping()}.\n * <li>Static {@code fromXxx(UriComponentsBuilder,...)} methods can be given\n * a baseUrl when operating outside the context of a request.\n * <li>Instance-based {@code withXxx(...)} methods where an instance of\n * MvcUriComponentsBuilder is created with a baseUrl via\n * {@link #relativeTo(org.springframework.web.util.UriComponentsBuilder)}.\n * </ul>\n *\n * <p><strong>Note:</strong> This class uses values from \"Forwarded\"\n * (<a href=\"https://tools.ietf.org/html/rfc7239\">RFC 7239</a>),\n * \"X-Forwarded-Host\", \"X-Forwarded-Port\", and \"X-Forwarded-Proto\" headers,\n * if present, in order to reflect the client-originated protocol and address.\n * Consider using the {@code ForwardedHeaderFilter} in order to choose from a\n * central place whether to extract and use, or to discard such headers.\n * See the Spring Framework reference for more on this filter.\n *\n * @author Oliver Gierke\n * @author Rossen Stoyanchev\n * @author Sam Brannen\n * @author Juergen Hoeller\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "signature": "public class MvcUriComponentsBuilder",
    "source_code": "public class MvcUriComponentsBuilder {\n\n\t/**\n\t * Well-known name for the {@link CompositeUriComponentsContributor} object in the bean factory.\n\t */\n\tpublic static final String MVC_URI_COMPONENTS_CONTRIBUTOR_BEAN_NAME = \"mvcUriComponentsContributor\";\n\n\n\tprivate static final Log logger = LogFactory.getLog(MvcUriComponentsBuilder.class);\n\n\tprivate static final SpringObjenesis objenesis = new SpringObjenesis();\n\n\tprivate static final PathMatcher pathMatcher = new AntPathMatcher();\n\n\tprivate static final ParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer();\n\n\tprivate static final CompositeUriComponentsContributor defaultUriComponentsContributor;\n\n\tstatic {\n\t\tdefaultUriComponentsContributor = new CompositeUriComponentsContributor(\n\t\t\t\tnew PathVariableMethodArgumentResolver(), new RequestParamMethodArgumentResolver(false));\n\t}\n\n\tprivate final UriComponentsBuilder baseUrl;\n\n\n\t/**\n\t * Default constructor. Protected to prevent direct instantiation.\n\t * @see #fromController(Class)\n\t * @see #fromMethodName(Class, String, Object...)\n\t * @see #fromMethodCall(Object)\n\t * @see #fromMappingName(String)\n\t * @see #fromMethod(Class, Method, Object...)\n\t */\n\tprotected MvcUriComponentsBuilder(UriComponentsBuilder baseUrl) {\n\t\tAssert.notNull(baseUrl, \"'baseUrl' is required\");\n\t\tthis.baseUrl = baseUrl;\n\t}\n\n\n\t/**\n\t * Create an instance of this class with a base URL. After that calls to one\n\t * of the instance based {@code withXxx(...}} methods will create URLs relative"
  },
  "org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder#arg(index,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 902
    },
    "return": "MethodArgumentBuilder",
    "signature": "public MethodArgumentBuilder arg(int index, Object value)",
    "source_code": "\t\tpublic MethodArgumentBuilder arg(int index, Object value) {\n\t\t\tthis.argumentValues[index] = value;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder#build()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 917
    },
    "return": "String",
    "signature": "public String build()",
    "source_code": "\t\tpublic String build() {\n\t\t\treturn fromMethodInternal(this.baseUrl, this.controllerType, this.method, this.argumentValues)\n\t\t\t\t\t.build().encode().toUriString();\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder#buildAndExpand(uriVars)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriVars"
    ],
    "position": {
      "column": 1,
      "line": 922
    },
    "return": "String",
    "signature": "public String buildAndExpand(Object... uriVars)",
    "source_code": "\t\tpublic String buildAndExpand(Object... uriVars) {\n\t\t\treturn fromMethodInternal(this.baseUrl, this.controllerType, this.method, this.argumentValues)\n\t\t\t\t\t.buildAndExpand(uriVars).encode().toString();\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder#controller(controllerType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a \"mock\" controller instance. When an {@code @RequestMapping} method\n\t * on the controller is invoked, the supplied argument values are remembered\n\t * and the result can then be used to create {@code UriComponentsBuilder} via\n\t * {@link #fromMethodCall(Object)}.\n\t * <p>This is a longer version of {@link #on(Class)}. It is needed with controller\n\t * methods returning void as well for repeated invocations.\n\t * <pre class=\"code\">\n\t * FooController fooController = controller(FooController.class);\n\t *\n\t * fooController.saveFoo(1, null);\n\t * builder = MvcUriComponentsBuilder.fromMethodCall(fooController);\n\t *\n\t * fooController.saveFoo(2, null);\n\t * builder = MvcUriComponentsBuilder.fromMethodCall(fooController);\n\t * </pre>\n\t * <p><strong>Note:</strong> This method extracts values from \"Forwarded\"\n\t * and \"X-Forwarded-*\" headers if found. See class-level docs.\n\t * @param controllerType the target controller\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "controllerType"
    ],
    "position": {
      "column": 1,
      "line": 386
    },
    "return": "T",
    "signature": "public T controller(Class<T> controllerType)",
    "source_code": "\tpublic static <T> T controller(Class<T> controllerType) {\n\t\tAssert.notNull(controllerType, \"'controllerType' must not be null\");\n\t\treturn ControllerMethodInvocationInterceptor.initProxy(controllerType, null);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder#encode()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Use this method only if you need to apply strong encoding to expanded\n\t\t * URI variables by quoting all characters with reserved meaning.\n\t\t * @since 5.0.8\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 912
    },
    "return": "MethodArgumentBuilder",
    "signature": "public MethodArgumentBuilder encode()",
    "source_code": "\t\tpublic MethodArgumentBuilder encode() {\n\t\t\tthis.baseUrl.encode();\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder#fromController(builder,controllerType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An alternative to {@link #fromController(Class)} that accepts a\n\t * {@code UriComponentsBuilder} representing the base URL. This is useful\n\t * when using MvcUriComponentsBuilder outside the context of processing a\n\t * request or to apply a custom baseUrl not matching the current request.\n\t * <p><strong>Note:</strong> This method extracts values from \"Forwarded\"\n\t * and \"X-Forwarded-*\" headers if found. See class-level docs.\n\t * @param builder the builder for the base URL; the builder will be cloned\n\t * and therefore not modified and may be re-used for further calls.\n\t * @param controllerType the controller to build a URI for\n\t * @return a UriComponentsBuilder instance (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "builder",
      "controllerType"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder fromController(@Nullable UriComponentsBuilder builder,\n\t\t\tClass<?> controllerType)",
    "source_code": "\tpublic static UriComponentsBuilder fromController(@Nullable UriComponentsBuilder builder,"
  },
  "org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder#fromController(controllerType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link UriComponentsBuilder} from the mapping of a controller class\n\t * and current request information including Servlet mapping. If the controller\n\t * contains multiple mappings, only the first one is used.\n\t * <p><strong>Note:</strong> This method extracts values from \"Forwarded\"\n\t * and \"X-Forwarded-*\" headers if found. See class-level docs.\n\t * @param controllerType the controller to build a URI for\n\t * @return a UriComponentsBuilder instance (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "controllerType"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder fromController(Class<?> controllerType)",
    "source_code": "\tpublic static UriComponentsBuilder fromController(Class<?> controllerType) {\n\t\treturn fromController(null, controllerType);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder#fromMappingName(builder,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An alternative to {@link #fromMappingName(String)} that accepts a\n\t * {@code UriComponentsBuilder} representing the base URL. This is useful\n\t * when using MvcUriComponentsBuilder outside the context of processing a\n\t * request or to apply a custom baseUrl not matching the current request.\n\t * <p><strong>Note:</strong> This method extracts values from \"Forwarded\"\n\t * and \"X-Forwarded-*\" headers if found. See class-level docs.\n\t * @param builder the builder for the base URL; the builder will be cloned\n\t * and therefore not modified and may be re-used for further calls.\n\t * @param name the mapping name\n\t * @return a builder to prepare the URI String\n\t * @throws IllegalArgumentException if the mapping name is not found or\n\t * if there is no unique match\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "builder",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 454
    },
    "return": "MethodArgumentBuilder",
    "signature": "public MethodArgumentBuilder fromMappingName(@Nullable UriComponentsBuilder builder, String name)",
    "source_code": "\tpublic static MethodArgumentBuilder fromMappingName(@Nullable UriComponentsBuilder builder, String name) {\n\t\tWebApplicationContext wac = getWebApplicationContext();\n\t\tAssert.state(wac != null, \"No WebApplicationContext\");\n\t\tMap<String, RequestMappingInfoHandlerMapping> map = wac.getBeansOfType(RequestMappingInfoHandlerMapping.class);\n\t\tList<HandlerMethod> handlerMethods = null;\n\t\tfor (RequestMappingInfoHandlerMapping mapping : map.values()) {\n\t\t\thandlerMethods = mapping.getHandlerMethodsForMappingName(name);\n\t\t\tif (handlerMethods != null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (handlerMethods == null) {\n\t\t\tthrow new IllegalArgumentException(\"Mapping not found: \" + name);\n\t\t}\n\t\telse if (handlerMethods.size() != 1) {\n\t\t\tthrow new IllegalArgumentException(\"No unique match for mapping \" + name + \": \" + handlerMethods);\n\t\t}\n\t\telse {\n\t\t\tHandlerMethod handlerMethod = handlerMethods.get(0);\n\t\t\tClass<?> controllerType = handlerMethod.getBeanType();\n\t\t\tMethod method = handlerMethod.getMethod();\n\t\t\treturn new MethodArgumentBuilder(builder, controllerType, method);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder#fromMappingName(mappingName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a URL from the name of a Spring MVC controller method's request mapping.\n\t * <p>The configured\n\t * {@link org.springframework.web.servlet.handler.HandlerMethodMappingNamingStrategy\n\t * HandlerMethodMappingNamingStrategy} determines the names of controller\n\t * method request mappings at startup. By default, all mappings are assigned\n\t * a name based on the capital letters of the class name, followed by \"#\" as\n\t * separator, and then the method name. For example \"PC#getPerson\"\n\t * for a class named PersonController with method getPerson. In case the\n\t * naming convention does not produce unique results, an explicit name may\n\t * be assigned through the name attribute of the {@code @RequestMapping}\n\t * annotation.\n\t * <p>This is aimed primarily for use in view rendering technologies and EL\n\t * expressions. The Spring URL tag library registers this method as a function\n\t * called \"mvcUrl\".\n\t * <p>For example, given this controller:\n\t * <pre class=\"code\">\n\t * &#064;RequestMapping(\"/people\")\n\t * class PersonController {\n\t *\n\t *   &#064;RequestMapping(\"/{id}\")\n\t *   public HttpEntity&lt;Void&gt; getPerson(&#064;PathVariable String id) { ... }\n\t *\n\t * }\n\t * </pre>\n\t *\n\t * A JSP can prepare a URL to the controller method as follows:\n\t *\n\t * <pre class=\"code\">\n\t * &lt;%@ taglib uri=\"http://www.springframework.org/tags\" prefix=\"s\" %&gt;\n\t *\n\t * &lt;a href=\"${s:mvcUrl('PC#getPerson').arg(0,\"123\").build()}\"&gt;Get Person&lt;/a&gt;\n\t * </pre>\n\t * <p>Note that it's not necessary to specify all arguments. Only the ones\n\t * required to prepare the URL, mainly {@code @RequestParam} and {@code @PathVariable}).\n\t *\n\t * <p><strong>Note:</strong> This method extracts values from \"Forwarded\"\n\t * and \"X-Forwarded-*\" headers if found. See class-level docs.\n\t * @param mappingName the mapping name\n\t * @return a builder to prepare the URI String\n\t * @throws IllegalArgumentException if the mapping name is not found or\n\t * if there is no unique match\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappingName"
    ],
    "position": {
      "column": 1,
      "line": 435
    },
    "return": "MethodArgumentBuilder",
    "signature": "public MethodArgumentBuilder fromMappingName(String mappingName)",
    "source_code": "\tpublic static MethodArgumentBuilder fromMappingName(String mappingName) {\n\t\treturn fromMappingName(null, mappingName);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder#fromMethod(baseUrl,controllerType,method,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An alternative to {@link #fromMethod(Class, Method, Object...)}\n\t * that accepts a {@code UriComponentsBuilder} representing the base URL.\n\t * This is useful when using MvcUriComponentsBuilder outside the context of\n\t * processing a request or to apply a custom baseUrl not matching the\n\t * current request.\n\t * <p><strong>Note:</strong> This method extracts values from \"Forwarded\"\n\t * and \"X-Forwarded-*\" headers if found. See class-level docs.\n\t * @param baseUrl the builder for the base URL; the builder will be cloned\n\t * and therefore not modified and may be re-used for further calls.\n\t * @param controllerType the controller type\n\t * @param method the controller method\n\t * @param args argument values for the controller method\n\t * @return a UriComponentsBuilder instance (never {@code null})\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "baseUrl",
      "controllerType",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder fromMethod(UriComponentsBuilder baseUrl,\n\t\t\t@Nullable Class<?> controllerType, Method method, Object... args)",
    "source_code": "\tpublic static UriComponentsBuilder fromMethod(UriComponentsBuilder baseUrl,"
  },
  "org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder#fromMethod(controllerType,method,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link UriComponentsBuilder} from the mapping of a controller method\n\t * and an array of method argument values. The array of values  must match the\n\t * signature of the controller method. Values for {@code @RequestParam} and\n\t * {@code @PathVariable} are used for building the URI (via implementations of\n\t * {@link org.springframework.web.method.support.UriComponentsContributor\n\t * UriComponentsContributor}) while remaining argument values are ignored and\n\t * can be {@code null}.\n\t * <p><strong>Note:</strong> This method extracts values from \"Forwarded\"\n\t * and \"X-Forwarded-*\" headers if found. See class-level docs.\n\t * @param controllerType the controller type\n\t * @param method the controller method\n\t * @param args argument values for the controller method\n\t * @return a UriComponentsBuilder instance, never {@code null}\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "controllerType",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder fromMethod(Class<?> controllerType, Method method, Object... args)",
    "source_code": "\tpublic static UriComponentsBuilder fromMethod(Class<?> controllerType, Method method, Object... args) {\n\t\treturn fromMethodInternal(null, controllerType, method, args);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder#fromMethodCall(builder,info)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An alternative to {@link #fromMethodCall(Object)} that accepts a\n\t * {@code UriComponentsBuilder} representing the base URL. This is useful\n\t * when using MvcUriComponentsBuilder outside the context of processing a\n\t * request or to apply a custom baseUrl not matching the current request.\n\t * <p><strong>Note:</strong> This method extracts values from \"Forwarded\"\n\t * and \"X-Forwarded-*\" headers if found. See class-level docs.\n\t * @param builder the builder for the base URL; the builder will be cloned\n\t * and therefore not modified and may be re-used for further calls.\n\t * @param info either the value returned from a \"mock\" controller\n\t * invocation or the \"mock\" controller itself after an invocation\n\t * @return a UriComponents instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "builder",
      "info"
    ],
    "position": {
      "column": 1,
      "line": 339
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder fromMethodCall(UriComponentsBuilder builder, Object info)",
    "source_code": "\tpublic static UriComponentsBuilder fromMethodCall(UriComponentsBuilder builder, Object info) {\n\t\tAssert.isInstanceOf(MethodInvocationInfo.class, info, \"MethodInvocationInfo required\");\n\t\tMethodInvocationInfo invocationInfo = (MethodInvocationInfo) info;\n\t\tClass<?> controllerType = invocationInfo.getControllerType();\n\t\tMethod method = invocationInfo.getControllerMethod();\n\t\tObject[] arguments = invocationInfo.getArgumentValues();\n\t\treturn fromMethodInternal(builder, controllerType, method, arguments);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder#fromMethodCall(info)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link UriComponentsBuilder} by invoking a \"mock\" controller method.\n\t * The controller method and the supplied argument values are then used to\n\t * delegate to {@link #fromMethod(Class, Method, Object...)}.\n\t * <p>For example, given this controller:\n\t * <pre class=\"code\">\n\t * &#064;RequestMapping(\"/people/{id}/addresses\")\n\t * class AddressController {\n\t *\n\t *   &#064;GetMapping(\"/{country}\")\n\t *   public HttpEntity&lt;Void&gt; getAddressesForCountry(&#064;PathVariable String country) { ... }\n\t *\n\t *   &#064;PostMapping\n\t *   public void addAddress(Address address) { ... }\n\t * }\n\t * </pre>\n\t * A UriComponentsBuilder can be created:\n\t * <pre class=\"code\">\n\t * // Inline style with static import of \"MvcUriComponentsBuilder.on\"\n\t *\n\t * MvcUriComponentsBuilder.fromMethodCall(\n\t * \t\ton(AddressController.class).getAddressesForCountry(\"US\")).buildAndExpand(1);\n\t *\n\t * // Longer form useful for repeated invocation (and void controller methods)\n\t *\n\t * AddressController controller = MvcUriComponentsBuilder.on(AddressController.class);\n\t * controller.addAddress(null);\n\t * builder = MvcUriComponentsBuilder.fromMethodCall(controller);\n\t * controller.getAddressesForCountry(\"US\")\n\t * builder = MvcUriComponentsBuilder.fromMethodCall(controller);\n\t * </pre>\n\t * <p><strong>Note:</strong> This method extracts values from \"Forwarded\"\n\t * and \"X-Forwarded-*\" headers if found. See class-level docs.\n\t * @param info either the value returned from a \"mock\" controller\n\t * invocation or the \"mock\" controller itself after an invocation\n\t * @return a UriComponents instance\n\t * @see #on(Class)\n\t * @see #controller(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "info"
    ],
    "position": {
      "column": 1,
      "line": 317
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder fromMethodCall(Object info)",
    "source_code": "\tpublic static UriComponentsBuilder fromMethodCall(Object info) {\n\t\tAssert.isInstanceOf(MethodInvocationInfo.class, info, \"MethodInvocationInfo required\");\n\t\tMethodInvocationInfo invocationInfo = (MethodInvocationInfo) info;\n\t\tClass<?> controllerType = invocationInfo.getControllerType();\n\t\tMethod method = invocationInfo.getControllerMethod();\n\t\tObject[] arguments = invocationInfo.getArgumentValues();\n\t\treturn fromMethodInternal(null, controllerType, method, arguments);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder#fromMethodName(builder,controllerType,methodName,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An alternative to {@link #fromMethodName(Class, String, Object...)} that\n\t * accepts a {@code UriComponentsBuilder} representing the base URL. This is\n\t * useful when using MvcUriComponentsBuilder outside the context of processing\n\t * a request or to apply a custom baseUrl not matching the current request.\n\t * <p><strong>Note:</strong> This method extracts values from \"Forwarded\"\n\t * and \"X-Forwarded-*\" headers if found. See class-level docs.\n\t * @param builder the builder for the base URL; the builder will be cloned\n\t * and therefore not modified and may be re-used for further calls.\n\t * @param controllerType the controller\n\t * @param methodName the method name\n\t * @param args the argument values\n\t * @return a UriComponentsBuilder instance, never {@code null}\n\t * @throws IllegalArgumentException if there is no matching or\n\t * if there is more than one matching method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "builder",
      "controllerType",
      "methodName",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder fromMethodName(UriComponentsBuilder builder,\n\t\t\tClass<?> controllerType, String methodName, Object... args)",
    "source_code": "\tpublic static UriComponentsBuilder fromMethodName(UriComponentsBuilder builder,"
  },
  "org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder#fromMethodName(controllerType,methodName,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link UriComponentsBuilder} from the mapping of a controller\n\t * method and an array of method argument values. This method delegates\n\t * to {@link #fromMethod(Class, Method, Object...)}.\n\t * <p><strong>Note:</strong> This method extracts values from \"Forwarded\"\n\t * and \"X-Forwarded-*\" headers if found. See class-level docs.\n\t * @param controllerType the controller\n\t * @param methodName the method name\n\t * @param args the argument values\n\t * @return a UriComponentsBuilder instance, never {@code null}\n\t * @throws IllegalArgumentException if there is no matching or\n\t * if there is more than one matching method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "controllerType",
      "methodName",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder fromMethodName(Class<?> controllerType,\n\t\t\tString methodName, Object... args)",
    "source_code": "\tpublic static UriComponentsBuilder fromMethodName(Class<?> controllerType,"
  },
  "org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder#getArgumentValues()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 784
    },
    "return": "Object[]",
    "signature": "public Object[] getArgumentValues()",
    "source_code": "\t\tpublic Object[] getArgumentValues() {\n\t\t\tAssert.state(this.argumentValues != null, \"Not initialized yet\");\n\t\t\treturn this.argumentValues;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder#getControllerMethod()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 778
    },
    "return": "Method",
    "signature": "public Method getControllerMethod()",
    "source_code": "\t\tpublic Method getControllerMethod() {\n\t\t\tAssert.state(this.controllerMethod != null, \"Not initialized yet\");\n\t\t\treturn this.controllerMethod;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder#intercept(obj,method,args,proxy)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj",
      "method",
      "args",
      "proxy"
    ],
    "position": {
      "column": 1,
      "line": 735
    },
    "return": "Object",
    "signature": "public Object intercept(@Nullable Object obj, Method method, Object[] args, @Nullable MethodProxy proxy)",
    "source_code": "\t\tpublic Object intercept(@Nullable Object obj, Method method, Object[] args, @Nullable MethodProxy proxy) {\n\t\t\tswitch (method.getName()) {\n\t\t\t\tcase \"getControllerType\" -> {\n\t\t\t\t\treturn this.controllerType;\n\t\t\t\t}\n\t\t\t\tcase \"getControllerMethod\" -> {\n\t\t\t\t\treturn this.controllerMethod;\n\t\t\t\t}\n\t\t\t\tcase \"getArgumentValues\" -> {\n\t\t\t\t\treturn this.argumentValues;\n\t\t\t\t}\n\t\t\t\tdefault -> {\n\t\t\t\t\tif (ReflectionUtils.isObjectMethod(method)) {\n\t\t\t\t\t\treturn ReflectionUtils.invokeMethod(method, obj, args);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.controllerMethod = method;\n\t\t\t\t\t\tthis.argumentValues = args;\n\t\t\t\t\t\tClass<?> returnType = method.getReturnType();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treturn (returnType == void.class ? null : returnType.cast(initProxy(returnType, this)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\t\t\"Failed to create proxy for controller method return type: \" + method, ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder#invoke(proxy,method,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 768
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, @Nullable Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, @Nullable Object[] args) {\n\t\t\treturn intercept(proxy, method, (args != null ? args : new Object[0]), null);\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder#on(controllerType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a \"mock\" controller instance. When an {@code @RequestMapping} method\n\t * on the controller is invoked, the supplied argument values are remembered\n\t * and the result can then be used to create a {@code UriComponentsBuilder}\n\t * via {@link #fromMethodCall(Object)}.\n\t * <p>Note that this is a shorthand version of {@link #controller(Class)} intended\n\t * for inline use (with a static import), for example:\n\t * <pre class=\"code\">\n\t * MvcUriComponentsBuilder.fromMethodCall(on(FooController.class).getFoo(1)).build();\n\t * </pre>\n\t * <p><strong>Note:</strong> This method extracts values from \"Forwarded\"\n\t * and \"X-Forwarded-*\" headers if found. See class-level docs.\n\t * @param controllerType the target controller\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "controllerType"
    ],
    "position": {
      "column": 1,
      "line": 362
    },
    "return": "T",
    "signature": "public T on(Class<T> controllerType)",
    "source_code": "\tpublic static <T> T on(Class<T> controllerType) {\n\t\treturn controller(controllerType);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder#relativeTo(baseUrl)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an instance of this class with a base URL. After that calls to one\n\t * of the instance based {@code withXxx(...}} methods will create URLs relative\n\t * to the given base URL.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "baseUrl"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "MvcUriComponentsBuilder",
    "signature": "public MvcUriComponentsBuilder relativeTo(UriComponentsBuilder baseUrl)",
    "source_code": "\tpublic static MvcUriComponentsBuilder relativeTo(UriComponentsBuilder baseUrl) {\n\t\treturn new MvcUriComponentsBuilder(baseUrl);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder#withController(controllerType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An alternative to {@link #fromController(Class)} for use with an instance\n\t * of this class created via a call to {@link #relativeTo}.\n\t * <p><strong>Note:</strong> This method extracts values from \"Forwarded\"\n\t * and \"X-Forwarded-*\" headers if found. See class-level docs.\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "controllerType"
    ],
    "position": {
      "column": 1,
      "line": 489
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder withController(Class<?> controllerType)",
    "source_code": "\tpublic UriComponentsBuilder withController(Class<?> controllerType) {\n\t\treturn fromController(this.baseUrl, controllerType);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder#withMappingName(mappingName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An alternative to {@link #fromMappingName(String)} for use with an instance\n\t * of this class created via {@link #relativeTo}.\n\t * <p><strong>Note:</strong> This method extracts values from \"Forwarded\"\n\t * and \"X-Forwarded-*\" headers if found. See class-level docs.\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappingName"
    ],
    "position": {
      "column": 1,
      "line": 522
    },
    "return": "MethodArgumentBuilder",
    "signature": "public MethodArgumentBuilder withMappingName(String mappingName)",
    "source_code": "\tpublic MethodArgumentBuilder withMappingName(String mappingName) {\n\t\treturn fromMappingName(this.baseUrl, mappingName);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder#withMethod(controllerType,method,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An alternative to {@link #fromMethod(Class, Method, Object...)}\n\t * for use with an instance of this class created via {@link #relativeTo}.\n\t * <p><strong>Note:</strong> This method extracts values from \"Forwarded\"\n\t * and \"X-Forwarded-*\" headers if found. See class-level docs.\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "controllerType",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 533
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder withMethod(Class<?> controllerType, Method method, Object... args)",
    "source_code": "\tpublic UriComponentsBuilder withMethod(Class<?> controllerType, Method method, Object... args) {\n\t\treturn fromMethod(this.baseUrl, controllerType, method, args);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder#withMethodCall(invocationInfo)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An alternative to {@link #fromMethodCall(Object)} for use with an instance\n\t * of this class created via {@link #relativeTo}.\n\t * <p><strong>Note:</strong> This method extracts values from \"Forwarded\"\n\t * and \"X-Forwarded-*\" headers if found. See class-level docs.\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "invocationInfo"
    ],
    "position": {
      "column": 1,
      "line": 511
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder withMethodCall(Object invocationInfo)",
    "source_code": "\tpublic UriComponentsBuilder withMethodCall(Object invocationInfo) {\n\t\treturn fromMethodCall(this.baseUrl, invocationInfo);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder#withMethodName(controllerType,methodName,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An alternative to {@link #fromMethodName(Class, String, Object...)}} for\n\t * use with an instance of this class created via {@link #relativeTo}.\n\t * <p><strong>Note:</strong> This method extracts values from \"Forwarded\"\n\t * and \"X-Forwarded-*\" headers if found. See class-level docs.\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "controllerType",
      "methodName",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 500
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder withMethodName(Class<?> controllerType, String methodName, Object... args)",
    "source_code": "\tpublic UriComponentsBuilder withMethodName(Class<?> controllerType, String methodName, Object... args) {\n\t\treturn fromMethodName(this.baseUrl, controllerType, methodName, args);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#execute(task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 1066
    },
    "return": "void",
    "signature": "public void execute(Runnable task)",
    "source_code": "\t\tpublic void execute(Runnable task) {\n\t\t\tif (taskExecutorWarning && logger.isWarnEnabled()) {\n\t\t\t\tsynchronized (this) {\n\t\t\t\t\tif (taskExecutorWarning) {\n\t\t\t\t\t\tlogger.warn(\"\"\"\n\t\t\t\t\t\t\t\t!!!\n\t\t\t\t\t\t\t\tPerforming asynchronous handling through the default Spring MVC SimpleAsyncTaskExecutor.\n\t\t\t\t\t\t\t\tThis executor is not suitable for production use under load.\n\t\t\t\t\t\t\t\tPlease, configure an AsyncTaskExecutor through the WebMvc config.\n\t\t\t\t\t\t\t\t-------------------------------\n\t\t\t\t\t\t\t\t!!!\"\"\");\n\t\t\t\t\t\ttaskExecutorWarning = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsuper.execute(task);\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#createRequestMappingInfo(httpExchange,customCondition)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link RequestMappingInfo} from the supplied\n\t * {@link HttpExchange @HttpExchange} annotation, meta-annotation,\n\t * or synthesized result of merging annotation attributes within an\n\t * annotation hierarchy.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "httpExchange",
      "customCondition"
    ],
    "position": {
      "column": 1,
      "line": 445
    },
    "return": "RequestMappingInfo",
    "signature": "protected RequestMappingInfo createRequestMappingInfo(HttpExchange httpExchange, @Nullable RequestCondition<?> customCondition)",
    "source_code": "\tprotected RequestMappingInfo createRequestMappingInfo("
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 642
    },
    "return": "boolean",
    "signature": "public boolean equals(Object obj)",
    "source_code": "\t\tpublic boolean equals(Object obj) {\n\t\t\treturn (obj instanceof AnnotationDescriptor that && this.annotation.equals(that.annotation));\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 647
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\t\tpublic int hashCode() {\n\t\t\treturn this.annotation.hashCode();\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 652
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn this.root.synthesize().toString();\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler#handleHandlerMethodValidationException(ex,headers,status,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link HandlerMethodValidationException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to be written to the response\n\t * @param status the selected response status\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 365
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleHandlerMethodValidationException(HandlerMethodValidationException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleHandlerMethodValidationException("
  },
  "org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler#handleMaxUploadSizeExceededException(ex,headers,status,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of any {@link MaxUploadSizeExceededException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 455
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleMaxUploadSizeExceededException(MaxUploadSizeExceededException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleMaxUploadSizeExceededException("
  },
  "org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler#handleMethodValidationException(ex,headers,status,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link MethodValidationException}.\n\t * <p>By default this method creates a {@link ProblemDetail} with the status\n\t * and a short detail message, and also looks up an override for the detail\n\t * via {@link MessageSource}, before delegating to\n\t * {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 591
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleMethodValidationException(MethodValidationException ex, HttpHeaders headers, HttpStatus status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleMethodValidationException("
  },
  "org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler#handleNoResourceFoundException(ex,headers,status,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link NoResourceFoundException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 401
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleNoResourceFoundException(NoResourceFoundException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleNoResourceFoundException("
  },
  "org.springframework.web.servlet.mvc.method.annotation.SseEmitter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A specialization of {@link ResponseBodyEmitter} for sending\n * <a href=\"https://www.w3.org/TR/eventsource/\">Server-Sent Events</a>.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Brian Clozel\n * @since 4.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "signature": "public class SseEmitter",
    "source_code": "public class SseEmitter extends ResponseBodyEmitter {\n\n\tprivate static final MediaType TEXT_PLAIN = new MediaType(\"text\", \"plain\", StandardCharsets.UTF_8);\n\n\t/**\n\t * Guards access to write operations on the response.\n\t */\n\tprivate final Lock writeLock = new ReentrantLock();\n\n\t/**\n\t * Create a new SseEmitter instance.\n\t */\n\tpublic SseEmitter() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * Create a SseEmitter with a custom timeout value.\n\t * <p>By default not set in which case the default configured in the MVC\n\t * Java Config or the MVC namespace is used, or if that's not set, then the\n\t * timeout depends on the default of the underlying server.\n\t * @param timeout the timeout value in milliseconds\n\t * @since 4.2.2\n\t */\n\tpublic SseEmitter(Long timeout) {\n\t\tsuper(timeout);\n\t}\n\n\n\t@Override\n\tprotected void extendResponse(ServerHttpResponse outputMessage) {\n\t\tsuper.extendResponse(outputMessage);\n\n\t\tHttpHeaders headers = outputMessage.getHeaders();\n\t\tif (headers.getContentType() == null) {\n\t\t\theaders.setContentType(MediaType.TEXT_EVENT_STREAM);\n\t\t}\n\t}\n\n\t/**\n\t * Send the object formatted as a single SSE \"data\" line. It's equivalent to:\n\t * <pre>\n\t * // static import of SseEmitter.*\n\t *\n\t * SseEmitter emitter = new SseEmitter();\n\t * emitter.send(event().data(myObject));\n\t * </pre>\n\t * <p>Please, see {@link ResponseBodyEmitter#send(Object) parent Javadoc}\n\t * for important notes on exception handling.\n\t * @param object the object to write\n\t * @throws IOException raised when an I/O error occurs\n\t * @throws java.lang.IllegalStateException wraps any other errors\n\t */\n\t@Override\n\tpublic void send(Object object) throws IOException {\n\t\tsend(object, null);\n\t}\n\n\t/**\n\t * Send the object formatted as a single SSE \"data\" line. It's equivalent to:\n\t * <pre>\n\t * // static import of SseEmitter.*\n\t *\n\t * SseEmitter emitter = new SseEmitter();\n\t * emitter.send(event().data(myObject, MediaType.APPLICATION_JSON));\n\t * </pre>\n\t * <p>Please, see {@link ResponseBodyEmitter#send(Object) parent Javadoc}\n\t * for important notes on exception handling.\n\t * @param object the object to write\n\t * @param mediaType a MediaType hint for selecting an HttpMessageConverter\n\t * @throws IOException raised when an I/O error occurs\n\t */\n\t@Override\n\tpublic void send(Object object, @Nullable MediaType mediaType) throws IOException {\n\t\tsend(event().data(object, mediaType));\n\t}\n\n\t/**\n\t * Send an SSE event prepared with the given builder. For example:\n\t * <pre>\n\t * // static import of SseEmitter\n\t * SseEmitter emitter = new SseEmitter();\n\t * emitter.send(event().name(\"update\").id(\"1\").data(myObject));\n\t * </pre>\n\t * @param builder a builder for an SSE formatted event.\n\t * @throws IOException raised when an I/O error occurs\n\t */\n\tpublic void send(SseEventBuilder builder) throws IOException {\n\t\tSet<DataWithMediaType> dataToSend = builder.build();\n\t\tthis.writeLock.lock();\n\t\ttry {\n\t\t\tsuper.send(dataToSend);\n\t\t}\n\t\tfinally {\n\t\t\tthis.writeLock.unlock();\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"SseEmitter@\" + ObjectUtils.getIdentityHexString(this);\n\t}\n\n\n\tpublic static SseEventBuilder event() {\n\t\treturn new SseEventBuilderImpl();\n\t}\n\n\n\t/**\n\t * A builder for an SSE event.\n\t */\n\tpublic interface SseEventBuilder {\n\n\t\t/**\n\t\t * Add an SSE \"id\" line.\n\t\t */\n\t\tSseEventBuilder id(String id);\n\n\t\t/**\n\t\t * Add an SSE \"event\" line.\n\t\t */\n\t\tSseEventBuilder name(String eventName);\n\n\t\t/**\n\t\t * Add an SSE \"retry\" line.\n\t\t */\n\t\tSseEventBuilder reconnectTime(long reconnectTimeMillis);\n\n\t\t/**\n\t\t * Add an SSE \"comment\" line.\n\t\t */\n\t\tSseEventBuilder comment(String comment);\n\n\t\t/**\n\t\t * Add an SSE \"data\" line.\n\t\t */\n\t\tSseEventBuilder data(Object object);\n\n\t\t/**\n\t\t * Add an SSE \"data\" line.\n\t\t */\n\t\tSseEventBuilder data(Object object, @Nullable MediaType mediaType);\n\n\t\t/**\n\t\t * Return one or more Object-MediaType pairs to write via\n\t\t * {@link #send(Object, MediaType)}.\n\t\t * @since 4.2.3\n\t\t */\n\t\tSet<DataWithMediaType> build();\n\t}\n\n\n\t/**\n\t * Default implementation of SseEventBuilder.\n\t */\n\tprivate static class SseEventBuilderImpl implements SseEventBuilder {\n\n\t\tprivate final Set<DataWithMediaType> dataToSend = new LinkedHashSet<>(4);\n\n\t\t@Nullable\n\t\tprivate StringBuilder sb;\n\n\t\t@Override\n\t\tpublic SseEventBuilder id(String id) {\n\t\t\tappend(\"id:\").append(id).append('\\n');\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic SseEventBuilder name(String name) {\n\t\t\tappend(\"event:\").append(name).append('\\n');\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic SseEventBuilder reconnectTime(long reconnectTimeMillis) {\n\t\t\tappend(\"retry:\").append(String.valueOf(reconnectTimeMillis)).append('\\n');\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic SseEventBuilder comment(String comment) {\n\t\t\tappend(':').append(comment).append('\\n');\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic SseEventBuilder data(Object object) {\n\t\t\treturn data(object, null);\n\t\t}\n\n\t\t@Override\n\t\tpublic SseEventBuilder data(Object object, @Nullable MediaType mediaType) {\n\t\t\tappend(\"data:\");\n\t\t\tsaveAppendedText();\n\t\t\tif (object instanceof String text) {\n\t\t\t\tobject = StringUtils.replace(text, \"\\n\", \"\\ndata:\");\n\t\t\t}\n\t\t\tthis.dataToSend.add(new DataWithMediaType(object, mediaType));\n\t\t\tappend('\\n');\n\t\t\treturn this;\n\t\t}\n\n\t\tSseEventBuilderImpl append(String text) {\n\t\t\tif (this.sb == null) {\n\t\t\t\tthis.sb = new StringBuilder();\n\t\t\t}\n\t\t\tthis.sb.append(text);\n\t\t\treturn this;\n\t\t}\n\n\t\tSseEventBuilderImpl append(char ch) {\n\t\t\tif (this.sb == null) {\n\t\t\t\tthis.sb = new StringBuilder();\n\t\t\t}\n\t\t\tthis.sb.append(ch);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<DataWithMediaType> build() {\n\t\t\tif (!StringUtils.hasLength(this.sb) && this.dataToSend.isEmpty()) {\n\t\t\t\treturn Collections.emptySet();\n\t\t\t}\n\t\t\tappend('\\n');\n\t\t\tsaveAppendedText();\n\t\t\treturn this.dataToSend;\n\t\t}\n\n\t\tprivate void saveAppendedText() {\n\t\t\tif (this.sb != null) {\n\t\t\t\tthis.dataToSend.add(new DataWithMediaType(this.sb.toString(), TEXT_PLAIN));\n\t\t\t\tthis.sb = null;\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.SseEmitter#build()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 265
    },
    "return": "Set<DataWithMediaType>",
    "signature": "public Set<DataWithMediaType> build()",
    "source_code": "\t\tpublic Set<DataWithMediaType> build() {\n\t\t\tif (!StringUtils.hasLength(this.sb) && this.dataToSend.isEmpty()) {\n\t\t\t\treturn Collections.emptySet();\n\t\t\t}\n\t\t\tappend('\\n');\n\t\t\tsaveAppendedText();\n\t\t\treturn this.dataToSend;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.SseEmitter#comment(comment)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "comment"
    ],
    "position": {
      "column": 1,
      "line": 226
    },
    "return": "SseEventBuilder",
    "signature": "public SseEventBuilder comment(String comment)",
    "source_code": "\t\tpublic SseEventBuilder comment(String comment) {\n\t\t\tappend(':').append(comment).append('\\n');\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.SseEmitter#data(object)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object"
    ],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "SseEventBuilder",
    "signature": "public SseEventBuilder data(Object object)",
    "source_code": "\t\tpublic SseEventBuilder data(Object object) {\n\t\t\treturn data(object, null);\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.SseEmitter#data(object,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "SseEventBuilder",
    "signature": "public SseEventBuilder data(Object object, @Nullable MediaType mediaType)",
    "source_code": "\t\tpublic SseEventBuilder data(Object object, @Nullable MediaType mediaType) {\n\t\t\tappend(\"data:\");\n\t\t\tsaveAppendedText();\n\t\t\tif (object instanceof String text) {\n\t\t\t\tobject = StringUtils.replace(text, \"\\n\", \"\\ndata:\");\n\t\t\t}\n\t\t\tthis.dataToSend.add(new DataWithMediaType(object, mediaType));\n\t\t\tappend('\\n');\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.SseEmitter#event()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "SseEventBuilder",
    "signature": "public SseEventBuilder event()",
    "source_code": "\tpublic static SseEventBuilder event() {\n\t\treturn new SseEventBuilderImpl();\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.SseEmitter#extendResponse(outputMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "protected void extendResponse(ServerHttpResponse outputMessage)",
    "source_code": "\tprotected void extendResponse(ServerHttpResponse outputMessage) {\n\t\tsuper.extendResponse(outputMessage);\n\n\t\tHttpHeaders headers = outputMessage.getHeaders();\n\t\tif (headers.getContentType() == null) {\n\t\t\theaders.setContentType(MediaType.TEXT_EVENT_STREAM);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.SseEmitter#id(id)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "id"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "SseEventBuilder",
    "signature": "public SseEventBuilder id(String id)",
    "source_code": "\t\tpublic SseEventBuilder id(String id) {\n\t\t\tappend(\"id:\").append(id).append('\\n');\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.SseEmitter#name(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "SseEventBuilder",
    "signature": "public SseEventBuilder name(String name)",
    "source_code": "\t\tpublic SseEventBuilder name(String name) {\n\t\t\tappend(\"event:\").append(name).append('\\n');\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.SseEmitter#reconnectTime(reconnectTimeMillis)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "reconnectTimeMillis"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "SseEventBuilder",
    "signature": "public SseEventBuilder reconnectTime(long reconnectTimeMillis)",
    "source_code": "\t\tpublic SseEventBuilder reconnectTime(long reconnectTimeMillis) {\n\t\t\tappend(\"retry:\").append(String.valueOf(reconnectTimeMillis)).append('\\n');\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.SseEmitter#send(builder)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Send an SSE event prepared with the given builder. For example:\n\t * <pre>\n\t * // static import of SseEmitter\n\t * SseEmitter emitter = new SseEmitter();\n\t * emitter.send(event().name(\"update\").id(\"1\").data(myObject));\n\t * </pre>\n\t * @param builder a builder for an SSE formatted event.\n\t * @throws IOException raised when an I/O error occurs\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "builder"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "void",
    "signature": "public void send(SseEventBuilder builder)",
    "source_code": "\tpublic void send(SseEventBuilder builder) throws IOException {\n\t\tSet<DataWithMediaType> dataToSend = builder.build();\n\t\tthis.writeLock.lock();\n\t\ttry {\n\t\t\tsuper.send(dataToSend);\n\t\t}\n\t\tfinally {\n\t\t\tthis.writeLock.unlock();\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.SseEmitter#send(object)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Send the object formatted as a single SSE \"data\" line. It's equivalent to:\n\t * <pre>\n\t * // static import of SseEmitter.*\n\t *\n\t * SseEmitter emitter = new SseEmitter();\n\t * emitter.send(event().data(myObject));\n\t * </pre>\n\t * <p>Please, see {@link ResponseBodyEmitter#send(Object) parent Javadoc}\n\t * for important notes on exception handling.\n\t * @param object the object to write\n\t * @throws IOException raised when an I/O error occurs\n\t * @throws java.lang.IllegalStateException wraps any other errors\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void send(Object object)",
    "source_code": "\tpublic void send(Object object) throws IOException {\n\t\tsend(object, null);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.SseEmitter#send(object,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Send the object formatted as a single SSE \"data\" line. It's equivalent to:\n\t * <pre>\n\t * // static import of SseEmitter.*\n\t *\n\t * SseEmitter emitter = new SseEmitter();\n\t * emitter.send(event().data(myObject, MediaType.APPLICATION_JSON));\n\t * </pre>\n\t * <p>Please, see {@link ResponseBodyEmitter#send(Object) parent Javadoc}\n\t * for important notes on exception handling.\n\t * @param object the object to write\n\t * @param mediaType a MediaType hint for selecting an HttpMessageConverter\n\t * @throws IOException raised when an I/O error occurs\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "void",
    "signature": "public void send(Object object, @Nullable MediaType mediaType)",
    "source_code": "\tpublic void send(Object object, @Nullable MediaType mediaType) throws IOException {\n\t\tsend(event().data(object, mediaType));\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.SseEmitter#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn \"SseEmitter@\" + ObjectUtils.getIdentityHexString(this);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.SseEventBuilder": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A builder for an SSE event.\n\t */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "signature": "public interface SseEventBuilder",
    "source_code": "\tpublic interface SseEventBuilder {\n\n\t\t/**\n\t\t * Add an SSE \"id\" line.\n\t\t */\n\t\tSseEventBuilder id(String id);\n\n\t\t/**\n\t\t * Add an SSE \"event\" line.\n\t\t */\n\t\tSseEventBuilder name(String eventName);\n\n\t\t/**\n\t\t * Add an SSE \"retry\" line.\n\t\t */\n\t\tSseEventBuilder reconnectTime(long reconnectTimeMillis);\n\n\t\t/**\n\t\t * Add an SSE \"comment\" line.\n\t\t */\n\t\tSseEventBuilder comment(String comment);\n\n\t\t/**\n\t\t * Add an SSE \"data\" line.\n\t\t */\n\t\tSseEventBuilder data(Object object);\n\n\t\t/**\n\t\t * Add an SSE \"data\" line.\n\t\t */\n\t\tSseEventBuilder data(Object object, @Nullable MediaType mediaType);\n\n\t\t/**\n\t\t * Return one or more Object-MediaType pairs to write via\n\t\t * {@link #send(Object, MediaType)}.\n\t\t * @since 4.2.3\n\t\t */\n\t\tSet<DataWithMediaType> build();\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#handleHandlerMethodValidationException(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where method validation for a controller method failed.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the exception to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 437
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleHandlerMethodValidationException(HandlerMethodValidationException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleHandlerMethodValidationException(HandlerMethodValidationException ex,"
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#handleMethodValidationException(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where method validation failed on a component that is\n\t * not a web controller, e.g. on some underlying service.\n\t * <p>The default implementation sends an HTTP 500 error, and returns an empty {@code ModelAndView}.\n\t * Alternatively, a fallback view could be chosen, or the HttpMessageNotWritableException could\n\t * be rethrown as-is.\n\t * @param ex the exception to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 662
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleMethodValidationException(MethodValidationException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleMethodValidationException(MethodValidationException ex,"
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#handleNoResourceFoundException(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where no static resource was found.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the {@link NoResourceFoundException} to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the resource handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 479
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleNoResourceFoundException(NoResourceFoundException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleNoResourceFoundException(NoResourceFoundException ex,"
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#logException(ex,request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 702
    },
    "return": "void",
    "signature": "protected void logException(Exception ex, HttpServletRequest request)",
    "source_code": "\tprotected void logException(Exception ex, HttpServletRequest request) {\n\t\tif (ex instanceof NoHandlerFoundException || ex instanceof NoResourceFoundException) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(buildLogMessage(ex, request));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tsuper.logException(ex, request);\n\t}"
  },
  "org.springframework.web.servlet.resource.ResourceHttpRequestHandler#getEtagGenerator()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the HTTP ETag generator function to be used when serving resources.\n\t * @return the HTTP ETag generator function\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 409
    },
    "return": "String>",
    "signature": "public String> getEtagGenerator()",
    "source_code": "\tpublic Function<Resource, String> getEtagGenerator() {\n\t\treturn this.etagGenerator;\n\t}"
  },
  "org.springframework.web.servlet.resource.ResourceHttpRequestHandler#setEtagGenerator(Function<Resource,etagGenerator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a generator function that will be used to create the ETag information,\n\t * given a {@link Resource} that is about to be written to the response.\n\t * <p>This function should return a String that will be used as an argument in\n\t * {@link ServletWebRequest#checkNotModified(String)}, or {@code null} if no value\n\t * can be generated for the given resource.\n\t * @param etagGenerator the HTTP ETag generator function to use.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<Resource",
      "etagGenerator"
    ],
    "position": {
      "column": 1,
      "line": 399
    },
    "return": "void",
    "signature": "public void setEtagGenerator(@Nullable Function<Resource, String> etagGenerator)",
    "source_code": "\tpublic void setEtagGenerator(@Nullable Function<Resource, String> etagGenerator) {\n\t\tthis.etagGenerator = etagGenerator;\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A {@link WebSocketSession} for use with the Jetty WebSocket API.\n *\n * @author Phillip Webb\n * @author Rossen Stoyanchev\n * @author Brian Clozel\n * @author Juergen Hoeller\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "signature": "public class JettyWebSocketSession",
    "source_code": "public class JettyWebSocketSession extends AbstractWebSocketSession<Session> {\n\n\tprivate final String id;\n\n\t@Nullable\n\tprivate URI uri;\n\n\t@Nullable\n\tprivate HttpHeaders headers;\n\n\t@Nullable\n\tprivate String acceptedProtocol;\n\n\t@Nullable\n\tprivate List<WebSocketExtension> extensions;\n\n\t@Nullable\n\tprivate Principal user;\n\n\n\t/**\n\t * Create a new {@link JettyWebSocketSession} instance.\n\t * @param attributes the attributes from the HTTP handshake to associate with the WebSocket session\n\t */\n\tpublic JettyWebSocketSession(Map<String, Object> attributes) {\n\t\tthis(attributes, null);\n\t}\n\n\t/**\n\t * Create a new {@link JettyWebSocketSession} instance associated with the given user.\n\t * @param attributes the attributes from the HTTP handshake to associate with the WebSocket\n\t * session; the provided attributes are copied, the original map is not used.\n\t * @param user the user associated with the session; if {@code null} we'll fall back on the\n\t * user available via {@link org.eclipse.jetty.websocket.api.Session#getUpgradeRequest()}\n\t */\n\tpublic JettyWebSocketSession(Map<String, Object> attributes, @Nullable Principal user) {\n\t\tsuper(attributes);\n\t\tthis.id = idGenerator.generateId().toString();\n\t\tthis.user = user;\n\t}\n\n\n\t@Override\n\tpublic String getId() {\n\t\treturn this.id;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic URI getUri() {\n\t\tcheckNativeSessionInitialized();\n\t\treturn this.uri;\n\t}\n\n\t@Override\n\tpublic HttpHeaders getHandshakeHeaders() {\n\t\tAssert.state(this.headers != null, \"WebSocket session is not yet initialized\");\n\t\treturn this.headers;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic String getAcceptedProtocol() {\n\t\tcheckNativeSessionInitialized();\n\t\treturn this.acceptedProtocol;\n\t}\n\n\t@Override\n\tpublic List<WebSocketExtension> getExtensions() {\n\t\tAssert.state(this.extensions != null, \"WebSocket session is not yet initialized\");\n\t\treturn this.extensions;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Principal getPrincipal() {\n\t\treturn this.user;\n\t}\n\n\t@Override\n\tpublic InetSocketAddress getLocalAddress() {\n\t\tcheckNativeSessionInitialized();\n\t\treturn (InetSocketAddress) getNativeSession().getLocalSocketAddress();\n\t}\n\n\t@Override\n\tpublic InetSocketAddress getRemoteAddress() {\n\t\tcheckNativeSessionInitialized();\n\t\treturn (InetSocketAddress) getNativeSession().getRemoteSocketAddress();\n\t}\n\n\t@Override\n\tpublic void setTextMessageSizeLimit(int messageSizeLimit) {\n\t\tcheckNativeSessionInitialized();\n\t\tgetNativeSession().setMaxTextMessageSize(messageSizeLimit);\n\t}\n\n\t@Override\n\tpublic int getTextMessageSizeLimit() {\n\t\tcheckNativeSessionInitialized();\n\t\treturn (int) getNativeSession().getMaxTextMessageSize();\n\t}\n\n\t@Override\n\tpublic void setBinaryMessageSizeLimit(int messageSizeLimit) {\n\t\tcheckNativeSessionInitialized();\n\t\tgetNativeSession().setMaxBinaryMessageSize(messageSizeLimit);\n\t}\n\n\t@Override\n\tpublic int getBinaryMessageSizeLimit() {\n\t\tcheckNativeSessionInitialized();\n\t\treturn (int) getNativeSession().getMaxBinaryMessageSize();\n\t}\n\n\t@Override\n\tpublic boolean isOpen() {\n\t\treturn getNativeSession().isOpen();\n\t}\n\n\n\t@Override\n\tpublic void initializeNativeSession(Session session) {\n\t\tsuper.initializeNativeSession(session);\n\n\t\tthis.uri = session.getUpgradeRequest().getRequestURI();\n\n\t\tHttpHeaders headers = new HttpHeaders();\n\t\tMap<String, List<String>> nativeHeaders = session.getUpgradeRequest().getHeaders();\n\t\tif (!CollectionUtils.isEmpty(nativeHeaders)) {\n\t\t\theaders.putAll(nativeHeaders);\n\t\t}\n\t\tthis.headers = HttpHeaders.readOnlyHttpHeaders(headers);\n\n\t\tthis.acceptedProtocol = session.getUpgradeResponse().getAcceptedSubProtocol();\n\t\tthis.extensions = getExtensions(session);\n\n\t\tif (this.user == null) {\n\t\t\ttry {\n\t\t\t\tthis.user = session.getUpgradeRequest().getUserPrincipal();\n\t\t\t}\n\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t// Necessary until https://github.com/eclipse/jetty.project/issues/10498 is resolved\n\t\t\t\tlogger.error(\"Failure from UpgradeRequest while getting Principal\", ex);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate List<WebSocketExtension> getExtensions(Session session) {\n\t\tList<ExtensionConfig> configs = session.getUpgradeResponse().getExtensions();\n\t\tif (!CollectionUtils.isEmpty(configs)) {\n\t\t\tList<WebSocketExtension> result = new ArrayList<>(configs.size());\n\t\t\tfor (ExtensionConfig config : configs) {\n\t\t\t\tresult.add(new WebSocketExtension(config.getName(), config.getParameters()));\n\t\t\t}\n\t\t\treturn Collections.unmodifiableList(result);\n\t\t}\n\t\treturn Collections.emptyList();\n\t}\n\n\n\t@Override\n\tprotected void sendTextMessage(TextMessage message) throws IOException {\n\t\tuseSession((session, callback) -> session.sendText(message.getPayload(), callback));\n\t}\n\n\t@Override\n\tprotected void sendBinaryMessage(BinaryMessage message) throws IOException {\n\t\tuseSession((session, callback) -> session.sendBinary(message.getPayload(), callback));\n\t}\n\n\t@Override\n\tprotected void sendPingMessage(PingMessage message) throws IOException {\n\t\tuseSession((session, callback) -> session.sendPing(message.getPayload(), callback));\n\t}\n\n\t@Override\n\tprotected void sendPongMessage(PongMessage message) throws IOException {\n\t\tuseSession((session, callback) -> session.sendPong(message.getPayload(), callback));\n\t}\n\n\t@Override\n\tprotected void closeInternal(CloseStatus status) throws IOException {\n\t\tuseSession((session, callback) -> session.close(status.getCode(), status.getReason(), callback));\n\t}\n\n\tprivate void useSession(SessionConsumer sessionConsumer) throws IOException {\n\t\ttry {\n\t\t\tCallback.Completable completable = new Callback.Completable();\n\t\t\tsessionConsumer.consume(getNativeSession(), completable);\n\t\t\tcompletable.get();\n\t\t}\n\t\tcatch (ExecutionException ex) {\n\t\t\tThrowable cause = ex.getCause();\n\n\t\t\tif (cause instanceof IOException ioEx) {\n\t\t\t\tthrow ioEx;\n\t\t\t}\n\t\t\telse if (cause instanceof UncheckedIOException uioEx) {\n\t\t\t\tthrow uioEx.getCause();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IOException(ex.getMessage(), cause);\n\t\t\t}\n\t\t}\n\t\tcatch (InterruptedException ex) {\n\t\t\tThread.currentThread().interrupt();\n\t\t}\n\t}\n\n\t@FunctionalInterface\n\tprivate interface SessionConsumer {\n\n\t\tvoid consume(Session session, Callback callback) throws IOException;\n\t}\n\n}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#closeInternal(status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "void",
    "signature": "protected void closeInternal(CloseStatus status)",
    "source_code": "\tprotected void closeInternal(CloseStatus status) throws IOException {\n\t\tuseSession((session, callback) -> session.close(status.getCode(), status.getReason(), callback));\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#getAcceptedProtocol()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "String",
    "signature": "public String getAcceptedProtocol()",
    "source_code": "\tpublic String getAcceptedProtocol() {\n\t\tcheckNativeSessionInitialized();\n\t\treturn this.acceptedProtocol;\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#getBinaryMessageSizeLimit()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "int",
    "signature": "public int getBinaryMessageSizeLimit()",
    "source_code": "\tpublic int getBinaryMessageSizeLimit() {\n\t\tcheckNativeSessionInitialized();\n\t\treturn (int) getNativeSession().getMaxBinaryMessageSize();\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#getExtensions()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "List<WebSocketExtension>",
    "signature": "public List<WebSocketExtension> getExtensions()",
    "source_code": "\tpublic List<WebSocketExtension> getExtensions() {\n\t\tAssert.state(this.extensions != null, \"WebSocket session is not yet initialized\");\n\t\treturn this.extensions;\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#getHandshakeHeaders()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders getHandshakeHeaders()",
    "source_code": "\tpublic HttpHeaders getHandshakeHeaders() {\n\t\tAssert.state(this.headers != null, \"WebSocket session is not yet initialized\");\n\t\treturn this.headers;\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#getId()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "String",
    "signature": "public String getId()",
    "source_code": "\tpublic String getId() {\n\t\treturn this.id;\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#getLocalAddress()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "InetSocketAddress",
    "signature": "public InetSocketAddress getLocalAddress()",
    "source_code": "\tpublic InetSocketAddress getLocalAddress() {\n\t\tcheckNativeSessionInitialized();\n\t\treturn (InetSocketAddress) getNativeSession().getLocalSocketAddress();\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#getPrincipal()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "Principal",
    "signature": "public Principal getPrincipal()",
    "source_code": "\tpublic Principal getPrincipal() {\n\t\treturn this.user;\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#getRemoteAddress()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "InetSocketAddress",
    "signature": "public InetSocketAddress getRemoteAddress()",
    "source_code": "\tpublic InetSocketAddress getRemoteAddress() {\n\t\tcheckNativeSessionInitialized();\n\t\treturn (InetSocketAddress) getNativeSession().getRemoteSocketAddress();\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#getTextMessageSizeLimit()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "int",
    "signature": "public int getTextMessageSizeLimit()",
    "source_code": "\tpublic int getTextMessageSizeLimit() {\n\t\tcheckNativeSessionInitialized();\n\t\treturn (int) getNativeSession().getMaxTextMessageSize();\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#getUri()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "URI",
    "signature": "public URI getUri()",
    "source_code": "\tpublic URI getUri() {\n\t\tcheckNativeSessionInitialized();\n\t\treturn this.uri;\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#initializeNativeSession(session)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "void",
    "signature": "public void initializeNativeSession(Session session)",
    "source_code": "\tpublic void initializeNativeSession(Session session) {\n\t\tsuper.initializeNativeSession(session);\n\n\t\tthis.uri = session.getUpgradeRequest().getRequestURI();\n\n\t\tHttpHeaders headers = new HttpHeaders();\n\t\tMap<String, List<String>> nativeHeaders = session.getUpgradeRequest().getHeaders();\n\t\tif (!CollectionUtils.isEmpty(nativeHeaders)) {\n\t\t\theaders.putAll(nativeHeaders);\n\t\t}\n\t\tthis.headers = HttpHeaders.readOnlyHttpHeaders(headers);\n\n\t\tthis.acceptedProtocol = session.getUpgradeResponse().getAcceptedSubProtocol();\n\t\tthis.extensions = getExtensions(session);\n\n\t\tif (this.user == null) {\n\t\t\ttry {\n\t\t\t\tthis.user = session.getUpgradeRequest().getUserPrincipal();\n\t\t\t}\n\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t// Necessary until https://github.com/eclipse/jetty.project/issues/10498 is resolved\n\t\t\t\tlogger.error(\"Failure from UpgradeRequest while getting Principal\", ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#isOpen()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "boolean",
    "signature": "public boolean isOpen()",
    "source_code": "\tpublic boolean isOpen() {\n\t\treturn getNativeSession().isOpen();\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#sendBinaryMessage(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "void",
    "signature": "protected void sendBinaryMessage(BinaryMessage message)",
    "source_code": "\tprotected void sendBinaryMessage(BinaryMessage message) throws IOException {\n\t\tuseSession((session, callback) -> session.sendBinary(message.getPayload(), callback));\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#sendPingMessage(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "void",
    "signature": "protected void sendPingMessage(PingMessage message)",
    "source_code": "\tprotected void sendPingMessage(PingMessage message) throws IOException {\n\t\tuseSession((session, callback) -> session.sendPing(message.getPayload(), callback));\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#sendPongMessage(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "void",
    "signature": "protected void sendPongMessage(PongMessage message)",
    "source_code": "\tprotected void sendPongMessage(PongMessage message) throws IOException {\n\t\tuseSession((session, callback) -> session.sendPong(message.getPayload(), callback));\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#sendTextMessage(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "void",
    "signature": "protected void sendTextMessage(TextMessage message)",
    "source_code": "\tprotected void sendTextMessage(TextMessage message) throws IOException {\n\t\tuseSession((session, callback) -> session.sendText(message.getPayload(), callback));\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#setBinaryMessageSizeLimit(messageSizeLimit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSizeLimit"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "void",
    "signature": "public void setBinaryMessageSizeLimit(int messageSizeLimit)",
    "source_code": "\tpublic void setBinaryMessageSizeLimit(int messageSizeLimit) {\n\t\tcheckNativeSessionInitialized();\n\t\tgetNativeSession().setMaxBinaryMessageSize(messageSizeLimit);\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#setTextMessageSizeLimit(messageSizeLimit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSizeLimit"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "public void setTextMessageSizeLimit(int messageSizeLimit)",
    "source_code": "\tpublic void setTextMessageSizeLimit(int messageSizeLimit) {\n\t\tcheckNativeSessionInitialized();\n\t\tgetNativeSession().setMaxTextMessageSize(messageSizeLimit);\n\t}"
  },
  "org.springframework.web.socket.config.annotation.WebMvcStompEndpointRegistry#isPreserveReceiveOrder()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "boolean",
    "signature": "protected boolean isPreserveReceiveOrder()",
    "source_code": "\tprotected boolean isPreserveReceiveOrder() {\n\t\treturn this.stompHandler.isPreserveReceiveOrder();\n\t}"
  },
  "org.springframework.web.socket.config.annotation.WebMvcStompEndpointRegistry#setPreserveReceiveOrder(preserveReceiveOrder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "preserveReceiveOrder"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "WebMvcStompEndpointRegistry",
    "signature": "public WebMvcStompEndpointRegistry setPreserveReceiveOrder(boolean preserveReceiveOrder)",
    "source_code": "\tpublic WebMvcStompEndpointRegistry setPreserveReceiveOrder(boolean preserveReceiveOrder) {\n\t\tthis.stompHandler.setPreserveReceiveOrder(preserveReceiveOrder);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport#stompWebSocketHandlerMapping(subProtocolWebSocketHandler,messageBrokerTaskScheduler)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "subProtocolWebSocketHandler",
      "messageBrokerTaskScheduler"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "HandlerMapping",
    "signature": "public HandlerMapping stompWebSocketHandlerMapping(WebSocketHandler subProtocolWebSocketHandler, TaskScheduler messageBrokerTaskScheduler)",
    "source_code": "\tpublic HandlerMapping stompWebSocketHandlerMapping("
  },
  "org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport#stompWebSocketHandlerMapping(subProtocolWebSocketHandler,messageBrokerTaskScheduler,clientInboundChannel)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "subProtocolWebSocketHandler",
      "messageBrokerTaskScheduler",
      "clientInboundChannel"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "HandlerMapping",
    "signature": "public HandlerMapping stompWebSocketHandlerMapping(WebSocketHandler subProtocolWebSocketHandler, TaskScheduler messageBrokerTaskScheduler,\n\t\t\tAbstractSubscribableChannel clientInboundChannel)",
    "source_code": "\tpublic HandlerMapping stompWebSocketHandlerMapping("
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler#handleMessageFromClient(session,webSocketMessage,outputChannel)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle incoming WebSocket messages from clients.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "webSocketMessage",
      "outputChannel"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "void",
    "signature": "public void handleMessageFromClient(WebSocketSession session,\n\t\t\tWebSocketMessage<?> webSocketMessage, MessageChannel outputChannel)",
    "source_code": "\tpublic void handleMessageFromClient(WebSocketSession session,"
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler#handleMessageFromClient(session,webSocketMessage,targetChannel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle incoming WebSocket messages from clients.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "webSocketMessage",
      "targetChannel"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "void",
    "signature": "public void handleMessageFromClient(WebSocketSession session,\n\t\t\tWebSocketMessage<?> webSocketMessage, MessageChannel targetChannel)",
    "source_code": "\tpublic void handleMessageFromClient(WebSocketSession session,"
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler#isPreserveReceiveOrder()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the handler is configured to handle inbound messages in the\n\t * order in which they were received.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "boolean",
    "signature": "public boolean isPreserveReceiveOrder()",
    "source_code": "\tpublic boolean isPreserveReceiveOrder() {\n\t\treturn (this.orderedHandlingMessageChannels != null);\n\t}"
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler#setPreserveReceiveOrder(preserveReceiveOrder)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether client messages must be handled in the order received.\n\t * <p>By default messages sent to the {@code \"clientInboundChannel\"} may\n\t * not be handled in the same order because the channel is backed by a\n\t * ThreadPoolExecutor that in turn does not guarantee processing in order.\n\t * <p>When this flag is set to {@code true} messages within the same session\n\t * will be sent to the {@code \"clientInboundChannel\"} one at a time to\n\t * preserve the order in which they were received.\n\t * @param preserveReceiveOrder whether to publish in order\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "preserveReceiveOrder"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "void",
    "signature": "public void setPreserveReceiveOrder(boolean preserveReceiveOrder)",
    "source_code": "\tpublic void setPreserveReceiveOrder(boolean preserveReceiveOrder) {\n\t\tthis.orderedHandlingMessageChannels = (preserveReceiveOrder ? new ConcurrentHashMap<>() : null);\n\t}"
  },
  "org.springframework.web.socket.server.support.WebSocketHandlerMapping#getPhase()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "int",
    "signature": "public int getPhase()",
    "source_code": "\tpublic int getPhase() {\n\t\treturn (this.phase != null ? this.phase : SmartLifecycle.super.getPhase());\n\t}"
  },
  "org.springframework.web.socket.server.support.WebSocketHandlerMapping#setPhase(phase)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the phase that this handler should run in.\n\t * <p>By default, this is {@link SmartLifecycle#DEFAULT_PHASE}.\n\t * @since 6.1.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "phase"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "void",
    "signature": "public void setPhase(int phase)",
    "source_code": "\tpublic void setPhase(int phase) {\n\t\tthis.phase = phase;\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.SockJsClient#buildSockJsUrlInfo(url)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link SockJsUrlInfo} for the current client execution.\n\t * <p>The default implementation builds a {@code SockJsUrlInfo} which\n\t * calculates a random server id and session id if necessary.\n\t * @param url the target URL\n\t * @since 6.1.3\n\t * @see SockJsUrlInfo#SockJsUrlInfo(URI)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "url"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "SockJsUrlInfo",
    "signature": "protected SockJsUrlInfo buildSockJsUrlInfo(URI url)",
    "source_code": "\tprotected SockJsUrlInfo buildSockJsUrlInfo(URI url) {\n\t\treturn new SockJsUrlInfo(url);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.disconnectedClientLogger": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Separate logger to use on network IO failure after a client has gone away.\n\t * @see #DISCONNECTED_CLIENT_LOG_CATEGORY\n\t */",
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "signature": "protected Log disconnectedClientLogger",
    "source_code": "\tprotected static final Log disconnectedClientLogger = LogFactory.getLog(DISCONNECTED_CLIENT_LOG_CATEGORY);",
    "type": "Log"
  },
  "org.springframework.web.util.<unknown>#convertToCharacter(entityReference)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the char mapped to the given entityReference or -1.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityReference"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "char",
    "signature": "public char convertToCharacter(String entityReference)",
    "source_code": "\tpublic char convertToCharacter(String entityReference) {\n\t\tCharacter referredCharacter = this.entityReferenceToCharacterMap.get(entityReference);\n\t\tif (referredCharacter != null) {\n\t\t\treturn referredCharacter;\n\t\t}\n\t\treturn CHAR_NULL;\n\t}"
  },
  "org.springframework.web.util.<unknown>#convertToReference(character)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the reference mapped to the given character, or {@code null} if none found.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "character"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "String",
    "signature": "public String convertToReference(char character)",
    "source_code": "\tpublic String convertToReference(char character) {\n\t\treturn convertToReference(character, WebUtils.DEFAULT_CHARACTER_ENCODING);\n\t}"
  },
  "org.springframework.web.util.<unknown>#convertToReference(character,encoding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the reference mapped to the given character, or {@code null} if none found.\n\t * @since 4.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "character",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "String",
    "signature": "public String convertToReference(char character, String encoding)",
    "source_code": "\tpublic String convertToReference(char character, String encoding) {\n\t\tif (encoding.startsWith(\"UTF-\")){\n\t\t\treturn switch (character){\n\t\t\t\tcase '<' -> \"&lt;\";\n\t\t\t\tcase '>' -> \"&gt;\";\n\t\t\t\tcase '\"' -> \"&quot;\";\n\t\t\t\tcase '&' -> \"&amp;\";\n\t\t\t\tcase '\\'' -> \"&#39;\";\n\t\t\t\tdefault -> null;\n\t\t\t};\n\t\t}\n\t\telse if (character < 1000 || (character >= 8000 && character < 10000)) {\n\t\t\tint index = (character < 1000 ? character : character - 7000);\n\t\t\tString entityReference = this.characterToEntityReferenceMap[index];\n\t\t\tif (entityReference != null) {\n\t\t\t\treturn entityReference;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.util.<unknown>#getSupportedReferenceCount()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the number of supported entity references.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "int",
    "signature": "public int getSupportedReferenceCount()",
    "source_code": "\tpublic int getSupportedReferenceCount() {\n\t\treturn this.entityReferenceToCharacterMap.size();\n\t}"
  },
  "org.springframework.web.util.<unknown>#isMappedToReference(character)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return true if the given character is mapped to a supported entity reference.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "character"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "boolean",
    "signature": "public boolean isMappedToReference(char character)",
    "source_code": "\tpublic boolean isMappedToReference(char character) {\n\t\treturn isMappedToReference(character, WebUtils.DEFAULT_CHARACTER_ENCODING);\n\t}"
  },
  "org.springframework.web.util.<unknown>#isMappedToReference(character,encoding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return true if the given character is mapped to a supported entity reference.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "character",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "boolean",
    "signature": "public boolean isMappedToReference(char character, String encoding)",
    "source_code": "\tpublic boolean isMappedToReference(char character, String encoding) {\n\t\treturn (convertToReference(character, encoding) != null);\n\t}"
  },
  "org.springframework.web.util.BindErrorUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Utility methods to resolve a list of {@link MessageSourceResolvable}s, and\n * optionally join them.\n *\n * @author Rossen Stoyanchev\n * @since 6.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class BindErrorUtils",
    "source_code": "public abstract class BindErrorUtils {\n\n\tprivate static final MessageSource defaultMessageSource = new MethodArgumentErrorMessageSource();\n\n\n\t/**\n\t * Shortcut for {@link #resolveAndJoin(List, MessageSource, Locale)} with\n\t * an empty {@link MessageSource} that simply formats the default message,\n\t * or first error code, also prepending the field name for field errors.\n\t */\n\tpublic static String resolveAndJoin(List<? extends MessageSourceResolvable> errors) {\n\t\treturn resolveAndJoin(errors, defaultMessageSource, Locale.getDefault());\n\t}\n\n\t/**\n\t * Shortcut for {@link #resolveAndJoin(CharSequence, CharSequence, CharSequence, List, MessageSource, Locale)}\n\t * with {@code \", and \"} as delimiter, and an empty prefix and suffix.\n\t */\n\tpublic static String resolveAndJoin(\n\t\t\tList<? extends MessageSourceResolvable> errors, MessageSource messageSource, Locale locale) {\n\n\t\treturn resolveAndJoin(\", and \", \"\", \"\", errors, messageSource, locale);\n\t}\n\n\t/**\n\t * Resolve all errors through the given {@link MessageSource} and join them.\n\t * @param delimiter the delimiter to use between each error\n\t * @param prefix characters to insert at the beginning\n\t * @param suffix characters to insert at the end\n\t * @param errors the errors to resolve and join\n\t * @param messageSource the {@code MessageSource} to resolve with\n\t * @param locale the locale to resolve with\n\t * @return the resolved errors formatted as a string\n\t */\n\tpublic static String resolveAndJoin(\n\t\t\tCharSequence delimiter, CharSequence prefix, CharSequence suffix,\n\t\t\tList<? extends MessageSourceResolvable> errors, MessageSource messageSource, Locale locale) {\n\n\t\treturn errors.stream()\n\t\t\t\t.map(error -> messageSource.getMessage(error, locale))\n\t\t\t\t.filter(StringUtils::hasText)\n\t\t\t\t.collect(Collectors.joining(delimiter, prefix, suffix));\n\t}\n\n\t/**\n\t * Shortcut for {@link #resolve(List, MessageSource, Locale)} with an empty\n\t * {@link MessageSource} that simply formats the default message, or first\n\t * error code, also prepending the field name for field errors.\n\t */\n\tpublic static <E extends MessageSourceResolvable> Map<E, String> resolve(List<E> errors) {\n\t\treturn resolve(errors, defaultMessageSource, Locale.getDefault());\n\t}\n\n\t/**\n\t * Resolve all errors through the given {@link MessageSource}.\n\t * @param errors the errors to resolve\n\t * @param messageSource the {@code MessageSource} to resolve with\n\t * @param locale the locale to resolve with an empty {@link MessageSource}\n\t * @return map with resolved errors as values, in the order of the input list\n\t */\n\tpublic static <E extends MessageSourceResolvable> Map<E, String> resolve(\n\t\t\tList<E> errors, MessageSource messageSource, Locale locale) {\n\n\t\tMap<E, String> map = new LinkedHashMap<>(errors.size());\n\t\terrors.forEach(error -> map.put(error, messageSource.getMessage(error, locale)));\n\t\treturn map;\n\t}\n\n\n\t/**\n\t * {@code MessageSource} for default error formatting.\n\t */\n\tprivate static class MethodArgumentErrorMessageSource extends StaticMessageSource {\n\n\t\tMethodArgumentErrorMessageSource() {\n\t\t\tsetUseCodeAsDefaultMessage(true);\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tprotected String getDefaultMessage(MessageSourceResolvable resolvable, Locale locale) {\n\t\t\tString message = super.getDefaultMessage(resolvable, locale);\n\t\t\treturn (resolvable instanceof FieldError error ? error.getField() + \": \" + message : message);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.util.BindErrorUtils#getDefaultMessage(resolvable,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resolvable",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "String",
    "signature": "protected String getDefaultMessage(MessageSourceResolvable resolvable, Locale locale)",
    "source_code": "\t\tprotected String getDefaultMessage(MessageSourceResolvable resolvable, Locale locale) {\n\t\t\tString message = super.getDefaultMessage(resolvable, locale);\n\t\t\treturn (resolvable instanceof FieldError error ? error.getField() + \": \" + message : message);\n\t\t}"
  },
  "org.springframework.web.util.BindErrorUtils#resolve(errors)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Shortcut for {@link #resolve(List, MessageSource, Locale)} with an empty\n\t * {@link MessageSource} that simply formats the default message, or first\n\t * error code, also prepending the field name for field errors.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "String>",
    "signature": "public String> resolve(List<E> errors)",
    "source_code": "\tpublic static <E extends MessageSourceResolvable> Map<E, String> resolve(List<E> errors) {\n\t\treturn resolve(errors, defaultMessageSource, Locale.getDefault());\n\t}"
  },
  "org.springframework.web.util.BindErrorUtils#resolve(errors,messageSource,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve all errors through the given {@link MessageSource}.\n\t * @param errors the errors to resolve\n\t * @param messageSource the {@code MessageSource} to resolve with\n\t * @param locale the locale to resolve with an empty {@link MessageSource}\n\t * @return map with resolved errors as values, in the order of the input list\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors",
      "messageSource",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "String>",
    "signature": "public String> resolve(List<E> errors, MessageSource messageSource, Locale locale)",
    "source_code": "\tpublic static <E extends MessageSourceResolvable> Map<E, String> resolve("
  },
  "org.springframework.web.util.BindErrorUtils#resolveAndJoin(delimiter,prefix,suffix,errors,messageSource,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve all errors through the given {@link MessageSource} and join them.\n\t * @param delimiter the delimiter to use between each error\n\t * @param prefix characters to insert at the beginning\n\t * @param suffix characters to insert at the end\n\t * @param errors the errors to resolve and join\n\t * @param messageSource the {@code MessageSource} to resolve with\n\t * @param locale the locale to resolve with\n\t * @return the resolved errors formatted as a string\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "delimiter",
      "prefix",
      "suffix",
      "errors",
      "messageSource",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "String",
    "signature": "public String resolveAndJoin(CharSequence delimiter, CharSequence prefix, CharSequence suffix,\n\t\t\tList<? extends MessageSourceResolvable> errors, MessageSource messageSource, Locale locale)",
    "source_code": "\tpublic static String resolveAndJoin("
  },
  "org.springframework.web.util.BindErrorUtils#resolveAndJoin(errors)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Shortcut for {@link #resolveAndJoin(List, MessageSource, Locale)} with\n\t * an empty {@link MessageSource} that simply formats the default message,\n\t * or first error code, also prepending the field name for field errors.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "return": "String",
    "signature": "public String resolveAndJoin(List<? extends MessageSourceResolvable> errors)",
    "source_code": "\tpublic static String resolveAndJoin(List<? extends MessageSourceResolvable> errors) {\n\t\treturn resolveAndJoin(errors, defaultMessageSource, Locale.getDefault());\n\t}"
  },
  "org.springframework.web.util.BindErrorUtils#resolveAndJoin(errors,messageSource,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Shortcut for {@link #resolveAndJoin(CharSequence, CharSequence, CharSequence, List, MessageSource, Locale)}\n\t * with {@code \", and \"} as delimiter, and an empty prefix and suffix.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors",
      "messageSource",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "String",
    "signature": "public String resolveAndJoin(List<? extends MessageSourceResolvable> errors, MessageSource messageSource, Locale locale)",
    "source_code": "\tpublic static String resolveAndJoin("
  },
  "org.springframework.web.util.SCOPE_APPLICATION": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Constant identifying the application scope. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "signature": "public String SCOPE_APPLICATION",
    "source_code": "\tpublic static final String SCOPE_APPLICATION = \"application\";",
    "type": "String"
  },
  "org.springframework.web.util.SCOPE_PAGE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Constant identifying the page scope. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public String SCOPE_PAGE",
    "source_code": "\tpublic static final String SCOPE_PAGE = \"page\";",
    "type": "String"
  },
  "org.springframework.web.util.SCOPE_REQUEST": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Constant identifying the request scope. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "public String SCOPE_REQUEST",
    "source_code": "\tpublic static final String SCOPE_REQUEST = \"request\";",
    "type": "String"
  },
  "org.springframework.web.util.SCOPE_SESSION": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Constant identifying the session scope. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "signature": "public String SCOPE_SESSION",
    "source_code": "\tpublic static final String SCOPE_SESSION = \"session\";",
    "type": "String"
  },
  "org.springframework.web.util.TagUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Utility class for tag library related code, exposing functionality\n * such as translating {@link String Strings} to web scopes.\n *\n * <p>\n * <ul>\n * <li>{@code page} will be transformed to\n * {@link jakarta.servlet.jsp.PageContext#PAGE_SCOPE PageContext.PAGE_SCOPE}\n * <li>{@code request} will be transformed to\n * {@link jakarta.servlet.jsp.PageContext#REQUEST_SCOPE PageContext.REQUEST_SCOPE}\n * <li>{@code session} will be transformed to\n * {@link jakarta.servlet.jsp.PageContext#SESSION_SCOPE PageContext.SESSION_SCOPE}\n * <li>{@code application} will be transformed to\n * {@link jakarta.servlet.jsp.PageContext#APPLICATION_SCOPE PageContext.APPLICATION_SCOPE}\n * </ul>\n *\n * @author Alef Arendsen\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @author Rick Evans\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "signature": "public class TagUtils",
    "source_code": "public abstract class TagUtils {\n\n\t/** Constant identifying the page scope. */\n\tpublic static final String SCOPE_PAGE = \"page\";\n\n\t/** Constant identifying the request scope. */\n\tpublic static final String SCOPE_REQUEST = \"request\";\n\n\t/** Constant identifying the session scope. */\n\tpublic static final String SCOPE_SESSION = \"session\";\n\n\t/** Constant identifying the application scope. */\n\tpublic static final String SCOPE_APPLICATION = \"application\";\n\n\n\t/**\n\t * Determines the scope for a given input {@code String}.\n\t * <p>If the {@code String} does not match 'request', 'session',\n\t * 'page' or 'application', the method will return {@link PageContext#PAGE_SCOPE}.\n\t * @param scope the {@code String} to inspect\n\t * @return the scope found, or {@link PageContext#PAGE_SCOPE} if no scope matched\n\t * @throws IllegalArgumentException if the supplied {@code scope} is {@code null}\n\t */\n\tpublic static int getScope(String scope) {\n\t\tAssert.notNull(scope, \"Scope to search for cannot be null\");\n\t\treturn switch (scope) {\n\t\t\tcase SCOPE_REQUEST -> PageContext.REQUEST_SCOPE;\n\t\t\tcase SCOPE_SESSION -> PageContext.SESSION_SCOPE;\n\t\t\tcase SCOPE_APPLICATION -> PageContext.APPLICATION_SCOPE;\n\t\t\tdefault -> PageContext.PAGE_SCOPE;\n\t\t};\n\t}\n\n\t/**\n\t * Determine whether the supplied {@link Tag} has any ancestor tag\n\t * of the supplied type.\n\t * @param tag the tag whose ancestors are to be checked\n\t * @param ancestorTagClass the ancestor {@link Class} being searched for\n\t * @return {@code true} if the supplied {@link Tag} has any ancestor tag\n\t * of the supplied type\n\t * @throws IllegalArgumentException if either of the supplied arguments is {@code null};\n\t * or if the supplied {@code ancestorTagClass} is not type-assignable to\n\t * the {@link Tag} class\n\t */\n\tpublic static boolean hasAncestorOfType(Tag tag, Class<?> ancestorTagClass) {\n\t\tAssert.notNull(tag, \"Tag cannot be null\");\n\t\tAssert.notNull(ancestorTagClass, \"Ancestor tag class cannot be null\");\n\t\tif (!Tag.class.isAssignableFrom(ancestorTagClass)) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Class '\" + ancestorTagClass.getName() + \"' is not a valid Tag type\");\n\t\t}\n\t\tTag ancestor = tag.getParent();\n\t\twhile (ancestor != null) {\n\t\t\tif (ancestorTagClass.isAssignableFrom(ancestor.getClass())) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tancestor = ancestor.getParent();\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Determine whether the supplied {@link Tag} has any ancestor tag\n\t * of the supplied type, throwing an {@link IllegalStateException}\n\t * if not.\n\t * @param tag the tag whose ancestors are to be checked\n\t * @param ancestorTagClass the ancestor {@link Class} being searched for\n\t * @param tagName the name of the {@code tag}; for example '{@code option}'\n\t * @param ancestorTagName the name of the ancestor {@code tag}; for example '{@code select}'\n\t * @throws IllegalStateException if the supplied {@code tag} does not\n\t * have a tag of the supplied {@code parentTagClass} as an ancestor\n\t * @throws IllegalArgumentException if any of the supplied arguments is {@code null},\n\t * or in the case of the {@link String}-typed arguments, is composed wholly\n\t * of whitespace; or if the supplied {@code ancestorTagClass} is not\n\t * type-assignable to the {@link Tag} class\n\t * @see #hasAncestorOfType(jakarta.servlet.jsp.tagext.Tag, Class)\n\t */\n\tpublic static void assertHasAncestorOfType(Tag tag, Class<?> ancestorTagClass, String tagName,\n\t\t\tString ancestorTagName) {\n\n\t\tAssert.hasText(tagName, \"'tagName' must not be empty\");\n\t\tAssert.hasText(ancestorTagName, \"'ancestorTagName' must not be empty\");\n\t\tif (!TagUtils.hasAncestorOfType(tag, ancestorTagClass)) {\n\t\t\tthrow new IllegalStateException(\"The '\" + tagName +\n\t\t\t\t\t\"' tag can only be used inside a valid '\" + ancestorTagName + \"' tag.\");\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.util.TagUtils#assertHasAncestorOfType(tag,ancestorTagClass,tagName,ancestorTagName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the supplied {@link Tag} has any ancestor tag\n\t * of the supplied type, throwing an {@link IllegalStateException}\n\t * if not.\n\t * @param tag the tag whose ancestors are to be checked\n\t * @param ancestorTagClass the ancestor {@link Class} being searched for\n\t * @param tagName the name of the {@code tag}; for example '{@code option}'\n\t * @param ancestorTagName the name of the ancestor {@code tag}; for example '{@code select}'\n\t * @throws IllegalStateException if the supplied {@code tag} does not\n\t * have a tag of the supplied {@code parentTagClass} as an ancestor\n\t * @throws IllegalArgumentException if any of the supplied arguments is {@code null},\n\t * or in the case of the {@link String}-typed arguments, is composed wholly\n\t * of whitespace; or if the supplied {@code ancestorTagClass} is not\n\t * type-assignable to the {@link Tag} class\n\t * @see #hasAncestorOfType(jakarta.servlet.jsp.tagext.Tag, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "tag",
      "ancestorTagClass",
      "tagName",
      "ancestorTagName"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "void",
    "signature": "public void assertHasAncestorOfType(Tag tag, Class<?> ancestorTagClass, String tagName,\n\t\t\tString ancestorTagName)",
    "source_code": "\tpublic static void assertHasAncestorOfType(Tag tag, Class<?> ancestorTagClass, String tagName,"
  },
  "org.springframework.web.util.TagUtils#getScope(scope)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determines the scope for a given input {@code String}.\n\t * <p>If the {@code String} does not match 'request', 'session',\n\t * 'page' or 'application', the method will return {@link PageContext#PAGE_SCOPE}.\n\t * @param scope the {@code String} to inspect\n\t * @return the scope found, or {@link PageContext#PAGE_SCOPE} if no scope matched\n\t * @throws IllegalArgumentException if the supplied {@code scope} is {@code null}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "int",
    "signature": "public int getScope(String scope)",
    "source_code": "\tpublic static int getScope(String scope) {\n\t\tAssert.notNull(scope, \"Scope to search for cannot be null\");\n\t\treturn switch (scope) {\n\t\t\tcase SCOPE_REQUEST -> PageContext.REQUEST_SCOPE;\n\t\t\tcase SCOPE_SESSION -> PageContext.SESSION_SCOPE;\n\t\t\tcase SCOPE_APPLICATION -> PageContext.APPLICATION_SCOPE;\n\t\t\tdefault -> PageContext.PAGE_SCOPE;\n\t\t};\n\t}"
  },
  "org.springframework.web.util.TagUtils#hasAncestorOfType(tag,ancestorTagClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the supplied {@link Tag} has any ancestor tag\n\t * of the supplied type.\n\t * @param tag the tag whose ancestors are to be checked\n\t * @param ancestorTagClass the ancestor {@link Class} being searched for\n\t * @return {@code true} if the supplied {@link Tag} has any ancestor tag\n\t * of the supplied type\n\t * @throws IllegalArgumentException if either of the supplied arguments is {@code null};\n\t * or if the supplied {@code ancestorTagClass} is not type-assignable to\n\t * the {@link Tag} class\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "tag",
      "ancestorTagClass"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "boolean",
    "signature": "public boolean hasAncestorOfType(Tag tag, Class<?> ancestorTagClass)",
    "source_code": "\tpublic static boolean hasAncestorOfType(Tag tag, Class<?> ancestorTagClass) {\n\t\tAssert.notNull(tag, \"Tag cannot be null\");\n\t\tAssert.notNull(ancestorTagClass, \"Ancestor tag class cannot be null\");\n\t\tif (!Tag.class.isAssignableFrom(ancestorTagClass)) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Class '\" + ancestorTagClass.getName() + \"' is not a valid Tag type\");\n\t\t}\n\t\tTag ancestor = tag.getParent();\n\t\twhile (ancestor != null) {\n\t\t\tif (ancestorTagClass.isAssignableFrom(ancestor.getClass())) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tancestor = ancestor.getParent();\n\t\t}\n\t\treturn false;\n\t}"
  }
}