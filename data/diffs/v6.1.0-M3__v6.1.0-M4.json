{
  "org.springframework.aop.aspectj.TypePatternClassFilter#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof TypePatternClassFilter that &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.typePattern, that.typePattern)));\n\t}"
  },
  "org.springframework.aop.aspectj.TypePatternClassFilter#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof TypePatternClassFilter that &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.typePattern, that.typePattern)));\n\t}"
  },
  "org.springframework.aop.support.ClassFilters#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object obj) {\n\t\t\treturn (this == obj || (obj instanceof IntersectionClassFilter that &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.filters, that.filters)));\n\t\t}"
  },
  "org.springframework.aop.support.ClassFilters#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other || (other instanceof IntersectionClassFilter that &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.filters, that.filters)));\n\t\t}"
  },
  "org.springframework.aop.support.NameMatchMethodPointcut#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof NameMatchMethodPointcut that &&\n\t\t\t\tthis.mappedNames.equals(that.mappedNames)));\n\t}"
  },
  "org.springframework.aop.support.NameMatchMethodPointcut#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof NameMatchMethodPointcut that &&\n\t\t\t\tthis.mappedNames.equals(that.mappedNames)));\n\t}"
  },
  "org.springframework.aop.support.RootClassFilter#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof RootClassFilter that &&\n\t\t\t\tthis.clazz.equals(that.clazz)));\n\t}"
  },
  "org.springframework.aop.support.RootClassFilter#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof RootClassFilter that &&\n\t\t\t\tthis.clazz.equals(that.clazz)));\n\t}"
  },
  "org.springframework.aot.generate.<unknown>#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof MethodName that && this.value.equals(that.value)));\n\t}"
  },
  "org.springframework.aot.generate.<unknown>#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.value.hashCode();\n\t}"
  },
  "org.springframework.aot.generate.<unknown>#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn (!StringUtils.hasLength(this.value)) ? \"$$aot\" : this.value ;\n\t}"
  },
  "org.springframework.aot.generate.NONE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An empty method name.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public MethodName NONE",
    "source_code": "\tpublic static final MethodName NONE = of();",
    "type": "MethodName"
  },
  "org.springframework.beans.<unknown>#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object obj) {\n\t\t\treturn (this == obj || (obj instanceof PropertyDescriptor that &&\n\t\t\t\t\tPropertyDescriptorUtils.equals(this, that)));\n\t\t}"
  },
  "org.springframework.beans.MutablePropertyValues#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 369
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof MutablePropertyValues that &&\n\t\t\t\tthis.propertyValueList.equals(that.propertyValueList)));\n\t}"
  },
  "org.springframework.beans.MutablePropertyValues#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 369
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof MutablePropertyValues that &&\n\t\t\t\tthis.propertyValueList.equals(that.propertyValueList)));\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation compares the underlying BeanDefinition.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof BeanDefinitionResource that &&\n\t\t\t\tthis.beanDefinition.equals(that.beanDefinition)));\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation compares the underlying BeanDefinition.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof BeanDefinitionResource that &&\n\t\t\t\tthis.beanDefinition.equals(that.beanDefinition)));\n\t}"
  },
  "org.springframework.beans.factory.support.DefaultListableBeanFactory#isBeanDefinitionOverridable(beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns {@code true} if bean definition overriding\n\t * is generally allowed.\n\t * @see #setAllowBeanDefinitionOverriding\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 1159
    },
    "return": "boolean",
    "signature": "public boolean isBeanDefinitionOverridable(String beanName)",
    "source_code": "\tpublic boolean isBeanDefinitionOverridable(String beanName) {\n\t\treturn isAllowBeanDefinitionOverriding();\n\t}"
  },
  "org.springframework.beans.factory.support.PREFERRED_CONSTRUCTORS_ATTRIBUTE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The name of an attribute that can be\n\t * {@link org.springframework.core.AttributeAccessor#setAttribute set} on a\n\t * {@link org.springframework.beans.factory.config.BeanDefinition} so that\n\t * bean definitions can indicate one or more preferred constructors. This is\n\t * analogous to {@code @Autowired} annotated constructors on the bean class.\n\t * <p>The attribute value may be a single {@link java.lang.reflect.Constructor}\n\t * reference or an array thereof.\n\t * @since 6.1\n\t * @see org.springframework.beans.factory.annotation.Autowired\n\t * @see org.springframework.beans.factory.support.RootBeanDefinition#getPreferredConstructors()\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "signature": "public String PREFERRED_CONSTRUCTORS_ATTRIBUTE",
    "source_code": "\tpublic static final String PREFERRED_CONSTRUCTORS_ATTRIBUTE = \"preferredConstructors\";",
    "type": "String"
  },
  "org.springframework.cache.caffeine.CaffeineCache#apply(o)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "Object",
    "signature": "public Object apply(Object o)",
    "source_code": "\t\tpublic Object apply(Object o) {\n\t\t\ttry {\n\t\t\t\treturn toStoreValue(this.valueLoader.call());\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new ValueRetrievalException(o, this.valueLoader, ex);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCache#getAsyncCache()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the internal Caffeine AsyncCache.\n\t * @throws IllegalStateException if no AsyncCache is available\n\t * @since 6.1\n\t * @see #CaffeineCache(String, AsyncCache, boolean)\n\t * @see CaffeineCacheManager#setAsyncCacheMode\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "Object>",
    "signature": "public Object> getAsyncCache()",
    "source_code": "\tpublic final AsyncCache<Object, Object> getAsyncCache() {\n\t\tAssert.state(this.asyncCache != null,\n\t\t\t\t\"No Caffeine AsyncCache available: set CaffeineCacheManager.setAsyncCacheMode(true)\");\n\t\treturn this.asyncCache;\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCache#retrieve(key,valueLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "valueLoader"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "CompletableFuture<T>",
    "signature": "public CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader)",
    "source_code": "\tpublic <T> CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader) {\n\t\treturn (CompletableFuture<T>) getAsyncCache().get(key, (k, e) -> valueLoader.get());\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link CacheManager} implementation that lazily builds {@link CaffeineCache}\n * instances for each {@link #getCache} request. Also supports a 'static' mode\n * where the set of cache names is pre-defined through {@link #setCacheNames},\n * with no dynamic creation of further cache regions at runtime.\n *\n * <p>The configuration of the underlying cache can be fine-tuned through a\n * {@link Caffeine} builder or {@link CaffeineSpec}, passed into this\n * CacheManager through {@link #setCaffeine}/{@link #setCaffeineSpec}.\n * A {@link CaffeineSpec}-compliant expression value can also be applied\n * via the {@link #setCacheSpecification \"cacheSpecification\"} bean property.\n *\n * <p>Supports the {@link Cache#retrieve(Object)} and\n * {@link Cache#retrieve(Object, Supplier)} operations through Caffeine's\n * {@link AsyncCache}, when configured via {@link #setAsyncCacheMode}.\n *\n * <p>Requires Caffeine 3.0 or higher, as of Spring Framework 6.1.\n *\n * @author Ben Manes\n * @author Juergen Hoeller\n * @author Stephane Nicoll\n * @author Sam Brannen\n * @author Brian Clozel\n * @since 4.3\n * @see CaffeineCache\n * @see #setCaffeineSpec\n * @see #setCacheSpecification\n * @see #setAsyncCacheMode\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "signature": "public class CaffeineCacheManager",
    "source_code": "public class CaffeineCacheManager implements CacheManager {\n\n\tprivate Caffeine<Object, Object> cacheBuilder = Caffeine.newBuilder();\n\n\t@Nullable\n\tprivate AsyncCacheLoader<Object, Object> cacheLoader;\n\n\tprivate boolean asyncCacheMode = false;\n\n\tprivate boolean allowNullValues = true;\n\n\tprivate boolean dynamic = true;\n\n\tprivate final Map<String, Cache> cacheMap = new ConcurrentHashMap<>(16);\n\n\tprivate final Collection<String> customCacheNames = new CopyOnWriteArrayList<>();\n\n\n\t/**\n\t * Construct a dynamic CaffeineCacheManager,\n\t * lazily creating cache instances as they are being requested.\n\t */\n\tpublic CaffeineCacheManager() {\n\t}\n\n\t/**\n\t * Construct a static CaffeineCacheManager,\n\t * managing caches for the specified cache names only.\n\t */\n\tpublic CaffeineCacheManager(String... cacheNames) {\n\t\tsetCacheNames(Arrays.asList(cacheNames));\n\t}\n\n\n\t/**\n\t * Specify the set of cache names for this CacheManager's 'static' mode.\n\t * <p>The number of caches and their names will be fixed after a call to this method,\n\t * with no creation of further cache regions at runtime.\n\t * <p>Calling this with a {@code null} collection argument resets the\n\t * mode to 'dynamic', allowing for further creation of caches again.\n\t */\n\tpublic void setCacheNames(@Nullable Collection<String> cacheNames) {\n\t\tif (cacheNames != null) {\n\t\t\tfor (String name : cacheNames) {\n\t\t\t\tthis.cacheMap.put(name, createCaffeineCache(name));\n\t\t\t}\n\t\t\tthis.dynamic = false;\n\t\t}\n\t\telse {\n\t\t\tthis.dynamic = true;\n\t\t}\n\t}\n\n\t/**\n\t * Set the Caffeine to use for building each individual\n\t * {@link CaffeineCache} instance.\n\t * @see #createNativeCaffeineCache\n\t * @see Caffeine#build()\n\t */\n\tpublic void setCaffeine(Caffeine<Object, Object> caffeine) {\n\t\tAssert.notNull(caffeine, \"Caffeine must not be null\");\n\t\tdoSetCaffeine(caffeine);\n\t}\n\n\t/**\n\t * Set the {@link CaffeineSpec} to use for building each individual\n\t * {@link CaffeineCache} instance.\n\t * @see #createNativeCaffeineCache\n\t * @see Caffeine#from(CaffeineSpec)\n\t */\n\tpublic void setCaffeineSpec(CaffeineSpec caffeineSpec) {\n\t\tdoSetCaffeine(Caffeine.from(caffeineSpec));\n\t}\n\n\t/**\n\t * Set the Caffeine cache specification String to use for building each\n\t * individual {@link CaffeineCache} instance. The given value needs to\n\t * comply with Caffeine's {@link CaffeineSpec} (see its javadoc).\n\t * @see #createNativeCaffeineCache\n\t * @see Caffeine#from(String)\n\t */\n\tpublic void setCacheSpecification(String cacheSpecification) {\n\t\tdoSetCaffeine(Caffeine.from(cacheSpecification));\n\t}\n\n\tprivate void doSetCaffeine(Caffeine<Object, Object> cacheBuilder) {\n\t\tif (!ObjectUtils.nullSafeEquals(this.cacheBuilder, cacheBuilder)) {\n\t\t\tthis.cacheBuilder = cacheBuilder;\n\t\t\trefreshCommonCaches();\n\t\t}\n\t}\n\n\t/**\n\t * Set the Caffeine CacheLoader to use for building each individual\n\t * {@link CaffeineCache} instance, turning it into a LoadingCache.\n\t * @see #createNativeCaffeineCache\n\t * @see Caffeine#build(CacheLoader)\n\t * @see com.github.benmanes.caffeine.cache.LoadingCache\n\t */\n\tpublic void setCacheLoader(CacheLoader<Object, Object> cacheLoader) {\n\t\tif (!ObjectUtils.nullSafeEquals(this.cacheLoader, cacheLoader)) {\n\t\t\tthis.cacheLoader = cacheLoader;\n\t\t\trefreshCommonCaches();\n\t\t}\n\t}\n\n\t/**\n\t * Set the Caffeine AsyncCacheLoader to use for building each individual\n\t * {@link CaffeineCache} instance, turning it into a LoadingCache.\n\t * <p>This implicitly switches the {@link #setAsyncCacheMode \"asyncCacheMode\"}\n\t * flag to {@code true}.\n\t * @since 6.1\n\t * @see #createAsyncCaffeineCache\n\t * @see Caffeine#buildAsync(AsyncCacheLoader)\n\t * @see com.github.benmanes.caffeine.cache.LoadingCache\n\t */\n\tpublic void setAsyncCacheLoader(AsyncCacheLoader<Object, Object> cacheLoader) {\n\t\tif (!ObjectUtils.nullSafeEquals(this.cacheLoader, cacheLoader)) {\n\t\t\tthis.cacheLoader = cacheLoader;\n\t\t\tthis.asyncCacheMode = true;\n\t\t\trefreshCommonCaches();\n\t\t}\n\t}\n\n\t/**\n\t * Set the common cache type that this cache manager builds to async.\n\t * This applies to {@link #setCacheNames} as well as on-demand caches.\n\t * <p>Individual cache registrations (such as {@link #registerCustomCache(String, AsyncCache)}\n\t * and {@link #registerCustomCache(String, com.github.benmanes.caffeine.cache.Cache)}\n\t * are not dependent on this setting.\n\t * <p>By default, this cache manager builds regular native Caffeine caches.\n\t * To switch to async caches which can also be used through the synchronous API\n\t * but come with support for {@code Cache#retrieve}, set this flag to {@code true}.\n\t * @since 6.1\n\t * @see Caffeine#buildAsync()\n\t * @see Cache#retrieve(Object)\n\t * @see Cache#retrieve(Object, Supplier)\n\t */\n\tpublic void setAsyncCacheMode(boolean asyncCacheMode) {\n\t\tif (this.asyncCacheMode != asyncCacheMode) {\n\t\t\tthis.asyncCacheMode = asyncCacheMode;\n\t\t\trefreshCommonCaches();\n\t\t}\n\t}\n\n\t/**\n\t * Specify whether to accept and convert {@code null} values for all caches\n\t * in this cache manager.\n\t * <p>Default is \"true\", despite Caffeine itself not supporting {@code null} values.\n\t * An internal holder object will be used to store user-level {@code null}s.\n\t */\n\tpublic void setAllowNullValues(boolean allowNullValues) {\n\t\tif (this.allowNullValues != allowNullValues) {\n\t\t\tthis.allowNullValues = allowNullValues;\n\t\t\trefreshCommonCaches();\n\t\t}\n\t}\n\n\t/**\n\t * Return whether this cache manager accepts and converts {@code null} values\n\t * for all of its caches.\n\t */\n\tpublic boolean isAllowNullValues() {\n\t\treturn this.allowNullValues;\n\t}\n\n\n\t@Override\n\tpublic Collection<String> getCacheNames() {\n\t\treturn Collections.unmodifiableSet(this.cacheMap.keySet());\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Cache getCache(String name) {\n\t\tCache cache = this.cacheMap.get(name);\n\t\tif (cache == null && this.dynamic) {\n\t\t\tcache = this.cacheMap.computeIfAbsent(name, this::createCaffeineCache);\n\t\t}\n\t\treturn cache;\n\t}\n\n\n\t/**\n\t * Register the given native Caffeine Cache instance with this cache manager,\n\t * adapting it to Spring's cache API for exposure through {@link #getCache}.\n\t * Any number of such custom caches may be registered side by side.\n\t * <p>This allows for custom settings per cache (as opposed to all caches\n\t * sharing the common settings in the cache manager's configuration) and\n\t * is typically used with the Caffeine builder API:\n\t * {@code registerCustomCache(\"myCache\", Caffeine.newBuilder().maximumSize(10).build())}\n\t * <p>Note that any other caches, whether statically specified through\n\t * {@link #setCacheNames} or dynamically built on demand, still operate\n\t * with the common settings in the cache manager's configuration.\n \t * @param name the name of the cache\n\t * @param cache the custom Caffeine Cache instance to register\n\t * @since 5.2.8\n\t * @see #adaptCaffeineCache(String, com.github.benmanes.caffeine.cache.Cache)\n\t */\n\tpublic void registerCustomCache(String name, com.github.benmanes.caffeine.cache.Cache<Object, Object> cache) {\n\t\tthis.customCacheNames.add(name);\n\t\tthis.cacheMap.put(name, adaptCaffeineCache(name, cache));\n\t}\n\n\t/**\n\t * Register the given Caffeine AsyncCache instance with this cache manager,\n\t * adapting it to Spring's cache API for exposure through {@link #getCache}.\n\t * Any number of such custom caches may be registered side by side.\n\t * <p>This allows for custom settings per cache (as opposed to all caches\n\t * sharing the common settings in the cache manager's configuration) and\n\t * is typically used with the Caffeine builder API:\n\t * {@code registerCustomCache(\"myCache\", Caffeine.newBuilder().maximumSize(10).buildAsync())}\n\t * <p>Note that any other caches, whether statically specified through\n\t * {@link #setCacheNames} or dynamically built on demand, still operate\n\t * with the common settings in the cache manager's configuration.\n\t * @param name the name of the cache\n\t * @param cache the custom Caffeine AsyncCache instance to register\n\t * @since 6.1\n\t * @see #adaptCaffeineCache(String, AsyncCache)\n\t */\n\tpublic void registerCustomCache(String name, AsyncCache<Object, Object> cache) {\n\t\tthis.customCacheNames.add(name);\n\t\tthis.cacheMap.put(name, adaptCaffeineCache(name, cache));\n\t}\n\n\t/**\n\t * Adapt the given new native Caffeine Cache instance to Spring's {@link Cache}\n\t * abstraction for the specified cache name.\n\t * @param name the name of the cache\n\t * @param cache the native Caffeine Cache instance\n\t * @return the Spring CaffeineCache adapter (or a decorator thereof)\n\t * @since 5.2.8\n\t * @see CaffeineCache#CaffeineCache(String, com.github.benmanes.caffeine.cache.Cache, boolean)\n\t * @see #isAllowNullValues()\n\t */\n\tprotected Cache adaptCaffeineCache(String name, com.github.benmanes.caffeine.cache.Cache<Object, Object> cache) {\n\t\treturn new CaffeineCache(name, cache, isAllowNullValues());\n\t}\n\n\t/**\n\t * Adapt the given new Caffeine AsyncCache instance to Spring's {@link Cache}\n\t * abstraction for the specified cache name.\n\t * @param name the name of the cache\n\t * @param cache the Caffeine AsyncCache instance\n\t * @return the Spring CaffeineCache adapter (or a decorator thereof)\n\t * @since 6.1\n\t * @see CaffeineCache#CaffeineCache(String, AsyncCache, boolean)\n\t * @see #isAllowNullValues()\n\t */\n\tprotected Cache adaptCaffeineCache(String name, AsyncCache<Object, Object> cache) {\n\t\treturn new CaffeineCache(name, cache, isAllowNullValues());\n\t}\n\n\t/**\n\t * Build a common {@link CaffeineCache} instance for the specified cache name,\n\t * using the common Caffeine configuration specified on this cache manager.\n\t * <p>Delegates to {@link #adaptCaffeineCache} as the adaptation method to\n\t * Spring's cache abstraction (allowing for centralized decoration etc),\n\t * passing in a freshly built native Caffeine Cache instance.\n\t * @param name the name of the cache\n\t * @return the Spring CaffeineCache adapter (or a decorator thereof)\n\t * @see #adaptCaffeineCache\n\t * @see #createNativeCaffeineCache\n\t */\n\tprotected Cache createCaffeineCache(String name) {\n\t\treturn (this.asyncCacheMode ? adaptCaffeineCache(name, createAsyncCaffeineCache(name)) :\n\t\t\t\tadaptCaffeineCache(name, createNativeCaffeineCache(name)));\n\t}\n\n\t/**\n\t * Build a common Caffeine Cache instance for the specified cache name,\n\t * using the common Caffeine configuration specified on this cache manager.\n\t * @param name the name of the cache\n\t * @return the native Caffeine Cache instance\n\t * @see #createCaffeineCache\n\t */\n\tprotected com.github.benmanes.caffeine.cache.Cache<Object, Object> createNativeCaffeineCache(String name) {\n\t\tif (this.cacheLoader != null) {\n\t\t\tif (this.cacheLoader instanceof CacheLoader<Object, Object> regularCacheLoader) {\n\t\t\t\treturn this.cacheBuilder.build(regularCacheLoader);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Cannot create regular Caffeine Cache with async-only cache loader: \" + this.cacheLoader);\n\t\t\t}\n\t\t}\n\t\treturn this.cacheBuilder.build();\n\t}\n\n\t/**\n\t * Build a common Caffeine AsyncCache instance for the specified cache name,\n\t * using the common Caffeine configuration specified on this cache manager.\n\t * @param name the name of the cache\n\t * @return the Caffeine AsyncCache instance\n\t * @since 6.1\n\t * @see #createCaffeineCache\n\t */\n\tprotected AsyncCache<Object, Object> createAsyncCaffeineCache(String name) {\n\t\treturn (this.cacheLoader != null ? this.cacheBuilder.buildAsync(this.cacheLoader) :\n\t\t\t\tthis.cacheBuilder.buildAsync());\n\t}\n\n\t/**\n\t * Recreate the common caches with the current state of this manager.\n\t */\n\tprivate void refreshCommonCaches() {\n\t\tfor (Map.Entry<String, Cache> entry : this.cacheMap.entrySet()) {\n\t\t\tif (!this.customCacheNames.contains(entry.getKey())) {\n\t\t\t\tentry.setValue(createCaffeineCache(entry.getKey()));\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#adaptCaffeineCache(name,AsyncCache<Object,cache)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Adapt the given new Caffeine AsyncCache instance to Spring's {@link Cache}\n\t * abstraction for the specified cache name.\n\t * @param name the name of the cache\n\t * @param cache the Caffeine AsyncCache instance\n\t * @return the Spring CaffeineCache adapter (or a decorator thereof)\n\t * @since 6.1\n\t * @see CaffeineCache#CaffeineCache(String, AsyncCache, boolean)\n\t * @see #isAllowNullValues()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "AsyncCache<Object",
      "cache"
    ],
    "position": {
      "column": 1,
      "line": 317
    },
    "return": "Cache",
    "signature": "protected Cache adaptCaffeineCache(String name, AsyncCache<Object, Object> cache)",
    "source_code": "\tprotected Cache adaptCaffeineCache(String name, AsyncCache<Object, Object> cache) {\n\t\treturn new CaffeineCache(name, cache, isAllowNullValues());\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#adaptCaffeineCache(name,com.github.benmanes.caffeine.cache.Cache<Object,cache)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Adapt the given new native Caffeine Cache instance to Spring's {@link Cache}\n\t * abstraction for the specified cache name.\n\t * @param name the name of the cache\n\t * @param cache the native Caffeine Cache instance\n\t * @return the Spring CaffeineCache adapter (or a decorator thereof)\n\t * @since 5.2.8\n\t * @see CaffeineCache#CaffeineCache(String, com.github.benmanes.caffeine.cache.Cache, boolean)\n\t * @see #isAllowNullValues()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "com.github.benmanes.caffeine.cache.Cache<Object",
      "cache"
    ],
    "position": {
      "column": 1,
      "line": 303
    },
    "return": "Cache",
    "signature": "protected Cache adaptCaffeineCache(String name, com.github.benmanes.caffeine.cache.Cache<Object, Object> cache)",
    "source_code": "\tprotected Cache adaptCaffeineCache(String name, com.github.benmanes.caffeine.cache.Cache<Object, Object> cache) {\n\t\treturn new CaffeineCache(name, cache, isAllowNullValues());\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#createAsyncCaffeineCache(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a common Caffeine AsyncCache instance for the specified cache name,\n\t * using the common Caffeine configuration specified on this cache manager.\n\t * @param name the name of the cache\n\t * @return the Caffeine AsyncCache instance\n\t * @since 6.1\n\t * @see #createCaffeineCache\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 365
    },
    "return": "Object>",
    "signature": "protected Object> createAsyncCaffeineCache(String name)",
    "source_code": "\tprotected AsyncCache<Object, Object> createAsyncCaffeineCache(String name) {\n\t\treturn (this.cacheLoader != null ? this.cacheBuilder.buildAsync(this.cacheLoader) :\n\t\t\t\tthis.cacheBuilder.buildAsync());\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#createCaffeineCache(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a common {@link CaffeineCache} instance for the specified cache name,\n\t * using the common Caffeine configuration specified on this cache manager.\n\t * <p>Delegates to {@link #adaptCaffeineCache} as the adaptation method to\n\t * Spring's cache abstraction (allowing for centralized decoration etc),\n\t * passing in a freshly built native Caffeine Cache instance.\n\t * @param name the name of the cache\n\t * @return the Spring CaffeineCache adapter (or a decorator thereof)\n\t * @see #adaptCaffeineCache\n\t * @see #createNativeCaffeineCache\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 332
    },
    "return": "Cache",
    "signature": "protected Cache createCaffeineCache(String name)",
    "source_code": "\tprotected Cache createCaffeineCache(String name) {\n\t\treturn (this.asyncCacheMode ? adaptCaffeineCache(name, createAsyncCaffeineCache(name)) :\n\t\t\t\tadaptCaffeineCache(name, createNativeCaffeineCache(name)));\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#getCache(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "Cache",
    "signature": "public Cache getCache(String name)",
    "source_code": "\tpublic Cache getCache(String name) {\n\t\tCache cache = this.cacheMap.get(name);\n\t\tif (cache == null && this.dynamic) {\n\t\t\tcache = this.cacheMap.computeIfAbsent(name, this::createCaffeineCache);\n\t\t}\n\t\treturn cache;\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#getCacheNames()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "Collection<String>",
    "signature": "public Collection<String> getCacheNames()",
    "source_code": "\tpublic Collection<String> getCacheNames() {\n\t\treturn Collections.unmodifiableSet(this.cacheMap.keySet());\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#isAllowNullValues()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether this cache manager accepts and converts {@code null} values\n\t * for all of its caches.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "boolean",
    "signature": "public boolean isAllowNullValues()",
    "source_code": "\tpublic boolean isAllowNullValues() {\n\t\treturn this.allowNullValues;\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#registerCustomCache(name,AsyncCache<Object,cache)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register the given Caffeine AsyncCache instance with this cache manager,\n\t * adapting it to Spring's cache API for exposure through {@link #getCache}.\n\t * Any number of such custom caches may be registered side by side.\n\t * <p>This allows for custom settings per cache (as opposed to all caches\n\t * sharing the common settings in the cache manager's configuration) and\n\t * is typically used with the Caffeine builder API:\n\t * {@code registerCustomCache(\"myCache\", Caffeine.newBuilder().maximumSize(10).buildAsync())}\n\t * <p>Note that any other caches, whether statically specified through\n\t * {@link #setCacheNames} or dynamically built on demand, still operate\n\t * with the common settings in the cache manager's configuration.\n\t * @param name the name of the cache\n\t * @param cache the custom Caffeine AsyncCache instance to register\n\t * @since 6.1\n\t * @see #adaptCaffeineCache(String, AsyncCache)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "AsyncCache<Object",
      "cache"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "void",
    "signature": "public void registerCustomCache(String name, AsyncCache<Object, Object> cache)",
    "source_code": "\tpublic void registerCustomCache(String name, AsyncCache<Object, Object> cache) {\n\t\tthis.customCacheNames.add(name);\n\t\tthis.cacheMap.put(name, adaptCaffeineCache(name, cache));\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#registerCustomCache(name,com.github.benmanes.caffeine.cache.Cache<Object,cache)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register the given native Caffeine Cache instance with this cache manager,\n\t * adapting it to Spring's cache API for exposure through {@link #getCache}.\n\t * Any number of such custom caches may be registered side by side.\n\t * <p>This allows for custom settings per cache (as opposed to all caches\n\t * sharing the common settings in the cache manager's configuration) and\n\t * is typically used with the Caffeine builder API:\n\t * {@code registerCustomCache(\"myCache\", Caffeine.newBuilder().maximumSize(10).build())}\n\t * <p>Note that any other caches, whether statically specified through\n\t * {@link #setCacheNames} or dynamically built on demand, still operate\n\t * with the common settings in the cache manager's configuration.\n \t * @param name the name of the cache\n\t * @param cache the custom Caffeine Cache instance to register\n\t * @since 5.2.8\n\t * @see #adaptCaffeineCache(String, com.github.benmanes.caffeine.cache.Cache)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "com.github.benmanes.caffeine.cache.Cache<Object",
      "cache"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "void",
    "signature": "public void registerCustomCache(String name, com.github.benmanes.caffeine.cache.Cache<Object, Object> cache)",
    "source_code": "\tpublic void registerCustomCache(String name, com.github.benmanes.caffeine.cache.Cache<Object, Object> cache) {\n\t\tthis.customCacheNames.add(name);\n\t\tthis.cacheMap.put(name, adaptCaffeineCache(name, cache));\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#setAllowNullValues(allowNullValues)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether to accept and convert {@code null} values for all caches\n\t * in this cache manager.\n\t * <p>Default is \"true\", despite Caffeine itself not supporting {@code null} values.\n\t * An internal holder object will be used to store user-level {@code null}s.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "allowNullValues"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "void",
    "signature": "public void setAllowNullValues(boolean allowNullValues)",
    "source_code": "\tpublic void setAllowNullValues(boolean allowNullValues) {\n\t\tif (this.allowNullValues != allowNullValues) {\n\t\t\tthis.allowNullValues = allowNullValues;\n\t\t\trefreshCommonCaches();\n\t\t}\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#setAsyncCacheLoader(AsyncCacheLoader<Object,cacheLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Caffeine AsyncCacheLoader to use for building each individual\n\t * {@link CaffeineCache} instance, turning it into a LoadingCache.\n\t * <p>This implicitly switches the {@link #setAsyncCacheMode \"asyncCacheMode\"}\n\t * flag to {@code true}.\n\t * @since 6.1\n\t * @see #createAsyncCaffeineCache\n\t * @see Caffeine#buildAsync(AsyncCacheLoader)\n\t * @see com.github.benmanes.caffeine.cache.LoadingCache\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "AsyncCacheLoader<Object",
      "cacheLoader"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "void",
    "signature": "public void setAsyncCacheLoader(AsyncCacheLoader<Object, Object> cacheLoader)",
    "source_code": "\tpublic void setAsyncCacheLoader(AsyncCacheLoader<Object, Object> cacheLoader) {\n\t\tif (!ObjectUtils.nullSafeEquals(this.cacheLoader, cacheLoader)) {\n\t\t\tthis.cacheLoader = cacheLoader;\n\t\t\tthis.asyncCacheMode = true;\n\t\t\trefreshCommonCaches();\n\t\t}\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#setAsyncCacheMode(asyncCacheMode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the common cache type that this cache manager builds to async.\n\t * This applies to {@link #setCacheNames} as well as on-demand caches.\n\t * <p>Individual cache registrations (such as {@link #registerCustomCache(String, AsyncCache)}\n\t * and {@link #registerCustomCache(String, com.github.benmanes.caffeine.cache.Cache)}\n\t * are not dependent on this setting.\n\t * <p>By default, this cache manager builds regular native Caffeine caches.\n\t * To switch to async caches which can also be used through the synchronous API\n\t * but come with support for {@code Cache#retrieve}, set this flag to {@code true}.\n\t * @since 6.1\n\t * @see Caffeine#buildAsync()\n\t * @see Cache#retrieve(Object)\n\t * @see Cache#retrieve(Object, Supplier)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "asyncCacheMode"
    ],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "void",
    "signature": "public void setAsyncCacheMode(boolean asyncCacheMode)",
    "source_code": "\tpublic void setAsyncCacheMode(boolean asyncCacheMode) {\n\t\tif (this.asyncCacheMode != asyncCacheMode) {\n\t\t\tthis.asyncCacheMode = asyncCacheMode;\n\t\t\trefreshCommonCaches();\n\t\t}\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#setCacheLoader(CacheLoader<Object,cacheLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Caffeine CacheLoader to use for building each individual\n\t * {@link CaffeineCache} instance, turning it into a LoadingCache.\n\t * @see #createNativeCaffeineCache\n\t * @see Caffeine#build(CacheLoader)\n\t * @see com.github.benmanes.caffeine.cache.LoadingCache\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "CacheLoader<Object",
      "cacheLoader"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "void",
    "signature": "public void setCacheLoader(CacheLoader<Object, Object> cacheLoader)",
    "source_code": "\tpublic void setCacheLoader(CacheLoader<Object, Object> cacheLoader) {\n\t\tif (!ObjectUtils.nullSafeEquals(this.cacheLoader, cacheLoader)) {\n\t\t\tthis.cacheLoader = cacheLoader;\n\t\t\trefreshCommonCaches();\n\t\t}\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#setCacheNames(cacheNames)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the set of cache names for this CacheManager's 'static' mode.\n\t * <p>The number of caches and their names will be fixed after a call to this method,\n\t * with no creation of further cache regions at runtime.\n\t * <p>Calling this with a {@code null} collection argument resets the\n\t * mode to 'dynamic', allowing for further creation of caches again.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cacheNames"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "void",
    "signature": "public void setCacheNames(@Nullable Collection<String> cacheNames)",
    "source_code": "\tpublic void setCacheNames(@Nullable Collection<String> cacheNames) {\n\t\tif (cacheNames != null) {\n\t\t\tfor (String name : cacheNames) {\n\t\t\t\tthis.cacheMap.put(name, createCaffeineCache(name));\n\t\t\t}\n\t\t\tthis.dynamic = false;\n\t\t}\n\t\telse {\n\t\t\tthis.dynamic = true;\n\t\t}\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#setCacheSpecification(cacheSpecification)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Caffeine cache specification String to use for building each\n\t * individual {@link CaffeineCache} instance. The given value needs to\n\t * comply with Caffeine's {@link CaffeineSpec} (see its javadoc).\n\t * @see #createNativeCaffeineCache\n\t * @see Caffeine#from(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cacheSpecification"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "void",
    "signature": "public void setCacheSpecification(String cacheSpecification)",
    "source_code": "\tpublic void setCacheSpecification(String cacheSpecification) {\n\t\tdoSetCaffeine(Caffeine.from(cacheSpecification));\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#setCaffeine(Caffeine<Object,caffeine)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Caffeine to use for building each individual\n\t * {@link CaffeineCache} instance.\n\t * @see #createNativeCaffeineCache\n\t * @see Caffeine#build()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Caffeine<Object",
      "caffeine"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void setCaffeine(Caffeine<Object, Object> caffeine)",
    "source_code": "\tpublic void setCaffeine(Caffeine<Object, Object> caffeine) {\n\t\tAssert.notNull(caffeine, \"Caffeine must not be null\");\n\t\tdoSetCaffeine(caffeine);\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#setCaffeineSpec(caffeineSpec)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link CaffeineSpec} to use for building each individual\n\t * {@link CaffeineCache} instance.\n\t * @see #createNativeCaffeineCache\n\t * @see Caffeine#from(CaffeineSpec)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "caffeineSpec"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "void",
    "signature": "public void setCaffeineSpec(CaffeineSpec caffeineSpec)",
    "source_code": "\tpublic void setCaffeineSpec(CaffeineSpec caffeineSpec) {\n\t\tdoSetCaffeine(Caffeine.from(caffeineSpec));\n\t}"
  },
  "org.springframework.cache.interceptor.CacheAspectSupport#apply(result)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "result"
    ],
    "position": {
      "column": 1,
      "line": 925
    },
    "return": "Object",
    "signature": "public Object apply(@Nullable Object result)",
    "source_code": "\t\tpublic Object apply(@Nullable Object result) {\n\t\t\tif (result instanceof CompletableFuture<?> future) {\n\t\t\t\treturn future.whenComplete((value, ex) -> {\n\t\t\t\t\tif (ex != null) {\n\t\t\t\t\t\tperformEvict(ex);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tperformPut(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (reactiveCachingHandler != null) {\n\t\t\t\tObject returnValue = reactiveCachingHandler.processPutRequest(this, result);\n\t\t\t\tif (returnValue != ReactiveCachingHandler.NOT_HANDLED) {\n\t\t\t\t\treturn returnValue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tperformPut(result);\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.cache.interceptor.CacheAspectSupport#executeSynchronized(invoker,method,cache,key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "invoker",
      "method",
      "cache",
      "key"
    ],
    "position": {
      "column": 1,
      "line": 1010
    },
    "return": "Object",
    "signature": "public Object executeSynchronized(CacheOperationInvoker invoker, Method method, Cache cache, Object key)",
    "source_code": "\t\tpublic Object executeSynchronized(CacheOperationInvoker invoker, Method method, Cache cache, Object key) {\n\t\t\tReactiveAdapter adapter = this.registry.getAdapter(method.getReturnType());\n\t\t\tif (adapter != null) {\n\t\t\t\tif (adapter.isMultiValue()) {\n\t\t\t\t\t// Flux or similar\n\t\t\t\t\treturn adapter.fromPublisher(Flux.from(Mono.fromFuture(\n\t\t\t\t\t\t\tcache.retrieve(key,\n\t\t\t\t\t\t\t\t\t() -> Flux.from(adapter.toPublisher(invokeOperation(invoker))).collectList().toFuture())))\n\t\t\t\t\t\t\t.flatMap(Flux::fromIterable));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Mono or similar\n\t\t\t\t\treturn adapter.fromPublisher(Mono.fromFuture(\n\t\t\t\t\t\t\tcache.retrieve(key,\n\t\t\t\t\t\t\t\t\t() -> Mono.from(adapter.toPublisher(invokeOperation(invoker))).toFuture())));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn NOT_HANDLED;\n\t\t}"
  },
  "org.springframework.cache.interceptor.CacheAspectSupport#findInCaches(context,cache,key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "cache",
      "key"
    ],
    "position": {
      "column": 1,
      "line": 1041
    },
    "return": "Object",
    "signature": "public Object findInCaches(CacheOperationContext context, Cache cache, Object key)",
    "source_code": "\t\tpublic Object findInCaches(CacheOperationContext context, Cache cache, Object key) {\n\t\t\tReactiveAdapter adapter = this.registry.getAdapter(context.getMethod().getReturnType());\n\t\t\tif (adapter != null) {\n\t\t\t\tCompletableFuture<?> cachedFuture = cache.retrieve(key);\n\t\t\t\tif (cachedFuture == null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (adapter.isMultiValue()) {\n\t\t\t\t\treturn adapter.fromPublisher(Flux.from(Mono.fromFuture(cachedFuture))\n\t\t\t\t\t\t\t.flatMap(v -> (v instanceof Iterable<?> iv ? Flux.fromIterable(iv) : Flux.just(v))));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn adapter.fromPublisher(Mono.fromFuture(cachedFuture));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn NOT_HANDLED;\n\t\t}"
  },
  "org.springframework.cache.interceptor.CacheAspectSupport#onComplete()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 994
    },
    "return": "void",
    "signature": "public void onComplete()",
    "source_code": "\t\tpublic void onComplete() {\n\t\t\tthis.request.performPut(this.cacheValue);\n\t\t}"
  },
  "org.springframework.cache.interceptor.CacheAspectSupport#onError(t)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "t"
    ],
    "position": {
      "column": 1,
      "line": 990
    },
    "return": "void",
    "signature": "public void onError(Throwable t)",
    "source_code": "\t\tpublic void onError(Throwable t) {\n\t\t\tthis.request.performEvict(t);\n\t\t}"
  },
  "org.springframework.cache.interceptor.CacheAspectSupport#onNext(o)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o"
    ],
    "position": {
      "column": 1,
      "line": 986
    },
    "return": "void",
    "signature": "public void onNext(Object o)",
    "source_code": "\t\tpublic void onNext(Object o) {\n\t\t\tthis.cacheValue.add(o);\n\t\t}"
  },
  "org.springframework.cache.interceptor.CacheAspectSupport#onSubscribe(s)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "s"
    ],
    "position": {
      "column": 1,
      "line": 982
    },
    "return": "void",
    "signature": "public void onSubscribe(Subscription s)",
    "source_code": "\t\tpublic void onSubscribe(Subscription s) {\n\t\t\ts.request(Integer.MAX_VALUE);\n\t\t}"
  },
  "org.springframework.cache.interceptor.CacheAspectSupport#processCacheEvicts(contexts,result)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contexts",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 1031
    },
    "return": "Object",
    "signature": "public Object processCacheEvicts(List<CacheOperationContext> contexts, @Nullable Object result)",
    "source_code": "\t\tpublic Object processCacheEvicts(List<CacheOperationContext> contexts, @Nullable Object result) {\n\t\t\tReactiveAdapter adapter = (result != null ? this.registry.getAdapter(result.getClass()) : null);\n\t\t\tif (adapter != null) {\n\t\t\t\treturn adapter.fromPublisher(Mono.from(adapter.toPublisher(result))\n\t\t\t\t\t\t.doOnSuccess(value -> performCacheEvicts(contexts, result)));\n\t\t\t}\n\t\t\treturn NOT_HANDLED;\n\t\t}"
  },
  "org.springframework.cache.interceptor.CacheAspectSupport#processPutRequest(request,result)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 1060
    },
    "return": "Object",
    "signature": "public Object processPutRequest(CachePutRequest request, @Nullable Object result)",
    "source_code": "\t\tpublic Object processPutRequest(CachePutRequest request, @Nullable Object result) {\n\t\t\tReactiveAdapter adapter = (result != null ? this.registry.getAdapter(result.getClass()) : null);\n\t\t\tif (adapter != null) {\n\t\t\t\tif (adapter.isMultiValue()) {\n\t\t\t\t\tFlux<?> source = Flux.from(adapter.toPublisher(result));\n\t\t\t\t\tsource.subscribe(new CachePutListSubscriber(request));\n\t\t\t\t\treturn adapter.fromPublisher(source);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn adapter.fromPublisher(Mono.from(adapter.toPublisher(result))\n\t\t\t\t\t\t\t.doOnSuccess(request::performPut).doOnError(request::performEvict));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn NOT_HANDLED;\n\t\t}"
  },
  "org.springframework.cache.interceptor.NOT_HANDLED": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 1005
    },
    "signature": "public Object NOT_HANDLED",
    "source_code": "\t\tpublic static final Object NOT_HANDLED = new Object();",
    "type": "Object"
  },
  "org.springframework.cache.interceptor.SimpleKey#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj ||\n\t\t\t\t(obj instanceof SimpleKey that && Arrays.deepEquals(this.params, that.params)));\n\t}"
  },
  "org.springframework.cache.interceptor.SimpleKey#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof SimpleKey that && Arrays.deepEquals(this.params, that.params)));\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj ||\n\t\t\t\t(obj instanceof BeanMethod that && this.metadata.equals(that.metadata)));\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof BeanMethod that && this.metadata.equals(that.metadata)));\n\t}"
  },
  "org.springframework.context.annotation.ClassPathBeanDefinitionScanner#isCompatible(newDef,existingDef)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given new bean definition is compatible with\n\t * the given existing bean definition.\n\t * <p>The default implementation considers them as compatible when the existing\n\t * bean definition comes from the same source or from a non-scanning source.\n\t * @param newDef the new bean definition, originated from scanning\n\t * @param existingDef the existing bean definition, potentially an\n\t * explicitly defined one or a previously generated one from scanning\n\t * @return whether the definitions are considered as compatible, with the\n\t * new definition to be skipped in favor of the existing definition\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "newDef",
      "existingDef"
    ],
    "position": {
      "column": 1,
      "line": 375
    },
    "return": "boolean",
    "signature": "protected boolean isCompatible(BeanDefinition newDef, BeanDefinition existingDef)",
    "source_code": "\tprotected boolean isCompatible(BeanDefinition newDef, BeanDefinition existingDef) {\n\t\treturn ((newDef.getSource() != null && newDef.getSource().equals(existingDef.getSource())) ||\n\t\t\t\tnewDef.equals(existingDef));\n\t}"
  },
  "org.springframework.context.annotation.ClassPathBeanDefinitionScanner#isCompatible(newDefinition,existingDefinition)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given new bean definition is compatible with\n\t * the given existing bean definition.\n\t * <p>The default implementation considers them as compatible when the existing\n\t * bean definition comes from the same source or from a non-scanning source.\n\t * @param newDefinition the new bean definition, originated from scanning\n\t * @param existingDefinition the existing bean definition, potentially an\n\t * explicitly defined one or a previously generated one from scanning\n\t * @return whether the definitions are considered as compatible, with the\n\t * new definition to be skipped in favor of the existing definition\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "newDefinition",
      "existingDefinition"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "boolean",
    "signature": "protected boolean isCompatible(BeanDefinition newDefinition, BeanDefinition existingDefinition)",
    "source_code": "\tprotected boolean isCompatible(BeanDefinition newDefinition, BeanDefinition existingDefinition) {\n\t\treturn (!(existingDefinition instanceof ScannedGenericBeanDefinition) ||  // explicitly registered overriding bean\n\t\t\t\t(newDefinition.getSource() != null && newDefinition.getSource().equals(existingDefinition.getSource())) ||  // scanned same file twice\n\t\t\t\tnewDefinition.equals(existingDefinition));  // scanned equivalent class twice\n\t}"
  },
  "org.springframework.context.support.GenericApplicationContext#isBeanDefinitionOverridable(beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 364
    },
    "return": "boolean",
    "signature": "public boolean isBeanDefinitionOverridable(String beanName)",
    "source_code": "\tpublic boolean isBeanDefinitionOverridable(String beanName) {\n\t\treturn this.beanFactory.isBeanDefinitionOverridable(beanName);\n\t}"
  },
  "org.springframework.context.support.ReloadableResourceBundleMessageSource#setFileExtensions(fileExtensions)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the list of supported file extensions.\n\t * <p>The default is a list containing {@code .properties} and {@code .xml}.\n\t * @param fileExtensions the file extensions (starts with a dot)\n\t * @since 6.1.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fileExtensions"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "void",
    "signature": "public void setFileExtensions(List<String> fileExtensions)",
    "source_code": "\tpublic void setFileExtensions(List<String> fileExtensions) {\n\t\tAssert.isTrue(!CollectionUtils.isEmpty(fileExtensions), \"At least one file extension is required\");\n\t\tfor (String extension : fileExtensions) {\n\t\t\tif (!extension.startsWith(\".\")) {\n\t\t\t\tthrow new IllegalArgumentException(\"File extension '\" + extension + \"' should start with '.'\");\n\t\t\t}\n\t\t}\n\t\tthis.fileExtensions = Collections.unmodifiableList(fileExtensions);\n\t}"
  },
  "org.springframework.core.AttributeAccessorSupport#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof AttributeAccessorSupport that &&\n\t\t\t\tthis.attributes.equals(that.attributes)));\n\t}"
  },
  "org.springframework.core.AttributeAccessorSupport#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof AttributeAccessorSupport that &&\n\t\t\t\tthis.attributes.equals(that.attributes)));\n\t}"
  },
  "org.springframework.core.ParameterizedTypeReference#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof ParameterizedTypeReference<?> that && this.type.equals(that.type)));\n\t}"
  },
  "org.springframework.core.ParameterizedTypeReference#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof ParameterizedTypeReference<?> that && this.type.equals(that.type)));\n\t}"
  },
  "org.springframework.core.ReactiveAdapterRegistry#cancel()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 415
    },
    "return": "void",
    "signature": "public void cancel()",
    "source_code": "\t\t\tpublic void cancel() {\n\t\t\t}"
  },
  "org.springframework.core.ReactiveAdapterRegistry#registerReactiveTypeOverride(descriptor,Function<Object,toAdapter,Function<Publisher<?>,fromAdapter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a reactive type along with functions to adapt to and from a\n\t * Reactive Streams {@link Publisher}. The function arguments assume that\n\t * their input is neither {@code null} nor {@link Optional}.\n\t * <p>This variant registers the new adapter first, effectively overriding\n\t * any previously registered adapters for the same reactive type. This allows\n\t * for overriding existing adapters, in particular default adapters.\n\t * <p>Note that existing adapters for specific types will still match before\n\t * an assignability match with the new adapter. In order to override all\n\t * existing matches, a new reactive type adapter needs to be registered\n\t * for every specific type, not relying on subtype assignability matches.\n\t * @since 5.3.30\n\t * @see #registerReactiveType\n\t * @see #getAdapter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "Function<Object",
      "toAdapter",
      "Function<Publisher<?>",
      "fromAdapter"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "void",
    "signature": "public void registerReactiveTypeOverride(ReactiveTypeDescriptor descriptor,\n\t\t\tFunction<Object, Publisher<?>> toAdapter, Function<Publisher<?>, Object> fromAdapter)",
    "source_code": "\tpublic void registerReactiveTypeOverride(ReactiveTypeDescriptor descriptor,"
  },
  "org.springframework.core.ReactiveAdapterRegistry#request(n)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "n"
    ],
    "position": {
      "column": 1,
      "line": 412
    },
    "return": "void",
    "signature": "public void request(long n)",
    "source_code": "\t\t\tpublic void request(long n) {\n\t\t\t}"
  },
  "org.springframework.core.convert.TypeDescriptor#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 782
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object obj) {\n\t\t\treturn (this == obj || (obj instanceof AnnotatedElementAdapter that &&\n\t\t\t\t\tArrays.equals(this.annotations, that.annotations)));\n\t\t}"
  },
  "org.springframework.core.env.<unknown>#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object obj) {\n\t\t\tif (this == obj) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (obj == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (getClass() != obj.getClass()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tParsedProfiles that = (ParsedProfiles) obj;\n\t\t\treturn this.expressions.equals(that.expressions);\n\t\t}"
  },
  "org.springframework.core.env.<unknown>#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other || (other instanceof ParsedProfiles that &&\n\t\t\t\t\tthis.expressions.equals(that.expressions)));\n\t\t}"
  },
  "org.springframework.core.env.PropertySource#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * This {@code PropertySource} object is equal to the given object if:\n\t * <ul>\n\t * <li>they are the same instance\n\t * <li>the {@code name} properties for both objects are equal\n\t * </ul>\n\t * <p>No properties other than {@code name} are evaluated.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof PropertySource<?> other &&\n\t\t\t\tObjectUtils.nullSafeEquals(getName(), other.getName())));\n\t}"
  },
  "org.springframework.core.env.PropertySource#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This {@code PropertySource} object is equal to the given object if:\n\t * <ul>\n\t * <li>they are the same instance\n\t * <li>the {@code name} properties for both objects are equal\n\t * </ul>\n\t * <p>No properties other than {@code name} are evaluated.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof PropertySource<?> that &&\n\t\t\t\tObjectUtils.nullSafeEquals(getName(), that.getName())));\n\t}"
  },
  "org.springframework.core.io.AbstractResource#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation compares description strings.\n\t * @see #getDescription()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof Resource that &&\n\t\t\t\tgetDescription().equals(that.getDescription())));\n\t}"
  },
  "org.springframework.core.io.AbstractResource#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation compares description strings.\n\t * @see #getDescription()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof Resource that &&\n\t\t\t\tgetDescription().equals(that.getDescription())));\n\t}"
  },
  "org.springframework.core.io.ByteArrayResource#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation compares the underlying byte array.\n\t * @see java.util.Arrays#equals(byte[], byte[])\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof ByteArrayResource that &&\n\t\t\t\tArrays.equals(this.byteArray, that.byteArray)));\n\t}"
  },
  "org.springframework.core.io.ByteArrayResource#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation compares the underlying byte array.\n\t * @see java.util.Arrays#equals(byte[], byte[])\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof ByteArrayResource that &&\n\t\t\t\tArrays.equals(this.byteArray, that.byteArray)));\n\t}"
  },
  "org.springframework.core.io.ClassPathResource#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation compares the underlying class path locations and\n\t * associated class loaders.\n\t * @see #getPath()\n\t * @see #getClassLoader()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 275
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\tif (this == obj) {\n\t\t\treturn true;\n\t\t}\n\t\treturn (obj instanceof ClassPathResource that &&\n\t\t\t\tthis.absolutePath.equals(that.absolutePath) &&\n\t\t\t\tObjectUtils.nullSafeEquals(getClassLoader(), that.getClassLoader()));\n\t}"
  },
  "org.springframework.core.io.ClassPathResource#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation compares the underlying class path locations and\n\t * associated class loaders.\n\t * @see #getPath()\n\t * @see #getClassLoader()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 275
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof ClassPathResource that &&\n\t\t\t\tthis.absolutePath.equals(that.absolutePath) &&\n\t\t\t\tObjectUtils.nullSafeEquals(getClassLoader(), that.getClassLoader())));\n\t}"
  },
  "org.springframework.core.io.DescriptiveResource#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation compares the underlying description String.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof DescriptiveResource that &&\n\t\t\t\tthis.description.equals(that.description)));\n\t}"
  },
  "org.springframework.core.io.DescriptiveResource#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation compares the underlying description String.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof DescriptiveResource that &&\n\t\t\t\tthis.description.equals(that.description)));\n\t}"
  },
  "org.springframework.core.io.FileSystemResource#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation compares the underlying file paths.\n\t * @see #getPath()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 398
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof FileSystemResource that && this.path.equals(that.path)));\n\t}"
  },
  "org.springframework.core.io.FileSystemResource#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation compares the underlying file paths.\n\t * @see #getPath()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 398
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof FileSystemResource that && this.path.equals(that.path)));\n\t}"
  },
  "org.springframework.core.io.InputStreamResource#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation compares the underlying InputStream.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof InputStreamResource that &&\n\t\t\t\tthis.inputStream.equals(that.inputStream)));\n\t}"
  },
  "org.springframework.core.io.InputStreamResource#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation compares the underlying InputStream.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof InputStreamResource that &&\n\t\t\t\tthis.inputStream.equals(that.inputStream)));\n\t}"
  },
  "org.springframework.core.io.PathResource#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation compares the underlying {@link Path} references.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 301
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof PathResource that && this.path.equals(that.path)));\n\t}"
  },
  "org.springframework.core.io.PathResource#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation compares the underlying {@link Path} references.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 301
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof PathResource that && this.path.equals(that.path)));\n\t}"
  },
  "org.springframework.core.io.UrlResource#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation compares the underlying URL references.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 344
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof UrlResource that &&\n\t\t\t\tgetCleanedUrl().equals(that.getCleanedUrl())));\n\t}"
  },
  "org.springframework.core.io.UrlResource#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation compares the underlying URL references.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 344
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof UrlResource that &&\n\t\t\t\tgetCleanedUrl().equals(that.getCleanedUrl())));\n\t}"
  },
  "org.springframework.core.io.VfsResource#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof VfsResource that &&\n\t\t\t\tthis.resource.equals(that.resource)));\n\t}"
  },
  "org.springframework.core.io.VfsResource#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof VfsResource that && this.resource.equals(that.resource)));\n\t}"
  },
  "org.springframework.core.io.buffer.Netty5DataBuffer#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 340
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof Netty5DataBuffer that && this.buffer.equals(that.buffer)));\n\t}"
  },
  "org.springframework.core.io.buffer.Netty5DataBuffer#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 340
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof Netty5DataBuffer that && this.buffer.equals(that.buffer)));\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 366
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof NettyDataBuffer that && this.byteBuf.equals(that.byteBuf)));\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 366
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof NettyDataBuffer that && this.byteBuf.equals(that.byteBuf)));\n\t}"
  },
  "org.springframework.core.test.tools.<unknown>#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof DynamicFiles<?> that && this.files.equals(that.files)));\n\t}"
  },
  "org.springframework.core.test.tools.<unknown>#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.files.hashCode();\n\t}"
  },
  "org.springframework.core.test.tools.<unknown>#iterator()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "Iterator<F>",
    "signature": "public Iterator<F> iterator()",
    "source_code": "\tpublic Iterator<F> iterator() {\n\t\treturn this.files.values().iterator();\n\t}"
  },
  "org.springframework.core.test.tools.<unknown>#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn this.files.toString();\n\t}"
  },
  "org.springframework.core.test.tools.ClassFiles": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * An immutable collection of {@link ClassFile} instances.\n *\n * @author Stephane Nicoll\n * @since 6.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 34
    },
    "signature": "public class ClassFiles",
    "source_code": "public final class ClassFiles implements Iterable<ClassFile> {\n\n\tprivate static final ClassFiles NONE = new ClassFiles(Collections.emptyMap());\n\n\n\tprivate final Map<String, ClassFile> files;\n\n\tprivate ClassFiles(Map<String, ClassFile> files) {\n\t\tthis.files = files;\n\t}\n\n\n\t/**\n\t * Return a {@link ClassFiles} instance with no items.\n\t * @return the empty instance\n\t */\n\tpublic static ClassFiles none() {\n\t\treturn NONE;\n\t}\n\n\t/**\n\t * Factory method that can be used to create a {@link ClassFiles}\n\t * instance containing the specified classes.\n\t * @param ClassFiles the classes to include\n\t * @return a {@link ClassFiles} instance\n\t */\n\tpublic static ClassFiles of(ClassFile... ClassFiles) {\n\t\treturn none().and(ClassFiles);\n\t}\n\n\n\t/**\n\t * Return a new {@link ClassFiles} instance that merges classes from\n\t * another array of {@link ClassFile} instances.\n\t * @param classFiles the instances to merge\n\t * @return a new {@link ClassFiles} instance containing merged content\n\t */\n\tpublic ClassFiles and(ClassFile... classFiles) {\n\t\tMap<String, ClassFile> merged = new LinkedHashMap<>(this.files);\n\t\tArrays.stream(classFiles).forEach(file -> merged.put(file.getName(), file));\n\t\treturn new ClassFiles(Collections.unmodifiableMap(merged));\n\t}\n\n\t/**\n\t * Return a new {@link ClassFiles} instance that merges classes from another\n\t * iterable of {@link ClassFiles} instances.\n\t * @param classFiles the instances to merge\n\t * @return a new {@link ClassFiles} instance containing merged content\n\t */\n\tpublic ClassFiles and(Iterable<ClassFile> classFiles) {\n\t\tMap<String, ClassFile> merged = new LinkedHashMap<>(this.files);\n\t\tclassFiles.forEach(file -> merged.put(file.getName(), file));\n\t\treturn new ClassFiles(Collections.unmodifiableMap(merged));\n\t}\n\n\t@Override\n\tpublic Iterator<ClassFile> iterator() {\n\t\treturn this.files.values().iterator();\n\t}\n\n\t/**\n\t * Stream the {@link ClassFile} instances contained in this collection.\n\t * @return a stream of classes\n\t */\n\tpublic Stream<ClassFile> stream() {\n\t\treturn this.files.values().stream();\n\t}\n\n\t/**\n\t * Returns {@code true} if this collection is empty.\n\t * @return if this collection is empty\n\t */\n\tpublic boolean isEmpty() {\n\t\treturn this.files.isEmpty();\n\t}\n\n\t/**\n\t * Get the {@link ClassFile} with the given class name.\n\t * @param name the fully qualified name to find\n\t * @return a {@link ClassFile} instance or {@code null}\n\t */\n\t@Nullable\n\tpublic ClassFile get(String name) {\n\t\treturn this.files.get(name);\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof ClassFiles that && this.files.equals(that.files)));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.files.hashCode();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn this.files.toString();\n\t}\n\n}"
  },
  "org.springframework.core.test.tools.ClassFiles#and(classFiles)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a new {@link ClassFiles} instance that merges classes from another\n\t * iterable of {@link ClassFiles} instances.\n\t * @param classFiles the instances to merge\n\t * @return a new {@link ClassFiles} instance containing merged content\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classFiles"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "ClassFiles",
    "signature": "public ClassFiles and(Iterable<ClassFile> classFiles)",
    "source_code": "\tpublic ClassFiles and(Iterable<ClassFile> classFiles) {\n\t\tMap<String, ClassFile> merged = new LinkedHashMap<>(this.files);\n\t\tclassFiles.forEach(file -> merged.put(file.getName(), file));\n\t\treturn new ClassFiles(Collections.unmodifiableMap(merged));\n\t}"
  },
  "org.springframework.core.test.tools.ClassFiles#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof ClassFiles that && this.files.equals(that.files)));\n\t}"
  },
  "org.springframework.core.test.tools.ClassFiles#get(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the {@link ClassFile} with the given class name.\n\t * @param name the fully qualified name to find\n\t * @return a {@link ClassFile} instance or {@code null}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "ClassFile",
    "signature": "public ClassFile get(String name)",
    "source_code": "\tpublic ClassFile get(String name) {\n\t\treturn this.files.get(name);\n\t}"
  },
  "org.springframework.core.test.tools.ClassFiles#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.files.hashCode();\n\t}"
  },
  "org.springframework.core.test.tools.ClassFiles#isEmpty()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns {@code true} if this collection is empty.\n\t * @return if this collection is empty\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "boolean",
    "signature": "public boolean isEmpty()",
    "source_code": "\tpublic boolean isEmpty() {\n\t\treturn this.files.isEmpty();\n\t}"
  },
  "org.springframework.core.test.tools.ClassFiles#iterator()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "Iterator<ClassFile>",
    "signature": "public Iterator<ClassFile> iterator()",
    "source_code": "\tpublic Iterator<ClassFile> iterator() {\n\t\treturn this.files.values().iterator();\n\t}"
  },
  "org.springframework.core.test.tools.ClassFiles#none()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ClassFiles} instance with no items.\n\t * @return the empty instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 50
    },
    "return": "ClassFiles",
    "signature": "public ClassFiles none()",
    "source_code": "\tpublic static ClassFiles none() {\n\t\treturn NONE;\n\t}"
  },
  "org.springframework.core.test.tools.ClassFiles#of(ClassFiles)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Factory method that can be used to create a {@link ClassFiles}\n\t * instance containing the specified classes.\n\t * @param ClassFiles the classes to include\n\t * @return a {@link ClassFiles} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ClassFiles"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "ClassFiles",
    "signature": "public ClassFiles of(ClassFile... ClassFiles)",
    "source_code": "\tpublic static ClassFiles of(ClassFile... ClassFiles) {\n\t\treturn none().and(ClassFiles);\n\t}"
  },
  "org.springframework.core.test.tools.ClassFiles#stream()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Stream the {@link ClassFile} instances contained in this collection.\n\t * @return a stream of classes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "Stream<ClassFile>",
    "signature": "public Stream<ClassFile> stream()",
    "source_code": "\tpublic Stream<ClassFile> stream() {\n\t\treturn this.files.values().stream();\n\t}"
  },
  "org.springframework.core.test.tools.ClassFiles#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn this.files.toString();\n\t}"
  },
  "org.springframework.core.test.tools.DynamicFile#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\tif (this == obj) {\n\t\t\treturn true;\n\t\t}\n\t\tif (obj == null || getClass() != obj.getClass()) {\n\t\t\treturn false;\n\t\t}\n\t\tDynamicFile other = (DynamicFile) obj;\n\t\treturn Objects.equals(this.path, other.path)\n\t\t\t\t&& Objects.equals(this.content, other.content);\n\t}"
  },
  "org.springframework.core.test.tools.DynamicFile#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof DynamicFile that &&\n\t\t\t\tthis.path.equals(that.path) && this.content.equals(that.content)));\n\t}"
  },
  "org.springframework.core.test.tools.ResourceFiles": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * An immutable collection of {@link ResourceFile} instances.\n *\n * @author Phillip Webb\n * @since 6.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 30
    },
    "signature": "public class ResourceFiles",
    "source_code": "public final class ResourceFiles implements Iterable<ResourceFile> {\n\n\tprivate static final ResourceFiles NONE = new ResourceFiles(DynamicFiles.none());\n\n\n\tprivate final DynamicFiles<ResourceFile> files;\n\n\n\tprivate ResourceFiles(DynamicFiles<ResourceFile> files) {\n\t\tthis.files = files;\n\t}\n\n\n\t/**\n\t * Return a {@link DynamicFiles} instance with no items.\n\t * @return the empty instance\n\t */\n\tpublic static ResourceFiles none() {\n\t\treturn NONE;\n\t}\n\n\t/**\n\t * Factory method that can be used to create a {@link ResourceFiles}\n\t * instance containing the specified files.\n\t * @param ResourceFiles the files to include\n\t * @return a {@link ResourceFiles} instance\n\t */\n\tpublic static ResourceFiles of(ResourceFile... ResourceFiles) {\n\t\treturn none().and(ResourceFiles);\n\t}\n\n\t/**\n\t * Return a new {@link ResourceFiles} instance that merges files from\n\t * another array of {@link ResourceFile} instances.\n\t * @param resourceFiles the instances to merge\n\t * @return a new {@link ResourceFiles} instance containing merged content\n\t */\n\tpublic ResourceFiles and(ResourceFile... resourceFiles) {\n\t\treturn new ResourceFiles(this.files.and(resourceFiles));\n\t}\n\n\t/**\n\t * Return a new {@link ResourceFiles} instance that merges files from another iterable\n\t * of {@link ResourceFiles} instances.\n\t * @param resourceFiles the instances to merge\n\t * @return a new {@link ResourceFiles} instance containing merged content\n\t */\n\tpublic ResourceFiles and(Iterable<ResourceFile> resourceFiles) {\n\t\treturn new ResourceFiles(this.files.and(resourceFiles));\n\t}\n\n\t/**\n\t * Return a new {@link ResourceFiles} instance that merges files from\n\t * another {@link ResourceFiles} instance.\n\t * @param ResourceFiles the instance to merge\n\t * @return a new {@link ResourceFiles} instance containing merged content\n\t */\n\tpublic ResourceFiles and(ResourceFiles ResourceFiles) {\n\t\treturn new ResourceFiles(this.files.and(ResourceFiles.files));\n\t}\n\n\t@Override\n\tpublic Iterator<ResourceFile> iterator() {\n\t\treturn this.files.iterator();\n\t}\n\n\t/**\n\t * Stream the {@link ResourceFile} instances contained in this collection.\n\t * @return a stream of file instances\n\t */\n\tpublic Stream<ResourceFile> stream() {\n\t\treturn this.files.stream();\n\t}\n\n\t/**\n\t * Returns {@code true} if this collection is empty.\n\t * @return if this collection is empty\n\t */\n\tpublic boolean isEmpty() {\n\t\treturn this.files.isEmpty();\n\t}\n\n\t/**\n\t * Get the {@link ResourceFile} with the given\n\t * {@linkplain  DynamicFile#getPath() path}.\n\t * @param path the path to find\n\t * @return a {@link ResourceFile} instance or {@code null}\n\t */\n\t@Nullable\n\tpublic ResourceFile get(String path) {\n\t\treturn this.files.get(path);\n\t}\n\n\t/**\n\t * Return the single {@link ResourceFile} contained in the collection.\n\t * @return the single file\n\t * @throws IllegalStateException if the collection doesn't contain exactly\n\t * one file\n\t */\n\tpublic ResourceFile getSingle() throws IllegalStateException {\n\t\treturn this.files.getSingle();\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof ResourceFiles that && this.files.equals(that.files)));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.files.hashCode();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn this.files.toString();\n\t}\n\n}"
  },
  "org.springframework.core.test.tools.ResourceFiles#and(ResourceFiles)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a new {@link ResourceFiles} instance that merges files from\n\t * another {@link ResourceFiles} instance.\n\t * @param ResourceFiles the instance to merge\n\t * @return a new {@link ResourceFiles} instance containing merged content\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ResourceFiles"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "ResourceFiles",
    "signature": "public ResourceFiles and(ResourceFiles ResourceFiles)",
    "source_code": "\tpublic ResourceFiles and(ResourceFiles ResourceFiles) {\n\t\treturn new ResourceFiles(this.files.and(ResourceFiles.files));\n\t}"
  },
  "org.springframework.core.test.tools.ResourceFiles#and(resourceFiles)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a new {@link ResourceFiles} instance that merges files from another iterable\n\t * of {@link ResourceFiles} instances.\n\t * @param resourceFiles the instances to merge\n\t * @return a new {@link ResourceFiles} instance containing merged content\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resourceFiles"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "ResourceFiles",
    "signature": "public ResourceFiles and(Iterable<ResourceFile> resourceFiles)",
    "source_code": "\tpublic ResourceFiles and(Iterable<ResourceFile> resourceFiles) {\n\t\treturn new ResourceFiles(this.files.and(resourceFiles));\n\t}"
  },
  "org.springframework.core.test.tools.ResourceFiles#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof ResourceFiles that && this.files.equals(that.files)));\n\t}"
  },
  "org.springframework.core.test.tools.ResourceFiles#get(path)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the {@link ResourceFile} with the given\n\t * {@linkplain  DynamicFile#getPath() path}.\n\t * @param path the path to find\n\t * @return a {@link ResourceFile} instance or {@code null}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "ResourceFile",
    "signature": "public ResourceFile get(String path)",
    "source_code": "\tpublic ResourceFile get(String path) {\n\t\treturn this.files.get(path);\n\t}"
  },
  "org.springframework.core.test.tools.ResourceFiles#getSingle()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the single {@link ResourceFile} contained in the collection.\n\t * @return the single file\n\t * @throws IllegalStateException if the collection doesn't contain exactly\n\t * one file\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "ResourceFile",
    "signature": "public ResourceFile getSingle()",
    "source_code": "\tpublic ResourceFile getSingle() throws IllegalStateException {\n\t\treturn this.files.getSingle();\n\t}"
  },
  "org.springframework.core.test.tools.ResourceFiles#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.files.hashCode();\n\t}"
  },
  "org.springframework.core.test.tools.ResourceFiles#isEmpty()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns {@code true} if this collection is empty.\n\t * @return if this collection is empty\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "boolean",
    "signature": "public boolean isEmpty()",
    "source_code": "\tpublic boolean isEmpty() {\n\t\treturn this.files.isEmpty();\n\t}"
  },
  "org.springframework.core.test.tools.ResourceFiles#iterator()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "Iterator<ResourceFile>",
    "signature": "public Iterator<ResourceFile> iterator()",
    "source_code": "\tpublic Iterator<ResourceFile> iterator() {\n\t\treturn this.files.iterator();\n\t}"
  },
  "org.springframework.core.test.tools.ResourceFiles#none()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link DynamicFiles} instance with no items.\n\t * @return the empty instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 47
    },
    "return": "ResourceFiles",
    "signature": "public ResourceFiles none()",
    "source_code": "\tpublic static ResourceFiles none() {\n\t\treturn NONE;\n\t}"
  },
  "org.springframework.core.test.tools.ResourceFiles#of(ResourceFiles)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Factory method that can be used to create a {@link ResourceFiles}\n\t * instance containing the specified files.\n\t * @param ResourceFiles the files to include\n\t * @return a {@link ResourceFiles} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ResourceFiles"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "ResourceFiles",
    "signature": "public ResourceFiles of(ResourceFile... ResourceFiles)",
    "source_code": "\tpublic static ResourceFiles of(ResourceFile... ResourceFiles) {\n\t\treturn none().and(ResourceFiles);\n\t}"
  },
  "org.springframework.core.test.tools.ResourceFiles#stream()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Stream the {@link ResourceFile} instances contained in this collection.\n\t * @return a stream of file instances\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "Stream<ResourceFile>",
    "signature": "public Stream<ResourceFile> stream()",
    "source_code": "\tpublic Stream<ResourceFile> stream() {\n\t\treturn this.files.stream();\n\t}"
  },
  "org.springframework.core.test.tools.ResourceFiles#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn this.files.toString();\n\t}"
  },
  "org.springframework.core.test.tools.SourceFiles": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * An immutable collection of {@link SourceFile} instances.\n *\n * @author Phillip Webb\n * @since 6.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 32
    },
    "signature": "public class SourceFiles",
    "source_code": "public final class SourceFiles implements Iterable<SourceFile> {\n\n\tprivate static final SourceFiles NONE = new SourceFiles(DynamicFiles.none());\n\n\n\tprivate final DynamicFiles<SourceFile> files;\n\n\n\tprivate SourceFiles(DynamicFiles<SourceFile> files) {\n\t\tthis.files = files;\n\t}\n\n\n\t/**\n\t * Return a {@link SourceFiles} instance with no items.\n\t * @return the empty instance\n\t */\n\tpublic static SourceFiles none() {\n\t\treturn NONE;\n\t}\n\n\t/**\n\t * Factory method that can be used to create a {@link SourceFiles} instance\n\t * containing the specified files.\n\t * @param sourceFiles the files to include\n\t * @return a {@link SourceFiles} instance\n\t */\n\tpublic static SourceFiles of(SourceFile... sourceFiles) {\n\t\treturn none().and(sourceFiles);\n\t}\n\n\t/**\n\t * Return a new {@link SourceFiles} instance that merges files from another\n\t * array of {@link SourceFile} instances.\n\t * @param sourceFiles the instances to merge\n\t * @return a new {@link SourceFiles} instance containing merged content\n\t */\n\tpublic SourceFiles and(SourceFile... sourceFiles) {\n\t\treturn new SourceFiles(this.files.and(sourceFiles));\n\t}\n\n\t/**\n\t * Return a new {@link SourceFiles} instance that merges files from another\n\t * array of {@link SourceFile} instances.\n\t * @param sourceFiles the instances to merge\n\t * @return a new {@link SourceFiles} instance containing merged content\n\t */\n\tpublic SourceFiles and(Iterable<SourceFile> sourceFiles) {\n\t\treturn new SourceFiles(this.files.and(sourceFiles));\n\t}\n\n\t/**\n\t * Return a new {@link SourceFiles} instance that merges files from another\n\t * {@link SourceFiles} instance.\n\t * @param sourceFiles the instance to merge\n\t * @return a new {@link SourceFiles} instance containing merged content\n\t */\n\tpublic SourceFiles and(SourceFiles sourceFiles) {\n\t\treturn new SourceFiles(this.files.and(sourceFiles.files));\n\t}\n\n\t@Override\n\tpublic Iterator<SourceFile> iterator() {\n\t\treturn this.files.iterator();\n\t}\n\n\t/**\n\t * Stream the {@link SourceFile} instances contained in this collection.\n\t * @return a stream of file instances\n\t */\n\tpublic Stream<SourceFile> stream() {\n\t\treturn this.files.stream();\n\t}\n\n\t/**\n\t * Returns {@code true} if this collection is empty.\n\t * @return if this collection is empty\n\t */\n\tpublic boolean isEmpty() {\n\t\treturn this.files.isEmpty();\n\t}\n\n\t/**\n\t * Get the {@link SourceFile} with the given\n\t * {@linkplain  DynamicFile#getPath() path}.\n\t * @param path the path to find\n\t * @return a {@link SourceFile} instance or {@code null}\n\t */\n\t@Nullable\n\tpublic SourceFile get(String path) {\n\t\treturn this.files.get(path);\n\t}\n\n\t/**\n\t * Return the single source file contained in the collection.\n\t * @return the single file\n\t * @throws IllegalStateException if the collection doesn't contain exactly\n\t * one file\n\t */\n\tpublic SourceFile getSingle() throws IllegalStateException {\n\t\treturn this.files.getSingle();\n\t}\n\n\t/**\n\t * Return the single matching source file contained in the collection.\n\t * @return the single file\n\t * @throws IllegalStateException if the collection doesn't contain exactly\n\t * one file\n\t */\n\tpublic SourceFile getSingle(String pattern) throws IllegalStateException {\n\t\treturn getSingle(Pattern.compile(pattern));\n\t}\n\n\tprivate SourceFile getSingle(Pattern pattern) {\n\t\treturn this.files.getSingle(\n\t\t\t\tcandidate -> pattern.matcher(candidate.getClassName()).matches());\n\t}\n\n\t/**\n\t * Return a single source file contained in the specified package.\n\t * @return the single file\n\t * @throws IllegalStateException if the collection doesn't contain exactly\n\t * one file\n\t */\n\tpublic SourceFile getSingleFromPackage(String packageName) {\n\t\treturn this.files.getSingle(candidate ->\n\t\t\t\tClassUtils.getPackageName(candidate.getClassName()).equals(packageName));\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof SourceFiles that && this.files.equals(that.files)));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.files.hashCode();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn this.files.toString();\n\t}\n\n}"
  },
  "org.springframework.core.test.tools.SourceFiles#and(sourceFiles)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a new {@link SourceFiles} instance that merges files from another\n\t * {@link SourceFiles} instance.\n\t * @param sourceFiles the instance to merge\n\t * @return a new {@link SourceFiles} instance containing merged content\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceFiles"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "SourceFiles",
    "signature": "public SourceFiles and(SourceFiles sourceFiles)",
    "source_code": "\tpublic SourceFiles and(SourceFiles sourceFiles) {\n\t\treturn new SourceFiles(this.files.and(sourceFiles.files));\n\t}"
  },
  "org.springframework.core.test.tools.SourceFiles#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof SourceFiles that && this.files.equals(that.files)));\n\t}"
  },
  "org.springframework.core.test.tools.SourceFiles#get(path)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the {@link SourceFile} with the given\n\t * {@linkplain  DynamicFile#getPath() path}.\n\t * @param path the path to find\n\t * @return a {@link SourceFile} instance or {@code null}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "SourceFile",
    "signature": "public SourceFile get(String path)",
    "source_code": "\tpublic SourceFile get(String path) {\n\t\treturn this.files.get(path);\n\t}"
  },
  "org.springframework.core.test.tools.SourceFiles#getSingle()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the single source file contained in the collection.\n\t * @return the single file\n\t * @throws IllegalStateException if the collection doesn't contain exactly\n\t * one file\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "SourceFile",
    "signature": "public SourceFile getSingle()",
    "source_code": "\tpublic SourceFile getSingle() throws IllegalStateException {\n\t\treturn this.files.getSingle();\n\t}"
  },
  "org.springframework.core.test.tools.SourceFiles#getSingle(pattern)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the single matching source file contained in the collection.\n\t * @return the single file\n\t * @throws IllegalStateException if the collection doesn't contain exactly\n\t * one file\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pattern"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "SourceFile",
    "signature": "public SourceFile getSingle(String pattern)",
    "source_code": "\tpublic SourceFile getSingle(String pattern) throws IllegalStateException {\n\t\treturn getSingle(Pattern.compile(pattern));\n\t}"
  },
  "org.springframework.core.test.tools.SourceFiles#getSingleFromPackage(packageName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a single source file contained in the specified package.\n\t * @return the single file\n\t * @throws IllegalStateException if the collection doesn't contain exactly\n\t * one file\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "packageName"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "SourceFile",
    "signature": "public SourceFile getSingleFromPackage(String packageName)",
    "source_code": "\tpublic SourceFile getSingleFromPackage(String packageName) {\n\t\treturn this.files.getSingle(candidate ->\n\t\t\t\tClassUtils.getPackageName(candidate.getClassName()).equals(packageName));\n\t}"
  },
  "org.springframework.core.test.tools.SourceFiles#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.files.hashCode();\n\t}"
  },
  "org.springframework.core.test.tools.SourceFiles#isEmpty()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns {@code true} if this collection is empty.\n\t * @return if this collection is empty\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "boolean",
    "signature": "public boolean isEmpty()",
    "source_code": "\tpublic boolean isEmpty() {\n\t\treturn this.files.isEmpty();\n\t}"
  },
  "org.springframework.core.test.tools.SourceFiles#iterator()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "Iterator<SourceFile>",
    "signature": "public Iterator<SourceFile> iterator()",
    "source_code": "\tpublic Iterator<SourceFile> iterator() {\n\t\treturn this.files.iterator();\n\t}"
  },
  "org.springframework.core.test.tools.SourceFiles#none()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link SourceFiles} instance with no items.\n\t * @return the empty instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 49
    },
    "return": "SourceFiles",
    "signature": "public SourceFiles none()",
    "source_code": "\tpublic static SourceFiles none() {\n\t\treturn NONE;\n\t}"
  },
  "org.springframework.core.test.tools.SourceFiles#of(sourceFiles)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Factory method that can be used to create a {@link SourceFiles} instance\n\t * containing the specified files.\n\t * @param sourceFiles the files to include\n\t * @return a {@link SourceFiles} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceFiles"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "SourceFiles",
    "signature": "public SourceFiles of(SourceFile... sourceFiles)",
    "source_code": "\tpublic static SourceFiles of(SourceFile... sourceFiles) {\n\t\treturn none().and(sourceFiles);\n\t}"
  },
  "org.springframework.core.test.tools.SourceFiles#stream()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Stream the {@link SourceFile} instances contained in this collection.\n\t * @return a stream of file instances\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "Stream<SourceFile>",
    "signature": "public Stream<SourceFile> stream()",
    "source_code": "\tpublic Stream<SourceFile> stream() {\n\t\treturn this.files.stream();\n\t}"
  },
  "org.springframework.core.test.tools.SourceFiles#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn this.files.toString();\n\t}"
  },
  "org.springframework.core.type.StandardClassMetadata#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof StandardClassMetadata that &&\n\t\t\t\tgetIntrospectedClass().equals(that.getIntrospectedClass())));\n\t}"
  },
  "org.springframework.core.type.StandardClassMetadata#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof StandardClassMetadata that &&\n\t\t\t\tgetIntrospectedClass().equals(that.getIntrospectedClass())));\n\t}"
  },
  "org.springframework.core.type.StandardMethodMetadata#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof StandardMethodMetadata that &&\n\t\t\t\tthis.introspectedMethod.equals(that.introspectedMethod)));\n\t}"
  },
  "org.springframework.core.type.StandardMethodMetadata#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof StandardMethodMetadata that &&\n\t\t\t\tthis.introspectedMethod.equals(that.introspectedMethod)));\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof SimpleAnnotationMetadata that && this.className.equals(that.className)));\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof SimpleAnnotationMetadata that && this.className.equals(that.className)));\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#getMetadata()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "SimpleAnnotationMetadata",
    "signature": "public SimpleAnnotationMetadata getMetadata()",
    "source_code": "\tpublic SimpleAnnotationMetadata getMetadata() {\n\t\tAssert.state(this.metadata != null, \"AnnotationMetadata not initialized\");\n\t\treturn this.metadata;\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#visit(version,access,name,signature,supername,interfaces)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "version",
      "access",
      "name",
      "signature",
      "supername",
      "interfaces"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "void",
    "signature": "public void visit(int version, int access, String name, String signature,\n\t\t\t@Nullable String supername, String[] interfaces)",
    "source_code": "\tpublic void visit(int version, int access, String name, String signature,"
  },
  "org.springframework.core.type.classreading.<unknown>#visitAnnotation(descriptor,visible)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "visible"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "AnnotationVisitor",
    "signature": "public AnnotationVisitor visitAnnotation(String descriptor, boolean visible)",
    "source_code": "\tpublic AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {\n\t\treturn MergedAnnotationReadingVisitor.get(this.classLoader, getSource(),\n\t\t\t\tdescriptor, visible, this.annotations::add);\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#visitInnerClass(name,outerName,innerName,access)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "outerName",
      "innerName",
      "access"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "void",
    "signature": "public void visitInnerClass(String name, @Nullable String outerName, String innerName, int access)",
    "source_code": "\tpublic void visitInnerClass(String name, @Nullable String outerName, String innerName, int access) {\n\t\tif (outerName != null) {\n\t\t\tString className = toClassName(name);\n\t\t\tString outerClassName = toClassName(outerName);\n\t\t\tif (this.className.equals(className)) {\n\t\t\t\tthis.enclosingClassName = outerClassName;\n\t\t\t\tthis.independentInnerClass = ((access & Opcodes.ACC_STATIC) != 0);\n\t\t\t}\n\t\t\telse if (this.className.equals(outerClassName)) {\n\t\t\t\tthis.memberClassNames.add(className);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#visitMethod(access,name,descriptor,signature,exceptions)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "access",
      "name",
      "descriptor",
      "signature",
      "exceptions"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "MethodVisitor",
    "signature": "public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions)",
    "source_code": "\tpublic MethodVisitor visitMethod("
  },
  "org.springframework.core.type.classreading.<unknown>#visitOuterClass(owner,name,desc)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "owner",
      "name",
      "desc"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "void",
    "signature": "public void visitOuterClass(String owner, String name, String desc)",
    "source_code": "\tpublic void visitOuterClass(String owner, String name, String desc) {\n\t\tthis.enclosingClassName = toClassName(owner);\n\t}"
  },
  "org.springframework.expression.spel.support.ReflectivePropertyAccessor#isKotlinProperty(method,methodSuffix)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "methodSuffix"
    ],
    "position": {
      "column": 1,
      "line": 780
    },
    "return": "boolean",
    "signature": "public boolean isKotlinProperty(Method method, String methodSuffix)",
    "source_code": "\t\tpublic static boolean isKotlinProperty(Method method, String methodSuffix) {\n\t\t\tKClass<?> kClass = JvmClassMappingKt.getKotlinClass(method.getDeclaringClass());\n\t\t\tfor (KProperty<?> property : KClasses.getMemberProperties(kClass)) {\n\t\t\t\tif (methodSuffix.equalsIgnoreCase(property.getName()) &&\n\t\t\t\t\t\t(method.equals(ReflectJvmMapping.getJavaGetter(property)) ||\n\t\t\t\t\t\t\t\tproperty instanceof KMutableProperty<?> mutableProperty &&\n\t\t\t\t\t\t\t\t\t\tmethod.equals(ReflectJvmMapping.getJavaSetter(mutableProperty)))) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.http.<unknown>#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj) || (obj instanceof HttpStatusCode that && this.value == that.value());\n\t}"
  },
  "org.springframework.http.<unknown>#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof HttpStatusCode that && this.value == that.value()));\n\t}"
  },
  "org.springframework.http.HttpHeaders#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 1837
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\tif (this == obj) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!(obj instanceof HttpHeaders other)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn unwrap(this).equals(unwrap(other));\n\t}"
  },
  "org.springframework.http.HttpHeaders#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 1837
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof HttpHeaders that && unwrap(this).equals(unwrap(that))));\n\t}"
  },
  "org.springframework.http.HttpMethod#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj) || (obj instanceof HttpMethod that && this.name.equals(that.name));\n\t}"
  },
  "org.springframework.http.HttpMethod#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof HttpMethod that && this.name.equals(that.name)));\n\t}"
  },
  "org.springframework.http.server.<unknown>#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object obj) {\n\t\t\treturn (this == obj) || (obj instanceof PathSegment that && value().equals(that.value()));\n\t\t}"
  },
  "org.springframework.http.server.<unknown>#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other || (other instanceof PathSegment that && this.value.equals(that.value())));\n\t\t}"
  },
  "org.springframework.jdbc.core.SimplePropertyRowMapper": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link RowMapper} implementation that converts a row into a new instance\n * of the specified mapped target class. The mapped target class must be a\n * top-level class or {@code static} nested class, and it may expose either a\n * <em>data class</em> constructor with named parameters corresponding to column\n * names or classic bean property setter methods with property names corresponding\n * to column names or fields with corresponding field names.\n *\n * <p>When combining a data class constructor with setter methods, any property\n * mapped successfully via a constructor argument will not be mapped additionally\n * via a corresponding setter method or field mapping. This means that constructor\n * arguments take precedence over property setter methods which in turn take\n * precedence over direct field mappings.\n *\n * <p>To facilitate mapping between columns and properties that don't have matching\n * names, try using underscore-separated column aliases in the SQL statement like\n * {@code \"select fname as first_name from customer\"}, where {@code first_name}\n * can be mapped to a {@code setFirstName(String)} method in the target class.\n *\n * <p>This is a flexible alternative to {@link DataClassRowMapper} and\n * {@link BeanPropertyRowMapper} for scenarios where no specific customization\n * and no pre-defined property mappings are needed.\n *\n * <p>In terms of its fallback property discovery algorithm, this class is similar to\n * {@link org.springframework.jdbc.core.namedparam.SimplePropertySqlParameterSource}\n * and is similarly used for {@link org.springframework.jdbc.core.simple.JdbcClient}.\n *\n * @author Juergen Hoeller\n * @since 6.1\n * @param <T> the result type\n * @see DataClassRowMapper\n * @see BeanPropertyRowMapper\n * @see org.springframework.jdbc.core.simple.JdbcClient.StatementSpec#query(Class)\n * @see org.springframework.jdbc.core.namedparam.SimplePropertySqlParameterSource\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "signature": "public class SimplePropertyRowMapper",
    "source_code": "public class SimplePropertyRowMapper<T> implements RowMapper<T> {\n\n\tprivate static final Object NO_DESCRIPTOR = new Object();\n\n\tprivate final Class<T> mappedClass;\n\n\tprivate final ConversionService conversionService;\n\n\tprivate final Constructor<T> mappedConstructor;\n\n\tprivate final String[] constructorParameterNames;\n\n\tprivate final TypeDescriptor[] constructorParameterTypes;\n\n\tprivate final Map<String, Object> propertyDescriptors = new ConcurrentHashMap<>();\n\n\n\t/**\n\t * Create a new {@code SimplePropertyRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t */\n\tpublic SimplePropertyRowMapper(Class<T> mappedClass) {\n\t\tthis(mappedClass, DefaultConversionService.getSharedInstance());\n\t}\n\n\t/**\n\t * Create a new {@code SimplePropertyRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t * @param conversionService a {@link ConversionService} for binding\n\t * JDBC values to bean properties\n\t */\n\tpublic SimplePropertyRowMapper(Class<T> mappedClass, ConversionService conversionService) {\n\t\tAssert.notNull(mappedClass, \"Mapped Class must not be null\");\n\t\tAssert.notNull(conversionService, \"ConversionService must not be null\");\n\t\tthis.mappedClass = mappedClass;\n\t\tthis.conversionService = conversionService;\n\n\t\tthis.mappedConstructor = BeanUtils.getResolvableConstructor(mappedClass);\n\t\tint paramCount = this.mappedConstructor.getParameterCount();\n\t\tthis.constructorParameterNames = (paramCount > 0 ?\n\t\t\t\tBeanUtils.getParameterNames(this.mappedConstructor) : new String[0]);\n\t\tthis.constructorParameterTypes = new TypeDescriptor[paramCount];\n\t\tfor (int i = 0; i < paramCount; i++) {\n\t\t\tthis.constructorParameterTypes[i] = new TypeDescriptor(new MethodParameter(this.mappedConstructor, i));\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic T mapRow(ResultSet rs, int rowNumber) throws SQLException {\n\t\tObject[] args = new Object[this.constructorParameterNames.length];\n\t\tSet<Integer> usedIndex = new HashSet<>();\n\t\tfor (int i = 0; i < args.length; i++) {\n\t\t\tString name = this.constructorParameterNames[i];\n\t\t\tint index;\n\t\t\ttry {\n\t\t\t\t// Try direct name match first\n\t\t\t\tindex = rs.findColumn(name);\n\t\t\t}\n\t\t\tcatch (SQLException ex) {\n\t\t\t\t// Try underscored name match instead\n\t\t\t\tindex = rs.findColumn(JdbcUtils.convertPropertyNameToUnderscoreName(name));\n\t\t\t}\n\t\t\tTypeDescriptor td = this.constructorParameterTypes[i];\n\t\t\tObject value = JdbcUtils.getResultSetValue(rs, index, td.getType());\n\t\t\tusedIndex.add(index);\n\t\t\targs[i] = this.conversionService.convert(value, td);\n\t\t}\n\t\tT mappedObject = BeanUtils.instantiateClass(this.mappedConstructor, args);\n\n\t\tResultSetMetaData rsmd = rs.getMetaData();\n\t\tint columnCount = rsmd.getColumnCount();\n\t\tfor (int index = 1; index <= columnCount; index++) {\n\t\t\tif (!usedIndex.contains(index)) {\n\t\t\t\tObject desc = getDescriptor(JdbcUtils.lookupColumnName(rsmd, index));\n\t\t\t\tif (desc instanceof MethodParameter mp) {\n\t\t\t\t\tMethod method = mp.getMethod();\n\t\t\t\t\tif (method != null) {\n\t\t\t\t\t\tObject value = JdbcUtils.getResultSetValue(rs, index, mp.getParameterType());\n\t\t\t\t\t\tvalue = this.conversionService.convert(value, new TypeDescriptor(mp));\n\t\t\t\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\t\t\t\tReflectionUtils.invokeMethod(method, mappedObject, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (desc instanceof Field field) {\n\t\t\t\t\tObject value = JdbcUtils.getResultSetValue(rs, index, field.getType());\n\t\t\t\t\tvalue = this.conversionService.convert(value, new TypeDescriptor(field));\n\t\t\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\t\t\tReflectionUtils.setField(field, mappedObject, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn mappedObject;\n\t}\n\n\tprivate Object getDescriptor(String column) {\n\t\treturn this.propertyDescriptors.computeIfAbsent(column, name -> {\n\n\t\t\t// Try direct match first\n\t\t\tPropertyDescriptor pd = BeanUtils.getPropertyDescriptor(this.mappedClass, name);\n\t\t\tif (pd != null && pd.getWriteMethod() != null) {\n\t\t\t\treturn BeanUtils.getWriteMethodParameter(pd);\n\t\t\t}\n\t\t\tField field = ReflectionUtils.findField(this.mappedClass, name);\n\t\t\tif (field != null) {\n\t\t\t\treturn field;\n\t\t\t}\n\n\t\t\t// Try de-underscored match instead\n\t\t\tString adaptedName = JdbcUtils.convertUnderscoreNameToPropertyName(name);\n\t\t\tif (!adaptedName.equals(name)) {\n\t\t\t\tpd = BeanUtils.getPropertyDescriptor(this.mappedClass, adaptedName);\n\t\t\t\tif (pd != null && pd.getWriteMethod() != null) {\n\t\t\t\t\treturn BeanUtils.getWriteMethodParameter(pd);\n\t\t\t\t}\n\t\t\t\tfield = ReflectionUtils.findField(this.mappedClass, adaptedName);\n\t\t\t\tif (field != null) {\n\t\t\t\t\treturn field;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fallback: case-insensitive match\n\t\t\tPropertyDescriptor[] pds = BeanUtils.getPropertyDescriptors(this.mappedClass);\n\t\t\tfor (PropertyDescriptor candidate : pds) {\n\t\t\t\tif (name.equalsIgnoreCase(candidate.getName())) {\n\t\t\t\t\treturn BeanUtils.getWriteMethodParameter(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfield = ReflectionUtils.findFieldIgnoreCase(this.mappedClass, name);\n\t\t\tif (field != null) {\n\t\t\t\treturn field;\n\t\t\t}\n\n\t\t\treturn NO_DESCRIPTOR;\n\t\t});\n\t}\n\n}"
  },
  "org.springframework.jdbc.core.SimplePropertyRowMapper#mapRow(rs,rowNumber)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "rowNumber"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "T",
    "signature": "public T mapRow(ResultSet rs, int rowNumber)",
    "source_code": "\tpublic T mapRow(ResultSet rs, int rowNumber) throws SQLException {\n\t\tObject[] args = new Object[this.constructorParameterNames.length];\n\t\tSet<Integer> usedIndex = new HashSet<>();\n\t\tfor (int i = 0; i < args.length; i++) {\n\t\t\tString name = this.constructorParameterNames[i];\n\t\t\tint index;\n\t\t\ttry {\n\t\t\t\t// Try direct name match first\n\t\t\t\tindex = rs.findColumn(name);\n\t\t\t}\n\t\t\tcatch (SQLException ex) {\n\t\t\t\t// Try underscored name match instead\n\t\t\t\tindex = rs.findColumn(JdbcUtils.convertPropertyNameToUnderscoreName(name));\n\t\t\t}\n\t\t\tTypeDescriptor td = this.constructorParameterTypes[i];\n\t\t\tObject value = JdbcUtils.getResultSetValue(rs, index, td.getType());\n\t\t\tusedIndex.add(index);\n\t\t\targs[i] = this.conversionService.convert(value, td);\n\t\t}\n\t\tT mappedObject = BeanUtils.instantiateClass(this.mappedConstructor, args);\n\n\t\tResultSetMetaData rsmd = rs.getMetaData();\n\t\tint columnCount = rsmd.getColumnCount();\n\t\tfor (int index = 1; index <= columnCount; index++) {\n\t\t\tif (!usedIndex.contains(index)) {\n\t\t\t\tObject desc = getDescriptor(JdbcUtils.lookupColumnName(rsmd, index));\n\t\t\t\tif (desc instanceof MethodParameter mp) {\n\t\t\t\t\tMethod method = mp.getMethod();\n\t\t\t\t\tif (method != null) {\n\t\t\t\t\t\tObject value = JdbcUtils.getResultSetValue(rs, index, mp.getParameterType());\n\t\t\t\t\t\tvalue = this.conversionService.convert(value, new TypeDescriptor(mp));\n\t\t\t\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\t\t\t\tReflectionUtils.invokeMethod(method, mappedObject, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (desc instanceof Field field) {\n\t\t\t\t\tObject value = JdbcUtils.getResultSetValue(rs, index, field.getType());\n\t\t\t\t\tvalue = this.conversionService.convert(value, new TypeDescriptor(field));\n\t\t\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\t\t\tReflectionUtils.setField(field, mappedObject, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn mappedObject;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.MapSqlParameterSource#hasValues()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether this parameter source has been configured with any values.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "boolean",
    "signature": "public boolean hasValues()",
    "source_code": "\tpublic boolean hasValues() {\n\t\treturn !this.values.isEmpty();\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.SimplePropertySqlParameterSource": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link SqlParameterSource} implementation that obtains parameter values\n * from bean properties of a given JavaBean object, from component accessors\n * of a record class, or from raw field access.\n *\n * <p>This is a more flexible variant of {@link BeanPropertySqlParameterSource},\n * with the limitation that it is not able to enumerate its\n * {@link #getParameterNames() parameter names}.\n *\n * <p>In terms of its fallback property discovery algorithm, this class is\n * similar to {@link org.springframework.validation.SimpleErrors} which is\n * also just used for property retrieval purposes (rather than binding).\n *\n * @author Juergen Hoeller\n * @since 6.1\n * @see NamedParameterJdbcTemplate\n * @see BeanPropertySqlParameterSource\n * @see org.springframework.jdbc.core.simple.JdbcClient.StatementSpec#paramSource(Object)\n * @see org.springframework.jdbc.core.SimplePropertyRowMapper\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "public class SimplePropertySqlParameterSource",
    "source_code": "public class SimplePropertySqlParameterSource extends AbstractSqlParameterSource {\n\n\tprivate static final Object NO_DESCRIPTOR = new Object();\n\n\tprivate final Object paramObject;\n\n\tprivate final Map<String, Object> propertyDescriptors = new ConcurrentHashMap<>();\n\n\n\t/**\n\t * Create a new SqlParameterSource for the given bean, record or field holder.\n\t * @param paramObject the bean, record or field holder instance to wrap\n\t */\n\tpublic SimplePropertySqlParameterSource(Object paramObject) {\n\t\tAssert.notNull(paramObject, \"Parameter object must not be null\");\n\t\tthis.paramObject = paramObject;\n\t}\n\n\n\t@Override\n\tpublic boolean hasValue(String paramName) {\n\t\treturn (getDescriptor(paramName) != NO_DESCRIPTOR);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Object getValue(String paramName) throws IllegalArgumentException {\n\t\tObject desc = getDescriptor(paramName);\n\t\tif (desc instanceof PropertyDescriptor pd) {\n\t\t\tReflectionUtils.makeAccessible(pd.getReadMethod());\n\t\t\treturn ReflectionUtils.invokeMethod(pd.getReadMethod(), this.paramObject);\n\t\t}\n\t\telse if (desc instanceof Field field) {\n\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\treturn ReflectionUtils.getField(field, this.paramObject);\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Cannot retrieve value for parameter '\" + paramName +\n\t\t\t\t\"' - neither a getter method nor a raw field found\");\n\t}\n\n\t/**\n\t * Derives a default SQL type from the corresponding property type.\n\t * @see StatementCreatorUtils#javaTypeToSqlParameterType\n\t */\n\t@Override\n\tpublic int getSqlType(String paramName) {\n\t\tint sqlType = super.getSqlType(paramName);\n\t\tif (sqlType != TYPE_UNKNOWN) {\n\t\t\treturn sqlType;\n\t\t}\n\t\tObject desc = getDescriptor(paramName);\n\t\tif (desc instanceof PropertyDescriptor pd) {\n\t\t\treturn StatementCreatorUtils.javaTypeToSqlParameterType(pd.getPropertyType());\n\t\t}\n\t\telse if (desc instanceof Field field) {\n\t\t\treturn StatementCreatorUtils.javaTypeToSqlParameterType(field.getType());\n\t\t}\n\t\treturn TYPE_UNKNOWN;\n\t}\n\n\tprivate Object getDescriptor(String paramName) {\n\t\treturn this.propertyDescriptors.computeIfAbsent(paramName, name -> {\n\t\t\tPropertyDescriptor pd = BeanUtils.getPropertyDescriptor(this.paramObject.getClass(), name);\n\t\t\tif (pd != null && pd.getReadMethod() != null) {\n\t\t\t\treturn pd;\n\t\t\t}\n\t\t\tField field = ReflectionUtils.findField(this.paramObject.getClass(), name);\n\t\t\tif (field != null) {\n\t\t\t\treturn field;\n\t\t\t}\n\t\t\treturn NO_DESCRIPTOR;\n\t\t});\n\t}\n\n}"
  },
  "org.springframework.jdbc.core.namedparam.SimplePropertySqlParameterSource#getSqlType(paramName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Derives a default SQL type from the corresponding property type.\n\t * @see StatementCreatorUtils#javaTypeToSqlParameterType\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "int",
    "signature": "public int getSqlType(String paramName)",
    "source_code": "\tpublic int getSqlType(String paramName) {\n\t\tint sqlType = super.getSqlType(paramName);\n\t\tif (sqlType != TYPE_UNKNOWN) {\n\t\t\treturn sqlType;\n\t\t}\n\t\tObject desc = getDescriptor(paramName);\n\t\tif (desc instanceof PropertyDescriptor pd) {\n\t\t\treturn StatementCreatorUtils.javaTypeToSqlParameterType(pd.getPropertyType());\n\t\t}\n\t\telse if (desc instanceof Field field) {\n\t\t\treturn StatementCreatorUtils.javaTypeToSqlParameterType(field.getType());\n\t\t}\n\t\treturn TYPE_UNKNOWN;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.SimplePropertySqlParameterSource#getValue(paramName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "Object",
    "signature": "public Object getValue(String paramName)",
    "source_code": "\tpublic Object getValue(String paramName) throws IllegalArgumentException {\n\t\tObject desc = getDescriptor(paramName);\n\t\tif (desc instanceof PropertyDescriptor pd) {\n\t\t\tReflectionUtils.makeAccessible(pd.getReadMethod());\n\t\t\treturn ReflectionUtils.invokeMethod(pd.getReadMethod(), this.paramObject);\n\t\t}\n\t\telse if (desc instanceof Field field) {\n\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\treturn ReflectionUtils.getField(field, this.paramObject);\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Cannot retrieve value for parameter '\" + paramName +\n\t\t\t\t\"' - neither a getter method nor a raw field found\");\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.SimplePropertySqlParameterSource#hasValue(paramName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "boolean",
    "signature": "public boolean hasValue(String paramName)",
    "source_code": "\tpublic boolean hasValue(String paramName) {\n\t\treturn (getDescriptor(paramName) != NO_DESCRIPTOR);\n\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#list()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 324
    },
    "return": "List<T>",
    "signature": "public List<T> list()",
    "source_code": "\t\t\tpublic List<T> list() {\n\t\t\t\treturn namedParamOps.query(sql, namedParamSource, this.rowMapper);\n\t\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#listOfRows()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "Object>>",
    "signature": "public Object>> listOfRows()",
    "source_code": "\t\t\tpublic List<Map<String, Object>> listOfRows() {\n\t\t\t\treturn namedParamOps.queryForList(sql, namedParamSource);\n\t\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#param(jdbcIndex,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "jdbcIndex",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec param(int jdbcIndex, Object value)",
    "source_code": "\t\tpublic StatementSpec param(int jdbcIndex, Object value) {\n\t\t\tif (jdbcIndex < 1) {\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid JDBC index: needs to start at 1\");\n\t\t\t}\n\t\t\tint index = jdbcIndex - 1;\n\t\t\tint size = this.indexedParams.size();\n\t\t\tif (index < size) {\n\t\t\t\tthis.indexedParams.set(index, value);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = size; i < index; i++) {\n\t\t\t\t\tthis.indexedParams.add(null);\n\t\t\t\t}\n\t\t\t\tthis.indexedParams.add(value);\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#param(jdbcIndex,value,sqlType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "jdbcIndex",
      "value",
      "sqlType"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec param(int jdbcIndex, Object value, int sqlType)",
    "source_code": "\t\tpublic StatementSpec param(int jdbcIndex, Object value, int sqlType) {\n\t\t\treturn param(jdbcIndex, new SqlParameterValue(sqlType, value));\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#param(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec param(String name, Object value)",
    "source_code": "\t\tpublic StatementSpec param(String name, Object value) {\n\t\t\tthis.namedParams.addValue(name, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#param(name,value,sqlType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value",
      "sqlType"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec param(String name, Object value, int sqlType)",
    "source_code": "\t\tpublic StatementSpec param(String name, Object value, int sqlType) {\n\t\t\tthis.namedParams.addValue(name, value, sqlType);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#param(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec param(Object value)",
    "source_code": "\t\tpublic StatementSpec param(Object value) {\n\t\t\tthis.indexedParams.add(value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#paramSource(namedParamObject)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "namedParamObject"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec paramSource(Object namedParamObject)",
    "source_code": "\t\tpublic StatementSpec paramSource(Object namedParamObject) {\n\t\t\tthis.namedParamSource = (namedParamObject instanceof Map map ?\n\t\t\t\t\tnew MapSqlParameterSource(map) :\n\t\t\t\t\tnew SimplePropertySqlParameterSource(namedParamObject));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#paramSource(namedParamSource)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "namedParamSource"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec paramSource(SqlParameterSource namedParamSource)",
    "source_code": "\t\tpublic StatementSpec paramSource(SqlParameterSource namedParamSource) {\n\t\t\tthis.namedParamSource = namedParamSource;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#params(Map<String,paramMap)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "paramMap"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec params(Map<String, ?> paramMap)",
    "source_code": "\t\tpublic StatementSpec params(Map<String, ?> paramMap) {\n\t\t\tthis.namedParams.addValues(paramMap);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#params(values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "values"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec params(List<?> values)",
    "source_code": "\t\tpublic StatementSpec params(List<?> values) {\n\t\t\tthis.indexedParams.addAll(values);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#query()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "ResultQuerySpec",
    "signature": "public ResultQuerySpec query()",
    "source_code": "\t\tpublic ResultQuerySpec query() {\n\t\t\treturn (useNamedParams() ?\n\t\t\t\t\tnew NamedParamResultQuerySpec() :\n\t\t\t\t\tnew IndexedParamResultQuerySpec());\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#query(mappedClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedClass"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "MappedQuerySpec<T>",
    "signature": "public MappedQuerySpec<T> query(Class<T> mappedClass)",
    "source_code": "\t\tpublic <T> MappedQuerySpec<T> query(Class<T> mappedClass) {\n\t\t\tRowMapper<?> rowMapper = rowMapperCache.computeIfAbsent(mappedClass, key ->\n\t\t\t\t\tBeanUtils.isSimpleProperty(mappedClass) ? new SingleColumnRowMapper<>(mappedClass) :\n\t\t\t\t\t\t\tnew SimplePropertyRowMapper<>(mappedClass));\n\t\t\treturn query((RowMapper<T>) rowMapper);\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#query(rch)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rch"
    ],
    "position": {
      "column": 1,
      "line": 195
    },
    "return": "void",
    "signature": "public void query(RowCallbackHandler rch)",
    "source_code": "\t\tpublic void query(RowCallbackHandler rch) {\n\t\t\tif (useNamedParams()) {\n\t\t\t\tnamedParamOps.query(this.sql, this.namedParams, rch);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tclassicOps.query(this.sql, rch, this.indexedParams.toArray());\n\t\t\t}\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#query(rowMapper)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "MappedQuerySpec<T>",
    "signature": "public MappedQuerySpec<T> query(RowMapper<T> rowMapper)",
    "source_code": "\t\tpublic <T> MappedQuerySpec<T> query(RowMapper<T> rowMapper) {\n\t\t\treturn (useNamedParams() ?\n\t\t\t\t\tnew NamedParamMappedQuerySpec<>(rowMapper) :\n\t\t\t\t\tnew IndexedParamMappedQuerySpec<>(rowMapper));\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#query(rse)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rse"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "T",
    "signature": "public T query(ResultSetExtractor<T> rse)",
    "source_code": "\t\tpublic <T> T query(ResultSetExtractor<T> rse) {\n\t\t\tT result = (useNamedParams() ?\n\t\t\t\t\tnamedParamOps.query(this.sql, this.namedParams, rse) :\n\t\t\t\t\tclassicOps.query(this.sql, rse, this.indexedParams.toArray()));\n\t\t\tAssert.state(result != null, \"No result from ResultSetExtractor\");\n\t\t\treturn result;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#rowSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 268
    },
    "return": "SqlRowSet",
    "signature": "public SqlRowSet rowSet()",
    "source_code": "\t\t\tpublic SqlRowSet rowSet() {\n\t\t\t\treturn namedParamOps.queryForRowSet(sql, namedParamSource);\n\t\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#singleColumn()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "List<T>",
    "signature": "public List<T> singleColumn()",
    "source_code": "\t\t\tpublic <T> List<T> singleColumn() {\n\t\t\t\treturn (List<T>) namedParamOps.queryForList(sql, namedParamSource, Object.class);\n\t\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#singleRow()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 278
    },
    "return": "Object>",
    "signature": "public Object> singleRow()",
    "source_code": "\t\t\tpublic Map<String, Object> singleRow() {\n\t\t\t\treturn namedParamOps.queryForMap(sql, namedParamSource);\n\t\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#sql(sql)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec sql(String sql)",
    "source_code": "\tpublic StatementSpec sql(String sql) {\n\t\treturn new DefaultStatementSpec(sql);\n\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#stream()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 319
    },
    "return": "Stream<T>",
    "signature": "public Stream<T> stream()",
    "source_code": "\t\t\tpublic Stream<T> stream() {\n\t\t\t\treturn namedParamOps.queryForStream(sql, namedParamSource, this.rowMapper);\n\t\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#update()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "int",
    "signature": "public int update()",
    "source_code": "\t\tpublic int update() {\n\t\t\treturn (useNamedParams() ?\n\t\t\t\t\tnamedParamOps.update(this.sql, this.namedParamSource) :\n\t\t\t\t\tclassicOps.update(this.sql, this.indexedParams.toArray()));\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#update(generatedKeyHolder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generatedKeyHolder"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "int",
    "signature": "public int update(KeyHolder generatedKeyHolder)",
    "source_code": "\t\tpublic int update(KeyHolder generatedKeyHolder) {\n\t\t\treturn (useNamedParams() ?\n\t\t\t\t\tnamedParamOps.update(this.sql, this.namedParamSource, generatedKeyHolder) :\n\t\t\t\t\tclassicOps.update(this.sql, this.indexedParams.toArray(), generatedKeyHolder));\n\t\t}"
  },
  "org.springframework.jdbc.support.JdbcUtils#convertPropertyNameToUnderscoreName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a property name using \"camelCase\" to a corresponding column name with underscores.\n\t * A name like \"customerNumber\" would match a \"customer_number\" column name.\n\t * @param name the property name to be converted\n\t * @return the column name using underscores\n\t * @since 6.1\n\t * @see #convertUnderscoreNameToPropertyName\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 520
    },
    "return": "String",
    "signature": "public String convertPropertyNameToUnderscoreName(@Nullable String name)",
    "source_code": "\tpublic static String convertPropertyNameToUnderscoreName(@Nullable String name) {\n\t\tif (!StringUtils.hasLength(name)) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tStringBuilder result = new StringBuilder();\n\t\tresult.append(Character.toLowerCase(name.charAt(0)));\n\t\tfor (int i = 1; i < name.length(); i++) {\n\t\t\tchar c = name.charAt(i);\n\t\t\tif (Character.isUpperCase(c)) {\n\t\t\t\tresult.append('_').append(Character.toLowerCase(c));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.append(c);\n\t\t\t}\n\t\t}\n\t\treturn result.toString();\n\t}"
  },
  "org.springframework.jms.connection.JmsTransactionManager#flush()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 453
    },
    "return": "void",
    "signature": "public void flush()",
    "source_code": "\t\tpublic void flush() {\n\t\t\t// no-op\n\t\t}"
  },
  "org.springframework.jms.core.JmsTemplate#setObservationRegistry(observationRegistry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@link ObservationRegistry} to use for recording JMS observations.\n\t * @param observationRegistry the observation registry to use.\n\t * @since 6.1\n\t * @see io.micrometer.core.instrument.binder.jms.JmsObservationDocumentation\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "observationRegistry"
    ],
    "position": {
      "column": 1,
      "line": 479
    },
    "return": "void",
    "signature": "public void setObservationRegistry(ObservationRegistry observationRegistry)",
    "source_code": "\tpublic void setObservationRegistry(ObservationRegistry observationRegistry) {\n\t\tthis.observationRegistry = observationRegistry;\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#getObservationRegistry()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link ObservationRegistry} used for recording\n\t * {@link JmsObservationDocumentation#JMS_MESSAGE_PUBLISH JMS message processing observations}.\n\t * @since 6.1.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 584
    },
    "return": "ObservationRegistry",
    "signature": "public ObservationRegistry getObservationRegistry()",
    "source_code": "\tpublic ObservationRegistry getObservationRegistry() {\n\t\treturn this.observationRegistry;\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#setObservationRegistry(observationRegistry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link ObservationRegistry} to be used for recording\n\t * {@link JmsObservationDocumentation#JMS_MESSAGE_PUBLISH JMS message processing observations}.\n\t * Defaults to no-op observations if the registry is not set.\n\t * @since 6.1.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "observationRegistry"
    ],
    "position": {
      "column": 1,
      "line": 594
    },
    "return": "void",
    "signature": "public void setObservationRegistry(@Nullable ObservationRegistry observationRegistry)",
    "source_code": "\tpublic void setObservationRegistry(@Nullable ObservationRegistry observationRegistry) {\n\t\tthis.observationRegistry = observationRegistry;\n\t}"
  },
  "org.springframework.messaging.MessageHeaders#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 336
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof MessageHeaders that && this.headers.equals(that.headers)));\n\t}"
  },
  "org.springframework.messaging.MessageHeaders#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 336
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof MessageHeaders that && this.headers.equals(that.headers)));\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessageMappingInfo#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj) || (obj instanceof SimpMessageMappingInfo that && this.delegate.equals(that.delegate));\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessageMappingInfo#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof SimpMessageMappingInfo that && this.delegate.equals(that.delegate)));\n\t}"
  },
  "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistry#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 484
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object obj) {\n\t\t\treturn (this == obj || (obj instanceof Subscription that && this.id.equals(that.id)));\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistry#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 484
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other || (other instanceof Subscription that && this.id.equals(that.id)));\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 557
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof StompHeaders that && this.headers.equals(that.headers)));\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 558
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof StompHeaders that && this.headers.equals(that.headers)));\n\t}"
  },
  "org.springframework.messaging.simp.user.MultiServerUserRegistry#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 458
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object obj) {\n\t\t\treturn (this == obj || (obj instanceof SimpSession that && this.id.equals(that.getId())));\n\t\t}"
  },
  "org.springframework.orm.hibernate5.SpringFlushSynchronization#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof SpringFlushSynchronization that && this.session == that.session));\n\t}"
  },
  "org.springframework.orm.hibernate5.SpringFlushSynchronization#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof SpringFlushSynchronization that && this.session == that.session));\n\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bindProperties(source)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source"
    ],
    "position": {
      "column": 1,
      "line": 324
    },
    "return": "DefaultGenericExecuteSpec",
    "signature": "public DefaultGenericExecuteSpec bindProperties(Object source)",
    "source_code": "\t\tpublic DefaultGenericExecuteSpec bindProperties(Object source) {\n\t\t\tassertNotPreparedOperation();\n\t\t\tAssert.notNull(source, \"Parameter source must not be null\");\n\n\t\t\tMap<String, Parameter> byName = new LinkedHashMap<>(this.byName);\n\t\t\tfor (PropertyDescriptor pd : BeanUtils.getPropertyDescriptors(source.getClass())) {\n\t\t\t\tif (pd.getReadMethod() != null && pd.getReadMethod().getDeclaringClass() != Object.class) {\n\t\t\t\t\tReflectionUtils.makeAccessible(pd.getReadMethod());\n\t\t\t\t\tObject value = ReflectionUtils.invokeMethod(pd.getReadMethod(), source);\n\t\t\t\t\tbyName.put(pd.getName(), (value != null ? Parameters.in(value) : Parameters.in(pd.getPropertyType())));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new DefaultGenericExecuteSpec(this.byIndex, byName, this.sqlSupplier, this.filterFunction);\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bindValues(Map<String,source)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 313
    },
    "return": "GenericExecuteSpec",
    "signature": "public GenericExecuteSpec bindValues(Map<String, ?> source)",
    "source_code": "\t\tpublic GenericExecuteSpec bindValues(Map<String, ?> source) {\n\t\t\tassertNotPreparedOperation();\n\t\t\tAssert.notNull(source, \"Parameter source must not be null\");\n\n\t\t\tMap<String, Parameter> target = new LinkedHashMap<>(this.byName);\n\t\t\tsource.forEach((name, value) -> target.put(name, resolveParameter(value)));\n\n\t\t\treturn new DefaultGenericExecuteSpec(this.byIndex, target, this.sqlSupplier, this.filterFunction);\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#equals(o)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o"
    ],
    "position": {
      "column": 1,
      "line": 401
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object o)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object o) {\n\t\t\tif (this == o) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!(o instanceof ParameterHolder that)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn this.startIndex == that.startIndex && this.endIndex == that.endIndex\n\t\t\t\t\t&& Objects.equals(this.parameterName, that.parameterName);\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 401
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other || (other instanceof ParameterHolder that &&\n\t\t\t\t\tthis.startIndex == that.startIndex && this.endIndex == that.endIndex &&\n\t\t\t\t\tthis.parameterName.equals(that.parameterName)));\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#mapProperties(mappedClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedClass"
    ],
    "position": {
      "column": 1,
      "line": 366
    },
    "return": "FetchSpec<R>",
    "signature": "public FetchSpec<R> mapProperties(Class<R> mappedClass)",
    "source_code": "\t\tpublic <R> FetchSpec<R> mapProperties(Class<R> mappedClass) {\n\t\t\tAssert.notNull(mappedClass, \"Mapped class must not be null\");\n\t\t\treturn execute(this.sqlSupplier, result -> result.map(new DataClassRowMapper<R>(mappedClass)));\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#mapValue(mappedClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedClass"
    ],
    "position": {
      "column": 1,
      "line": 360
    },
    "return": "RowsFetchSpec<R>",
    "signature": "public RowsFetchSpec<R> mapValue(Class<R> mappedClass)",
    "source_code": "\t\tpublic <R> RowsFetchSpec<R> mapValue(Class<R> mappedClass) {\n\t\t\tAssert.notNull(mappedClass, \"Mapped class must not be null\");\n\t\t\treturn execute(this.sqlSupplier, result -> result.map(row -> row.get(0, mappedClass)));\n\t\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#getConversionService()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ConversionService} for binding R2DBC values to bean properties,\n\t * or {@code null} if none.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "ConversionService",
    "signature": "public ConversionService getConversionService()",
    "source_code": "\tpublic ConversionService getConversionService() {\n\t\treturn this.conversionService;\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#getItemValue(readable,itemIndex,pd)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve an R2DBC object value for the specified item index (a column or an\n\t * out-parameter).\n\t * <p>The default implementation delegates to\n\t * {@link #getItemValue(Readable, int, Class)}.\n\t * @param readable is the {@code Row} or {@code OutParameters} holding the data\n\t * @param itemIndex is the column index or out-parameter index\n\t * @param pd the bean property that each result object is expected to match\n\t * @return the Object value\n\t * @see #getItemValue(Readable, int, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "readable",
      "itemIndex",
      "pd"
    ],
    "position": {
      "column": 1,
      "line": 405
    },
    "return": "Object",
    "signature": "protected Object getItemValue(Readable readable, int itemIndex, PropertyDescriptor pd)",
    "source_code": "\tprotected Object getItemValue(Readable readable, int itemIndex, PropertyDescriptor pd) {\n\t\treturn getItemValue(readable, itemIndex, pd.getPropertyType());\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#getMappedClass()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the class that we are mapping to.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "Class<T>",
    "signature": "public Class<T> getMappedClass()",
    "source_code": "\tpublic final Class<T> getMappedClass() {\n\t\treturn this.mappedClass;\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#initBeanWrapper(bw)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the given BeanWrapper to be used for row mapping or outParameters\n\t * mapping.\n\t * <p>To be called for each Readable.\n\t * <p>The default implementation applies the configured {@link ConversionService},\n\t * if any. Can be overridden in subclasses.\n\t * @param bw the BeanWrapper to initialize\n\t * @see #getConversionService()\n\t * @see BeanWrapper#setConversionService\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bw"
    ],
    "position": {
      "column": 1,
      "line": 386
    },
    "return": "void",
    "signature": "protected void initBeanWrapper(BeanWrapper bw)",
    "source_code": "\tprotected void initBeanWrapper(BeanWrapper bw) {\n\t\tConversionService cs = getConversionService();\n\t\tif (cs != null) {\n\t\t\tbw.setConversionService(cs);\n\t\t}\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#initialize(mappedClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the mapping meta-data for the given class.\n\t * @param mappedClass the mapped class\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mappedClass"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "void",
    "signature": "protected void initialize(Class<T> mappedClass)",
    "source_code": "\tprotected void initialize(Class<T> mappedClass) {\n\t\tthis.mappedClass = mappedClass;\n\t\tthis.mappedProperties = new HashMap<>();\n\t\tthis.mappedPropertyNames = new HashSet<>();\n\n\t\tfor (PropertyDescriptor pd : BeanUtils.getPropertyDescriptors(mappedClass)) {\n\t\t\tif (pd.getWriteMethod() != null) {\n\t\t\t\tString lowerCaseName = lowerCaseName(pd.getName());\n\t\t\t\tthis.mappedProperties.put(lowerCaseName, pd);\n\t\t\t\tString underscoreName = underscoreName(pd.getName());\n\t\t\t\tif (!lowerCaseName.equals(underscoreName)) {\n\t\t\t\t\tthis.mappedProperties.put(underscoreName, pd);\n\t\t\t\t}\n\t\t\t\tthis.mappedPropertyNames.add(pd.getName());\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#isCheckFullyPopulated()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether we're strictly validating that all bean properties have been\n\t * mapped from corresponding database columns or out-parameters.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "boolean",
    "signature": "public boolean isCheckFullyPopulated()",
    "source_code": "\tpublic boolean isCheckFullyPopulated() {\n\t\treturn this.checkFullyPopulated;\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#isPrimitivesDefaultedForNullValue()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the value of the {@code primitivesDefaultedForNullValue} flag.\n\t * @see #setPrimitivesDefaultedForNullValue(boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "boolean",
    "signature": "public boolean isPrimitivesDefaultedForNullValue()",
    "source_code": "\tpublic boolean isPrimitivesDefaultedForNullValue() {\n\t\treturn this.primitivesDefaultedForNullValue;\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#newInstance(mappedClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create a new {@code BeanPropertyRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t * @see #newInstance(Class, ConversionService)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedClass"
    ],
    "position": {
      "column": 1,
      "line": 439
    },
    "return": "BeanPropertyRowMapper<T>",
    "signature": "public BeanPropertyRowMapper<T> newInstance(Class<T> mappedClass)",
    "source_code": "\tpublic static <T> BeanPropertyRowMapper<T> newInstance(Class<T> mappedClass) {\n\t\treturn new BeanPropertyRowMapper<>(mappedClass);\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#newInstance(mappedClass,conversionService)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create a new {@code BeanPropertyRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t * @param conversionService the {@link ConversionService} for binding\n\t * R2DBC values to bean properties, or {@code null} for none\n\t * @see #newInstance(Class)\n\t * @see #setConversionService\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedClass",
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 451
    },
    "return": "BeanPropertyRowMapper<T>",
    "signature": "public BeanPropertyRowMapper<T> newInstance(Class<T> mappedClass, @Nullable ConversionService conversionService)",
    "source_code": "\tpublic static <T> BeanPropertyRowMapper<T> newInstance("
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#setCheckFullyPopulated(checkFullyPopulated)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether we're strictly validating that all bean properties have been mapped\n\t * from corresponding database columns or out-parameters.\n\t * <p>Default is {@code false}, accepting unpopulated properties in the target bean.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "checkFullyPopulated"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "void",
    "signature": "public void setCheckFullyPopulated(boolean checkFullyPopulated)",
    "source_code": "\tpublic void setCheckFullyPopulated(boolean checkFullyPopulated) {\n\t\tthis.checkFullyPopulated = checkFullyPopulated;\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#setConversionService(conversionService)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a {@link ConversionService} for binding R2DBC values to bean properties,\n\t * or {@code null} for none.\n\t * <p>Default is a {@link DefaultConversionService}. This provides support for\n\t * {@code java.time} conversion and other special types.\n\t * @see #initBeanWrapper(BeanWrapper)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "void",
    "signature": "public void setConversionService(@Nullable ConversionService conversionService)",
    "source_code": "\tpublic void setConversionService(@Nullable ConversionService conversionService) {\n\t\tthis.conversionService = conversionService;\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#setPrimitivesDefaultedForNullValue(primitivesDefaultedForNullValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether a {@code NULL} database column or out-parameter value should\n\t * be ignored when mapping to a corresponding primitive property in the target class.\n\t * <p>Default is {@code false}, throwing an exception when nulls are mapped\n\t * to Java primitives.\n\t * <p>If this flag is set to {@code true} and you use an <em>ignored</em>\n\t * primitive property value from the mapped bean to update the database, the\n\t * value in the database will be changed from {@code NULL} to the current value\n\t * of that primitive property. That value may be the property's initial value\n\t * (potentially Java's default value for the respective primitive type), or\n\t * it may be some other value set for the property in the default constructor\n\t * (or initialization block) or as a side effect of setting some other property\n\t * in the mapped bean.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "primitivesDefaultedForNullValue"
    ],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "void",
    "signature": "public void setPrimitivesDefaultedForNullValue(boolean primitivesDefaultedForNullValue)",
    "source_code": "\tpublic void setPrimitivesDefaultedForNullValue(boolean primitivesDefaultedForNullValue) {\n\t\tthis.primitivesDefaultedForNullValue = primitivesDefaultedForNullValue;\n\t}"
  },
  "org.springframework.r2dbc.core.Parameter#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\tif (this == obj) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!(obj instanceof Parameter other)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (ObjectUtils.nullSafeEquals(this.value, other.value) &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.type, other.type));\n\t}"
  },
  "org.springframework.r2dbc.core.Parameter#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof Parameter that &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.value, that.value) &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.type, that.type)));\n\t}"
  },
  "org.springframework.r2dbc.core.logger": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/** Logger available to subclasses. */",
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A simple implementation of Spring's {@link TaskScheduler} interface, using\n * a single scheduler thread and executing every scheduled task in an individual\n * separate thread. This is an attractive choice with virtual threads on JDK 21,\n * expecting common usage with {@link #setVirtualThreads setVirtualThreads(true)}.\n *\n * <p>Supports a graceful shutdown through {@link #setTaskTerminationTimeout},\n * at the expense of task tracking overhead per execution thread at runtime.\n * Supports limiting concurrent threads through {@link #setConcurrencyLimit}.\n * By default, the number of concurrent task executions is unlimited.\n * This allows for dynamic concurrency of scheduled task executions, in contrast\n * to {@link ThreadPoolTaskScheduler} which requires a fixed pool size.\n *\n * <p><b>NOTE: This implementation does not reuse threads!</b> Consider a\n * thread-pooling TaskScheduler implementation instead, in particular for\n * scheduling a large number of short-lived tasks. Alternatively, on JDK 21,\n * consider setting {@link #setVirtualThreads} to {@code true}.\n *\n * <p>Extends {@link SimpleAsyncTaskExecutor} and can serve as a fully capable\n * replacement for it, e.g. as a single shared instance serving as a\n * {@link org.springframework.core.task.TaskExecutor} as well as a {@link TaskScheduler}.\n * This is generally not the case with other executor/scheduler implementations\n * which tend to have specific constraints for the scheduler thread pool,\n * requiring a separate thread pool for general executor purposes in practice.\n *\n * <p>As an alternative to the built-in thread-per-task capability, this scheduler\n * can also be configured with a separate target executor for scheduled task\n * execution through {@link #setTargetTaskExecutor}: e.g. pointing to a shared\n * {@link ThreadPoolTaskExecutor} bean. This is still rather different from a\n * {@link ThreadPoolTaskScheduler} setup since it always uses a single scheduler\n * thread while dynamically dispatching to the target thread pool which may have\n * a dynamic core/max pool size range, participating in a shared concurrency limit.\n *\n * @author Juergen Hoeller\n * @since 6.1\n * @see #setVirtualThreads\n * @see #setTaskTerminationTimeout\n * @see #setConcurrencyLimit\n * @see SimpleAsyncTaskExecutor\n * @see ThreadPoolTaskScheduler\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "signature": "public class SimpleAsyncTaskScheduler",
    "source_code": "public class SimpleAsyncTaskScheduler extends SimpleAsyncTaskExecutor implements TaskScheduler,"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#afterExecute(task,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "void",
    "signature": "protected void afterExecute(Runnable task, Throwable ex)",
    "source_code": "\t\t\tprotected void afterExecute(Runnable task, Throwable ex) {\n\t\t\t\tlifecycleDelegate.afterExecute();\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#beforeExecute(thread,task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "thread",
      "task"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "void",
    "signature": "protected void beforeExecute(Thread thread, Runnable task)",
    "source_code": "\t\t\tprotected void beforeExecute(Thread thread, Runnable task) {\n\t\t\t\tlifecycleDelegate.beforeExecute(thread);\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#close()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 285
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\tpublic void close() {\n\t\tfor (Runnable remainingTask : this.scheduledExecutor.shutdownNow()) {\n\t\t\tif (remainingTask instanceof Future<?> future) {\n\t\t\t\tfuture.cancel(true);\n\t\t\t}\n\t\t}\n\t\tsuper.close();\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#doExecute(task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "void",
    "signature": "protected void doExecute(Runnable task)",
    "source_code": "\tprotected void doExecute(Runnable task) {\n\t\tif (this.targetTaskExecutor != null) {\n\t\t\tthis.targetTaskExecutor.execute(task);\n\t\t}\n\t\telse {\n\t\t\tsuper.doExecute(task);\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#getClock()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "Clock",
    "signature": "public Clock getClock()",
    "source_code": "\tpublic Clock getClock() {\n\t\treturn this.clock;\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#getPhase()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the lifecycle phase for pausing and resuming this executor.\n\t * @see #setPhase\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "int",
    "signature": "public int getPhase()",
    "source_code": "\tpublic int getPhase() {\n\t\treturn this.phase;\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#isRunning()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "boolean",
    "signature": "public boolean isRunning()",
    "source_code": "\tpublic boolean isRunning() {\n\t\treturn this.lifecycleDelegate.isRunning();\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#onApplicationEvent(event)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "event"
    ],
    "position": {
      "column": 1,
      "line": 278
    },
    "return": "void",
    "signature": "public void onApplicationEvent(ContextClosedEvent event)",
    "source_code": "\tpublic void onApplicationEvent(ContextClosedEvent event) {\n\t\tif (event.getApplicationContext() == this.applicationContext) {\n\t\t\tthis.scheduledExecutor.shutdown();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#setApplicationContext(applicationContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "applicationContext"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "void",
    "signature": "public void setApplicationContext(ApplicationContext applicationContext)",
    "source_code": "\tpublic void setApplicationContext(ApplicationContext applicationContext) {\n\t\tthis.applicationContext = applicationContext;\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#setClock(clock)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the clock to use for scheduling purposes.\n\t * <p>The default clock is the system clock for the default time zone.\n\t * @since 5.3\n\t * @see Clock#systemDefaultZone()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clock"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "public void setClock(Clock clock)",
    "source_code": "\tpublic void setClock(Clock clock) {\n\t\tthis.clock = clock;\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#setPhase(phase)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the lifecycle phase for pausing and resuming this executor.\n\t * The default is {@link #DEFAULT_PHASE}.\n\t * @see SmartLifecycle#getPhase()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "phase"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void setPhase(int phase)",
    "source_code": "\tpublic void setPhase(int phase) {\n\t\tthis.phase = phase;\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#setTargetTaskExecutor(targetTaskExecutor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify a custom target {@link Executor} to delegate to for\n\t * the individual execution of scheduled tasks. This can for example\n\t * be set to a separate thread pool for executing scheduled tasks,\n\t * whereas this scheduler keeps using its single scheduler thread.\n\t * <p>If not set, the regular {@link SimpleAsyncTaskExecutor}\n\t * arrangements kicks in with a new thread per task.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetTaskExecutor"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "void",
    "signature": "public void setTargetTaskExecutor(Executor targetTaskExecutor)",
    "source_code": "\tpublic void setTargetTaskExecutor(Executor targetTaskExecutor) {\n\t\tthis.targetTaskExecutor = (targetTaskExecutor == this ? null : targetTaskExecutor);\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#start()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "void",
    "signature": "public void start()",
    "source_code": "\tpublic void start() {\n\t\tthis.lifecycleDelegate.start();\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#stop()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "void",
    "signature": "public void stop()",
    "source_code": "\tpublic void stop() {\n\t\tthis.lifecycleDelegate.stop();\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#stop(callback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 268
    },
    "return": "void",
    "signature": "public void stop(Runnable callback)",
    "source_code": "\tpublic void stop(Runnable callback) {\n\t\tthis.lifecycleDelegate.stop(callback);\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code MergedContextConfiguration} encapsulates the <em>merged</em> context\n * configuration declared on a test class and all of its superclasses and\n * enclosing classes via {@link ContextConfiguration @ContextConfiguration},\n * {@link ActiveProfiles @ActiveProfiles}, and\n * {@link TestPropertySource @TestPropertySource}.\n *\n * <p>Merged context resource locations, annotated classes, active profiles,\n * property resource locations, and in-lined properties represent all declared\n * values in the test class hierarchy and enclosing class hierarchy taking into\n * consideration the semantics of the {@link ContextConfiguration#inheritLocations},\n * {@link ActiveProfiles#inheritProfiles},\n * {@link TestPropertySource#inheritLocations}, and\n * {@link TestPropertySource#inheritProperties} flags.\n *\n * <p>A {@link SmartContextLoader} uses {@code MergedContextConfiguration}\n * to load an {@link org.springframework.context.ApplicationContext ApplicationContext}.\n *\n * <p>{@code MergedContextConfiguration} is also used by the\n * {@link org.springframework.test.context.cache.ContextCache ContextCache}\n * as the key for caching an\n * {@link org.springframework.context.ApplicationContext ApplicationContext}\n * that was loaded using properties of this {@code MergedContextConfiguration}.\n *\n * @author Sam Brannen\n * @author Phillip Webb\n * @since 3.1\n * @see ContextConfiguration\n * @see ContextHierarchy\n * @see ActiveProfiles\n * @see TestPropertySource\n * @see ContextConfigurationAttributes\n * @see SmartContextLoader#loadContext(MergedContextConfiguration)\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "signature": "public class MergedContextConfiguration",
    "source_code": "public class MergedContextConfiguration implements Serializable {\n\n\tprivate static final long serialVersionUID = -3290560718464957422L;\n\n\tprivate static final String[] EMPTY_STRING_ARRAY = new String[0];\n\n\tprivate static final Class<?>[] EMPTY_CLASS_ARRAY = new Class<?>[0];\n\n\tprivate static final Set<Class<? extends ApplicationContextInitializer<?>>> EMPTY_INITIALIZER_CLASSES =\n\t\t\tCollections.emptySet();\n\n\tprivate static final Set<ContextCustomizer> EMPTY_CONTEXT_CUSTOMIZERS = Collections.emptySet();\n\n\n\tprivate final Class<?> testClass;\n\n\tprivate final String[] locations;\n\n\tprivate final Class<?>[] classes;\n\n\t@SuppressWarnings(\"serial\")\n\tprivate final Set<Class<? extends ApplicationContextInitializer<?>>> contextInitializerClasses;\n\n\tprivate final String[] activeProfiles;\n\n\tprivate final List<PropertySourceDescriptor> propertySourceDescriptors;\n\n\tprivate final String[] propertySourceLocations;\n\n\tprivate final String[] propertySourceProperties;\n\n\t@SuppressWarnings(\"serial\")\n\tprivate final Set<ContextCustomizer> contextCustomizers;\n\n\t@SuppressWarnings(\"serial\")\n\tprivate final ContextLoader contextLoader;\n\n\t@Nullable\n\t@SuppressWarnings(\"serial\")\n\tprivate final CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate;\n\n\t@Nullable\n\tprivate final MergedContextConfiguration parent;\n\n\n\t/**\n\t * Create a new {@code MergedContextConfiguration} instance for the\n\t * supplied parameters.\n\t * @param testClass the test class for which the configuration was merged\n\t * @param locations the merged context resource locations\n\t * @param classes the merged annotated classes\n\t * @param activeProfiles the merged active bean definition profiles\n\t * @param contextLoader the resolved {@code ContextLoader}\n\t */\n\tpublic MergedContextConfiguration(Class<?> testClass, @Nullable String[] locations, @Nullable Class<?>[] classes,\n\t\t\t@Nullable String[] activeProfiles, ContextLoader contextLoader) {\n\n\t\tthis(testClass, locations, classes, null, activeProfiles, contextLoader);\n\t}\n\n\t/**\n\t * Create a new {@code MergedContextConfiguration} instance for the\n\t * supplied parameters.\n\t * @param testClass the test class for which the configuration was merged\n\t * @param locations the merged context resource locations\n\t * @param classes the merged annotated classes\n\t * @param contextInitializerClasses the merged context initializer classes\n\t * @param activeProfiles the merged active bean definition profiles\n\t * @param contextLoader the resolved {@code ContextLoader}\n\t */\n\tpublic MergedContextConfiguration(Class<?> testClass, @Nullable String[] locations, @Nullable Class<?>[] classes,\n\t\t\t@Nullable Set<Class<? extends ApplicationContextInitializer<?>>> contextInitializerClasses,\n\t\t\t@Nullable String[] activeProfiles, ContextLoader contextLoader) {\n\n\t\tthis(testClass, locations, classes, contextInitializerClasses, activeProfiles, contextLoader, null, null);\n\t}\n\n\t/**\n\t * Create a new {@code MergedContextConfiguration} instance for the\n\t * supplied parameters.\n\t * @param testClass the test class for which the configuration was merged\n\t * @param locations the merged context resource locations\n\t * @param classes the merged annotated classes\n\t * @param contextInitializerClasses the merged context initializer classes\n\t * @param activeProfiles the merged active bean definition profiles\n\t * @param contextLoader the resolved {@code ContextLoader}\n\t * @param cacheAwareContextLoaderDelegate a cache-aware context loader\n\t * delegate with which to retrieve the parent {@code ApplicationContext}\n\t * @param parent the parent configuration or {@code null} if there is no parent\n\t * @since 3.2.2\n\t */\n\tpublic MergedContextConfiguration(Class<?> testClass, @Nullable String[] locations, @Nullable Class<?>[] classes,\n\t\t\t@Nullable Set<Class<? extends ApplicationContextInitializer<?>>> contextInitializerClasses,\n\t\t\t@Nullable String[] activeProfiles, ContextLoader contextLoader,\n\t\t\t@Nullable CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate,\n\t\t\t@Nullable MergedContextConfiguration parent) {\n\n\t\tthis(testClass, locations, classes, contextInitializerClasses, activeProfiles, null, null,\n\t\t\t\tcontextLoader, cacheAwareContextLoaderDelegate, parent);\n\t}\n\n\t/**\n\t * Create a new {@code MergedContextConfiguration} instance by copying\n\t * all fields from the supplied {@code MergedContextConfiguration}.\n\t * @since 4.1\n\t */\n\tpublic MergedContextConfiguration(MergedContextConfiguration mergedConfig) {\n\t\tthis(mergedConfig.testClass, mergedConfig.locations, mergedConfig.classes,\n\t\t\t\tmergedConfig.contextInitializerClasses, mergedConfig.activeProfiles,\n\t\t\t\tmergedConfig.propertySourceDescriptors, mergedConfig.propertySourceProperties,\n\t\t\t\tmergedConfig.contextCustomizers, mergedConfig.contextLoader,\n\t\t\t\tmergedConfig.cacheAwareContextLoaderDelegate, mergedConfig.parent);\n\t}\n\n\t/**\n\t * Create a new {@code MergedContextConfiguration} instance for the\n\t * supplied parameters.\n\t * <p>If a {@code null} value is supplied for {@code locations},\n\t * {@code classes}, {@code activeProfiles}, {@code propertySourceLocations},\n\t * or {@code propertySourceProperties} an empty array will be stored instead.\n\t * If a {@code null} value is supplied for the\n\t * {@code contextInitializerClasses} an empty set will be stored instead.\n\t * Furthermore, active profiles will be sorted, and duplicate profiles\n\t * will be removed.\n\t * @param testClass the test class for which the configuration was merged\n\t * @param locations the merged context resource locations\n\t * @param classes the merged annotated classes\n\t * @param contextInitializerClasses the merged context initializer classes\n\t * @param activeProfiles the merged active bean definition profiles\n\t * @param propertySourceLocations the merged {@code PropertySource} locations\n\t * @param propertySourceProperties the merged {@code PropertySource} properties\n\t * @param contextLoader the resolved {@code ContextLoader}\n\t * @param cacheAwareContextLoaderDelegate a cache-aware context loader\n\t * delegate with which to retrieve the parent {@code ApplicationContext}\n\t * @param parent the parent configuration or {@code null} if there is no parent\n\t * @since 4.1\n\t * @deprecated since 6.1 in favor of\n\t * {@link #MergedContextConfiguration(Class, String[], Class[], Set, String[], List, String[], Set, ContextLoader, CacheAwareContextLoaderDelegate, MergedContextConfiguration)}\n\t */\n\t@Deprecated(since = \"6.1\")\n\tpublic MergedContextConfiguration(Class<?> testClass, @Nullable String[] locations, @Nullable Class<?>[] classes,\n\t\t\t@Nullable Set<Class<? extends ApplicationContextInitializer<?>>> contextInitializerClasses,\n\t\t\t@Nullable String[] activeProfiles, @Nullable String[] propertySourceLocations,\n\t\t\t@Nullable String[] propertySourceProperties, ContextLoader contextLoader,\n\t\t\t@Nullable CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate,\n\t\t\t@Nullable MergedContextConfiguration parent) {\n\n\t\tthis(testClass, locations, classes, contextInitializerClasses, activeProfiles,\n\t\t\t\tpropertySourceLocations, propertySourceProperties,\n\t\t\t\tEMPTY_CONTEXT_CUSTOMIZERS, contextLoader,\n\t\t\t\tcacheAwareContextLoaderDelegate, parent);\n\t}\n\n\t/**\n\t * Create a new {@code MergedContextConfiguration} instance for the\n\t * supplied parameters.\n\t * <p>If a {@code null} value is supplied for {@code locations},\n\t * {@code classes}, {@code activeProfiles}, {@code propertySourceLocations},\n\t * or {@code propertySourceProperties} an empty array will be stored instead.\n\t * If a {@code null} value is supplied for {@code contextInitializerClasses}\n\t * or {@code contextCustomizers}, an empty set will be stored instead.\n\t * Furthermore, active profiles will be sorted, and duplicate profiles\n\t * will be removed.\n\t * @param testClass the test class for which the configuration was merged\n\t * @param locations the merged context resource locations\n\t * @param classes the merged annotated classes\n\t * @param contextInitializerClasses the merged context initializer classes\n\t * @param activeProfiles the merged active bean definition profiles\n\t * @param propertySourceLocations the merged {@code PropertySource} locations\n\t * @param propertySourceProperties the merged {@code PropertySource} properties\n\t * @param contextCustomizers the context customizers\n\t * @param contextLoader the resolved {@code ContextLoader}\n\t * @param cacheAwareContextLoaderDelegate a cache-aware context loader\n\t * delegate with which to retrieve the parent {@code ApplicationContext}\n\t * @param parent the parent configuration or {@code null} if there is no parent\n\t * @since 4.3\n\t * @deprecated since 6.1 in favor of\n\t * {@link #MergedContextConfiguration(Class, String[], Class[], Set, String[], List, String[], Set, ContextLoader, CacheAwareContextLoaderDelegate, MergedContextConfiguration)}\n\t */\n\t@Deprecated(since = \"6.1\")\n\tpublic MergedContextConfiguration(Class<?> testClass, @Nullable String[] locations, @Nullable Class<?>[] classes,\n\t\t\t@Nullable Set<Class<? extends ApplicationContextInitializer<?>>> contextInitializerClasses,\n\t\t\t@Nullable String[] activeProfiles, @Nullable String[] propertySourceLocations,\n\t\t\t@Nullable String[] propertySourceProperties, @Nullable Set<ContextCustomizer> contextCustomizers,\n\t\t\tContextLoader contextLoader, @Nullable CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate,\n\t\t\t@Nullable MergedContextConfiguration parent) {\n\n\t\tthis(testClass, locations, classes, contextInitializerClasses, activeProfiles,\n\t\t\tList.of(new PropertySourceDescriptor(processStrings(propertySourceLocations))),\n\t\t\tpropertySourceProperties, contextCustomizers, contextLoader, cacheAwareContextLoaderDelegate,\n\t\t\tparent);\n\t}\n\n\t/**\n\t * Create a new {@code MergedContextConfiguration} instance for the supplied\n\t * parameters.\n\t * <p>If a {@code null} value is supplied for {@code locations}, {@code classes},\n\t * {@code activeProfiles}, or {@code propertySourceProperties} an empty array\n\t * will be stored instead. If a {@code null} value is supplied for\n\t * {@code contextInitializerClasses} or {@code contextCustomizers}, an empty\n\t * set will be stored instead. Furthermore, active profiles will be sorted,\n\t * and duplicate profiles will be removed.\n\t * @param testClass the test class for which the configuration was merged\n\t * @param locations the merged context resource locations\n\t * @param classes the merged annotated classes\n\t * @param contextInitializerClasses the merged context initializer classes\n\t * @param activeProfiles the merged active bean definition profiles\n\t * @param propertySourceDescriptors the merged property source descriptors\n\t * @param propertySourceProperties the merged inlined properties\n\t * @param contextCustomizers the context customizers\n\t * @param contextLoader the resolved {@code ContextLoader}\n\t * @param cacheAwareContextLoaderDelegate a cache-aware context loader\n\t * delegate with which to retrieve the parent {@code ApplicationContext}\n\t * @param parent the parent configuration or {@code null} if there is no parent\n\t * @since 6.1\n\t */\n\tpublic MergedContextConfiguration(Class<?> testClass, @Nullable String[] locations, @Nullable Class<?>[] classes,\n\t\t\t@Nullable Set<Class<? extends ApplicationContextInitializer<?>>> contextInitializerClasses,\n\t\t\t@Nullable String[] activeProfiles, List<PropertySourceDescriptor> propertySourceDescriptors,\n\t\t\t@Nullable String[] propertySourceProperties, @Nullable Set<ContextCustomizer> contextCustomizers,\n\t\t\tContextLoader contextLoader, @Nullable CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate,\n\t\t\t@Nullable MergedContextConfiguration parent) {\n\n\t\tthis.testClass = testClass;\n\t\tthis.locations = processStrings(locations);\n\t\tthis.classes = processClasses(classes);\n\t\tthis.contextInitializerClasses = processContextInitializerClasses(contextInitializerClasses);\n\t\tthis.activeProfiles = processActiveProfiles(activeProfiles);\n\t\tthis.propertySourceDescriptors = Collections.unmodifiableList(propertySourceDescriptors);\n\t\tthis.propertySourceLocations = this.propertySourceDescriptors.stream()\n\t\t\t\t.map(PropertySourceDescriptor::locations)\n\t\t\t\t.flatMap(List::stream)\n\t\t\t\t.toArray(String[]::new);\n\t\tthis.propertySourceProperties = processStrings(propertySourceProperties);\n\t\tthis.contextCustomizers = processContextCustomizers(contextCustomizers);\n\t\tthis.contextLoader = contextLoader;\n\t\tthis.cacheAwareContextLoaderDelegate = cacheAwareContextLoaderDelegate;\n\t\tthis.parent = parent;\n\t}\n\n\n\t/**\n\t * Get the {@linkplain Class test class} associated with this\n\t * {@code MergedContextConfiguration}.\n\t */\n\tpublic Class<?> getTestClass() {\n\t\treturn this.testClass;\n\t}\n\n\t/**\n\t * Get the merged resource locations for {@code ApplicationContext}\n\t * configuration files for the {@linkplain #getTestClass() test class}.\n\t * <p>Context resource locations typically represent XML configuration\n\t * files or Groovy scripts.\n\t */\n\tpublic String[] getLocations() {\n\t\treturn this.locations;\n\t}\n\n\t/**\n\t * Get the merged annotated classes for the {@linkplain #getTestClass() test class}.\n\t */\n\tpublic Class<?>[] getClasses() {\n\t\treturn this.classes;\n\t}\n\n\t/**\n\t * Determine if this {@code MergedContextConfiguration} instance has\n\t * path-based context resource locations.\n\t * @return {@code true} if the {@link #getLocations() locations} array is not empty\n\t * @since 4.0.4\n\t * @see #hasResources()\n\t * @see #hasClasses()\n\t */\n\tpublic boolean hasLocations() {\n\t\treturn !ObjectUtils.isEmpty(getLocations());\n\t}\n\n\t/**\n\t * Determine if this {@code MergedContextConfiguration} instance has\n\t * class-based resources.\n\t * @return {@code true} if the {@link #getClasses() classes} array is not empty\n\t * @since 4.0.4\n\t * @see #hasResources()\n\t * @see #hasLocations()\n\t */\n\tpublic boolean hasClasses() {\n\t\treturn !ObjectUtils.isEmpty(getClasses());\n\t}\n\n\t/**\n\t * Determine if this {@code MergedContextConfiguration} instance has\n\t * either path-based context resource locations or class-based resources.\n\t * @return {@code true} if either the {@link #getLocations() locations}\n\t * or the {@link #getClasses() classes} array is not empty\n\t * @since 4.0.4\n\t * @see #hasLocations()\n\t * @see #hasClasses()\n\t */\n\tpublic boolean hasResources() {\n\t\treturn (hasLocations() || hasClasses());\n\t}\n\n\t/**\n\t * Get the merged {@code ApplicationContextInitializer} classes for the\n\t * {@linkplain #getTestClass() test class}.\n\t */\n\tpublic Set<Class<? extends ApplicationContextInitializer<?>>> getContextInitializerClasses() {\n\t\treturn this.contextInitializerClasses;\n\t}\n\n\t/**\n\t * Get the merged active bean definition profiles for the\n\t * {@linkplain #getTestClass() test class}.\n\t * @see ActiveProfiles\n\t */\n\tpublic String[] getActiveProfiles() {\n\t\treturn this.activeProfiles;\n\t}\n\n\t/**\n\t * Get the merged descriptors for resource locations for test {@code PropertySources}\n\t * for the {@linkplain #getTestClass() test class}.\n\t * <p>Properties will be loaded into the {@code Environment}'s set of\n\t * {@code PropertySources}.\n\t * @since 6.1\n\t * @see TestPropertySource#locations\n\t * @see TestPropertySource#encoding\n\t * @see TestPropertySource#factory\n\t */\n\tpublic List<PropertySourceDescriptor> getPropertySourceDescriptors() {\n\t\treturn this.propertySourceDescriptors;\n\t}\n\n\t/**\n\t * Get the merged resource locations of properties files for the\n\t * {@linkplain #getTestClass() test class}.\n\t * @see TestPropertySource#locations\n\t * @see java.util.Properties\n\t * @deprecated since 6.1 in favor of {@link #getPropertySourceDescriptors()}\n\t */\n\t@Deprecated(since = \"6.1\")\n\tpublic String[] getPropertySourceLocations() {\n\t\treturn this.propertySourceLocations;\n\t}\n\n\t/**\n\t * Get the merged inlined properties for the {@linkplain #getTestClass() test class}.\n\t * <p>Properties will be loaded into the {@code Environment}'s set of\n\t * {@code PropertySources}.\n\t * @see TestPropertySource#properties\n\t * @see java.util.Properties\n\t */\n\tpublic String[] getPropertySourceProperties() {\n\t\treturn this.propertySourceProperties;\n\t}\n\n\t/**\n\t * Get the merged {@link ContextCustomizer ContextCustomizers} that will be applied\n\t * when the application context is loaded.\n\t */\n\tpublic Set<ContextCustomizer> getContextCustomizers() {\n\t\treturn this.contextCustomizers;\n\t}\n\n\t/**\n\t * Get the resolved {@link ContextLoader} for the {@linkplain #getTestClass() test class}.\n\t */\n\tpublic ContextLoader getContextLoader() {\n\t\treturn this.contextLoader;\n\t}\n\n\t/**\n\t * Get the {@link MergedContextConfiguration} for the parent application context\n\t * in a context hierarchy.\n\t * @return the parent configuration or {@code null} if there is no parent\n\t * @since 3.2.2\n\t * @see #getParentApplicationContext()\n\t */\n\t@Nullable\n\tpublic MergedContextConfiguration getParent() {\n\t\treturn this.parent;\n\t}\n\n\t/**\n\t * Get the parent {@link ApplicationContext} for the context defined by this\n\t * {@code MergedContextConfiguration} from the context cache.\n\t * <p>If the parent context has not yet been loaded, it will be loaded, stored\n\t * in the cache, and then returned.\n\t * @return the parent {@code ApplicationContext} or {@code null} if there is no parent\n\t * @since 3.2.2\n\t * @see #getParent()\n\t */\n\t@Nullable\n\tpublic ApplicationContext getParentApplicationContext() {\n\t\tif (this.parent == null) {\n\t\t\treturn null;\n\t\t}\n\t\tAssert.state(this.cacheAwareContextLoaderDelegate != null,\n\t\t\t\t\"Cannot retrieve a parent application context without access to the CacheAwareContextLoaderDelegate\");\n\t\treturn this.cacheAwareContextLoaderDelegate.loadContext(this.parent);\n\t}\n\n\n\t/**\n\t * Determine if the supplied object is equal to this {@code MergedContextConfiguration}\n\t * instance by comparing both objects' {@linkplain #getLocations() locations},\n\t * {@linkplain #getClasses() annotated classes},\n\t * {@linkplain #getContextInitializerClasses() context initializer classes},\n\t * {@linkplain #getActiveProfiles() active profiles},\n\t * {@linkplain #getPropertySourceDescriptors() property source descriptors},\n\t * {@linkplain #getPropertySourceProperties() property source properties},\n\t * {@linkplain #getContextCustomizers() context customizers},\n\t * {@linkplain #getParent() parents}, and the fully qualified names of their\n\t * {@link #getContextLoader() ContextLoaders}.\n\t */\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (other == null || other.getClass() != getClass()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tMergedContextConfiguration otherConfig = (MergedContextConfiguration) other;\n\t\tif (!Arrays.equals(this.locations, otherConfig.locations)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!Arrays.equals(this.classes, otherConfig.classes)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!this.contextInitializerClasses.equals(otherConfig.contextInitializerClasses)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!Arrays.equals(this.activeProfiles, otherConfig.activeProfiles)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!this.propertySourceDescriptors.equals(otherConfig.propertySourceDescriptors)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!Arrays.equals(this.propertySourceProperties, otherConfig.propertySourceProperties)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!this.contextCustomizers.equals(otherConfig.contextCustomizers)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.parent == null) {\n\t\t\tif (otherConfig.parent != null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (!this.parent.equals(otherConfig.parent)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!nullSafeClassName(this.contextLoader).equals(nullSafeClassName(otherConfig.contextLoader))) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Generate a unique hash code for all properties of this\n\t * {@code MergedContextConfiguration} excluding the\n\t * {@linkplain #getTestClass() test class}.\n\t */\n\t@Override\n\tpublic int hashCode() {\n\t\tint result = Arrays.hashCode(this.locations);\n\t\tresult = 31 * result + Arrays.hashCode(this.classes);\n\t\tresult = 31 * result + this.contextInitializerClasses.hashCode();\n\t\tresult = 31 * result + Arrays.hashCode(this.activeProfiles);\n\t\tresult = 31 * result + this.propertySourceDescriptors.hashCode();\n\t\tresult = 31 * result + Arrays.hashCode(this.propertySourceProperties);\n\t\tresult = 31 * result + this.contextCustomizers.hashCode();\n\t\tresult = 31 * result + (this.parent != null ? this.parent.hashCode() : 0);\n\t\tresult = 31 * result + nullSafeClassName(this.contextLoader).hashCode();\n\t\treturn result;\n\t}\n\n\t/**\n\t * Provide a String representation of the {@linkplain #getTestClass() test class},\n\t * {@linkplain #getLocations() locations}, {@linkplain #getClasses() annotated classes},\n\t * {@linkplain #getContextInitializerClasses() context initializer classes},\n\t * {@linkplain #getActiveProfiles() active profiles},\n\t * {@linkplain #getPropertySourceDescriptors() property source descriptors},\n\t * {@linkplain #getPropertySourceProperties() property source properties},\n\t * {@linkplain #getContextCustomizers() context customizers},\n\t * the name of the {@link #getContextLoader() ContextLoader}, and the\n\t * {@linkplain #getParent() parent configuration}.\n\t */\n\t@Override\n\tpublic String toString() {\n\t\treturn new ToStringCreator(this, new DefaultToStringStyler(new SimpleValueStyler()))\n\t\t\t\t.append(\"testClass\", this.testClass)\n\t\t\t\t.append(\"locations\", this.locations)\n\t\t\t\t.append(\"classes\", this.classes)\n\t\t\t\t.append(\"contextInitializerClasses\", this.contextInitializerClasses)\n\t\t\t\t.append(\"activeProfiles\", this.activeProfiles)\n\t\t\t\t.append(\"propertySourceDescriptors\", this.propertySourceDescriptors)\n\t\t\t\t.append(\"propertySourceProperties\", this.propertySourceProperties)\n\t\t\t\t.append(\"contextCustomizers\", this.contextCustomizers)\n\t\t\t\t.append(\"contextLoader\", (this.contextLoader != null ? this.contextLoader.getClass() : null))\n\t\t\t\t.append(\"parent\", this.parent)\n\t\t\t\t.toString();\n\t}\n\n\n\tprotected static String[] processStrings(@Nullable String[] array) {\n\t\treturn (array != null ? array : EMPTY_STRING_ARRAY);\n\t}\n\n\tprivate static Class<?>[] processClasses(@Nullable Class<?>[] classes) {\n\t\treturn (classes != null ? classes : EMPTY_CLASS_ARRAY);\n\t}\n\n\tprivate static Set<Class<? extends ApplicationContextInitializer<?>>> processContextInitializerClasses(\n\t\t\t@Nullable Set<Class<? extends ApplicationContextInitializer<?>>> contextInitializerClasses) {\n\n\t\treturn (contextInitializerClasses != null ?\n\t\t\t\tCollections.unmodifiableSet(contextInitializerClasses) : EMPTY_INITIALIZER_CLASSES);\n\t}\n\n\tprivate static Set<ContextCustomizer> processContextCustomizers(\n\t\t\t@Nullable Set<ContextCustomizer> contextCustomizers) {\n\n\t\treturn (contextCustomizers != null ?\n\t\t\t\tCollections.unmodifiableSet(contextCustomizers) : EMPTY_CONTEXT_CUSTOMIZERS);\n\t}\n\n\tprivate static String[] processActiveProfiles(@Nullable String[] activeProfiles) {\n\t\tif (activeProfiles == null) {\n\t\t\treturn EMPTY_STRING_ARRAY;\n\t\t}\n\n\t\t// Active profiles must be unique\n\t\tSet<String> profilesSet = new LinkedHashSet<>(Arrays.asList(activeProfiles));\n\t\treturn StringUtils.toStringArray(profilesSet);\n\t}\n\n\t/**\n\t * Generate a null-safe {@link String} representation of the supplied\n\t * {@link ContextLoader} based solely on the fully qualified name of the\n\t * loader or &quot;null&quot; if the supplied loader is {@code null}.\n\t */\n\tprotected static String nullSafeClassName(@Nullable ContextLoader contextLoader) {\n\t\treturn (contextLoader != null ? contextLoader.getClass().getName() : \"null\");\n\t}\n\n}"
  },
  "org.springframework.test.context.MergedContextConfiguration#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied object is equal to this {@code MergedContextConfiguration}\n\t * instance by comparing both objects' {@linkplain #getLocations() locations},\n\t * {@linkplain #getClasses() annotated classes},\n\t * {@linkplain #getContextInitializerClasses() context initializer classes},\n\t * {@linkplain #getActiveProfiles() active profiles},\n\t * {@linkplain #getPropertySourceDescriptors() property source descriptors},\n\t * {@linkplain #getPropertySourceProperties() property source properties},\n\t * {@linkplain #getContextCustomizers() context customizers},\n\t * {@linkplain #getParent() parents}, and the fully qualified names of their\n\t * {@link #getContextLoader() ContextLoaders}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 488
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (other == null || other.getClass() != getClass()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tMergedContextConfiguration otherConfig = (MergedContextConfiguration) other;\n\t\tif (!Arrays.equals(this.locations, otherConfig.locations)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!Arrays.equals(this.classes, otherConfig.classes)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!this.contextInitializerClasses.equals(otherConfig.contextInitializerClasses)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!Arrays.equals(this.activeProfiles, otherConfig.activeProfiles)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!this.propertySourceDescriptors.equals(otherConfig.propertySourceDescriptors)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!Arrays.equals(this.propertySourceProperties, otherConfig.propertySourceProperties)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!this.contextCustomizers.equals(otherConfig.contextCustomizers)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.parent == null) {\n\t\t\tif (otherConfig.parent != null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (!this.parent.equals(otherConfig.parent)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!nullSafeClassName(this.contextLoader).equals(nullSafeClassName(otherConfig.contextLoader))) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#getActiveProfiles()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the merged active bean definition profiles for the\n\t * {@linkplain #getTestClass() test class}.\n\t * @see ActiveProfiles\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 387
    },
    "return": "String[]",
    "signature": "public String[] getActiveProfiles()",
    "source_code": "\tpublic String[] getActiveProfiles() {\n\t\treturn this.activeProfiles;\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#getContextCustomizers()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the merged {@link ContextCustomizer ContextCustomizers} that will be applied\n\t * when the application context is loaded.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 432
    },
    "return": "Set<ContextCustomizer>",
    "signature": "public Set<ContextCustomizer> getContextCustomizers()",
    "source_code": "\tpublic Set<ContextCustomizer> getContextCustomizers() {\n\t\treturn this.contextCustomizers;\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#getContextLoader()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the resolved {@link ContextLoader} for the {@linkplain #getTestClass() test class}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 439
    },
    "return": "ContextLoader",
    "signature": "public ContextLoader getContextLoader()",
    "source_code": "\tpublic ContextLoader getContextLoader() {\n\t\treturn this.contextLoader;\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#getLocations()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the merged resource locations for {@code ApplicationContext}\n\t * configuration files for the {@linkplain #getTestClass() test class}.\n\t * <p>Context resource locations typically represent XML configuration\n\t * files or Groovy scripts.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 326
    },
    "return": "String[]",
    "signature": "public String[] getLocations()",
    "source_code": "\tpublic String[] getLocations() {\n\t\treturn this.locations;\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#getParent()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the {@link MergedContextConfiguration} for the parent application context\n\t * in a context hierarchy.\n\t * @return the parent configuration or {@code null} if there is no parent\n\t * @since 3.2.2\n\t * @see #getParentApplicationContext()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 451
    },
    "return": "MergedContextConfiguration",
    "signature": "public MergedContextConfiguration getParent()",
    "source_code": "\tpublic MergedContextConfiguration getParent() {\n\t\treturn this.parent;\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#getParentApplicationContext()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the parent {@link ApplicationContext} for the context defined by this\n\t * {@code MergedContextConfiguration} from the context cache.\n\t * <p>If the parent context has not yet been loaded, it will be loaded, stored\n\t * in the cache, and then returned.\n\t * @return the parent {@code ApplicationContext} or {@code null} if there is no parent\n\t * @since 3.2.2\n\t * @see #getParent()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 465
    },
    "return": "ApplicationContext",
    "signature": "public ApplicationContext getParentApplicationContext()",
    "source_code": "\tpublic ApplicationContext getParentApplicationContext() {\n\t\tif (this.parent == null) {\n\t\t\treturn null;\n\t\t}\n\t\tAssert.state(this.cacheAwareContextLoaderDelegate != null,\n\t\t\t\t\"Cannot retrieve a parent application context without access to the CacheAwareContextLoaderDelegate\");\n\t\treturn this.cacheAwareContextLoaderDelegate.loadContext(this.parent);\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#getPropertySourceDescriptors()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the merged descriptors for resource locations for test {@code PropertySources}\n\t * for the {@linkplain #getTestClass() test class}.\n\t * <p>Properties will be loaded into the {@code Environment}'s set of\n\t * {@code PropertySources}.\n\t * @since 6.1\n\t * @see TestPropertySource#locations\n\t * @see TestPropertySource#encoding\n\t * @see TestPropertySource#factory\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 401
    },
    "return": "List<PropertySourceDescriptor>",
    "signature": "public List<PropertySourceDescriptor> getPropertySourceDescriptors()",
    "source_code": "\tpublic List<PropertySourceDescriptor> getPropertySourceDescriptors() {\n\t\treturn this.propertySourceDescriptors;\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#getPropertySourceLocations()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the merged resource locations of properties files for the\n\t * {@linkplain #getTestClass() test class}.\n\t * @see TestPropertySource#locations\n\t * @see java.util.Properties\n\t * @deprecated since 6.1 in favor of {@link #getPropertySourceDescriptors()}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 413
    },
    "return": "String[]",
    "signature": "public String[] getPropertySourceLocations()",
    "source_code": "\tpublic String[] getPropertySourceLocations() {\n\t\treturn this.propertySourceLocations;\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#getPropertySourceProperties()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the merged inlined properties for the {@linkplain #getTestClass() test class}.\n\t * <p>Properties will be loaded into the {@code Environment}'s set of\n\t * {@code PropertySources}.\n\t * @see TestPropertySource#properties\n\t * @see java.util.Properties\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 424
    },
    "return": "String[]",
    "signature": "public String[] getPropertySourceProperties()",
    "source_code": "\tpublic String[] getPropertySourceProperties() {\n\t\treturn this.propertySourceProperties;\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#hasClasses()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if this {@code MergedContextConfiguration} instance has\n\t * class-based resources.\n\t * @return {@code true} if the {@link #getClasses() classes} array is not empty\n\t * @since 4.0.4\n\t * @see #hasResources()\n\t * @see #hasLocations()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 357
    },
    "return": "boolean",
    "signature": "public boolean hasClasses()",
    "source_code": "\tpublic boolean hasClasses() {\n\t\treturn !ObjectUtils.isEmpty(getClasses());\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#hasLocations()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if this {@code MergedContextConfiguration} instance has\n\t * path-based context resource locations.\n\t * @return {@code true} if the {@link #getLocations() locations} array is not empty\n\t * @since 4.0.4\n\t * @see #hasResources()\n\t * @see #hasClasses()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 345
    },
    "return": "boolean",
    "signature": "public boolean hasLocations()",
    "source_code": "\tpublic boolean hasLocations() {\n\t\treturn !ObjectUtils.isEmpty(getLocations());\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#hasResources()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if this {@code MergedContextConfiguration} instance has\n\t * either path-based context resource locations or class-based resources.\n\t * @return {@code true} if either the {@link #getLocations() locations}\n\t * or the {@link #getClasses() classes} array is not empty\n\t * @since 4.0.4\n\t * @see #hasLocations()\n\t * @see #hasClasses()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 370
    },
    "return": "boolean",
    "signature": "public boolean hasResources()",
    "source_code": "\tpublic boolean hasResources() {\n\t\treturn (hasLocations() || hasClasses());\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate a unique hash code for all properties of this\n\t * {@code MergedContextConfiguration} excluding the\n\t * {@linkplain #getTestClass() test class}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 541
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\tint result = Arrays.hashCode(this.locations);\n\t\tresult = 31 * result + Arrays.hashCode(this.classes);\n\t\tresult = 31 * result + this.contextInitializerClasses.hashCode();\n\t\tresult = 31 * result + Arrays.hashCode(this.activeProfiles);\n\t\tresult = 31 * result + this.propertySourceDescriptors.hashCode();\n\t\tresult = 31 * result + Arrays.hashCode(this.propertySourceProperties);\n\t\tresult = 31 * result + this.contextCustomizers.hashCode();\n\t\tresult = 31 * result + (this.parent != null ? this.parent.hashCode() : 0);\n\t\tresult = 31 * result + nullSafeClassName(this.contextLoader).hashCode();\n\t\treturn result;\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#nullSafeClassName(contextLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate a null-safe {@link String} representation of the supplied\n\t * {@link ContextLoader} based solely on the fully qualified name of the\n\t * loader or &quot;null&quot; if the supplied loader is {@code null}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "contextLoader"
    ],
    "position": {
      "column": 1,
      "line": 619
    },
    "return": "String",
    "signature": "protected String nullSafeClassName(@Nullable ContextLoader contextLoader)",
    "source_code": "\tprotected static String nullSafeClassName(@Nullable ContextLoader contextLoader) {\n\t\treturn (contextLoader != null ? contextLoader.getClass().getName() : \"null\");\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#processStrings(array)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "array"
    ],
    "position": {
      "column": 1,
      "line": 582
    },
    "return": "String[]",
    "signature": "protected String[] processStrings(@Nullable String[] array)",
    "source_code": "\tprotected static String[] processStrings(@Nullable String[] array) {\n\t\treturn (array != null ? array : EMPTY_STRING_ARRAY);\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide a String representation of the {@linkplain #getTestClass() test class},\n\t * {@linkplain #getLocations() locations}, {@linkplain #getClasses() annotated classes},\n\t * {@linkplain #getContextInitializerClasses() context initializer classes},\n\t * {@linkplain #getActiveProfiles() active profiles},\n\t * {@linkplain #getPropertySourceDescriptors() property source descriptors},\n\t * {@linkplain #getPropertySourceProperties() property source properties},\n\t * {@linkplain #getContextCustomizers() context customizers},\n\t * the name of the {@link #getContextLoader() ContextLoader}, and the\n\t * {@linkplain #getParent() parent configuration}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 566
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn new ToStringCreator(this, new DefaultToStringStyler(new SimpleValueStyler()))\n\t\t\t\t.append(\"testClass\", this.testClass)\n\t\t\t\t.append(\"locations\", this.locations)\n\t\t\t\t.append(\"classes\", this.classes)\n\t\t\t\t.append(\"contextInitializerClasses\", this.contextInitializerClasses)\n\t\t\t\t.append(\"activeProfiles\", this.activeProfiles)\n\t\t\t\t.append(\"propertySourceDescriptors\", this.propertySourceDescriptors)\n\t\t\t\t.append(\"propertySourceProperties\", this.propertySourceProperties)\n\t\t\t\t.append(\"contextCustomizers\", this.contextCustomizers)\n\t\t\t\t.append(\"contextLoader\", (this.contextLoader != null ? this.contextLoader.getClass() : null))\n\t\t\t\t.append(\"parent\", this.parent)\n\t\t\t\t.toString();\n\t}"
  },
  "org.springframework.test.context.aot.FAIL_ON_ERROR_PROPERTY_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * JVM system property used to set the {@code failOnError} flag: {@value}.\n\t * <p>The {@code failOnError} flag controls whether errors encountered during\n\t * AOT processing in the <em>Spring TestContext Framework</em> should result\n\t * in an exception that fails the overall process.\n\t * <p>Defaults to {@code true}.\n\t * <p>Supported values include {@code true} or {@code false}, ignoring case.\n\t * For example, the default may be changed to {@code false} by supplying\n\t * the following JVM system property via the command line.\n\t * <pre style=\"code\">-Dspring.test.aot.processing.failOnError=false</pre>\n\t * <p>May alternatively be configured via the\n\t * {@link org.springframework.core.SpringProperties SpringProperties}\n\t * mechanism.\n\t * @since 6.1\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "signature": "public String FAIL_ON_ERROR_PROPERTY_NAME",
    "source_code": "\tpublic static final String FAIL_ON_ERROR_PROPERTY_NAME = \"spring.test.aot.processing.failOnError\";",
    "type": "String"
  },
  "org.springframework.test.context.support.<unknown>#customizeContext(context,mergedConfig)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "mergedConfig"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "void",
    "signature": "public void customizeContext(ConfigurableApplicationContext context, MergedContextConfiguration mergedConfig)",
    "source_code": "\tpublic void customizeContext(ConfigurableApplicationContext context, MergedContextConfiguration mergedConfig) {\n\t\tMutablePropertySources sources = context.getEnvironment().getPropertySources();\n\t\tsources.addFirst(new DynamicValuesPropertySource(PROPERTY_SOURCE_NAME, buildDynamicPropertiesMap()));\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof DynamicPropertiesContextCustomizer that &&\n\t\t\t\tthis.methods.equals(that.methods)));\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.methods.hashCode();\n\t}"
  },
  "org.springframework.test.context.support.INLINED_PROPERTIES_PROPERTY_SOURCE_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The name of the {@link MapPropertySource} created from <em>inlined properties</em>.\n\t * @since 4.1.5\n\t * @see #addInlinedPropertiesToEnvironment\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "signature": "public String INLINED_PROPERTIES_PROPERTY_SOURCE_NAME",
    "source_code": "\tpublic static final String INLINED_PROPERTIES_PROPERTY_SOURCE_NAME = \"Inlined Test Properties\";",
    "type": "String"
  },
  "org.springframework.test.context.support.TestPropertySourceUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Utility methods for working with {@link TestPropertySource @TestPropertySource}\n * and adding test {@link PropertySource PropertySources} to the {@code Environment}.\n *\n * <p>Primarily intended for use within the framework.\n *\n * @author Sam Brannen\n * @author Anatoliy Korovin\n * @author Phillip Webb\n * @since 4.1\n * @see TestPropertySource\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "signature": "public class TestPropertySourceUtils",
    "source_code": "public abstract class TestPropertySourceUtils {\n\n\t/**\n\t * The name of the {@link MapPropertySource} created from <em>inlined properties</em>.\n\t * @since 4.1.5\n\t * @see #addInlinedPropertiesToEnvironment\n\t */\n\tpublic static final String INLINED_PROPERTIES_PROPERTY_SOURCE_NAME = \"Inlined Test Properties\";\n\n\tprivate static final PropertySourceFactory defaultPropertySourceFactory = new DefaultPropertySourceFactory();\n\n\tprivate static final Log logger = LogFactory.getLog(TestPropertySourceUtils.class);\n\n\n\tstatic MergedTestPropertySources buildMergedTestPropertySources(Class<?> testClass) {\n\t\tList<TestPropertySourceAttributes> attributesList = new ArrayList<>();\n\n\t\tTestPropertySourceAttributes previousAttributes = null;\n\t\t// Iterate over all aggregate levels, where each level is represented by\n\t\t// a list of merged annotations found at that level (e.g., on a test\n\t\t// class in the class hierarchy).\n\t\tfor (List<MergedAnnotation<TestPropertySource>> aggregatedAnnotations :\n\t\t\t\tfindRepeatableAnnotations(testClass, TestPropertySource.class)) {\n\n\t\t\t// Convert all the merged annotations for the current aggregate\n\t\t\t// level to a list of TestPropertySourceAttributes.\n\t\t\tList<TestPropertySourceAttributes> aggregatedAttributesList =\n\t\t\t\t\taggregatedAnnotations.stream().map(TestPropertySourceAttributes::new).toList();\n\t\t\t// Merge all TestPropertySourceAttributes instances for the current\n\t\t\t// aggregate level into a single TestPropertySourceAttributes instance.\n\t\t\tTestPropertySourceAttributes mergedAttributes = mergeTestPropertySourceAttributes(aggregatedAttributesList);\n\t\t\tif (mergedAttributes != null) {\n\t\t\t\tif (!duplicationDetected(mergedAttributes, previousAttributes)) {\n\t\t\t\t\tattributesList.add(mergedAttributes);\n\t\t\t\t}\n\t\t\t\tpreviousAttributes = mergedAttributes;\n\t\t\t}\n\t\t}\n\n\t\tif (attributesList.isEmpty()) {\n\t\t\treturn MergedTestPropertySources.empty();\n\t\t}\n\t\treturn new MergedTestPropertySources(mergeLocations(attributesList), mergeProperties(attributesList));\n\t}\n\n\t@Nullable\n\tprivate static TestPropertySourceAttributes mergeTestPropertySourceAttributes(\n\t\t\tList<TestPropertySourceAttributes> aggregatedAttributesList) {\n\n\t\tTestPropertySourceAttributes mergedAttributes = null;\n\t\tTestPropertySourceAttributes previousAttributes = null;\n\t\tfor (TestPropertySourceAttributes currentAttributes : aggregatedAttributesList) {\n\t\t\tif (mergedAttributes == null) {\n\t\t\t\tmergedAttributes = currentAttributes;\n\t\t\t}\n\t\t\telse if (!duplicationDetected(currentAttributes, previousAttributes)) {\n\t\t\t\tmergedAttributes.mergeWith(currentAttributes);\n\t\t\t}\n\t\t\tpreviousAttributes = currentAttributes;\n\t\t}\n\n\t\treturn mergedAttributes;\n\t}\n\n\tprivate static boolean duplicationDetected(TestPropertySourceAttributes currentAttributes,\n\t\t\t@Nullable TestPropertySourceAttributes previousAttributes) {\n\n\t\tboolean duplicationDetected =\n\t\t\t\t(currentAttributes.equals(previousAttributes) && !currentAttributes.isEmpty());\n\n\t\tif (duplicationDetected && logger.isTraceEnabled()) {\n\t\t\tlogger.trace(String.format(\"Ignoring duplicate %s declaration on %s since it is also declared on %s\",\n\t\t\t\t\tcurrentAttributes, currentAttributes.getDeclaringClass().getName(),\n\t\t\t\t\tpreviousAttributes.getDeclaringClass().getName()));\n\t\t}\n\n\t\treturn duplicationDetected;\n\t}\n\n\tprivate static List<PropertySourceDescriptor> mergeLocations(List<TestPropertySourceAttributes> attributesList) {\n\t\tList<PropertySourceDescriptor> descriptors = new ArrayList<>();\n\t\tfor (TestPropertySourceAttributes attrs : attributesList) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Processing locations for \" + attrs);\n\t\t\t}\n\t\t\tdescriptors.addAll(0, attrs.getPropertySourceDescriptors());\n\t\t\tif (!attrs.isInheritLocations()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn descriptors;\n\t}\n\n\tprivate static String[] mergeProperties(List<TestPropertySourceAttributes> attributesList) {\n\t\tList<String> properties = new ArrayList<>();\n\t\tfor (TestPropertySourceAttributes attrs : attributesList) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Processing inlined properties for \" + attrs);\n\t\t\t}\n\t\t\tString[] attrProps = attrs.getProperties();\n\t\t\tproperties.addAll(0, Arrays.asList(attrProps));\n\t\t\tif (!attrs.isInheritProperties()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn StringUtils.toStringArray(properties);\n\t}\n\n\t/**\n\t * Add the {@link Properties} files from the given resource {@code locations}\n\t * to the {@link Environment} of the supplied {@code context}.\n\t * <p>This method delegates to\n\t * {@link #addPropertiesFilesToEnvironment(ConfigurableEnvironment, ResourceLoader, String...)}.\n\t * @param context the application context whose environment should be updated;\n\t * never {@code null}\n\t * @param locations the resource locations of {@code Properties} files to add\n\t * to the environment; potentially empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing a properties file\n\t * @since 4.1.5\n\t * @see org.springframework.core.io.support.ResourcePropertySource\n\t * @see TestPropertySource#locations\n\t * @see #addPropertiesFilesToEnvironment(ConfigurableEnvironment, ResourceLoader, String...)\n\t * @see #addPropertySourcesToEnvironment(ConfigurableApplicationContext, List)\n\t */\n\tpublic static void addPropertiesFilesToEnvironment(ConfigurableApplicationContext context, String... locations) {\n\t\tAssert.notNull(context, \"'context' must not be null\");\n\t\tAssert.notNull(locations, \"'locations' must not be null\");\n\t\taddPropertiesFilesToEnvironment(context.getEnvironment(), context, locations);\n\t}\n\n\t/**\n\t * Add the {@link Properties} files from the given resource {@code locations}\n\t * to the supplied {@link ConfigurableEnvironment environment}.\n\t * <p>Property placeholders in resource locations (i.e., <code>${...}</code>)\n\t * will be {@linkplain Environment#resolveRequiredPlaceholders(String) resolved}\n\t * against the {@code Environment}.\n\t * <p>A {@link ResourcePatternResolver} will be used to resolve resource\n\t * location patterns into multiple resource locations.\n\t * <p>Each properties file will be converted to a\n\t * {@link org.springframework.core.io.support.ResourcePropertySource ResourcePropertySource}\n\t * that will be added to the {@link PropertySources} of the environment with\n\t * the highest precedence.\n\t * @param environment the environment to update; never {@code null}\n\t * @param resourceLoader the {@code ResourceLoader} to use to load each resource;\n\t * never {@code null}\n\t * @param locations the resource locations of {@code Properties} files to add\n\t * to the environment; potentially empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing a properties file\n\t * @since 4.3\n\t * @see org.springframework.core.io.support.ResourcePropertySource\n\t * @see TestPropertySource#locations\n\t * @see #addPropertiesFilesToEnvironment(ConfigurableApplicationContext, String...)\n\t * @see #addPropertySourcesToEnvironment(ConfigurableApplicationContext, List)\n\t */\n\tpublic static void addPropertiesFilesToEnvironment(ConfigurableEnvironment environment,\n\t\t\tResourceLoader resourceLoader, String... locations) {\n\n\t\tAssert.notNull(locations, \"'locations' must not be null\");\n\t\taddPropertySourcesToEnvironment(environment, resourceLoader,\n\t\t\t\tList.of(new PropertySourceDescriptor(locations)));\n\t}\n\n\t/**\n\t * Add property sources for the given {@code descriptors} to the\n\t * {@link Environment} of the supplied {@code context}.\n\t * <p>This method delegates to\n\t * {@link #addPropertySourcesToEnvironment(ConfigurableEnvironment, ResourceLoader, List)}.\n\t * @param context the application context whose environment should be updated;\n\t * never {@code null}\n\t * @param descriptors the property source descriptors to process; potentially\n\t * empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing the\n\t * descriptors and registering property sources\n\t * @since 6.1\n\t * @see TestPropertySource#locations\n\t * @see TestPropertySource#encoding\n\t * @see TestPropertySource#factory\n\t * @see PropertySourceFactory\n\t * @see #addPropertySourcesToEnvironment(ConfigurableEnvironment, ResourceLoader, List)\n\t */\n\tpublic static void addPropertySourcesToEnvironment(ConfigurableApplicationContext context,\n\t\t\tList<PropertySourceDescriptor> descriptors) {\n\n\t\tAssert.notNull(context, \"'context' must not be null\");\n\t\tAssert.notNull(descriptors, \"'descriptors' must not be null\");\n\t\taddPropertySourcesToEnvironment(context.getEnvironment(), context, descriptors);\n\t}\n\n\t/**\n\t * Add property sources for the given {@code descriptors} to the supplied\n\t * {@link ConfigurableEnvironment environment}.\n\t * <p>Property placeholders in resource locations (i.e., <code>${...}</code>)\n\t * will be {@linkplain Environment#resolveRequiredPlaceholders(String) resolved}\n\t * against the {@code Environment}.\n\t * <p>A {@link ResourcePatternResolver} will be used to resolve resource\n\t * location patterns into multiple resource locations.\n\t * <p>Each {@link PropertySource} will be created via the configured\n\t * {@link PropertySourceDescriptor#propertySourceFactory() PropertySourceFactory}\n\t * (or the {@link DefaultPropertySourceFactory} if no factory is configured)\n\t * and added to the {@link PropertySources} of the environment with the highest\n\t * precedence.\n\t * @param environment the environment to update; never {@code null}\n\t * @param resourceLoader the {@code ResourceLoader} to use to load resources;\n\t * never {@code null}\n\t * @param descriptors the property source descriptors to process; potentially\n\t * empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing the\n\t * descriptors and registering property sources\n\t * @since 6.1\n\t * @see TestPropertySource#locations\n\t * @see TestPropertySource#encoding\n\t * @see TestPropertySource#factory\n\t * @see PropertySourceFactory\n\t */\n\tpublic static void addPropertySourcesToEnvironment(ConfigurableEnvironment environment,\n\t\t\tResourceLoader resourceLoader, List<PropertySourceDescriptor> descriptors) {\n\n\t\tAssert.notNull(environment, \"'environment' must not be null\");\n\t\tAssert.notNull(resourceLoader, \"'resourceLoader' must not be null\");\n\t\tAssert.notNull(descriptors, \"'descriptors' must not be null\");\n\t\tResourcePatternResolver resourcePatternResolver =\n\t\t\t\tResourcePatternUtils.getResourcePatternResolver(resourceLoader);\n\t\tMutablePropertySources propertySources = environment.getPropertySources();\n\t\ttry {\n\t\t\tfor (PropertySourceDescriptor descriptor : descriptors) {\n\t\t\t\tif (!descriptor.locations().isEmpty()) {\n\t\t\t\t\tClass<? extends PropertySourceFactory> factoryClass = descriptor.propertySourceFactory();\n\t\t\t\t\tPropertySourceFactory factory = (factoryClass != null ?\n\t\t\t\t\t\t\tBeanUtils.instantiateClass(factoryClass) : defaultPropertySourceFactory);\n\n\t\t\t\t\tfor (String location : descriptor.locations()) {\n\t\t\t\t\t\tString resolvedLocation = environment.resolveRequiredPlaceholders(location);\n\t\t\t\t\t\tfor (Resource resource : resourcePatternResolver.getResources(resolvedLocation)) {\n\t\t\t\t\t\t\tPropertySource<?> propertySource = factory.createPropertySource(descriptor.name(),\n\t\t\t\t\t\t\t\t\tnew EncodedResource(resource, descriptor.encoding()));\n\t\t\t\t\t\t\tpropertySources.addFirst(propertySource);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new IllegalStateException(\"Failed to add PropertySource to Environment\", ex);\n\t\t}\n\t}\n\n\t/**\n\t * Add the given <em>inlined properties</em> to the {@link Environment} of the\n\t * supplied {@code context}.\n\t * <p>This method simply delegates to\n\t * {@link #addInlinedPropertiesToEnvironment(ConfigurableEnvironment, String[])}.\n\t * @param context the application context whose environment should be updated;\n\t * never {@code null}\n\t * @param inlinedProperties the inlined properties to add to the environment;\n\t * potentially empty but never {@code null}\n\t * @since 4.1.5\n\t * @see TestPropertySource#properties\n\t * @see #addInlinedPropertiesToEnvironment(ConfigurableEnvironment, String[])\n\t */\n\tpublic static void addInlinedPropertiesToEnvironment(ConfigurableApplicationContext context, String... inlinedProperties) {\n\t\tAssert.notNull(context, \"'context' must not be null\");\n\t\tAssert.notNull(inlinedProperties, \"'inlinedProperties' must not be null\");\n\t\taddInlinedPropertiesToEnvironment(context.getEnvironment(), inlinedProperties);\n\t}\n\n\t/**\n\t * Add the given <em>inlined properties</em> (in the form of <em>key-value</em>\n\t * pairs) to the supplied {@link ConfigurableEnvironment environment}.\n\t * <p>All key-value pairs will be added to the {@code Environment} as a\n\t * single {@link MapPropertySource} with the highest precedence.\n\t * <p>For details on the parsing of <em>inlined properties</em>, consult the\n\t * Javadoc for {@link #convertInlinedPropertiesToMap}.\n\t * @param environment the environment to update; never {@code null}\n\t * @param inlinedProperties the inlined properties to add to the environment;\n\t * potentially empty but never {@code null}\n\t * @since 4.1.5\n\t * @see MapPropertySource\n\t * @see #INLINED_PROPERTIES_PROPERTY_SOURCE_NAME\n\t * @see TestPropertySource#properties\n\t * @see #convertInlinedPropertiesToMap\n\t */\n\tpublic static void addInlinedPropertiesToEnvironment(ConfigurableEnvironment environment, String... inlinedProperties) {\n\t\tAssert.notNull(environment, \"'environment' must not be null\");\n\t\tAssert.notNull(inlinedProperties, \"'inlinedProperties' must not be null\");\n\t\tif (!ObjectUtils.isEmpty(inlinedProperties)) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Adding inlined properties to environment: \" +\n\t\t\t\t\t\tObjectUtils.nullSafeToString(inlinedProperties));\n\t\t\t}\n\t\t\tMapPropertySource ps = (MapPropertySource)\n\t\t\t\t\tenvironment.getPropertySources().get(INLINED_PROPERTIES_PROPERTY_SOURCE_NAME);\n\t\t\tif (ps == null) {\n\t\t\t\tps = new MapPropertySource(INLINED_PROPERTIES_PROPERTY_SOURCE_NAME, new LinkedHashMap<>());\n\t\t\t\tenvironment.getPropertySources().addFirst(ps);\n\t\t\t}\n\t\t\tps.getSource().putAll(convertInlinedPropertiesToMap(inlinedProperties));\n\t\t}\n\t}\n\n\t/**\n\t * Convert the supplied <em>inlined properties</em> (in the form of <em>key-value</em>\n\t * pairs) into a map keyed by property name.\n\t * <p>Parsing of the key-value pairs is achieved by converting all supplied\n\t * strings into <em>virtual</em> properties files in memory and delegating to\n\t * {@link Properties#load(java.io.Reader)} to parse each virtual file.\n\t * <p>The ordering of property names will be preserved in the returned map,\n\t * analogous to the order in which the key-value pairs are supplied to this\n\t * method. This also applies if a single string contains multiple key-value\n\t * pairs separated by newlines &mdash; for example, when supplied by a user\n\t * via a <em>text block</em>.\n\t * <p>For a full discussion of <em>inlined properties</em>, consult the Javadoc\n\t * for {@link TestPropertySource#properties}.\n\t * @param inlinedProperties the inlined properties to convert; potentially empty\n\t * but never {@code null}\n\t * @return a new, ordered map containing the converted properties\n\t * @throws IllegalStateException if a given key-value pair cannot be parsed\n\t * @since 4.1.5\n\t * @see #addInlinedPropertiesToEnvironment(ConfigurableEnvironment, String[])\n\t */\n\tpublic static Map<String, Object> convertInlinedPropertiesToMap(String... inlinedProperties) {\n\t\tAssert.notNull(inlinedProperties, \"'inlinedProperties' must not be null\");\n\n\t\tLinkedHashMap<String, Object> map = new LinkedHashMap<>();\n\t\tSequencedProperties sequencedProperties = new SequencedProperties(map);\n\n\t\tfor (String input : inlinedProperties) {\n\t\t\tif (!StringUtils.hasText(input)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tsequencedProperties.load(new StringReader(input));\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new IllegalStateException(\"Failed to load test environment properties from [\" + input + \"]\", ex);\n\t\t\t}\n\t\t}\n\n\t\treturn map;\n\t}\n\n\tprivate static <T extends Annotation> List<List<MergedAnnotation<T>>> findRepeatableAnnotations(\n\t\t\tClass<?> clazz, Class<T> annotationType) {\n\n\t\tList<List<MergedAnnotation<T>>> listOfLists = new ArrayList<>();\n\t\tfindRepeatableAnnotations(clazz, annotationType, listOfLists, new int[] {0});\n\t\treturn listOfLists;\n\t}\n\n\tprivate static <T extends Annotation> void findRepeatableAnnotations(\n\t\t\tClass<?> clazz, Class<T> annotationType, List<List<MergedAnnotation<T>>> listOfLists, int[] aggregateIndex) {\n\n\t\t// Ensure we have a list for the current aggregate index.\n\t\tif (listOfLists.size() < aggregateIndex[0] + 1) {\n\t\t\tlistOfLists.add(new ArrayList<>());\n\t\t}\n\n\t\tMergedAnnotations.from(clazz, SearchStrategy.DIRECT)\n\t\t\t.stream(annotationType)\n\t\t\t.sorted(highMetaDistancesFirst())\n\t\t\t.forEach(annotation -> listOfLists.get(aggregateIndex[0]).add(0, annotation));\n\n\t\taggregateIndex[0]++;\n\n\t\t// Declared on an interface?\n\t\tfor (Class<?> ifc : clazz.getInterfaces()) {\n\t\t\tfindRepeatableAnnotations(ifc, annotationType, listOfLists, aggregateIndex);\n\t\t}\n\n\t\t// Declared on a superclass?\n\t\tClass<?> superclass = clazz.getSuperclass();\n\t\tif (superclass != null & superclass != Object.class) {\n\t\t\tfindRepeatableAnnotations(superclass, annotationType, listOfLists, aggregateIndex);\n\t\t}\n\n\t\t// Declared on an enclosing class of an inner class?\n\t\tif (TestContextAnnotationUtils.searchEnclosingClass(clazz)) {\n\t\t\tfindRepeatableAnnotations(clazz.getEnclosingClass(), annotationType, listOfLists, aggregateIndex);\n\t\t}\n\t}\n\n\tprivate static <A extends Annotation> Comparator<MergedAnnotation<A>> highMetaDistancesFirst() {\n\t\treturn Comparator.<MergedAnnotation<A>> comparingInt(MergedAnnotation::getDistance).reversed();\n\t}\n\n\t/**\n\t * Extension of {@link Properties} that mimics a {@code SequencedMap} by\n\t * tracking all added properties in the supplied {@link LinkedHashMap}.\n\t * @since 6.1\n\t */\n\t@SuppressWarnings(\"serial\")\n\tprivate static class SequencedProperties extends Properties {\n\n\t\tprivate final LinkedHashMap<String, Object> map;\n\n\t\tSequencedProperties(LinkedHashMap<String, Object> map) {\n\t\t\tthis.map = map;\n\t\t}\n\n\t\t@Override\n\t\tpublic synchronized Object put(Object key, Object value) {\n\t\t\tif (key instanceof String str) {\n\t\t\t\tthis.map.put(str, value);\n\t\t\t}\n\t\t\treturn super.put(key, value);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.test.context.support.TestPropertySourceUtils#addInlinedPropertiesToEnvironment(context,inlinedProperties)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given <em>inlined properties</em> to the {@link Environment} of the\n\t * supplied {@code context}.\n\t * <p>This method simply delegates to\n\t * {@link #addInlinedPropertiesToEnvironment(ConfigurableEnvironment, String[])}.\n\t * @param context the application context whose environment should be updated;\n\t * never {@code null}\n\t * @param inlinedProperties the inlined properties to add to the environment;\n\t * potentially empty but never {@code null}\n\t * @since 4.1.5\n\t * @see TestPropertySource#properties\n\t * @see #addInlinedPropertiesToEnvironment(ConfigurableEnvironment, String[])\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "inlinedProperties"
    ],
    "position": {
      "column": 1,
      "line": 330
    },
    "return": "void",
    "signature": "public void addInlinedPropertiesToEnvironment(ConfigurableApplicationContext context, String... inlinedProperties)",
    "source_code": "\tpublic static void addInlinedPropertiesToEnvironment(ConfigurableApplicationContext context, String... inlinedProperties) {\n\t\tAssert.notNull(context, \"'context' must not be null\");\n\t\tAssert.notNull(inlinedProperties, \"'inlinedProperties' must not be null\");\n\t\taddInlinedPropertiesToEnvironment(context.getEnvironment(), inlinedProperties);\n\t}"
  },
  "org.springframework.test.context.support.TestPropertySourceUtils#addInlinedPropertiesToEnvironment(environment,inlinedProperties)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given <em>inlined properties</em> (in the form of <em>key-value</em>\n\t * pairs) to the supplied {@link ConfigurableEnvironment environment}.\n\t * <p>All key-value pairs will be added to the {@code Environment} as a\n\t * single {@link MapPropertySource} with the highest precedence.\n\t * <p>For details on the parsing of <em>inlined properties</em>, consult the\n\t * Javadoc for {@link #convertInlinedPropertiesToMap}.\n\t * @param environment the environment to update; never {@code null}\n\t * @param inlinedProperties the inlined properties to add to the environment;\n\t * potentially empty but never {@code null}\n\t * @since 4.1.5\n\t * @see MapPropertySource\n\t * @see #INLINED_PROPERTIES_PROPERTY_SOURCE_NAME\n\t * @see TestPropertySource#properties\n\t * @see #convertInlinedPropertiesToMap\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "environment",
      "inlinedProperties"
    ],
    "position": {
      "column": 1,
      "line": 352
    },
    "return": "void",
    "signature": "public void addInlinedPropertiesToEnvironment(ConfigurableEnvironment environment, String... inlinedProperties)",
    "source_code": "\tpublic static void addInlinedPropertiesToEnvironment(ConfigurableEnvironment environment, String... inlinedProperties) {\n\t\tAssert.notNull(environment, \"'environment' must not be null\");\n\t\tAssert.notNull(inlinedProperties, \"'inlinedProperties' must not be null\");\n\t\tif (!ObjectUtils.isEmpty(inlinedProperties)) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Adding inlined properties to environment: \" +\n\t\t\t\t\t\tObjectUtils.nullSafeToString(inlinedProperties));\n\t\t\t}\n\t\t\tMapPropertySource ps = (MapPropertySource)\n\t\t\t\t\tenvironment.getPropertySources().get(INLINED_PROPERTIES_PROPERTY_SOURCE_NAME);\n\t\t\tif (ps == null) {\n\t\t\t\tps = new MapPropertySource(INLINED_PROPERTIES_PROPERTY_SOURCE_NAME, new LinkedHashMap<>());\n\t\t\t\tenvironment.getPropertySources().addFirst(ps);\n\t\t\t}\n\t\t\tps.getSource().putAll(convertInlinedPropertiesToMap(inlinedProperties));\n\t\t}\n\t}"
  },
  "org.springframework.test.context.support.TestPropertySourceUtils#addPropertiesFilesToEnvironment(context,locations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the {@link Properties} files from the given resource {@code locations}\n\t * to the {@link Environment} of the supplied {@code context}.\n\t * <p>This method delegates to\n\t * {@link #addPropertiesFilesToEnvironment(ConfigurableEnvironment, ResourceLoader, String...)}.\n\t * @param context the application context whose environment should be updated;\n\t * never {@code null}\n\t * @param locations the resource locations of {@code Properties} files to add\n\t * to the environment; potentially empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing a properties file\n\t * @since 4.1.5\n\t * @see org.springframework.core.io.support.ResourcePropertySource\n\t * @see TestPropertySource#locations\n\t * @see #addPropertiesFilesToEnvironment(ConfigurableEnvironment, ResourceLoader, String...)\n\t * @see #addPropertySourcesToEnvironment(ConfigurableApplicationContext, List)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "locations"
    ],
    "position": {
      "column": 1,
      "line": 195
    },
    "return": "void",
    "signature": "public void addPropertiesFilesToEnvironment(ConfigurableApplicationContext context, String... locations)",
    "source_code": "\tpublic static void addPropertiesFilesToEnvironment(ConfigurableApplicationContext context, String... locations) {\n\t\tAssert.notNull(context, \"'context' must not be null\");\n\t\tAssert.notNull(locations, \"'locations' must not be null\");\n\t\taddPropertiesFilesToEnvironment(context.getEnvironment(), context, locations);\n\t}"
  },
  "org.springframework.test.context.support.TestPropertySourceUtils#addPropertiesFilesToEnvironment(environment,resourceLoader,locations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the {@link Properties} files from the given resource {@code locations}\n\t * to the supplied {@link ConfigurableEnvironment environment}.\n\t * <p>Property placeholders in resource locations (i.e., <code>${...}</code>)\n\t * will be {@linkplain Environment#resolveRequiredPlaceholders(String) resolved}\n\t * against the {@code Environment}.\n\t * <p>A {@link ResourcePatternResolver} will be used to resolve resource\n\t * location patterns into multiple resource locations.\n\t * <p>Each properties file will be converted to a\n\t * {@link org.springframework.core.io.support.ResourcePropertySource ResourcePropertySource}\n\t * that will be added to the {@link PropertySources} of the environment with\n\t * the highest precedence.\n\t * @param environment the environment to update; never {@code null}\n\t * @param resourceLoader the {@code ResourceLoader} to use to load each resource;\n\t * never {@code null}\n\t * @param locations the resource locations of {@code Properties} files to add\n\t * to the environment; potentially empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing a properties file\n\t * @since 4.3\n\t * @see org.springframework.core.io.support.ResourcePropertySource\n\t * @see TestPropertySource#locations\n\t * @see #addPropertiesFilesToEnvironment(ConfigurableApplicationContext, String...)\n\t * @see #addPropertySourcesToEnvironment(ConfigurableApplicationContext, List)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "environment",
      "resourceLoader",
      "locations"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "void",
    "signature": "public void addPropertiesFilesToEnvironment(ConfigurableEnvironment environment,\n\t\t\tResourceLoader resourceLoader, String... locations)",
    "source_code": "\tpublic static void addPropertiesFilesToEnvironment(ConfigurableEnvironment environment,"
  },
  "org.springframework.test.context.support.TestPropertySourceUtils#addPropertySourcesToEnvironment(context,descriptors)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add property sources for the given {@code descriptors} to the\n\t * {@link Environment} of the supplied {@code context}.\n\t * <p>This method delegates to\n\t * {@link #addPropertySourcesToEnvironment(ConfigurableEnvironment, ResourceLoader, List)}.\n\t * @param context the application context whose environment should be updated;\n\t * never {@code null}\n\t * @param descriptors the property source descriptors to process; potentially\n\t * empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing the\n\t * descriptors and registering property sources\n\t * @since 6.1\n\t * @see TestPropertySource#locations\n\t * @see TestPropertySource#encoding\n\t * @see TestPropertySource#factory\n\t * @see PropertySourceFactory\n\t * @see #addPropertySourcesToEnvironment(ConfigurableEnvironment, ResourceLoader, List)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "descriptors"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "void",
    "signature": "public void addPropertySourcesToEnvironment(ConfigurableApplicationContext context,\n\t\t\tList<PropertySourceDescriptor> descriptors)",
    "source_code": "\tpublic static void addPropertySourcesToEnvironment(ConfigurableApplicationContext context,"
  },
  "org.springframework.test.context.support.TestPropertySourceUtils#addPropertySourcesToEnvironment(environment,resourceLoader,descriptors)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add property sources for the given {@code descriptors} to the supplied\n\t * {@link ConfigurableEnvironment environment}.\n\t * <p>Property placeholders in resource locations (i.e., <code>${...}</code>)\n\t * will be {@linkplain Environment#resolveRequiredPlaceholders(String) resolved}\n\t * against the {@code Environment}.\n\t * <p>A {@link ResourcePatternResolver} will be used to resolve resource\n\t * location patterns into multiple resource locations.\n\t * <p>Each {@link PropertySource} will be created via the configured\n\t * {@link PropertySourceDescriptor#propertySourceFactory() PropertySourceFactory}\n\t * (or the {@link DefaultPropertySourceFactory} if no factory is configured)\n\t * and added to the {@link PropertySources} of the environment with the highest\n\t * precedence.\n\t * @param environment the environment to update; never {@code null}\n\t * @param resourceLoader the {@code ResourceLoader} to use to load resources;\n\t * never {@code null}\n\t * @param descriptors the property source descriptors to process; potentially\n\t * empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing the\n\t * descriptors and registering property sources\n\t * @since 6.1\n\t * @see TestPropertySource#locations\n\t * @see TestPropertySource#encoding\n\t * @see TestPropertySource#factory\n\t * @see PropertySourceFactory\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "environment",
      "resourceLoader",
      "descriptors"
    ],
    "position": {
      "column": 1,
      "line": 285
    },
    "return": "void",
    "signature": "public void addPropertySourcesToEnvironment(ConfigurableEnvironment environment,\n\t\t\tResourceLoader resourceLoader, List<PropertySourceDescriptor> descriptors)",
    "source_code": "\tpublic static void addPropertySourcesToEnvironment(ConfigurableEnvironment environment,"
  },
  "org.springframework.test.context.support.TestPropertySourceUtils#convertInlinedPropertiesToMap(inlinedProperties)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the supplied <em>inlined properties</em> (in the form of <em>key-value</em>\n\t * pairs) into a map keyed by property name.\n\t * <p>Parsing of the key-value pairs is achieved by converting all supplied\n\t * strings into <em>virtual</em> properties files in memory and delegating to\n\t * {@link Properties#load(java.io.Reader)} to parse each virtual file.\n\t * <p>The ordering of property names will be preserved in the returned map,\n\t * analogous to the order in which the key-value pairs are supplied to this\n\t * method. This also applies if a single string contains multiple key-value\n\t * pairs separated by newlines &mdash; for example, when supplied by a user\n\t * via a <em>text block</em>.\n\t * <p>For a full discussion of <em>inlined properties</em>, consult the Javadoc\n\t * for {@link TestPropertySource#properties}.\n\t * @param inlinedProperties the inlined properties to convert; potentially empty\n\t * but never {@code null}\n\t * @return a new, ordered map containing the converted properties\n\t * @throws IllegalStateException if a given key-value pair cannot be parsed\n\t * @since 4.1.5\n\t * @see #addInlinedPropertiesToEnvironment(ConfigurableEnvironment, String[])\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inlinedProperties"
    ],
    "position": {
      "column": 1,
      "line": 390
    },
    "return": "Object>",
    "signature": "public Object> convertInlinedPropertiesToMap(String... inlinedProperties)",
    "source_code": "\tpublic static Map<String, Object> convertInlinedPropertiesToMap(String... inlinedProperties) {\n\t\tAssert.notNull(inlinedProperties, \"'inlinedProperties' must not be null\");\n\n\t\tLinkedHashMap<String, Object> map = new LinkedHashMap<>();\n\t\tSequencedProperties sequencedProperties = new SequencedProperties(map);\n\n\t\tfor (String input : inlinedProperties) {\n\t\t\tif (!StringUtils.hasText(input)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tsequencedProperties.load(new StringReader(input));\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new IllegalStateException(\"Failed to load test environment properties from [\" + input + \"]\", ex);\n\t\t\t}\n\t\t}\n\n\t\treturn map;\n\t}"
  },
  "org.springframework.test.context.support.TestPropertySourceUtils#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 470
    },
    "return": "Object",
    "signature": "public Object put(Object key, Object value)",
    "source_code": "\t\tpublic synchronized Object put(Object key, Object value) {\n\t\t\tif (key instanceof String str) {\n\t\t\t\tthis.map.put(str, value);\n\t\t\t}\n\t\t\treturn super.put(key, value);\n\t\t}"
  },
  "org.springframework.transaction.event.<unknown>#afterCompletion(status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> afterCompletion(int status)",
    "source_code": "\t\tpublic Mono<Void> afterCompletion(int status) {\n\t\t\tTransactionPhase phase = getTransactionPhase();\n\t\t\tif (phase == TransactionPhase.AFTER_COMMIT && status == STATUS_COMMITTED) {\n\t\t\t\treturn Mono.fromRunnable(this::processEventWithCallbacks);\n\t\t\t}\n\t\t\telse if (phase == TransactionPhase.AFTER_ROLLBACK && status == STATUS_ROLLED_BACK) {\n\t\t\t\treturn Mono.fromRunnable(this::processEventWithCallbacks);\n\t\t\t}\n\t\t\telse if (phase == TransactionPhase.AFTER_COMPLETION) {\n\t\t\t\treturn Mono.fromRunnable(this::processEventWithCallbacks);\n\t\t\t}\n\t\t\treturn Mono.empty();\n\t\t}"
  },
  "org.springframework.transaction.event.<unknown>#beforeCommit(readOnly)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "readOnly"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> beforeCommit(boolean readOnly)",
    "source_code": "\t\tpublic Mono<Void> beforeCommit(boolean readOnly) {\n\t\t\tif (getTransactionPhase() == TransactionPhase.BEFORE_COMMIT) {\n\t\t\t\treturn Mono.fromRunnable(this::processEventWithCallbacks);\n\t\t\t}\n\t\t\treturn Mono.empty();\n\t\t}"
  },
  "org.springframework.transaction.event.<unknown>#getOrder()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 54
    },
    "return": "int",
    "signature": "public int getOrder()",
    "source_code": "\tpublic int getOrder() {\n\t\treturn this.listener.getOrder();\n\t}"
  },
  "org.springframework.transaction.event.<unknown>#getTransactionPhase()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "TransactionPhase",
    "signature": "public TransactionPhase getTransactionPhase()",
    "source_code": "\tpublic TransactionPhase getTransactionPhase() {\n\t\treturn this.listener.getTransactionPhase();\n\t}"
  },
  "org.springframework.transaction.event.<unknown>#processEventWithCallbacks()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "void",
    "signature": "public void processEventWithCallbacks()",
    "source_code": "\tpublic void processEventWithCallbacks() {\n\t\tthis.callbacks.forEach(callback -> callback.preProcessEvent(this.event));\n\t\ttry {\n\t\t\tthis.listener.processEvent(this.event);\n\t\t}\n\t\tcatch (RuntimeException | Error ex) {\n\t\t\tthis.callbacks.forEach(callback -> callback.postProcessEvent(this.event, ex));\n\t\t\tthrow ex;\n\t\t}\n\t\tthis.callbacks.forEach(callback -> callback.postProcessEvent(this.event, null));\n\t}"
  },
  "org.springframework.transaction.event.<unknown>#register(event,listener,callbacks)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "event",
      "listener",
      "callbacks"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "boolean",
    "signature": "public boolean register(E event, TransactionalApplicationListener<E> listener,\n\t\t\tList<TransactionalApplicationListener.SynchronizationCallback> callbacks)",
    "source_code": "\tpublic static <E extends ApplicationEvent> boolean register("
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Default implementation of the {@link TransactionDefinition} interface,\n * offering bean-style configuration and sensible default values\n * (PROPAGATION_REQUIRED, ISOLATION_DEFAULT, TIMEOUT_DEFAULT, readOnly=false).\n *\n * <p>Base class for both {@link TransactionTemplate} and\n * {@link org.springframework.transaction.interceptor.DefaultTransactionAttribute}.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 08.05.2003\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class DefaultTransactionDefinition",
    "source_code": "public class DefaultTransactionDefinition implements TransactionDefinition, Serializable {\n\n\t/** Prefix for the propagation constants defined in TransactionDefinition. */\n\tpublic static final String PREFIX_PROPAGATION = \"PROPAGATION_\";\n\n\t/** Prefix for the isolation constants defined in TransactionDefinition. */\n\tpublic static final String PREFIX_ISOLATION = \"ISOLATION_\";\n\n\t/** Prefix for transaction timeout values in description strings. */\n\tpublic static final String PREFIX_TIMEOUT = \"timeout_\";\n\n\t/** Marker for read-only transactions in description strings. */\n\tpublic static final String READ_ONLY_MARKER = \"readOnly\";\n\n\n\t/**\n\t * Map of constant names to constant values for the propagation constants\n\t * defined in {@link TransactionDefinition}.\n\t */\n\tstatic final Map<String, Integer> propagationConstants = Map.of(\n\t\t\t\"PROPAGATION_REQUIRED\", TransactionDefinition.PROPAGATION_REQUIRED,\n\t\t\t\"PROPAGATION_SUPPORTS\", TransactionDefinition.PROPAGATION_SUPPORTS,\n\t\t\t\"PROPAGATION_MANDATORY\", TransactionDefinition.PROPAGATION_MANDATORY,\n\t\t\t\"PROPAGATION_REQUIRES_NEW\", TransactionDefinition.PROPAGATION_REQUIRES_NEW,\n\t\t\t\"PROPAGATION_NOT_SUPPORTED\", TransactionDefinition.PROPAGATION_NOT_SUPPORTED,\n\t\t\t\"PROPAGATION_NEVER\", TransactionDefinition.PROPAGATION_NEVER,\n\t\t\t\"PROPAGATION_NESTED\", TransactionDefinition.PROPAGATION_NESTED\n\t\t);\n\n\t/**\n\t * Map of constant names to constant values for the isolation constants\n\t * defined in {@link TransactionDefinition}.\n\t */\n\tstatic final Map<String, Integer> isolationConstants = Map.of(\n\t\t\t\"ISOLATION_DEFAULT\", TransactionDefinition.ISOLATION_DEFAULT,\n\t\t\t\"ISOLATION_READ_UNCOMMITTED\", TransactionDefinition.ISOLATION_READ_UNCOMMITTED,\n\t\t\t\"ISOLATION_READ_COMMITTED\", TransactionDefinition.ISOLATION_READ_COMMITTED,\n\t\t\t\"ISOLATION_REPEATABLE_READ\", TransactionDefinition.ISOLATION_REPEATABLE_READ,\n\t\t\t\"ISOLATION_SERIALIZABLE\", TransactionDefinition.ISOLATION_SERIALIZABLE\n\t\t);\n\n\tprivate int propagationBehavior = PROPAGATION_REQUIRED;\n\n\tprivate int isolationLevel = ISOLATION_DEFAULT;\n\n\tprivate int timeout = TIMEOUT_DEFAULT;\n\n\tprivate boolean readOnly = false;\n\n\t@Nullable\n\tprivate String name;\n\n\n\t/**\n\t * Create a new DefaultTransactionDefinition, with default settings.\n\t * Can be modified through bean property setters.\n\t * @see #setPropagationBehavior\n\t * @see #setIsolationLevel\n\t * @see #setTimeout\n\t * @see #setReadOnly\n\t * @see #setName\n\t */\n\tpublic DefaultTransactionDefinition() {\n\t}\n\n\t/**\n\t * Copy constructor. Definition can be modified through bean property setters.\n\t * @see #setPropagationBehavior\n\t * @see #setIsolationLevel\n\t * @see #setTimeout\n\t * @see #setReadOnly\n\t * @see #setName\n\t */\n\tpublic DefaultTransactionDefinition(TransactionDefinition other) {\n\t\tthis.propagationBehavior = other.getPropagationBehavior();\n\t\tthis.isolationLevel = other.getIsolationLevel();\n\t\tthis.timeout = other.getTimeout();\n\t\tthis.readOnly = other.isReadOnly();\n\t\tthis.name = other.getName();\n\t}\n\n\t/**\n\t * Create a new DefaultTransactionDefinition with the given\n\t * propagation behavior. Can be modified through bean property setters.\n\t * @param propagationBehavior one of the propagation constants in the\n\t * TransactionDefinition interface\n\t * @see #setIsolationLevel\n\t * @see #setTimeout\n\t * @see #setReadOnly\n\t */\n\tpublic DefaultTransactionDefinition(int propagationBehavior) {\n\t\tthis.propagationBehavior = propagationBehavior;\n\t}\n\n\n\t/**\n\t * Set the propagation behavior by the name of the corresponding constant in\n\t * {@link TransactionDefinition} &mdash; for example, {@code \"PROPAGATION_REQUIRED\"}.\n\t * @param constantName name of the constant\n\t * @throws IllegalArgumentException if the supplied value is not resolvable\n\t * to one of the {@code PROPAGATION_} constants or is {@code null}\n\t * @see #setPropagationBehavior\n\t * @see #PROPAGATION_REQUIRED\n\t */\n\tpublic final void setPropagationBehaviorName(String constantName) throws IllegalArgumentException {\n\t\tAssert.hasText(constantName, \"'constantName' must not be null or blank\");\n\t\tInteger propagationBehavior = propagationConstants.get(constantName);\n\t\tAssert.notNull(propagationBehavior, \"Only propagation behavior constants allowed\");\n\t\tthis.propagationBehavior = propagationBehavior;\n\t}\n\n\t/**\n\t * Set the propagation behavior. Must be one of the propagation constants\n\t * in the TransactionDefinition interface. Default is PROPAGATION_REQUIRED.\n\t * <p>Exclusively designed for use with {@link #PROPAGATION_REQUIRED} or\n\t * {@link #PROPAGATION_REQUIRES_NEW} since it only applies to newly started\n\t * transactions. Consider switching the \"validateExistingTransactions\" flag to\n\t * \"true\" on your transaction manager if you'd like isolation level declarations\n\t * to get rejected when participating in an existing transaction with a different\n\t * isolation level.\n\t * <p>Note that a transaction manager that does not support custom isolation levels\n\t * will throw an exception when given any other level than {@link #ISOLATION_DEFAULT}.\n\t * @throws IllegalArgumentException if the supplied value is not one of the\n\t * {@code PROPAGATION_} constants\n\t * @see #PROPAGATION_REQUIRED\n\t */\n\tpublic final void setPropagationBehavior(int propagationBehavior) {\n\t\tAssert.isTrue(propagationConstants.containsValue(propagationBehavior),\n\t\t\t\t\"Only values of propagation constants allowed\");\n\t\tthis.propagationBehavior = propagationBehavior;\n\t}\n\n\t@Override\n\tpublic final int getPropagationBehavior() {\n\t\treturn this.propagationBehavior;\n\t}\n\n\t/**\n\t * Set the isolation level by the name of the corresponding constant in\n\t * {@link TransactionDefinition} &mdash; for example, {@code \"ISOLATION_DEFAULT\"}.\n\t * @param constantName name of the constant\n\t * @throws IllegalArgumentException if the supplied value is not resolvable\n\t * to one of the {@code ISOLATION_} constants or is {@code null}\n\t * @see #setIsolationLevel\n\t * @see #ISOLATION_DEFAULT\n\t */\n\tpublic final void setIsolationLevelName(String constantName) throws IllegalArgumentException {\n\t\tAssert.hasText(constantName, \"'constantName' must not be null or blank\");\n\t\tInteger isolationLevel = isolationConstants.get(constantName);\n\t\tAssert.notNull(isolationLevel, \"Only isolation constants allowed\");\n\t\tthis.isolationLevel = isolationLevel;\n\t}\n\n\t/**\n\t * Set the isolation level. Must be one of the isolation constants\n\t * in the TransactionDefinition interface. Default is ISOLATION_DEFAULT.\n\t * <p>Exclusively designed for use with {@link #PROPAGATION_REQUIRED} or\n\t * {@link #PROPAGATION_REQUIRES_NEW} since it only applies to newly started\n\t * transactions. Consider switching the \"validateExistingTransactions\" flag to\n\t * \"true\" on your transaction manager if you'd like isolation level declarations\n\t * to get rejected when participating in an existing transaction with a different\n\t * isolation level.\n\t * <p>Note that a transaction manager that does not support custom isolation levels\n\t * will throw an exception when given any other level than {@link #ISOLATION_DEFAULT}.\n\t * @throws IllegalArgumentException if the supplied value is not one of the\n\t * {@code ISOLATION_} constants\n\t * @see #ISOLATION_DEFAULT\n\t */\n\tpublic final void setIsolationLevel(int isolationLevel) {\n\t\tAssert.isTrue(isolationConstants.containsValue(isolationLevel),\n\t\t\t\t\"Only values of isolation constants allowed\");\n\t\tthis.isolationLevel = isolationLevel;\n\t}\n\n\t@Override\n\tpublic final int getIsolationLevel() {\n\t\treturn this.isolationLevel;\n\t}\n\n\t/**\n\t * Set the timeout to apply, as number of seconds.\n\t * Default is TIMEOUT_DEFAULT (-1).\n\t * <p>Exclusively designed for use with {@link #PROPAGATION_REQUIRED} or\n\t * {@link #PROPAGATION_REQUIRES_NEW} since it only applies to newly started\n\t * transactions.\n\t * <p>Note that a transaction manager that does not support timeouts will throw\n\t * an exception when given any other timeout than {@link #TIMEOUT_DEFAULT}.\n\t * @see #TIMEOUT_DEFAULT\n\t */\n\tpublic final void setTimeout(int timeout) {\n\t\tif (timeout < TIMEOUT_DEFAULT) {\n\t\t\tthrow new IllegalArgumentException(\"Timeout must be a positive integer or TIMEOUT_DEFAULT\");\n\t\t}\n\t\tthis.timeout = timeout;\n\t}\n\n\t@Override\n\tpublic final int getTimeout() {\n\t\treturn this.timeout;\n\t}\n\n\t/**\n\t * Set whether to optimize as read-only transaction.\n\t * Default is \"false\".\n\t * <p>The read-only flag applies to any transaction context, whether backed\n\t * by an actual resource transaction ({@link #PROPAGATION_REQUIRED}/\n\t * {@link #PROPAGATION_REQUIRES_NEW}) or operating non-transactionally at\n\t * the resource level ({@link #PROPAGATION_SUPPORTS}). In the latter case,\n\t * the flag will only apply to managed resources within the application,\n\t * such as a Hibernate {@code Session}.\n\t * <p>This just serves as a hint for the actual transaction subsystem;\n\t * it will <i>not necessarily</i> cause failure of write access attempts.\n\t * A transaction manager which cannot interpret the read-only hint will\n\t * <i>not</i> throw an exception when asked for a read-only transaction.\n\t */\n\tpublic final void setReadOnly(boolean readOnly) {\n\t\tthis.readOnly = readOnly;\n\t}\n\n\t@Override\n\tpublic final boolean isReadOnly() {\n\t\treturn this.readOnly;\n\t}\n\n\t/**\n\t * Set the name of this transaction. Default is none.\n\t * <p>This will be used as transaction name to be shown in a\n\t * transaction monitor, if applicable (for example, WebLogic's).\n\t */\n\tpublic final void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic final String getName() {\n\t\treturn this.name;\n\t}\n\n\n\t/**\n\t * This implementation compares the {@code toString()} results.\n\t * @see #toString()\n\t */\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof TransactionDefinition && toString().equals(other.toString())));\n\t}\n\n\t/**\n\t * This implementation returns {@code toString()}'s hash code.\n\t * @see #toString()\n\t */\n\t@Override\n\tpublic int hashCode() {\n\t\treturn toString().hashCode();\n\t}\n\n\t/**\n\t * Return an identifying description for this transaction definition.\n\t * <p>The format matches the one used by\n\t * {@link org.springframework.transaction.interceptor.TransactionAttributeEditor},\n\t * to be able to feed {@code toString} results into bean properties of type\n\t * {@link org.springframework.transaction.interceptor.TransactionAttribute}.\n\t * <p>Has to be overridden in subclasses for correct {@code equals}\n\t * and {@code hashCode} behavior. Alternatively, {@link #equals}\n\t * and {@link #hashCode} can be overridden themselves.\n\t * @see #getDefinitionDescription()\n\t * @see org.springframework.transaction.interceptor.TransactionAttributeEditor\n\t */\n\t@Override\n\tpublic String toString() {\n\t\treturn getDefinitionDescription().toString();\n\t}\n\n\t/**\n\t * Return an identifying description for this transaction definition.\n\t * <p>Available to subclasses, for inclusion in their {@code toString()} result.\n\t */\n\tprotected final StringBuilder getDefinitionDescription() {\n\t\tStringBuilder result = new StringBuilder();\n\t\tresult.append(getPropagationBehaviorName(this.propagationBehavior));\n\t\tresult.append(',');\n\t\tresult.append(getIsolationLevelName(this.isolationLevel));\n\t\tif (this.timeout != TIMEOUT_DEFAULT) {\n\t\t\tresult.append(',');\n\t\t\tresult.append(PREFIX_TIMEOUT).append(this.timeout);\n\t\t}\n\t\tif (this.readOnly) {\n\t\t\tresult.append(',');\n\t\t\tresult.append(READ_ONLY_MARKER);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static String getPropagationBehaviorName(int propagationBehavior) {\n\t\treturn switch(propagationBehavior) {\n\t\t\tcase TransactionDefinition.PROPAGATION_REQUIRED -> \"PROPAGATION_REQUIRED\";\n\t\t\tcase TransactionDefinition.PROPAGATION_SUPPORTS -> \"PROPAGATION_SUPPORTS\";\n\t\t\tcase TransactionDefinition.PROPAGATION_MANDATORY -> \"PROPAGATION_MANDATORY\";\n\t\t\tcase TransactionDefinition.PROPAGATION_REQUIRES_NEW -> \"PROPAGATION_REQUIRES_NEW\";\n\t\t\tcase TransactionDefinition.PROPAGATION_NOT_SUPPORTED -> \"PROPAGATION_NOT_SUPPORTED\";\n\t\t\tcase TransactionDefinition.PROPAGATION_NEVER -> \"PROPAGATION_NEVER\";\n\t\t\tcase TransactionDefinition.PROPAGATION_NESTED -> \"PROPAGATION_NESTED\";\n\t\t\tdefault -> throw new IllegalArgumentException(\"Unsupported propagation behavior: \" + propagationBehavior);\n\t\t};\n\t}\n\n\tstatic String getIsolationLevelName(int isolationLevel) {\n\t\treturn switch(isolationLevel) {\n\t\t\tcase TransactionDefinition.ISOLATION_DEFAULT -> \"ISOLATION_DEFAULT\";\n\t\t\tcase TransactionDefinition.ISOLATION_READ_UNCOMMITTED -> \"ISOLATION_READ_UNCOMMITTED\";\n\t\t\tcase TransactionDefinition.ISOLATION_READ_COMMITTED -> \"ISOLATION_READ_COMMITTED\";\n\t\t\tcase TransactionDefinition.ISOLATION_REPEATABLE_READ -> \"ISOLATION_REPEATABLE_READ\";\n\t\t\tcase TransactionDefinition.ISOLATION_SERIALIZABLE -> \"ISOLATION_SERIALIZABLE\";\n\t\t\tdefault -> throw new IllegalArgumentException(\"Unsupported isolation level: \" + isolationLevel);\n\t\t};\n\t}\n\n}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation compares the {@code toString()} results.\n\t * @see #toString()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof TransactionDefinition && toString().equals(other.toString())));\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#getDefinitionDescription()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return an identifying description for this transaction definition.\n\t * <p>Available to subclasses, for inclusion in their {@code toString()} result.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 318
    },
    "return": "StringBuilder",
    "signature": "protected StringBuilder getDefinitionDescription()",
    "source_code": "\tprotected final StringBuilder getDefinitionDescription() {\n\t\tStringBuilder result = new StringBuilder();\n\t\tresult.append(getPropagationBehaviorName(this.propagationBehavior));\n\t\tresult.append(',');\n\t\tresult.append(getIsolationLevelName(this.isolationLevel));\n\t\tif (this.timeout != TIMEOUT_DEFAULT) {\n\t\t\tresult.append(',');\n\t\t\tresult.append(PREFIX_TIMEOUT).append(this.timeout);\n\t\t}\n\t\tif (this.readOnly) {\n\t\t\tresult.append(',');\n\t\t\tresult.append(READ_ONLY_MARKER);\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#getIsolationLevel()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "int",
    "signature": "public int getIsolationLevel()",
    "source_code": "\tpublic final int getIsolationLevel() {\n\t\treturn this.isolationLevel;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#getName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "String",
    "signature": "public String getName()",
    "source_code": "\tpublic final String getName() {\n\t\treturn this.name;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#getPropagationBehavior()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "int",
    "signature": "public int getPropagationBehavior()",
    "source_code": "\tpublic final int getPropagationBehavior() {\n\t\treturn this.propagationBehavior;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#getTimeout()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "int",
    "signature": "public int getTimeout()",
    "source_code": "\tpublic final int getTimeout() {\n\t\treturn this.timeout;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns {@code toString()}'s hash code.\n\t * @see #toString()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn toString().hashCode();\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#isReadOnly()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 259
    },
    "return": "boolean",
    "signature": "public boolean isReadOnly()",
    "source_code": "\tpublic final boolean isReadOnly() {\n\t\treturn this.readOnly;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#setIsolationLevel(isolationLevel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the isolation level. Must be one of the isolation constants\n\t * in the TransactionDefinition interface. Default is ISOLATION_DEFAULT.\n\t * <p>Exclusively designed for use with {@link #PROPAGATION_REQUIRED} or\n\t * {@link #PROPAGATION_REQUIRES_NEW} since it only applies to newly started\n\t * transactions. Consider switching the \"validateExistingTransactions\" flag to\n\t * \"true\" on your transaction manager if you'd like isolation level declarations\n\t * to get rejected when participating in an existing transaction with a different\n\t * isolation level.\n\t * <p>Note that a transaction manager that does not support custom isolation levels\n\t * will throw an exception when given any other level than {@link #ISOLATION_DEFAULT}.\n\t * @throws IllegalArgumentException if the supplied value is not one of the\n\t * {@code ISOLATION_} constants\n\t * @see #ISOLATION_DEFAULT\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "isolationLevel"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "void",
    "signature": "public void setIsolationLevel(int isolationLevel)",
    "source_code": "\tpublic final void setIsolationLevel(int isolationLevel) {\n\t\tAssert.isTrue(isolationConstants.containsValue(isolationLevel),\n\t\t\t\t\"Only values of isolation constants allowed\");\n\t\tthis.isolationLevel = isolationLevel;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#setIsolationLevelName(constantName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the isolation level by the name of the corresponding constant in\n\t * {@link TransactionDefinition} &mdash; for example, {@code \"ISOLATION_DEFAULT\"}.\n\t * @param constantName name of the constant\n\t * @throws IllegalArgumentException if the supplied value is not resolvable\n\t * to one of the {@code ISOLATION_} constants or is {@code null}\n\t * @see #setIsolationLevel\n\t * @see #ISOLATION_DEFAULT\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "constantName"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "void",
    "signature": "public void setIsolationLevelName(String constantName)",
    "source_code": "\tpublic final void setIsolationLevelName(String constantName) throws IllegalArgumentException {\n\t\tAssert.hasText(constantName, \"'constantName' must not be null or blank\");\n\t\tInteger isolationLevel = isolationConstants.get(constantName);\n\t\tAssert.notNull(isolationLevel, \"Only isolation constants allowed\");\n\t\tthis.isolationLevel = isolationLevel;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#setName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of this transaction. Default is none.\n\t * <p>This will be used as transaction name to be shown in a\n\t * transaction monitor, if applicable (for example, WebLogic's).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 268
    },
    "return": "void",
    "signature": "public void setName(String name)",
    "source_code": "\tpublic final void setName(String name) {\n\t\tthis.name = name;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#setPropagationBehavior(propagationBehavior)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the propagation behavior. Must be one of the propagation constants\n\t * in the TransactionDefinition interface. Default is PROPAGATION_REQUIRED.\n\t * <p>Exclusively designed for use with {@link #PROPAGATION_REQUIRED} or\n\t * {@link #PROPAGATION_REQUIRES_NEW} since it only applies to newly started\n\t * transactions. Consider switching the \"validateExistingTransactions\" flag to\n\t * \"true\" on your transaction manager if you'd like isolation level declarations\n\t * to get rejected when participating in an existing transaction with a different\n\t * isolation level.\n\t * <p>Note that a transaction manager that does not support custom isolation levels\n\t * will throw an exception when given any other level than {@link #ISOLATION_DEFAULT}.\n\t * @throws IllegalArgumentException if the supplied value is not one of the\n\t * {@code PROPAGATION_} constants\n\t * @see #PROPAGATION_REQUIRED\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propagationBehavior"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "void",
    "signature": "public void setPropagationBehavior(int propagationBehavior)",
    "source_code": "\tpublic final void setPropagationBehavior(int propagationBehavior) {\n\t\tAssert.isTrue(propagationConstants.containsValue(propagationBehavior),\n\t\t\t\t\"Only values of propagation constants allowed\");\n\t\tthis.propagationBehavior = propagationBehavior;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#setPropagationBehaviorName(constantName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the propagation behavior by the name of the corresponding constant in\n\t * {@link TransactionDefinition} &mdash; for example, {@code \"PROPAGATION_REQUIRED\"}.\n\t * @param constantName name of the constant\n\t * @throws IllegalArgumentException if the supplied value is not resolvable\n\t * to one of the {@code PROPAGATION_} constants or is {@code null}\n\t * @see #setPropagationBehavior\n\t * @see #PROPAGATION_REQUIRED\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "constantName"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "void",
    "signature": "public void setPropagationBehaviorName(String constantName)",
    "source_code": "\tpublic final void setPropagationBehaviorName(String constantName) throws IllegalArgumentException {\n\t\tAssert.hasText(constantName, \"'constantName' must not be null or blank\");\n\t\tInteger propagationBehavior = propagationConstants.get(constantName);\n\t\tAssert.notNull(propagationBehavior, \"Only propagation behavior constants allowed\");\n\t\tthis.propagationBehavior = propagationBehavior;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#setReadOnly(readOnly)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to optimize as read-only transaction.\n\t * Default is \"false\".\n\t * <p>The read-only flag applies to any transaction context, whether backed\n\t * by an actual resource transaction ({@link #PROPAGATION_REQUIRED}/\n\t * {@link #PROPAGATION_REQUIRES_NEW}) or operating non-transactionally at\n\t * the resource level ({@link #PROPAGATION_SUPPORTS}). In the latter case,\n\t * the flag will only apply to managed resources within the application,\n\t * such as a Hibernate {@code Session}.\n\t * <p>This just serves as a hint for the actual transaction subsystem;\n\t * it will <i>not necessarily</i> cause failure of write access attempts.\n\t * A transaction manager which cannot interpret the read-only hint will\n\t * <i>not</i> throw an exception when asked for a read-only transaction.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "readOnly"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "void",
    "signature": "public void setReadOnly(boolean readOnly)",
    "source_code": "\tpublic final void setReadOnly(boolean readOnly) {\n\t\tthis.readOnly = readOnly;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#setTimeout(timeout)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the timeout to apply, as number of seconds.\n\t * Default is TIMEOUT_DEFAULT (-1).\n\t * <p>Exclusively designed for use with {@link #PROPAGATION_REQUIRED} or\n\t * {@link #PROPAGATION_REQUIRES_NEW} since it only applies to newly started\n\t * transactions.\n\t * <p>Note that a transaction manager that does not support timeouts will throw\n\t * an exception when given any other timeout than {@link #TIMEOUT_DEFAULT}.\n\t * @see #TIMEOUT_DEFAULT\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "void",
    "signature": "public void setTimeout(int timeout)",
    "source_code": "\tpublic final void setTimeout(int timeout) {\n\t\tif (timeout < TIMEOUT_DEFAULT) {\n\t\t\tthrow new IllegalArgumentException(\"Timeout must be a positive integer or TIMEOUT_DEFAULT\");\n\t\t}\n\t\tthis.timeout = timeout;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return an identifying description for this transaction definition.\n\t * <p>The format matches the one used by\n\t * {@link org.springframework.transaction.interceptor.TransactionAttributeEditor},\n\t * to be able to feed {@code toString} results into bean properties of type\n\t * {@link org.springframework.transaction.interceptor.TransactionAttribute}.\n\t * <p>Has to be overridden in subclasses for correct {@code equals}\n\t * and {@code hashCode} behavior. Alternatively, {@link #equals}\n\t * and {@link #hashCode} can be overridden themselves.\n\t * @see #getDefinitionDescription()\n\t * @see org.springframework.transaction.interceptor.TransactionAttributeEditor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 310
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn getDefinitionDescription().toString();\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionStatus#getTransactionName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "String",
    "signature": "public String getTransactionName()",
    "source_code": "\tpublic String getTransactionName() {\n\t\treturn (this.transactionName != null ? this.transactionName : \"\");\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionStatus#isNested()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "boolean",
    "signature": "public boolean isNested()",
    "source_code": "\tpublic boolean isNested() {\n\t\treturn this.nested;\n\t}"
  },
  "org.springframework.transaction.support.PREFIX_ISOLATION": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Prefix for the isolation constants defined in TransactionDefinition. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "signature": "public String PREFIX_ISOLATION",
    "source_code": "\tpublic static final String PREFIX_ISOLATION = \"ISOLATION_\";",
    "type": "String"
  },
  "org.springframework.transaction.support.PREFIX_PROPAGATION": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Prefix for the propagation constants defined in TransactionDefinition. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public String PREFIX_PROPAGATION",
    "source_code": "\tpublic static final String PREFIX_PROPAGATION = \"PROPAGATION_\";",
    "type": "String"
  },
  "org.springframework.transaction.support.PREFIX_TIMEOUT": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Prefix for transaction timeout values in description strings. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public String PREFIX_TIMEOUT",
    "source_code": "\tpublic static final String PREFIX_TIMEOUT = \"timeout_\";",
    "type": "String"
  },
  "org.springframework.transaction.support.READ_ONLY_MARKER": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Marker for read-only transactions in description strings. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "public String READ_ONLY_MARKER",
    "source_code": "\tpublic static final String READ_ONLY_MARKER = \"readOnly\";",
    "type": "String"
  },
  "org.springframework.util.<unknown>#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 628
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object obj) {\n\t\t\treturn this == obj || this.delegate.equals(obj);\n\t\t}"
  },
  "org.springframework.util.<unknown>#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 607
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other || this.delegate.equals(other));\n\t\t}"
  },
  "org.springframework.util.ReflectionUtils#findFieldIgnoreCase(clazz,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to find a {@link Field field} on the supplied {@link Class} with the\n\t * supplied {@code name}. Searches all superclasses up to {@link Object}.\n\t * @param clazz the class to introspect\n\t * @param name the name of the field (with upper/lower case to be ignored)\n\t * @return the corresponding Field object, or {@code null} if not found\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 621
    },
    "return": "Field",
    "signature": "public Field findFieldIgnoreCase(Class<?> clazz, String name)",
    "source_code": "\tpublic static Field findFieldIgnoreCase(Class<?> clazz, String name) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tClass<?> searchType = clazz;\n\t\twhile (Object.class != searchType && searchType != null) {\n\t\t\tField[] fields = getDeclaredFields(searchType);\n\t\t\tfor (Field field : fields) {\n\t\t\t\tif (name.equalsIgnoreCase(field.getName())) {\n\t\t\t\t\treturn field;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsearchType = searchType.getSuperclass();\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.util.comparator.BooleanComparator#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof BooleanComparator that && this.trueLow == that.trueLow));\n\t}"
  },
  "org.springframework.util.comparator.BooleanComparator#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof BooleanComparator that && this.trueLow == that.trueLow));\n\t}"
  },
  "org.springframework.util.xml.<unknown>#endPrefixMapping(prefix)": {
    "change": "modifier_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "prefix"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "void",
    "signature": "public void endPrefixMapping(String prefix)",
    "source_code": "\tpublic void endPrefixMapping(String prefix) {\n\t}"
  },
  "org.springframework.validation.DataBinder#getNameResolver()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link #setNameResolver configured} name resolver for\n\t * constructor parameters.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 634
    },
    "return": "NameResolver",
    "signature": "public NameResolver getNameResolver()",
    "source_code": "\tpublic NameResolver getNameResolver() {\n\t\treturn this.nameResolver;\n\t}"
  },
  "org.springframework.validation.DataBinder#isDeclarativeBinding()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether to bind only fields intended for binding.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 449
    },
    "return": "boolean",
    "signature": "public boolean isDeclarativeBinding()",
    "source_code": "\tpublic boolean isDeclarativeBinding() {\n\t\treturn this.declarativeBinding;\n\t}"
  },
  "org.springframework.validation.DataBinder#setDeclarativeBinding(declarativeBinding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to bind only fields explicitly intended for binding including:\n\t * <ul>\n\t * <li>Constructor binding via {@link #construct}.\n\t * <li>Property binding with configured\n\t * {@link #setAllowedFields(String...) allowedFields}.\n\t * </ul>\n\t * <p>Default is \"false\". Turn this on to limit binding to constructor\n\t * parameters and allowed fields.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "declarativeBinding"
    ],
    "position": {
      "column": 1,
      "line": 441
    },
    "return": "void",
    "signature": "public void setDeclarativeBinding(boolean declarativeBinding)",
    "source_code": "\tpublic void setDeclarativeBinding(boolean declarativeBinding) {\n\t\tthis.declarativeBinding = declarativeBinding;\n\t}"
  },
  "org.springframework.validation.DataBinder#setNameResolver(nameResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a resolver to determine the name of the value to bind to a\n\t * constructor parameter in {@link #construct}.\n\t * <p>If not configured, or if the name cannot be resolved, by default\n\t * {@link org.springframework.core.DefaultParameterNameDiscoverer} is used.\n\t * @param nameResolver the resolver to use\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nameResolver"
    ],
    "position": {
      "column": 1,
      "line": 624
    },
    "return": "void",
    "signature": "public void setNameResolver(NameResolver nameResolver)",
    "source_code": "\tpublic void setNameResolver(NameResolver nameResolver) {\n\t\tthis.nameResolver = nameResolver;\n\t}"
  },
  "org.springframework.validation.DataBinder#shouldNotBindPropertyValues()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to not bind parameters to properties. Returns \"true\" if\n\t * {@link #isDeclarativeBinding()} is on, and\n\t * {@link #setAllowedFields(String...) allowedFields} are not configured.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1072
    },
    "return": "boolean",
    "signature": "protected boolean shouldNotBindPropertyValues()",
    "source_code": "\tprotected boolean shouldNotBindPropertyValues() {\n\t\treturn (isDeclarativeBinding() && ObjectUtils.isEmpty(this.allowedFields));\n\t}"
  },
  "org.springframework.validation.NameResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Strategy to determine the name of the value to bind to a method parameter.\n\t * Supported on constructor parameters with {@link #construct constructor\n\t * binding} which performs lookups via {@link ValueResolver#resolveValue}.\n\t */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 1265
    },
    "signature": "public interface NameResolver",
    "source_code": "\tpublic interface NameResolver {\n\n\t\t/**\n\t\t * Return the name to use for the given method parameter, or {@code null}\n\t\t * if unresolved. For constructor parameters, the name is determined via\n\t\t * {@link org.springframework.core.DefaultParameterNameDiscoverer} if\n\t\t * unresolved.\n\t\t */\n\t\t@Nullable\n\t\tString resolveName(MethodParameter parameter);\n\n\t}"
  },
  "org.springframework.validation.SimpleErrors": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A simple implementation of the {@link Errors} interface, managing global\n * errors and field errors for a top-level target object. Flexibly retrieves\n * field values through bean property getter methods, and automatically\n * falls back to raw field access if necessary.\n *\n * <p>Note that this {@link Errors} implementation comes without support for\n * nested paths. It is exclusively designed for the validation of individual\n * top-level objects, not aggregating errors from multiple sources.\n * If this is insufficient for your purposes, use a binding-capable\n * {@link Errors} implementation such as {@link BeanPropertyBindingResult}.\n *\n * @author Juergen Hoeller\n * @since 6.1\n * @see Validator#validateObject(Object)\n * @see BeanPropertyBindingResult\n * @see DirectFieldBindingResult\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "public class SimpleErrors",
    "source_code": "public class SimpleErrors implements Errors, Serializable {\n\n\tprivate final Object target;\n\n\tprivate final String objectName;\n\n\tprivate final List<ObjectError> globalErrors = new ArrayList<>();\n\n\tprivate final List<FieldError> fieldErrors = new ArrayList<>();\n\n\n\t/**\n\t * Create a new {@link SimpleErrors} holder for the given target,\n\t * using the simple name of the target class as the object name.\n\t * @param target the target to wrap\n\t */\n\tpublic SimpleErrors(Object target) {\n\t\tAssert.notNull(target, \"Target must not be null\");\n\t\tthis.target = target;\n\t\tthis.objectName = this.target.getClass().getSimpleName();\n\t}\n\n\t/**\n\t * Create a new {@link SimpleErrors} holder for the given target.\n\t * @param target the target to wrap\n\t * @param objectName the name of the target object for error reporting\n\t */\n\tpublic SimpleErrors(Object target, String objectName) {\n\t\tAssert.notNull(target, \"Target must not be null\");\n\t\tthis.target = target;\n\t\tthis.objectName = objectName;\n\t}\n\n\n\t@Override\n\tpublic String getObjectName() {\n\t\treturn this.objectName;\n\t}\n\n\t@Override\n\tpublic void reject(String errorCode, @Nullable Object[] errorArgs, @Nullable String defaultMessage) {\n\t\tthis.globalErrors.add(new ObjectError(getObjectName(), new String[] {errorCode}, errorArgs, defaultMessage));\n\t}\n\n\t@Override\n\tpublic void rejectValue(@Nullable String field, String errorCode,\n\t\t\t@Nullable Object[] errorArgs, @Nullable String defaultMessage) {\n\n\t\tif (!StringUtils.hasLength(field)) {\n\t\t\treject(errorCode, errorArgs, defaultMessage);\n\t\t\treturn;\n\t\t}\n\n\t\tObject newVal = getFieldValue(field);\n\t\tthis.fieldErrors.add(new FieldError(getObjectName(), field, newVal, false,\n\t\t\t\tnew String[] {errorCode}, errorArgs, defaultMessage));\n\t}\n\n\t@Override\n\tpublic void addAllErrors(Errors errors) {\n\t\tthis.globalErrors.addAll(errors.getGlobalErrors());\n\t\tthis.fieldErrors.addAll(errors.getFieldErrors());\n\t}\n\n\t@Override\n\tpublic List<ObjectError> getGlobalErrors() {\n\t\treturn this.globalErrors;\n\t}\n\n\t@Override\n\tpublic List<FieldError> getFieldErrors() {\n\t\treturn this.fieldErrors;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Object getFieldValue(String field) {\n\t\tFieldError fieldError = getFieldError(field);\n\t\tif (fieldError != null) {\n\t\t\treturn fieldError.getRejectedValue();\n\t\t}\n\n\t\tPropertyDescriptor pd = BeanUtils.getPropertyDescriptor(this.target.getClass(), field);\n\t\tif (pd != null && pd.getReadMethod() != null) {\n\t\t\tReflectionUtils.makeAccessible(pd.getReadMethod());\n\t\t\treturn ReflectionUtils.invokeMethod(pd.getReadMethod(), this.target);\n\t\t}\n\n\t\tField rawField = ReflectionUtils.findField(this.target.getClass(), field);\n\t\tif (rawField != null) {\n\t\t\tReflectionUtils.makeAccessible(rawField);\n\t\t\treturn ReflectionUtils.getField(rawField, this.target);\n\t\t}\n\n\t\tthrow new IllegalArgumentException(\"Cannot retrieve value for field '\" + field +\n\t\t\t\t\"' - neither a getter method nor a raw field found\");\n\t}\n\n\t@Override\n\tpublic Class<?> getFieldType(String field) {\n\t\tPropertyDescriptor pd = BeanUtils.getPropertyDescriptor(this.target.getClass(), field);\n\t\tif (pd != null) {\n\t\t\treturn pd.getPropertyType();\n\t\t}\n\t\tField rawField = ReflectionUtils.findField(this.target.getClass(), field);\n\t\tif (rawField != null) {\n\t\t\treturn rawField.getType();\n\t\t}\n\t\treturn null;\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof SimpleErrors that &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.target, that.target) &&\n\t\t\t\tthis.globalErrors.equals(that.globalErrors) &&\n\t\t\t\tthis.fieldErrors.equals(that.fieldErrors)));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.target.hashCode();\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (ObjectError error : this.globalErrors) {\n\t\t\tsb.append('\\n').append(error);\n\t\t}\n\t\tfor (ObjectError error : this.fieldErrors) {\n\t\t\tsb.append('\\n').append(error);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n}"
  },
  "org.springframework.validation.SimpleErrors#addAllErrors(errors)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "void",
    "signature": "public void addAllErrors(Errors errors)",
    "source_code": "\tpublic void addAllErrors(Errors errors) {\n\t\tthis.globalErrors.addAll(errors.getGlobalErrors());\n\t\tthis.fieldErrors.addAll(errors.getFieldErrors());\n\t}"
  },
  "org.springframework.validation.SimpleErrors#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof SimpleErrors that &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.target, that.target) &&\n\t\t\t\tthis.globalErrors.equals(that.globalErrors) &&\n\t\t\t\tthis.fieldErrors.equals(that.fieldErrors)));\n\t}"
  },
  "org.springframework.validation.SimpleErrors#getFieldErrors()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "List<FieldError>",
    "signature": "public List<FieldError> getFieldErrors()",
    "source_code": "\tpublic List<FieldError> getFieldErrors() {\n\t\treturn this.fieldErrors;\n\t}"
  },
  "org.springframework.validation.SimpleErrors#getFieldValue(field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "Object",
    "signature": "public Object getFieldValue(String field)",
    "source_code": "\tpublic Object getFieldValue(String field) {\n\t\tFieldError fieldError = getFieldError(field);\n\t\tif (fieldError != null) {\n\t\t\treturn fieldError.getRejectedValue();\n\t\t}\n\n\t\tPropertyDescriptor pd = BeanUtils.getPropertyDescriptor(this.target.getClass(), field);\n\t\tif (pd != null && pd.getReadMethod() != null) {\n\t\t\tReflectionUtils.makeAccessible(pd.getReadMethod());\n\t\t\treturn ReflectionUtils.invokeMethod(pd.getReadMethod(), this.target);\n\t\t}\n\n\t\tField rawField = ReflectionUtils.findField(this.target.getClass(), field);\n\t\tif (rawField != null) {\n\t\t\tReflectionUtils.makeAccessible(rawField);\n\t\t\treturn ReflectionUtils.getField(rawField, this.target);\n\t\t}\n\n\t\tthrow new IllegalArgumentException(\"Cannot retrieve value for field '\" + field +\n\t\t\t\t\"' - neither a getter method nor a raw field found\");\n\t}"
  },
  "org.springframework.validation.SimpleErrors#getGlobalErrors()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "List<ObjectError>",
    "signature": "public List<ObjectError> getGlobalErrors()",
    "source_code": "\tpublic List<ObjectError> getGlobalErrors() {\n\t\treturn this.globalErrors;\n\t}"
  },
  "org.springframework.validation.SimpleErrors#getObjectName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "String",
    "signature": "public String getObjectName()",
    "source_code": "\tpublic String getObjectName() {\n\t\treturn this.objectName;\n\t}"
  },
  "org.springframework.validation.SimpleErrors#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.target.hashCode();\n\t}"
  },
  "org.springframework.validation.SimpleErrors#reject(errorCode,errorArgs,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "void",
    "signature": "public void reject(String errorCode, @Nullable Object[] errorArgs, @Nullable String defaultMessage)",
    "source_code": "\tpublic void reject(String errorCode, @Nullable Object[] errorArgs, @Nullable String defaultMessage) {\n\t\tthis.globalErrors.add(new ObjectError(getObjectName(), new String[] {errorCode}, errorArgs, defaultMessage));\n\t}"
  },
  "org.springframework.validation.SimpleErrors#rejectValue(field,errorCode,errorArgs,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode,\n\t\t\t@Nullable Object[] errorArgs, @Nullable String defaultMessage)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode,"
  },
  "org.springframework.validation.SimpleErrors#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (ObjectError error : this.globalErrors) {\n\t\t\tsb.append('\\n').append(error);\n\t\t}\n\t\tfor (ObjectError error : this.fieldErrors) {\n\t\t\tsb.append('\\n').append(error);\n\t\t}\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.web.multipart.<unknown>#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof MultipartFileResource other &&\n\t\t\t\tthis.multipartFile.equals(other.multipartFile)));\n\t}"
  },
  "org.springframework.web.multipart.<unknown>#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof MultipartFileResource that &&\n\t\t\t\tthis.multipartFile.equals(that.multipartFile)));\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#build()": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "Mono<RenderingResponse>",
    "signature": "public Mono<RenderingResponse> build()",
    "source_code": "\tpublic Mono<RenderingResponse> build() {\n\t\treturn Mono.just(\n\t\t\t\tnew DefaultRenderingResponse(this.status, this.headers, this.cookies, this.name, this.model));\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMapping#createRequestMappingInfo(httpExchange,customCondition)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link RequestMappingInfo} from the supplied\n\t * {@link HttpExchange @HttpExchange} annotation, or meta-annotation,\n\t * or synthesized result of merging annotation attributes within an\n\t * annotation hierarchy.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "httpExchange",
      "customCondition"
    ],
    "position": {
      "column": 1,
      "line": 268
    },
    "return": "RequestMappingInfo",
    "signature": "protected RequestMappingInfo createRequestMappingInfo(HttpExchange httpExchange, @Nullable RequestCondition<?> customCondition)",
    "source_code": "\tprotected RequestMappingInfo createRequestMappingInfo("
  },
  "org.springframework.web.servlet.handler.MappedInterceptor#getExcludePathPatterns()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the exclude path patterns this interceptor is mapped to.\n\t * @since 6.1\n\t * @see #getIncludePathPatterns()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "String[]",
    "signature": "public String[] getExcludePathPatterns()",
    "source_code": "\tpublic String[] getExcludePathPatterns() {\n\t\treturn (!ObjectUtils.isEmpty(this.excludePatterns) ?\n\t\t\t\tArrays.stream(this.excludePatterns).map(PatternAdapter::getPatternString).toArray(String[]::new) :\n\t\t\t\tnull);\n\t}"
  },
  "org.springframework.web.servlet.handler.MappedInterceptor#getIncludePathPatterns()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the include path patterns this interceptor is mapped to.\n\t * @since 6.1\n\t * @see #getExcludePathPatterns()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "String[]",
    "signature": "public String[] getIncludePathPatterns()",
    "source_code": "\tpublic String[] getIncludePathPatterns() {\n\t\treturn (!ObjectUtils.isEmpty(this.includePatterns) ?\n\t\t\t\tArrays.stream(this.includePatterns).map(PatternAdapter::getPatternString).toArray(String[]::new) :\n\t\t\t\tnull);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#shouldApplyTo(request,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 377
    },
    "return": "boolean",
    "signature": "protected boolean shouldApplyTo(HttpServletRequest request, @Nullable Object handler)",
    "source_code": "\tprotected boolean shouldApplyTo(HttpServletRequest request, @Nullable Object handler) {\n\t\treturn (handler instanceof ResourceHttpRequestHandler ?\n\t\t\t\thasGlobalExceptionHandlers() : super.shouldApplyTo(request, handler));\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#createRequestMappingInfo(httpExchange,customCondition)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link RequestMappingInfo} from the supplied\n\t * {@link HttpExchange @HttpExchange} annotation, or meta-annotation,\n\t * or synthesized result of merging annotation attributes within an\n\t * annotation hierarchy.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "httpExchange",
      "customCondition"
    ],
    "position": {
      "column": 1,
      "line": 423
    },
    "return": "RequestMappingInfo",
    "signature": "protected RequestMappingInfo createRequestMappingInfo(HttpExchange httpExchange, @Nullable RequestCondition<?> customCondition)",
    "source_code": "\tprotected RequestMappingInfo createRequestMappingInfo("
  },
  "org.springframework.web.servlet.mvc.method.annotation.ResponseBodyEmitterReturnValueHandler#send(items)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "items"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "void",
    "signature": "public void send(Set<ResponseBodyEmitter.DataWithMediaType> items)",
    "source_code": "\t\tpublic void send(Set<ResponseBodyEmitter.DataWithMediaType> items) throws IOException {\n\t\t\tfor (ResponseBodyEmitter.DataWithMediaType item : items) {\n\t\t\t\tsendInternal(item.getData(), item.getMediaType());\n\t\t\t}\n\t\t\tthis.outputMessage.flush();\n\t\t}"
  }
}