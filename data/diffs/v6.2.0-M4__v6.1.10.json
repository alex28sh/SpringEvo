{
  "org.springframework.aop.aspectj.autoproxy.AspectJAwareAdvisorAutoProxyCreator#afterSingletonsInstantiated()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "void",
    "signature": "public void afterSingletonsInstantiated()",
    "source_code": "\tpublic void afterSingletonsInstantiated() {\n\t\tShadowMatchUtils.clearCache();\n\t}"
  },
  "org.springframework.aop.aspectj.autoproxy.AspectJAwareAdvisorAutoProxyCreator#destroy()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "void",
    "signature": "public void destroy()",
    "source_code": "\tpublic void destroy() {\n\t\tShadowMatchUtils.clearCache();\n\t}"
  },
  "org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract BeanFactory-based PointcutAdvisor that allows for any Advice\n * to be configured as reference to an Advice bean in a BeanFactory.\n *\n * <p>Specifying the name of an advice bean instead of the advice object itself\n * (if running within a BeanFactory) increases loose coupling at initialization time,\n * in order to not initialize the advice object until the pointcut actually matches.\n *\n * @author Juergen Hoeller\n * @since 2.0.2\n * @see #setAdviceBeanName\n * @see DefaultBeanFactoryPointcutAdvisor\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "signature": "public class AbstractBeanFactoryPointcutAdvisor",
    "source_code": "public abstract class AbstractBeanFactoryPointcutAdvisor extends AbstractPointcutAdvisor implements BeanFactoryAware {\n\n\t@Nullable\n\tprivate String adviceBeanName;\n\n\t@Nullable\n\tprivate BeanFactory beanFactory;\n\n\t@Nullable\n\tprivate transient volatile Advice advice;\n\n\tprivate transient volatile Object adviceMonitor = new Object();\n\n\n\t/**\n\t * Specify the name of the advice bean that this advisor should refer to.\n\t * <p>An instance of the specified bean will be obtained on first access\n\t * of this advisor's advice. This advisor will only ever obtain at most one\n\t * single instance of the advice bean, caching the instance for the lifetime\n\t * of the advisor.\n\t * @see #getAdvice()\n\t */\n\tpublic void setAdviceBeanName(@Nullable String adviceBeanName) {\n\t\tthis.adviceBeanName = adviceBeanName;\n\t}\n\n\t/**\n\t * Return the name of the advice bean that this advisor refers to, if any.\n\t */\n\t@Nullable\n\tpublic String getAdviceBeanName() {\n\t\treturn this.adviceBeanName;\n\t}\n\n\t@Override\n\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t\tresetAdviceMonitor();\n\t}\n\n\tprivate void resetAdviceMonitor() {\n\t\tif (this.beanFactory instanceof ConfigurableBeanFactory cbf) {\n\t\t\tthis.adviceMonitor = cbf.getSingletonMutex();\n\t\t}\n\t\telse {\n\t\t\tthis.adviceMonitor = new Object();\n\t\t}\n\t}\n\n\t/**\n\t * Specify a particular instance of the target advice directly,\n\t * avoiding lazy resolution in {@link #getAdvice()}.\n\t * @since 3.1\n\t */\n\tpublic void setAdvice(Advice advice) {\n\t\tsynchronized (this.adviceMonitor) {\n\t\t\tthis.advice = advice;\n\t\t}\n\t}\n\n\t@Override\n\tpublic Advice getAdvice() {\n\t\tAdvice advice = this.advice;\n\t\tif (advice != null) {\n\t\t\treturn advice;\n\t\t}\n\n\t\tAssert.state(this.adviceBeanName != null, \"'adviceBeanName' must be specified\");\n\t\tAssert.state(this.beanFactory != null, \"BeanFactory must be set to resolve 'adviceBeanName'\");\n\n\t\tif (this.beanFactory.isSingleton(this.adviceBeanName)) {\n\t\t\t// Rely on singleton semantics provided by the factory.\n\t\t\tadvice = this.beanFactory.getBean(this.adviceBeanName, Advice.class);\n\t\t\tthis.advice = advice;\n\t\t\treturn advice;\n\t\t}\n\t\telse {\n\t\t\t// No singleton guarantees from the factory -> let's lock locally but\n\t\t\t// reuse the factory's singleton lock, just in case a lazy dependency\n\t\t\t// of our advice bean happens to trigger the singleton lock implicitly...\n\t\t\tsynchronized (this.adviceMonitor) {\n\t\t\t\tadvice = this.advice;\n\t\t\t\tif (advice == null) {\n\t\t\t\t\tadvice = this.beanFactory.getBean(this.adviceBeanName, Advice.class);\n\t\t\t\t\tthis.advice = advice;\n\t\t\t\t}\n\t\t\t\treturn advice;\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder(getClass().getName());\n\t\tsb.append(\": advice \");\n\t\tif (this.adviceBeanName != null) {\n\t\t\tsb.append(\"bean '\").append(this.adviceBeanName).append('\\'');\n\t\t}\n\t\telse {\n\t\t\tsb.append(this.advice);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Serialization support\n\t//---------------------------------------------------------------------\n\n\tprivate void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\n\t\t// Rely on default serialization, just initialize state after deserialization.\n\t\tois.defaultReadObject();\n\n\t\t// Initialize transient fields.\n\t\tresetAdviceMonitor();\n\t}\n\n}"
  },
  "org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor#getAdvice()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "Advice",
    "signature": "public Advice getAdvice()",
    "source_code": "\tpublic Advice getAdvice() {\n\t\tAdvice advice = this.advice;\n\t\tif (advice != null) {\n\t\t\treturn advice;\n\t\t}\n\n\t\tAssert.state(this.adviceBeanName != null, \"'adviceBeanName' must be specified\");\n\t\tAssert.state(this.beanFactory != null, \"BeanFactory must be set to resolve 'adviceBeanName'\");\n\n\t\tif (this.beanFactory.isSingleton(this.adviceBeanName)) {\n\t\t\t// Rely on singleton semantics provided by the factory.\n\t\t\tadvice = this.beanFactory.getBean(this.adviceBeanName, Advice.class);\n\t\t\tthis.advice = advice;\n\t\t\treturn advice;\n\t\t}\n\t\telse {\n\t\t\t// No singleton guarantees from the factory -> let's lock locally but\n\t\t\t// reuse the factory's singleton lock, just in case a lazy dependency\n\t\t\t// of our advice bean happens to trigger the singleton lock implicitly...\n\t\t\tsynchronized (this.adviceMonitor) {\n\t\t\t\tadvice = this.advice;\n\t\t\t\tif (advice == null) {\n\t\t\t\t\tadvice = this.beanFactory.getBean(this.adviceBeanName, Advice.class);\n\t\t\t\t\tthis.advice = advice;\n\t\t\t\t}\n\t\t\t\treturn advice;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor#getAdviceBeanName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the name of the advice bean that this advisor refers to, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "String",
    "signature": "public String getAdviceBeanName()",
    "source_code": "\tpublic String getAdviceBeanName() {\n\t\treturn this.adviceBeanName;\n\t}"
  },
  "org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor#setAdvice(advice)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify a particular instance of the target advice directly,\n\t * avoiding lazy resolution in {@link #getAdvice()}.\n\t * @since 3.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "advice"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void setAdvice(Advice advice)",
    "source_code": "\tpublic void setAdvice(Advice advice) {\n\t\tsynchronized (this.adviceMonitor) {\n\t\t\tthis.advice = advice;\n\t\t}\n\t}"
  },
  "org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor#setAdviceBeanName(adviceBeanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the name of the advice bean that this advisor should refer to.\n\t * <p>An instance of the specified bean will be obtained on first access\n\t * of this advisor's advice. This advisor will only ever obtain at most one\n\t * single instance of the advice bean, caching the instance for the lifetime\n\t * of the advisor.\n\t * @see #getAdvice()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "adviceBeanName"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "void",
    "signature": "public void setAdviceBeanName(@Nullable String adviceBeanName)",
    "source_code": "\tpublic void setAdviceBeanName(@Nullable String adviceBeanName) {\n\t\tthis.adviceBeanName = adviceBeanName;\n\t}"
  },
  "org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t\tresetAdviceMonitor();\n\t}"
  },
  "org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder(getClass().getName());\n\t\tsb.append(\": advice \");\n\t\tif (this.adviceBeanName != null) {\n\t\t\tsb.append(\"bean '\").append(this.adviceBeanName).append('\\'');\n\t\t}\n\t\telse {\n\t\t\tsb.append(this.advice);\n\t\t}\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.beans.factory.annotation.BeanFactoryAnnotationUtils#getQualifierValue(annotatedElement)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the {@link Qualifier#value() qualifier value} for the given\n\t * annotated element.\n\t * @param annotatedElement the class, method or parameter to introspect\n\t * @return the associated qualifier value, or {@code null} if none\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "String",
    "signature": "public String getQualifierValue(AnnotatedElement annotatedElement)",
    "source_code": "\tpublic static String getQualifierValue(AnnotatedElement annotatedElement) {\n\t\tQualifier qualifier = AnnotationUtils.getAnnotation(annotatedElement, Qualifier.class);\n\t\treturn (qualifier != null ? qualifier.value() : null);\n\t}"
  },
  "org.springframework.beans.factory.annotation.QualifierAnnotationAutowireCandidateResolver#getSuggestedName(descriptor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 348
    },
    "return": "String",
    "signature": "public String getSuggestedName(DependencyDescriptor descriptor)",
    "source_code": "\tpublic String getSuggestedName(DependencyDescriptor descriptor) {\n\t\tfor (Annotation annotation : descriptor.getAnnotations()) {\n\t\t\tif (isQualifier(annotation.annotationType())) {\n\t\t\t\tObject value = AnnotationUtils.getValue(annotation);\n\t\t\t\tif (value instanceof String str) {\n\t\t\t\t\treturn str;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#applyTo(generationContext,beanFactoryInitializationCode)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanFactoryInitializationCode"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "void",
    "signature": "public void applyTo(GenerationContext generationContext,\n\t\t\tBeanFactoryInitializationCode beanFactoryInitializationCode)",
    "source_code": "\tpublic void applyTo(GenerationContext generationContext,"
  },
  "org.springframework.beans.factory.aot.<unknown>#getClassName()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "ClassName",
    "signature": "public ClassName getClassName()",
    "source_code": "\t\tpublic ClassName getClassName() {\n\t\t\treturn this.generatedClass.getName();\n\t\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#getMethods()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "GeneratedMethods",
    "signature": "public GeneratedMethods getMethods()",
    "source_code": "\t\tpublic GeneratedMethods getMethods() {\n\t\t\treturn this.generatedClass.getMethods();\n\t\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Descriptor for a specific dependency that is about to be injected.\n * Wraps a constructor parameter, a method parameter or a field,\n * allowing unified access to their metadata.\n *\n * @author Juergen Hoeller\n * @since 2.5\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "public class DependencyDescriptor",
    "source_code": "public class DependencyDescriptor extends InjectionPoint implements Serializable {\n\n\tprivate final Class<?> declaringClass;\n\n\t@Nullable\n\tprivate String methodName;\n\n\t@Nullable\n\tprivate Class<?>[] parameterTypes;\n\n\tprivate int parameterIndex;\n\n\t@Nullable\n\tprivate String fieldName;\n\n\tprivate final boolean required;\n\n\tprivate final boolean eager;\n\n\tprivate int nestingLevel = 1;\n\n\t@Nullable\n\tprivate Class<?> containingClass;\n\n\t@Nullable\n\tprivate transient volatile ResolvableType resolvableType;\n\n\t@Nullable\n\tprivate transient volatile TypeDescriptor typeDescriptor;\n\n\n\t/**\n\t * Create a new descriptor for a method or constructor parameter.\n\t * Considers the dependency as 'eager'.\n\t * @param methodParameter the MethodParameter to wrap\n\t * @param required whether the dependency is required\n\t */\n\tpublic DependencyDescriptor(MethodParameter methodParameter, boolean required) {\n\t\tthis(methodParameter, required, true);\n\t}\n\n\t/**\n\t * Create a new descriptor for a method or constructor parameter.\n\t * @param methodParameter the MethodParameter to wrap\n\t * @param required whether the dependency is required\n\t * @param eager whether this dependency is 'eager' in the sense of\n\t * eagerly resolving potential target beans for type matching\n\t */\n\tpublic DependencyDescriptor(MethodParameter methodParameter, boolean required, boolean eager) {\n\t\tsuper(methodParameter);\n\n\t\tthis.declaringClass = methodParameter.getDeclaringClass();\n\t\tif (methodParameter.getMethod() != null) {\n\t\t\tthis.methodName = methodParameter.getMethod().getName();\n\t\t}\n\t\tthis.parameterTypes = methodParameter.getExecutable().getParameterTypes();\n\t\tthis.parameterIndex = methodParameter.getParameterIndex();\n\t\tthis.containingClass = methodParameter.getContainingClass();\n\t\tthis.required = required;\n\t\tthis.eager = eager;\n\t}\n\n\t/**\n\t * Create a new descriptor for a field.\n\t * Considers the dependency as 'eager'.\n\t * @param field the field to wrap\n\t * @param required whether the dependency is required\n\t */\n\tpublic DependencyDescriptor(Field field, boolean required) {\n\t\tthis(field, required, true);\n\t}\n\n\t/**\n\t * Create a new descriptor for a field.\n\t * @param field the field to wrap\n\t * @param required whether the dependency is required\n\t * @param eager whether this dependency is 'eager' in the sense of\n\t * eagerly resolving potential target beans for type matching\n\t */\n\tpublic DependencyDescriptor(Field field, boolean required, boolean eager) {\n\t\tsuper(field);\n\n\t\tthis.declaringClass = field.getDeclaringClass();\n\t\tthis.fieldName = field.getName();\n\t\tthis.required = required;\n\t\tthis.eager = eager;\n\t}\n\n\t/**\n\t * Copy constructor.\n\t * @param original the original descriptor to create a copy from\n\t */\n\tpublic DependencyDescriptor(DependencyDescriptor original) {\n\t\tsuper(original);\n\n\t\tthis.declaringClass = original.declaringClass;\n\t\tthis.methodName = original.methodName;\n\t\tthis.parameterTypes = original.parameterTypes;\n\t\tthis.parameterIndex = original.parameterIndex;\n\t\tthis.fieldName = original.fieldName;\n\t\tthis.containingClass = original.containingClass;\n\t\tthis.required = original.required;\n\t\tthis.eager = original.eager;\n\t\tthis.nestingLevel = original.nestingLevel;\n\t}\n\n\n\t/**\n\t * Return whether this dependency is required.\n\t * <p>Optional semantics are derived from Java 8's {@link java.util.Optional},\n\t * any variant of a parameter-level {@code Nullable} annotation (such as from\n\t * JSR-305 or the FindBugs set of annotations), or a language-level nullable\n\t * type declaration in Kotlin.\n\t */\n\tpublic boolean isRequired() {\n\t\tif (!this.required) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.field != null) {\n\t\t\treturn !(this.field.getType() == Optional.class || hasNullableAnnotation() ||\n\t\t\t\t\t(KotlinDetector.isKotlinReflectPresent() &&\n\t\t\t\t\t\t\tKotlinDetector.isKotlinType(this.field.getDeclaringClass()) &&\n\t\t\t\t\t\t\tKotlinDelegate.isNullable(this.field)));\n\t\t}\n\t\telse {\n\t\t\treturn !obtainMethodParameter().isOptional();\n\t\t}\n\t}\n\n\t/**\n\t * Check whether the underlying field is annotated with any variant of a\n\t * {@code Nullable} annotation, e.g. {@code jakarta.annotation.Nullable} or\n\t * {@code edu.umd.cs.findbugs.annotations.Nullable}.\n\t */\n\tprivate boolean hasNullableAnnotation() {\n\t\tfor (Annotation ann : getAnnotations()) {\n\t\t\tif (\"Nullable\".equals(ann.annotationType().getSimpleName())) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Return whether this dependency is 'eager' in the sense of\n\t * eagerly resolving potential target beans for type matching.\n\t */\n\tpublic boolean isEager() {\n\t\treturn this.eager;\n\t}\n\n\t/**\n\t * Resolve the specified not-unique scenario: by default,\n\t * throwing a {@link NoUniqueBeanDefinitionException}.\n\t * <p>Subclasses may override this to select one of the instances or\n\t * to opt out with no result at all through returning {@code null}.\n\t * @param type the requested bean type\n\t * @param matchingBeans a map of bean names and corresponding bean\n\t * instances which have been pre-selected for the given type\n\t * (qualifiers etc already applied)\n\t * @return a bean instance to proceed with, or {@code null} for none\n\t * @throws BeansException in case of the not-unique scenario being fatal\n\t * @since 5.1\n\t */\n\t@Nullable\n\tpublic Object resolveNotUnique(ResolvableType type, Map<String, Object> matchingBeans) throws BeansException {\n\t\tthrow new NoUniqueBeanDefinitionException(type, matchingBeans.keySet());\n\t}\n\n\t/**\n\t * Resolve a shortcut for this dependency against the given factory, for example\n\t * taking some pre-resolved information into account.\n\t * <p>The resolution algorithm will first attempt to resolve a shortcut through this\n\t * method before going into the regular type matching algorithm across all beans.\n\t * Subclasses may override this method to improve resolution performance based on\n\t * pre-cached information while still receiving {@link InjectionPoint} exposure etc.\n\t * @param beanFactory the associated factory\n\t * @return the shortcut result if any, or {@code null} if none\n\t * @throws BeansException if the shortcut could not be obtained\n\t * @since 4.3.1\n\t */\n\t@Nullable\n\tpublic Object resolveShortcut(BeanFactory beanFactory) throws BeansException {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Resolve the specified bean name, as a candidate result of the matching\n\t * algorithm for this dependency, to a bean instance from the given factory.\n\t * <p>The default implementation calls {@link BeanFactory#getBean(String)}.\n\t * Subclasses may provide additional arguments or other customizations.\n\t * @param beanName the bean name, as a candidate result for this dependency\n\t * @param requiredType the expected type of the bean (as an assertion)\n\t * @param beanFactory the associated factory\n\t * @return the bean instance (never {@code null})\n\t * @throws BeansException if the bean could not be obtained\n\t * @since 4.3.2\n\t * @see BeanFactory#getBean(String)\n\t */\n\tpublic Object resolveCandidate(String beanName, Class<?> requiredType, BeanFactory beanFactory)\n\t\t\tthrows BeansException {\n\n\t\treturn beanFactory.getBean(beanName);\n\t}\n\n\n\t/**\n\t * Increase this descriptor's nesting level.\n\t */\n\tpublic void increaseNestingLevel() {\n\t\tthis.nestingLevel++;\n\t\tthis.resolvableType = null;\n\t\tif (this.methodParameter != null) {\n\t\t\tthis.methodParameter = this.methodParameter.nested();\n\t\t}\n\t}\n\n\t/**\n\t * Optionally set the concrete class that contains this dependency.\n\t * This may differ from the class that declares the parameter/field in that\n\t * it may be a subclass thereof, potentially substituting type variables.\n\t * @since 4.0\n\t */\n\tpublic void setContainingClass(Class<?> containingClass) {\n\t\tthis.containingClass = containingClass;\n\t\tthis.resolvableType = null;\n\t\tif (this.methodParameter != null) {\n\t\t\tthis.methodParameter = this.methodParameter.withContainingClass(containingClass);\n\t\t}\n\t}\n\n\t/**\n\t * Build a {@link ResolvableType} object for the wrapped parameter/field.\n\t * @since 4.0\n\t */\n\tpublic ResolvableType getResolvableType() {\n\t\tResolvableType resolvableType = this.resolvableType;\n\t\tif (resolvableType == null) {\n\t\t\tresolvableType = (this.field != null ?\n\t\t\t\t\tResolvableType.forField(this.field, this.nestingLevel, this.containingClass) :\n\t\t\t\t\tResolvableType.forMethodParameter(obtainMethodParameter()));\n\t\t\tthis.resolvableType = resolvableType;\n\t\t}\n\t\treturn resolvableType;\n\t}\n\n\t/**\n\t * Build a {@link TypeDescriptor} object for the wrapped parameter/field.\n\t * @since 5.1.4\n\t */\n\tpublic TypeDescriptor getTypeDescriptor() {\n\t\tTypeDescriptor typeDescriptor = this.typeDescriptor;\n\t\tif (typeDescriptor == null) {\n\t\t\ttypeDescriptor = (this.field != null ?\n\t\t\t\t\tnew TypeDescriptor(getResolvableType(), getDependencyType(), getAnnotations()) :\n\t\t\t\t\tnew TypeDescriptor(obtainMethodParameter()));\n\t\t\tthis.typeDescriptor = typeDescriptor;\n\t\t}\n\t\treturn typeDescriptor;\n\t}\n\n\t/**\n\t * Return whether a fallback match is allowed.\n\t * <p>This is {@code false} by default but may be overridden to return {@code true} in order\n\t * to suggest to an {@link org.springframework.beans.factory.support.AutowireCandidateResolver}\n\t * that a fallback match is acceptable as well.\n\t * @since 4.0\n\t */\n\tpublic boolean fallbackMatchAllowed() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Return a variant of this descriptor that is intended for a fallback match.\n\t * @since 4.0\n\t * @see #fallbackMatchAllowed()\n\t */\n\tpublic DependencyDescriptor forFallbackMatch() {\n\t\treturn new DependencyDescriptor(this) {\n\t\t\t@Override\n\t\t\tpublic boolean fallbackMatchAllowed() {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic boolean usesStandardBeanLookup() {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Initialize parameter name discovery for the underlying method parameter, if any.\n\t * <p>This method does not actually try to retrieve the parameter name at\n\t * this point; it just allows discovery to happen when the application calls\n\t * {@link #getDependencyName()} (if ever).\n\t */\n\tpublic void initParameterNameDiscovery(@Nullable ParameterNameDiscoverer parameterNameDiscoverer) {\n\t\tif (this.methodParameter != null) {\n\t\t\tthis.methodParameter.initParameterNameDiscovery(parameterNameDiscoverer);\n\t\t}\n\t}\n\n\t/**\n\t * Determine the name of the wrapped parameter/field.\n\t * @return the declared name (may be {@code null} if unresolvable)\n\t */\n\t@Nullable\n\tpublic String getDependencyName() {\n\t\treturn (this.field != null ? this.field.getName() : obtainMethodParameter().getParameterName());\n\t}\n\n\t/**\n\t * Determine the declared (non-generic) type of the wrapped parameter/field.\n\t * @return the declared type (never {@code null})\n\t */\n\tpublic Class<?> getDependencyType() {\n\t\tif (this.field != null) {\n\t\t\tif (this.nestingLevel > 1) {\n\t\t\t\tClass<?> clazz = getResolvableType().getRawClass();\n\t\t\t\treturn (clazz != null ? clazz : Object.class);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn this.field.getType();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn obtainMethodParameter().getNestedParameterType();\n\t\t}\n\t}\n\n\t/**\n\t * Determine whether this dependency supports lazy resolution,\n\t * e.g. through extra proxying. The default is {@code true}.\n\t * @since 6.1.2\n\t * @see org.springframework.beans.factory.support.AutowireCandidateResolver#getLazyResolutionProxyIfNecessary\n\t */\n\tpublic boolean supportsLazyResolution() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Determine whether this descriptor uses a standard bean lookup\n\t * in {@link #resolveCandidate(String, Class, BeanFactory)} and\n\t * therefore qualifies for factory-level shortcut resolution.\n\t * <p>By default, the {@code DependencyDescriptor} class itself\n\t * uses a standard bean lookup but subclasses may override this.\n\t * If a subclass overrides other methods but preserves a standard\n\t * bean lookup, it may override this method to return {@code true}.\n\t * @since 6.2\n\t * @see #resolveCandidate(String, Class, BeanFactory)\n\t */\n\tpublic boolean usesStandardBeanLookup() {\n\t\treturn (getClass() == DependencyDescriptor.class);\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!super.equals(other)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (other instanceof DependencyDescriptor otherDesc && this.required == otherDesc.required &&\n\t\t\t\tthis.eager == otherDesc.eager && this.nestingLevel == otherDesc.nestingLevel &&\n\t\t\t\tthis.containingClass == otherDesc.containingClass);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn (31 * super.hashCode() + ObjectUtils.nullSafeHashCode(this.containingClass));\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Serialization support\n\t//---------------------------------------------------------------------\n\n\tprivate void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\n\t\t// Rely on default serialization; just initialize state after deserialization.\n\t\tois.defaultReadObject();\n\n\t\t// Restore reflective handles (which are unfortunately not serializable)\n\t\ttry {\n\t\t\tif (this.fieldName != null) {\n\t\t\t\tthis.field = this.declaringClass.getDeclaredField(this.fieldName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (this.methodName != null) {\n\t\t\t\t\tthis.methodParameter = new MethodParameter(\n\t\t\t\t\t\t\tthis.declaringClass.getDeclaredMethod(this.methodName, this.parameterTypes), this.parameterIndex);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.methodParameter = new MethodParameter(\n\t\t\t\t\t\t\tthis.declaringClass.getDeclaredConstructor(this.parameterTypes), this.parameterIndex);\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i < this.nestingLevel; i++) {\n\t\t\t\t\tthis.methodParameter = this.methodParameter.nested();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new IllegalStateException(\"Could not find original class structure\", ex);\n\t\t}\n\t}\n\n\n\t/**\n\t * Inner class to avoid a hard dependency on Kotlin at runtime.\n\t */\n\tprivate static class KotlinDelegate {\n\n\t\t/**\n\t\t * Check whether the specified {@link Field} represents a nullable Kotlin type or not.\n\t\t */\n\t\tpublic static boolean isNullable(Field field) {\n\t\t\tKProperty<?> property = ReflectJvmMapping.getKotlinProperty(field);\n\t\t\treturn (property != null && property.getReturnType().isMarkedNullable());\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#equals(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 409
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!super.equals(other)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (other instanceof DependencyDescriptor otherDesc && this.required == otherDesc.required &&\n\t\t\t\tthis.eager == otherDesc.eager && this.nestingLevel == otherDesc.nestingLevel &&\n\t\t\t\tthis.containingClass == otherDesc.containingClass);\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#fallbackMatchAllowed()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 332
    },
    "return": "boolean",
    "signature": "public boolean fallbackMatchAllowed()",
    "source_code": "\t\t\tpublic boolean fallbackMatchAllowed() {\n\t\t\t\treturn true;\n\t\t\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#forFallbackMatch()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a variant of this descriptor that is intended for a fallback match.\n\t * @since 4.0\n\t * @see #fallbackMatchAllowed()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 329
    },
    "return": "DependencyDescriptor",
    "signature": "public DependencyDescriptor forFallbackMatch()",
    "source_code": "\tpublic DependencyDescriptor forFallbackMatch() {\n\t\treturn new DependencyDescriptor(this) {\n\t\t\t@Override\n\t\t\tpublic boolean fallbackMatchAllowed() {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic boolean usesStandardBeanLookup() {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#getDependencyName()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the name of the wrapped parameter/field.\n\t * @return the declared name (may be {@code null} if unresolvable)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 359
    },
    "return": "String",
    "signature": "public String getDependencyName()",
    "source_code": "\tpublic String getDependencyName() {\n\t\treturn (this.field != null ? this.field.getName() : obtainMethodParameter().getParameterName());\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#getResolvableType()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@link ResolvableType} object for the wrapped parameter/field.\n\t * @since 4.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType getResolvableType()",
    "source_code": "\tpublic ResolvableType getResolvableType() {\n\t\tResolvableType resolvableType = this.resolvableType;\n\t\tif (resolvableType == null) {\n\t\t\tresolvableType = (this.field != null ?\n\t\t\t\t\tResolvableType.forField(this.field, this.nestingLevel, this.containingClass) :\n\t\t\t\t\tResolvableType.forMethodParameter(obtainMethodParameter()));\n\t\t\tthis.resolvableType = resolvableType;\n\t\t}\n\t\treturn resolvableType;\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#getTypeDescriptor()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@link TypeDescriptor} object for the wrapped parameter/field.\n\t * @since 5.1.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getTypeDescriptor()",
    "source_code": "\tpublic TypeDescriptor getTypeDescriptor() {\n\t\tTypeDescriptor typeDescriptor = this.typeDescriptor;\n\t\tif (typeDescriptor == null) {\n\t\t\ttypeDescriptor = (this.field != null ?\n\t\t\t\t\tnew TypeDescriptor(getResolvableType(), getDependencyType(), getAnnotations()) :\n\t\t\t\t\tnew TypeDescriptor(obtainMethodParameter()));\n\t\t\tthis.typeDescriptor = typeDescriptor;\n\t\t}\n\t\treturn typeDescriptor;\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#hashCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 422
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn (31 * super.hashCode() + ObjectUtils.nullSafeHashCode(this.containingClass));\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#increaseNestingLevel()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Increase this descriptor's nesting level.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "void",
    "signature": "public void increaseNestingLevel()",
    "source_code": "\tpublic void increaseNestingLevel() {\n\t\tthis.nestingLevel++;\n\t\tthis.resolvableType = null;\n\t\tif (this.methodParameter != null) {\n\t\t\tthis.methodParameter = this.methodParameter.nested();\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#initParameterNameDiscovery(parameterNameDiscoverer)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize parameter name discovery for the underlying method parameter, if any.\n\t * <p>This method does not actually try to retrieve the parameter name at\n\t * this point; it just allows discovery to happen when the application calls\n\t * {@link #getDependencyName()} (if ever).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterNameDiscoverer"
    ],
    "position": {
      "column": 1,
      "line": 348
    },
    "return": "void",
    "signature": "public void initParameterNameDiscovery(@Nullable ParameterNameDiscoverer parameterNameDiscoverer)",
    "source_code": "\tpublic void initParameterNameDiscovery(@Nullable ParameterNameDiscoverer parameterNameDiscoverer) {\n\t\tif (this.methodParameter != null) {\n\t\t\tthis.methodParameter.initParameterNameDiscovery(parameterNameDiscoverer);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#isEager()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether this dependency is 'eager' in the sense of\n\t * eagerly resolving potential target beans for type matching.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "boolean",
    "signature": "public boolean isEager()",
    "source_code": "\tpublic boolean isEager() {\n\t\treturn this.eager;\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#isNullable(field)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Check whether the specified {@link Field} represents a nullable Kotlin type or not.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field"
    ],
    "position": {
      "column": 1,
      "line": 468
    },
    "return": "boolean",
    "signature": "public boolean isNullable(Field field)",
    "source_code": "\t\tpublic static boolean isNullable(Field field) {\n\t\t\tKProperty<?> property = ReflectJvmMapping.getKotlinProperty(field);\n\t\t\treturn (property != null && property.getReturnType().isMarkedNullable());\n\t\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#isRequired()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether this dependency is required.\n\t * <p>Optional semantics are derived from Java 8's {@link java.util.Optional},\n\t * any variant of a parameter-level {@code Nullable} annotation (such as from\n\t * JSR-305 or the FindBugs set of annotations), or a language-level nullable\n\t * type declaration in Kotlin.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "boolean",
    "signature": "public boolean isRequired()",
    "source_code": "\tpublic boolean isRequired() {\n\t\tif (!this.required) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.field != null) {\n\t\t\treturn !(this.field.getType() == Optional.class || hasNullableAnnotation() ||\n\t\t\t\t\t(KotlinDetector.isKotlinReflectPresent() &&\n\t\t\t\t\t\t\tKotlinDetector.isKotlinType(this.field.getDeclaringClass()) &&\n\t\t\t\t\t\t\tKotlinDelegate.isNullable(this.field)));\n\t\t}\n\t\telse {\n\t\t\treturn !obtainMethodParameter().isOptional();\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#resolveCandidate(beanName,requiredType,beanFactory)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the specified bean name, as a candidate result of the matching\n\t * algorithm for this dependency, to a bean instance from the given factory.\n\t * <p>The default implementation calls {@link BeanFactory#getBean(String)}.\n\t * Subclasses may provide additional arguments or other customizations.\n\t * @param beanName the bean name, as a candidate result for this dependency\n\t * @param requiredType the expected type of the bean (as an assertion)\n\t * @param beanFactory the associated factory\n\t * @return the bean instance (never {@code null})\n\t * @throws BeansException if the bean could not be obtained\n\t * @since 4.3.2\n\t * @see BeanFactory#getBean(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "requiredType",
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "Object",
    "signature": "public Object resolveCandidate(String beanName, Class<?> requiredType, BeanFactory beanFactory)",
    "source_code": "\tpublic Object resolveCandidate(String beanName, Class<?> requiredType, BeanFactory beanFactory)"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#resolveNotUnique(type,Map<String,matchingBeans)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the specified not-unique scenario: by default,\n\t * throwing a {@link NoUniqueBeanDefinitionException}.\n\t * <p>Subclasses may override this to select one of the instances or\n\t * to opt out with no result at all through returning {@code null}.\n\t * @param type the requested bean type\n\t * @param matchingBeans a map of bean names and corresponding bean\n\t * instances which have been pre-selected for the given type\n\t * (qualifiers etc already applied)\n\t * @return a bean instance to proceed with, or {@code null} for none\n\t * @throws BeansException in case of the not-unique scenario being fatal\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "Map<String",
      "matchingBeans"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "Object",
    "signature": "public Object resolveNotUnique(ResolvableType type, Map<String, Object> matchingBeans)",
    "source_code": "\tpublic Object resolveNotUnique(ResolvableType type, Map<String, Object> matchingBeans) throws BeansException {\n\t\tthrow new NoUniqueBeanDefinitionException(type, matchingBeans.keySet());\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#resolveShortcut(beanFactory)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve a shortcut for this dependency against the given factory, for example\n\t * taking some pre-resolved information into account.\n\t * <p>The resolution algorithm will first attempt to resolve a shortcut through this\n\t * method before going into the regular type matching algorithm across all beans.\n\t * Subclasses may override this method to improve resolution performance based on\n\t * pre-cached information while still receiving {@link InjectionPoint} exposure etc.\n\t * @param beanFactory the associated factory\n\t * @return the shortcut result if any, or {@code null} if none\n\t * @throws BeansException if the shortcut could not be obtained\n\t * @since 4.3.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 234
    },
    "return": "Object",
    "signature": "public Object resolveShortcut(BeanFactory beanFactory)",
    "source_code": "\tpublic Object resolveShortcut(BeanFactory beanFactory) throws BeansException {\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#setContainingClass(containingClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Optionally set the concrete class that contains this dependency.\n\t * This may differ from the class that declares the parameter/field in that\n\t * it may be a subclass thereof, potentially substituting type variables.\n\t * @since 4.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "containingClass"
    ],
    "position": {
      "column": 1,
      "line": 275
    },
    "return": "void",
    "signature": "public void setContainingClass(Class<?> containingClass)",
    "source_code": "\tpublic void setContainingClass(Class<?> containingClass) {\n\t\tthis.containingClass = containingClass;\n\t\tthis.resolvableType = null;\n\t\tif (this.methodParameter != null) {\n\t\t\tthis.methodParameter = this.methodParameter.withContainingClass(containingClass);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#supportsLazyResolution()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether this dependency supports lazy resolution,\n\t * e.g. through extra proxying. The default is {@code true}.\n\t * @since 6.1.2\n\t * @see org.springframework.beans.factory.support.AutowireCandidateResolver#getLazyResolutionProxyIfNecessary\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 388
    },
    "return": "boolean",
    "signature": "public boolean supportsLazyResolution()",
    "source_code": "\tpublic boolean supportsLazyResolution() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#usesStandardBeanLookup()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether this descriptor uses a standard bean lookup\n\t * in {@link #resolveCandidate(String, Class, BeanFactory)} and\n\t * therefore qualifies for factory-level shortcut resolution.\n\t * <p>By default, the {@code DependencyDescriptor} class itself\n\t * uses a standard bean lookup but subclasses may override this.\n\t * If a subclass overrides other methods but preserves a standard\n\t * bean lookup, it may override this method to return {@code true}.\n\t * @since 6.2\n\t * @see #resolveCandidate(String, Class, BeanFactory)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 403
    },
    "return": "boolean",
    "signature": "public boolean usesStandardBeanLookup()",
    "source_code": "\tpublic boolean usesStandardBeanLookup() {\n\t\treturn (getClass() == DependencyDescriptor.class);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#usesStandardBeanLookup()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1453
    },
    "return": "boolean",
    "signature": "public boolean usesStandardBeanLookup()",
    "source_code": "\t\tpublic boolean usesStandardBeanLookup() {\n\t\t\treturn true;\n\t\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinition#isBackgroundInit()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the bootstrap mode for this bean: default is {@code false} for using\n\t * the main pre-instantiation thread for non-lazy singleton beans and the caller\n\t * thread for prototype beans.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 606
    },
    "return": "boolean",
    "signature": "public boolean isBackgroundInit()",
    "source_code": "\tpublic boolean isBackgroundInit() {\n\t\treturn this.backgroundInit;\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinition#isDefaultCandidate()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether this bean is a candidate for getting autowired into some other\n\t * bean based on the plain type, without any further indications such as a\n\t * qualifier match?\n\t * <p>The default is {@code true}.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 768
    },
    "return": "boolean",
    "signature": "public boolean isDefaultCandidate()",
    "source_code": "\tpublic boolean isDefaultCandidate() {\n\t\treturn this.defaultCandidate;\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinition#isFallback()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p>The default is {@code false}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 804
    },
    "return": "boolean",
    "signature": "public boolean isFallback()",
    "source_code": "\tpublic boolean isFallback() {\n\t\treturn this.fallback;\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinition#setBackgroundInit(backgroundInit)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the bootstrap mode for this bean: default is {@code false} for using\n\t * the main pre-instantiation thread for non-lazy singleton beans and the caller\n\t * thread for prototype beans.\n\t * <p>Set this flag to {@code true} to allow for instantiating this bean on a\n\t * background thread. For a non-lazy singleton, a background pre-instantiation\n\t * thread can be used then, while still enforcing the completion at the end of\n\t * {@link DefaultListableBeanFactory#preInstantiateSingletons()}.\n\t * For a lazy singleton, a background pre-instantiation thread can be used as well\n\t * - with completion allowed at a later point, enforcing it when actually accessed.\n\t * <p>Note that this flag may be ignored by bean factories not set up for\n\t * background bootstrapping, always applying single-threaded bootstrapping\n\t * for non-lazy singleton beans.\n\t * @since 6.2\n\t * @see #setLazyInit\n\t * @see DefaultListableBeanFactory#setBootstrapExecutor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "backgroundInit"
    ],
    "position": {
      "column": 1,
      "line": 596
    },
    "return": "void",
    "signature": "public void setBackgroundInit(boolean backgroundInit)",
    "source_code": "\tpublic void setBackgroundInit(boolean backgroundInit) {\n\t\tthis.backgroundInit = backgroundInit;\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinition#setDefaultCandidate(defaultCandidate)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether this bean is a candidate for getting autowired into some other\n\t * bean based on the plain type, without any further indications such as a\n\t * qualifier match.\n\t * <p>The default is {@code true}, allowing injection by type at any injection point.\n\t * Switch this to {@code false} in order to restrict injection by default,\n\t * effectively enforcing an additional indication such as a qualifier match.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultCandidate"
    ],
    "position": {
      "column": 1,
      "line": 757
    },
    "return": "void",
    "signature": "public void setDefaultCandidate(boolean defaultCandidate)",
    "source_code": "\tpublic void setDefaultCandidate(boolean defaultCandidate) {\n\t\tthis.defaultCandidate = defaultCandidate;\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinition#setFallback(fallback)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p>The default is {@code false}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fallback"
    ],
    "position": {
      "column": 1,
      "line": 795
    },
    "return": "void",
    "signature": "public void setFallback(boolean fallback)",
    "source_code": "\tpublic void setFallback(boolean fallback) {\n\t\tthis.fallback = fallback;\n\t}"
  },
  "org.springframework.beans.factory.support.DefaultListableBeanFactory#checkMergedBeanDefinition(mbd,beanName,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mbd",
      "beanName",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 983
    },
    "return": "void",
    "signature": "protected void checkMergedBeanDefinition(RootBeanDefinition mbd, String beanName, @Nullable Object[] args)",
    "source_code": "\tprotected void checkMergedBeanDefinition(RootBeanDefinition mbd, String beanName, @Nullable Object[] args) {\n\t\tsuper.checkMergedBeanDefinition(mbd, beanName, args);\n\n\t\tif (mbd.isBackgroundInit()) {\n\t\t\tif (this.preInstantiationThread.get() == PreInstantiation.MAIN && getBootstrapExecutor() != null) {\n\t\t\t\tthrow new BeanCurrentlyInCreationException(beanName, \"Bean marked for background \" +\n\t\t\t\t\t\t\"initialization but requested in mainline thread - declare ObjectProvider \" +\n\t\t\t\t\t\t\"or lazy injection point in dependent mainline beans\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Bean intended to be initialized in main bootstrap thread\n\t\t\tif (this.preInstantiationThread.get() == PreInstantiation.BACKGROUND) {\n\t\t\t\tthrow new BeanCurrentlyInCreationException(beanName, \"Bean marked for mainline initialization \" +\n\t\t\t\t\t\t\"but requested in background thread - enforce early instantiation in mainline thread \" +\n\t\t\t\t\t\t\"through depends-on '\" + beanName + \"' declaration for dependent background beans\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.DefaultListableBeanFactory#getBootstrapExecutor()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "Executor",
    "signature": "public Executor getBootstrapExecutor()",
    "source_code": "\tpublic Executor getBootstrapExecutor() {\n\t\treturn this.bootstrapExecutor;\n\t}"
  },
  "org.springframework.beans.factory.support.DefaultListableBeanFactory#isCurrentThreadAllowedToHoldSingletonLock()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1004
    },
    "return": "boolean",
    "signature": "protected boolean isCurrentThreadAllowedToHoldSingletonLock()",
    "source_code": "\tprotected boolean isCurrentThreadAllowedToHoldSingletonLock() {\n\t\treturn (this.preInstantiationThread.get() != PreInstantiation.BACKGROUND);\n\t}"
  },
  "org.springframework.beans.factory.support.DefaultListableBeanFactory#setBootstrapExecutor(bootstrapExecutor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bootstrapExecutor"
    ],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "void",
    "signature": "public void setBootstrapExecutor(@Nullable Executor bootstrapExecutor)",
    "source_code": "\tpublic void setBootstrapExecutor(@Nullable Executor bootstrapExecutor) {\n\t\tthis.bootstrapExecutor = bootstrapExecutor;\n\t}"
  },
  "org.springframework.beans.factory.support.DefaultListableBeanFactory#usesStandardBeanLookup()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 2399
    },
    "return": "boolean",
    "signature": "public boolean usesStandardBeanLookup()",
    "source_code": "\t\t\t\tpublic boolean usesStandardBeanLookup() {\n\t\t\t\t\treturn true;\n\t\t\t\t}"
  },
  "org.springframework.cache.annotation.AnnotationCacheOperationSource#setPublicMethodsOnly(publicMethodsOnly)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether cacheable methods are expected to be public.\n\t * <p>The default is {@code true}.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "publicMethodsOnly"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "void",
    "signature": "public void setPublicMethodsOnly(boolean publicMethodsOnly)",
    "source_code": "\tpublic void setPublicMethodsOnly(boolean publicMethodsOnly) {\n\t\tthis.publicMethodsOnly = publicMethodsOnly;\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.<unknown>#equals(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other || (other instanceof JCacheOperationSourceClassFilter that &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(getCacheOperationSource(), that.getCacheOperationSource())));\n\t\t}"
  },
  "org.springframework.cache.jcache.interceptor.<unknown>#hashCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\t\tpublic int hashCode() {\n\t\t\treturn JCacheOperationSourceClassFilter.class.hashCode();\n\t\t}"
  },
  "org.springframework.cache.jcache.interceptor.<unknown>#matches(clazz)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "boolean",
    "signature": "public boolean matches(Class<?> clazz)",
    "source_code": "\t\tpublic boolean matches(Class<?> clazz) {\n\t\t\tif (CacheManager.class.isAssignableFrom(clazz)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn (cacheOperationSource == null || cacheOperationSource.isCandidateClass(clazz));\n\t\t}"
  },
  "org.springframework.cache.jcache.interceptor.<unknown>#matches(method,targetClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\treturn (this.cacheOperationSource == null ||\n\t\t\t\tthis.cacheOperationSource.hasCacheOperation(method, targetClass));\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.<unknown>#setCacheOperationSource(cacheOperationSource)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cacheOperationSource"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "return": "void",
    "signature": "public void setCacheOperationSource(@Nullable JCacheOperationSource cacheOperationSource)",
    "source_code": "\tpublic void setCacheOperationSource(@Nullable JCacheOperationSource cacheOperationSource) {\n\t\tthis.cacheOperationSource = cacheOperationSource;\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.<unknown>#toString()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn JCacheOperationSourceClassFilter.class.getName() + \": \" + getCacheOperationSource();\n\t\t}"
  },
  "org.springframework.cache.jcache.interceptor.BeanFactoryJCacheOperationSourceAdvisor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Advisor driven by a {@link JCacheOperationSource}, used to include a\n * cache advice bean for methods that are cacheable.\n *\n * @author Stephane Nicoll\n * @author Juergen Hoeller\n * @since 4.1\n * @see #setAdviceBeanName\n * @see JCacheInterceptor\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 40
    },
    "signature": "public class BeanFactoryJCacheOperationSourceAdvisor",
    "source_code": "public class BeanFactoryJCacheOperationSourceAdvisor extends AbstractBeanFactoryPointcutAdvisor {\n\n\tprivate final JCacheOperationSourcePointcut pointcut = new JCacheOperationSourcePointcut();\n\n\n\t/**\n\t * Set the cache operation attribute source which is used to find cache\n\t * attributes. This should usually be identical to the source reference\n\t * set on the cache interceptor itself.\n\t * @see JCacheInterceptor#setCacheOperationSource\n\t */\n\tpublic void setCacheOperationSource(JCacheOperationSource cacheOperationSource) {\n\t\tthis.pointcut.setCacheOperationSource(cacheOperationSource);\n\t}\n\n\t/**\n\t * Set the {@link org.springframework.aop.ClassFilter} to use for this pointcut.\n\t * Default is {@link org.springframework.aop.ClassFilter#TRUE}.\n\t */\n\tpublic void setClassFilter(ClassFilter classFilter) {\n\t\tthis.pointcut.setClassFilter(classFilter);\n\t}\n\n\t@Override\n\tpublic Pointcut getPointcut() {\n\t\treturn this.pointcut;\n\t}\n\n\n\tprivate static class JCacheOperationSourcePointcut extends StaticMethodMatcherPointcut implements Serializable {\n\n\t\t@Nullable\n\t\tprivate JCacheOperationSource cacheOperationSource;\n\n\t\tpublic void setCacheOperationSource(@Nullable JCacheOperationSource cacheOperationSource) {\n\t\t\tthis.cacheOperationSource = cacheOperationSource;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\t\treturn (this.cacheOperationSource == null ||\n\t\t\t\t\tthis.cacheOperationSource.getCacheOperation(method, targetClass) != null);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other || (other instanceof JCacheOperationSourcePointcut that &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.cacheOperationSource, that.cacheOperationSource)));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn JCacheOperationSourcePointcut.class.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn getClass().getName() + \": \" + this.cacheOperationSource;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.cache.jcache.interceptor.BeanFactoryJCacheOperationSourceAdvisor#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other || (other instanceof JCacheOperationSourcePointcut that &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.cacheOperationSource, that.cacheOperationSource)));\n\t\t}"
  },
  "org.springframework.cache.jcache.interceptor.BeanFactoryJCacheOperationSourceAdvisor#getPointcut()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "Pointcut",
    "signature": "public Pointcut getPointcut()",
    "source_code": "\tpublic Pointcut getPointcut() {\n\t\treturn this.pointcut;\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.BeanFactoryJCacheOperationSourceAdvisor#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\t\tpublic int hashCode() {\n\t\t\treturn JCacheOperationSourcePointcut.class.hashCode();\n\t\t}"
  },
  "org.springframework.cache.jcache.interceptor.BeanFactoryJCacheOperationSourceAdvisor#matches(method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\t\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\t\treturn (this.cacheOperationSource == null ||\n\t\t\t\t\tthis.cacheOperationSource.getCacheOperation(method, targetClass) != null);\n\t\t}"
  },
  "org.springframework.cache.jcache.interceptor.BeanFactoryJCacheOperationSourceAdvisor#setCacheOperationSource(cacheOperationSource)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cacheOperationSource"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "public void setCacheOperationSource(@Nullable JCacheOperationSource cacheOperationSource)",
    "source_code": "\t\tpublic void setCacheOperationSource(@Nullable JCacheOperationSource cacheOperationSource) {\n\t\t\tthis.cacheOperationSource = cacheOperationSource;\n\t\t}"
  },
  "org.springframework.cache.jcache.interceptor.BeanFactoryJCacheOperationSourceAdvisor#setClassFilter(classFilter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link org.springframework.aop.ClassFilter} to use for this pointcut.\n\t * Default is {@link org.springframework.aop.ClassFilter#TRUE}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classFilter"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "void",
    "signature": "public void setClassFilter(ClassFilter classFilter)",
    "source_code": "\tpublic void setClassFilter(ClassFilter classFilter) {\n\t\tthis.pointcut.setClassFilter(classFilter);\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.BeanFactoryJCacheOperationSourceAdvisor#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn getClass().getName() + \": \" + this.cacheOperationSource;\n\t\t}"
  },
  "org.springframework.cache.jcache.interceptor.JCacheOperationSourcePointcut": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A {@code Pointcut} that matches if the underlying {@link JCacheOperationSource}\n * has an operation for a given method.\n *\n * @author Stephane Nicoll\n * @since 4.1\n * @deprecated since 6.0.10, as it is not used by the framework anymore\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 36
    },
    "signature": "public class JCacheOperationSourcePointcut",
    "source_code": "public abstract class JCacheOperationSourcePointcut extends StaticMethodMatcherPointcut implements Serializable {\n\n\t@Override\n\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\tJCacheOperationSource cas = getCacheOperationSource();\n\t\treturn (cas != null && cas.getCacheOperation(method, targetClass) != null);\n\t}\n\n\t/**\n\t * Obtain the underlying {@link JCacheOperationSource} (may be {@code null}).\n\t * To be implemented by subclasses.\n\t */\n\t@Nullable\n\tprotected abstract JCacheOperationSource getCacheOperationSource();\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof JCacheOperationSourcePointcut that &&\n\t\t\t\tObjectUtils.nullSafeEquals(getCacheOperationSource(), that.getCacheOperationSource())));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn JCacheOperationSourcePointcut.class.hashCode();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getClass().getName() + \": \" + getCacheOperationSource();\n\t}\n\n}"
  },
  "org.springframework.cache.jcache.interceptor.JCacheOperationSourcePointcut#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof JCacheOperationSourcePointcut that &&\n\t\t\t\tObjectUtils.nullSafeEquals(getCacheOperationSource(), that.getCacheOperationSource())));\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.JCacheOperationSourcePointcut#getCacheOperationSource()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain the underlying {@link JCacheOperationSource} (may be {@code null}).\n\t * To be implemented by subclasses.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 49
    },
    "return": "JCacheOperationSource",
    "signature": "protected JCacheOperationSource getCacheOperationSource()",
    "source_code": "\tprotected abstract JCacheOperationSource getCacheOperationSource();"
  },
  "org.springframework.cache.jcache.interceptor.JCacheOperationSourcePointcut#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn JCacheOperationSourcePointcut.class.hashCode();\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.JCacheOperationSourcePointcut#matches(method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\tJCacheOperationSource cas = getCacheOperationSource();\n\t\treturn (cas != null && cas.getCacheOperation(method, targetClass) != null);\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.JCacheOperationSourcePointcut#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn getClass().getName() + \": \" + getCacheOperationSource();\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#add(deferredImport)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "deferredImport"
    ],
    "position": {
      "column": 1,
      "line": 803
    },
    "return": "void",
    "signature": "public void add(DeferredImportSelectorHolder deferredImport)",
    "source_code": "\t\tpublic void add(DeferredImportSelectorHolder deferredImport) {\n\t\t\tthis.deferredImports.add(deferredImport);\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#getCandidateFilter()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 819
    },
    "return": "Predicate<String>",
    "signature": "public Predicate<String> getCandidateFilter()",
    "source_code": "\t\tpublic Predicate<String> getCandidateFilter() {\n\t\t\tPredicate<String> mergedFilter = DEFAULT_EXCLUSION_FILTER;\n\t\t\tfor (DeferredImportSelectorHolder deferredImport : this.deferredImports) {\n\t\t\t\tPredicate<String> selectorFilter = deferredImport.getImportSelector().getExclusionFilter();\n\t\t\t\tif (selectorFilter != null) {\n\t\t\t\t\tmergedFilter = mergedFilter.or(selectorFilter);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn mergedFilter;\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#getConfigurationClass()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 783
    },
    "return": "ConfigurationClass",
    "signature": "public ConfigurationClass getConfigurationClass()",
    "source_code": "\t\tpublic ConfigurationClass getConfigurationClass() {\n\t\t\treturn this.configurationClass;\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#getConfigurationClasses()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "Set<ConfigurationClass>",
    "signature": "public Set<ConfigurationClass> getConfigurationClasses()",
    "source_code": "\tpublic Set<ConfigurationClass> getConfigurationClasses() {\n\t\treturn this.configurationClasses.keySet();\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#getImportSelector()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 787
    },
    "return": "DeferredImportSelector",
    "signature": "public DeferredImportSelector getImportSelector()",
    "source_code": "\t\tpublic DeferredImportSelector getImportSelector() {\n\t\t\treturn this.importSelector;\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#handle(configClass,importSelector)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Handle the specified {@link DeferredImportSelector}. If deferred import\n\t\t * selectors are being collected, this registers this instance to the list. If\n\t\t * they are being processed, the {@link DeferredImportSelector} is also processed\n\t\t * immediately according to its {@link DeferredImportSelector.Group}.\n\t\t * @param configClass the source configuration class\n\t\t * @param importSelector the selector to handle\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "configClass",
      "importSelector"
    ],
    "position": {
      "column": 1,
      "line": 694
    },
    "return": "void",
    "signature": "public void handle(ConfigurationClass configClass, DeferredImportSelector importSelector)",
    "source_code": "\t\tpublic void handle(ConfigurationClass configClass, DeferredImportSelector importSelector) {\n\t\t\tDeferredImportSelectorHolder holder = new DeferredImportSelectorHolder(configClass, importSelector);\n\t\t\tif (this.deferredImportSelectors == null) {\n\t\t\t\tDeferredImportSelectorGroupingHandler handler = new DeferredImportSelectorGroupingHandler();\n\t\t\t\thandler.register(holder);\n\t\t\t\thandler.processGroupImports();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.deferredImportSelectors.add(holder);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#parse(className,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "className",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "void",
    "signature": "protected void parse(@Nullable String className, String beanName)",
    "source_code": "\tprotected final void parse(@Nullable String className, String beanName) throws IOException {\n\t\tAssert.notNull(className, \"No bean class name for configuration class bean definition\");\n\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(className);\n\t\tprocessConfigurationClass(new ConfigurationClass(reader, beanName), DEFAULT_EXCLUSION_FILTER);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#parse(clazz,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "void",
    "signature": "protected void parse(Class<?> clazz, String beanName)",
    "source_code": "\tprotected final void parse(Class<?> clazz, String beanName) throws IOException {\n\t\tprocessConfigurationClass(new ConfigurationClass(clazz, beanName), DEFAULT_EXCLUSION_FILTER);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#parse(metadata,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "metadata",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "void",
    "signature": "protected void parse(AnnotationMetadata metadata, String beanName)",
    "source_code": "\tprotected final void parse(AnnotationMetadata metadata, String beanName) throws IOException {\n\t\tprocessConfigurationClass(new ConfigurationClass(metadata, beanName), DEFAULT_EXCLUSION_FILTER);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#process()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 706
    },
    "return": "void",
    "signature": "public void process()",
    "source_code": "\t\tpublic void process() {\n\t\t\tList<DeferredImportSelectorHolder> deferredImports = this.deferredImportSelectors;\n\t\t\tthis.deferredImportSelectors = null;\n\t\t\ttry {\n\t\t\t\tif (deferredImports != null) {\n\t\t\t\t\tDeferredImportSelectorGroupingHandler handler = new DeferredImportSelectorGroupingHandler();\n\t\t\t\t\tdeferredImports.sort(DEFERRED_IMPORT_COMPARATOR);\n\t\t\t\t\tdeferredImports.forEach(handler::register);\n\t\t\t\t\thandler.processGroupImports();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.deferredImportSelectors = new ArrayList<>();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#processGroupImports()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 740
    },
    "return": "void",
    "signature": "public void processGroupImports()",
    "source_code": "\t\tpublic void processGroupImports() {\n\t\t\tfor (DeferredImportSelectorGrouping grouping : this.groupings.values()) {\n\t\t\t\tPredicate<String> exclusionFilter = grouping.getCandidateFilter();\n\t\t\t\tgrouping.getImports().forEach(entry -> {\n\t\t\t\t\tConfigurationClass configurationClass = this.configurationClasses.get(entry.getMetadata());\n\t\t\t\t\ttry {\n\t\t\t\t\t\tprocessImports(configurationClass, asSourceClass(configurationClass, exclusionFilter),\n\t\t\t\t\t\t\t\tCollections.singleton(asSourceClass(entry.getImportClassName(), exclusionFilter)),\n\t\t\t\t\t\t\t\texclusionFilter, false);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (BeanDefinitionStoreException ex) {\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tthrow new BeanDefinitionStoreException(\n\t\t\t\t\t\t\t\t\"Failed to process import candidates for configuration class [\" +\n\t\t\t\t\t\t\t\t\t\tconfigurationClass.getMetadata().getClassName() + \"]\", ex);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#register(deferredImport)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "deferredImport"
    ],
    "position": {
      "column": 1,
      "line": 730
    },
    "return": "void",
    "signature": "public void register(DeferredImportSelectorHolder deferredImport)",
    "source_code": "\t\tpublic void register(DeferredImportSelectorHolder deferredImport) {\n\t\t\tClass<? extends Group> group = deferredImport.getImportSelector().getImportGroup();\n\t\t\tDeferredImportSelectorGrouping grouping = this.groupings.computeIfAbsent(\n\t\t\t\t\t(group != null ? group : deferredImport),\n\t\t\t\t\tkey -> new DeferredImportSelectorGrouping(createGroup(group)));\n\t\t\tgrouping.add(deferredImport);\n\t\t\tthis.configurationClasses.put(deferredImport.getConfigurationClass().getMetadata(),\n\t\t\t\t\tdeferredImport.getConfigurationClass());\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerImport(importingClass,importedClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "importingClass",
      "importedClass"
    ],
    "position": {
      "column": 1,
      "line": 639
    },
    "return": "void",
    "signature": "public void registerImport(AnnotationMetadata importingClass, String importedClass)",
    "source_code": "\t\tpublic void registerImport(AnnotationMetadata importingClass, String importedClass) {\n\t\t\tthis.imports.add(importedClass, importingClass);\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#validate()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Validate each {@link ConfigurationClass} object.\n\t * @see ConfigurationClass#validate\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "void",
    "signature": "public void validate()",
    "source_code": "\tpublic void validate() {\n\t\tfor (ConfigurationClass configClass : this.configurationClasses.keySet()) {\n\t\t\tconfigClass.validate(this.problemReporter);\n\t\t}\n\t}"
  },
  "org.springframework.context.event.ApplicationListenerMethodAdapter#isDefaultExecution()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether default execution is applicable for the target listener.\n\t * @since 6.2\n\t * @see #onApplicationEvent\n\t * @see EventListener#defaultExecution()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "boolean",
    "signature": "protected boolean isDefaultExecution()",
    "source_code": "\tprotected boolean isDefaultExecution() {\n\t\treturn this.defaultExecution;\n\t}"
  },
  "org.springframework.context.support.AbstractApplicationContext#clearResourceCaches()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1033
    },
    "return": "void",
    "signature": "public void clearResourceCaches()",
    "source_code": "\tpublic void clearResourceCaches() {\n\t\tsuper.clearResourceCaches();\n\t\tif (this.resourcePatternResolver instanceof PathMatchingResourcePatternResolver pmrpr) {\n\t\t\tpmrpr.clearCache();\n\t\t}\n\t}"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#setTimeoutForShutdownPhase(phase,timeout)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the maximum time allotted for the shutdown of a specific phase\n\t * (group of {@link SmartLifecycle} beans with the same 'phase' value).\n\t * <p>In case of no specific timeout configured, the default timeout per\n\t * shutdown phase will apply: 10000 milliseconds (10 seconds) as of 6.2.\n\t * @param phase the phase value (matching {@link SmartLifecycle#getPhase()})\n\t * @param timeout the corresponding timeout value (in milliseconds)\n\t * @since 6.2\n\t * @see SmartLifecycle#getPhase()\n\t * @see #setTimeoutPerShutdownPhase\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "phase",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "void",
    "signature": "public void setTimeoutForShutdownPhase(int phase, long timeout)",
    "source_code": "\tpublic void setTimeoutForShutdownPhase(int phase, long timeout) {\n\t\tthis.timeoutsForShutdownPhases.put(phase, timeout);\n\t}"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#setTimeoutsForShutdownPhases(Map<Integer,timeoutsForShutdownPhases)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the maximum time allotted for the shutdown of each given phase\n\t * (group of {@link SmartLifecycle} beans with the same 'phase' value).\n\t * <p>In case of no specific timeout configured, the default timeout per\n\t * shutdown phase will apply: 10000 milliseconds (10 seconds) as of 6.2.\n\t * @param timeoutsForShutdownPhases a map of phase values (matching\n\t * {@link SmartLifecycle#getPhase()}) and corresponding timeout values\n\t * (in milliseconds)\n\t * @since 6.2\n\t * @see SmartLifecycle#getPhase()\n\t * @see #setTimeoutPerShutdownPhase\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Integer",
      "timeoutsForShutdownPhases"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "void",
    "signature": "public void setTimeoutsForShutdownPhases(Map<Integer, Long> timeoutsForShutdownPhases)",
    "source_code": "\tpublic void setTimeoutsForShutdownPhases(Map<Integer, Long> timeoutsForShutdownPhases) {\n\t\tthis.timeoutsForShutdownPhases.putAll(timeoutsForShutdownPhases);\n\t}"
  },
  "org.springframework.core.ResolvableType#isAssignableFrom(type,Map<Type,matchedBefore)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return {@code true} if these bounds are assignable from the specified type.\n\t\t * @param type the type to test against\n\t\t * @return {@code true} if these bounds are assignable from the type\n\t\t * @since 6.2\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "Map<Type",
      "matchedBefore"
    ],
    "position": {
      "column": 1,
      "line": 1726
    },
    "return": "boolean",
    "signature": "public boolean isAssignableFrom(ResolvableType type, @Nullable Map<Type, Type> matchedBefore)",
    "source_code": "\t\tpublic boolean isAssignableFrom(ResolvableType type, @Nullable Map<Type, Type> matchedBefore) {\n\t\t\tfor (ResolvableType bound : this.bounds) {\n\t\t\t\tif (this.kind == Kind.UPPER ? !bound.isAssignableFrom(type, false, matchedBefore, false) :\n\t\t\t\t\t\t!type.isAssignableFrom(bound, false, matchedBefore, false)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}"
  },
  "org.springframework.core.ResolvableType#isAssignableFrom(types)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return {@code true} if this bounds is assignable to all the specified types.\n\t\t * @param types the types to test against\n\t\t * @return {@code true} if this bounds is assignable to all types\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "types"
    ],
    "position": {
      "column": 1,
      "line": 1659
    },
    "return": "boolean",
    "signature": "public boolean isAssignableFrom(ResolvableType... types)",
    "source_code": "\t\tpublic boolean isAssignableFrom(ResolvableType... types) {\n\t\t\tfor (ResolvableType bound : this.bounds) {\n\t\t\t\tfor (ResolvableType type : types) {\n\t\t\t\t\tif (!isAssignable(bound, type)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}"
  },
  "org.springframework.core.ResolvableType#isAssignableFrom(types,Map<Type,matchedBefore)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return {@code true} if these bounds are assignable from all the specified types.\n\t\t * @param types the types to test against\n\t\t * @return {@code true} if these bounds are assignable from all types\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "types",
      "Map<Type",
      "matchedBefore"
    ],
    "position": {
      "column": 1,
      "line": 1711
    },
    "return": "boolean",
    "signature": "public boolean isAssignableFrom(ResolvableType[] types, @Nullable Map<Type, Type> matchedBefore)",
    "source_code": "\t\tpublic boolean isAssignableFrom(ResolvableType[] types, @Nullable Map<Type, Type> matchedBefore) {\n\t\t\tfor (ResolvableType type : types) {\n\t\t\t\tif (!isAssignableFrom(type, matchedBefore)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}"
  },
  "org.springframework.core.ResolvableType#isAssignableFromResolvedPart(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether this {@code ResolvableType} is assignable from the\n\t * specified other type, as far as the other type is actually resolvable.\n\t * @param other the type to be checked against (as a {@code ResolvableType})\n\t * @return {@code true} if the specified other type can be assigned to this\n\t * {@code ResolvableType} as far as it is resolvable; {@code false} otherwise\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "boolean",
    "signature": "public boolean isAssignableFromResolvedPart(ResolvableType other)",
    "source_code": "\tpublic boolean isAssignableFromResolvedPart(ResolvableType other) {\n\t\treturn isAssignableFrom(other, false, null, true);\n\t}"
  },
  "org.springframework.core.ResolvableType#isAssignableTo(type,Map<Type,matchedBefore)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return {@code true} if these bounds are assignable to the specified type.\n\t\t * @param type the type to test against\n\t\t * @return {@code true} if these bounds are assignable to the type\n\t\t * @since 6.2\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "Map<Type",
      "matchedBefore"
    ],
    "position": {
      "column": 1,
      "line": 1742
    },
    "return": "boolean",
    "signature": "public boolean isAssignableTo(ResolvableType type, @Nullable Map<Type, Type> matchedBefore)",
    "source_code": "\t\tpublic boolean isAssignableTo(ResolvableType type, @Nullable Map<Type, Type> matchedBefore) {\n\t\t\tif (this.kind == Kind.UPPER) {\n\t\t\t\tfor (ResolvableType bound : this.bounds) {\n\t\t\t\t\tif (type.isAssignableFrom(bound, false, matchedBefore, false)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn (type.resolve() == Object.class);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.core.io.support.PathMatchingResourcePatternResolver#clearCache()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Clear the local resource cache, removing all cached classpath/jar structures.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 369
    },
    "return": "void",
    "signature": "public void clearCache()",
    "source_code": "\tpublic void clearCache() {\n\t\tthis.rootDirCache.clear();\n\t\tthis.jarEntryCache.clear();\n\t}"
  },
  "org.springframework.docs.integration.jms.jmsreceivingasync.ExampleListener": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 25
    },
    "signature": "public class ExampleListener",
    "source_code": "public class ExampleListener implements MessageListener {\n\n\tpublic void onMessage(Message message) {\n\t\tif (message instanceof TextMessage textMessage) {\n\t\t\ttry {\n\t\t\t\tSystem.out.println(textMessage.getText());\n\t\t\t}\n\t\t\tcatch (JMSException ex) {\n\t\t\t\tthrow new RuntimeException(ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Message must be of type TextMessage\");\n\t\t}\n\t}\n}"
  },
  "org.springframework.docs.integration.jms.jmsreceivingasync.ExampleListener#onMessage(message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 27
    },
    "return": "void",
    "signature": "public void onMessage(Message message)",
    "source_code": "\tpublic void onMessage(Message message) {\n\t\tif (message instanceof TextMessage textMessage) {\n\t\t\ttry {\n\t\t\t\tSystem.out.println(textMessage.getText());\n\t\t\t}\n\t\t\tcatch (JMSException ex) {\n\t\t\t\tthrow new RuntimeException(ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Message must be of type TextMessage\");\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#generateCodeForArgument(methodVisitor,argument,requiredType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate bytecode that loads the supplied argument onto the stack.\n\t * <p>Delegates to {@link #generateCodeForArgument(MethodVisitor, SpelNode, String)}\n\t * with the {@linkplain #toDescriptor(Class) descriptor} for\n\t * the supplied {@code requiredType}.\n\t * <p>This method also performs any boxing, unboxing, or check-casting\n\t * necessary to ensure that the type of the argument on the stack matches the\n\t * supplied {@code requiredType}.\n\t * <p>Use this method when a node in the AST will be used as an argument for\n\t * a constructor or method invocation. For example, if you wish to invoke a\n\t * method with an {@code indexNode} that must be of type {@code int} for the\n\t * actual method invocation within bytecode, you would call\n\t * {@code codeFlow.generateCodeForArgument(methodVisitor, indexNode, int.class)}.\n\t * @param methodVisitor the ASM {@link MethodVisitor} into which code should\n\t * be generated\n\t * @param argument a {@link SpelNode} that represents an argument to a method\n\t * or constructor\n\t * @param requiredType the required type for the argument when invoking the\n\t * corresponding constructor or method\n\t * @since 6.2\n\t * @see #generateCodeForArgument(MethodVisitor, SpelNode, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodVisitor",
      "argument",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 270
    },
    "return": "void",
    "signature": "public void generateCodeForArgument(MethodVisitor methodVisitor, SpelNode argument, Class<?> requiredType)",
    "source_code": "\tpublic void generateCodeForArgument(MethodVisitor methodVisitor, SpelNode argument, Class<?> requiredType) {\n\t\tgenerateCodeForArgument(methodVisitor, argument, toDescriptor(requiredType));\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#generateCodeForArgument(methodVisitor,argument,requiredTypeDesc)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate bytecode that loads the supplied argument onto the stack.\n\t * <p>This method also performs any boxing, unboxing, or check-casting\n\t * necessary to ensure that the type of the argument on the stack matches the\n\t * supplied {@code requiredTypeDesc}.\n\t * <p>Use this method when a node in the AST will be used as an argument for\n\t * a constructor or method invocation. For example, if you wish to invoke a\n\t * method with an {@code indexNode} that must be of type {@code int} for the\n\t * actual method invocation within bytecode, you would call\n\t * {@code codeFlow.generateCodeForArgument(methodVisitor, indexNode, \"I\")}.\n\t * @param methodVisitor the ASM {@link MethodVisitor} into which code should\n\t * be generated\n\t * @param argument a {@link SpelNode} that represents an argument to a method\n\t * or constructor\n\t * @param requiredTypeDesc a descriptor for the required type for the argument\n\t * when invoking the corresponding constructor or method\n\t * @since 6.2\n\t * @see #generateCodeForArgument(MethodVisitor, SpelNode, Class)\n\t * @see #toDescriptor(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodVisitor",
      "argument",
      "requiredTypeDesc"
    ],
    "position": {
      "column": 1,
      "line": 294
    },
    "return": "void",
    "signature": "public void generateCodeForArgument(MethodVisitor methodVisitor, SpelNode argument, String requiredTypeDesc)",
    "source_code": "\tpublic void generateCodeForArgument(MethodVisitor methodVisitor, SpelNode argument, String requiredTypeDesc) {\n\t\tenterCompilationScope();\n\t\targument.generateCode(methodVisitor, this);\n\t\tString lastDesc = lastDescriptor();\n\t\tAssert.state(lastDesc != null, \"No last descriptor\");\n\t\tboolean primitiveOnStack = isPrimitive(lastDesc);\n\t\t// Check if we need to box it.\n\t\tif (primitiveOnStack && requiredTypeDesc.charAt(0) == 'L') {\n\t\t\tinsertBoxIfNecessary(methodVisitor, lastDesc.charAt(0));\n\t\t}\n\t\t// Check if we need to unbox it.\n\t\telse if (requiredTypeDesc.length() == 1 && !primitiveOnStack) {\n\t\t\tinsertUnboxInsns(methodVisitor, requiredTypeDesc.charAt(0), lastDesc);\n\t\t}\n\t\t// Check if we need to check-cast\n\t\telse if (!requiredTypeDesc.equals(lastDesc)) {\n\t\t\t// This would be unnecessary in the case of subtyping (e.g. method takes Number but Integer passed in)\n\t\t\tinsertCheckCast(methodVisitor, requiredTypeDesc);\n\t\t}\n\t\texitCompilationScope();\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#insertArrayStore(mv,arrayComponentType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Produce appropriate bytecode to store a stack item in an array.\n\t * <p>The instruction to use varies depending on whether the type is a\n\t * primitive or reference type.\n\t * @param mv where to insert the bytecode\n\t * @param arrayComponentType the component type of the array\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "arrayComponentType"
    ],
    "position": {
      "column": 1,
      "line": 980
    },
    "return": "void",
    "signature": "public void insertArrayStore(MethodVisitor mv, String arrayComponentType)",
    "source_code": "\tpublic static void insertArrayStore(MethodVisitor mv, String arrayComponentType) {\n\t\tif (arrayComponentType.length() == 1) {\n\t\t\tchar componentType = arrayComponentType.charAt(0);\n\t\t\tswitch (componentType) {\n\t\t\t\tcase 'B', 'Z' -> mv.visitInsn(BASTORE);\n\t\t\t\tcase 'I' -> mv.visitInsn(IASTORE);\n\t\t\t\tcase 'J' -> mv.visitInsn(LASTORE);\n\t\t\t\tcase 'F' -> mv.visitInsn(FASTORE);\n\t\t\t\tcase 'D' -> mv.visitInsn(DASTORE);\n\t\t\t\tcase 'C' -> mv.visitInsn(CASTORE);\n\t\t\t\tcase 'S' -> mv.visitInsn(SASTORE);\n\t\t\t\tdefault -> throw new IllegalArgumentException(\"Unexpected array component type \" + componentType);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tmv.visitInsn(AASTORE);\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#insertArrayStore(mv,arrayElementType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Produce appropriate bytecode to store a stack item in an array. The\n\t * instruction to use varies depending on whether the type\n\t * is a primitive or reference type.\n\t * @param mv where to insert the bytecode\n\t * @param arrayElementType the type of the array elements\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "arrayElementType"
    ],
    "position": {
      "column": 1,
      "line": 831
    },
    "return": "void",
    "signature": "public void insertArrayStore(MethodVisitor mv, String arrayElementType)",
    "source_code": "\tpublic static void insertArrayStore(MethodVisitor mv, String arrayElementType) {\n\t\tif (arrayElementType.length() == 1) {\n\t\t\tswitch (arrayElementType.charAt(0)) {\n\t\t\t\tcase 'B', 'Z' -> mv.visitInsn(BASTORE);\n\t\t\t\tcase 'I' -> mv.visitInsn(IASTORE);\n\t\t\t\tcase 'J' -> mv.visitInsn(LASTORE);\n\t\t\t\tcase 'F' -> mv.visitInsn(FASTORE);\n\t\t\t\tcase 'D' -> mv.visitInsn(DASTORE);\n\t\t\t\tcase 'C' -> mv.visitInsn(CASTORE);\n\t\t\t\tcase 'S' -> mv.visitInsn(SASTORE);\n\t\t\t\tdefault -> throw new IllegalArgumentException(\"Unexpected array type \" + arrayElementType.charAt(0));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tmv.visitInsn(AASTORE);\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.ast.Indexer#isNullSafe()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Does this node represent a null-safe index operation?\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "boolean",
    "signature": "public boolean isNullSafe()",
    "source_code": "\tpublic final boolean isNullSafe() {\n\t\treturn this.nullSafe;\n\t}"
  },
  "org.springframework.expression.spel.ast.SpelNodeImpl#generateCode(mv,cf)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate the bytecode for this node into the supplied visitor. Context info about\n\t * the current expression being compiled is available in the codeflow object, e.g.\n\t * including information about the type of the object currently on the stack.\n\t * @param mv the ASM MethodVisitor into which code should be generated\n\t * @param cf a context object with info about what is on the stack\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "cf"
    ],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "void",
    "signature": "public void generateCode(MethodVisitor mv, CodeFlow cf)",
    "source_code": "\tpublic void generateCode(MethodVisitor mv, CodeFlow cf) {\n\t\tthrow new IllegalStateException(getClass().getName() +\" has no generateCode(..) method\");\n\t}"
  },
  "org.springframework.expression.spel.ast.SpelNodeImpl#generateCodeForArguments(mv,cf,executable,arguments)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate code that handles building the argument values for the specified\n\t * {@link Executable} (method or constructor).\n\t * <p>This method takes into account whether the method or constructor was\n\t * declared to accept varargs, and if it was then the argument values will be\n\t * appropriately packaged into an array.\n\t * @param mv the method visitor where code should be generated\n\t * @param cf the current {@link CodeFlow}\n\t * @param executable the {@link Executable} (method or constructor) for which\n\t * arguments are being set up\n\t * @param arguments the expression nodes for the expression supplied argument\n\t * values\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mv",
      "cf",
      "executable",
      "arguments"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "void",
    "signature": "protected void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Executable executable, SpelNodeImpl[] arguments)",
    "source_code": "\tprotected static void generateCodeForArguments("
  },
  "org.springframework.expression.spel.ast.SpelNodeImpl#isCompilable()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether a node can be compiled to bytecode. The reasoning in each node may\n\t * be different but will typically involve checking whether the exit type descriptor\n\t * of the node is known and any relevant child nodes are compilable.\n\t * @return {@code true} if this node can be compiled to bytecode\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "boolean",
    "signature": "public boolean isCompilable()",
    "source_code": "\tpublic boolean isCompilable() {\n\t\treturn false;\n\t}"
  },
  "org.springframework.expression.spel.support.OptimalPropertyAccessor": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An optimized form of a PropertyAccessor that will use reflection but only knows\n\t * how to access a particular property on a particular class. This is unlike the\n\t * general ReflectivePropertyResolver which manages a cache of methods/fields that\n\t * may be invoked to access different properties on different classes. This optimal\n\t * accessor exists because looking up the appropriate reflective object by class/name\n\t * on each read is not cheap.\n\t */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 635
    },
    "signature": "public class OptimalPropertyAccessor",
    "source_code": "\tpublic static class OptimalPropertyAccessor implements CompilablePropertyAccessor {\n\n\t\t/**\n\t\t * The member being accessed.\n\t\t */\n\t\tpublic final Member member;\n\n\t\tprivate final TypeDescriptor typeDescriptor;\n\n\t\tOptimalPropertyAccessor(InvokerPair target) {\n\t\t\tthis.member = target.member;\n\t\t\tthis.typeDescriptor = target.typeDescriptor;\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Class<?>[] getSpecificTargetClasses() {\n\t\t\tthrow new UnsupportedOperationException(\"Should not be called on an OptimalPropertyAccessor\");\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean canRead(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\t\tif (target == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tClass<?> type = (target instanceof Class<?> clazz ? clazz : target.getClass());\n\t\t\tif (type.isArray()) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (this.member instanceof Method method) {\n\t\t\t\tString getterName = \"get\" + StringUtils.capitalize(name);\n\t\t\t\tif (getterName.equals(method.getName())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tgetterName = \"is\" + StringUtils.capitalize(name);\n\t\t\t\tif (getterName.equals(method.getName())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.member.getName().equals(name);\n\t\t}\n\n\t\t@Override\n\t\tpublic TypedValue read(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\t\tif (this.member instanceof Method method) {\n\t\t\t\ttry {\n\t\t\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\t\t\tObject value = method.invoke(target);\n\t\t\t\t\treturn new TypedValue(value, this.typeDescriptor.narrow(value));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new AccessException(\"Unable to access property '\" + name + \"' through getter method\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tField field = (Field) this.member;\n\t\t\t\ttry {\n\t\t\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\t\t\tObject value = field.get(target);\n\t\t\t\t\treturn new TypedValue(value, this.typeDescriptor.narrow(value));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new AccessException(\"Unable to access field '\" + name + \"'\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean canWrite(EvaluationContext context, @Nullable Object target, String name) {\n\t\t\tthrow new UnsupportedOperationException(\"Should not be called on an OptimalPropertyAccessor\");\n\t\t}\n\n\t\t@Override\n\t\tpublic void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object newValue) {\n\t\t\tthrow new UnsupportedOperationException(\"Should not be called on an OptimalPropertyAccessor\");\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isCompilable() {\n\t\t\treturn (Modifier.isPublic(this.member.getModifiers()) &&\n\t\t\t\t\tModifier.isPublic(this.member.getDeclaringClass().getModifiers()));\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<?> getPropertyType() {\n\t\t\tif (this.member instanceof Method method) {\n\t\t\t\treturn method.getReturnType();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn ((Field) this.member).getType();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void generateCode(String propertyName, MethodVisitor mv, CodeFlow cf) {\n\t\t\tboolean isStatic = Modifier.isStatic(this.member.getModifiers());\n\t\t\tString descriptor = cf.lastDescriptor();\n\t\t\tString classDesc = this.member.getDeclaringClass().getName().replace('.', '/');\n\n\t\t\tif (!isStatic) {\n\t\t\t\tif (descriptor == null) {\n\t\t\t\t\tcf.loadTarget(mv);\n\t\t\t\t}\n\t\t\t\tif (descriptor == null || !classDesc.equals(descriptor.substring(1))) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, classDesc);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (descriptor != null) {\n\t\t\t\t\t// A static field/method call will not consume what is on the stack,\n\t\t\t\t\t// it needs to be popped off.\n\t\t\t\t\tmv.visitInsn(POP);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.member instanceof Method method) {\n\t\t\t\tboolean isInterface = method.getDeclaringClass().isInterface();\n\t\t\t\tint opcode = (isStatic ? INVOKESTATIC : isInterface ? INVOKEINTERFACE : INVOKEVIRTUAL);\n\t\t\t\tmv.visitMethodInsn(opcode, classDesc, method.getName(),\n\t\t\t\t\t\tCodeFlow.createSignatureDescriptor(method), isInterface);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmv.visitFieldInsn((isStatic ? GETSTATIC : GETFIELD), classDesc, this.member.getName(),\n\t\t\t\t\t\tCodeFlow.toJvmDescriptor(((Field) this.member).getType()));\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.support.ReflectivePropertyAccessor#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 599
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other || (other instanceof PropertyCacheKey that &&\n\t\t\t\t\tthis.clazz == that.clazz && this.property.equals(that.property) &&\n\t\t\t\t\tthis.targetIsClass == that.targetIsClass));\n\t\t}"
  },
  "org.springframework.expression.spel.support.ReflectivePropertyAccessor#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 606
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\t\tpublic int hashCode() {\n\t\t\treturn (this.clazz.hashCode() * 29 + this.property.hashCode());\n\t\t}"
  },
  "org.springframework.expression.spel.support.ReflectivePropertyAccessor#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 611
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn \"PropertyCacheKey [clazz=\" + this.clazz.getName() + \", property=\" + this.property +\n\t\t\t\t\t\", targetIsClass=\" + this.targetIsClass + \"]\";\n\t\t}"
  },
  "org.springframework.expression.spel.support.member": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * The member being accessed.\n\t\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 640
    },
    "signature": "public Member member",
    "source_code": "\t\tpublic final Member member;",
    "type": "Member"
  },
  "org.springframework.http.APPLICATION_YAML": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Public constant media type for {@code application/yaml}.\n\t * @since 6.2\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 319
    },
    "signature": "public MediaType APPLICATION_YAML",
    "source_code": "\tpublic static final MediaType APPLICATION_YAML;",
    "type": "MediaType"
  },
  "org.springframework.http.APPLICATION_YAML_VALUE": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * A String equivalent of {@link MediaType#APPLICATION_YAML}.\n\t * @since 6.2\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 325
    },
    "signature": "public String APPLICATION_YAML_VALUE",
    "source_code": "\tpublic static final String APPLICATION_YAML_VALUE = \"application/yaml\";",
    "type": "String"
  },
  "org.springframework.http.HttpHeaders#asSingleValueMap()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1791
    },
    "return": "String>",
    "signature": "public String> asSingleValueMap()",
    "source_code": "\tpublic Map<String, String> asSingleValueMap() {\n\t\treturn this.headers.asSingleValueMap();\n\t}"
  },
  "org.springframework.http.RequestEntity": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Extension of {@link HttpEntity} that also exposes the HTTP method and the\n * target URL. For use in the {@code RestTemplate} to prepare requests with\n * and in {@code @Controller} methods to represent request input.\n *\n * <p>Example use with the {@code RestTemplate}:\n * <pre class=\"code\">\n * MyRequest body = ...\n * RequestEntity&lt;MyRequest&gt; request = RequestEntity\n *     .post(&quot;https://example.com/{foo}&quot;, &quot;bar&quot;)\n *     .accept(MediaType.APPLICATION_JSON)\n *     .body(body);\n * ResponseEntity&lt;MyResponse&gt; response = template.exchange(request, MyResponse.class);\n * </pre>\n *\n * <p>Example use in an {@code @Controller}:\n * <pre class=\"code\">\n * &#64;RequestMapping(\"/handle\")\n * public void handle(RequestEntity&lt;String&gt; request) {\n *   HttpMethod method = request.getMethod();\n *   URI url = request.getUrl();\n *   String body = request.getBody();\n * }\n * </pre>\n *\n * @author Arjen Poutsma\n * @author Sebastien Deleuze\n * @author Parviz Rozikov\n * @since 4.1\n * @param <T> the body type\n * @see #getMethod()\n * @see #getUrl()\n * @see org.springframework.web.client.RestOperations#exchange(RequestEntity, Class)\n * @see ResponseEntity\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "signature": "public class RequestEntity",
    "source_code": "public class RequestEntity<T> extends HttpEntity<T> {\n\n\t@Nullable\n\tprivate final HttpMethod method;\n\n\t@Nullable\n\tprivate final URI url;\n\n\t@Nullable\n\tprivate final Type type;\n\n\t/**\n\t * Constructor with method and URL but without body nor headers.\n\t * @param method the method\n\t * @param url the URL\n\t */\n\tpublic RequestEntity(HttpMethod method, URI url) {\n\t\tthis(null, null, method, url, null);\n\t}\n\n\t/**\n\t * Constructor with method, URL and body but without headers.\n\t * @param body the body\n\t * @param method the method\n\t * @param url the URL\n\t */\n\tpublic RequestEntity(@Nullable T body, HttpMethod method, URI url) {\n\t\tthis(body, null, method, url, null);\n\t}\n\n\t/**\n\t * Constructor with method, URL, body and type but without headers.\n\t * @param body the body\n\t * @param method the method\n\t * @param url the URL\n\t * @param type the type used for generic type resolution\n\t * @since 4.3\n\t */\n\tpublic RequestEntity(@Nullable T body, HttpMethod method, URI url, Type type) {\n\t\tthis(body, null, method, url, type);\n\t}\n\n\t/**\n\t * Constructor with method, URL and headers but without body.\n\t * @param headers the headers\n\t * @param method the method\n\t * @param url the URL\n\t */\n\tpublic RequestEntity(MultiValueMap<String, String> headers, HttpMethod method, URI url) {\n\t\tthis(null, headers, method, url, null);\n\t}\n\n\t/**\n\t * Constructor with method, URL, headers and body.\n\t * @param body the body\n\t * @param headers the headers\n\t * @param method the method\n\t * @param url the URL\n\t */\n\tpublic RequestEntity(@Nullable T body, @Nullable MultiValueMap<String, String> headers,\n\t\t\t@Nullable HttpMethod method, URI url) {\n\n\t\tthis(body, headers, method, url, null);\n\t}\n\n\t/**\n\t * Constructor with method, URL, headers, body and type.\n\t * @param body the body\n\t * @param headers the headers\n\t * @param method the method\n\t * @param url the URL\n\t * @param type the type used for generic type resolution\n\t * @since 4.3\n\t */\n\tpublic RequestEntity(@Nullable T body, @Nullable MultiValueMap<String, String> headers,\n\t\t\t@Nullable HttpMethod method, @Nullable URI url, @Nullable Type type) {\n\n\t\tsuper(body, headers);\n\t\tthis.method = method;\n\t\tthis.url = url;\n\t\tthis.type = type;\n\t}\n\n\n\t/**\n\t * Return the HTTP method of the request.\n\t * @return the HTTP method as an {@code HttpMethod} enum value\n\t */\n\t@Nullable\n\tpublic HttpMethod getMethod() {\n\t\treturn this.method;\n\t}\n\n\t/**\n\t * Return the {@link URI} for the target HTTP endpoint.\n\t * <p><strong>Note:</strong> This method raises\n\t * {@link UnsupportedOperationException} if the {@code RequestEntity} was\n\t * created with a URI template and variables rather than with a {@link URI}\n\t * instance. This is because a URI cannot be created without further input\n\t * on how to expand template and encode the URI. In such cases, the\n\t * {@code URI} is prepared by the\n\t * {@link org.springframework.web.client.RestTemplate} with the help of the\n\t * {@link org.springframework.web.util.UriTemplateHandler} it is configured with.\n\t */\n\tpublic URI getUrl() {\n\t\tif (this.url == null) {\n\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\"The RequestEntity was created with a URI template and variables, \" +\n\t\t\t\t\t\t\t\"and there is not enough information on how to correctly expand and \" +\n\t\t\t\t\t\t\t\"encode the URI template. This will be done by the RestTemplate instead \" +\n\t\t\t\t\t\t\t\"with help from the UriTemplateHandler it is configured with.\");\n\t\t}\n\t\treturn this.url;\n\t}\n\n\n\t/**\n\t * Return the type of the request's body.\n\t * @return the request's body type, or {@code null} if not known\n\t * @since 4.3\n\t */\n\t@Nullable\n\tpublic Type getType() {\n\t\tif (this.type == null) {\n\t\t\tT body = getBody();\n\t\t\tif (body != null) {\n\t\t\t\treturn body.getClass();\n\t\t\t}\n\t\t}\n\t\treturn this.type;\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!super.equals(other)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (other instanceof RequestEntity<?> otherEntity &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.method, otherEntity.method) &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.url, otherEntity.url));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tint hashCode = super.hashCode();\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(this.method);\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(this.url);\n\t\treturn hashCode;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn format(getMethod(), getUrl().toString(), getBody(), getHeaders());\n\t}\n\n\tstatic <T> String format(@Nullable HttpMethod httpMethod, String url, @Nullable T body, HttpHeaders headers) {\n\t\tStringBuilder builder = new StringBuilder(\"<\");\n\t\tbuilder.append(httpMethod);\n\t\tbuilder.append(' ');\n\t\tbuilder.append(url);\n\t\tbuilder.append(',');\n\t\tif (body != null) {\n\t\t\tbuilder.append(body);\n\t\t\tbuilder.append(',');\n\t\t}\n\t\tbuilder.append(headers);\n\t\tbuilder.append('>');\n\t\treturn builder.toString();\n\t}\n\n\n\t// Static builder methods\n\n\t/**\n\t * Create a builder with the given method and url.\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param url the URL\n\t * @return the created builder\n\t */\n\tpublic static BodyBuilder method(HttpMethod method, URI url) {\n\t\treturn new DefaultBodyBuilder(method, url);\n\t}\n\n\t/**\n\t * Create a builder with the given HTTP method, URI template, and variables.\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */\n\tpublic static BodyBuilder method(HttpMethod method, String uriTemplate, Object... uriVariables) {\n\t\treturn new DefaultBodyBuilder(method, uriTemplate, uriVariables);\n\t}\n\n\t/**\n\t * Create a builder with the given HTTP method, URI template, and variables.\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param uriTemplate the uri template to use\n\t * @return the created builder\n\t * @since 5.3\n\t */\n\tpublic static BodyBuilder method(HttpMethod method, String uriTemplate, Map<String, ?> uriVariables) {\n\t\treturn new DefaultBodyBuilder(method, uriTemplate, uriVariables);\n\t}\n\n\n\t/**\n\t * Create an HTTP GET builder with the given url.\n\t * @param url the URL\n\t * @return the created builder\n\t */\n\tpublic static HeadersBuilder<?> get(URI url) {\n\t\treturn method(HttpMethod.GET, url);\n\t}\n\n\t/**\n\t * Create an HTTP GET builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */\n\tpublic static HeadersBuilder<?> get(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.GET, uriTemplate, uriVariables);\n\t}\n\n\t/**\n\t * Create an HTTP HEAD builder with the given url.\n\t * @param url the URL\n\t * @return the created builder\n\t */\n\tpublic static HeadersBuilder<?> head(URI url) {\n\t\treturn method(HttpMethod.HEAD, url);\n\t}\n\n\t/**\n\t * Create an HTTP HEAD builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */\n\tpublic static HeadersBuilder<?> head(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.HEAD, uriTemplate, uriVariables);\n\t}\n\n\t/**\n\t * Create an HTTP POST builder with the given url.\n\t * @param url the URL\n\t * @return the created builder\n\t */\n\tpublic static BodyBuilder post(URI url) {\n\t\treturn method(HttpMethod.POST, url);\n\t}\n\n\t/**\n\t * Create an HTTP POST builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */\n\tpublic static BodyBuilder post(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.POST, uriTemplate, uriVariables);\n\t}\n\n\t/**\n\t * Create an HTTP PUT builder with the given url.\n\t * @param url the URL\n\t * @return the created builder\n\t */\n\tpublic static BodyBuilder put(URI url) {\n\t\treturn method(HttpMethod.PUT, url);\n\t}\n\n\t/**\n\t * Create an HTTP PUT builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */\n\tpublic static BodyBuilder put(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.PUT, uriTemplate, uriVariables);\n\t}\n\n\t/**\n\t * Create an HTTP PATCH builder with the given url.\n\t * @param url the URL\n\t * @return the created builder\n\t */\n\tpublic static BodyBuilder patch(URI url) {\n\t\treturn method(HttpMethod.PATCH, url);\n\t}\n\n\t/**\n\t * Create an HTTP PATCH builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */\n\tpublic static BodyBuilder patch(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.PATCH, uriTemplate, uriVariables);\n\t}\n\n\t/**\n\t * Create an HTTP DELETE builder with the given url.\n\t * @param url the URL\n\t * @return the created builder\n\t */\n\tpublic static HeadersBuilder<?> delete(URI url) {\n\t\treturn method(HttpMethod.DELETE, url);\n\t}\n\n\t/**\n\t * Create an HTTP DELETE builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */\n\tpublic static HeadersBuilder<?> delete(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.DELETE, uriTemplate, uriVariables);\n\t}\n\n\t/**\n\t * Creates an HTTP OPTIONS builder with the given url.\n\t * @param url the URL\n\t * @return the created builder\n\t */\n\tpublic static HeadersBuilder<?> options(URI url) {\n\t\treturn method(HttpMethod.OPTIONS, url);\n\t}\n\n\t/**\n\t * Creates an HTTP OPTIONS builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */\n\tpublic static HeadersBuilder<?> options(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.OPTIONS, uriTemplate, uriVariables);\n\t}\n\n\n\t/**\n\t * Defines a builder that adds headers to the request entity.\n\t * @param <B> the builder subclass\n\t */\n\tpublic interface HeadersBuilder<B extends HeadersBuilder<B>> {\n\n\t\t/**\n\t\t * Add the given, single header value under the given name.\n\t\t * @param headerName  the header name\n\t\t * @param headerValues the header value(s)\n\t\t * @return this builder\n\t\t * @see HttpHeaders#add(String, String)\n\t\t */\n\t\tB header(String headerName, String... headerValues);\n\n\t\t/**\n\t\t * Copy the given headers into the entity's headers map.\n\t\t * @param headers the existing HttpHeaders to copy from\n\t\t * @return this builder\n\t\t * @since 5.2\n\t\t * @see HttpHeaders#add(String, String)\n\t\t */\n\t\tB headers(@Nullable HttpHeaders headers);\n\n\t\t/**\n\t\t * Manipulate this entity's headers with the given consumer. The\n\t\t * headers provided to the consumer are \"live\", so that the consumer can be used to\n\t\t * {@linkplain HttpHeaders#set(String, String) overwrite} existing header values,\n\t\t * {@linkplain HttpHeaders#remove(Object) remove} values, or use any of the other\n\t\t * {@link HttpHeaders} methods.\n\t\t * @param headersConsumer a function that consumes the {@code HttpHeaders}\n\t\t * @return this builder\n\t\t * @since 5.2\n\t\t */\n\t\tB headers(Consumer<HttpHeaders> headersConsumer);\n\n\t\t/**\n\t\t * Set the list of acceptable {@linkplain MediaType media types}, as\n\t\t * specified by the {@code Accept} header.\n\t\t * @param acceptableMediaTypes the acceptable media types\n\t\t */\n\t\tB accept(MediaType... acceptableMediaTypes);\n\n\t\t/**\n\t\t * Set the list of acceptable {@linkplain Charset charsets}, as specified\n\t\t * by the {@code Accept-Charset} header.\n\t\t * @param acceptableCharsets the acceptable charsets\n\t\t */\n\t\tB acceptCharset(Charset... acceptableCharsets);\n\n\t\t/**\n\t\t * Set the value of the {@code If-Modified-Since} header.\n\t\t * @param ifModifiedSince the new value of the header\n\t\t * @since 5.1.4\n\t\t */\n\t\tB ifModifiedSince(ZonedDateTime ifModifiedSince);\n\n\t\t/**\n\t\t * Set the value of the {@code If-Modified-Since} header.\n\t\t * @param ifModifiedSince the new value of the header\n\t\t * @since 5.1.4\n\t\t */\n\t\tB ifModifiedSince(Instant ifModifiedSince);\n\n\t\t/**\n\t\t * Set the value of the {@code If-Modified-Since} header.\n\t\t * <p>The date should be specified as the number of milliseconds since\n\t\t * January 1, 1970 GMT.\n\t\t * @param ifModifiedSince the new value of the header\n\t\t */\n\t\tB ifModifiedSince(long ifModifiedSince);\n\n\t\t/**\n\t\t * Set the values of the {@code If-None-Match} header.\n\t\t * @param ifNoneMatches the new value of the header\n\t\t */\n\t\tB ifNoneMatch(String... ifNoneMatches);\n\n\t\t/**\n\t\t * Builds the request entity with no body.\n\t\t * @return the request entity\n\t\t * @see BodyBuilder#body(Object)\n\t\t */\n\t\tRequestEntity<Void> build();\n\t}\n\n\n\t/**\n\t * Defines a builder that adds a body to the response entity.\n\t */\n\tpublic interface BodyBuilder extends HeadersBuilder<BodyBuilder> {\n\n\t\t/**\n\t\t * Set the length of the body in bytes, as specified by the\n\t\t * {@code Content-Length} header.\n\t\t * @param contentLength the content length\n\t\t * @return this builder\n\t\t * @see HttpHeaders#setContentLength(long)\n\t\t */\n\t\tBodyBuilder contentLength(long contentLength);\n\n\t\t/**\n\t\t * Set the {@linkplain MediaType media type} of the body, as specified\n\t\t * by the {@code Content-Type} header.\n\t\t * @param contentType the content type\n\t\t * @return this builder\n\t\t * @see HttpHeaders#setContentType(MediaType)\n\t\t */\n\t\tBodyBuilder contentType(MediaType contentType);\n\n\t\t/**\n\t\t * Set the body of the request entity and build the RequestEntity.\n\t\t * @param <T> the type of the body\n\t\t * @param body the body of the request entity\n\t\t * @return the built request entity\n\t\t */\n\t\t<T> RequestEntity<T> body(T body);\n\n\t\t/**\n\t\t * Set the body and type of the request entity and build the RequestEntity.\n\t\t * @param <T> the type of the body\n\t\t * @param body the body of the request entity\n\t\t * @param type the type of the body, useful for generic type resolution\n\t\t * @return the built request entity\n\t\t * @since 4.3\n\t\t */\n\t\t<T> RequestEntity<T> body(T body, Type type);\n\t}\n\n\n\tprivate static class DefaultBodyBuilder implements BodyBuilder {\n\n\t\tprivate final HttpMethod method;\n\n\t\tprivate final HttpHeaders headers = new HttpHeaders();\n\n\t\t@Nullable\n\t\tprivate final URI uri;\n\n\t\t@Nullable\n\t\tprivate final String uriTemplate;\n\n\t\t@Nullable\n\t\tprivate final Object[] uriVarsArray;\n\n\t\t@Nullable\n\t\tprivate final Map<String, ?> uriVarsMap;\n\n\t\tDefaultBodyBuilder(HttpMethod method, URI url) {\n\t\t\tthis.method = method;\n\t\t\tthis.uri = url;\n\t\t\tthis.uriTemplate = null;\n\t\t\tthis.uriVarsArray = null;\n\t\t\tthis.uriVarsMap = null;\n\t\t}\n\n\t\tDefaultBodyBuilder(HttpMethod method, String uriTemplate, Object... uriVars) {\n\t\t\tthis.method = method;\n\t\t\tthis.uri = null;\n\t\t\tthis.uriTemplate = uriTemplate;\n\t\t\tthis.uriVarsArray = uriVars;\n\t\t\tthis.uriVarsMap = null;\n\t\t}\n\n\t\tDefaultBodyBuilder(HttpMethod method, String uriTemplate, Map<String, ?> uriVars) {\n\t\t\tthis.method = method;\n\t\t\tthis.uri = null;\n\t\t\tthis.uriTemplate = uriTemplate;\n\t\t\tthis.uriVarsArray = null;\n\t\t\tthis.uriVarsMap = uriVars;\n\t\t}\n\n\t\t@Override\n\t\tpublic BodyBuilder header(String headerName, String... headerValues) {\n\t\t\tfor (String headerValue : headerValues) {\n\t\t\t\tthis.headers.add(headerName, headerValue);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic BodyBuilder headers(@Nullable HttpHeaders headers) {\n\t\t\tif (headers != null) {\n\t\t\t\tthis.headers.putAll(headers);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic BodyBuilder headers(Consumer<HttpHeaders> headersConsumer) {\n\t\t\theadersConsumer.accept(this.headers);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic BodyBuilder accept(MediaType... acceptableMediaTypes) {\n\t\t\tthis.headers.setAccept(Arrays.asList(acceptableMediaTypes));\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic BodyBuilder acceptCharset(Charset... acceptableCharsets) {\n\t\t\tthis.headers.setAcceptCharset(Arrays.asList(acceptableCharsets));\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic BodyBuilder contentLength(long contentLength) {\n\t\t\tthis.headers.setContentLength(contentLength);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic BodyBuilder contentType(MediaType contentType) {\n\t\t\tthis.headers.setContentType(contentType);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic BodyBuilder ifModifiedSince(ZonedDateTime ifModifiedSince) {\n\t\t\tthis.headers.setIfModifiedSince(ifModifiedSince);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic BodyBuilder ifModifiedSince(Instant ifModifiedSince) {\n\t\t\tthis.headers.setIfModifiedSince(ifModifiedSince);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic BodyBuilder ifModifiedSince(long ifModifiedSince) {\n\t\t\tthis.headers.setIfModifiedSince(ifModifiedSince);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic BodyBuilder ifNoneMatch(String... ifNoneMatches) {\n\t\t\tthis.headers.setIfNoneMatch(Arrays.asList(ifNoneMatches));\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic RequestEntity<Void> build() {\n\t\t\treturn buildInternal(null, null);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> RequestEntity<T> body(T body) {\n\t\t\treturn buildInternal(body, null);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> RequestEntity<T> body(T body, Type type) {\n\t\t\treturn buildInternal(body, type);\n\t\t}\n\n\t\tprivate <T> RequestEntity<T> buildInternal(@Nullable T body, @Nullable Type type) {\n\t\t\tif (this.uri != null) {\n\t\t\t\treturn new RequestEntity<>(body, this.headers, this.method, this.uri, type);\n\t\t\t}\n\t\t\telse if (this.uriTemplate != null){\n\t\t\t\treturn new UriTemplateRequestEntity<>(body, this.headers, this.method, type,\n\t\t\t\t\t\tthis.uriTemplate, this.uriVarsArray, this.uriVarsMap);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalStateException(\"Neither URI nor URI template\");\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * RequestEntity initialized with a URI template and variables instead of a {@link URI}.\n\t * @since 5.3\n\t * @param <T> the body type\n\t */\n\tpublic static class UriTemplateRequestEntity<T> extends RequestEntity<T> {\n\n\t\tprivate final String uriTemplate;\n\n\t\t@Nullable\n\t\tprivate final Object[] uriVarsArray;\n\n\t\t@Nullable\n\t\tprivate final Map<String, ?> uriVarsMap;\n\n\t\tUriTemplateRequestEntity(\n\t\t\t\t@Nullable T body, @Nullable MultiValueMap<String, String> headers,\n\t\t\t\t@Nullable HttpMethod method, @Nullable Type type, String uriTemplate,\n\t\t\t\t@Nullable Object[] uriVarsArray, @Nullable Map<String, ?> uriVarsMap) {\n\n\t\t\tsuper(body, headers, method, null, type);\n\t\t\tthis.uriTemplate = uriTemplate;\n\t\t\tthis.uriVarsArray = uriVarsArray;\n\t\t\tthis.uriVarsMap = uriVarsMap;\n\t\t}\n\n\t\tpublic String getUriTemplate() {\n\t\t\treturn this.uriTemplate;\n\t\t}\n\n\t\t@Nullable\n\t\tpublic Object[] getVars() {\n\t\t\treturn this.uriVarsArray;\n\t\t}\n\n\t\t@Nullable\n\t\tpublic Map<String, ?> getVarsMap() {\n\t\t\treturn this.uriVarsMap;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\tif (this == other) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!super.equals(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn (other instanceof UriTemplateRequestEntity<?> otherEntity &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.uriTemplate, otherEntity.uriTemplate) &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.uriVarsArray, otherEntity.uriVarsArray) &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.uriVarsMap, otherEntity.uriVarsMap));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn (29 * super.hashCode() + ObjectUtils.nullSafeHashCode(this.uriTemplate));\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn format(getMethod(), getUriTemplate(), getBody(), getHeaders());\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.http.RequestEntity#accept(acceptableMediaTypes)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "acceptableMediaTypes"
    ],
    "position": {
      "column": 1,
      "line": 614
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder accept(MediaType... acceptableMediaTypes)",
    "source_code": "\t\tpublic BodyBuilder accept(MediaType... acceptableMediaTypes) {\n\t\t\tthis.headers.setAccept(Arrays.asList(acceptableMediaTypes));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.RequestEntity#acceptCharset(acceptableCharsets)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "acceptableCharsets"
    ],
    "position": {
      "column": 1,
      "line": 620
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder acceptCharset(Charset... acceptableCharsets)",
    "source_code": "\t\tpublic BodyBuilder acceptCharset(Charset... acceptableCharsets) {\n\t\t\tthis.headers.setAcceptCharset(Arrays.asList(acceptableCharsets));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.RequestEntity#body(body)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body"
    ],
    "position": {
      "column": 1,
      "line": 667
    },
    "return": "RequestEntity<T>",
    "signature": "public RequestEntity<T> body(T body)",
    "source_code": "\t\tpublic <T> RequestEntity<T> body(T body) {\n\t\t\treturn buildInternal(body, null);\n\t\t}"
  },
  "org.springframework.http.RequestEntity#body(body,type)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 672
    },
    "return": "RequestEntity<T>",
    "signature": "public RequestEntity<T> body(T body, Type type)",
    "source_code": "\t\tpublic <T> RequestEntity<T> body(T body, Type type) {\n\t\t\treturn buildInternal(body, type);\n\t\t}"
  },
  "org.springframework.http.RequestEntity#build()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 662
    },
    "return": "RequestEntity<Void>",
    "signature": "public RequestEntity<Void> build()",
    "source_code": "\t\tpublic RequestEntity<Void> build() {\n\t\t\treturn buildInternal(null, null);\n\t\t}"
  },
  "org.springframework.http.RequestEntity#contentLength(contentLength)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentLength"
    ],
    "position": {
      "column": 1,
      "line": 626
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder contentLength(long contentLength)",
    "source_code": "\t\tpublic BodyBuilder contentLength(long contentLength) {\n\t\t\tthis.headers.setContentLength(contentLength);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.RequestEntity#contentType(contentType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 632
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder contentType(MediaType contentType)",
    "source_code": "\t\tpublic BodyBuilder contentType(MediaType contentType) {\n\t\t\tthis.headers.setContentType(contentType);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.RequestEntity#equals(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 732
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\tif (this == other) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!super.equals(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn (other instanceof UriTemplateRequestEntity<?> otherEntity &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.uriTemplate, otherEntity.uriTemplate) &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.uriVarsArray, otherEntity.uriVarsArray) &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.uriVarsMap, otherEntity.uriVarsMap));\n\t\t}"
  },
  "org.springframework.http.RequestEntity#getMethod()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the HTTP method of the request.\n\t * @return the HTTP method as an {@code HttpMethod} enum value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "HttpMethod",
    "signature": "public HttpMethod getMethod()",
    "source_code": "\tpublic HttpMethod getMethod() {\n\t\treturn this.method;\n\t}"
  },
  "org.springframework.http.RequestEntity#getType()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the type of the request's body.\n\t * @return the request's body type, or {@code null} if not known\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "Type",
    "signature": "public Type getType()",
    "source_code": "\tpublic Type getType() {\n\t\tif (this.type == null) {\n\t\t\tT body = getBody();\n\t\t\tif (body != null) {\n\t\t\t\treturn body.getClass();\n\t\t\t}\n\t\t}\n\t\treturn this.type;\n\t}"
  },
  "org.springframework.http.RequestEntity#getUriTemplate()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 717
    },
    "return": "String",
    "signature": "public String getUriTemplate()",
    "source_code": "\t\tpublic String getUriTemplate() {\n\t\t\treturn this.uriTemplate;\n\t\t}"
  },
  "org.springframework.http.RequestEntity#getUrl()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link URI} for the target HTTP endpoint.\n\t * <p><strong>Note:</strong> This method raises\n\t * {@link UnsupportedOperationException} if the {@code RequestEntity} was\n\t * created with a URI template and variables rather than with a {@link URI}\n\t * instance. This is because a URI cannot be created without further input\n\t * on how to expand template and encode the URI. In such cases, the\n\t * {@code URI} is prepared by the\n\t * {@link org.springframework.web.client.RestTemplate} with the help of the\n\t * {@link org.springframework.web.util.UriTemplateHandler} it is configured with.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "URI",
    "signature": "public URI getUrl()",
    "source_code": "\tpublic URI getUrl() {\n\t\tif (this.url == null) {\n\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\"The RequestEntity was created with a URI template and variables, \" +\n\t\t\t\t\t\t\t\"and there is not enough information on how to correctly expand and \" +\n\t\t\t\t\t\t\t\"encode the URI template. This will be done by the RestTemplate instead \" +\n\t\t\t\t\t\t\t\"with help from the UriTemplateHandler it is configured with.\");\n\t\t}\n\t\treturn this.url;\n\t}"
  },
  "org.springframework.http.RequestEntity#getVars()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 722
    },
    "return": "Object[]",
    "signature": "public Object[] getVars()",
    "source_code": "\t\tpublic Object[] getVars() {\n\t\t\treturn this.uriVarsArray;\n\t\t}"
  },
  "org.springframework.http.RequestEntity#hashCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 746
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\t\tpublic int hashCode() {\n\t\t\treturn (29 * super.hashCode() + ObjectUtils.nullSafeHashCode(this.uriTemplate));\n\t\t}"
  },
  "org.springframework.http.RequestEntity#header(headerName,headerValues)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 592
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder header(String headerName, String... headerValues)",
    "source_code": "\t\tpublic BodyBuilder header(String headerName, String... headerValues) {\n\t\t\tfor (String headerValue : headerValues) {\n\t\t\t\tthis.headers.add(headerName, headerValue);\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.RequestEntity#headers(headers)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 600
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder headers(@Nullable HttpHeaders headers)",
    "source_code": "\t\tpublic BodyBuilder headers(@Nullable HttpHeaders headers) {\n\t\t\tif (headers != null) {\n\t\t\t\tthis.headers.putAll(headers);\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.RequestEntity#headers(headersConsumer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headersConsumer"
    ],
    "position": {
      "column": 1,
      "line": 608
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder headers(Consumer<HttpHeaders> headersConsumer)",
    "source_code": "\t\tpublic BodyBuilder headers(Consumer<HttpHeaders> headersConsumer) {\n\t\t\theadersConsumer.accept(this.headers);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.RequestEntity#ifModifiedSince(ifModifiedSince)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ifModifiedSince"
    ],
    "position": {
      "column": 1,
      "line": 650
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder ifModifiedSince(long ifModifiedSince)",
    "source_code": "\t\tpublic BodyBuilder ifModifiedSince(long ifModifiedSince) {\n\t\t\tthis.headers.setIfModifiedSince(ifModifiedSince);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.RequestEntity#ifNoneMatch(ifNoneMatches)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ifNoneMatches"
    ],
    "position": {
      "column": 1,
      "line": 656
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder ifNoneMatch(String... ifNoneMatches)",
    "source_code": "\t\tpublic BodyBuilder ifNoneMatch(String... ifNoneMatches) {\n\t\t\tthis.headers.setIfNoneMatch(Arrays.asList(ifNoneMatches));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.RequestEntity#method(method,uriTemplate,Map<String,uriVariables)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a builder with the given HTTP method, URI template, and variables.\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param uriTemplate the uri template to use\n\t * @return the created builder\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "uriTemplate",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder method(HttpMethod method, String uriTemplate, Map<String, ?> uriVariables)",
    "source_code": "\tpublic static BodyBuilder method(HttpMethod method, String uriTemplate, Map<String, ?> uriVariables) {\n\t\treturn new DefaultBodyBuilder(method, uriTemplate, uriVariables);\n\t}"
  },
  "org.springframework.http.RequestEntity#method(method,uriTemplate,uriVariables)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a builder with the given HTTP method, URI template, and variables.\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder method(HttpMethod method, String uriTemplate, Object... uriVariables)",
    "source_code": "\tpublic static BodyBuilder method(HttpMethod method, String uriTemplate, Object... uriVariables) {\n\t\treturn new DefaultBodyBuilder(method, uriTemplate, uriVariables);\n\t}"
  },
  "org.springframework.http.RequestEntity#method(method,url)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a builder with the given method and url.\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param url the URL\n\t * @return the created builder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "url"
    ],
    "position": {
      "column": 1,
      "line": 250
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder method(HttpMethod method, URI url)",
    "source_code": "\tpublic static BodyBuilder method(HttpMethod method, URI url) {\n\t\treturn new DefaultBodyBuilder(method, url);\n\t}"
  },
  "org.springframework.http.RequestEntity#patch(uriTemplate,uriVariables)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an HTTP PATCH builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 374
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder patch(String uriTemplate, Object... uriVariables)",
    "source_code": "\tpublic static BodyBuilder patch(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.PATCH, uriTemplate, uriVariables);\n\t}"
  },
  "org.springframework.http.RequestEntity#patch(url)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an HTTP PATCH builder with the given url.\n\t * @param url the URL\n\t * @return the created builder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder patch(URI url)",
    "source_code": "\tpublic static BodyBuilder patch(URI url) {\n\t\treturn method(HttpMethod.PATCH, url);\n\t}"
  },
  "org.springframework.http.RequestEntity#post(uriTemplate,uriVariables)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an HTTP POST builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder post(String uriTemplate, Object... uriVariables)",
    "source_code": "\tpublic static BodyBuilder post(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.POST, uriTemplate, uriVariables);\n\t}"
  },
  "org.springframework.http.RequestEntity#post(url)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an HTTP POST builder with the given url.\n\t * @param url the URL\n\t * @return the created builder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder post(URI url)",
    "source_code": "\tpublic static BodyBuilder post(URI url) {\n\t\treturn method(HttpMethod.POST, url);\n\t}"
  },
  "org.springframework.http.RequestEntity#put(uriTemplate,uriVariables)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an HTTP PUT builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 354
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder put(String uriTemplate, Object... uriVariables)",
    "source_code": "\tpublic static BodyBuilder put(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.PUT, uriTemplate, uriVariables);\n\t}"
  },
  "org.springframework.http.RequestEntity#put(url)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an HTTP PUT builder with the given url.\n\t * @param url the URL\n\t * @return the created builder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url"
    ],
    "position": {
      "column": 1,
      "line": 343
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder put(URI url)",
    "source_code": "\tpublic static BodyBuilder put(URI url) {\n\t\treturn method(HttpMethod.PUT, url);\n\t}"
  },
  "org.springframework.http.RequestEntity#toString()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 751
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn format(getMethod(), getUriTemplate(), getBody(), getHeaders());\n\t\t}"
  },
  "org.springframework.http.ResponseCookie#isPartitioned()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return {@code true} if the cookie has the \"Partitioned\" attribute.\n\t * @since 6.2\n\t * @see <a href=\"https://datatracker.ietf.org/doc/html/draft-cutler-httpbis-partitioned-cookies#section-2.1\">The Partitioned attribute spec</a>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "boolean",
    "signature": "public boolean isPartitioned()",
    "source_code": "\tpublic boolean isPartitioned() {\n\t\treturn this.partitioned;\n\t}"
  },
  "org.springframework.http.ResponseCookie#partitioned(partitioned)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "partitioned"
    ],
    "position": {
      "column": 1,
      "line": 490
    },
    "return": "ResponseCookieBuilder",
    "signature": "public ResponseCookieBuilder partitioned(boolean partitioned)",
    "source_code": "\t\tpublic ResponseCookieBuilder partitioned(boolean partitioned) {\n\t\t\tthis.partitioned = partitioned;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.UriTemplateRequestEntity": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * RequestEntity initialized with a URI template and variables instead of a {@link URI}.\n\t * @since 5.3\n\t * @param <T> the body type\n\t */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 696
    },
    "signature": "public class UriTemplateRequestEntity",
    "source_code": "\tpublic static class UriTemplateRequestEntity<T> extends RequestEntity<T> {\n\n\t\tprivate final String uriTemplate;\n\n\t\t@Nullable\n\t\tprivate final Object[] uriVarsArray;\n\n\t\t@Nullable\n\t\tprivate final Map<String, ?> uriVarsMap;\n\n\t\tUriTemplateRequestEntity(\n\t\t\t\t@Nullable T body, @Nullable MultiValueMap<String, String> headers,\n\t\t\t\t@Nullable HttpMethod method, @Nullable Type type, String uriTemplate,\n\t\t\t\t@Nullable Object[] uriVarsArray, @Nullable Map<String, ?> uriVarsMap) {\n\n\t\t\tsuper(body, headers, method, null, type);\n\t\t\tthis.uriTemplate = uriTemplate;\n\t\t\tthis.uriVarsArray = uriVarsArray;\n\t\t\tthis.uriVarsMap = uriVarsMap;\n\t\t}\n\n\t\tpublic String getUriTemplate() {\n\t\t\treturn this.uriTemplate;\n\t\t}\n\n\t\t@Nullable\n\t\tpublic Object[] getVars() {\n\t\t\treturn this.uriVarsArray;\n\t\t}\n\n\t\t@Nullable\n\t\tpublic Map<String, ?> getVarsMap() {\n\t\t\treturn this.uriVarsMap;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\tif (this == other) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!super.equals(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn (other instanceof UriTemplateRequestEntity<?> otherEntity &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.uriTemplate, otherEntity.uriTemplate) &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.uriVarsArray, otherEntity.uriVarsArray) &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.uriVarsMap, otherEntity.uriVarsMap));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn (29 * super.hashCode() + ObjectUtils.nullSafeHashCode(this.uriTemplate));\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn format(getMethod(), getUriTemplate(), getBody(), getHeaders());\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#yaml()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a {@link Jackson2ObjectMapperBuilder} instance in order to\n\t * build a YAML data format {@link ObjectMapper} instance.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 946
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder yaml()",
    "source_code": "\tpublic static Jackson2ObjectMapperBuilder yaml() {\n\t\treturn new Jackson2ObjectMapperBuilder().factory(new YamlFactoryInitializer().create());\n\t}"
  },
  "org.springframework.http.server.ServletServerHttpRequest#clear()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 353
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\t\tpublic void clear() {\n\t\t\tfor (Enumeration<String> names = servletRequest.getAttributeNames(); names.hasMoreElements(); ) {\n\t\t\t\tString name = names.nextElement();\n\t\t\t\tservletRequest.removeAttribute(name);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.http.server.ServletServerHttpRequest#entrySet()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 413
    },
    "return": "Object>>",
    "signature": "public Object>> entrySet()",
    "source_code": "\t\tpublic Set<Entry<String, Object>> entrySet() {\n\t\t\tSet<Entry<String, Object>> entrySet = this.entrySet;\n\t\t\tif (entrySet == null) {\n\t\t\t\tentrySet = new AbstractSet<>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Iterator<Entry<String, Object>> iterator() {\n\t\t\t\t\t\tEnumeration<String> e = servletRequest.getAttributeNames();\n\t\t\t\t\t\treturn new Iterator<>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic boolean hasNext() {\n\t\t\t\t\t\t\t\treturn e.hasMoreElements();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic Entry<String, Object> next() {\n\t\t\t\t\t\t\t\tString name = e.nextElement();\n\t\t\t\t\t\t\t\tObject value = servletRequest.getAttribute(name);\n\t\t\t\t\t\t\t\treturn new SimpleImmutableEntry<>(name, value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic int size() {\n\t\t\t\t\t\treturn AttributesMap.this.size();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tthis.entrySet = entrySet;\n\t\t\t}\n\t\t\treturn entrySet;\n\t\t}"
  },
  "org.springframework.http.server.ServletServerHttpRequest#get(key)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 322
    },
    "return": "Object",
    "signature": "public Object get(Object key)",
    "source_code": "\t\tpublic Object get(Object key) {\n\t\t\tif (key instanceof String name) {\n\t\t\t\treturn servletRequest.getAttribute(name);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.http.server.ServletServerHttpRequest#getAttributes()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "Object>",
    "signature": "public Object> getAttributes()",
    "source_code": "\tpublic Map<String, Object> getAttributes() {\n\t\tMap<String, Object> attributes = this.attributes;\n\t\tif (attributes == null) {\n\t\t\tattributes = new AttributesMap();\n\t\t\tthis.attributes = attributes;\n\t\t}\n\t\treturn attributes;\n\t}"
  },
  "org.springframework.http.server.ServletServerHttpRequest#hasNext()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 422
    },
    "return": "boolean",
    "signature": "public boolean hasNext()",
    "source_code": "\t\t\t\t\t\t\tpublic boolean hasNext() {\n\t\t\t\t\t\t\t\treturn e.hasMoreElements();\n\t\t\t\t\t\t\t}"
  },
  "org.springframework.http.server.ServletServerHttpRequest#iterator()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 418
    },
    "return": "Object>>",
    "signature": "public Object>> iterator()",
    "source_code": "\t\t\t\t\tpublic Iterator<Entry<String, Object>> iterator() {\n\t\t\t\t\t\tEnumeration<String> e = servletRequest.getAttributeNames();\n\t\t\t\t\t\treturn new Iterator<>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic boolean hasNext() {\n\t\t\t\t\t\t\t\treturn e.hasMoreElements();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic Entry<String, Object> next() {\n\t\t\t\t\t\t\t\tString name = e.nextElement();\n\t\t\t\t\t\t\t\tObject value = servletRequest.getAttribute(name);\n\t\t\t\t\t\t\t\treturn new SimpleImmutableEntry<>(name, value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}"
  },
  "org.springframework.http.server.ServletServerHttpRequest#keySet()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 361
    },
    "return": "Set<String>",
    "signature": "public Set<String> keySet()",
    "source_code": "\t\tpublic Set<String> keySet() {\n\t\t\tSet<String> keySet = this.keySet;\n\t\t\tif (keySet == null) {\n\t\t\t\tkeySet = new AbstractSet<>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Iterator<String> iterator() {\n\t\t\t\t\t\treturn servletRequest.getAttributeNames().asIterator();\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic int size() {\n\t\t\t\t\t\treturn AttributesMap.this.size();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tthis.keySet = keySet;\n\t\t\t}\n\t\t\treturn keySet;\n\t\t}"
  },
  "org.springframework.http.server.ServletServerHttpRequest#next()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 427
    },
    "return": "Object>",
    "signature": "public Object> next()",
    "source_code": "\t\t\t\t\t\t\tpublic Entry<String, Object> next() {\n\t\t\t\t\t\t\t\tString name = e.nextElement();\n\t\t\t\t\t\t\t\tObject value = servletRequest.getAttribute(name);\n\t\t\t\t\t\t\t\treturn new SimpleImmutableEntry<>(name, value);\n\t\t\t\t\t\t\t}"
  },
  "org.springframework.http.server.ServletServerHttpRequest#put(key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "Object",
    "signature": "public Object put(String key, Object value)",
    "source_code": "\t\tpublic Object put(String key, Object value) {\n\t\t\tObject old = get(key);\n\t\t\tservletRequest.setAttribute(key, value);\n\t\t\treturn old;\n\t\t}"
  },
  "org.springframework.http.server.ServletServerHttpRequest#remove(key)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "Object",
    "signature": "public Object remove(Object key)",
    "source_code": "\t\tpublic Object remove(Object key) {\n\t\t\tif (key instanceof String name) {\n\t\t\t\tObject old = get(key);\n\t\t\t\tservletRequest.removeAttribute(name);\n\t\t\t\treturn old;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.http.server.ServletServerHttpRequest#size()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 436
    },
    "return": "int",
    "signature": "public int size()",
    "source_code": "\t\t\t\t\tpublic int size() {\n\t\t\t\t\t\treturn AttributesMap.this.size();\n\t\t\t\t\t}"
  },
  "org.springframework.http.server.ServletServerHttpRequest#values()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 381
    },
    "return": "Collection<Object>",
    "signature": "public Collection<Object> values()",
    "source_code": "\t\tpublic Collection<Object> values() {\n\t\t\tCollection<Object> values = this.values;\n\t\t\tif (values == null) {\n\t\t\t\tvalues = new AbstractCollection<>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Iterator<Object> iterator() {\n\t\t\t\t\t\tEnumeration<String> e = servletRequest.getAttributeNames();\n\t\t\t\t\t\treturn new Iterator<>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic boolean hasNext() {\n\t\t\t\t\t\t\t\treturn e.hasMoreElements();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic Object next() {\n\t\t\t\t\t\t\t\tString name = e.nextElement();\n\t\t\t\t\t\t\t\treturn servletRequest.getAttribute(name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic int size() {\n\t\t\t\t\t\treturn AttributesMap.this.size();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tthis.values = values;\n\t\t\t}\n\t\t\treturn values;\n\t\t}"
  },
  "org.springframework.http.server.reactive.ServerHttpRequestDecorator#getAttributes()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "Object>",
    "signature": "public Object> getAttributes()",
    "source_code": "\tpublic Map<String, Object> getAttributes() {\n\t\treturn getDelegate().getAttributes();\n\t}"
  },
  "org.springframework.jdbc.datasource.embedded.<unknown>#getConfigurer(type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a configurer instance for the given embedded database type.\n\t * @param type the embedded database type (HSQL, H2 or Derby)\n\t * @return the configurer instance\n\t * @throws IllegalStateException if the driver for the specified database type is not available\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "return": "EmbeddedDatabaseConfigurer",
    "signature": "public EmbeddedDatabaseConfigurer getConfigurer(EmbeddedDatabaseType type)",
    "source_code": "\tpublic static EmbeddedDatabaseConfigurer getConfigurer(EmbeddedDatabaseType type) throws IllegalStateException {\n\t\tAssert.notNull(type, \"EmbeddedDatabaseType is required\");\n\t\ttry {\n\t\t\treturn switch (type) {\n\t\t\t\tcase HSQL -> HsqlEmbeddedDatabaseConfigurer.getInstance();\n\t\t\t\tcase H2 -> H2EmbeddedDatabaseConfigurer.getInstance();\n\t\t\t\tcase DERBY -> DerbyEmbeddedDatabaseConfigurer.getInstance();\n\t\t\t\tdefault -> throw new UnsupportedOperationException(\"Embedded database type [\" + type + \"] is not supported\");\n\t\t\t};\n\t\t}\n\t\tcatch (ClassNotFoundException | NoClassDefFoundError ex) {\n\t\t\tthrow new IllegalStateException(\"Driver for test database type [\" + type + \"] is not available\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseConfigurers": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Maps well-known {@linkplain EmbeddedDatabaseType embedded database types}\n * to {@link EmbeddedDatabaseConfigurer} strategies.\n *\n * @author Keith Donald\n * @author Oliver Gierke\n * @author Sam Brannen\n * @author Stephane Nicoll\n * @since 6.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 33
    },
    "signature": "public class EmbeddedDatabaseConfigurers",
    "source_code": "public abstract class EmbeddedDatabaseConfigurers {\n\n\t/**\n\t * Return a configurer instance for the given embedded database type.\n\t * @param type the {@linkplain EmbeddedDatabaseType embedded database type}\n\t * @return the configurer instance\n\t * @throws IllegalStateException if the driver for the specified database type is not available\n\t */\n\tpublic static EmbeddedDatabaseConfigurer getConfigurer(EmbeddedDatabaseType type) {\n\t\tAssert.notNull(type, \"EmbeddedDatabaseType is required\");\n\t\ttry {\n\t\t\treturn switch (type) {\n\t\t\t\tcase HSQL -> HsqlEmbeddedDatabaseConfigurer.getInstance();\n\t\t\t\tcase H2 -> H2EmbeddedDatabaseConfigurer.getInstance();\n\t\t\t\tcase DERBY -> DerbyEmbeddedDatabaseConfigurer.getInstance();\n\t\t\t};\n\t\t}\n\t\tcatch (ClassNotFoundException | NoClassDefFoundError ex) {\n\t\t\tthrow new IllegalStateException(\"Driver for test database type [\" + type + \"] is not available\", ex);\n\t\t}\n\t}\n\n\t/**\n\t * Customize the default configurer for the given embedded database type.\n\t * <p>The {@code customizer} typically uses\n\t * {@link EmbeddedDatabaseConfigurerDelegate} to customize things as necessary.\n\t * @param type the {@linkplain EmbeddedDatabaseType embedded database type}\n\t * @param customizer the customizer to return based on the default\n\t * @return the customized configurer instance\n\t * @throws IllegalStateException if the driver for the specified database type is not available\n\t */\n\tpublic static EmbeddedDatabaseConfigurer customizeConfigurer(\n\t\t\tEmbeddedDatabaseType type, UnaryOperator<EmbeddedDatabaseConfigurer> customizer) {\n\n\t\tEmbeddedDatabaseConfigurer defaultConfigurer = getConfigurer(type);\n\t\treturn customizer.apply(defaultConfigurer);\n\t}\n\n}"
  },
  "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseConfigurers#customizeConfigurer(type,customizer)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the default configurer for the given embedded database type.\n\t * <p>The {@code customizer} typically uses\n\t * {@link EmbeddedDatabaseConfigurerDelegate} to customize things as necessary.\n\t * @param type the {@linkplain EmbeddedDatabaseType embedded database type}\n\t * @param customizer the customizer to return based on the default\n\t * @return the customized configurer instance\n\t * @throws IllegalStateException if the driver for the specified database type is not available\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "customizer"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "EmbeddedDatabaseConfigurer",
    "signature": "public EmbeddedDatabaseConfigurer customizeConfigurer(EmbeddedDatabaseType type, UnaryOperator<EmbeddedDatabaseConfigurer> customizer)",
    "source_code": "\tpublic static EmbeddedDatabaseConfigurer customizeConfigurer("
  },
  "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseConfigurers#getConfigurer(type)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a configurer instance for the given embedded database type.\n\t * @param type the {@linkplain EmbeddedDatabaseType embedded database type}\n\t * @return the configurer instance\n\t * @throws IllegalStateException if the driver for the specified database type is not available\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "return": "EmbeddedDatabaseConfigurer",
    "signature": "public EmbeddedDatabaseConfigurer getConfigurer(EmbeddedDatabaseType type)",
    "source_code": "\tpublic static EmbeddedDatabaseConfigurer getConfigurer(EmbeddedDatabaseType type) {\n\t\tAssert.notNull(type, \"EmbeddedDatabaseType is required\");\n\t\ttry {\n\t\t\treturn switch (type) {\n\t\t\t\tcase HSQL -> HsqlEmbeddedDatabaseConfigurer.getInstance();\n\t\t\t\tcase H2 -> H2EmbeddedDatabaseConfigurer.getInstance();\n\t\t\t\tcase DERBY -> DerbyEmbeddedDatabaseConfigurer.getInstance();\n\t\t\t};\n\t\t}\n\t\tcatch (ClassNotFoundException | NoClassDefFoundError ex) {\n\t\t\tthrow new IllegalStateException(\"Driver for test database type [\" + type + \"] is not available\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Helper bean for registering {@link JmsListenerEndpoint} with a {@link JmsListenerEndpointRegistry}.\n *\n * @author Stephane Nicoll\n * @author Juergen Hoeller\n * @since 4.1\n * @see org.springframework.jms.annotation.JmsListenerConfigurer\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class JmsListenerEndpointRegistrar",
    "source_code": "public class JmsListenerEndpointRegistrar implements BeanFactoryAware, InitializingBean {\n\n\t@Nullable\n\tprivate JmsListenerEndpointRegistry endpointRegistry;\n\n\t@Nullable\n\tprivate MessageHandlerMethodFactory messageHandlerMethodFactory;\n\n\t@Nullable\n\tprivate JmsListenerContainerFactory<?> containerFactory;\n\n\t@Nullable\n\tprivate String containerFactoryBeanName;\n\n\t@Nullable\n\tprivate BeanFactory beanFactory;\n\n\tprivate final List<JmsListenerEndpointDescriptor> endpointDescriptors = new ArrayList<>();\n\n\tprivate boolean startImmediately;\n\n\tprivate Object mutex = this.endpointDescriptors;\n\n\n\t/**\n\t * Set the {@link JmsListenerEndpointRegistry} instance to use.\n\t */\n\tpublic void setEndpointRegistry(@Nullable JmsListenerEndpointRegistry endpointRegistry) {\n\t\tthis.endpointRegistry = endpointRegistry;\n\t}\n\n\t/**\n\t * Return the {@link JmsListenerEndpointRegistry} instance for this\n\t * registrar, may be {@code null}.\n\t */\n\t@Nullable\n\tpublic JmsListenerEndpointRegistry getEndpointRegistry() {\n\t\treturn this.endpointRegistry;\n\t}\n\n\t/**\n\t * Set the {@link MessageHandlerMethodFactory} to use to configure the message\n\t * listener responsible to serve an endpoint detected by this processor.\n\t * <p>By default, {@link DefaultMessageHandlerMethodFactory} is used and it\n\t * can be configured further to support additional method arguments\n\t * or to customize conversion and validation support. See\n\t * {@link DefaultMessageHandlerMethodFactory} javadoc for more details.\n\t */\n\tpublic void setMessageHandlerMethodFactory(@Nullable MessageHandlerMethodFactory messageHandlerMethodFactory) {\n\t\tthis.messageHandlerMethodFactory = messageHandlerMethodFactory;\n\t}\n\n\t/**\n\t * Return the custom {@link MessageHandlerMethodFactory} to use, if any.\n\t */\n\t@Nullable\n\tpublic MessageHandlerMethodFactory getMessageHandlerMethodFactory() {\n\t\treturn this.messageHandlerMethodFactory;\n\t}\n\n\t/**\n\t * Set the {@link JmsListenerContainerFactory} to use in case a {@link JmsListenerEndpoint}\n\t * is registered with a {@code null} container factory.\n\t * <p>Alternatively, the bean name of the {@link JmsListenerContainerFactory} to use\n\t * can be specified for a lazy lookup, see {@link #setContainerFactoryBeanName}.\n\t */\n\tpublic void setContainerFactory(JmsListenerContainerFactory<?> containerFactory) {\n\t\tthis.containerFactory = containerFactory;\n\t}\n\n\t/**\n\t * Set the bean name of the {@link JmsListenerContainerFactory} to use in case\n\t * a {@link JmsListenerEndpoint} is registered with a {@code null} container factory.\n\t * Alternatively, the container factory instance can be registered directly:\n\t * see {@link #setContainerFactory(JmsListenerContainerFactory)}.\n\t * @see #setBeanFactory\n\t */\n\tpublic void setContainerFactoryBeanName(String containerFactoryBeanName) {\n\t\tthis.containerFactoryBeanName = containerFactoryBeanName;\n\t}\n\n\t/**\n\t * A {@link BeanFactory} only needs to be available in conjunction with\n\t * {@link #setContainerFactoryBeanName}.\n\t */\n\t@Override\n\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t\tif (beanFactory instanceof ConfigurableBeanFactory cbf) {\n\t\t\tthis.mutex = cbf.getSingletonMutex();\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic void afterPropertiesSet() {\n\t\tregisterAllEndpoints();\n\t}\n\n\tprotected void registerAllEndpoints() {\n\t\tAssert.state(this.endpointRegistry != null, \"No JmsListenerEndpointRegistry set\");\n\t\tsynchronized (this.mutex) {\n\t\t\tfor (JmsListenerEndpointDescriptor descriptor : this.endpointDescriptors) {\n\t\t\t\tthis.endpointRegistry.registerListenerContainer(\n\t\t\t\t\t\tdescriptor.endpoint, resolveContainerFactory(descriptor));\n\t\t\t}\n\t\t\tthis.startImmediately = true;  // trigger immediate startup\n\t\t}\n\t}\n\n\tprivate JmsListenerContainerFactory<?> resolveContainerFactory(JmsListenerEndpointDescriptor descriptor) {\n\t\tif (descriptor.containerFactory != null) {\n\t\t\treturn descriptor.containerFactory;\n\t\t}\n\t\telse if (this.containerFactory != null) {\n\t\t\treturn this.containerFactory;\n\t\t}\n\t\telse if (this.containerFactoryBeanName != null) {\n\t\t\tAssert.state(this.beanFactory != null, \"BeanFactory must be set to obtain container factory by bean name\");\n\t\t\t// Consider changing this if live change of the factory is required...\n\t\t\tthis.containerFactory = this.beanFactory.getBean(\n\t\t\t\t\tthis.containerFactoryBeanName, JmsListenerContainerFactory.class);\n\t\t\treturn this.containerFactory;\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\"Could not resolve the \" +\n\t\t\t\t\tJmsListenerContainerFactory.class.getSimpleName() + \" to use for [\" +\n\t\t\t\t\tdescriptor.endpoint + \"] no factory was given and no default is set.\");\n\t\t}\n\t}\n\n\t/**\n\t * Register a new {@link JmsListenerEndpoint} alongside the\n\t * {@link JmsListenerContainerFactory} to use to create the underlying container.\n\t * <p>The {@code factory} may be {@code null} if the default factory should be\n\t * used for the supplied endpoint.\n\t */\n\tpublic void registerEndpoint(JmsListenerEndpoint endpoint, @Nullable JmsListenerContainerFactory<?> factory) {\n\t\tAssert.notNull(endpoint, \"Endpoint must not be null\");\n\t\tAssert.hasText(endpoint.getId(), \"Endpoint id must be set\");\n\n\t\t// Factory may be null, we defer the resolution right before actually creating the container\n\t\tJmsListenerEndpointDescriptor descriptor = new JmsListenerEndpointDescriptor(endpoint, factory);\n\n\t\tsynchronized (this.mutex) {\n\t\t\tif (this.startImmediately) {  // register and start immediately\n\t\t\t\tAssert.state(this.endpointRegistry != null, \"No JmsListenerEndpointRegistry set\");\n\t\t\t\tthis.endpointRegistry.registerListenerContainer(descriptor.endpoint,\n\t\t\t\t\t\tresolveContainerFactory(descriptor), true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.endpointDescriptors.add(descriptor);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Register a new {@link JmsListenerEndpoint} using the default\n\t * {@link JmsListenerContainerFactory} to create the underlying container.\n\t * @see #setContainerFactory(JmsListenerContainerFactory)\n\t * @see #registerEndpoint(JmsListenerEndpoint, JmsListenerContainerFactory)\n\t */\n\tpublic void registerEndpoint(JmsListenerEndpoint endpoint) {\n\t\tregisterEndpoint(endpoint, null);\n\t}\n\n\n\tprivate static class JmsListenerEndpointDescriptor {\n\n\t\tpublic final JmsListenerEndpoint endpoint;\n\n\t\t@Nullable\n\t\tpublic final JmsListenerContainerFactory<?> containerFactory;\n\n\t\tpublic JmsListenerEndpointDescriptor(JmsListenerEndpoint endpoint,\n\t\t\t\t@Nullable JmsListenerContainerFactory<?> containerFactory) {\n\n\t\t\tthis.endpoint = endpoint;\n\t\t\tthis.containerFactory = containerFactory;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tregisterAllEndpoints();\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#getEndpointRegistry()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link JmsListenerEndpointRegistry} instance for this\n\t * registrar, may be {@code null}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "JmsListenerEndpointRegistry",
    "signature": "public JmsListenerEndpointRegistry getEndpointRegistry()",
    "source_code": "\tpublic JmsListenerEndpointRegistry getEndpointRegistry() {\n\t\treturn this.endpointRegistry;\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#getMessageHandlerMethodFactory()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the custom {@link MessageHandlerMethodFactory} to use, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "MessageHandlerMethodFactory",
    "signature": "public MessageHandlerMethodFactory getMessageHandlerMethodFactory()",
    "source_code": "\tpublic MessageHandlerMethodFactory getMessageHandlerMethodFactory() {\n\t\treturn this.messageHandlerMethodFactory;\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#registerAllEndpoints()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "void",
    "signature": "protected void registerAllEndpoints()",
    "source_code": "\tprotected void registerAllEndpoints() {\n\t\tAssert.state(this.endpointRegistry != null, \"No JmsListenerEndpointRegistry set\");\n\t\tsynchronized (this.mutex) {\n\t\t\tfor (JmsListenerEndpointDescriptor descriptor : this.endpointDescriptors) {\n\t\t\t\tthis.endpointRegistry.registerListenerContainer(\n\t\t\t\t\t\tdescriptor.endpoint, resolveContainerFactory(descriptor));\n\t\t\t}\n\t\t\tthis.startImmediately = true;  // trigger immediate startup\n\t\t}\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#registerEndpoint(endpoint)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a new {@link JmsListenerEndpoint} using the default\n\t * {@link JmsListenerContainerFactory} to create the underlying container.\n\t * @see #setContainerFactory(JmsListenerContainerFactory)\n\t * @see #registerEndpoint(JmsListenerEndpoint, JmsListenerContainerFactory)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "endpoint"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "void",
    "signature": "public void registerEndpoint(JmsListenerEndpoint endpoint)",
    "source_code": "\tpublic void registerEndpoint(JmsListenerEndpoint endpoint) {\n\t\tregisterEndpoint(endpoint, null);\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#registerEndpoint(endpoint,factory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a new {@link JmsListenerEndpoint} alongside the\n\t * {@link JmsListenerContainerFactory} to use to create the underlying container.\n\t * <p>The {@code factory} may be {@code null} if the default factory should be\n\t * used for the supplied endpoint.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "endpoint",
      "factory"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "void",
    "signature": "public void registerEndpoint(JmsListenerEndpoint endpoint, @Nullable JmsListenerContainerFactory<?> factory)",
    "source_code": "\tpublic void registerEndpoint(JmsListenerEndpoint endpoint, @Nullable JmsListenerContainerFactory<?> factory) {\n\t\tAssert.notNull(endpoint, \"Endpoint must not be null\");\n\t\tAssert.hasText(endpoint.getId(), \"Endpoint id must be set\");\n\n\t\t// Factory may be null, we defer the resolution right before actually creating the container\n\t\tJmsListenerEndpointDescriptor descriptor = new JmsListenerEndpointDescriptor(endpoint, factory);\n\n\t\tsynchronized (this.mutex) {\n\t\t\tif (this.startImmediately) {  // register and start immediately\n\t\t\t\tAssert.state(this.endpointRegistry != null, \"No JmsListenerEndpointRegistry set\");\n\t\t\t\tthis.endpointRegistry.registerListenerContainer(descriptor.endpoint,\n\t\t\t\t\t\tresolveContainerFactory(descriptor), true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.endpointDescriptors.add(descriptor);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A {@link BeanFactory} only needs to be available in conjunction with\n\t * {@link #setContainerFactoryBeanName}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "void",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t\tif (beanFactory instanceof ConfigurableBeanFactory cbf) {\n\t\t\tthis.mutex = cbf.getSingletonMutex();\n\t\t}\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#setContainerFactory(containerFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link JmsListenerContainerFactory} to use in case a {@link JmsListenerEndpoint}\n\t * is registered with a {@code null} container factory.\n\t * <p>Alternatively, the bean name of the {@link JmsListenerContainerFactory} to use\n\t * can be specified for a lazy lookup, see {@link #setContainerFactoryBeanName}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "containerFactory"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "void",
    "signature": "public void setContainerFactory(JmsListenerContainerFactory<?> containerFactory)",
    "source_code": "\tpublic void setContainerFactory(JmsListenerContainerFactory<?> containerFactory) {\n\t\tthis.containerFactory = containerFactory;\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#setContainerFactoryBeanName(containerFactoryBeanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the bean name of the {@link JmsListenerContainerFactory} to use in case\n\t * a {@link JmsListenerEndpoint} is registered with a {@code null} container factory.\n\t * Alternatively, the container factory instance can be registered directly:\n\t * see {@link #setContainerFactory(JmsListenerContainerFactory)}.\n\t * @see #setBeanFactory\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "containerFactoryBeanName"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "void",
    "signature": "public void setContainerFactoryBeanName(String containerFactoryBeanName)",
    "source_code": "\tpublic void setContainerFactoryBeanName(String containerFactoryBeanName) {\n\t\tthis.containerFactoryBeanName = containerFactoryBeanName;\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#setEndpointRegistry(endpointRegistry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link JmsListenerEndpointRegistry} instance to use.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "endpointRegistry"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "void",
    "signature": "public void setEndpointRegistry(@Nullable JmsListenerEndpointRegistry endpointRegistry)",
    "source_code": "\tpublic void setEndpointRegistry(@Nullable JmsListenerEndpointRegistry endpointRegistry) {\n\t\tthis.endpointRegistry = endpointRegistry;\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#setMessageHandlerMethodFactory(messageHandlerMethodFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link MessageHandlerMethodFactory} to use to configure the message\n\t * listener responsible to serve an endpoint detected by this processor.\n\t * <p>By default, {@link DefaultMessageHandlerMethodFactory} is used and it\n\t * can be configured further to support additional method arguments\n\t * or to customize conversion and validation support. See\n\t * {@link DefaultMessageHandlerMethodFactory} javadoc for more details.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageHandlerMethodFactory"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "void",
    "signature": "public void setMessageHandlerMethodFactory(@Nullable MessageHandlerMethodFactory messageHandlerMethodFactory)",
    "source_code": "\tpublic void setMessageHandlerMethodFactory(@Nullable MessageHandlerMethodFactory messageHandlerMethodFactory) {\n\t\tthis.messageHandlerMethodFactory = messageHandlerMethodFactory;\n\t}"
  },
  "org.springframework.jms.config.endpoint": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "signature": "public JmsListenerEndpoint endpoint",
    "source_code": "\t\tpublic final JmsListenerEndpoint endpoint;",
    "type": "JmsListenerEndpoint"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#setVirtualThreads(virtualThreads)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether the default {@link SimpleAsyncTaskExecutor} should be\n\t * configured to use virtual threads instead of platform threads, for\n\t * efficient blocking behavior in listener threads on Java 21 or higher.\n\t * This is off by default, setting up one platform thread per consumer.\n\t * <p>Only applicable if the internal default executor is in use rather than\n\t * an externally provided {@link #setTaskExecutor TaskExecutor} instance.\n\t * The thread name prefix for virtual threads will be derived from the\n\t * listener container's bean name, just like with default platform threads.\n\t * <p>Alternatively, pass in a virtual threads based executor through\n\t * {@link #setTaskExecutor} (with externally defined thread naming).\n\t * <p>Consider specifying concurrency limits through {@link #setConcurrency}\n\t * or {@link #setConcurrentConsumers}/{@link #setMaxConcurrentConsumers},\n\t * for potential dynamic scaling. This works fine with the default executor;\n\t * see {@link #setIdleReceivesPerTaskLimit} with its effective default of 10.\n\t * @since 6.2\n\t * @see #setTaskExecutor\n\t * @see SimpleAsyncTaskExecutor#setVirtualThreads\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "virtualThreads"
    ],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "void",
    "signature": "public void setVirtualThreads(boolean virtualThreads)",
    "source_code": "\tpublic void setVirtualThreads(boolean virtualThreads) {\n\t\tthis.virtualThreads = virtualThreads;\n\t}"
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#brokerChannelExecutor(clientInboundChannel,clientOutboundChannel)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel"
    ],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "TaskExecutor",
    "signature": "public TaskExecutor brokerChannelExecutor(AbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel)",
    "source_code": "\tpublic TaskExecutor brokerChannelExecutor("
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#clientInboundChannelExecutor()": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "TaskExecutor",
    "signature": "public TaskExecutor clientInboundChannelExecutor()",
    "source_code": "\tpublic TaskExecutor clientInboundChannelExecutor() {\n\t\tChannelRegistration registration = getClientInboundChannelRegistration();\n\t\tTaskExecutor executor = getTaskExecutor(registration, \"clientInboundChannel-\", this::defaultTaskExecutor);\n\t\tif (executor instanceof ExecutorConfigurationSupport executorSupport) {\n\t\t\texecutorSupport.setPhase(getPhase());\n\t\t}\n\t\treturn executor;\n\t}"
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#clientOutboundChannelExecutor()": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "TaskExecutor",
    "signature": "public TaskExecutor clientOutboundChannelExecutor()",
    "source_code": "\tpublic TaskExecutor clientOutboundChannelExecutor() {\n\t\tChannelRegistration registration = getClientOutboundChannelRegistration();\n\t\tTaskExecutor executor = getTaskExecutor(registration, \"clientOutboundChannel-\", this::defaultTaskExecutor);\n\t\tif (executor instanceof ExecutorConfigurationSupport executorSupport) {\n\t\t\texecutorSupport.setPhase(getPhase());\n\t\t}\n\t\treturn executor;\n\t}"
  },
  "org.springframework.mock.web.MockHttpServletResponse#sendRedirect(url,sc,clearBuffer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "sc",
      "clearBuffer"
    ],
    "position": {
      "column": 1,
      "line": 633
    },
    "return": "void",
    "signature": "public void sendRedirect(String url, int sc, boolean clearBuffer)",
    "source_code": "\tpublic void sendRedirect(String url, int sc, boolean clearBuffer) throws IOException {\n\t\tAssert.state(!isCommitted(), \"Cannot send redirect - response is already committed\");\n\t\tAssert.notNull(url, \"Redirect URL must not be null\");\n\t\tsetHeader(HttpHeaders.LOCATION, url);\n\t\tsetStatus(sc);\n\t\tsetCommitted(true);\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#afterSingletonsInstantiated()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 609
    },
    "return": "void",
    "signature": "public void afterSingletonsInstantiated()",
    "source_code": "\tpublic void afterSingletonsInstantiated() {\n\t\t// Enforce completion of asynchronous Hibernate initialization before context refresh completion.\n\t\tif (this.sessionFactory instanceof InfrastructureProxy proxy) {\n\t\t\tproxy.getWrappedObject();\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.AbstractEntityManagerFactoryBean#afterSingletonsInstantiated()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 411
    },
    "return": "void",
    "signature": "public void afterSingletonsInstantiated()",
    "source_code": "\tpublic void afterSingletonsInstantiated() {\n\t\t// Enforce completion of asynchronous JPA initialization before context refresh completion.\n\t\tgetNativeEntityManagerFactory();\n\t}"
  },
  "org.springframework.scheduling.concurrent.DEFAULT_PHASE": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * The default phase for an executor {@link SmartLifecycle}: {@code Integer.MAX_VALUE / 2}.\n\t * <p>This is different from the default phase {@code Integer.MAX_VALUE} associated with\n\t * other {@link SmartLifecycle} implementations, putting the typically auto-started\n\t * executor/scheduler beans into an earlier startup phase and a later shutdown phase while\n\t * still leaving room for regular {@link Lifecycle} components with the common phase 0.\n\t * @since 6.2\n\t * @see #getPhase()\n\t * @see SmartLifecycle#DEFAULT_PHASE\n\t * @see org.springframework.context.support.DefaultLifecycleProcessor#setTimeoutPerShutdownPhase\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "signature": "public int DEFAULT_PHASE",
    "source_code": "\tpublic static final int DEFAULT_PHASE = Integer.MAX_VALUE / 2;",
    "type": "int"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#execute(task)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "void",
    "signature": "public void execute(Runnable task)",
    "source_code": "\tpublic void execute(Runnable task) {\n\t\tsuper.execute(TaskUtils.decorateTaskWithErrorHandler(task, this.errorHandler, false));\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#setErrorHandler(errorHandler)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide an {@link ErrorHandler} strategy.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorHandler"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "void",
    "signature": "public void setErrorHandler(ErrorHandler errorHandler)",
    "source_code": "\tpublic void setErrorHandler(ErrorHandler errorHandler) {\n\t\tAssert.notNull(errorHandler, \"ErrorHandler must not be null\");\n\t\tthis.errorHandler = errorHandler;\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#submit(task)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 250
    },
    "return": "Future<T>",
    "signature": "public Future<T> submit(Callable<T> task)",
    "source_code": "\tpublic <T> Future<T> submit(Callable<T> task) {\n\t\treturn super.submit(new DelegatingErrorHandlingCallable<>(task, this.errorHandler));\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#submitListenable(task)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "ListenableFuture<T>",
    "signature": "public ListenableFuture<T> submitListenable(Callable<T> task)",
    "source_code": "\tpublic <T> ListenableFuture<T> submitListenable(Callable<T> task) {\n\t\treturn super.submitListenable(new DelegatingErrorHandlingCallable<>(task, this.errorHandler));\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#call()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 478
    },
    "return": "V",
    "signature": "public V call()",
    "source_code": "\t\tpublic V call() throws Exception {\n\t\t\ttry {\n\t\t\t\treturn this.delegate.call();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthis.errorHandler.handleError(ex);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#cancel(mayInterruptIfRunning)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mayInterruptIfRunning"
    ],
    "position": {
      "column": 1,
      "line": 512
    },
    "return": "boolean",
    "signature": "public boolean cancel(boolean mayInterruptIfRunning)",
    "source_code": "\t\tpublic boolean cancel(boolean mayInterruptIfRunning) {\n\t\t\treturn this.future.cancel(mayInterruptIfRunning);\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#compareTo(o)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o"
    ],
    "position": {
      "column": 1,
      "line": 547
    },
    "return": "int",
    "signature": "public int compareTo(Delayed o)",
    "source_code": "\t\tpublic int compareTo(Delayed o) {\n\t\t\treturn this.future.compareTo(o);\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#decorateTask(callable,task)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "callable",
      "task"
    ],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "RunnableScheduledFuture<V>",
    "signature": "protected RunnableScheduledFuture<V> decorateTask(Callable<V> callable, RunnableScheduledFuture<V> task)",
    "source_code": "\t\t\tprotected <V> RunnableScheduledFuture<V> decorateTask(Callable<V> callable, RunnableScheduledFuture<V> task) {\n\t\t\t\treturn decorateTaskIfNecessary(task);\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#decorateTask(runnable,task)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "runnable",
      "task"
    ],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "RunnableScheduledFuture<V>",
    "signature": "protected RunnableScheduledFuture<V> decorateTask(Runnable runnable, RunnableScheduledFuture<V> task)",
    "source_code": "\t\t\tprotected <V> RunnableScheduledFuture<V> decorateTask(Runnable runnable, RunnableScheduledFuture<V> task) {\n\t\t\t\treturn decorateTaskIfNecessary(task);\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#get()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 527
    },
    "return": "V",
    "signature": "public V get()",
    "source_code": "\t\tpublic V get() throws InterruptedException, ExecutionException {\n\t\t\treturn this.future.get();\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#get(timeout,unit)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeout",
      "unit"
    ],
    "position": {
      "column": 1,
      "line": 532
    },
    "return": "V",
    "signature": "public V get(long timeout, TimeUnit unit)",
    "source_code": "\t\tpublic V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n\t\t\treturn this.future.get(timeout, unit);\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#getDelay(unit)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "unit"
    ],
    "position": {
      "column": 1,
      "line": 542
    },
    "return": "long",
    "signature": "public long getDelay(TimeUnit unit)",
    "source_code": "\t\tpublic long getDelay(TimeUnit unit) {\n\t\t\treturn this.future.getDelay(unit);\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#isCancelled()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 517
    },
    "return": "boolean",
    "signature": "public boolean isCancelled()",
    "source_code": "\t\tpublic boolean isCancelled() {\n\t\t\treturn this.future.isCancelled();\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#isDone()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 522
    },
    "return": "boolean",
    "signature": "public boolean isDone()",
    "source_code": "\t\tpublic boolean isDone() {\n\t\t\treturn this.future.isDone();\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#isPeriodic()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 537
    },
    "return": "boolean",
    "signature": "public boolean isPeriodic()",
    "source_code": "\t\tpublic boolean isPeriodic() {\n\t\t\treturn this.future.isPeriodic();\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#run()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 507
    },
    "return": "void",
    "signature": "public void run()",
    "source_code": "\t\tpublic void run() {\n\t\t\tthis.decoratedRunnable.run();\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#setTaskDecorator(taskDecorator)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify a custom {@link TaskDecorator} to be applied to any {@link Runnable}\n\t * about to be executed.\n\t * <p>Note that such a decorator is not being applied to the user-supplied\n\t * {@code Runnable}/{@code Callable} but rather to the scheduled execution\n\t * callback (a wrapper around the user-supplied task).\n\t * <p>The primary use case is to set some execution context around the task's\n\t * invocation, or to provide some monitoring/statistics for task execution.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "taskDecorator"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "void",
    "signature": "public void setTaskDecorator(TaskDecorator taskDecorator)",
    "source_code": "\tpublic void setTaskDecorator(TaskDecorator taskDecorator) {\n\t\tthis.taskDecorator = taskDecorator;\n\t}"
  },
  "org.springframework.scheduling.config.Status": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Status of the task execution outcome.\n\t */",
    "kind": "enum",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "signature": "public enum Status",
    "source_code": "\tpublic enum Status {\n\t\t/**\n\t\t * The task has not been executed so far.\n\t\t */\n\t\tNONE,\n\t\t/**\n\t\t * The task execution has been started and is ongoing.\n\t\t */\n\t\tSTARTED,\n\t\t/**\n\t\t * The task execution finished successfully.\n\t\t */\n\t\tSUCCESS,\n\t\t/**\n\t\t * The task execution finished with an error.\n\t\t */\n\t\tERROR\n\t}"
  },
  "org.springframework.scheduling.config.TaskExecutionOutcome": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Outcome of a {@link Task} execution.\n * @param executionTime the instant when the task execution started, {@code null} if the task has not started.\n * @param status        the {@link Status} of the execution outcome.\n * @param throwable     the exception thrown from the task execution, if any.\n * @author Brian Clozel\n * @since 6.2\n */",
    "kind": "record",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 32
    },
    "signature": "public record TaskExecutionOutcome",
    "source_code": "public record TaskExecutionOutcome(@Nullable Instant executionTime, Status status, @Nullable Throwable throwable) {\n\n\tTaskExecutionOutcome start(Instant executionTime) {\n\t\treturn new TaskExecutionOutcome(executionTime, Status.STARTED, null);\n\t}\n\n\tTaskExecutionOutcome success() {\n\t\tAssert.state(this.executionTime != null, \"Task has not been started yet\");\n\t\treturn new TaskExecutionOutcome(this.executionTime, Status.SUCCESS, null);\n\t}\n\n\tTaskExecutionOutcome failure(Throwable throwable) {\n\t\tAssert.state(this.executionTime != null, \"Task has not been started yet\");\n\t\treturn new TaskExecutionOutcome(this.executionTime, Status.ERROR, throwable);\n\t}\n\n\tstatic TaskExecutionOutcome create() {\n\t\treturn new TaskExecutionOutcome(null, Status.NONE, null);\n\t}\n\n\n\t/**\n\t * Status of the task execution outcome.\n\t */\n\tpublic enum Status {\n\t\t/**\n\t\t * The task has not been executed so far.\n\t\t */\n\t\tNONE,\n\t\t/**\n\t\t * The task execution has been started and is ongoing.\n\t\t */\n\t\tSTARTED,\n\t\t/**\n\t\t * The task execution finished successfully.\n\t\t */\n\t\tSUCCESS,\n\t\t/**\n\t\t * The task execution finished with an error.\n\t\t */\n\t\tERROR\n\t}\n}"
  },
  "org.springframework.scheduling.config.TaskExecutionOutcome#<init>(executionTime,status,throwable)": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Outcome of a {@link Task} execution.\n * @param executionTime the instant when the task execution started, {@code null} if the task has not started.\n * @param status        the {@link Status} of the execution outcome.\n * @param throwable     the exception thrown from the task execution, if any.\n * @author Brian Clozel\n * @since 6.2\n */",
    "kind": "constructor",
    "modifiers": [
      "public"
    ],
    "params": [
      "executionTime",
      "status",
      "throwable"
    ],
    "position": {
      "column": 1,
      "line": 32
    },
    "signature": "public TaskExecutionOutcome(@Nullable Instant executionTime, Status status, @Nullable Throwable throwable)",
    "source_code": "public record TaskExecutionOutcome(@Nullable Instant executionTime, Status status, @Nullable Throwable throwable) {\n\n\tTaskExecutionOutcome start(Instant executionTime) {\n\t\treturn new TaskExecutionOutcome(executionTime, Status.STARTED, null);\n\t}\n\n\tTaskExecutionOutcome success() {\n\t\tAssert.state(this.executionTime != null, \"Task has not been started yet\");\n\t\treturn new TaskExecutionOutcome(this.executionTime, Status.SUCCESS, null);\n\t}\n\n\tTaskExecutionOutcome failure(Throwable throwable) {\n\t\tAssert.state(this.executionTime != null, \"Task has not been started yet\");\n\t\treturn new TaskExecutionOutcome(this.executionTime, Status.ERROR, throwable);\n\t}\n\n\tstatic TaskExecutionOutcome create() {\n\t\treturn new TaskExecutionOutcome(null, Status.NONE, null);\n\t}\n\n\n\t/**\n\t * Status of the task execution outcome.\n\t */\n\tpublic enum Status {\n\t\t/**\n\t\t * The task has not been executed so far.\n\t\t */\n\t\tNONE,\n\t\t/**\n\t\t * The task execution has been started and is ongoing.\n\t\t */\n\t\tSTARTED,\n\t\t/**\n\t\t * The task execution finished successfully.\n\t\t */\n\t\tSUCCESS,\n\t\t/**\n\t\t * The task execution finished with an error.\n\t\t */\n\t\tERROR\n\t}\n}"
  },
  "org.springframework.test.context.bean.override.<unknown>#copyBeanDefinitionDetails(from,to)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy certain details of a {@link BeanDefinition} to the definition created by\n\t * this processor for a given {@link OverrideMetadata}.\n\t * <p>The default implementation copies the {@linkplain BeanDefinition#isPrimary()\n\t * primary flag}, @{@linkplain BeanDefinition#isFallback() fallback flag}\n\t * and the {@linkplain BeanDefinition#getScope() scope}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "from",
      "to"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "void",
    "signature": "protected void copyBeanDefinitionDetails(BeanDefinition from, RootBeanDefinition to)",
    "source_code": "\tprotected void copyBeanDefinitionDetails(BeanDefinition from, RootBeanDefinition to) {\n\t\tto.setPrimary(from.isPrimary());\n\t\tto.setFallback(from.isFallback());\n\t\tto.setScope(from.getScope());\n\t}"
  },
  "org.springframework.test.context.bean.override.<unknown>#customizeContext(context,mergedConfig)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "mergedConfig"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "void",
    "signature": "public void customizeContext(ConfigurableApplicationContext context, MergedContextConfiguration mergedConfig)",
    "source_code": "\tpublic void customizeContext(ConfigurableApplicationContext context, MergedContextConfiguration mergedConfig) {\n\t\tif (!(context instanceof BeanDefinitionRegistry registry)) {\n\t\t\tthrow new IllegalStateException(\"Cannot process bean overrides with an ApplicationContext \" +\n\t\t\t\t\t\"that doesn't implement BeanDefinitionRegistry: \" + context.getClass());\n\t\t}\n\t\tregisterInfrastructure(registry);\n\t}"
  },
  "org.springframework.test.context.bean.override.<unknown>#equals(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "boolean",
    "signature": "public boolean equals(Object other)",
    "source_code": "\tpublic boolean equals(Object other) {\n\t\tif (other == this) {\n\t\t\treturn true;\n\t\t}\n\t\tif (other == null || other.getClass() != getClass()) {\n\t\t\treturn false;\n\t\t}\n\t\tBeanOverrideContextCustomizer that = (BeanOverrideContextCustomizer) other;\n\t\treturn this.metadata.equals(that.metadata);\n\t}"
  },
  "org.springframework.test.context.bean.override.<unknown>#getEarlyBeanReference(bean,beanName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "Object",
    "signature": "public Object getEarlyBeanReference(Object bean, String beanName)",
    "source_code": "\t\tpublic Object getEarlyBeanReference(Object bean, String beanName) throws BeansException {\n\t\t\tif (bean instanceof FactoryBean) {\n\t\t\t\treturn bean;\n\t\t\t}\n\t\t\tthis.earlyReferences.put(getCacheKey(bean, beanName), bean);\n\t\t\treturn this.overrideRegistrar.wrapIfNecessary(bean, beanName);\n\t\t}"
  },
  "org.springframework.test.context.bean.override.<unknown>#getOrder()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "int",
    "signature": "public int getOrder()",
    "source_code": "\t\tpublic int getOrder() {\n\t\t\treturn Ordered.HIGHEST_PRECEDENCE;\n\t\t}"
  },
  "org.springframework.test.context.bean.override.<unknown>#hashCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.metadata.hashCode();\n\t}"
  },
  "org.springframework.test.context.bean.override.<unknown>#postProcessAfterInitialization(bean,beanName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 301
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(Object bean, String beanName)",
    "source_code": "\t\tpublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n\t\t\tif (bean instanceof FactoryBean) {\n\t\t\t\treturn bean;\n\t\t\t}\n\t\t\tif (this.earlyReferences.remove(getCacheKey(bean, beanName)) != bean) {\n\t\t\t\treturn this.overrideRegistrar.wrapIfNecessary(bean, beanName);\n\t\t\t}\n\t\t\treturn bean;\n\t\t}"
  },
  "org.springframework.test.context.bean.override.<unknown>#postProcessBeanFactory(beanFactory)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "void",
    "signature": "public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)",
    "source_code": "\tpublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n\t\tif (!(beanFactory instanceof BeanDefinitionRegistry registry)) {\n\t\t\tthrow new IllegalStateException(\"Cannot process bean override with a BeanFactory \" +\n\t\t\t\t\t\"that doesn't implement BeanDefinitionRegistry: \" + beanFactory.getClass());\n\t\t}\n\t\tpostProcessWithRegistry(beanFactory, registry);\n\t}"
  },
  "org.springframework.test.context.bean.override.<unknown>#setBeanFactory(beanFactory)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "void",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n\t\tif (!(beanFactory instanceof ConfigurableBeanFactory cbf)) {\n\t\t\tthrow new IllegalStateException(\"Cannot process bean override with a BeanFactory \" +\n\t\t\t\t\t\"that doesn't implement ConfigurableBeanFactory: \" + beanFactory.getClass());\n\t\t}\n\t\tthis.beanFactory = cbf;\n\t}"
  },
  "org.springframework.test.context.bean.override.convention.<unknown>#createMetadata(overrideAnnotation,testClass,field)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "overrideAnnotation",
      "testClass",
      "field"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "TestBeanOverrideMetadata",
    "signature": "public TestBeanOverrideMetadata createMetadata(Annotation overrideAnnotation, Class<?> testClass, Field field)",
    "source_code": "\tpublic TestBeanOverrideMetadata createMetadata(Annotation overrideAnnotation, Class<?> testClass, Field field) {\n\t\tif (!(overrideAnnotation instanceof TestBean testBeanAnnotation)) {\n\t\t\tthrow new IllegalStateException(\"Invalid annotation passed to %s: expected @TestBean on field %s.%s\"\n\t\t\t\t\t.formatted(getClass().getSimpleName(), field.getDeclaringClass().getName(), field.getName()));\n\t\t}\n\t\tMethod overrideMethod;\n\t\tString methodName = testBeanAnnotation.methodName();\n\t\tif (!methodName.isBlank()) {\n\t\t\t// If the user specified an explicit method name, search for that.\n\t\t\toverrideMethod = findTestBeanFactoryMethod(testClass, field.getType(), methodName);\n\t\t}\n\t\telse {\n\t\t\t// Otherwise, search for candidate factory methods the field name\n\t\t\t// or explicit bean name (if any).\n\t\t\tList<String> candidateMethodNames = new ArrayList<>();\n\t\t\tcandidateMethodNames.add(field.getName());\n\n\t\t\tString beanName = testBeanAnnotation.name();\n\t\t\tif (StringUtils.hasText(beanName)) {\n\t\t\t\tcandidateMethodNames.add(beanName);\n\t\t\t}\n\t\t\toverrideMethod = findTestBeanFactoryMethod(testClass, field.getType(), candidateMethodNames);\n\t\t}\n\t\tString beanName = (StringUtils.hasText(testBeanAnnotation.name()) ? testBeanAnnotation.name() : null);\n\t\treturn new TestBeanOverrideMetadata(field, ResolvableType.forField(field, testClass), beanName, overrideMethod);\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.<unknown>#createMetadata(overrideAnnotation,testClass,field)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "overrideAnnotation",
      "testClass",
      "field"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "return": "MockitoOverrideMetadata",
    "signature": "public MockitoOverrideMetadata createMetadata(Annotation overrideAnnotation, Class<?> testClass, Field field)",
    "source_code": "\tpublic MockitoOverrideMetadata createMetadata(Annotation overrideAnnotation, Class<?> testClass, Field field) {\n\t\tif (overrideAnnotation instanceof MockitoBean mockBean) {\n\t\t\treturn new MockitoBeanOverrideMetadata(field, ResolvableType.forField(field, testClass), mockBean);\n\t\t}\n\t\telse if (overrideAnnotation instanceof MockitoSpyBean spyBean) {\n\t\t\treturn new MockitoSpyBeanOverrideMetadata(field, ResolvableType.forField(field, testClass), spyBean);\n\t\t}\n\t\tthrow new IllegalStateException(String.format(\"Invalid annotation passed to MockitoBeanOverrideProcessor: \"\n\t\t\t\t+ \"expected @MockitoBean/@MockitoSpyBean on field %s.%s\",\n\t\t\t\tfield.getDeclaringClass().getName(), field.getName()));\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockReset": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Reset strategy used on a mock bean. Usually applied to a mock through the\n * {@link MockitoBean @MockitoBean} annotation but can also be directly applied\n * to any mock in the {@code ApplicationContext} using the static methods.\n *\n * @author Phillip Webb\n * @since 6.2\n * @see MockitoResetTestExecutionListener\n */",
    "kind": "enum",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public enum MockReset",
    "source_code": "public enum MockReset {\n\n\t/**\n\t * Reset the mock before the test method runs.\n\t */\n\tBEFORE,\n\n\t/**\n\t * Reset the mock after the test method runs.\n\t */\n\tAFTER,\n\n\t/**\n\t * Don't reset the mock.\n\t */\n\tNONE;\n\n\n\t/**\n\t * Create {@link MockSettings settings} to be used with mocks where reset\n\t * should occur before each test method runs.\n\t * @return mock settings\n\t */\n\tpublic static MockSettings before() {\n\t\treturn withSettings(BEFORE);\n\t}\n\n\t/**\n\t * Create {@link MockSettings settings} to be used with mocks where reset\n\t * should occur after each test method runs.\n\t * @return mock settings\n\t */\n\tpublic static MockSettings after() {\n\t\treturn withSettings(AFTER);\n\t}\n\n\t/**\n\t * Create {@link MockSettings settings} to be used with mocks where a\n\t * specific reset should occur.\n\t * @param reset the reset type\n\t * @return mock settings\n\t */\n\tpublic static MockSettings withSettings(MockReset reset) {\n\t\treturn apply(reset, Mockito.withSettings());\n\t}\n\n\t/**\n\t * Apply {@link MockReset} to existing {@link MockSettings settings}.\n\t * @param reset the reset type\n\t * @param settings the settings\n\t * @return the configured settings\n\t */\n\tpublic static MockSettings apply(MockReset reset, MockSettings settings) {\n\t\tAssert.notNull(settings, \"Settings must not be null\");\n\t\tif (reset != null && reset != NONE) {\n\t\t\tsettings.invocationListeners(new ResetInvocationListener(reset));\n\t\t}\n\t\treturn settings;\n\t}\n\n\t/**\n\t * Get the {@link MockReset} associated with the given mock.\n\t * @param mock the source mock\n\t * @return the reset type (never {@code null})\n\t */\n\tstatic MockReset get(Object mock) {\n\t\tMockReset reset = MockReset.NONE;\n\t\tMockingDetails mockingDetails = Mockito.mockingDetails(mock);\n\t\tif (mockingDetails.isMock()) {\n\t\t\tMockCreationSettings<?> settings = mockingDetails.getMockCreationSettings();\n\t\t\tList<InvocationListener> listeners = settings.getInvocationListeners();\n\t\t\tfor (Object listener : listeners) {\n\t\t\t\tif (listener instanceof ResetInvocationListener resetInvocationListener) {\n\t\t\t\t\treset = resetInvocationListener.getReset();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn reset;\n\t}\n\n\t/**\n\t * Dummy {@link InvocationListener} used to hold the {@link MockReset} value.\n\t */\n\tprivate static class ResetInvocationListener implements InvocationListener {\n\n\t\tprivate final MockReset reset;\n\n\t\tResetInvocationListener(MockReset reset) {\n\t\t\tthis.reset = reset;\n\t\t}\n\n\t\tMockReset getReset() {\n\t\t\treturn this.reset;\n\t\t}\n\n\t\t@Override\n\t\tpublic void reportInvocation(MethodInvocationReport methodInvocationReport) {\n\t\t}\n\n\t}\n\n}"
  },
  "org.springframework.test.context.bean.override.mockito.MockReset#after()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create {@link MockSettings settings} to be used with mocks where reset\n\t * should occur after each test method runs.\n\t * @return mock settings\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "MockSettings",
    "signature": "public MockSettings after()",
    "source_code": "\tpublic static MockSettings after() {\n\t\treturn withSettings(AFTER);\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockReset#apply(reset,settings)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply {@link MockReset} to existing {@link MockSettings settings}.\n\t * @param reset the reset type\n\t * @param settings the settings\n\t * @return the configured settings\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "reset",
      "settings"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "MockSettings",
    "signature": "public MockSettings apply(MockReset reset, MockSettings settings)",
    "source_code": "\tpublic static MockSettings apply(MockReset reset, MockSettings settings) {\n\t\tAssert.notNull(settings, \"Settings must not be null\");\n\t\tif (reset != null && reset != NONE) {\n\t\t\tsettings.invocationListeners(new ResetInvocationListener(reset));\n\t\t}\n\t\treturn settings;\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockReset#before()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create {@link MockSettings settings} to be used with mocks where reset\n\t * should occur before each test method runs.\n\t * @return mock settings\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "MockSettings",
    "signature": "public MockSettings before()",
    "source_code": "\tpublic static MockSettings before() {\n\t\treturn withSettings(BEFORE);\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockReset#reportInvocation(methodInvocationReport)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodInvocationReport"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "void",
    "signature": "public void reportInvocation(MethodInvocationReport methodInvocationReport)",
    "source_code": "\t\tpublic void reportInvocation(MethodInvocationReport methodInvocationReport) {\n\t\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockReset#withSettings(reset)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create {@link MockSettings settings} to be used with mocks where a\n\t * specific reset should occur.\n\t * @param reset the reset type\n\t * @return mock settings\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "reset"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "MockSettings",
    "signature": "public MockSettings withSettings(MockReset reset)",
    "source_code": "\tpublic static MockSettings withSettings(MockReset reset) {\n\t\treturn apply(reset, Mockito.withSettings());\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockitoResetTestExecutionListener": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * {@code TestExecutionListener} that resets any mock beans that have been marked\n * with a {@link MockReset}.\n *\n * @author Phillip Webb\n * @since 6.2\n * @see MockitoTestExecutionListener\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "signature": "public class MockitoResetTestExecutionListener",
    "source_code": "public class MockitoResetTestExecutionListener extends AbstractTestExecutionListener {\n\n\t/**\n\t * Executes before {@link org.springframework.test.context.bean.override.BeanOverrideTestExecutionListener}.\n\t */\n\t@Override\n\tpublic int getOrder() {\n\t\treturn Ordered.LOWEST_PRECEDENCE - 100;\n\t}\n\n\t@Override\n\tpublic void beforeTestMethod(TestContext testContext) throws Exception {\n\t\tif (MockitoTestExecutionListener.mockitoPresent && !NativeDetector.inNativeImage()) {\n\t\t\tresetMocks(testContext.getApplicationContext(), MockReset.BEFORE);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void afterTestMethod(TestContext testContext) throws Exception {\n\t\tif (MockitoTestExecutionListener.mockitoPresent && !NativeDetector.inNativeImage()) {\n\t\t\tresetMocks(testContext.getApplicationContext(), MockReset.AFTER);\n\t\t}\n\t}\n\n\tprivate void resetMocks(ApplicationContext applicationContext, MockReset reset) {\n\t\tif (applicationContext instanceof ConfigurableApplicationContext configurableContext) {\n\t\t\tresetMocks(configurableContext, reset);\n\t\t}\n\t}\n\n\tprivate void resetMocks(ConfigurableApplicationContext applicationContext, MockReset reset) {\n\t\tConfigurableListableBeanFactory beanFactory = applicationContext.getBeanFactory();\n\t\tString[] names = beanFactory.getBeanDefinitionNames();\n\t\tSet<String> instantiatedSingletons = new HashSet<>(Arrays.asList(beanFactory.getSingletonNames()));\n\t\tfor (String name : names) {\n\t\t\tBeanDefinition definition = beanFactory.getBeanDefinition(name);\n\t\t\tif (definition.isSingleton() && instantiatedSingletons.contains(name)) {\n\t\t\t\tObject bean = getBean(beanFactory, name);\n\t\t\t\tif (bean != null && reset.equals(MockReset.get(bean))) {\n\t\t\t\t\tMockito.reset(bean);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tMockitoBeans mockedBeans = beanFactory.getBean(MockitoBeans.class);\n\t\t\tfor (Object mockedBean : mockedBeans) {\n\t\t\t\tif (reset.equals(MockReset.get(mockedBean))) {\n\t\t\t\t\tMockito.reset(mockedBean);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Continue\n\t\t}\n\t\tif (applicationContext.getParent() != null) {\n\t\t\tresetMocks(applicationContext.getParent(), reset);\n\t\t}\n\t}\n\n\t@Nullable\n\tprivate Object getBean(ConfigurableListableBeanFactory beanFactory, String name) {\n\t\ttry {\n\t\t\tif (isStandardBeanOrSingletonFactoryBean(beanFactory, name)) {\n\t\t\t\treturn beanFactory.getBean(name);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\t// Continue\n\t\t}\n\t\treturn beanFactory.getSingleton(name);\n\t}\n\n\tprivate boolean isStandardBeanOrSingletonFactoryBean(ConfigurableListableBeanFactory beanFactory, String name) {\n\t\tString factoryBeanName = BeanFactory.FACTORY_BEAN_PREFIX + name;\n\t\tif (beanFactory.containsBean(factoryBeanName)) {\n\t\t\tFactoryBean<?> factoryBean = (FactoryBean<?>) beanFactory.getBean(factoryBeanName);\n\t\t\treturn factoryBean.isSingleton();\n\t\t}\n\t\treturn true;\n\t}\n\n}"
  },
  "org.springframework.test.context.bean.override.mockito.MockitoResetTestExecutionListener#afterTestMethod(testContext)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "void",
    "signature": "public void afterTestMethod(TestContext testContext)",
    "source_code": "\tpublic void afterTestMethod(TestContext testContext) throws Exception {\n\t\tif (MockitoTestExecutionListener.mockitoPresent && !NativeDetector.inNativeImage()) {\n\t\t\tresetMocks(testContext.getApplicationContext(), MockReset.AFTER);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockitoResetTestExecutionListener#beforeTestMethod(testContext)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "void",
    "signature": "public void beforeTestMethod(TestContext testContext)",
    "source_code": "\tpublic void beforeTestMethod(TestContext testContext) throws Exception {\n\t\tif (MockitoTestExecutionListener.mockitoPresent && !NativeDetector.inNativeImage()) {\n\t\t\tresetMocks(testContext.getApplicationContext(), MockReset.BEFORE);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockitoResetTestExecutionListener#getOrder()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Executes before {@link org.springframework.test.context.bean.override.BeanOverrideTestExecutionListener}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "int",
    "signature": "public int getOrder()",
    "source_code": "\tpublic int getOrder() {\n\t\treturn Ordered.LOWEST_PRECEDENCE - 100;\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockitoTestExecutionListener": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * {@code TestExecutionListener} that enables {@link MockitoBean @MockitoBean} and\n * {@link MockitoSpyBean @MockitoSpyBean} support. Also triggers\n * {@link MockitoAnnotations#openMocks(Object)} when any Mockito annotations are\n * used, primarily to support {@link Captor @Captor} annotations.\n *\n * <p>The automatic reset support for {@code @MockBean} and {@code @SpyBean} is\n * handled by the {@link MockitoResetTestExecutionListener}.\n *\n * @author Simon Basl\u00e9\n * @author Phillip Webb\n * @author Andy Wilkinson\n * @author Moritz Halbritter\n * @since 6.2\n * @see MockitoResetTestExecutionListener\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "public class MockitoTestExecutionListener",
    "source_code": "public class MockitoTestExecutionListener extends AbstractTestExecutionListener {\n\n\tprivate static final String MOCKS_ATTRIBUTE_NAME = MockitoTestExecutionListener.class.getName() + \".mocks\";\n\n\tstatic final boolean mockitoPresent = ClassUtils.isPresent(\"org.mockito.MockSettings\",\n\t\t\tMockitoTestExecutionListener.class.getClassLoader());\n\n\n\t/**\n\t * Executes before {@link DependencyInjectionTestExecutionListener}.\n\t */\n\t@Override\n\tpublic final int getOrder() {\n\t\treturn 1950;\n\t}\n\n\t@Override\n\tpublic void prepareTestInstance(TestContext testContext) throws Exception {\n\t\tif (mockitoPresent) {\n\t\t\tcloseMocks(testContext);\n\t\t\tinitMocks(testContext);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void beforeTestMethod(TestContext testContext) throws Exception {\n\t\tif (mockitoPresent && Boolean.TRUE.equals(\n\t\t\t\ttestContext.getAttribute(DependencyInjectionTestExecutionListener.REINJECT_DEPENDENCIES_ATTRIBUTE))) {\n\t\t\tcloseMocks(testContext);\n\t\t\tinitMocks(testContext);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void afterTestMethod(TestContext testContext) throws Exception {\n\t\tif (mockitoPresent) {\n\t\t\tcloseMocks(testContext);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void afterTestClass(TestContext testContext) throws Exception {\n\t\tif (mockitoPresent) {\n\t\t\tcloseMocks(testContext);\n\t\t}\n\t}\n\n\tprivate void initMocks(TestContext testContext) {\n\t\tif (hasMockitoAnnotations(testContext)) {\n\t\t\tObject testInstance = testContext.getTestInstance();\n\t\t\ttestContext.setAttribute(MOCKS_ATTRIBUTE_NAME, MockitoAnnotations.openMocks(testInstance));\n\t\t}\n\t}\n\n\tprivate void closeMocks(TestContext testContext) throws Exception {\n\t\tObject mocks = testContext.getAttribute(MOCKS_ATTRIBUTE_NAME);\n\t\tif (mocks instanceof AutoCloseable closeable) {\n\t\t\tcloseable.close();\n\t\t}\n\t}\n\n\tprivate boolean hasMockitoAnnotations(TestContext testContext) {\n\t\tMockitoAnnotationCollector collector = new MockitoAnnotationCollector();\n\t\tReflectionUtils.doWithFields(testContext.getTestClass(), collector);\n\t\treturn collector.hasAnnotations();\n\t}\n\n\n\t/**\n\t * {@link FieldCallback} that collects Mockito annotations.\n\t */\n\tprivate static final class MockitoAnnotationCollector implements FieldCallback {\n\n\t\tprivate final Set<Annotation> annotations = new LinkedHashSet<>();\n\n\t\t@Override\n\t\tpublic void doWith(Field field) throws IllegalArgumentException {\n\t\t\tfor (Annotation annotation : field.getAnnotations()) {\n\t\t\t\tif (annotation.annotationType().getPackageName().startsWith(\"org.mockito\")) {\n\t\t\t\t\tthis.annotations.add(annotation);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboolean hasAnnotations() {\n\t\t\treturn !this.annotations.isEmpty();\n\t\t}\n\n\t}\n\n}"
  },
  "org.springframework.test.context.bean.override.mockito.MockitoTestExecutionListener#afterTestClass(testContext)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "void",
    "signature": "public void afterTestClass(TestContext testContext)",
    "source_code": "\tpublic void afterTestClass(TestContext testContext) throws Exception {\n\t\tif (mockitoPresent) {\n\t\t\tcloseMocks(testContext);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockitoTestExecutionListener#afterTestMethod(testContext)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "void",
    "signature": "public void afterTestMethod(TestContext testContext)",
    "source_code": "\tpublic void afterTestMethod(TestContext testContext) throws Exception {\n\t\tif (mockitoPresent) {\n\t\t\tcloseMocks(testContext);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockitoTestExecutionListener#beforeTestMethod(testContext)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "void",
    "signature": "public void beforeTestMethod(TestContext testContext)",
    "source_code": "\tpublic void beforeTestMethod(TestContext testContext) throws Exception {\n\t\tif (mockitoPresent && Boolean.TRUE.equals(\n\t\t\t\ttestContext.getAttribute(DependencyInjectionTestExecutionListener.REINJECT_DEPENDENCIES_ATTRIBUTE))) {\n\t\t\tcloseMocks(testContext);\n\t\t\tinitMocks(testContext);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockitoTestExecutionListener#doWith(field)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void doWith(Field field)",
    "source_code": "\t\tpublic void doWith(Field field) throws IllegalArgumentException {\n\t\t\tfor (Annotation annotation : field.getAnnotations()) {\n\t\t\t\tif (annotation.annotationType().getPackageName().startsWith(\"org.mockito\")) {\n\t\t\t\t\tthis.annotations.add(annotation);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockitoTestExecutionListener#getOrder()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Executes before {@link DependencyInjectionTestExecutionListener}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "int",
    "signature": "public int getOrder()",
    "source_code": "\tpublic final int getOrder() {\n\t\treturn 1950;\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockitoTestExecutionListener#prepareTestInstance(testContext)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "void",
    "signature": "public void prepareTestInstance(TestContext testContext)",
    "source_code": "\tpublic void prepareTestInstance(TestContext testContext) throws Exception {\n\t\tif (mockitoPresent) {\n\t\t\tcloseMocks(testContext);\n\t\t\tinitMocks(testContext);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.support.CommonCachesTestExecutionListener": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * {@code TestExecutionListener} which makes sure that common caches are cleared\n * once they are no longer required.\n *\n * <p>Clears the resource caches of the {@link ApplicationContext} since they are\n * only required during the bean initialization phase. Runs after\n * {@link DirtiesContextTestExecutionListener} since dirtying the context will\n * close it and remove it from the context cache, making it unnecessary to clear\n * the associated resource caches.\n *\n * @author Stephane Nicoll\n * @since 6.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 36
    },
    "signature": "public class CommonCachesTestExecutionListener",
    "source_code": "public class CommonCachesTestExecutionListener extends AbstractTestExecutionListener {\n\n\t/**\n\t * Returns {@code 3005}.\n\t */\n\t@Override\n\tpublic final int getOrder() {\n\t\treturn 3005;\n\t}\n\n\n\t@Override\n\tpublic void afterTestClass(TestContext testContext) throws Exception {\n\t\tif (testContext.hasApplicationContext()) {\n\t\t\tApplicationContext applicationContext = testContext.getApplicationContext();\n\t\t\tif (applicationContext instanceof AbstractApplicationContext ctx) {\n\t\t\t\tctx.clearResourceCaches();\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.test.context.support.CommonCachesTestExecutionListener#afterTestClass(testContext)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "return": "void",
    "signature": "public void afterTestClass(TestContext testContext)",
    "source_code": "\tpublic void afterTestClass(TestContext testContext) throws Exception {\n\t\tif (testContext.hasApplicationContext()) {\n\t\t\tApplicationContext applicationContext = testContext.getApplicationContext();\n\t\t\tif (applicationContext instanceof AbstractApplicationContext ctx) {\n\t\t\t\tctx.clearResourceCaches();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.test.context.support.CommonCachesTestExecutionListener#getOrder()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns {@code 3005}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 42
    },
    "return": "int",
    "signature": "public int getOrder()",
    "source_code": "\tpublic final int getOrder() {\n\t\treturn 3005;\n\t}"
  },
  "org.springframework.test.context.web.WebMergedContextConfiguration": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * {@code WebMergedContextConfiguration} encapsulates the <em>merged</em> context\n * configuration declared on a test class and all of its superclasses and\n * enclosing classes via\n * {@link org.springframework.test.context.ContextConfiguration @ContextConfiguration},\n * {@link WebAppConfiguration @WebAppConfiguration},\n * {@link org.springframework.test.context.ActiveProfiles @ActiveProfiles}, and\n * {@link org.springframework.test.context.TestPropertySource @TestPropertySource}.\n *\n * <p>{@code WebMergedContextConfiguration} extends the contract of\n * {@link MergedContextConfiguration} by adding support for the {@linkplain\n * #getResourceBasePath() resource base path} configured via {@code @WebAppConfiguration}.\n * This allows the {@link org.springframework.test.context.cache.ContextCache ContextCache}\n * to properly cache the corresponding {@link\n * org.springframework.web.context.WebApplicationContext WebApplicationContext}\n * that was loaded using properties of this {@code WebMergedContextConfiguration}.\n *\n * @author Sam Brannen\n * @since 3.2\n * @see WebAppConfiguration\n * @see MergedContextConfiguration\n * @see org.springframework.test.context.ContextConfiguration\n * @see org.springframework.test.context.ActiveProfiles\n * @see org.springframework.test.context.ContextConfigurationAttributes\n * @see org.springframework.test.context.SmartContextLoader#loadContext(MergedContextConfiguration)\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "signature": "public class WebMergedContextConfiguration",
    "source_code": "public class WebMergedContextConfiguration extends MergedContextConfiguration {\n\n\tprivate static final long serialVersionUID = 7323361588604247458L;\n\n\tprivate final String resourceBasePath;\n\n\n\t/**\n\t * Create a new {@code WebMergedContextConfiguration} instance by copying\n\t * all properties from the supplied {@code MergedContextConfiguration}.\n\t * <p>If an <em>empty</em> value is supplied for the {@code resourceBasePath}\n\t * an empty string will be used.\n\t * @param resourceBasePath the resource path to the root directory of the web application\n\t * @since 4.1\n\t */\n\tpublic WebMergedContextConfiguration(MergedContextConfiguration mergedConfig, String resourceBasePath) {\n\t\tsuper(mergedConfig);\n\t\tthis.resourceBasePath = (StringUtils.hasText(resourceBasePath) ? resourceBasePath : \"\");\n\t}\n\n\t/**\n\t * Create a new {@code WebMergedContextConfiguration} instance for the\n\t * supplied parameters.\n\t * <p>If a {@code null} value is supplied for {@code locations},\n\t * {@code classes}, {@code activeProfiles}, {@code propertySourceLocations},\n\t * or {@code propertySourceProperties} an empty array will be stored instead.\n\t * If a {@code null} value is supplied for the\n\t * {@code contextInitializerClasses} an empty set will be stored instead.\n\t * If an <em>empty</em> value is supplied for the {@code resourceBasePath}\n\t * an empty string will be used. Furthermore, active profiles will be sorted,\n\t * and duplicate profiles will be removed.\n\t * @param testClass the test class for which the configuration was merged\n\t * @param locations the merged resource locations\n\t * @param classes the merged annotated classes\n\t * @param contextInitializerClasses the merged context initializer classes\n\t * @param activeProfiles the merged active bean definition profiles\n\t * @param propertySourceLocations the merged {@code PropertySource} locations\n\t * @param propertySourceProperties the merged {@code PropertySource} properties\n\t * @param resourceBasePath the resource path to the root directory of the web application\n\t * @param contextLoader the resolved {@code ContextLoader}\n\t * @param cacheAwareContextLoaderDelegate a cache-aware context loader\n\t * delegate with which to retrieve the parent context\n\t * @param parent the parent configuration or {@code null} if there is no parent\n\t * @since 4.1\n\t * @deprecated since 6.1 in favor of\n\t * {@link #WebMergedContextConfiguration(Class, String[], Class[], Set, String[], List, String[], Set, String, ContextLoader, CacheAwareContextLoaderDelegate, MergedContextConfiguration)}\n\t */\n\t@Deprecated(since = \"6.1\")\n\tpublic WebMergedContextConfiguration(Class<?> testClass, @Nullable String[] locations, @Nullable Class<?>[] classes,\n\t\t\t@Nullable Set<Class<? extends ApplicationContextInitializer<?>>> contextInitializerClasses,\n\t\t\t@Nullable String[] activeProfiles, @Nullable String[] propertySourceLocations, @Nullable String[] propertySourceProperties,\n\t\t\tString resourceBasePath, ContextLoader contextLoader,\n\t\t\tCacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate, @Nullable MergedContextConfiguration parent) {\n\n\t\tthis(testClass, locations, classes, contextInitializerClasses, activeProfiles, propertySourceLocations,\n\t\t\tpropertySourceProperties, null, resourceBasePath, contextLoader, cacheAwareContextLoaderDelegate, parent);\n\t}\n\n\t/**\n\t * Create a new {@code WebMergedContextConfiguration} instance for the\n\t * supplied parameters.\n\t * <p>If a {@code null} value is supplied for {@code locations},\n\t * {@code classes}, {@code activeProfiles}, {@code propertySourceLocations},\n\t * or {@code propertySourceProperties} an empty array will be stored instead.\n\t * If a {@code null} value is supplied for {@code contextInitializerClasses}\n\t * or {@code contextCustomizers}, an empty set will be stored instead.\n\t * If an <em>empty</em> value is supplied for the {@code resourceBasePath}\n\t * an empty string will be used. Furthermore, active profiles will be sorted,\n\t * and duplicate profiles will be removed.\n\t * @param testClass the test class for which the configuration was merged\n\t * @param locations the merged context resource locations\n\t * @param classes the merged annotated classes\n\t * @param contextInitializerClasses the merged context initializer classes\n\t * @param activeProfiles the merged active bean definition profiles\n\t * @param propertySourceLocations the merged {@code PropertySource} locations\n\t * @param propertySourceProperties the merged {@code PropertySource} properties\n\t * @param contextCustomizers the context customizers\n\t * @param resourceBasePath the resource path to the root directory of the web application\n\t * @param contextLoader the resolved {@code ContextLoader}\n\t * @param cacheAwareContextLoaderDelegate a cache-aware context loader\n\t * delegate with which to retrieve the parent context\n\t * @param parent the parent configuration or {@code null} if there is no parent\n\t * @since 4.3\n\t * @deprecated since 6.1 in favor of\n\t * {@link #WebMergedContextConfiguration(Class, String[], Class[], Set, String[], List, String[], Set, String, ContextLoader, CacheAwareContextLoaderDelegate, MergedContextConfiguration)}\n\t */\n\t@Deprecated(since = \"6.1\")\n\tpublic WebMergedContextConfiguration(Class<?> testClass, @Nullable String[] locations, @Nullable Class<?>[] classes,\n\t\t\t@Nullable Set<Class<? extends ApplicationContextInitializer<?>>> contextInitializerClasses,\n\t\t\t@Nullable String[] activeProfiles, @Nullable String[] propertySourceLocations, @Nullable String[] propertySourceProperties,\n\t\t\t@Nullable Set<ContextCustomizer> contextCustomizers, String resourceBasePath, ContextLoader contextLoader,\n\t\t\tCacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate, @Nullable MergedContextConfiguration parent) {\n\n\t\tthis(testClass, locations, classes, contextInitializerClasses, activeProfiles,\n\t\t\tList.of(new PropertySourceDescriptor(processStrings(propertySourceLocations))),\n\t\t\tpropertySourceProperties, contextCustomizers, resourceBasePath, contextLoader,\n\t\t\tcacheAwareContextLoaderDelegate, parent);\n\t}\n\n\t/**\n\t * Create a new {@code WebMergedContextConfiguration} instance for the supplied\n\t * parameters.\n\t * <p>If a {@code null} value is supplied for {@code locations}, {@code classes},\n\t * {@code activeProfiles}, or {@code propertySourceProperties} an empty array\n\t * will be stored instead. If a {@code null} value is supplied for\n\t * {@code contextInitializerClasses} or {@code contextCustomizers}, an empty\n\t * set will be stored instead. Furthermore, active profiles will be sorted,\n\t * and duplicate profiles will be removed.\n\t * @param testClass the test class for which the configuration was merged\n\t * @param locations the merged context resource locations\n\t * @param classes the merged annotated classes\n\t * @param contextInitializerClasses the merged context initializer classes\n\t * @param activeProfiles the merged active bean definition profiles\n\t * @param propertySourceDescriptors the merged property source descriptors\n\t * @param propertySourceProperties the merged inlined properties\n\t * @param contextCustomizers the context customizers\n\t * @param resourceBasePath the resource path to the root directory of the web application\n\t * @param contextLoader the resolved {@code ContextLoader}\n\t * @param cacheAwareContextLoaderDelegate a cache-aware context loader\n\t * delegate with which to retrieve the parent {@code ApplicationContext}\n\t * @param parent the parent configuration or {@code null} if there is no parent\n\t * @since 6.1\n\t */\n\tpublic WebMergedContextConfiguration(Class<?> testClass, @Nullable String[] locations, @Nullable Class<?>[] classes,\n\t\t\t@Nullable Set<Class<? extends ApplicationContextInitializer<?>>> contextInitializerClasses,\n\t\t\t@Nullable String[] activeProfiles,\n\t\t\tList<PropertySourceDescriptor> propertySourceDescriptors, @Nullable String[] propertySourceProperties,\n\t\t\t@Nullable Set<ContextCustomizer> contextCustomizers, String resourceBasePath, ContextLoader contextLoader,\n\t\t\tCacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate, @Nullable MergedContextConfiguration parent) {\n\n\t\tsuper(testClass, locations, classes, contextInitializerClasses, activeProfiles, propertySourceDescriptors,\n\t\t\tpropertySourceProperties, contextCustomizers, contextLoader, cacheAwareContextLoaderDelegate, parent);\n\n\t\tthis.resourceBasePath = (StringUtils.hasText(resourceBasePath) ? resourceBasePath : \"\");\n\t}\n\n\t/**\n\t * Get the resource path to the root directory of the web application for the\n\t * {@linkplain #getTestClass() test class}, configured via {@code @WebAppConfiguration}.\n\t * @see WebAppConfiguration\n\t */\n\tpublic String getResourceBasePath() {\n\t\treturn this.resourceBasePath;\n\t}\n\n\n\t/**\n\t * Determine if the supplied object is equal to this {@code WebMergedContextConfiguration}\n\t * instance by comparing both objects' {@linkplain #getLocations() locations},\n\t * {@linkplain #getClasses() annotated classes},\n\t * {@linkplain #getContextInitializerClasses() context initializer classes},\n\t * {@linkplain #getActiveProfiles() active profiles},\n\t * {@linkplain #getResourceBasePath() resource base paths},\n\t * {@linkplain #getPropertySourceDescriptors() property source descriptors},\n\t * {@linkplain #getPropertySourceProperties() property source properties},\n\t * {@linkplain #getContextCustomizers() context customizers},\n\t * {@linkplain #getParent() parents}, and the fully qualified names of their\n\t * {@link #getContextLoader() ContextLoaders}.\n\t */\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (super.equals(other) && other instanceof WebMergedContextConfiguration otherConfiguration &&\n\t\t\t\tthis.resourceBasePath.equals(otherConfiguration.resourceBasePath)));\n\t}\n\n\t/**\n\t * Generate a unique hash code for all properties of this\n\t * {@code WebMergedContextConfiguration} excluding the\n\t * {@linkplain #getTestClass() test class}.\n\t */\n\t@Override\n\tpublic int hashCode() {\n\t\treturn (31 * super.hashCode() + this.resourceBasePath.hashCode());\n\t}\n\n\t/**\n\t * Provide a String representation of the {@linkplain #getTestClass() test class},\n\t * {@linkplain #getLocations() locations}, {@linkplain #getClasses() annotated classes},\n\t * {@linkplain #getContextInitializerClasses() context initializer classes},\n\t * {@linkplain #getActiveProfiles() active profiles},\n\t * {@linkplain #getPropertySourceDescriptors() property source descriptors},\n\t * {@linkplain #getPropertySourceProperties() property source properties},\n\t * {@linkplain #getContextCustomizers() context customizers},\n\t * {@linkplain #getResourceBasePath() resource base path}, the name of the\n\t * {@link #getContextLoader() ContextLoader}, and the\n\t * {@linkplain #getParent() parent configuration}.\n\t */\n\t@Override\n\tpublic String toString() {\n\t\treturn new ToStringCreator(this, new DefaultToStringStyler(new SimpleValueStyler()))\n\t\t\t\t.append(\"testClass\", getTestClass())\n\t\t\t\t.append(\"locations\", getLocations())\n\t\t\t\t.append(\"classes\", getClasses())\n\t\t\t\t.append(\"contextInitializerClasses\", getContextInitializerClasses())\n\t\t\t\t.append(\"activeProfiles\", getActiveProfiles())\n\t\t\t\t.append(\"propertySourceDescriptors\", getPropertySourceDescriptors())\n\t\t\t\t.append(\"propertySourceProperties\", getPropertySourceProperties())\n\t\t\t\t.append(\"contextCustomizers\", getContextCustomizers())\n\t\t\t\t.append(\"resourceBasePath\", getResourceBasePath())\n\t\t\t\t.append(\"contextLoader\", (getContextLoader() != null ? getContextLoader().getClass() : null))\n\t\t\t\t.append(\"parent\", getParent())\n\t\t\t\t.toString();\n\t}\n\n}"
  },
  "org.springframework.test.context.web.WebMergedContextConfiguration#equals(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied object is equal to this {@code WebMergedContextConfiguration}\n\t * instance by comparing both objects' {@linkplain #getLocations() locations},\n\t * {@linkplain #getClasses() annotated classes},\n\t * {@linkplain #getContextInitializerClasses() context initializer classes},\n\t * {@linkplain #getActiveProfiles() active profiles},\n\t * {@linkplain #getResourceBasePath() resource base paths},\n\t * {@linkplain #getPropertySourceDescriptors() property source descriptors},\n\t * {@linkplain #getPropertySourceProperties() property source properties},\n\t * {@linkplain #getContextCustomizers() context customizers},\n\t * {@linkplain #getParent() parents}, and the fully qualified names of their\n\t * {@link #getContextLoader() ContextLoaders}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (super.equals(other) && other instanceof WebMergedContextConfiguration otherConfiguration &&\n\t\t\t\tthis.resourceBasePath.equals(otherConfiguration.resourceBasePath)));\n\t}"
  },
  "org.springframework.test.context.web.WebMergedContextConfiguration#getResourceBasePath()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the resource path to the root directory of the web application for the\n\t * {@linkplain #getTestClass() test class}, configured via {@code @WebAppConfiguration}.\n\t * @see WebAppConfiguration\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "String",
    "signature": "public String getResourceBasePath()",
    "source_code": "\tpublic String getResourceBasePath() {\n\t\treturn this.resourceBasePath;\n\t}"
  },
  "org.springframework.test.context.web.WebMergedContextConfiguration#hashCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate a unique hash code for all properties of this\n\t * {@code WebMergedContextConfiguration} excluding the\n\t * {@linkplain #getTestClass() test class}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 231
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn (31 * super.hashCode() + this.resourceBasePath.hashCode());\n\t}"
  },
  "org.springframework.test.context.web.WebMergedContextConfiguration#toString()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide a String representation of the {@linkplain #getTestClass() test class},\n\t * {@linkplain #getLocations() locations}, {@linkplain #getClasses() annotated classes},\n\t * {@linkplain #getContextInitializerClasses() context initializer classes},\n\t * {@linkplain #getActiveProfiles() active profiles},\n\t * {@linkplain #getPropertySourceDescriptors() property source descriptors},\n\t * {@linkplain #getPropertySourceProperties() property source properties},\n\t * {@linkplain #getContextCustomizers() context customizers},\n\t * {@linkplain #getResourceBasePath() resource base path}, the name of the\n\t * {@link #getContextLoader() ContextLoader}, and the\n\t * {@linkplain #getParent() parent configuration}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn new ToStringCreator(this, new DefaultToStringStyler(new SimpleValueStyler()))\n\t\t\t\t.append(\"testClass\", getTestClass())\n\t\t\t\t.append(\"locations\", getLocations())\n\t\t\t\t.append(\"classes\", getClasses())\n\t\t\t\t.append(\"contextInitializerClasses\", getContextInitializerClasses())\n\t\t\t\t.append(\"activeProfiles\", getActiveProfiles())\n\t\t\t\t.append(\"propertySourceDescriptors\", getPropertySourceDescriptors())\n\t\t\t\t.append(\"propertySourceProperties\", getPropertySourceProperties())\n\t\t\t\t.append(\"contextCustomizers\", getContextCustomizers())\n\t\t\t\t.append(\"resourceBasePath\", getResourceBasePath())\n\t\t\t\t.append(\"contextLoader\", (getContextLoader() != null ? getContextLoader().getClass() : null))\n\t\t\t\t.append(\"parent\", getParent())\n\t\t\t\t.toString();\n\t}"
  },
  "org.springframework.test.util.JsonPathExpectationsHelper#evaluateJsonPath(content,targetType)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #evaluateJsonPath(String)} with a target type.\n\t * <p>This can be useful for matching numbers reliably for example coercing an\n\t * integer into a double.\n\t * @param content the content to evaluate against\n\t * @return the result of the evaluation\n\t * @throws AssertionError if the evaluation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 314
    },
    "return": "Object",
    "signature": "public Object evaluateJsonPath(String content, Class<?> targetType)",
    "source_code": "\tpublic Object evaluateJsonPath(String content, Class<?> targetType) {\n\t\ttry {\n\t\t\treturn JsonPath.parse(content).read(this.expression, targetType);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tString message = \"No value at JSON path \\\"\" + this.expression + \"\\\"\";\n\t\t\tthrow new AssertionError(message, ex);\n\t\t}\n\t}"
  },
  "org.springframework.test.util.JsonPathExpectationsHelper#getType()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 425
    },
    "return": "Type",
    "signature": "public Type getType()",
    "source_code": "\t\tpublic Type getType() {\n\t\t\treturn this.type;\n\t\t}"
  },
  "org.springframework.test.web.client.match.ContentRequestMatchers#json(expectedJsonContent,comparator)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the request body and the given string as JSON and assert the two\n\t * using the given {@link JsonComparator}. If the comparison failed, throws an\n\t * {@link AssertionError} with the message of the {@link JsonComparison}.\n\t * <p>Use this matcher if you require a custom JSONAssert configuration or\n\t * if you desire to use another assertion library.\n\t * @param expectedJsonContent the expected JSON content\n\t * @param comparator the comparator to use\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedJsonContent",
      "comparator"
    ],
    "position": {
      "column": 1,
      "line": 382
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher json(String expectedJsonContent, JsonComparator comparator)",
    "source_code": "\tpublic RequestMatcher json(String expectedJsonContent, JsonComparator comparator) {\n\t\treturn request -> {\n\t\t\ttry {\n\t\t\t\tMockClientHttpRequest mockRequest = (MockClientHttpRequest) request;\n\t\t\t\tcomparator.assertIsMatch(expectedJsonContent, mockRequest.getBodyAsString());\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new AssertionError(\"Failed to parse expected or actual JSON request content\", ex);\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.test.web.client.match.ContentRequestMatchers#json(expectedJsonContent,compareMode)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the request body and the given string as JSON and assert the two\n\t * using the given {@linkplain JsonCompareMode mode}. If the comparison failed,\n\t * throws an {@link AssertionError} with the message of the {@link JsonComparison}.\n\t * <p>Use of this matcher requires the <a\n\t * href=\"https://jsonassert.skyscreamer.org/\">JSONassert</a> library.\n\t * @param expectedJsonContent the expected JSON content\n\t * @param compareMode the compare mode\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedJsonContent",
      "compareMode"
    ],
    "position": {
      "column": 1,
      "line": 368
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher json(String expectedJsonContent, JsonCompareMode compareMode)",
    "source_code": "\tpublic RequestMatcher json(String expectedJsonContent, JsonCompareMode compareMode) {\n\t\treturn json(expectedJsonContent, JsonAssert.comparator(compareMode));\n\t}"
  },
  "org.springframework.test.web.client.match.ContentRequestMatchers#multipartData(MultiValueMap<String,expectedMap,defaultCharset)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #multipartData(MultiValueMap)} with a defaultCharset.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "expectedMap",
      "defaultCharset"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher multipartData(MultiValueMap<String, ?> expectedMap, Charset defaultCharset)",
    "source_code": "\tpublic RequestMatcher multipartData(MultiValueMap<String, ?> expectedMap, Charset defaultCharset) {\n\t\treturn multipartData(expectedMap, defaultCharset, true);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.HandlerResultAssert": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * AssertJ {@linkplain org.assertj.core.api.Assert assertions} that can be applied\n * to a handler or handler method.\n\n * @author Stephane Nicoll\n * @since 6.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class HandlerResultAssert",
    "source_code": "public class HandlerResultAssert extends AbstractObjectAssert<HandlerResultAssert, Object> {\n\n\tpublic HandlerResultAssert(@Nullable Object actual) {\n\t\tsuper(actual, HandlerResultAssert.class);\n\t\tas(\"Handler result\");\n\t}\n\n\t/**\n\t * Return a new {@linkplain MethodAssert assertion} object that uses\n\t * the {@link Method} that handles the request as the object to test.\n\t * <p>Verifies first that the handler is a {@linkplain #isMethodHandler()\n\t * method handler}.\n\t * <p>Example: <pre><code class=\"java\">\n\t * // Check that a GET to \"/greet\" is invoked on a \"handleGreet\" method name\n\t * assertThat(mvc.perform(get(\"/greet\")).handler().method().hasName(\"handleGreet\");\n\t * </code></pre>\n\t */\n\tpublic MethodAssert method() {\n\t\treturn new MethodAssert(getHandlerMethod());\n\t}\n\n\t/**\n\t * Verify that the handler is managed by a method invocation, typically on\n\t * a controller.\n\t */\n\tpublic HandlerResultAssert isMethodHandler() {\n\t\treturn isNotNull().isInstanceOf(HandlerMethod.class);\n\t}\n\n\t/**\n\t * Verify that the handler is managed by the given {@code handlerMethod}.\n\t * <p>This creates a \"mock\" for the given {@code controllerType} and records\n\t * the method invocation in the {@code handlerMethod}. The arguments used by\n\t * the target method invocation can be {@code null} as the purpose of the mock\n\t * is to identify the method that was invoked.\n\t * <p>Example: <pre><code class=\"java\">\n\t * // If the method has a return type, you can return the result of the invocation\n\t * assertThat(mvc.perform(get(\"/greet\")).handler().isInvokedOn(\n\t *         GreetController.class, controller -> controller.sayGreet());\n\t *\n\t * // If the method has a void return type, the controller should be returned\n\t * assertThat(mvc.perform(post(\"/persons/\")).handler().isInvokedOn(\n\t *         PersonController.class, controller -> controller.createPerson(null, null));\n\t * </code></pre>\n\t * @param controllerType the controller to mock\n\t * @param handlerMethod the method\n\t */\n\tpublic <T> HandlerResultAssert isInvokedOn(Class<T> controllerType, Function<T, Object> handlerMethod) {\n\t\tMethodAssert actual = method();\n\t\tObject methodInvocationInfo = handlerMethod.apply(MvcUriComponentsBuilder.on(controllerType));\n\t\tAssertions.assertThat(methodInvocationInfo)\n\t\t\t\t.as(\"Method invocation on controller '%s'\", controllerType.getSimpleName())\n\t\t\t\t.isInstanceOfSatisfying(MethodInvocationInfo.class, mii ->\n\t\t\t\t\t\tactual.isEqualTo(mii.getControllerMethod()));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Verify that the handler is of the given {@code type}. For a controller\n\t * method, this is the type of the controller.\n\t * <p>Example: <pre><code class=\"java\">\n\t * // Check that a GET to \"/greet\" is managed by GreetController\n\t * assertThat(mvc.perform(get(\"/greet\")).handler().hasType(GreetController.class);\n\t * </code></pre>\n\t * @param type the expected type of the handler\n\t */\n\tpublic HandlerResultAssert hasType(Class<?> type) {\n\t\tisNotNull();\n\t\tClass<?> actualType = this.actual.getClass();\n\t\tif (this.actual instanceof HandlerMethod handlerMethod) {\n\t\t\tactualType = handlerMethod.getBeanType();\n\t\t}\n\t\tAssertions.assertThat(ClassUtils.getUserClass(actualType)).as(\"Handler result type\").isEqualTo(type);\n\t\treturn this;\n\t}\n\n\tprivate Method getHandlerMethod() {\n\t\tisMethodHandler(); // validate type\n\t\treturn ((HandlerMethod) this.actual).getMethod();\n\t}\n\n\n}"
  },
  "org.springframework.test.web.servlet.assertj.HandlerResultAssert#hasType(type)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Verify that the handler is of the given {@code type}. For a controller\n\t * method, this is the type of the controller.\n\t * <p>Example: <pre><code class=\"java\">\n\t * // Check that a GET to \"/greet\" is managed by GreetController\n\t * assertThat(mvc.perform(get(\"/greet\")).handler().hasType(GreetController.class);\n\t * </code></pre>\n\t * @param type the expected type of the handler\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "HandlerResultAssert",
    "signature": "public HandlerResultAssert hasType(Class<?> type)",
    "source_code": "\tpublic HandlerResultAssert hasType(Class<?> type) {\n\t\tisNotNull();\n\t\tClass<?> actualType = this.actual.getClass();\n\t\tif (this.actual instanceof HandlerMethod handlerMethod) {\n\t\t\tactualType = handlerMethod.getBeanType();\n\t\t}\n\t\tAssertions.assertThat(ClassUtils.getUserClass(actualType)).as(\"Handler result type\").isEqualTo(type);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.HandlerResultAssert#isInvokedOn(controllerType,Function<T,handlerMethod)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Verify that the handler is managed by the given {@code handlerMethod}.\n\t * <p>This creates a \"mock\" for the given {@code controllerType} and records\n\t * the method invocation in the {@code handlerMethod}. The arguments used by\n\t * the target method invocation can be {@code null} as the purpose of the mock\n\t * is to identify the method that was invoked.\n\t * <p>Example: <pre><code class=\"java\">\n\t * // If the method has a return type, you can return the result of the invocation\n\t * assertThat(mvc.perform(get(\"/greet\")).handler().isInvokedOn(\n\t *         GreetController.class, controller -> controller.sayGreet());\n\t *\n\t * // If the method has a void return type, the controller should be returned\n\t * assertThat(mvc.perform(post(\"/persons/\")).handler().isInvokedOn(\n\t *         PersonController.class, controller -> controller.createPerson(null, null));\n\t * </code></pre>\n\t * @param controllerType the controller to mock\n\t * @param handlerMethod the method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "controllerType",
      "Function<T",
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "HandlerResultAssert",
    "signature": "public HandlerResultAssert isInvokedOn(Class<T> controllerType, Function<T, Object> handlerMethod)",
    "source_code": "\tpublic <T> HandlerResultAssert isInvokedOn(Class<T> controllerType, Function<T, Object> handlerMethod) {\n\t\tMethodAssert actual = method();\n\t\tObject methodInvocationInfo = handlerMethod.apply(MvcUriComponentsBuilder.on(controllerType));\n\t\tAssertions.assertThat(methodInvocationInfo)\n\t\t\t\t.as(\"Method invocation on controller '%s'\", controllerType.getSimpleName())\n\t\t\t\t.isInstanceOfSatisfying(MethodInvocationInfo.class, mii ->\n\t\t\t\t\t\tactual.isEqualTo(mii.getControllerMethod()));\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.HandlerResultAssert#isMethodHandler()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Verify that the handler is managed by a method invocation, typically on\n\t * a controller.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "HandlerResultAssert",
    "signature": "public HandlerResultAssert isMethodHandler()",
    "source_code": "\tpublic HandlerResultAssert isMethodHandler() {\n\t\treturn isNotNull().isInstanceOf(HandlerMethod.class);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.HandlerResultAssert#method()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a new {@linkplain MethodAssert assertion} object that uses\n\t * the {@link Method} that handles the request as the object to test.\n\t * <p>Verifies first that the handler is a {@linkplain #isMethodHandler()\n\t * method handler}.\n\t * <p>Example: <pre><code class=\"java\">\n\t * // Check that a GET to \"/greet\" is invoked on a \"handleGreet\" method name\n\t * assertThat(mvc.perform(get(\"/greet\")).handler().method().hasName(\"handleGreet\");\n\t * </code></pre>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "MethodAssert",
    "signature": "public MethodAssert method()",
    "source_code": "\tpublic MethodAssert method() {\n\t\treturn new MethodAssert(getHandlerMethod());\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcRequestBuilder": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * A builder for {@link MockHttpServletRequest} that supports AssertJ.\n\t */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 381
    },
    "signature": "public class MockMvcRequestBuilder",
    "source_code": "\tpublic final class MockMvcRequestBuilder extends AbstractMockHttpServletRequestBuilder<MockMvcRequestBuilder>"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * {@code MockMvcTester} provides support for testing Spring MVC applications\n * with {@link MockMvc} for server request handling using\n * {@linkplain org.assertj.core.api.Assertions AssertJ}.\n *\n * <p>A tester instance can be created from a {@link WebApplicationContext}:\n * <pre><code class=\"java\">\n * // Create an instance with default settings\n * MockMvcTester mvc = MockMvcTester.from(applicationContext);\n *\n * // Create an instance with a custom Filter\n * MockMvcTester mvc = MockMvcTester.from(applicationContext,\n *         builder -> builder.addFilters(filter).build());\n * </code></pre>\n *\n * <p>A tester can be created in standalone mode by providing the controller(s)\n * to include:<pre><code class=\"java\">\n * // Create an instance for PersonController\n * MockMvcTester mvc = MockMvcTester.of(new PersonController());\n * </code></pre>\n *\n * <p>Simple, single-statement assertions can be done wrapping the request\n * builder in {@code assertThat()} provides access to assertions. For instance:\n * <pre><code class=\"java\">\n * // perform a GET on /hi and assert the response body is equal to Hello\n * assertThat(mvc.get().uri(\"/hi\")).hasStatusOk().hasBodyTextEqualTo(\"Hello\");\n * </code></pre>\n *\n *<p>For more complex scenarios the {@linkplain MvcTestResult result} of the\n * exchange can be assigned in a variable to run multiple assertions:\n * <pre><code class=\"java\">\n * // perform a POST on /save and assert the response body is empty\n * MvcTestResult result = mvc.post().uri(\"/save\").exchange();\n * assertThat(result).hasStatus(HttpStatus.CREATED);\n * assertThat(result).body().isEmpty();\n * </code></pre>\n *\n * <p>You can also perform requests using the static builders approach that\n * {@link MockMvc} uses. For instance:<pre><code class=\"java\">\n * // perform a GET on /hi and assert the response body is equal to Hello\n * assertThat(mvc.perform(get(\"/hi\")))\n *         .hasStatusOk().hasBodyTextEqualTo(\"Hello\");\n * </code></pre>\n *\n * <p>One main difference between {@link MockMvc} and {@code MockMvcTester} is\n * that an unresolved exception is not thrown directly when using\n * {@code MockMvcTester}. Rather an {@link MvcTestResult} is available with an\n * {@linkplain MvcTestResult#getUnresolvedException() unresolved exception}\n * which allows you to assert that a request failed unexpectedly:\n * <pre><code class=\"java\">\n * // perform a GET on /boom and assert the message for the the unresolved exception\n * assertThat(mvc.get().uri(\"/boom\")).hasUnresolvedException())\n *         .withMessage(\"Test exception\");\n * </code></pre>\n *\n * <p>{@code MockMvcTester} can be configured with a list of\n * {@linkplain HttpMessageConverter message converters} to allow the response\n * body to be deserialized, rather than asserting on the raw values.\n *\n * @author Stephane Nicoll\n * @author Brian Clozel\n * @since 6.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "signature": "public class MockMvcTester",
    "source_code": "public final class MockMvcTester {\n\n\tprivate static final MediaType JSON = MediaType.APPLICATION_JSON;\n\n\tprivate final MockMvc mockMvc;\n\n\t@Nullable\n\tprivate final GenericHttpMessageConverter<Object> jsonMessageConverter;\n\n\n\tprivate MockMvcTester(MockMvc mockMvc, @Nullable GenericHttpMessageConverter<Object> jsonMessageConverter) {\n\t\tAssert.notNull(mockMvc, \"mockMVC should not be null\");\n\t\tthis.mockMvc = mockMvc;\n\t\tthis.jsonMessageConverter = jsonMessageConverter;\n\t}\n\n\t/**\n\t * Create an instance that delegates to the given {@link MockMvc} instance.\n\t * @param mockMvc the MockMvc instance to delegate calls to\n\t */\n\tpublic static MockMvcTester create(MockMvc mockMvc) {\n\t\treturn new MockMvcTester(mockMvc, null);\n\t}\n\n\t/**\n\t * Create an instance using the given, fully initialized (i.e.,\n\t * <em>refreshed</em>) {@link WebApplicationContext}. The given\n\t * {@code customizations} are applied to the {@link DefaultMockMvcBuilder}\n\t * that ultimately creates the underlying {@link MockMvc} instance.\n\t * <p>If no further customization of the underlying {@link MockMvc} instance\n\t * is required, use {@link #from(WebApplicationContext)}.\n\t * @param applicationContext the application context to detect the Spring\n\t * MVC infrastructure and application controllers from\n\t * @param customizations a function that creates a {@link MockMvc}\n\t * instance based on a {@link DefaultMockMvcBuilder}\n\t * @see MockMvcBuilders#webAppContextSetup(WebApplicationContext)\n\t */\n\tpublic static MockMvcTester from(WebApplicationContext applicationContext,\n\t\t\tFunction<DefaultMockMvcBuilder, MockMvc> customizations) {\n\n\t\tDefaultMockMvcBuilder builder = MockMvcBuilders.webAppContextSetup(applicationContext);\n\t\tMockMvc mockMvc = customizations.apply(builder);\n\t\treturn create(mockMvc);\n\t}\n\n\t/**\n\t * Shortcut to create an instance using the given fully initialized (i.e.,\n\t * <em>refreshed</em>) {@link WebApplicationContext}.\n\t * <p>Consider using {@link #from(WebApplicationContext, Function)} if\n\t * further customization of the underlying {@link MockMvc} instance is\n\t * required.\n\t * @param applicationContext the application context to detect the Spring\n\t * MVC infrastructure and application controllers from\n\t * @see MockMvcBuilders#webAppContextSetup(WebApplicationContext)\n\t */\n\tpublic static MockMvcTester from(WebApplicationContext applicationContext) {\n\t\treturn from(applicationContext, DefaultMockMvcBuilder::build);\n\t}\n\n\t/**\n\t * Create an instance by registering one or more {@code @Controller} instances\n\t * and configuring Spring MVC infrastructure programmatically.\n\t * <p>This allows full control over the instantiation and initialization of\n\t * controllers and their dependencies, similar to plain unit tests while\n\t * also making it possible to test one controller at a time.\n\t * @param controllers one or more {@code @Controller} instances or\n\t * {@code @Controller} types to test; a type ({@code Class}) will be turned\n\t * into an instance\n\t * @param customizations a function that creates a {@link MockMvc} instance\n\t * based on a {@link StandaloneMockMvcBuilder}, typically to configure the\n\t * Spring MVC infrastructure\n\t * @see MockMvcBuilders#standaloneSetup(Object...)\n\t */\n\tpublic static MockMvcTester of(Collection<?> controllers,\n\t\t\tFunction<StandaloneMockMvcBuilder, MockMvc> customizations) {\n\n\t\tStandaloneMockMvcBuilder builder = MockMvcBuilders.standaloneSetup(controllers.toArray());\n\t\treturn create(customizations.apply(builder));\n\t}\n\n\t/**\n\t * Shortcut to create an instance by registering one or more {@code @Controller}\n\t * instances.\n\t * <p>The minimum infrastructure required by the\n\t * {@link org.springframework.web.servlet.DispatcherServlet DispatcherServlet}\n\t * to serve requests with annotated controllers is created. Consider using\n\t * {@link #of(Collection, Function)} if additional configuration of the MVC\n\t * infrastructure is required.\n\t * @param controllers one or more {@code @Controller} instances or\n\t * {@code @Controller} types to test; a type ({@code Class}) will be turned\n\t * into an instance\n\t * @see MockMvcBuilders#standaloneSetup(Object...)\n\t */\n\tpublic static MockMvcTester of(Object... controllers) {\n\t\treturn of(Arrays.asList(controllers), StandaloneMockMvcBuilder::build);\n\t}\n\n\t/**\n\t * Return a new instance using the specified {@linkplain HttpMessageConverter\n\t * message converters}.\n\t * <p>If none are specified, only basic assertions on the response body can\n\t * be performed. Consider registering a suitable JSON converter for asserting\n\t * against JSON data structures.\n\t * @param httpMessageConverters the message converters to use\n\t * @return a new instance using the specified converters\n\t */\n\tpublic MockMvcTester withHttpMessageConverters(Iterable<HttpMessageConverter<?>> httpMessageConverters) {\n\t\treturn new MockMvcTester(this.mockMvc, findJsonMessageConverter(httpMessageConverters));\n\t}\n\n\t/**\n\t * Prepare an HTTP GET request.\n\t * <p>The returned builder can be wrapped in {@code assertThat} to enable\n\t * assertions on the result. For multi-statements assertions, use\n\t * {@linkplain MockMvcRequestBuilder#exchange() exchange} to assign the\n\t * result.\n\t * @return a request builder for specifying the target URI\n\t */\n\tpublic MockMvcRequestBuilder get() {\n\t\treturn method(HttpMethod.GET);\n\t}\n\n\t/**\n\t * Prepare an HTTP HEAD request.\n\t * <p>The returned builder can be wrapped in {@code assertThat} to enable\n\t * assertions on the result. For multi-statements assertions, use\n\t * {@linkplain MockMvcRequestBuilder#exchange() exchange} to assign the\n\t * result.\n\t * @return a request builder for specifying the target URI\n\t */\n\tpublic MockMvcRequestBuilder head() {\n\t\treturn method(HttpMethod.HEAD);\n\t}\n\n\t/**\n\t * Prepare an HTTP POST request.\n\t * <p>The returned builder can be wrapped in {@code assertThat} to enable\n\t * assertions on the result. For multi-statements assertions, use\n\t * {@linkplain MockMvcRequestBuilder#exchange() exchange} to assign the\n\t * result.\n\t * @return a request builder for specifying the target URI\n\t */\n\tpublic MockMvcRequestBuilder post() {\n\t\treturn method(HttpMethod.POST);\n\t}\n\n\t/**\n\t * Prepare an HTTP PUT request.\n\t * <p>The returned builder can be wrapped in {@code assertThat} to enable\n\t * assertions on the result. For multi-statements assertions, use\n\t * {@linkplain MockMvcRequestBuilder#exchange() exchange} to assign the\n\t * result.\n\t * @return a request builder for specifying the target URI\n\t */\n\tpublic MockMvcRequestBuilder put() {\n\t\treturn method(HttpMethod.PUT);\n\t}\n\n\t/**\n\t * Prepare an HTTP PATCH request.\n\t * <p>The returned builder can be wrapped in {@code assertThat} to enable\n\t * assertions on the result. For multi-statements assertions, use\n\t * {@linkplain MockMvcRequestBuilder#exchange() exchange} to assign the\n\t * result.\n\t * @return a request builder for specifying the target URI\n\t */\n\tpublic MockMvcRequestBuilder patch() {\n\t\treturn method(HttpMethod.PATCH);\n\t}\n\n\t/**\n\t * Prepare an HTTP DELETE request.\n\t * <p>The returned builder can be wrapped in {@code assertThat} to enable\n\t * assertions on the result. For multi-statements assertions, use\n\t * {@linkplain MockMvcRequestBuilder#exchange() exchange} to assign the\n\t * result.\n\t * @return a request builder for specifying the target URI\n\t */\n\tpublic MockMvcRequestBuilder delete() {\n\t\treturn method(HttpMethod.DELETE);\n\t}\n\n\t/**\n\t * Prepare an HTTP OPTIONS request.\n\t * <p>The returned builder can be wrapped in {@code assertThat} to enable\n\t * assertions on the result. For multi-statements assertions, use\n\t * {@linkplain MockMvcRequestBuilder#exchange() exchange} to assign the\n\t * result.\n\t * @return a request builder for specifying the target URI\n\t */\n\tpublic MockMvcRequestBuilder options() {\n\t\treturn method(HttpMethod.OPTIONS);\n\t}\n\n\t/**\n\t * Prepare a request for the specified {@code HttpMethod}.\n\t * <p>The returned builder can be wrapped in {@code assertThat} to enable\n\t * assertions on the result. For multi-statements assertions, use\n\t * {@linkplain MockMvcRequestBuilder#exchange() exchange} to assign the\n\t * result.\n\t * @return a request builder for specifying the target URI\n\t */\n\tpublic MockMvcRequestBuilder method(HttpMethod method) {\n\t\treturn new MockMvcRequestBuilder(method);\n\t}\n\n\t/**\n\t * Perform a request using {@link MockMvcRequestBuilders} and return a\n\t * {@link MvcTestResult result} that can be used with standard\n\t * {@link org.assertj.core.api.Assertions AssertJ} assertions.\n\t * <p>Use static methods of {@link MockMvcRequestBuilders} to prepare the\n\t * request, wrapping the invocation in {@code assertThat}. The following\n\t * asserts that a {@linkplain MockMvcRequestBuilders#get(URI) GET} request\n\t * against \"/greet\" has an HTTP status code 200 (OK) and a simple body:\n\t * <pre><code class=\"java\">assertThat(mvc.perform(get(\"/greet\")))\n\t *       .hasStatusOk()\n\t *       .body().asString().isEqualTo(\"Hello\");\n\t * </code></pre>\n\t * <p>Contrary to {@link MockMvc#perform(RequestBuilder)}, this does not\n\t * throw an exception if the request fails with an unresolved exception.\n\t * Rather, the result provides the exception, if any. Assuming that a\n\t * {@link MockMvcRequestBuilders#post(URI) POST} request against\n\t * {@code /boom} throws an {@code IllegalStateException}, the following\n\t * asserts that the invocation has indeed failed with the expected error\n\t * message:\n\t * <pre><code class=\"java\">assertThat(mvc.perform(post(\"/boom\")))\n\t *       .unresolvedException().isInstanceOf(IllegalStateException.class)\n\t *       .hasMessage(\"Expected\");\n\t * </code></pre>\n\t * @param requestBuilder used to prepare the request to execute;\n\t * see static factory methods in\n\t * {@link org.springframework.test.web.servlet.request.MockMvcRequestBuilders}\n\t * @return an {@link MvcTestResult} to be wrapped in {@code assertThat}\n\t * @see MockMvc#perform(RequestBuilder)\n\t * @see #get()\n\t * @see #post()\n\t */\n\tpublic MvcTestResult perform(RequestBuilder requestBuilder) {\n\t\tObject result = getMvcResultOrFailure(requestBuilder);\n\t\tif (result instanceof MvcResult mvcResult) {\n\t\t\treturn new DefaultMvcTestResult(mvcResult, null, this.jsonMessageConverter);\n\t\t}\n\t\telse {\n\t\t\treturn new DefaultMvcTestResult(null, (Exception) result, this.jsonMessageConverter);\n\t\t}\n\t}\n\n\tprivate Object getMvcResultOrFailure(RequestBuilder requestBuilder) {\n\t\ttry {\n\t\t\treturn this.mockMvc.perform(requestBuilder).andReturn();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\treturn ex;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Nullable\n\tprivate GenericHttpMessageConverter<Object> findJsonMessageConverter(\n\t\t\tIterable<HttpMessageConverter<?>> messageConverters) {\n\n\t\treturn StreamSupport.stream(messageConverters.spliterator(), false)\n\t\t\t\t.filter(GenericHttpMessageConverter.class::isInstance)\n\t\t\t\t.map(GenericHttpMessageConverter.class::cast)\n\t\t\t\t.filter(converter -> converter.canWrite(null, Map.class, JSON))\n\t\t\t\t.filter(converter -> converter.canRead(Map.class, JSON))\n\t\t\t\t.findFirst().orElse(null);\n\t}\n\n\n\t/**\n\t * A builder for {@link MockHttpServletRequest} that supports AssertJ.\n\t */\n\tpublic final class MockMvcRequestBuilder extends AbstractMockHttpServletRequestBuilder<MockMvcRequestBuilder>\n\t\t\timplements AssertProvider<MvcTestResultAssert> {\n\n\t\tprivate MockMvcRequestBuilder(HttpMethod httpMethod) {\n\t\t\tsuper(httpMethod);\n\t\t}\n\n\t\tpublic MvcTestResult exchange() {\n\t\t\treturn perform(this);\n\t\t}\n\n\t\t@Override\n\t\tpublic MvcTestResultAssert assertThat() {\n\t\t\treturn new MvcTestResultAssert(exchange(), MockMvcTester.this.jsonMessageConverter);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#assertThat()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 393
    },
    "return": "MvcTestResultAssert",
    "signature": "public MvcTestResultAssert assertThat()",
    "source_code": "\t\tpublic MvcTestResultAssert assertThat() {\n\t\t\treturn new MvcTestResultAssert(exchange(), MockMvcTester.this.jsonMessageConverter);\n\t\t}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#create(mockMvc)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an instance that delegates to the given {@link MockMvc} instance.\n\t * @param mockMvc the MockMvc instance to delegate calls to\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mockMvc"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "MockMvcTester",
    "signature": "public MockMvcTester create(MockMvc mockMvc)",
    "source_code": "\tpublic static MockMvcTester create(MockMvc mockMvc) {\n\t\treturn new MockMvcTester(mockMvc, null);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#delete()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare an HTTP DELETE request.\n\t * <p>The returned builder can be wrapped in {@code assertThat} to enable\n\t * assertions on the result. For multi-statements assertions, use\n\t * {@linkplain MockMvcRequestBuilder#exchange() exchange} to assign the\n\t * result.\n\t * @return a request builder for specifying the target URI\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "MockMvcRequestBuilder",
    "signature": "public MockMvcRequestBuilder delete()",
    "source_code": "\tpublic MockMvcRequestBuilder delete() {\n\t\treturn method(HttpMethod.DELETE);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#exchange()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 388
    },
    "return": "MvcTestResult",
    "signature": "public MvcTestResult exchange()",
    "source_code": "\t\tpublic MvcTestResult exchange() {\n\t\t\treturn perform(this);\n\t\t}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#from(applicationContext)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Shortcut to create an instance using the given fully initialized (i.e.,\n\t * <em>refreshed</em>) {@link WebApplicationContext}.\n\t * <p>Consider using {@link #from(WebApplicationContext, Function)} if\n\t * further customization of the underlying {@link MockMvc} instance is\n\t * required.\n\t * @param applicationContext the application context to detect the Spring\n\t * MVC infrastructure and application controllers from\n\t * @see MockMvcBuilders#webAppContextSetup(WebApplicationContext)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "applicationContext"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "MockMvcTester",
    "signature": "public MockMvcTester from(WebApplicationContext applicationContext)",
    "source_code": "\tpublic static MockMvcTester from(WebApplicationContext applicationContext) {\n\t\treturn from(applicationContext, DefaultMockMvcBuilder::build);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#from(applicationContext,Function<DefaultMockMvcBuilder,customizations)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an instance using the given, fully initialized (i.e.,\n\t * <em>refreshed</em>) {@link WebApplicationContext}. The given\n\t * {@code customizations} are applied to the {@link DefaultMockMvcBuilder}\n\t * that ultimately creates the underlying {@link MockMvc} instance.\n\t * <p>If no further customization of the underlying {@link MockMvc} instance\n\t * is required, use {@link #from(WebApplicationContext)}.\n\t * @param applicationContext the application context to detect the Spring\n\t * MVC infrastructure and application controllers from\n\t * @param customizations a function that creates a {@link MockMvc}\n\t * instance based on a {@link DefaultMockMvcBuilder}\n\t * @see MockMvcBuilders#webAppContextSetup(WebApplicationContext)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "applicationContext",
      "Function<DefaultMockMvcBuilder",
      "customizations"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "MockMvcTester",
    "signature": "public MockMvcTester from(WebApplicationContext applicationContext,\n\t\t\tFunction<DefaultMockMvcBuilder, MockMvc> customizations)",
    "source_code": "\tpublic static MockMvcTester from(WebApplicationContext applicationContext,"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#get()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare an HTTP GET request.\n\t * <p>The returned builder can be wrapped in {@code assertThat} to enable\n\t * assertions on the result. For multi-statements assertions, use\n\t * {@linkplain MockMvcRequestBuilder#exchange() exchange} to assign the\n\t * result.\n\t * @return a request builder for specifying the target URI\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 226
    },
    "return": "MockMvcRequestBuilder",
    "signature": "public MockMvcRequestBuilder get()",
    "source_code": "\tpublic MockMvcRequestBuilder get() {\n\t\treturn method(HttpMethod.GET);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#head()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare an HTTP HEAD request.\n\t * <p>The returned builder can be wrapped in {@code assertThat} to enable\n\t * assertions on the result. For multi-statements assertions, use\n\t * {@linkplain MockMvcRequestBuilder#exchange() exchange} to assign the\n\t * result.\n\t * @return a request builder for specifying the target URI\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "MockMvcRequestBuilder",
    "signature": "public MockMvcRequestBuilder head()",
    "source_code": "\tpublic MockMvcRequestBuilder head() {\n\t\treturn method(HttpMethod.HEAD);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#method(method)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare a request for the specified {@code HttpMethod}.\n\t * <p>The returned builder can be wrapped in {@code assertThat} to enable\n\t * assertions on the result. For multi-statements assertions, use\n\t * {@linkplain MockMvcRequestBuilder#exchange() exchange} to assign the\n\t * result.\n\t * @return a request builder for specifying the target URI\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 310
    },
    "return": "MockMvcRequestBuilder",
    "signature": "public MockMvcRequestBuilder method(HttpMethod method)",
    "source_code": "\tpublic MockMvcRequestBuilder method(HttpMethod method) {\n\t\treturn new MockMvcRequestBuilder(method);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#of(controllers)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Shortcut to create an instance by registering one or more {@code @Controller}\n\t * instances.\n\t * <p>The minimum infrastructure required by the\n\t * {@link org.springframework.web.servlet.DispatcherServlet DispatcherServlet}\n\t * to serve requests with annotated controllers is created. Consider using\n\t * {@link #of(Collection, Function)} if additional configuration of the MVC\n\t * infrastructure is required.\n\t * @param controllers one or more {@code @Controller} instances or\n\t * {@code @Controller} types to test; a type ({@code Class}) will be turned\n\t * into an instance\n\t * @see MockMvcBuilders#standaloneSetup(Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "controllers"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "MockMvcTester",
    "signature": "public MockMvcTester of(Object... controllers)",
    "source_code": "\tpublic static MockMvcTester of(Object... controllers) {\n\t\treturn of(Arrays.asList(controllers), StandaloneMockMvcBuilder::build);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#of(controllers,Function<StandaloneMockMvcBuilder,customizations)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an instance by registering one or more {@code @Controller} instances\n\t * and configuring Spring MVC infrastructure programmatically.\n\t * <p>This allows full control over the instantiation and initialization of\n\t * controllers and their dependencies, similar to plain unit tests while\n\t * also making it possible to test one controller at a time.\n\t * @param controllers one or more {@code @Controller} instances or\n\t * {@code @Controller} types to test; a type ({@code Class}) will be turned\n\t * into an instance\n\t * @param customizations a function that creates a {@link MockMvc} instance\n\t * based on a {@link StandaloneMockMvcBuilder}, typically to configure the\n\t * Spring MVC infrastructure\n\t * @see MockMvcBuilders#standaloneSetup(Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "controllers",
      "Function<StandaloneMockMvcBuilder",
      "customizations"
    ],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "MockMvcTester",
    "signature": "public MockMvcTester of(Collection<?> controllers,\n\t\t\tFunction<StandaloneMockMvcBuilder, MockMvc> customizations)",
    "source_code": "\tpublic static MockMvcTester of(Collection<?> controllers,"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#options()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare an HTTP OPTIONS request.\n\t * <p>The returned builder can be wrapped in {@code assertThat} to enable\n\t * assertions on the result. For multi-statements assertions, use\n\t * {@linkplain MockMvcRequestBuilder#exchange() exchange} to assign the\n\t * result.\n\t * @return a request builder for specifying the target URI\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 298
    },
    "return": "MockMvcRequestBuilder",
    "signature": "public MockMvcRequestBuilder options()",
    "source_code": "\tpublic MockMvcRequestBuilder options() {\n\t\treturn method(HttpMethod.OPTIONS);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#patch()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare an HTTP PATCH request.\n\t * <p>The returned builder can be wrapped in {@code assertThat} to enable\n\t * assertions on the result. For multi-statements assertions, use\n\t * {@linkplain MockMvcRequestBuilder#exchange() exchange} to assign the\n\t * result.\n\t * @return a request builder for specifying the target URI\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "MockMvcRequestBuilder",
    "signature": "public MockMvcRequestBuilder patch()",
    "source_code": "\tpublic MockMvcRequestBuilder patch() {\n\t\treturn method(HttpMethod.PATCH);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#perform(requestBuilder)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform a request using {@link MockMvcRequestBuilders} and return a\n\t * {@link MvcTestResult result} that can be used with standard\n\t * {@link org.assertj.core.api.Assertions AssertJ} assertions.\n\t * <p>Use static methods of {@link MockMvcRequestBuilders} to prepare the\n\t * request, wrapping the invocation in {@code assertThat}. The following\n\t * asserts that a {@linkplain MockMvcRequestBuilders#get(URI) GET} request\n\t * against \"/greet\" has an HTTP status code 200 (OK) and a simple body:\n\t * <pre><code class=\"java\">assertThat(mvc.perform(get(\"/greet\")))\n\t *       .hasStatusOk()\n\t *       .body().asString().isEqualTo(\"Hello\");\n\t * </code></pre>\n\t * <p>Contrary to {@link MockMvc#perform(RequestBuilder)}, this does not\n\t * throw an exception if the request fails with an unresolved exception.\n\t * Rather, the result provides the exception, if any. Assuming that a\n\t * {@link MockMvcRequestBuilders#post(URI) POST} request against\n\t * {@code /boom} throws an {@code IllegalStateException}, the following\n\t * asserts that the invocation has indeed failed with the expected error\n\t * message:\n\t * <pre><code class=\"java\">assertThat(mvc.perform(post(\"/boom\")))\n\t *       .unresolvedException().isInstanceOf(IllegalStateException.class)\n\t *       .hasMessage(\"Expected\");\n\t * </code></pre>\n\t * @param requestBuilder used to prepare the request to execute;\n\t * see static factory methods in\n\t * {@link org.springframework.test.web.servlet.request.MockMvcRequestBuilders}\n\t * @return an {@link MvcTestResult} to be wrapped in {@code assertThat}\n\t * @see MockMvc#perform(RequestBuilder)\n\t * @see #get()\n\t * @see #post()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestBuilder"
    ],
    "position": {
      "column": 1,
      "line": 345
    },
    "return": "MvcTestResult",
    "signature": "public MvcTestResult perform(RequestBuilder requestBuilder)",
    "source_code": "\tpublic MvcTestResult perform(RequestBuilder requestBuilder) {\n\t\tObject result = getMvcResultOrFailure(requestBuilder);\n\t\tif (result instanceof MvcResult mvcResult) {\n\t\t\treturn new DefaultMvcTestResult(mvcResult, null, this.jsonMessageConverter);\n\t\t}\n\t\telse {\n\t\t\treturn new DefaultMvcTestResult(null, (Exception) result, this.jsonMessageConverter);\n\t\t}\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#post()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare an HTTP POST request.\n\t * <p>The returned builder can be wrapped in {@code assertThat} to enable\n\t * assertions on the result. For multi-statements assertions, use\n\t * {@linkplain MockMvcRequestBuilder#exchange() exchange} to assign the\n\t * result.\n\t * @return a request builder for specifying the target URI\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 250
    },
    "return": "MockMvcRequestBuilder",
    "signature": "public MockMvcRequestBuilder post()",
    "source_code": "\tpublic MockMvcRequestBuilder post() {\n\t\treturn method(HttpMethod.POST);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#put()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare an HTTP PUT request.\n\t * <p>The returned builder can be wrapped in {@code assertThat} to enable\n\t * assertions on the result. For multi-statements assertions, use\n\t * {@linkplain MockMvcRequestBuilder#exchange() exchange} to assign the\n\t * result.\n\t * @return a request builder for specifying the target URI\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "MockMvcRequestBuilder",
    "signature": "public MockMvcRequestBuilder put()",
    "source_code": "\tpublic MockMvcRequestBuilder put() {\n\t\treturn method(HttpMethod.PUT);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.MockMvcTester#withHttpMessageConverters(httpMessageConverters)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a new instance using the specified {@linkplain HttpMessageConverter\n\t * message converters}.\n\t * <p>If none are specified, only basic assertions on the response body can\n\t * be performed. Consider registering a suitable JSON converter for asserting\n\t * against JSON data structures.\n\t * @param httpMessageConverters the message converters to use\n\t * @return a new instance using the specified converters\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "httpMessageConverters"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "MockMvcTester",
    "signature": "public MockMvcTester withHttpMessageConverters(Iterable<HttpMessageConverter<?>> httpMessageConverters)",
    "source_code": "\tpublic MockMvcTester withHttpMessageConverters(Iterable<HttpMessageConverter<?>> httpMessageConverters) {\n\t\treturn new MockMvcTester(this.mockMvc, findJsonMessageConverter(httpMessageConverters));\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Base builder for {@link MockHttpServletRequest} required as input to\n * perform requests in {@link MockMvc}.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Arjen Poutsma\n * @author Sam Brannen\n * @author Kamill Sokol\n * @since 6.2\n * @param <B> a self reference to the builder type\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "signature": "public class AbstractMockHttpServletRequestBuilder",
    "source_code": "public abstract class AbstractMockHttpServletRequestBuilder<B extends AbstractMockHttpServletRequestBuilder<B>>"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#accept(mediaTypes)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@code Accept} header using raw String values, possibly not even\n\t * well-formed (for testing purposes).\n\t * @param mediaTypes one or more media types; internally joined as\n\t * comma-separated String\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mediaTypes"
    ],
    "position": {
      "column": 1,
      "line": 328
    },
    "return": "B",
    "signature": "public B accept(String... mediaTypes)",
    "source_code": "\tpublic B accept(String... mediaTypes) {\n\t\tAssert.notEmpty(mediaTypes, \"'mediaTypes' must not be empty\");\n\t\tthis.headers.set(\"Accept\", String.join(\", \", mediaTypes));\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#buildRequest(servletContext)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@link MockHttpServletRequest}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 700
    },
    "return": "MockHttpServletRequest",
    "signature": "public MockHttpServletRequest buildRequest(ServletContext servletContext)",
    "source_code": "\tpublic final MockHttpServletRequest buildRequest(ServletContext servletContext) {\n\t\tAssert.notNull(this.uri, \"'uri' is required\");\n\t\tMockHttpServletRequest request = createServletRequest(servletContext);\n\n\t\trequest.setAsyncSupported(true);\n\t\trequest.setMethod(this.method.name());\n\n\t\tString requestUri = this.uri.getRawPath();\n\t\trequest.setRequestURI(requestUri);\n\n\t\tif (this.uri.getScheme() != null) {\n\t\t\trequest.setScheme(this.uri.getScheme());\n\t\t}\n\t\tif (this.uri.getHost() != null) {\n\t\t\trequest.setServerName(this.uri.getHost());\n\t\t}\n\t\tif (this.uri.getPort() != -1) {\n\t\t\trequest.setServerPort(this.uri.getPort());\n\t\t}\n\n\t\tupdatePathRequestProperties(request, requestUri);\n\n\t\tif (this.secure != null) {\n\t\t\trequest.setSecure(this.secure);\n\t\t}\n\t\tif (this.principal != null) {\n\t\t\trequest.setUserPrincipal(this.principal);\n\t\t}\n\t\tif (this.remoteAddress != null) {\n\t\t\trequest.setRemoteAddr(this.remoteAddress);\n\t\t}\n\t\tif (this.session != null) {\n\t\t\trequest.setSession(this.session);\n\t\t}\n\n\t\trequest.setCharacterEncoding(this.characterEncoding);\n\t\trequest.setContent(this.content);\n\t\trequest.setContentType(this.contentType);\n\n\t\tthis.headers.forEach((name, values) -> {\n\t\t\tfor (Object value : values) {\n\t\t\t\trequest.addHeader(name, value);\n\t\t\t}\n\t\t});\n\n\t\tif (!ObjectUtils.isEmpty(this.content) &&\n\t\t\t\t!this.headers.containsKey(HttpHeaders.CONTENT_LENGTH) &&\n\t\t\t\t!this.headers.containsKey(HttpHeaders.TRANSFER_ENCODING)) {\n\n\t\t\trequest.addHeader(HttpHeaders.CONTENT_LENGTH, this.content.length);\n\t\t}\n\n\t\tString query = this.uri.getRawQuery();\n\t\tif (!this.queryParams.isEmpty()) {\n\t\t\tString str = UriComponentsBuilder.newInstance().queryParams(this.queryParams).build().encode().getQuery();\n\t\t\tquery = StringUtils.hasLength(query) ? (query + \"&\" + str) : str;\n\t\t}\n\t\tif (query != null) {\n\t\t\trequest.setQueryString(query);\n\t\t}\n\t\taddRequestParams(request, UriComponentsBuilder.fromUri(this.uri).build().getQueryParams());\n\n\t\tthis.parameters.forEach((name, values) -> {\n\t\t\tfor (String value : values) {\n\t\t\t\trequest.addParameter(name, value);\n\t\t\t}\n\t\t});\n\n\t\tif (!this.formFields.isEmpty()) {\n\t\t\tif (this.content != null && this.content.length > 0) {\n\t\t\t\tthrow new IllegalStateException(\"Could not write form data with an existing body\");\n\t\t\t}\n\t\t\tCharset charset = (this.characterEncoding != null ?\n\t\t\t\t\tCharset.forName(this.characterEncoding) : StandardCharsets.UTF_8);\n\t\t\tMediaType mediaType = (request.getContentType() != null ?\n\t\t\t\t\tMediaType.parseMediaType(request.getContentType()) :\n\t\t\t\t\tnew MediaType(MediaType.APPLICATION_FORM_URLENCODED, charset));\n\t\t\tif (!mediaType.isCompatibleWith(MediaType.APPLICATION_FORM_URLENCODED)) {\n\t\t\t\tthrow new IllegalStateException(\"Invalid content type: '\" + mediaType +\n\t\t\t\t\t\t\"' is not compatible with '\" + MediaType.APPLICATION_FORM_URLENCODED + \"'\");\n\t\t\t}\n\t\t\trequest.setContent(writeFormData(mediaType, charset));\n\t\t\tif (request.getContentType() == null) {\n\t\t\t\trequest.setContentType(mediaType.toString());\n\t\t\t}\n\t\t}\n\t\tif (this.content != null && this.content.length > 0) {\n\t\t\tString requestContentType = request.getContentType();\n\t\t\tif (requestContentType != null) {\n\t\t\t\ttry {\n\t\t\t\t\tMediaType mediaType = MediaType.parseMediaType(requestContentType);\n\t\t\t\t\tif (MediaType.APPLICATION_FORM_URLENCODED.includes(mediaType)) {\n\t\t\t\t\t\taddRequestParams(request, parseFormData(mediaType));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t// Must be invalid, ignore\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!ObjectUtils.isEmpty(this.cookies)) {\n\t\t\trequest.setCookies(this.cookies.toArray(new Cookie[0]));\n\t\t}\n\t\tif (!ObjectUtils.isEmpty(this.locales)) {\n\t\t\trequest.setPreferredLocales(this.locales);\n\t\t}\n\n\t\tthis.requestAttributes.forEach(request::setAttribute);\n\t\tthis.sessionAttributes.forEach((name, attribute) -> {\n\t\t\tHttpSession session = request.getSession();\n\t\t\tAssert.state(session != null, \"No HttpSession\");\n\t\t\tsession.setAttribute(name, attribute);\n\t\t});\n\n\t\tFlashMap flashMap = new FlashMap();\n\t\tflashMap.putAll(this.flashAttributes);\n\t\tFlashMapManager flashMapManager = getFlashMapManager(request);\n\t\tflashMapManager.saveOutputFlashMap(flashMap, request, new MockHttpServletResponse());\n\n\t\treturn request;\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#characterEncoding(encoding)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the character encoding of the request.\n\t * @param encoding the character encoding\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "B",
    "signature": "public B characterEncoding(String encoding)",
    "source_code": "\tpublic B characterEncoding(String encoding) {\n\t\tthis.characterEncoding = encoding;\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#content(content)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the request body as a UTF-8 String.\n\t * <p>If content is provided and {@link #contentType(MediaType)} is set to\n\t * {@code application/x-www-form-urlencoded}, the content will be parsed\n\t * and used to populate the {@link #param(String, String...) request\n\t * parameters} map.\n\t * @param content the body content\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content"
    ],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "B",
    "signature": "public B content(String content)",
    "source_code": "\tpublic B content(String content) {\n\t\tthis.content = content.getBytes(StandardCharsets.UTF_8);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#contentType(contentType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the 'Content-Type' header of the request as a raw String value,\n\t * possibly not even well-formed (for testing purposes).\n\t * @param contentType the content type\n\t * @since 4.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 306
    },
    "return": "B",
    "signature": "public B contentType(String contentType)",
    "source_code": "\tpublic B contentType(String contentType) {\n\t\tAssert.notNull(contentType, \"'contentType' must not be null\");\n\t\tthis.contentType = contentType;\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#contextPath(contextPath)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the portion of the requestURI that represents the context path.\n\t * The context path, if specified, must match to the start of the request URI.\n\t * <p>In most cases, tests can be written by omitting the context path from\n\t * the requestURI. This is because most applications don't actually depend\n\t * on the name under which they're deployed. If specified here, the context\n\t * path must start with a \"/\" and must not end with a \"/\".\n\t * @see jakarta.servlet.http.HttpServletRequest#getContextPath()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contextPath"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "B",
    "signature": "public B contextPath(String contextPath)",
    "source_code": "\tpublic B contextPath(String contextPath) {\n\t\tif (StringUtils.hasText(contextPath)) {\n\t\t\tAssert.isTrue(contextPath.startsWith(\"/\"), \"Context path must start with a '/'\");\n\t\t\tAssert.isTrue(!contextPath.endsWith(\"/\"), \"Context path must not end with a '/'\");\n\t\t}\n\t\tthis.contextPath = contextPath;\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#cookie(cookies)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given cookies to the request. Cookies are always added.\n\t * @param cookies the cookies to add\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cookies"
    ],
    "position": {
      "column": 1,
      "line": 443
    },
    "return": "B",
    "signature": "public B cookie(Cookie... cookies)",
    "source_code": "\tpublic B cookie(Cookie... cookies) {\n\t\tAssert.notEmpty(cookies, \"'cookies' must not be empty\");\n\t\tthis.cookies.addAll(Arrays.asList(cookies));\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#createServletRequest(servletContext)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link MockHttpServletRequest} based on the supplied\n\t * {@code ServletContext}.\n\t * <p>Can be overridden in subclasses.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 828
    },
    "return": "MockHttpServletRequest",
    "signature": "protected MockHttpServletRequest createServletRequest(ServletContext servletContext)",
    "source_code": "\tprotected MockHttpServletRequest createServletRequest(ServletContext servletContext) {\n\t\treturn new MockHttpServletRequest(servletContext);\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#flashAttr(name,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set an \"input\" flash attribute.\n\t * @param name the flash attribute name\n\t * @param value the flash attribute value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 509
    },
    "return": "B",
    "signature": "public B flashAttr(String name, Object value)",
    "source_code": "\tpublic B flashAttr(String name, Object value) {\n\t\taddToMap(this.flashAttributes, name, value);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#flashAttrs(Map<String,flashAttributes)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set flash attributes.\n\t * @param flashAttributes the flash attributes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "flashAttributes"
    ],
    "position": {
      "column": 1,
      "line": 518
    },
    "return": "B",
    "signature": "public B flashAttrs(Map<String, Object> flashAttributes)",
    "source_code": "\tpublic B flashAttrs(Map<String, Object> flashAttributes) {\n\t\tAssert.notEmpty(flashAttributes, \"'flashAttributes' must not be empty\");\n\t\tflashAttributes.forEach(this::flashAttr);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#formField(name,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Append the given value(s) to the given form field and also add them to the\n\t * {@linkplain #param(String, String...) request parameters} map.\n\t * @param name the field name\n\t * @param values one or more values\n\t * @since 6.1.7\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 422
    },
    "return": "B",
    "signature": "public B formField(String name, String... values)",
    "source_code": "\tpublic B formField(String name, String... values) {\n\t\tparam(name, values);\n\t\tthis.formFields.addAll(name, Arrays.asList(values));\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#formFields(MultiValueMap<String,formFields)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #formField(String, String...)} with a {@link MultiValueMap}.\n\t * @param formFields the form fields to add\n\t * @since 6.1.7\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "formFields"
    ],
    "position": {
      "column": 1,
      "line": 433
    },
    "return": "B",
    "signature": "public B formFields(MultiValueMap<String, String> formFields)",
    "source_code": "\tpublic B formFields(MultiValueMap<String, String> formFields) {\n\t\tparams(formFields);\n\t\tthis.formFields.addAll(formFields);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#getBody()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 892
    },
    "return": "InputStream",
    "signature": "public InputStream getBody()",
    "source_code": "\t\t\tpublic InputStream getBody() {\n\t\t\t\tbyte[] bodyContent = AbstractMockHttpServletRequestBuilder.this.content;\n\t\t\t\treturn (bodyContent != null ? new ByteArrayInputStream(bodyContent) : InputStream.nullInputStream());\n\t\t\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#getHeaders()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 897
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders getHeaders()",
    "source_code": "\t\t\tpublic HttpHeaders getHeaders() {\n\t\t\t\tHttpHeaders headers = new HttpHeaders();\n\t\t\t\theaders.setContentType(mediaType);\n\t\t\t\treturn headers;\n\t\t\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#header(name,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a header to the request. Values are always added.\n\t * @param name the header name\n\t * @param values one or more header values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 339
    },
    "return": "B",
    "signature": "public B header(String name, Object... values)",
    "source_code": "\tpublic B header(String name, Object... values) {\n\t\taddToMultiValueMap(this.headers, name, values);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#headers(httpHeaders)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add all headers to the request. Values are always added.\n\t * @param httpHeaders the headers and values to add\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "httpHeaders"
    ],
    "position": {
      "column": 1,
      "line": 348
    },
    "return": "B",
    "signature": "public B headers(HttpHeaders httpHeaders)",
    "source_code": "\tpublic B headers(HttpHeaders httpHeaders) {\n\t\thttpHeaders.forEach(this.headers::addAll);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#isMergeEnabled()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * @return always returns {@code true}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 577
    },
    "return": "boolean",
    "signature": "public boolean isMergeEnabled()",
    "source_code": "\tpublic boolean isMergeEnabled() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#locale(locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the locale of the request, overriding any previous locales.\n\t * @param locale the locale, or {@code null} to reset it\n\t * @see #locale(Locale...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 466
    },
    "return": "B",
    "signature": "public B locale(@Nullable Locale locale)",
    "source_code": "\tpublic B locale(@Nullable Locale locale) {\n\t\tthis.locales.clear();\n\t\tif (locale != null) {\n\t\t\tthis.locales.add(locale);\n\t\t}\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#locale(locales)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the specified locales as preferred request locales.\n\t * @param locales the locales to add\n\t * @since 4.3.6\n\t * @see #locale(Locale)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locales"
    ],
    "position": {
      "column": 1,
      "line": 455
    },
    "return": "B",
    "signature": "public B locale(Locale... locales)",
    "source_code": "\tpublic B locale(Locale... locales) {\n\t\tAssert.notEmpty(locales, \"'locales' must not be empty\");\n\t\tthis.locales.addAll(Arrays.asList(locales));\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#merge(parent)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Merges the properties of the \"parent\" RequestBuilder accepting values\n\t * only if not already set in \"this\" instance.\n\t * @param parent the parent {@code RequestBuilder} to inherit properties from\n\t * @return the result of the merge\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parent"
    ],
    "position": {
      "column": 1,
      "line": 588
    },
    "return": "Object",
    "signature": "public Object merge(@Nullable Object parent)",
    "source_code": "\tpublic Object merge(@Nullable Object parent) {\n\t\tif (parent == null) {\n\t\t\treturn this;\n\t\t}\n\t\tif (!(parent instanceof AbstractMockHttpServletRequestBuilder<?> parentBuilder)) {\n\t\t\tthrow new IllegalArgumentException(\"Cannot merge with [\" + parent.getClass().getName() + \"]\");\n\t\t}\n\t\tif (!StringUtils.hasText(this.contextPath)) {\n\t\t\tthis.contextPath = parentBuilder.contextPath;\n\t\t}\n\t\tif (!StringUtils.hasText(this.servletPath)) {\n\t\t\tthis.servletPath = parentBuilder.servletPath;\n\t\t}\n\t\tif (\"\".equals(this.pathInfo)) {\n\t\t\tthis.pathInfo = parentBuilder.pathInfo;\n\t\t}\n\n\t\tif (this.secure == null) {\n\t\t\tthis.secure = parentBuilder.secure;\n\t\t}\n\t\tif (this.principal == null) {\n\t\t\tthis.principal = parentBuilder.principal;\n\t\t}\n\t\tif (this.session == null) {\n\t\t\tthis.session = parentBuilder.session;\n\t\t}\n\t\tif (this.remoteAddress == null) {\n\t\t\tthis.remoteAddress = parentBuilder.remoteAddress;\n\t\t}\n\n\t\tif (this.characterEncoding == null) {\n\t\t\tthis.characterEncoding = parentBuilder.characterEncoding;\n\t\t}\n\t\tif (this.content == null) {\n\t\t\tthis.content = parentBuilder.content;\n\t\t}\n\t\tif (this.contentType == null) {\n\t\t\tthis.contentType = parentBuilder.contentType;\n\t\t}\n\n\t\tfor (Map.Entry<String, List<Object>> entry : parentBuilder.headers.entrySet()) {\n\t\t\tString headerName = entry.getKey();\n\t\t\tif (!this.headers.containsKey(headerName)) {\n\t\t\t\tthis.headers.put(headerName, entry.getValue());\n\t\t\t}\n\t\t}\n\t\tfor (Map.Entry<String, List<String>> entry : parentBuilder.parameters.entrySet()) {\n\t\t\tString paramName = entry.getKey();\n\t\t\tif (!this.parameters.containsKey(paramName)) {\n\t\t\t\tthis.parameters.put(paramName, entry.getValue());\n\t\t\t}\n\t\t}\n\t\tfor (Map.Entry<String, List<String>> entry : parentBuilder.queryParams.entrySet()) {\n\t\t\tString paramName = entry.getKey();\n\t\t\tif (!this.queryParams.containsKey(paramName)) {\n\t\t\t\tthis.queryParams.put(paramName, entry.getValue());\n\t\t\t}\n\t\t}\n\t\tfor (Map.Entry<String, List<String>> entry : parentBuilder.formFields.entrySet()) {\n\t\t\tString paramName = entry.getKey();\n\t\t\tif (!this.formFields.containsKey(paramName)) {\n\t\t\t\tthis.formFields.put(paramName, entry.getValue());\n\t\t\t}\n\t\t}\n\t\tfor (Cookie cookie : parentBuilder.cookies) {\n\t\t\tif (!containsCookie(cookie)) {\n\t\t\t\tthis.cookies.add(cookie);\n\t\t\t}\n\t\t}\n\t\tfor (Locale locale : parentBuilder.locales) {\n\t\t\tif (!this.locales.contains(locale)) {\n\t\t\t\tthis.locales.add(locale);\n\t\t\t}\n\t\t}\n\n\t\tfor (Map.Entry<String, Object> entry : parentBuilder.requestAttributes.entrySet()) {\n\t\t\tString attributeName = entry.getKey();\n\t\t\tif (!this.requestAttributes.containsKey(attributeName)) {\n\t\t\t\tthis.requestAttributes.put(attributeName, entry.getValue());\n\t\t\t}\n\t\t}\n\t\tfor (Map.Entry<String, Object> entry : parentBuilder.sessionAttributes.entrySet()) {\n\t\t\tString attributeName = entry.getKey();\n\t\t\tif (!this.sessionAttributes.containsKey(attributeName)) {\n\t\t\t\tthis.sessionAttributes.put(attributeName, entry.getValue());\n\t\t\t}\n\t\t}\n\t\tfor (Map.Entry<String, Object> entry : parentBuilder.flashAttributes.entrySet()) {\n\t\t\tString attributeName = entry.getKey();\n\t\t\tif (!this.flashAttributes.containsKey(attributeName)) {\n\t\t\t\tthis.flashAttributes.put(attributeName, entry.getValue());\n\t\t\t}\n\t\t}\n\n\t\tthis.postProcessors.addAll(0, parentBuilder.postProcessors);\n\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#param(name,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a request parameter to {@link MockHttpServletRequest#getParameterMap()}.\n\t * <p>In the Servlet API, a request parameter may be parsed from the query\n\t * string and/or from the body of an {@code application/x-www-form-urlencoded}\n\t * request. This method simply adds to the request parameter map. You may\n\t * also use add Servlet request parameters by specifying the query or form\n\t * data through one of the following:\n\t * <ul>\n\t * <li>Supply a URL with a query to {@link MockMvcRequestBuilders}.\n\t * <li>Add query params via {@link #queryParam} or {@link #queryParams}.\n\t * <li>Provide {@link #content} with {@link #contentType}\n\t * {@code application/x-www-form-urlencoded}.\n\t * </ul>\n\t * @param name the parameter name\n\t * @param values one or more values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 369
    },
    "return": "B",
    "signature": "public B param(String name, String... values)",
    "source_code": "\tpublic B param(String name, String... values) {\n\t\taddToMultiValueMap(this.parameters, name, values);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#params(MultiValueMap<String,params)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #param(String, String...)} with a {@link MultiValueMap}.\n\t * @param params the parameters to add\n\t * @since 4.2.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 379
    },
    "return": "B",
    "signature": "public B params(MultiValueMap<String, String> params)",
    "source_code": "\tpublic B params(MultiValueMap<String, String> params) {\n\t\tparams.forEach((name, values) -> {\n\t\t\tfor (String value : values) {\n\t\t\t\tthis.parameters.add(name, value);\n\t\t\t}\n\t\t});\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#pathInfo(pathInfo)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the portion of the requestURI that represents the pathInfo.\n\t * <p>If left unspecified (recommended), the pathInfo will be automatically derived\n\t * by removing the contextPath and the servletPath from the requestURI and using any\n\t * remaining part. If specified here, the pathInfo must start with a \"/\".\n\t * <p>If specified, the pathInfo will be used as-is.\n\t * @see jakarta.servlet.http.HttpServletRequest#getPathInfo()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pathInfo"
    ],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "B",
    "signature": "public B pathInfo(@Nullable String pathInfo)",
    "source_code": "\tpublic B pathInfo(@Nullable String pathInfo) {\n\t\tif (StringUtils.hasText(pathInfo)) {\n\t\t\tAssert.isTrue(pathInfo.startsWith(\"/\"), \"Path info must start with a '/'\");\n\t\t}\n\t\tthis.pathInfo = pathInfo;\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#postProcessRequest(request)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 926
    },
    "return": "MockHttpServletRequest",
    "signature": "public MockHttpServletRequest postProcessRequest(MockHttpServletRequest request)",
    "source_code": "\tpublic MockHttpServletRequest postProcessRequest(MockHttpServletRequest request) {\n\t\tfor (RequestPostProcessor postProcessor : this.postProcessors) {\n\t\t\trequest = postProcessor.postProcessRequest(request);\n\t\t}\n\t\treturn request;\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#principal(principal)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the principal of the request.\n\t * @param principal the principal\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "principal"
    ],
    "position": {
      "column": 1,
      "line": 540
    },
    "return": "B",
    "signature": "public B principal(Principal principal)",
    "source_code": "\tpublic B principal(Principal principal) {\n\t\tAssert.notNull(principal, \"'principal' must not be null\");\n\t\tthis.principal = principal;\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#queryParam(name,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Append to the query string and also add to the\n\t * {@link #param(String, String...) request parameters} map. The parameter\n\t * name and value are encoded when they are added to the query string.\n\t * @param name the parameter name\n\t * @param values one or more values\n\t * @since 5.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 396
    },
    "return": "B",
    "signature": "public B queryParam(String name, String... values)",
    "source_code": "\tpublic B queryParam(String name, String... values) {\n\t\tparam(name, values);\n\t\tthis.queryParams.addAll(name, Arrays.asList(values));\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#queryParams(MultiValueMap<String,params)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Append to the query string and also add to the\n\t * {@link #params(MultiValueMap) request parameters} map. The parameter\n\t * name and value are encoded when they are added to the query string.\n\t * @param params the parameters to add\n\t * @since 5.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 409
    },
    "return": "B",
    "signature": "public B queryParams(MultiValueMap<String, String> params)",
    "source_code": "\tpublic B queryParams(MultiValueMap<String, String> params) {\n\t\tparams(params);\n\t\tthis.queryParams.addAll(params);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#remoteAddress(remoteAddress)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the remote address of the request.\n\t * @param remoteAddress the remote address (IP)\n\t * @since 6.0.10\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "remoteAddress"
    ],
    "position": {
      "column": 1,
      "line": 551
    },
    "return": "B",
    "signature": "public B remoteAddress(String remoteAddress)",
    "source_code": "\tpublic B remoteAddress(String remoteAddress) {\n\t\tAssert.hasText(remoteAddress, \"'remoteAddress' must not be null or blank\");\n\t\tthis.remoteAddress = remoteAddress;\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#requestAttr(name,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a request attribute.\n\t * @param name the attribute name\n\t * @param value the attribute value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 479
    },
    "return": "B",
    "signature": "public B requestAttr(String name, Object value)",
    "source_code": "\tpublic B requestAttr(String name, Object value) {\n\t\taddToMap(this.requestAttributes, name, value);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#secure(secure)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the secure property of the {@link ServletRequest} indicating use of a\n\t * secure channel, such as HTTPS.\n\t * @param secure whether the request is using a secure channel\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "secure"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "B",
    "signature": "public B secure(boolean secure)",
    "source_code": "\tpublic B secure(boolean secure){\n\t\tthis.secure = secure;\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#self()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "B",
    "signature": "protected B self()",
    "source_code": "\tprotected B self() {\n\t\treturn (B) this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#servletPath(servletPath)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the portion of the requestURI that represents the path to which\n\t * the Servlet is mapped. This is typically a portion of the requestURI\n\t * after the context path.\n\t * <p>In most cases, tests can be written by omitting the servlet path from\n\t * the requestURI. This is because most applications don't actually depend\n\t * on the prefix to which a servlet is mapped. For example if a Servlet is\n\t * mapped to {@code \"/main/*\"}, tests can be written with the requestURI\n\t * {@code \"/accounts/1\"} as opposed to {@code \"/main/accounts/1\"}.\n\t * If specified here, the servletPath must start with a \"/\" and must not\n\t * end with a \"/\".\n\t * @see jakarta.servlet.http.HttpServletRequest#getServletPath()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletPath"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "B",
    "signature": "public B servletPath(String servletPath)",
    "source_code": "\tpublic B servletPath(String servletPath) {\n\t\tif (StringUtils.hasText(servletPath)) {\n\t\t\tAssert.isTrue(servletPath.startsWith(\"/\"), \"Servlet path must start with a '/'\");\n\t\t\tAssert.isTrue(!servletPath.endsWith(\"/\"), \"Servlet path must not end with a '/'\");\n\t\t}\n\t\tthis.servletPath = servletPath;\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#session(session)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the HTTP session to use, possibly re-used across requests.\n\t * <p>Individual attributes provided via {@link #sessionAttr(String, Object)}\n\t * override the content of the session provided here.\n\t * @param session the HTTP session\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 530
    },
    "return": "B",
    "signature": "public B session(MockHttpSession session)",
    "source_code": "\tpublic B session(MockHttpSession session) {\n\t\tAssert.notNull(session, \"'session' must not be null\");\n\t\tthis.session = session;\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#sessionAttr(name,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a session attribute.\n\t * @param name the session attribute name\n\t * @param value the session attribute value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 489
    },
    "return": "B",
    "signature": "public B sessionAttr(String name, Object value)",
    "source_code": "\tpublic B sessionAttr(String name, Object value) {\n\t\taddToMap(this.sessionAttributes, name, value);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#sessionAttrs(Map<String,sessionAttributes)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set session attributes.\n\t * @param sessionAttributes the session attributes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "sessionAttributes"
    ],
    "position": {
      "column": 1,
      "line": 498
    },
    "return": "B",
    "signature": "public B sessionAttrs(Map<String, Object> sessionAttributes)",
    "source_code": "\tpublic B sessionAttrs(Map<String, Object> sessionAttributes) {\n\t\tAssert.notEmpty(sessionAttributes, \"'sessionAttributes' must not be empty\");\n\t\tsessionAttributes.forEach(this::sessionAttr);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#uri(uri)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the URI using an absolute, fully constructed {@link java.net.URI}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uri"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "B",
    "signature": "public B uri(URI uri)",
    "source_code": "\tpublic B uri(URI uri) {\n\t\tthis.uri = uri;\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#uri(uriTemplate,uriVariables)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the URI for the request using a URI template and URI variables.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "B",
    "signature": "public B uri(String uriTemplate, Object... uriVariables)",
    "source_code": "\tpublic B uri(String uriTemplate, Object... uriVariables) {\n\t\treturn uri(initUri(uriTemplate, uriVariables));\n\t}"
  },
  "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#with(postProcessor)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * An extension point for further initialization of {@link MockHttpServletRequest}\n\t * in ways not built directly into the {@code MockHttpServletRequestBuilder}.\n\t * Implementation of this interface can have builder-style methods themselves\n\t * and be made accessible through static factory methods.\n\t * @param postProcessor a post-processor to add\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 565
    },
    "return": "B",
    "signature": "public B with(RequestPostProcessor postProcessor)",
    "source_code": "\tpublic B with(RequestPostProcessor postProcessor) {\n\t\tAssert.notNull(postProcessor, \"postProcessor is required\");\n\t\tthis.postProcessors.add(postProcessor);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Default builder for {@link MockHttpServletRequest} required as input to\n * perform requests in {@link MockMvc}.\n *\n * <p>Application tests will typically access this builder through the static\n * factory methods in {@link MockMvcRequestBuilders}.\n *\n * <p>This class is not open for extension. To apply custom initialization to\n * the created {@code MockHttpServletRequest}, please use the\n * {@link #with(RequestPostProcessor)} extension point.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Arjen Poutsma\n * @author Sam Brannen\n * @author Kamill Sokol\n * @since 3.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "signature": "public class MockHttpServletRequestBuilder",
    "source_code": "public class MockHttpServletRequestBuilder"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#accept(mediaTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@code Accept} header using raw String values, possibly not even\n\t * well-formed (for testing purposes).\n\t * @param mediaTypes one or more media types; internally joined as\n\t * comma-separated String\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mediaTypes"
    ],
    "position": {
      "column": 1,
      "line": 343
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder accept(String... mediaTypes)",
    "source_code": "\tpublic MockHttpServletRequestBuilder accept(String... mediaTypes) {\n\t\tAssert.notEmpty(mediaTypes, \"'mediaTypes' must not be empty\");\n\t\tthis.headers.set(\"Accept\", String.join(\", \", mediaTypes));\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#buildRequest(servletContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@link MockHttpServletRequest}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 715
    },
    "return": "MockHttpServletRequest",
    "signature": "public MockHttpServletRequest buildRequest(ServletContext servletContext)",
    "source_code": "\tpublic final MockHttpServletRequest buildRequest(ServletContext servletContext) {\n\t\tMockHttpServletRequest request = createServletRequest(servletContext);\n\n\t\trequest.setAsyncSupported(true);\n\t\trequest.setMethod(this.method);\n\n\t\tString requestUri = this.url.getRawPath();\n\t\trequest.setRequestURI(requestUri);\n\n\t\tif (this.url.getScheme() != null) {\n\t\t\trequest.setScheme(this.url.getScheme());\n\t\t}\n\t\tif (this.url.getHost() != null) {\n\t\t\trequest.setServerName(this.url.getHost());\n\t\t}\n\t\tif (this.url.getPort() != -1) {\n\t\t\trequest.setServerPort(this.url.getPort());\n\t\t}\n\n\t\tupdatePathRequestProperties(request, requestUri);\n\n\t\tif (this.secure != null) {\n\t\t\trequest.setSecure(this.secure);\n\t\t}\n\t\tif (this.principal != null) {\n\t\t\trequest.setUserPrincipal(this.principal);\n\t\t}\n\t\tif (this.remoteAddress != null) {\n\t\t\trequest.setRemoteAddr(this.remoteAddress);\n\t\t}\n\t\tif (this.session != null) {\n\t\t\trequest.setSession(this.session);\n\t\t}\n\n\t\trequest.setCharacterEncoding(this.characterEncoding);\n\t\trequest.setContent(this.content);\n\t\trequest.setContentType(this.contentType);\n\n\t\tthis.headers.forEach((name, values) -> {\n\t\t\tfor (Object value : values) {\n\t\t\t\trequest.addHeader(name, value);\n\t\t\t}\n\t\t});\n\n\t\tif (!ObjectUtils.isEmpty(this.content) &&\n\t\t\t\t!this.headers.containsKey(HttpHeaders.CONTENT_LENGTH) &&\n\t\t\t\t!this.headers.containsKey(HttpHeaders.TRANSFER_ENCODING)) {\n\n\t\t\trequest.addHeader(HttpHeaders.CONTENT_LENGTH, this.content.length);\n\t\t}\n\n\t\tString query = this.url.getRawQuery();\n\t\tif (!this.queryParams.isEmpty()) {\n\t\t\tString str = UriComponentsBuilder.newInstance().queryParams(this.queryParams).build().encode().getQuery();\n\t\t\tquery = StringUtils.hasLength(query) ? (query + \"&\" + str) : str;\n\t\t}\n\t\tif (query != null) {\n\t\t\trequest.setQueryString(query);\n\t\t}\n\t\taddRequestParams(request, UriComponentsBuilder.fromUri(this.url).build().getQueryParams());\n\n\t\tthis.parameters.forEach((name, values) -> {\n\t\t\tfor (String value : values) {\n\t\t\t\trequest.addParameter(name, value);\n\t\t\t}\n\t\t});\n\n\t\tif (!this.formFields.isEmpty()) {\n\t\t\tif (this.content != null && this.content.length > 0) {\n\t\t\t\tthrow new IllegalStateException(\"Could not write form data with an existing body\");\n\t\t\t}\n\t\t\tCharset charset = (this.characterEncoding != null ?\n\t\t\t\t\tCharset.forName(this.characterEncoding) : StandardCharsets.UTF_8);\n\t\t\tMediaType mediaType = (request.getContentType() != null ?\n\t\t\t\t\tMediaType.parseMediaType(request.getContentType()) :\n\t\t\t\t\tnew MediaType(MediaType.APPLICATION_FORM_URLENCODED, charset));\n\t\t\tif (!mediaType.isCompatibleWith(MediaType.APPLICATION_FORM_URLENCODED)) {\n\t\t\t\tthrow new IllegalStateException(\"Invalid content type: '\" + mediaType +\n\t\t\t\t\t\t\"' is not compatible with '\" + MediaType.APPLICATION_FORM_URLENCODED + \"'\");\n\t\t\t}\n\t\t\trequest.setContent(writeFormData(mediaType, charset));\n\t\t\tif (request.getContentType() == null) {\n\t\t\t\trequest.setContentType(mediaType.toString());\n\t\t\t}\n\t\t}\n\t\tif (this.content != null && this.content.length > 0) {\n\t\t\tString requestContentType = request.getContentType();\n\t\t\tif (requestContentType != null) {\n\t\t\t\ttry {\n\t\t\t\t\tMediaType mediaType = MediaType.parseMediaType(requestContentType);\n\t\t\t\t\tif (MediaType.APPLICATION_FORM_URLENCODED.includes(mediaType)) {\n\t\t\t\t\t\taddRequestParams(request, parseFormData(mediaType));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t// Must be invalid, ignore..\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!ObjectUtils.isEmpty(this.cookies)) {\n\t\t\trequest.setCookies(this.cookies.toArray(new Cookie[0]));\n\t\t}\n\t\tif (!ObjectUtils.isEmpty(this.locales)) {\n\t\t\trequest.setPreferredLocales(this.locales);\n\t\t}\n\n\t\tthis.requestAttributes.forEach(request::setAttribute);\n\t\tthis.sessionAttributes.forEach((name, attribute) -> {\n\t\t\tHttpSession session = request.getSession();\n\t\t\tAssert.state(session != null, \"No HttpSession\");\n\t\t\tsession.setAttribute(name, attribute);\n\t\t});\n\n\t\tFlashMap flashMap = new FlashMap();\n\t\tflashMap.putAll(this.flashAttributes);\n\t\tFlashMapManager flashMapManager = getFlashMapManager(request);\n\t\tflashMapManager.saveOutputFlashMap(flashMap, request, new MockHttpServletResponse());\n\n\t\treturn request;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#characterEncoding(encoding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the character encoding of the request.\n\t * @param encoding the character encoding\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 270
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder characterEncoding(String encoding)",
    "source_code": "\tpublic MockHttpServletRequestBuilder characterEncoding(String encoding) {\n\t\tthis.characterEncoding = encoding;\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#content(content)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the request body as a UTF-8 String.\n\t * <p>If content is provided and {@link #contentType(MediaType)} is set to\n\t * {@code application/x-www-form-urlencoded}, the content will be parsed\n\t * and used to populate the {@link #param(String, String...) request\n\t * parameters} map.\n\t * @param content the body content\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder content(String content)",
    "source_code": "\tpublic MockHttpServletRequestBuilder content(String content) {\n\t\tthis.content = content.getBytes(StandardCharsets.UTF_8);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#contentType(contentType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the 'Content-Type' header of the request as a raw String value,\n\t * possibly not even well-formed (for testing purposes).\n\t * @param contentType the content type\n\t * @since 4.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 321
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder contentType(String contentType)",
    "source_code": "\tpublic MockHttpServletRequestBuilder contentType(String contentType) {\n\t\tAssert.notNull(contentType, \"'contentType' must not be null\");\n\t\tthis.contentType = contentType;\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#contextPath(contextPath)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the portion of the requestURI that represents the context path.\n\t * The context path, if specified, must match to the start of the request URI.\n\t * <p>In most cases, tests can be written by omitting the context path from\n\t * the requestURI. This is because most applications don't actually depend\n\t * on the name under which they're deployed. If specified here, the context\n\t * path must start with a \"/\" and must not end with a \"/\".\n\t * @see jakarta.servlet.http.HttpServletRequest#getContextPath()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contextPath"
    ],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder contextPath(String contextPath)",
    "source_code": "\tpublic MockHttpServletRequestBuilder contextPath(String contextPath) {\n\t\tif (StringUtils.hasText(contextPath)) {\n\t\t\tAssert.isTrue(contextPath.startsWith(\"/\"), \"Context path must start with a '/'\");\n\t\t\tAssert.isTrue(!contextPath.endsWith(\"/\"), \"Context path must not end with a '/'\");\n\t\t}\n\t\tthis.contextPath = contextPath;\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#cookie(cookies)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given cookies to the request. Cookies are always added.\n\t * @param cookies the cookies to add\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cookies"
    ],
    "position": {
      "column": 1,
      "line": 458
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder cookie(Cookie... cookies)",
    "source_code": "\tpublic MockHttpServletRequestBuilder cookie(Cookie... cookies) {\n\t\tAssert.notEmpty(cookies, \"'cookies' must not be empty\");\n\t\tthis.cookies.addAll(Arrays.asList(cookies));\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#createServletRequest(servletContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link MockHttpServletRequest} based on the supplied\n\t * {@code ServletContext}.\n\t * <p>Can be overridden in subclasses.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 842
    },
    "return": "MockHttpServletRequest",
    "signature": "protected MockHttpServletRequest createServletRequest(ServletContext servletContext)",
    "source_code": "\tprotected MockHttpServletRequest createServletRequest(ServletContext servletContext) {\n\t\treturn new MockHttpServletRequest(servletContext);\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#flashAttr(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set an \"input\" flash attribute.\n\t * @param name the flash attribute name\n\t * @param value the flash attribute value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 524
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder flashAttr(String name, Object value)",
    "source_code": "\tpublic MockHttpServletRequestBuilder flashAttr(String name, Object value) {\n\t\taddToMap(this.flashAttributes, name, value);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#flashAttrs(Map<String,flashAttributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set flash attributes.\n\t * @param flashAttributes the flash attributes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "flashAttributes"
    ],
    "position": {
      "column": 1,
      "line": 533
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder flashAttrs(Map<String, Object> flashAttributes)",
    "source_code": "\tpublic MockHttpServletRequestBuilder flashAttrs(Map<String, Object> flashAttributes) {\n\t\tAssert.notEmpty(flashAttributes, \"'flashAttributes' must not be empty\");\n\t\tflashAttributes.forEach(this::flashAttr);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#formField(name,values)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Append the given value(s) to the given form field and also add them to the\n\t * {@linkplain #param(String, String...) request parameters} map.\n\t * @param name the field name\n\t * @param values one or more values\n\t * @since 6.1.7\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 437
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder formField(String name, String... values)",
    "source_code": "\tpublic MockHttpServletRequestBuilder formField(String name, String... values) {\n\t\tparam(name, values);\n\t\tthis.formFields.addAll(name, Arrays.asList(values));\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#formFields(MultiValueMap<String,formFields)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #formField(String, String...)} with a {@link MultiValueMap}.\n\t * @param formFields the form fields to add\n\t * @since 6.1.7\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "formFields"
    ],
    "position": {
      "column": 1,
      "line": 448
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder formFields(MultiValueMap<String, String> formFields)",
    "source_code": "\tpublic MockHttpServletRequestBuilder formFields(MultiValueMap<String, String> formFields) {\n\t\tparams(formFields);\n\t\tthis.formFields.addAll(formFields);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#getBody()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 905
    },
    "return": "InputStream",
    "signature": "public InputStream getBody()",
    "source_code": "\t\t\tpublic InputStream getBody() {\n\t\t\t\treturn (content != null ? new ByteArrayInputStream(content) : InputStream.nullInputStream());\n\t\t\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#getHeaders()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 909
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders getHeaders()",
    "source_code": "\t\t\tpublic HttpHeaders getHeaders() {\n\t\t\t\tHttpHeaders headers = new HttpHeaders();\n\t\t\t\theaders.setContentType(mediaType);\n\t\t\t\treturn headers;\n\t\t\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#header(name,values)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a header to the request. Values are always added.\n\t * @param name the header name\n\t * @param values one or more header values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 354
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder header(String name, Object... values)",
    "source_code": "\tpublic MockHttpServletRequestBuilder header(String name, Object... values) {\n\t\taddToMultiValueMap(this.headers, name, values);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#headers(httpHeaders)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add all headers to the request. Values are always added.\n\t * @param httpHeaders the headers and values to add\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "httpHeaders"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder headers(HttpHeaders httpHeaders)",
    "source_code": "\tpublic MockHttpServletRequestBuilder headers(HttpHeaders httpHeaders) {\n\t\thttpHeaders.forEach(this.headers::addAll);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#isMergeEnabled()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * @return always returns {@code true}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 592
    },
    "return": "boolean",
    "signature": "public boolean isMergeEnabled()",
    "source_code": "\tpublic boolean isMergeEnabled() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#locale(locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the locale of the request, overriding any previous locales.\n\t * @param locale the locale, or {@code null} to reset it\n\t * @see #locale(Locale...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 481
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder locale(@Nullable Locale locale)",
    "source_code": "\tpublic MockHttpServletRequestBuilder locale(@Nullable Locale locale) {\n\t\tthis.locales.clear();\n\t\tif (locale != null) {\n\t\t\tthis.locales.add(locale);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#locale(locales)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the specified locales as preferred request locales.\n\t * @param locales the locales to add\n\t * @since 4.3.6\n\t * @see #locale(Locale)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locales"
    ],
    "position": {
      "column": 1,
      "line": 470
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder locale(Locale... locales)",
    "source_code": "\tpublic MockHttpServletRequestBuilder locale(Locale... locales) {\n\t\tAssert.notEmpty(locales, \"'locales' must not be empty\");\n\t\tthis.locales.addAll(Arrays.asList(locales));\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#merge(parent)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Merges the properties of the \"parent\" RequestBuilder accepting values\n\t * only if not already set in \"this\" instance.\n\t * @param parent the parent {@code RequestBuilder} to inherit properties from\n\t * @return the result of the merge\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parent"
    ],
    "position": {
      "column": 1,
      "line": 603
    },
    "return": "Object",
    "signature": "public Object merge(@Nullable Object parent)",
    "source_code": "\tpublic Object merge(@Nullable Object parent) {\n\t\tif (parent == null) {\n\t\t\treturn this;\n\t\t}\n\t\tif (!(parent instanceof MockHttpServletRequestBuilder parentBuilder)) {\n\t\t\tthrow new IllegalArgumentException(\"Cannot merge with [\" + parent.getClass().getName() + \"]\");\n\t\t}\n\t\tif (!StringUtils.hasText(this.contextPath)) {\n\t\t\tthis.contextPath = parentBuilder.contextPath;\n\t\t}\n\t\tif (!StringUtils.hasText(this.servletPath)) {\n\t\t\tthis.servletPath = parentBuilder.servletPath;\n\t\t}\n\t\tif (\"\".equals(this.pathInfo)) {\n\t\t\tthis.pathInfo = parentBuilder.pathInfo;\n\t\t}\n\n\t\tif (this.secure == null) {\n\t\t\tthis.secure = parentBuilder.secure;\n\t\t}\n\t\tif (this.principal == null) {\n\t\t\tthis.principal = parentBuilder.principal;\n\t\t}\n\t\tif (this.session == null) {\n\t\t\tthis.session = parentBuilder.session;\n\t\t}\n\t\tif (this.remoteAddress == null) {\n\t\t\tthis.remoteAddress = parentBuilder.remoteAddress;\n\t\t}\n\n\t\tif (this.characterEncoding == null) {\n\t\t\tthis.characterEncoding = parentBuilder.characterEncoding;\n\t\t}\n\t\tif (this.content == null) {\n\t\t\tthis.content = parentBuilder.content;\n\t\t}\n\t\tif (this.contentType == null) {\n\t\t\tthis.contentType = parentBuilder.contentType;\n\t\t}\n\n\t\tfor (Map.Entry<String, List<Object>> entry : parentBuilder.headers.entrySet()) {\n\t\t\tString headerName = entry.getKey();\n\t\t\tif (!this.headers.containsKey(headerName)) {\n\t\t\t\tthis.headers.put(headerName, entry.getValue());\n\t\t\t}\n\t\t}\n\t\tfor (Map.Entry<String, List<String>> entry : parentBuilder.parameters.entrySet()) {\n\t\t\tString paramName = entry.getKey();\n\t\t\tif (!this.parameters.containsKey(paramName)) {\n\t\t\t\tthis.parameters.put(paramName, entry.getValue());\n\t\t\t}\n\t\t}\n\t\tfor (Map.Entry<String, List<String>> entry : parentBuilder.queryParams.entrySet()) {\n\t\t\tString paramName = entry.getKey();\n\t\t\tif (!this.queryParams.containsKey(paramName)) {\n\t\t\t\tthis.queryParams.put(paramName, entry.getValue());\n\t\t\t}\n\t\t}\n\t\tfor (Map.Entry<String, List<String>> entry : parentBuilder.formFields.entrySet()) {\n\t\t\tString paramName = entry.getKey();\n\t\t\tif (!this.formFields.containsKey(paramName)) {\n\t\t\t\tthis.formFields.put(paramName, entry.getValue());\n\t\t\t}\n\t\t}\n\t\tfor (Cookie cookie : parentBuilder.cookies) {\n\t\t\tif (!containsCookie(cookie)) {\n\t\t\t\tthis.cookies.add(cookie);\n\t\t\t}\n\t\t}\n\t\tfor (Locale locale : parentBuilder.locales) {\n\t\t\tif (!this.locales.contains(locale)) {\n\t\t\t\tthis.locales.add(locale);\n\t\t\t}\n\t\t}\n\n\t\tfor (Map.Entry<String, Object> entry : parentBuilder.requestAttributes.entrySet()) {\n\t\t\tString attributeName = entry.getKey();\n\t\t\tif (!this.requestAttributes.containsKey(attributeName)) {\n\t\t\t\tthis.requestAttributes.put(attributeName, entry.getValue());\n\t\t\t}\n\t\t}\n\t\tfor (Map.Entry<String, Object> entry : parentBuilder.sessionAttributes.entrySet()) {\n\t\t\tString attributeName = entry.getKey();\n\t\t\tif (!this.sessionAttributes.containsKey(attributeName)) {\n\t\t\t\tthis.sessionAttributes.put(attributeName, entry.getValue());\n\t\t\t}\n\t\t}\n\t\tfor (Map.Entry<String, Object> entry : parentBuilder.flashAttributes.entrySet()) {\n\t\t\tString attributeName = entry.getKey();\n\t\t\tif (!this.flashAttributes.containsKey(attributeName)) {\n\t\t\t\tthis.flashAttributes.put(attributeName, entry.getValue());\n\t\t\t}\n\t\t}\n\n\t\tthis.postProcessors.addAll(0, parentBuilder.postProcessors);\n\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#param(name,values)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a request parameter to {@link MockHttpServletRequest#getParameterMap()}.\n\t * <p>In the Servlet API, a request parameter may be parsed from the query\n\t * string and/or from the body of an {@code application/x-www-form-urlencoded}\n\t * request. This method simply adds to the request parameter map. You may\n\t * also use add Servlet request parameters by specifying the query or form\n\t * data through one of the following:\n\t * <ul>\n\t * <li>Supply a URL with a query to {@link MockMvcRequestBuilders}.\n\t * <li>Add query params via {@link #queryParam} or {@link #queryParams}.\n\t * <li>Provide {@link #content} with {@link #contentType}\n\t * {@code application/x-www-form-urlencoded}.\n\t * </ul>\n\t * @param name the parameter name\n\t * @param values one or more values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder param(String name, String... values)",
    "source_code": "\tpublic MockHttpServletRequestBuilder param(String name, String... values) {\n\t\taddToMultiValueMap(this.parameters, name, values);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#params(MultiValueMap<String,params)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #param(String, String...)} with a {@link MultiValueMap}.\n\t * @param params the parameters to add\n\t * @since 4.2.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 394
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder params(MultiValueMap<String, String> params)",
    "source_code": "\tpublic MockHttpServletRequestBuilder params(MultiValueMap<String, String> params) {\n\t\tparams.forEach((name, values) -> {\n\t\t\tfor (String value : values) {\n\t\t\t\tthis.parameters.add(name, value);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#pathInfo(pathInfo)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the portion of the requestURI that represents the pathInfo.\n\t * <p>If left unspecified (recommended), the pathInfo will be automatically derived\n\t * by removing the contextPath and the servletPath from the requestURI and using any\n\t * remaining part. If specified here, the pathInfo must start with a \"/\".\n\t * <p>If specified, the pathInfo will be used as-is.\n\t * @see jakarta.servlet.http.HttpServletRequest#getPathInfo()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pathInfo"
    ],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder pathInfo(@Nullable String pathInfo)",
    "source_code": "\tpublic MockHttpServletRequestBuilder pathInfo(@Nullable String pathInfo) {\n\t\tif (StringUtils.hasText(pathInfo)) {\n\t\t\tAssert.isTrue(pathInfo.startsWith(\"/\"), \"Path info must start with a '/'\");\n\t\t}\n\t\tthis.pathInfo = pathInfo;\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#postProcessRequest(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 938
    },
    "return": "MockHttpServletRequest",
    "signature": "public MockHttpServletRequest postProcessRequest(MockHttpServletRequest request)",
    "source_code": "\tpublic MockHttpServletRequest postProcessRequest(MockHttpServletRequest request) {\n\t\tfor (RequestPostProcessor postProcessor : this.postProcessors) {\n\t\t\trequest = postProcessor.postProcessRequest(request);\n\t\t}\n\t\treturn request;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#principal(principal)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the principal of the request.\n\t * @param principal the principal\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "principal"
    ],
    "position": {
      "column": 1,
      "line": 555
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder principal(Principal principal)",
    "source_code": "\tpublic MockHttpServletRequestBuilder principal(Principal principal) {\n\t\tAssert.notNull(principal, \"'principal' must not be null\");\n\t\tthis.principal = principal;\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#queryParam(name,values)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Append to the query string and also add to the\n\t * {@link #param(String, String...) request parameters} map. The parameter\n\t * name and value are encoded when they are added to the query string.\n\t * @param name the parameter name\n\t * @param values one or more values\n\t * @since 5.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 411
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder queryParam(String name, String... values)",
    "source_code": "\tpublic MockHttpServletRequestBuilder queryParam(String name, String... values) {\n\t\tparam(name, values);\n\t\tthis.queryParams.addAll(name, Arrays.asList(values));\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#queryParams(MultiValueMap<String,params)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Append to the query string and also add to the\n\t * {@link #params(MultiValueMap) request parameters} map. The parameter\n\t * name and value are encoded when they are added to the query string.\n\t * @param params the parameters to add\n\t * @since 5.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 424
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder queryParams(MultiValueMap<String, String> params)",
    "source_code": "\tpublic MockHttpServletRequestBuilder queryParams(MultiValueMap<String, String> params) {\n\t\tparams(params);\n\t\tthis.queryParams.addAll(params);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#remoteAddress(remoteAddress)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the remote address of the request.\n\t * @param remoteAddress the remote address (IP)\n\t * @since 6.0.10\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "remoteAddress"
    ],
    "position": {
      "column": 1,
      "line": 566
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder remoteAddress(String remoteAddress)",
    "source_code": "\tpublic MockHttpServletRequestBuilder remoteAddress(String remoteAddress) {\n\t\tAssert.hasText(remoteAddress, \"'remoteAddress' must not be null or blank\");\n\t\tthis.remoteAddress = remoteAddress;\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#requestAttr(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a request attribute.\n\t * @param name the attribute name\n\t * @param value the attribute value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 494
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder requestAttr(String name, Object value)",
    "source_code": "\tpublic MockHttpServletRequestBuilder requestAttr(String name, Object value) {\n\t\taddToMap(this.requestAttributes, name, value);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#secure(secure)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the secure property of the {@link ServletRequest} indicating use of a\n\t * secure channel, such as HTTPS.\n\t * @param secure whether the request is using a secure channel\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "secure"
    ],
    "position": {
      "column": 1,
      "line": 250
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder secure(boolean secure)",
    "source_code": "\tpublic MockHttpServletRequestBuilder secure(boolean secure){\n\t\tthis.secure = secure;\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#servletPath(servletPath)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the portion of the requestURI that represents the path to which\n\t * the Servlet is mapped. This is typically a portion of the requestURI\n\t * after the context path.\n\t * <p>In most cases, tests can be written by omitting the servlet path from\n\t * the requestURI. This is because most applications don't actually depend\n\t * on the prefix to which a servlet is mapped. For example if a Servlet is\n\t * mapped to {@code \"/main/*\"}, tests can be written with the requestURI\n\t * {@code \"/accounts/1\"} as opposed to {@code \"/main/accounts/1\"}.\n\t * If specified here, the servletPath must start with a \"/\" and must not\n\t * end with a \"/\".\n\t * @see jakarta.servlet.http.HttpServletRequest#getServletPath()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletPath"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder servletPath(String servletPath)",
    "source_code": "\tpublic MockHttpServletRequestBuilder servletPath(String servletPath) {\n\t\tif (StringUtils.hasText(servletPath)) {\n\t\t\tAssert.isTrue(servletPath.startsWith(\"/\"), \"Servlet path must start with a '/'\");\n\t\t\tAssert.isTrue(!servletPath.endsWith(\"/\"), \"Servlet path must not end with a '/'\");\n\t\t}\n\t\tthis.servletPath = servletPath;\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#session(session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the HTTP session to use, possibly re-used across requests.\n\t * <p>Individual attributes provided via {@link #sessionAttr(String, Object)}\n\t * override the content of the session provided here.\n\t * @param session the HTTP session\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 545
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder session(MockHttpSession session)",
    "source_code": "\tpublic MockHttpServletRequestBuilder session(MockHttpSession session) {\n\t\tAssert.notNull(session, \"'session' must not be null\");\n\t\tthis.session = session;\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#sessionAttr(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a session attribute.\n\t * @param name the session attribute name\n\t * @param value the session attribute value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 504
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder sessionAttr(String name, Object value)",
    "source_code": "\tpublic MockHttpServletRequestBuilder sessionAttr(String name, Object value) {\n\t\taddToMap(this.sessionAttributes, name, value);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#sessionAttrs(Map<String,sessionAttributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set session attributes.\n\t * @param sessionAttributes the session attributes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "sessionAttributes"
    ],
    "position": {
      "column": 1,
      "line": 513
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder sessionAttrs(Map<String, Object> sessionAttributes)",
    "source_code": "\tpublic MockHttpServletRequestBuilder sessionAttrs(Map<String, Object> sessionAttributes) {\n\t\tAssert.notEmpty(sessionAttributes, \"'sessionAttributes' must not be empty\");\n\t\tsessionAttributes.forEach(this::sessionAttr);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#with(postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An extension point for further initialization of {@link MockHttpServletRequest}\n\t * in ways not built directly into the {@code MockHttpServletRequestBuilder}.\n\t * Implementation of this interface can have builder-style methods themselves\n\t * and be made accessible through static factory methods.\n\t * @param postProcessor a post-processor to add\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 580
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder with(RequestPostProcessor postProcessor)",
    "source_code": "\tpublic MockHttpServletRequestBuilder with(RequestPostProcessor postProcessor) {\n\t\tAssert.notNull(postProcessor, \"postProcessor is required\");\n\t\tthis.postProcessors.add(postProcessor);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * A {@code MockMvcBuilder} that accepts {@link RouterFunction} registrations\n * thus allowing full control over the instantiation and initialization of\n * router functions and their dependencies similar to plain unit tests, and also\n * making it possible to test one function at a time.\n *\n * <p>This builder creates the minimum infrastructure required by the\n * {@link DispatcherServlet} to serve requests with router functions and\n * also provides methods for customization. The resulting configuration and\n * customization options are equivalent to using MVC Java config except\n * using builder style methods.\n *\n * <p>To configure view resolution, either select a \"fixed\" view to use for every\n * request performed (see {@link #setSingleView(View)}) or provide a list of\n * {@code ViewResolver}s (see {@link #setViewResolvers(ViewResolver...)}).\n *\n * @author Arjen Poutsma\n * @since 6.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "signature": "public class RouterFunctionMockMvcBuilder",
    "source_code": "public class RouterFunctionMockMvcBuilder extends AbstractMockMvcBuilder<RouterFunctionMockMvcBuilder> {\n\n\tprivate final RouterFunction<?> routerFunction;\n\n\tprivate List<HttpMessageConverter<?>> messageConverters = new ArrayList<>();\n\n\tprivate final List<MappedInterceptor> mappedInterceptors = new ArrayList<>();\n\n\t@Nullable\n\tprivate List<HandlerExceptionResolver> handlerExceptionResolvers;\n\n\t@Nullable\n\tprivate Long asyncRequestTimeout;\n\n\t@Nullable\n\tprivate List<ViewResolver> viewResolvers;\n\n\t@Nullable\n\tprivate PathPatternParser patternParser;\n\n\tprivate Supplier<RouterFunctionMapping> handlerMappingFactory = RouterFunctionMapping::new;\n\n\n\tprotected RouterFunctionMockMvcBuilder(RouterFunction<?>... routerFunctions) {\n\t\tAssert.notEmpty(routerFunctions, \"RouterFunctions must not be empty\");\n\n\t\tthis.routerFunction = Arrays.stream(routerFunctions).reduce(RouterFunction::andOther).orElseThrow();\n\t}\n\n\n\t/**\n\t * Set the message converters to use in argument resolvers and in return value\n\t * handlers, which support reading and/or writing to the body of the request\n\t * and response. If no message converters are added to the list, a default\n\t * list of converters is added instead.\n\t */\n\tpublic RouterFunctionMockMvcBuilder setMessageConverters(HttpMessageConverter<?>...messageConverters) {\n\t\tthis.messageConverters = Arrays.asList(messageConverters);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add interceptors mapped to all incoming requests.\n\t */\n\tpublic RouterFunctionMockMvcBuilder addInterceptors(HandlerInterceptor... interceptors) {\n\t\taddMappedInterceptors(null, interceptors);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add interceptors mapped to a set of path patterns.\n\t */\n\tpublic RouterFunctionMockMvcBuilder addMappedInterceptors(@Nullable String[] pathPatterns,\n\t\t\tHandlerInterceptor... interceptors) {\n\n\t\tfor (HandlerInterceptor interceptor : interceptors) {\n\t\t\tthis.mappedInterceptors.add(new MappedInterceptor(pathPatterns, null, interceptor));\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the HandlerExceptionResolver types to use as a list.\n\t */\n\tpublic RouterFunctionMockMvcBuilder setHandlerExceptionResolvers(List<HandlerExceptionResolver> exceptionResolvers) {\n\t\tthis.handlerExceptionResolvers = exceptionResolvers;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the HandlerExceptionResolver types to use as an array.\n\t */\n\tpublic RouterFunctionMockMvcBuilder setHandlerExceptionResolvers(HandlerExceptionResolver... exceptionResolvers) {\n\t\tthis.handlerExceptionResolvers = Arrays.asList(exceptionResolvers);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Configure the factory to create a custom {@link RequestMappingHandlerMapping}.\n\t * @param factory the factory\n\t */\n\tpublic RouterFunctionMockMvcBuilder setCustomHandlerMapping(Supplier<RouterFunctionMapping> factory) {\n\t\tthis.handlerMappingFactory = factory;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set up view resolution with the given {@link ViewResolver ViewResolvers}.\n\t * <p>If not set, an {@link InternalResourceViewResolver} is used by default.\n\t */\n\tpublic RouterFunctionMockMvcBuilder setViewResolvers(ViewResolver...resolvers) {\n\t\tthis.viewResolvers = Arrays.asList(resolvers);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set up a single {@link ViewResolver} that always returns the provided\n\t * view instance.\n\t * <p>This is a convenient shortcut if you need to use one {@link View}\n\t * instance only &mdash; for example, rendering generated content (JSON, XML,\n\t * Atom).\n\t */\n\tpublic RouterFunctionMockMvcBuilder setSingleView(View view) {\n\t\tthis.viewResolvers = Collections.singletonList(new StaticViewResolver(view));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Specify the timeout value for async execution.\n\t * <p>In Spring MVC Test, this value is used to determine how long to wait\n\t * for async execution to complete so that a test can verify the results\n\t * synchronously.\n\t * @param timeout the timeout value in milliseconds\n\t */\n\tpublic RouterFunctionMockMvcBuilder setAsyncRequestTimeout(long timeout) {\n\t\tthis.asyncRequestTimeout = timeout;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Enable URL path matching with parsed\n\t * {@link org.springframework.web.util.pattern.PathPattern PathPatterns}\n\t * instead of String pattern matching with a {@link org.springframework.util.PathMatcher}.\n\t * @param parser the parser to use\n\t */\n\tpublic RouterFunctionMockMvcBuilder setPatternParser(@Nullable PathPatternParser parser) {\n\t\tthis.patternParser = parser;\n\t\treturn this;\n\t}\n\n\n\t@Override\n\tprotected WebApplicationContext initWebAppContext() {\n\t\tMockServletContext servletContext = new MockServletContext();\n\t\tStubWebApplicationContext wac = new StubWebApplicationContext(servletContext);\n\t\tregisterRouterFunction(wac);\n\t\tservletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, wac);\n\t\treturn wac;\n\t}\n\n\tprivate void registerRouterFunction(StubWebApplicationContext wac) {\n\t\tHandlerFunctionConfiguration config = new HandlerFunctionConfiguration();\n\t\tconfig.setApplicationContext(wac);\n\t\tServletContext sc = wac.getServletContext();\n\n\t\twac.addBean(\"routerFunction\", this.routerFunction);\n\n\t\tFormattingConversionService mvcConversionService = config.mvcConversionService();\n\t\twac.addBean(\"mvcConversionService\", mvcConversionService);\n\t\tResourceUrlProvider resourceUrlProvider = config.mvcResourceUrlProvider();\n\t\twac.addBean(\"mvcResourceUrlProvider\", resourceUrlProvider);\n\t\tContentNegotiationManager mvcContentNegotiationManager = config.mvcContentNegotiationManager();\n\t\twac.addBean(\"mvcContentNegotiationManager\", mvcContentNegotiationManager);\n\n\t\tRouterFunctionMapping hm = config.getHandlerMapping(mvcConversionService, resourceUrlProvider);\n\t\tif (sc != null) {\n\t\t\thm.setServletContext(sc);\n\t\t}\n\t\thm.setApplicationContext(wac);\n\t\thm.afterPropertiesSet();\n\t\twac.addBean(\"routerFunctionMapping\", hm);\n\n\t\tHandlerFunctionAdapter ha = config.handlerFunctionAdapter();\n\t\twac.addBean(\"handlerFunctionAdapter\", ha);\n\n\t\twac.addBean(\"handlerExceptionResolver\", config.handlerExceptionResolver(mvcContentNegotiationManager));\n\n\t\twac.addBeans(initViewResolvers(wac));\n\t}\n\n\tprivate List<ViewResolver> initViewResolvers(WebApplicationContext wac) {\n\t\tthis.viewResolvers = (this.viewResolvers != null ? this.viewResolvers :\n\t\t\t\tCollections.singletonList(new InternalResourceViewResolver()));\n\t\tfor (Object viewResolver : this.viewResolvers) {\n\t\t\tif (viewResolver instanceof WebApplicationObjectSupport support) {\n\t\t\t\tsupport.setApplicationContext(wac);\n\t\t\t}\n\t\t}\n\t\treturn this.viewResolvers;\n\t}\n\n\n\t/** Using the MVC Java configuration as the starting point for the \"standalone\" setup. */\n\tprivate class HandlerFunctionConfiguration extends WebMvcConfigurationSupport {\n\n\t\tpublic RouterFunctionMapping getHandlerMapping(\n\t\t\t\tFormattingConversionService mvcConversionService,\n\t\t\t\tResourceUrlProvider mvcResourceUrlProvider) {\n\n\t\t\tRouterFunctionMapping handlerMapping = handlerMappingFactory.get();\n\t\t\thandlerMapping.setOrder(0);\n\t\t\thandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));\n\t\t\thandlerMapping.setMessageConverters(getMessageConverters());\n\t\t\tif (patternParser != null) {\n\t\t\t\thandlerMapping.setPatternParser(patternParser);\n\t\t\t}\n\t\t\treturn handlerMapping;\n\t\t}\n\n\t\t@Override\n\t\tprotected void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n\t\t\tconverters.addAll(messageConverters);\n\t\t}\n\n\t\t@Override\n\t\tprotected void addInterceptors(InterceptorRegistry registry) {\n\t\t\tfor (MappedInterceptor interceptor : mappedInterceptors) {\n\t\t\t\tInterceptorRegistration registration = registry.addInterceptor(interceptor.getInterceptor());\n\t\t\t\tif (interceptor.getIncludePathPatterns() != null) {\n\t\t\t\t\tregistration.addPathPatterns(interceptor.getIncludePathPatterns());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void configureAsyncSupport(AsyncSupportConfigurer configurer) {\n\t\t\tif (asyncRequestTimeout != null) {\n\t\t\t\tconfigurer.setDefaultTimeout(asyncRequestTimeout);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tprotected void configureHandlerExceptionResolvers(List<HandlerExceptionResolver> exceptionResolvers) {\n\t\t\tif (handlerExceptionResolvers == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (HandlerExceptionResolver resolver : handlerExceptionResolvers) {\n\t\t\t\tif (resolver instanceof ApplicationContextAware applicationContextAware) {\n\t\t\t\t\tApplicationContext applicationContext = getApplicationContext();\n\t\t\t\t\tif (applicationContext != null) {\n\t\t\t\t\t\tapplicationContextAware.setApplicationContext(applicationContext);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (resolver instanceof InitializingBean initializingBean) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tinitializingBean.afterPropertiesSet();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"Failure from afterPropertiesSet\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\texceptionResolvers.add(resolver);\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#addInterceptors(interceptors)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add interceptors mapped to all incoming requests.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "interceptors"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "RouterFunctionMockMvcBuilder",
    "signature": "public RouterFunctionMockMvcBuilder addInterceptors(HandlerInterceptor... interceptors)",
    "source_code": "\tpublic RouterFunctionMockMvcBuilder addInterceptors(HandlerInterceptor... interceptors) {\n\t\taddMappedInterceptors(null, interceptors);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#addInterceptors(registry)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "void",
    "signature": "protected void addInterceptors(InterceptorRegistry registry)",
    "source_code": "\t\tprotected void addInterceptors(InterceptorRegistry registry) {\n\t\t\tfor (MappedInterceptor interceptor : mappedInterceptors) {\n\t\t\t\tInterceptorRegistration registration = registry.addInterceptor(interceptor.getInterceptor());\n\t\t\t\tif (interceptor.getIncludePathPatterns() != null) {\n\t\t\t\t\tregistration.addPathPatterns(interceptor.getIncludePathPatterns());\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#addMappedInterceptors(pathPatterns,interceptors)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add interceptors mapped to a set of path patterns.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pathPatterns",
      "interceptors"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "RouterFunctionMockMvcBuilder",
    "signature": "public RouterFunctionMockMvcBuilder addMappedInterceptors(@Nullable String[] pathPatterns,\n\t\t\tHandlerInterceptor... interceptors)",
    "source_code": "\tpublic RouterFunctionMockMvcBuilder addMappedInterceptors(@Nullable String[] pathPatterns,"
  },
  "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#configureAsyncSupport(configurer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "configurer"
    ],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "void",
    "signature": "public void configureAsyncSupport(AsyncSupportConfigurer configurer)",
    "source_code": "\t\tpublic void configureAsyncSupport(AsyncSupportConfigurer configurer) {\n\t\t\tif (asyncRequestTimeout != null) {\n\t\t\t\tconfigurer.setDefaultTimeout(asyncRequestTimeout);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#configureHandlerExceptionResolvers(exceptionResolvers)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exceptionResolvers"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "void",
    "signature": "protected void configureHandlerExceptionResolvers(List<HandlerExceptionResolver> exceptionResolvers)",
    "source_code": "\t\tprotected void configureHandlerExceptionResolvers(List<HandlerExceptionResolver> exceptionResolvers) {\n\t\t\tif (handlerExceptionResolvers == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (HandlerExceptionResolver resolver : handlerExceptionResolvers) {\n\t\t\t\tif (resolver instanceof ApplicationContextAware applicationContextAware) {\n\t\t\t\t\tApplicationContext applicationContext = getApplicationContext();\n\t\t\t\t\tif (applicationContext != null) {\n\t\t\t\t\t\tapplicationContextAware.setApplicationContext(applicationContext);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (resolver instanceof InitializingBean initializingBean) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tinitializingBean.afterPropertiesSet();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"Failure from afterPropertiesSet\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\texceptionResolvers.add(resolver);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#configureMessageConverters(converters)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "converters"
    ],
    "position": {
      "column": 1,
      "line": 275
    },
    "return": "void",
    "signature": "protected void configureMessageConverters(List<HttpMessageConverter<?>> converters)",
    "source_code": "\t\tprotected void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n\t\t\tconverters.addAll(messageConverters);\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#getHandlerMapping(mvcConversionService,mvcResourceUrlProvider)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mvcConversionService",
      "mvcResourceUrlProvider"
    ],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "RouterFunctionMapping",
    "signature": "public RouterFunctionMapping getHandlerMapping(FormattingConversionService mvcConversionService,\n\t\t\t\tResourceUrlProvider mvcResourceUrlProvider)",
    "source_code": "\t\tpublic RouterFunctionMapping getHandlerMapping("
  },
  "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#initWebAppContext()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "WebApplicationContext",
    "signature": "protected WebApplicationContext initWebAppContext()",
    "source_code": "\tprotected WebApplicationContext initWebAppContext() {\n\t\tMockServletContext servletContext = new MockServletContext();\n\t\tStubWebApplicationContext wac = new StubWebApplicationContext(servletContext);\n\t\tregisterRouterFunction(wac);\n\t\tservletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, wac);\n\t\treturn wac;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#setAsyncRequestTimeout(timeout)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the timeout value for async execution.\n\t * <p>In Spring MVC Test, this value is used to determine how long to wait\n\t * for async execution to complete so that a test can verify the results\n\t * synchronously.\n\t * @param timeout the timeout value in milliseconds\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "RouterFunctionMockMvcBuilder",
    "signature": "public RouterFunctionMockMvcBuilder setAsyncRequestTimeout(long timeout)",
    "source_code": "\tpublic RouterFunctionMockMvcBuilder setAsyncRequestTimeout(long timeout) {\n\t\tthis.asyncRequestTimeout = timeout;\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#setCustomHandlerMapping(factory)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the factory to create a custom {@link RequestMappingHandlerMapping}.\n\t * @param factory the factory\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "factory"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "RouterFunctionMockMvcBuilder",
    "signature": "public RouterFunctionMockMvcBuilder setCustomHandlerMapping(Supplier<RouterFunctionMapping> factory)",
    "source_code": "\tpublic RouterFunctionMockMvcBuilder setCustomHandlerMapping(Supplier<RouterFunctionMapping> factory) {\n\t\tthis.handlerMappingFactory = factory;\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#setHandlerExceptionResolvers(exceptionResolvers)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the HandlerExceptionResolver types to use as an array.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exceptionResolvers"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "RouterFunctionMockMvcBuilder",
    "signature": "public RouterFunctionMockMvcBuilder setHandlerExceptionResolvers(HandlerExceptionResolver... exceptionResolvers)",
    "source_code": "\tpublic RouterFunctionMockMvcBuilder setHandlerExceptionResolvers(HandlerExceptionResolver... exceptionResolvers) {\n\t\tthis.handlerExceptionResolvers = Arrays.asList(exceptionResolvers);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#setMessageConverters(HttpMessageConverter<?>...messageConverters)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the message converters to use in argument resolvers and in return value\n\t * handlers, which support reading and/or writing to the body of the request\n\t * and response. If no message converters are added to the list, a default\n\t * list of converters is added instead.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "HttpMessageConverter<?>...messageConverters"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "RouterFunctionMockMvcBuilder",
    "signature": "public RouterFunctionMockMvcBuilder setMessageConverters(HttpMessageConverter<?>...messageConverters)",
    "source_code": "\tpublic RouterFunctionMockMvcBuilder setMessageConverters(HttpMessageConverter<?>...messageConverters) {\n\t\tthis.messageConverters = Arrays.asList(messageConverters);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#setPatternParser(parser)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Enable URL path matching with parsed\n\t * {@link org.springframework.web.util.pattern.PathPattern PathPatterns}\n\t * instead of String pattern matching with a {@link org.springframework.util.PathMatcher}.\n\t * @param parser the parser to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parser"
    ],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "RouterFunctionMockMvcBuilder",
    "signature": "public RouterFunctionMockMvcBuilder setPatternParser(@Nullable PathPatternParser parser)",
    "source_code": "\tpublic RouterFunctionMockMvcBuilder setPatternParser(@Nullable PathPatternParser parser) {\n\t\tthis.patternParser = parser;\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#setSingleView(view)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set up a single {@link ViewResolver} that always returns the provided\n\t * view instance.\n\t * <p>This is a convenient shortcut if you need to use one {@link View}\n\t * instance only &mdash; for example, rendering generated content (JSON, XML,\n\t * Atom).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "view"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "RouterFunctionMockMvcBuilder",
    "signature": "public RouterFunctionMockMvcBuilder setSingleView(View view)",
    "source_code": "\tpublic RouterFunctionMockMvcBuilder setSingleView(View view) {\n\t\tthis.viewResolvers = Collections.singletonList(new StaticViewResolver(view));\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#setViewResolvers(ViewResolver...resolvers)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set up view resolution with the given {@link ViewResolver ViewResolvers}.\n\t * <p>If not set, an {@link InternalResourceViewResolver} is used by default.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ViewResolver...resolvers"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "RouterFunctionMockMvcBuilder",
    "signature": "public RouterFunctionMockMvcBuilder setViewResolvers(ViewResolver...resolvers)",
    "source_code": "\tpublic RouterFunctionMockMvcBuilder setViewResolvers(ViewResolver...resolvers) {\n\t\tthis.viewResolvers = Arrays.asList(resolvers);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder#resolveViewName(viewName,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 613
    },
    "return": "View",
    "signature": "public View resolveViewName(String viewName, Locale locale)",
    "source_code": "\t\tpublic View resolveViewName(String viewName, Locale locale) {\n\t\t\treturn this.view;\n\t\t}"
  },
  "org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#addDefaultRollbackRule(rollbackRule)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a default rollback rule, to be applied to all rule-based\n\t * transaction attributes returned by this source.\n\t * <p>By default, a rollback will be triggered on unchecked exceptions\n\t * but not on checked exceptions. A default rule may override this\n\t * while still respecting any custom rules in the transaction attribute.\n\t * @param rollbackRule a rollback rule overriding the default behavior,\n\t * e.g. {@link RollbackRuleAttribute#ROLLBACK_ON_ALL_EXCEPTIONS}\n\t * @since 6.2\n\t * @see RuleBasedTransactionAttribute#getRollbackRules()\n\t * @see EnableTransactionManagement#rollbackOn()\n\t * @see Transactional#rollbackFor()\n\t * @see Transactional#noRollbackFor()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rollbackRule"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "void",
    "signature": "public void addDefaultRollbackRule(RollbackRuleAttribute rollbackRule)",
    "source_code": "\tpublic void addDefaultRollbackRule(RollbackRuleAttribute rollbackRule) {\n\t\tif (this.defaultRollbackRules == null) {\n\t\t\tthis.defaultRollbackRules = new LinkedHashSet<>();\n\t\t}\n\t\tthis.defaultRollbackRules.add(rollbackRule);\n\t}"
  },
  "org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#setPublicMethodsOnly(publicMethodsOnly)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether transactional methods are expected to be public.\n\t * <p>The default is {@code true}.\n\t * @since 6.2\n\t * @see #AnnotationTransactionAttributeSource(boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "publicMethodsOnly"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "void",
    "signature": "public void setPublicMethodsOnly(boolean publicMethodsOnly)",
    "source_code": "\tpublic void setPublicMethodsOnly(boolean publicMethodsOnly) {\n\t\tthis.publicMethodsOnly = publicMethodsOnly;\n\t}"
  },
  "org.springframework.transaction.interceptor.AbstractFallbackTransactionAttributeSource#hasTransactionAttribute(method,targetClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "boolean",
    "signature": "public boolean hasTransactionAttribute(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tpublic boolean hasTransactionAttribute(Method method, @Nullable Class<?> targetClass) {\n\t\treturn (getTransactionAttribute(method, targetClass, false) != null);\n\t}"
  },
  "org.springframework.transaction.interceptor.ROLLBACK_ON_ALL_EXCEPTIONS": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * The {@linkplain RollbackRuleAttribute rollback rule} for all\n\t * {@link Exception Exceptions}, including checked exceptions.\n\t * @since 6.2\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "signature": "public RollbackRuleAttribute ROLLBACK_ON_ALL_EXCEPTIONS",
    "source_code": "\tpublic static final RollbackRuleAttribute ROLLBACK_ON_ALL_EXCEPTIONS =",
    "type": "RollbackRuleAttribute"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#determineTransactionManager(txAttr,targetClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the specific transaction manager to use for the given transaction.\n\t * @param txAttr the current transaction attribute\n\t * @param targetClass the target class that the attribute has been declared on\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "txAttr",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 510
    },
    "return": "TransactionManager",
    "signature": "protected TransactionManager determineTransactionManager(@Nullable TransactionAttribute txAttr, @Nullable Class<?> targetClass)",
    "source_code": "\tprotected TransactionManager determineTransactionManager("
  },
  "org.springframework.util.<unknown>#asSingleValueMap()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "V>",
    "signature": "public V> asSingleValueMap()",
    "source_code": "\tpublic Map<K, V> asSingleValueMap() {\n\t\treturn this.delegate.asSingleValueMap();\n\t}"
  },
  "org.springframework.util.<unknown>#equals(o)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o"
    ],
    "position": {
      "column": 1,
      "line": 275
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object o)",
    "source_code": "\tpublic boolean equals(@Nullable Object o) {\n\t\tif (o == this) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (o instanceof Map<?,?> other) {\n\t\t\tif (this.size() != other.size()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tfor (Entry<K, List<V>> e : entrySet()) {\n\t\t\t\t\tK key = e.getKey();\n\t\t\t\t\tList<V> values = e.getValue();\n\t\t\t\t\tif (values == null) {\n\t\t\t\t\t\tif (other.get(key) != null || !other.containsKey(key)) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (!values .equals(other.get(key))) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (ClassCastException | NullPointerException ignore) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 36
    },
    "return": "boolean",
    "signature": "public boolean equals(Object obj)",
    "source_code": "\tpublic boolean equals(Object obj) {\n\t\tif (obj == this) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (obj instanceof Set<?> set) {\n\t\t\tif (set.size() != size()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn containsAll(set);\n\t\t\t}\n\t\t\tcatch (ClassCastException | NullPointerException ignored) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#flagPlaceholderAsVisited(placeholder)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "placeholder"
    ],
    "position": {
      "column": 1,
      "line": 351
    },
    "return": "void",
    "signature": "public void flagPlaceholderAsVisited(String placeholder)",
    "source_code": "\t\tpublic void flagPlaceholderAsVisited(String placeholder) {\n\t\t\tif (this.visitedPlaceholders == null) {\n\t\t\t\tthis.visitedPlaceholders = new HashSet<>(4);\n\t\t\t}\n\t\t\tif (!this.visitedPlaceholders.add(placeholder)) {\n\t\t\t\tthrow new PlaceholderResolutionException(\n\t\t\t\t\t\t\"Circular placeholder reference '%s'\".formatted(placeholder), placeholder, null);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.util.<unknown>#handleUnresolvablePlaceholder(key,text)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "text"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "String",
    "signature": "public String handleUnresolvablePlaceholder(String key, String text)",
    "source_code": "\t\tpublic String handleUnresolvablePlaceholder(String key, String text) {\n\t\t\tif (this.ignoreUnresolvablePlaceholders) {\n\t\t\t\treturn toPlaceholderText(key);\n\t\t\t}\n\t\t\tString originalValue = (!key.equals(text) ? toPlaceholderText(text) : null);\n\t\t\tthrow new PlaceholderResolutionException(\n\t\t\t\t\t\"Could not resolve placeholder '%s'\".formatted(key), key, originalValue);\n\t\t}"
  },
  "org.springframework.util.<unknown>#parse(text)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text"
    ],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "List<Part>",
    "signature": "public List<Part> parse(String text)",
    "source_code": "\t\tpublic List<Part> parse(String text) {\n\t\t\treturn this.parser.apply(text);\n\t\t}"
  },
  "org.springframework.util.<unknown>#put(key,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "List<V>",
    "signature": "public List<V> put(K key, List<V> values)",
    "source_code": "\tpublic List<V> put(K key, List<V> values) {\n\t\tif (values.isEmpty()) {\n\t\t\tV result = this.targetMap.put(key, null);\n\t\t\treturn (result != null) ? Collections.singletonList(result) : null;\n\t\t}\n\t\telse if (values.size() == 1) {\n\t\t\tV result = this.targetMap.put(key, values.get(0));\n\t\t\treturn (result != null) ? Collections.singletonList(result) : null;\n\t\t}\n\t\telse {\n\t\t\tthrow new UnsupportedOperationException(\"Duplicate key: \" + key);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#putAll(K,map)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "K",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends K, ? extends List<V>> map)",
    "source_code": "\tpublic void putAll(Map<? extends K, ? extends List<V>> map) {\n\t\tfor (Entry<? extends K, ? extends List<V>> entry : map.entrySet()) {\n\t\t\tput(entry.getKey(), entry.getValue());\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#removePlaceholder(placeholder)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "placeholder"
    ],
    "position": {
      "column": 1,
      "line": 361
    },
    "return": "void",
    "signature": "public void removePlaceholder(String placeholder)",
    "source_code": "\t\tpublic void removePlaceholder(String placeholder) {\n\t\t\tAssert.state(this.visitedPlaceholders != null, \"Visited placeholders must not be null\");\n\t\t\tthis.visitedPlaceholders.remove(placeholder);\n\t\t}"
  },
  "org.springframework.util.<unknown>#replacePlaceholders(value,placeholderResolver)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Replace all placeholders of format {@code ${name}} with the value returned\n\t * from the supplied {@link PlaceholderResolver}.\n\t * @param value the value containing the placeholders to be replaced\n\t * @param placeholderResolver the {@code PlaceholderResolver} to use for replacement\n\t * @return the supplied value with placeholders replaced inline\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "placeholderResolver"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "String",
    "signature": "public String replacePlaceholders(String value, PlaceholderResolver placeholderResolver)",
    "source_code": "\tpublic String replacePlaceholders(String value, PlaceholderResolver placeholderResolver) {\n\t\tAssert.notNull(value, \"'value' must not be null\");\n\t\tParsedValue parsedValue = parse(value);\n\t\tPartResolutionContext resolutionContext = new PartResolutionContext(placeholderResolver,\n\t\t\t\tthis.prefix, this.suffix, this.ignoreUnresolvablePlaceholders,\n\t\t\t\tcandidate -> parse(candidate, false));\n\t\treturn parsedValue.resolve(resolutionContext);\n\t}"
  },
  "org.springframework.util.<unknown>#resolve(resolutionContext)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolutionContext"
    ],
    "position": {
      "column": 1,
      "line": 495
    },
    "return": "String",
    "signature": "public String resolve(PartResolutionContext resolutionContext)",
    "source_code": "\t\tpublic String resolve(PartResolutionContext resolutionContext) {\n\t\t\tString resolvedKey = Part.resolveAll(this.keyParts, resolutionContext);\n\t\t\tString value = resolutionContext.resolvePlaceholder(resolvedKey);\n\t\t\tif (value != null) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\telse if (this.defaultParts != null) {\n\t\t\t\treturn Part.resolveAll(this.defaultParts, resolutionContext);\n\t\t\t}\n\t\t\treturn resolutionContext.handleUnresolvablePlaceholder(resolvedKey, this.text);\n\t\t}"
  },
  "org.springframework.util.<unknown>#resolvePlaceholder(placeholderName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "placeholderName"
    ],
    "position": {
      "column": 1,
      "line": 326
    },
    "return": "String",
    "signature": "public String resolvePlaceholder(String placeholderName)",
    "source_code": "\t\tpublic String resolvePlaceholder(String placeholderName) {\n\t\t\tString value = this.resolver.resolvePlaceholder(placeholderName);\n\t\t\tif (value != null && logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Resolved placeholder '\" + placeholderName + \"'\");\n\t\t\t}\n\t\t\treturn value;\n\t\t}"
  },
  "org.springframework.util.CollectionUtils#compositeMap(Map<K,first,Map<K,second)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a (partially unmodifiable) map that combines the provided two\n\t * maps. Invoking {@link Map#put(Object, Object)} or {@link Map#putAll(Map)}\n\t * on the returned map results in an {@link UnsupportedOperationException}.\n\t *\n\t * <p>In the case of a key collision, {@code first} takes precedence over\n\t * {@code second}. In other words, entries in {@code second} with a key\n\t * that is also mapped by {@code first} are effectively ignored.\n\t * @param first the first map to compose\n\t * @param second the second map to compose\n\t * @return a new map that composes the given two maps\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<K",
      "first",
      "Map<K",
      "second"
    ],
    "position": {
      "column": 1,
      "line": 527
    },
    "return": "V>",
    "signature": "public V> compositeMap(Map<K,V> first, Map<K,V> second)",
    "source_code": "\tpublic static <K, V> Map<K, V> compositeMap(Map<K,V> first, Map<K,V> second) {\n\t\treturn new CompositeMap<>(first, second);\n\t}"
  },
  "org.springframework.util.CollectionUtils#compositeMap(Map<K,first,Map<K,second,BiFunction<K,V,putFunction,Consumer<Map<K,putAllFunction)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a map that combines the provided maps. Invoking\n\t * {@link Map#put(Object, Object)} on the returned map will apply\n\t * {@code putFunction}, or will throw an\n\t * {@link UnsupportedOperationException} {@code putFunction} is\n\t * {@code null}. The same applies to {@link Map#putAll(Map)} and\n\t * {@code putAllFunction}.\n\t *\n\t * <p>In the case of a key collision, {@code first} takes precedence over\n\t * {@code second}. In other words, entries in {@code second} with a key\n\t * that is also mapped by {@code first} are effectively ignored.\n\t * @param first the first map to compose\n\t * @param second the second map to compose\n\t * @param putFunction applied when {@code Map::put} is invoked. If\n\t * {@code null}, {@code Map::put} throws an\n\t * {@code UnsupportedOperationException}.\n\t * @param putAllFunction applied when {@code Map::putAll} is invoked. If\n\t * {@code null}, {@code Map::putAll} throws an\n\t * {@code UnsupportedOperationException}.\n\t * @return a new map that composes the give maps\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<K",
      "first",
      "Map<K",
      "second",
      "BiFunction<K",
      "V",
      "putFunction",
      "Consumer<Map<K",
      "putAllFunction"
    ],
    "position": {
      "column": 1,
      "line": 553
    },
    "return": "V>",
    "signature": "public V> compositeMap(Map<K,V> first, Map<K,V> second,\n\t\t\t@Nullable BiFunction<K, V, V> putFunction,\n\t\t\t@Nullable Consumer<Map<K, V>> putAllFunction)",
    "source_code": "\tpublic static <K, V> Map<K, V> compositeMap(Map<K,V> first, Map<K,V> second,"
  },
  "org.springframework.util.CollectionUtils#newHashSet(expectedSize)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Instantiate a new {@link HashSet} with an initial capacity that can\n\t * accommodate the specified number of elements without any immediate\n\t * resize/rehash operations to be expected.\n\t * @param expectedSize the expected number of elements (with a corresponding\n\t * capacity to be derived so that no resize/rehash operations are needed)\n\t * @since 6.2\n\t * @see #newLinkedHashSet(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedSize"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "HashSet<E>",
    "signature": "public HashSet<E> newHashSet(int expectedSize)",
    "source_code": "\tpublic static <E> HashSet<E> newHashSet(int expectedSize) {\n\t\treturn new HashSet<>(computeInitialCapacity(expectedSize), DEFAULT_LOAD_FACTOR);\n\t}"
  },
  "org.springframework.util.CollectionUtils#newLinkedHashSet(expectedSize)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Instantiate a new {@link LinkedHashSet} with an initial capacity that can\n\t * accommodate the specified number of elements without any immediate\n\t * resize/rehash operations to be expected.\n\t * @param expectedSize the expected number of elements (with a corresponding\n\t * capacity to be derived so that no resize/rehash operations are needed)\n\t * @since 6.2\n\t * @see #newHashSet(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedSize"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "LinkedHashSet<E>",
    "signature": "public LinkedHashSet<E> newLinkedHashSet(int expectedSize)",
    "source_code": "\tpublic static <E> LinkedHashSet<E> newLinkedHashSet(int expectedSize) {\n\t\treturn new LinkedHashSet<>(computeInitialCapacity(expectedSize), DEFAULT_LOAD_FACTOR);\n\t}"
  },
  "org.springframework.util.xml.<unknown>#endPrefixMapping(prefix)": {
    "change": "modifier_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "prefix"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "void",
    "signature": "public void endPrefixMapping(String prefix)",
    "source_code": "\tpublic void endPrefixMapping(String prefix) {\n\t}"
  },
  "org.springframework.validation.FieldError": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Encapsulates a field error, that is, a reason for rejecting a specific\n * field value.\n *\n * <p>See the {@link DefaultMessageCodesResolver} javadoc for details on\n * how a message code list is built for a {@code FieldError}.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 10.03.2003\n * @see DefaultMessageCodesResolver\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 36
    },
    "signature": "public class FieldError",
    "source_code": "public class FieldError extends ObjectError {\n\n\tprivate final String field;\n\n\t@Nullable\n\tprivate final Object rejectedValue;\n\n\tprivate final boolean bindingFailure;\n\n\n\t/**\n\t * Create a new FieldError instance.\n\t * @param objectName the name of the affected object\n\t * @param field the affected field of the object\n\t * @param defaultMessage the default message to be used to resolve this message\n\t */\n\tpublic FieldError(String objectName, String field, String defaultMessage) {\n\t\tthis(objectName, field, null, false, null, null, defaultMessage);\n\t}\n\n\t/**\n\t * Create a new FieldError instance.\n\t * @param objectName the name of the affected object\n\t * @param field the affected field of the object\n\t * @param rejectedValue the rejected field value\n\t * @param bindingFailure whether this error represents a binding failure\n\t * (like a type mismatch); else, it is a validation failure\n\t * @param codes the codes to be used to resolve this message\n\t * @param arguments the array of arguments to be used to resolve this message\n\t * @param defaultMessage the default message to be used to resolve this message\n\t */\n\tpublic FieldError(String objectName, String field, @Nullable Object rejectedValue, boolean bindingFailure,\n\t\t\t@Nullable String[] codes, @Nullable Object[] arguments, @Nullable String defaultMessage) {\n\n\t\tsuper(objectName, codes, arguments, defaultMessage);\n\t\tAssert.notNull(field, \"Field must not be null\");\n\t\tthis.field = field;\n\t\tthis.rejectedValue = rejectedValue;\n\t\tthis.bindingFailure = bindingFailure;\n\t}\n\n\n\t/**\n\t * Return the affected field of the object.\n\t */\n\tpublic String getField() {\n\t\treturn this.field;\n\t}\n\n\t/**\n\t * Return the rejected field value.\n\t */\n\t@Nullable\n\tpublic Object getRejectedValue() {\n\t\treturn this.rejectedValue;\n\t}\n\n\t/**\n\t * Return whether this error represents a binding failure\n\t * (like a type mismatch); otherwise it is a validation failure.\n\t */\n\tpublic boolean isBindingFailure() {\n\t\treturn this.bindingFailure;\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!super.equals(other)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (other instanceof FieldError otherError && getField().equals(otherError.getField()) &&\n\t\t\t\tObjectUtils.nullSafeEquals(getRejectedValue(), otherError.getRejectedValue()) &&\n\t\t\t\tisBindingFailure() == otherError.isBindingFailure());\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tint hashCode = super.hashCode();\n\t\thashCode = 29 * hashCode + getField().hashCode();\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getRejectedValue());\n\t\thashCode = 29 * hashCode + (isBindingFailure() ? 1 : 0);\n\t\treturn hashCode;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\t// We would preferably use ObjectUtils.nullSafeConciseToString(rejectedValue) here but\n\t\t// keep including the full nullSafeToString representation for backwards compatibility.\n\t\treturn \"Field error in object '\" + getObjectName() + \"' on field '\" + this.field +\n\t\t\t\t\"': rejected value [\" + ObjectUtils.nullSafeToString(this.rejectedValue) + \"]; \" +\n\t\t\t\tresolvableToString();\n\t}\n\n}"
  },
  "org.springframework.validation.FieldError#equals(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!super.equals(other)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (other instanceof FieldError otherError && getField().equals(otherError.getField()) &&\n\t\t\t\tObjectUtils.nullSafeEquals(getRejectedValue(), otherError.getRejectedValue()) &&\n\t\t\t\tisBindingFailure() == otherError.isBindingFailure());\n\t}"
  },
  "org.springframework.validation.FieldError#getField()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the affected field of the object.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "String",
    "signature": "public String getField()",
    "source_code": "\tpublic String getField() {\n\t\treturn this.field;\n\t}"
  },
  "org.springframework.validation.FieldError#getRejectedValue()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the rejected field value.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "Object",
    "signature": "public Object getRejectedValue()",
    "source_code": "\tpublic Object getRejectedValue() {\n\t\treturn this.rejectedValue;\n\t}"
  },
  "org.springframework.validation.FieldError#hashCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\tint hashCode = super.hashCode();\n\t\thashCode = 29 * hashCode + getField().hashCode();\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getRejectedValue());\n\t\thashCode = 29 * hashCode + (isBindingFailure() ? 1 : 0);\n\t\treturn hashCode;\n\t}"
  },
  "org.springframework.validation.FieldError#isBindingFailure()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether this error represents a binding failure\n\t * (like a type mismatch); otherwise it is a validation failure.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "boolean",
    "signature": "public boolean isBindingFailure()",
    "source_code": "\tpublic boolean isBindingFailure() {\n\t\treturn this.bindingFailure;\n\t}"
  },
  "org.springframework.validation.FieldError#toString()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\t// We would preferably use ObjectUtils.nullSafeConciseToString(rejectedValue) here but\n\t\t// keep including the full nullSafeToString representation for backwards compatibility.\n\t\treturn \"Field error in object '\" + getObjectName() + \"' on field '\" + this.field +\n\t\t\t\t\"': rejected value [\" + ObjectUtils.nullSafeToString(this.rejectedValue) + \"]; \" +\n\t\t\t\tresolvableToString();\n\t}"
  },
  "org.springframework.validation.method.ParameterValidationResult": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Store and expose the results of method validation for a method parameter.\n * <ul>\n * <li>Validation errors directly on method parameter values are exposed as a\n * list of {@link MessageSourceResolvable}s.\n * <li>Nested validation errors on an Object method parameter are exposed as\n * {@link org.springframework.validation.Errors} by the subclass\n * {@link ParameterErrors}.\n * </ul>\n *\n * <p>When the method parameter is a container such as a {@link List}, array,\n * or {@link java.util.Map}, then a separate {@link ParameterValidationResult}\n * is created for each element with errors. In that case, the properties\n * {@link #getContainer() container}, {@link #getContainerIndex() containerIndex},\n * and {@link #getContainerKey() containerKey} provide additional context.\n *\n * @author Rossen Stoyanchev\n * @since 6.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "signature": "public class ParameterValidationResult",
    "source_code": "public class ParameterValidationResult {\n\n\tprivate final MethodParameter methodParameter;\n\n\t@Nullable\n\tprivate final Object argument;\n\n\tprivate final List<MessageSourceResolvable> resolvableErrors;\n\n\t@Nullable\n\tprivate final Object container;\n\n\t@Nullable\n\tprivate final Integer containerIndex;\n\n\t@Nullable\n\tprivate final Object containerKey;\n\n\n\t/**\n\t * Create a {@code ParameterValidationResult}.\n\t */\n\tpublic ParameterValidationResult(\n\t\t\tMethodParameter param, @Nullable Object arg, Collection<? extends MessageSourceResolvable> errors,\n\t\t\t@Nullable Object container, @Nullable Integer index, @Nullable Object key) {\n\n\t\tAssert.notNull(param, \"MethodParameter is required\");\n\t\tAssert.notEmpty(errors, \"`resolvableErrors` must not be empty\");\n\t\tthis.methodParameter = param;\n\t\tthis.argument = arg;\n\t\tthis.resolvableErrors = List.copyOf(errors);\n\t\tthis.container = container;\n\t\tthis.containerIndex = index;\n\t\tthis.containerKey = key;\n\t}\n\n\t/**\n\t * Create a {@code ParameterValidationResult}.\n\t * @deprecated in favor of\n\t * {@link ParameterValidationResult#ParameterValidationResult(MethodParameter, Object, Collection, Object, Integer, Object)}\n\t */\n\t@Deprecated(since = \"6.1.3\", forRemoval = true)\n\tpublic ParameterValidationResult(\n\t\t\tMethodParameter param, @Nullable Object arg, Collection<? extends MessageSourceResolvable> errors) {\n\n\t\tthis(param, arg, errors, null, null, null);\n\t}\n\n\n\t/**\n\t * The method parameter the validation results are for.\n\t */\n\tpublic MethodParameter getMethodParameter() {\n\t\treturn this.methodParameter;\n\t}\n\n\t/**\n\t * The method argument value that was validated.\n\t */\n\t@Nullable\n\tpublic Object getArgument() {\n\t\treturn this.argument;\n\t}\n\n\t/**\n\t * List of {@link MessageSourceResolvable} representations adapted from the\n\t * validation errors of the validation library.\n\t * <ul>\n\t * <li>For a constraints directly on a method parameter, error codes are\n\t * based on the names of the constraint annotation, the object, the method,\n\t * the parameter, and parameter type, e.g.\n\t * {@code [\"Max.myObject#myMethod.myParameter\", \"Max.myParameter\", \"Max.int\", \"Max\"]}.\n\t * Arguments include the parameter itself as a {@link MessageSourceResolvable}, e.g.\n\t * {@code [\"myObject#myMethod.myParameter\", \"myParameter\"]}, followed by actual\n\t * constraint annotation attributes (i.e. excluding \"message\", \"groups\" and\n\t * \"payload\") in alphabetical order of attribute names.\n\t * <li>For cascaded constraints via {@link jakarta.validation.Validator @Valid}\n\t * on a bean method parameter, this method returns\n\t * {@link org.springframework.validation.FieldError field errors} that you\n\t * can also access more conveniently through methods of the\n\t * {@link ParameterErrors} sub-class.\n\t * </ul>\n\t */\n\tpublic List<MessageSourceResolvable> getResolvableErrors() {\n\t\treturn this.resolvableErrors;\n\t}\n\n\t/**\n\t * When {@code @Valid} is declared on a container of elements such as\n\t * {@link java.util.Collection}, {@link java.util.Map},\n\t * {@link java.util.Optional}, and others, this method returns the container\n\t * of the validated {@link #getArgument() argument}, while\n\t * {@link #getContainerIndex()} and {@link #getContainerKey()} provide\n\t * information about the index or key if applicable.\n\t */\n\t@Nullable\n\tpublic Object getContainer() {\n\t\treturn this.container;\n\t}\n\n\t/**\n\t * When {@code @Valid} is declared on an indexed container of elements such as\n\t * {@link List} or array, this method returns the index of the validated\n\t * {@link #getArgument() argument}.\n\t */\n\t@Nullable\n\tpublic Integer getContainerIndex() {\n\t\treturn this.containerIndex;\n\t}\n\n\t/**\n\t * When {@code @Valid} is declared on a container of elements referenced by\n\t * key such as {@link java.util.Map}, this method returns the key of the\n\t * validated {@link #getArgument() argument}.\n\t */\n\t@Nullable\n\tpublic Object getContainerKey() {\n\t\treturn this.containerKey;\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!super.equals(other)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (other instanceof ParameterValidationResult otherResult &&\n\t\t\t\tgetMethodParameter().equals(otherResult.getMethodParameter()) &&\n\t\t\t\tObjectUtils.nullSafeEquals(getArgument(), otherResult.getArgument()) &&\n\t\t\t\tObjectUtils.nullSafeEquals(getContainerIndex(), otherResult.getContainerIndex()) &&\n\t\t\t\tObjectUtils.nullSafeEquals(getContainerKey(), otherResult.getContainerKey()));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tint hashCode = super.hashCode();\n\t\thashCode = 29 * hashCode + getMethodParameter().hashCode();\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getArgument());\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getContainerIndex());\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getContainerKey());\n\t\treturn hashCode;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \" for \" + this.methodParameter +\n\t\t\t\t\", argument value '\" + ObjectUtils.nullSafeConciseToString(this.argument) + \"',\" +\n\t\t\t\t(this.containerIndex != null ? \"containerIndex[\" + this.containerIndex + \"],\" : \"\") +\n\t\t\t\t(this.containerKey != null ? \"containerKey['\" + this.containerKey + \"'],\" : \"\") +\n\t\t\t\t\" errors: \" + getResolvableErrors();\n\t}\n\n}"
  },
  "org.springframework.validation.method.ParameterValidationResult#equals(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!super.equals(other)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (other instanceof ParameterValidationResult otherResult &&\n\t\t\t\tgetMethodParameter().equals(otherResult.getMethodParameter()) &&\n\t\t\t\tObjectUtils.nullSafeEquals(getArgument(), otherResult.getArgument()) &&\n\t\t\t\tObjectUtils.nullSafeEquals(getContainerIndex(), otherResult.getContainerIndex()) &&\n\t\t\t\tObjectUtils.nullSafeEquals(getContainerKey(), otherResult.getContainerKey()));\n\t}"
  },
  "org.springframework.validation.method.ParameterValidationResult#getArgument()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * The method argument value that was validated.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "Object",
    "signature": "public Object getArgument()",
    "source_code": "\tpublic Object getArgument() {\n\t\treturn this.argument;\n\t}"
  },
  "org.springframework.validation.method.ParameterValidationResult#getContainer()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * When {@code @Valid} is declared on a container of elements such as\n\t * {@link java.util.Collection}, {@link java.util.Map},\n\t * {@link java.util.Optional}, and others, this method returns the container\n\t * of the validated {@link #getArgument() argument}, while\n\t * {@link #getContainerIndex()} and {@link #getContainerKey()} provide\n\t * information about the index or key if applicable.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "Object",
    "signature": "public Object getContainer()",
    "source_code": "\tpublic Object getContainer() {\n\t\treturn this.container;\n\t}"
  },
  "org.springframework.validation.method.ParameterValidationResult#getContainerIndex()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * When {@code @Valid} is declared on an indexed container of elements such as\n\t * {@link List} or array, this method returns the index of the validated\n\t * {@link #getArgument() argument}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "Integer",
    "signature": "public Integer getContainerIndex()",
    "source_code": "\tpublic Integer getContainerIndex() {\n\t\treturn this.containerIndex;\n\t}"
  },
  "org.springframework.validation.method.ParameterValidationResult#getContainerKey()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * When {@code @Valid} is declared on a container of elements referenced by\n\t * key such as {@link java.util.Map}, this method returns the key of the\n\t * validated {@link #getArgument() argument}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "Object",
    "signature": "public Object getContainerKey()",
    "source_code": "\tpublic Object getContainerKey() {\n\t\treturn this.containerKey;\n\t}"
  },
  "org.springframework.validation.method.ParameterValidationResult#getMethodParameter()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * The method parameter the validation results are for.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter getMethodParameter()",
    "source_code": "\tpublic MethodParameter getMethodParameter() {\n\t\treturn this.methodParameter;\n\t}"
  },
  "org.springframework.validation.method.ParameterValidationResult#getResolvableErrors()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * List of {@link MessageSourceResolvable} representations adapted from the\n\t * validation errors of the validation library.\n\t * <ul>\n\t * <li>For a constraints directly on a method parameter, error codes are\n\t * based on the names of the constraint annotation, the object, the method,\n\t * the parameter, and parameter type, e.g.\n\t * {@code [\"Max.myObject#myMethod.myParameter\", \"Max.myParameter\", \"Max.int\", \"Max\"]}.\n\t * Arguments include the parameter itself as a {@link MessageSourceResolvable}, e.g.\n\t * {@code [\"myObject#myMethod.myParameter\", \"myParameter\"]}, followed by actual\n\t * constraint annotation attributes (i.e. excluding \"message\", \"groups\" and\n\t * \"payload\") in alphabetical order of attribute names.\n\t * <li>For cascaded constraints via {@link jakarta.validation.Validator @Valid}\n\t * on a bean method parameter, this method returns\n\t * {@link org.springframework.validation.FieldError field errors} that you\n\t * can also access more conveniently through methods of the\n\t * {@link ParameterErrors} sub-class.\n\t * </ul>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "List<MessageSourceResolvable>",
    "signature": "public List<MessageSourceResolvable> getResolvableErrors()",
    "source_code": "\tpublic List<MessageSourceResolvable> getResolvableErrors() {\n\t\treturn this.resolvableErrors;\n\t}"
  },
  "org.springframework.validation.method.ParameterValidationResult#hashCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\tint hashCode = super.hashCode();\n\t\thashCode = 29 * hashCode + getMethodParameter().hashCode();\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getArgument());\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getContainerIndex());\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getContainerKey());\n\t\treturn hashCode;\n\t}"
  },
  "org.springframework.validation.method.ParameterValidationResult#toString()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \" for \" + this.methodParameter +\n\t\t\t\t\", argument value '\" + ObjectUtils.nullSafeConciseToString(this.argument) + \"',\" +\n\t\t\t\t(this.containerIndex != null ? \"containerIndex[\" + this.containerIndex + \"],\" : \"\") +\n\t\t\t\t(this.containerKey != null ? \"containerKey['\" + this.containerKey + \"'],\" : \"\") +\n\t\t\t\t\" errors: \" + getResolvableErrors();\n\t}"
  },
  "org.springframework.web.client.<unknown>#attribute(name,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 399
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec attribute(String name, Object value)",
    "source_code": "\t\tpublic RequestBodySpec attribute(String name, Object value) {\n\t\t\tgetAttributes().put(name, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#attributes(Consumer<Map<String,attributesConsumer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Consumer<Map<String",
      "attributesConsumer"
    ],
    "position": {
      "column": 1,
      "line": 405
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec attributes(Consumer<Map<String, Object>> attributesConsumer)",
    "source_code": "\t\tpublic RequestBodySpec attributes(Consumer<Map<String, Object>> attributesConsumer) {\n\t\t\tattributesConsumer.accept(getAttributes());\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.context.request.KEY": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Key under which this accessor is registered in\n\t * {@link io.micrometer.context.ContextRegistry}.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "signature": "public String KEY",
    "source_code": "\tpublic static final String KEY = RequestAttributesThreadLocalAccessor.class.getName() + \".KEY\";",
    "type": "String"
  },
  "org.springframework.web.context.request.RequestAttributesThreadLocalAccessor": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Adapt {@link RequestContextHolder} to the {@link ThreadLocalAccessor} contract\n * to assist the Micrometer Context Propagation library with\n * {@link RequestAttributes} propagation.\n *\n * @author Tadaya Tsuyukubo\n * @author Rossen Stoyanchev\n * @since 6.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "signature": "public class RequestAttributesThreadLocalAccessor",
    "source_code": "public class RequestAttributesThreadLocalAccessor implements ThreadLocalAccessor<RequestAttributes> {\n\n\t/**\n\t * Key under which this accessor is registered in\n\t * {@link io.micrometer.context.ContextRegistry}.\n\t */\n\tpublic static final String KEY = RequestAttributesThreadLocalAccessor.class.getName() + \".KEY\";\n\n\t@Override\n\tpublic Object key() {\n\t\treturn KEY;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic RequestAttributes getValue() {\n\t\tRequestAttributes request = RequestContextHolder.getRequestAttributes();\n\t\tif (request instanceof ServletRequestAttributes sra && !(sra instanceof SnapshotServletRequestAttributes)) {\n\t\t\trequest = new SnapshotServletRequestAttributes(sra);\n\t\t}\n\t\treturn request;\n\t}\n\n\t@Override\n\tpublic void setValue(RequestAttributes value) {\n\t\tRequestContextHolder.setRequestAttributes(value);\n\t}\n\n\t@Override\n\tpublic void setValue() {\n\t\tRequestContextHolder.resetRequestAttributes();\n\t}\n\n\n\t/**\n\t * ServletRequestAttributes that takes another instance, and makes a copy of the\n\t * request attributes at present to provides extended read access during async\n\t * handling when the DispatcherServlet has exited from the initial REQUEST dispatch\n\t * and marked the request {@link ServletRequestAttributes#requestCompleted()}.\n\t * <p>Note that beyond access to request attributes, here is no attempt to support\n\t * setting or removing request attributes, nor to access session attributes after\n\t * the initial REQUEST dispatch has exited.\n\t */\n\tprivate static final class SnapshotServletRequestAttributes extends ServletRequestAttributes {\n\n\t\tprivate final ServletRequestAttributes delegate;\n\n\t\tprivate final Map<String, Object> attributeMap;\n\n\t\tpublic SnapshotServletRequestAttributes(ServletRequestAttributes requestAttributes) {\n\t\t\tsuper(requestAttributes.getRequest(), requestAttributes.getResponse());\n\t\t\tthis.delegate = requestAttributes;\n\t\t\tthis.attributeMap = getAttributes(requestAttributes.getRequest());\n\t\t}\n\n\t\tprivate static Map<String, Object> getAttributes(HttpServletRequest request) {\n\t\t\tMap<String, Object> map = new HashMap<>();\n\t\t\tEnumeration<String> names = request.getAttributeNames();\n\t\t\twhile (names.hasMoreElements()) {\n\t\t\t\tString name = names.nextElement();\n\t\t\t\tmap.put(name, request.getAttribute(name));\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\t// Delegate methods that check isRequestActive()\n\n\t\t@Nullable\n\t\t@Override\n\t\tpublic Object getAttribute(String name, int scope) {\n\t\t\tif (scope == RequestAttributes.SCOPE_REQUEST && !this.delegate.isRequestActive()) {\n\t\t\t\treturn this.attributeMap.get(name);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn this.delegate.getAttribute(name, scope);\n\t\t\t}\n\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\tif (scope == RequestAttributes.SCOPE_REQUEST) {\n\t\t\t\t\treturn this.attributeMap.get(name);\n\t\t\t\t}\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String[] getAttributeNames(int scope) {\n\t\t\tif (scope == RequestAttributes.SCOPE_REQUEST && !this.delegate.isRequestActive()) {\n\t\t\t\treturn this.attributeMap.keySet().toArray(new String[0]);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn this.delegate.getAttributeNames(scope);\n\t\t\t}\n\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\tif (scope == RequestAttributes.SCOPE_REQUEST) {\n\t\t\t\t\treturn this.attributeMap.keySet().toArray(new String[0]);\n\t\t\t\t}\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void setAttribute(String name, Object value, int scope) {\n\t\t\tthis.delegate.setAttribute(name, value, scope);\n\t\t}\n\n\t\t@Override\n\t\tpublic void removeAttribute(String name, int scope) {\n\t\t\tthis.delegate.removeAttribute(name, scope);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.context.request.RequestAttributesThreadLocalAccessor#getAttribute(name,scope)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "Object",
    "signature": "public Object getAttribute(String name, int scope)",
    "source_code": "\t\tpublic Object getAttribute(String name, int scope) {\n\t\t\tif (scope == RequestAttributes.SCOPE_REQUEST && !this.delegate.isRequestActive()) {\n\t\t\t\treturn this.attributeMap.get(name);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn this.delegate.getAttribute(name, scope);\n\t\t\t}\n\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\tif (scope == RequestAttributes.SCOPE_REQUEST) {\n\t\t\t\t\treturn this.attributeMap.get(name);\n\t\t\t\t}\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.context.request.RequestAttributesThreadLocalAccessor#getAttributeNames(scope)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "String[]",
    "signature": "public String[] getAttributeNames(int scope)",
    "source_code": "\t\tpublic String[] getAttributeNames(int scope) {\n\t\t\tif (scope == RequestAttributes.SCOPE_REQUEST && !this.delegate.isRequestActive()) {\n\t\t\t\treturn this.attributeMap.keySet().toArray(new String[0]);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn this.delegate.getAttributeNames(scope);\n\t\t\t}\n\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\tif (scope == RequestAttributes.SCOPE_REQUEST) {\n\t\t\t\t\treturn this.attributeMap.keySet().toArray(new String[0]);\n\t\t\t\t}\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.context.request.RequestAttributesThreadLocalAccessor#getValue()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "RequestAttributes",
    "signature": "public RequestAttributes getValue()",
    "source_code": "\tpublic RequestAttributes getValue() {\n\t\tRequestAttributes request = RequestContextHolder.getRequestAttributes();\n\t\tif (request instanceof ServletRequestAttributes sra && !(sra instanceof SnapshotServletRequestAttributes)) {\n\t\t\trequest = new SnapshotServletRequestAttributes(sra);\n\t\t}\n\t\treturn request;\n\t}"
  },
  "org.springframework.web.context.request.RequestAttributesThreadLocalAccessor#key()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 46
    },
    "return": "Object",
    "signature": "public Object key()",
    "source_code": "\tpublic Object key() {\n\t\treturn KEY;\n\t}"
  },
  "org.springframework.web.context.request.RequestAttributesThreadLocalAccessor#removeAttribute(name,scope)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "void",
    "signature": "public void removeAttribute(String name, int scope)",
    "source_code": "\t\tpublic void removeAttribute(String name, int scope) {\n\t\t\tthis.delegate.removeAttribute(name, scope);\n\t\t}"
  },
  "org.springframework.web.context.request.RequestAttributesThreadLocalAccessor#setAttribute(name,value,scope)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value",
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "void",
    "signature": "public void setAttribute(String name, Object value, int scope)",
    "source_code": "\t\tpublic void setAttribute(String name, Object value, int scope) {\n\t\t\tthis.delegate.setAttribute(name, value, scope);\n\t\t}"
  },
  "org.springframework.web.context.request.RequestAttributesThreadLocalAccessor#setValue()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "void",
    "signature": "public void setValue()",
    "source_code": "\tpublic void setValue() {\n\t\tRequestContextHolder.resetRequestAttributes();\n\t}"
  },
  "org.springframework.web.context.request.RequestAttributesThreadLocalAccessor#setValue(value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "void",
    "signature": "public void setValue(RequestAttributes value)",
    "source_code": "\tpublic void setValue(RequestAttributes value) {\n\t\tRequestContextHolder.setRequestAttributes(value);\n\t}"
  },
  "org.springframework.web.method.annotation.ExceptionHandlerMethodResolver": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Discovers {@linkplain ExceptionHandler @ExceptionHandler} methods in a given class,\n * including all of its superclasses, and helps to resolve a given {@link Exception}\n * and {@link MediaType} requested by clients to combinations supported by a given {@link Method}.\n * <p>This resolver will use the exception information declared as {@code @ExceptionHandler}\n * annotation attributes, or as a method argument as a fallback. This will throw\n * {@code IllegalStateException} instances if:\n * <ul>\n *     <li>No Exception information could be found for a method\n *     <li>An invalid {@link MediaType} has been declared as {@code @ExceptionHandler} attribute\n *     <li>Multiple handlers declare the same exception + media type mapping\n * </ul>\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Brian Clozel\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "signature": "public class ExceptionHandlerMethodResolver",
    "source_code": "public class ExceptionHandlerMethodResolver {\n\n\t/**\n\t * A filter for selecting {@code @ExceptionHandler} methods.\n\t */\n\tprivate static final MethodFilter EXCEPTION_HANDLER_METHODS = method ->\n\t\t\tAnnotatedElementUtils.hasAnnotation(method, ExceptionHandler.class);\n\n\tprivate static final ExceptionHandlerMappingInfo NO_MATCHING_EXCEPTION_HANDLER;\n\n\tstatic {\n\t\ttry {\n\t\t\tNO_MATCHING_EXCEPTION_HANDLER = new ExceptionHandlerMappingInfo(Set.of(), Set.of(),\n\t\t\t\t\tExceptionHandlerMethodResolver.class.getDeclaredMethod(\"noMatchingExceptionHandler\"));\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\tthrow new IllegalStateException(\"Expected method not found: \" + ex);\n\t\t}\n\t}\n\n\tprivate final Map<ExceptionMapping, ExceptionHandlerMappingInfo> mappedMethods = new HashMap<>(16);\n\n\tprivate final ConcurrentLruCache<ExceptionMapping, ExceptionHandlerMappingInfo> lookupCache = new ConcurrentLruCache<>(24,\n\t\t\tcacheKey -> getMappedMethod(cacheKey.exceptionType(), cacheKey.mediaType()));\n\n\n\t/**\n\t * A constructor that finds {@link ExceptionHandler} methods in the given type.\n\t * @param handlerType the type to introspect\n\t * @throws IllegalStateException in case of invalid or ambiguous exception mapping declarations\n\t */\n\tpublic ExceptionHandlerMethodResolver(Class<?> handlerType) {\n\t\tfor (Method method : MethodIntrospector.selectMethods(handlerType, EXCEPTION_HANDLER_METHODS)) {\n\t\t\tExceptionHandlerMappingInfo mappingInfo = detectExceptionMappings(method);\n\t\t\tfor (Class<? extends Throwable> exceptionType : mappingInfo.getExceptionTypes()) {\n\t\t\t\tfor (MediaType producibleType : mappingInfo.getProducibleTypes()) {\n\t\t\t\t\taddExceptionMapping(new ExceptionMapping(exceptionType, producibleType), mappingInfo);\n\t\t\t\t}\n\t\t\t\tif (mappingInfo.getProducibleTypes().isEmpty()) {\n\t\t\t\t\taddExceptionMapping(new ExceptionMapping(exceptionType, MediaType.ALL), mappingInfo);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Extract exception mappings from the {@code @ExceptionHandler} annotation first,\n\t * and then as a fallback from the method signature itself.\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprivate ExceptionHandlerMappingInfo detectExceptionMappings(Method method) {\n\t\tExceptionHandler exceptionHandler = readExceptionHandlerAnnotation(method);\n\t\tList<Class<? extends Throwable>> exceptions = new ArrayList<>(Arrays.asList(exceptionHandler.exception()));\n\t\tif (exceptions.isEmpty()) {\n\t\t\tfor (Class<?> paramType : method.getParameterTypes()) {\n\t\t\t\tif (Throwable.class.isAssignableFrom(paramType)) {\n\t\t\t\t\texceptions.add((Class<? extends Throwable>) paramType);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (exceptions.isEmpty()) {\n\t\t\tthrow new IllegalStateException(\"No exception types mapped to \" + method);\n\t\t}\n\t\tSet<MediaType> mediaTypes = new HashSet<>();\n\t\tfor (String mediaType : exceptionHandler.produces()) {\n\t\t\ttry {\n\t\t\t\tmediaTypes.add(MediaType.parseMediaType(mediaType));\n\t\t\t}\n\t\t\tcatch (InvalidMediaTypeException exc) {\n\t\t\t\tthrow new IllegalStateException(\"Invalid media type [\" + mediaType + \"] declared on @ExceptionHandler for \" + method, exc);\n\t\t\t}\n\t\t}\n\t\treturn new ExceptionHandlerMappingInfo(Set.copyOf(exceptions), mediaTypes, method);\n\t}\n\n\tprivate ExceptionHandler readExceptionHandlerAnnotation(Method method) {\n\t\tExceptionHandler ann = AnnotatedElementUtils.findMergedAnnotation(method, ExceptionHandler.class);\n\t\tAssert.state(ann != null, \"No ExceptionHandler annotation\");\n\t\treturn ann;\n\t}\n\n\tprivate void addExceptionMapping(ExceptionMapping mapping, ExceptionHandlerMappingInfo mappingInfo) {\n\t\tExceptionHandlerMappingInfo oldMapping = this.mappedMethods.put(mapping, mappingInfo);\n\t\tif (oldMapping != null && !oldMapping.getHandlerMethod().equals(mappingInfo.getHandlerMethod())) {\n\t\t\tthrow new IllegalStateException(\"Ambiguous @ExceptionHandler method mapped for [\" +\n\t\t\t\t\tmapping + \"]: {\" + oldMapping.getHandlerMethod() + \", \" + mappingInfo.getHandlerMethod() + \"}\");\n\t\t}\n\t}\n\n\t/**\n\t * Whether the contained type has any exception mappings.\n\t */\n\tpublic boolean hasExceptionMappings() {\n\t\treturn !this.mappedMethods.isEmpty();\n\t}\n\n\t/**\n\t * Find a {@link Method} to handle the given exception.\n\t * <p>Uses {@link ExceptionDepthComparator} if more than one match is found.\n\t * @param exception the exception\n\t * @return a Method to handle the exception, or {@code null} if none found\n\t */\n\t@Nullable\n\tpublic Method resolveMethod(Exception exception) {\n\t\tExceptionHandlerMappingInfo mappingInfo = resolveExceptionMapping(exception, MediaType.ALL);\n\t\treturn (mappingInfo != null) ? mappingInfo.getHandlerMethod() : null;\n\t}\n\n\t/**\n\t * Find a {@link Method} to handle the given Throwable.\n\t * <p>Uses {@link ExceptionDepthComparator} if more than one match is found.\n\t * @param exception the exception\n\t * @return a Method to handle the exception, or {@code null} if none found\n\t * @since 5.0\n\t */\n\t@Nullable\n\tpublic Method resolveMethodByThrowable(Throwable exception) {\n\t\tExceptionHandlerMappingInfo mappingInfo = resolveExceptionMapping(exception, MediaType.ALL);\n\t\treturn (mappingInfo != null) ? mappingInfo.getHandlerMethod() : null;\n\t}\n\n\t/**\n\t * Find a {@link Method} to handle the given Throwable for the requested {@link MediaType}.\n\t * <p>Uses {@link ExceptionDepthComparator} and {@link MediaType#isMoreSpecific(MimeType)}\n\t * if more than one match is found.\n\t * @param exception the exception\n\t * @param mediaType the media type requested by the HTTP client\n\t * @return a Method to handle the exception, or {@code null} if none found\n\t * @since 6.2\n\t */\n\t@Nullable\n\tpublic ExceptionHandlerMappingInfo resolveExceptionMapping(Throwable exception, MediaType mediaType) {\n\t\tExceptionHandlerMappingInfo mappingInfo = resolveExceptionMappingByExceptionType(exception.getClass(), mediaType);\n\t\tif (mappingInfo == null) {\n\t\t\tThrowable cause = exception.getCause();\n\t\t\tif (cause != null) {\n\t\t\t\tmappingInfo = resolveExceptionMapping(cause, mediaType);\n\t\t\t}\n\t\t}\n\t\treturn mappingInfo;\n\t}\n\n\t/**\n\t * Find a {@link Method} to handle the given exception type. This can be\n\t * useful if an {@link Exception} instance is not available (e.g. for tools).\n\t * <p>Uses {@link ExceptionDepthComparator} if more than one match is found.\n\t * @param exceptionType the exception type\n\t * @return a Method to handle the exception, or {@code null} if none found\n\t */\n\t@Nullable\n\tpublic Method resolveMethodByExceptionType(Class<? extends Throwable> exceptionType) {\n\t\tExceptionHandlerMappingInfo mappingInfo = resolveExceptionMappingByExceptionType(exceptionType, MediaType.ALL);\n\t\treturn (mappingInfo != null) ? mappingInfo.getHandlerMethod() : null;\n\t}\n\n\t/**\n\t * Find a {@link Method} to handle the given exception type and media type.\n\t * This can be useful if an {@link Exception} instance is not available (e.g. for tools).\n\t * @param exceptionType the exception type\n\t * @param mediaType the media type requested by the HTTP client\n\t * @return a Method to handle the exception, or {@code null} if none found\n\t */\n\t@Nullable\n\tpublic ExceptionHandlerMappingInfo resolveExceptionMappingByExceptionType(Class<? extends Throwable> exceptionType, MediaType mediaType) {\n\t\tExceptionHandlerMappingInfo mappingInfo = this.lookupCache.get(new ExceptionMapping(exceptionType, mediaType));\n\t\treturn (mappingInfo != NO_MATCHING_EXCEPTION_HANDLER ? mappingInfo : null);\n\t}\n\n\t/**\n\t * Return the {@link Method} mapped to the given exception type, or\n\t * {@link #NO_MATCHING_EXCEPTION_HANDLER} if none.\n\t */\n\t@Nullable\n\tprivate ExceptionHandlerMappingInfo getMappedMethod(Class<? extends Throwable> exceptionType, MediaType mediaType) {\n\t\tList<ExceptionMapping> matches = new ArrayList<>();\n\t\tfor (ExceptionMapping mappingInfo : this.mappedMethods.keySet()) {\n\t\t\tif (mappingInfo.exceptionType().isAssignableFrom(exceptionType) && mappingInfo.mediaType().isCompatibleWith(mediaType)) {\n\t\t\t\tmatches.add(mappingInfo);\n\t\t\t}\n\t\t}\n\t\tif (!matches.isEmpty()) {\n\t\t\tif (matches.size() > 1) {\n\t\t\t\tmatches.sort(new ExceptionMapingComparator(exceptionType, mediaType));\n\t\t\t}\n\t\t\treturn this.mappedMethods.get(matches.get(0));\n\t\t}\n\t\telse {\n\t\t\treturn NO_MATCHING_EXCEPTION_HANDLER;\n\t\t}\n\t}\n\n\t/**\n\t * For the {@link #NO_MATCHING_EXCEPTION_HANDLER} constant.\n \t */\n\t@SuppressWarnings(\"unused\")\n\tprivate void noMatchingExceptionHandler() {\n\t}\n\n\tprivate record ExceptionMapping(Class<? extends Throwable> exceptionType, MediaType mediaType) {\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"ExceptionHandler{\" +\n\t\t\t\t\t\"exceptionType=\" + this.exceptionType.getCanonicalName() +\n\t\t\t\t\t\", mediaType=\" + this.mediaType +\n\t\t\t\t\t'}';\n\t\t}\n\t}\n\n\tprivate static class ExceptionMapingComparator implements Comparator<ExceptionMapping> {\n\n\t\tprivate final ExceptionDepthComparator exceptionDepthComparator;\n\n\t\tprivate final MediaType mediaType;\n\n\t\tpublic ExceptionMapingComparator(Class<? extends Throwable> exceptionType, MediaType mediaType) {\n\t\t\tthis.exceptionDepthComparator = new ExceptionDepthComparator(exceptionType);\n\t\t\tthis.mediaType = mediaType;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compare(ExceptionMapping o1, ExceptionMapping o2) {\n\t\t\tint result = this.exceptionDepthComparator.compare(o1.exceptionType(), o2.exceptionType());\n\t\t\tif (result != 0) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tif(o1.mediaType.equals(this.mediaType)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(o2.mediaType.equals(this.mediaType)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (o1.mediaType.equals(o2.mediaType)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn (o1.mediaType.isMoreSpecific(o2.mediaType)) ? -1 : 1;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.method.annotation.ExceptionHandlerMethodResolver#compare(o1,o2)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o1",
      "o2"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "int",
    "signature": "public int compare(ExceptionMapping o1, ExceptionMapping o2)",
    "source_code": "\t\tpublic int compare(ExceptionMapping o1, ExceptionMapping o2) {\n\t\t\tint result = this.exceptionDepthComparator.compare(o1.exceptionType(), o2.exceptionType());\n\t\t\tif (result != 0) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tif(o1.mediaType.equals(this.mediaType)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(o2.mediaType.equals(this.mediaType)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (o1.mediaType.equals(o2.mediaType)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn (o1.mediaType.isMoreSpecific(o2.mediaType)) ? -1 : 1;\n\t\t}"
  },
  "org.springframework.web.method.annotation.ExceptionHandlerMethodResolver#hasExceptionMappings()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the contained type has any exception mappings.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "boolean",
    "signature": "public boolean hasExceptionMappings()",
    "source_code": "\tpublic boolean hasExceptionMappings() {\n\t\treturn !this.mappedMethods.isEmpty();\n\t}"
  },
  "org.springframework.web.method.annotation.ExceptionHandlerMethodResolver#resolveExceptionMapping(exception,mediaType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a {@link Method} to handle the given Throwable for the requested {@link MediaType}.\n\t * <p>Uses {@link ExceptionDepthComparator} and {@link MediaType#isMoreSpecific(MimeType)}\n\t * if more than one match is found.\n\t * @param exception the exception\n\t * @param mediaType the media type requested by the HTTP client\n\t * @return a Method to handle the exception, or {@code null} if none found\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exception",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "ExceptionHandlerMappingInfo",
    "signature": "public ExceptionHandlerMappingInfo resolveExceptionMapping(Throwable exception, MediaType mediaType)",
    "source_code": "\tpublic ExceptionHandlerMappingInfo resolveExceptionMapping(Throwable exception, MediaType mediaType) {\n\t\tExceptionHandlerMappingInfo mappingInfo = resolveExceptionMappingByExceptionType(exception.getClass(), mediaType);\n\t\tif (mappingInfo == null) {\n\t\t\tThrowable cause = exception.getCause();\n\t\t\tif (cause != null) {\n\t\t\t\tmappingInfo = resolveExceptionMapping(cause, mediaType);\n\t\t\t}\n\t\t}\n\t\treturn mappingInfo;\n\t}"
  },
  "org.springframework.web.method.annotation.ExceptionHandlerMethodResolver#resolveExceptionMappingByExceptionType(exceptionType,mediaType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a {@link Method} to handle the given exception type and media type.\n\t * This can be useful if an {@link Exception} instance is not available (e.g. for tools).\n\t * @param exceptionType the exception type\n\t * @param mediaType the media type requested by the HTTP client\n\t * @return a Method to handle the exception, or {@code null} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exceptionType",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "ExceptionHandlerMappingInfo",
    "signature": "public ExceptionHandlerMappingInfo resolveExceptionMappingByExceptionType(Class<? extends Throwable> exceptionType, MediaType mediaType)",
    "source_code": "\tpublic ExceptionHandlerMappingInfo resolveExceptionMappingByExceptionType(Class<? extends Throwable> exceptionType, MediaType mediaType) {\n\t\tExceptionHandlerMappingInfo mappingInfo = this.lookupCache.get(new ExceptionMapping(exceptionType, mediaType));\n\t\treturn (mappingInfo != NO_MATCHING_EXCEPTION_HANDLER ? mappingInfo : null);\n\t}"
  },
  "org.springframework.web.method.annotation.ExceptionHandlerMethodResolver#resolveMethod(exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a {@link Method} to handle the given exception.\n\t * <p>Uses {@link ExceptionDepthComparator} if more than one match is found.\n\t * @param exception the exception\n\t * @return a Method to handle the exception, or {@code null} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "Method",
    "signature": "public Method resolveMethod(Exception exception)",
    "source_code": "\tpublic Method resolveMethod(Exception exception) {\n\t\tExceptionHandlerMappingInfo mappingInfo = resolveExceptionMapping(exception, MediaType.ALL);\n\t\treturn (mappingInfo != null) ? mappingInfo.getHandlerMethod() : null;\n\t}"
  },
  "org.springframework.web.method.annotation.ExceptionHandlerMethodResolver#resolveMethodByExceptionType(exceptionType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a {@link Method} to handle the given exception type. This can be\n\t * useful if an {@link Exception} instance is not available (e.g. for tools).\n\t * <p>Uses {@link ExceptionDepthComparator} if more than one match is found.\n\t * @param exceptionType the exception type\n\t * @return a Method to handle the exception, or {@code null} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exceptionType"
    ],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "Method",
    "signature": "public Method resolveMethodByExceptionType(Class<? extends Throwable> exceptionType)",
    "source_code": "\tpublic Method resolveMethodByExceptionType(Class<? extends Throwable> exceptionType) {\n\t\tExceptionHandlerMappingInfo mappingInfo = resolveExceptionMappingByExceptionType(exceptionType, MediaType.ALL);\n\t\treturn (mappingInfo != null) ? mappingInfo.getHandlerMethod() : null;\n\t}"
  },
  "org.springframework.web.method.annotation.ExceptionHandlerMethodResolver#resolveMethodByThrowable(exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a {@link Method} to handle the given Throwable.\n\t * <p>Uses {@link ExceptionDepthComparator} if more than one match is found.\n\t * @param exception the exception\n\t * @return a Method to handle the exception, or {@code null} if none found\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "Method",
    "signature": "public Method resolveMethodByThrowable(Throwable exception)",
    "source_code": "\tpublic Method resolveMethodByThrowable(Throwable exception) {\n\t\tExceptionHandlerMappingInfo mappingInfo = resolveExceptionMapping(exception, MediaType.ALL);\n\t\treturn (mappingInfo != null) ? mappingInfo.getHandlerMethod() : null;\n\t}"
  },
  "org.springframework.web.method.annotation.ExceptionHandlerMethodResolver#toString()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn \"ExceptionHandler{\" +\n\t\t\t\t\t\"exceptionType=\" + this.exceptionType.getCanonicalName() +\n\t\t\t\t\t\", mediaType=\" + this.mediaType +\n\t\t\t\t\t'}';\n\t\t}"
  },
  "org.springframework.web.reactive.function.BodyInserters#fromValue(body,bodyType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter to write the given value.\n\t * <p>Alternatively, consider using the {@code bodyValue(Object, ParameterizedTypeReference)} shortcuts on\n\t * {@link org.springframework.web.reactive.function.client.WebClient WebClient} and\n\t * {@link org.springframework.web.reactive.function.server.ServerResponse ServerResponse}.\n\t * @param body the value to write\n\t * @param bodyType the type of the body, used to capture the generic type\n\t * @param <T> the type of the body\n\t * @return the inserter to write a single value\n\t * @throws IllegalArgumentException if {@code body} is a {@link Publisher} or an\n\t * instance of a type supported by {@link ReactiveAdapterRegistry#getSharedInstance()},\n\t * for which {@link #fromPublisher(Publisher, ParameterizedTypeReference)} or\n\t * {@link #fromProducer(Object, ParameterizedTypeReference)} should be used.\n\t * @since 6.2\n\t * @see #fromPublisher(Publisher, ParameterizedTypeReference)\n\t * @see #fromProducer(Object, ParameterizedTypeReference)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> fromValue(T body, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic static <T> BodyInserter<T, ReactiveHttpOutputMessage> fromValue(T body, ParameterizedTypeReference<T> bodyType) {\n\t\tAssert.notNull(body, \"'body' must not be null\");\n\t\tAssert.notNull(bodyType, \"'bodyType' must not be null\");\n\t\tAssert.isNull(registry.getAdapter(body.getClass()),\n\t\t\t\t\"'body' should be an object, for reactive types use a variant specifying a publisher/producer and its related element type\");\n\t\treturn (message, context) ->\n\t\t\t\twriteWithMessageWriters(message, context, Mono.just(body), ResolvableType.forType(bodyType), null);\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#getAttributes()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "Object>",
    "signature": "public Object> getAttributes()",
    "source_code": "\t\tpublic Map<String, Object> getAttributes() {\n\t\t\treturn Collections.emptyMap();\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#bodyValue(body,bodyType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> bodyValue(T body, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic <T> Mono<ServerResponse> bodyValue(T body, ParameterizedTypeReference<T> bodyType) {\n\t\treturn initBuilder(body, BodyInserters.fromValue(body, bodyType));\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#build()": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> build()",
    "source_code": "\tpublic Mono<ServerResponse> build() {\n\t\treturn build((exchange, handlerStrategies) -> exchange.getResponse().setComplete());\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter#getContentTypeResolver()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured {@link RequestedContentTypeResolver}.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "RequestedContentTypeResolver",
    "signature": "public RequestedContentTypeResolver getContentTypeResolver()",
    "source_code": "\tpublic RequestedContentTypeResolver getContentTypeResolver() {\n\t\treturn this.contentTypeResolver;\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter#setContentTypeResolver(contentTypeResolver)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link RequestedContentTypeResolver} to use to determine requested\n\t * media types. If not set, the default constructor is used.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentTypeResolver"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "void",
    "signature": "public void setContentTypeResolver(RequestedContentTypeResolver contentTypeResolver)",
    "source_code": "\tpublic void setContentTypeResolver(RequestedContentTypeResolver contentTypeResolver) {\n\t\tAssert.notNull(contentTypeResolver, \"'contentTypeResolver' must not be null\");\n\t\tthis.contentTypeResolver = contentTypeResolver;\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Default implementation of {@link ServerWebExchange}.\n *\n * @author Rossen Stoyanchev\n * @author Brian Clozel\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "signature": "public class DefaultServerWebExchange",
    "source_code": "public class DefaultServerWebExchange implements ServerWebExchange {\n\n\tprivate static final Set<HttpMethod> SAFE_METHODS = Set.of(HttpMethod.GET, HttpMethod.HEAD);\n\n\tprivate static final ResolvableType FORM_DATA_TYPE =\n\t\t\tResolvableType.forClassWithGenerics(MultiValueMap.class, String.class, String.class);\n\n\tprivate static final ResolvableType MULTIPART_DATA_TYPE = ResolvableType.forClassWithGenerics(\n\t\t\tMultiValueMap.class, String.class, Part.class);\n\n\tprivate static final Mono<MultiValueMap<String, String>> EMPTY_FORM_DATA =\n\t\t\tMono.just(CollectionUtils.unmodifiableMultiValueMap(new LinkedMultiValueMap<String, String>(0)))\n\t\t\t\t\t.cache();\n\n\tprivate static final Mono<MultiValueMap<String, Part>> EMPTY_MULTIPART_DATA =\n\t\t\tMono.just(CollectionUtils.unmodifiableMultiValueMap(new LinkedMultiValueMap<String, Part>(0)))\n\t\t\t\t\t.cache();\n\n\n\tprivate final ServerHttpRequest request;\n\n\tprivate final ServerHttpResponse response;\n\n\tprivate final Map<String, Object> attributes = new ConcurrentHashMap<>();\n\n\tprivate final Mono<WebSession> sessionMono;\n\n\tprivate final LocaleContextResolver localeContextResolver;\n\n\tprivate final Mono<MultiValueMap<String, String>> formDataMono;\n\n\tprivate final Mono<MultiValueMap<String, Part>> multipartDataMono;\n\n\tprivate volatile boolean multipartRead = false;\n\n\t@Nullable\n\tprivate final ApplicationContext applicationContext;\n\n\tprivate volatile boolean notModified;\n\n\tprivate Function<String, String> urlTransformer = url -> url;\n\n\t@Nullable\n\tprivate Object logId;\n\n\tprivate String logPrefix = \"\";\n\n\n\tpublic DefaultServerWebExchange(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSessionManager sessionManager, ServerCodecConfigurer codecConfigurer,\n\t\t\tLocaleContextResolver localeContextResolver) {\n\n\t\tthis(request, response, sessionManager, codecConfigurer, localeContextResolver, null);\n\t}\n\n\tDefaultServerWebExchange(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSessionManager sessionManager, ServerCodecConfigurer codecConfigurer,\n\t\t\tLocaleContextResolver localeContextResolver, @Nullable ApplicationContext applicationContext) {\n\n\t\tAssert.notNull(request, \"'request' is required\");\n\t\tAssert.notNull(response, \"'response' is required\");\n\t\tAssert.notNull(sessionManager, \"'sessionManager' is required\");\n\t\tAssert.notNull(codecConfigurer, \"'codecConfigurer' is required\");\n\t\tAssert.notNull(localeContextResolver, \"'localeContextResolver' is required\");\n\n\t\t// Initialize before first call to getLogPrefix()\n\t\tthis.attributes.put(ServerWebExchange.LOG_ID_ATTRIBUTE, request.getId());\n\n\t\tthis.request = request;\n\t\tthis.response = response;\n\t\tthis.sessionMono = sessionManager.getSession(this).cache();\n\t\tthis.localeContextResolver = localeContextResolver;\n\t\tthis.formDataMono = initFormData(request, codecConfigurer, getLogPrefix());\n\t\tthis.multipartDataMono = initMultipartData(codecConfigurer, getLogPrefix());\n\t\tthis.applicationContext = applicationContext;\n\n\t\tif (request instanceof AbstractServerHttpRequest abstractServerHttpRequest) {\n\t\t\tabstractServerHttpRequest.setAttributesSupplier(() -> this.attributes);\n\t\t}\n\t}\n\n\tprivate static Mono<MultiValueMap<String, String>> initFormData(ServerHttpRequest request,\n\t\t\tServerCodecConfigurer configurer, String logPrefix) {\n\n\t\tMediaType contentType = getContentType(request);\n\t\tif (contentType == null || !contentType.isCompatibleWith(MediaType.APPLICATION_FORM_URLENCODED)) {\n\t\t\treturn EMPTY_FORM_DATA;\n\t\t}\n\n\t\tHttpMessageReader<MultiValueMap<String, String>> reader = getReader(configurer, contentType, FORM_DATA_TYPE);\n\t\tif (reader == null) {\n\t\t\treturn Mono.error(new IllegalStateException(\"No HttpMessageReader for \" + contentType));\n\t\t}\n\n\t\treturn reader\n\t\t\t\t.readMono(FORM_DATA_TYPE, request, Hints.from(Hints.LOG_PREFIX_HINT, logPrefix))\n\t\t\t\t.switchIfEmpty(EMPTY_FORM_DATA)\n\t\t\t\t.cache();\n\t}\n\n\tprivate Mono<MultiValueMap<String, Part>> initMultipartData(ServerCodecConfigurer configurer, String logPrefix) {\n\n\t\tMediaType contentType = getContentType(this.request);\n\t\tif (contentType == null || !contentType.getType().equalsIgnoreCase(\"multipart\")) {\n\t\t\treturn EMPTY_MULTIPART_DATA;\n\t\t}\n\n\t\tHttpMessageReader<MultiValueMap<String, Part>> reader = getReader(configurer, contentType, MULTIPART_DATA_TYPE);\n\t\tif (reader == null) {\n\t\t\treturn Mono.error(new IllegalStateException(\"No HttpMessageReader for \" + contentType));\n\t\t}\n\n\t\treturn reader\n\t\t\t\t.readMono(MULTIPART_DATA_TYPE, this.request, Hints.from(Hints.LOG_PREFIX_HINT, logPrefix))\n\t\t\t\t.doOnNext(ignored -> this.multipartRead = true)\n\t\t\t\t.switchIfEmpty(EMPTY_MULTIPART_DATA)\n\t\t\t\t.cache();\n\t}\n\n\t@Nullable\n\tprivate static MediaType getContentType(ServerHttpRequest request) {\n\t\tMediaType contentType = null;\n\t\ttry {\n\t\t\tcontentType = request.getHeaders().getContentType();\n\t\t}\n\t\tcatch (InvalidMediaTypeException ex) {\n\t\t\t// ignore\n\t\t}\n\t\treturn contentType;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Nullable\n\tprivate static <E> HttpMessageReader<E> getReader(\n\t\t\tServerCodecConfigurer configurer, MediaType contentType, ResolvableType targetType) {\n\n\t\tHttpMessageReader<E> result = null;\n\t\tfor (HttpMessageReader<?> reader : configurer.getReaders()) {\n\t\t\tif (reader.canRead(targetType, contentType)) {\n\t\t\t\tresult = (HttpMessageReader<E>) reader;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\n\t@Override\n\tpublic ServerHttpRequest getRequest() {\n\t\treturn this.request;\n\t}\n\n\tprivate HttpHeaders getRequestHeaders() {\n\t\treturn getRequest().getHeaders();\n\t}\n\n\t@Override\n\tpublic ServerHttpResponse getResponse() {\n\t\treturn this.response;\n\t}\n\n\tprivate HttpHeaders getResponseHeaders() {\n\t\treturn getResponse().getHeaders();\n\t}\n\n\t@Override\n\tpublic Map<String, Object> getAttributes() {\n\t\treturn this.attributes;\n\t}\n\n\t@Override\n\tpublic Mono<WebSession> getSession() {\n\t\treturn this.sessionMono;\n\t}\n\n\t@Override\n\tpublic <T extends Principal> Mono<T> getPrincipal() {\n\t\treturn Mono.empty();\n\t}\n\n\t@Override\n\tpublic Mono<MultiValueMap<String, String>> getFormData() {\n\t\treturn this.formDataMono;\n\t}\n\n\t@Override\n\tpublic Mono<MultiValueMap<String, Part>> getMultipartData() {\n\t\treturn this.multipartDataMono;\n\t}\n\n\t@Override\n\tpublic Mono<Void> cleanupMultipart() {\n\t\treturn Mono.defer(() -> {\n\t\t\tif (this.multipartRead) {\n\t\t\t\treturn Mono.usingWhen(getMultipartData().onErrorComplete().map(this::collectParts),\n\t\t\t\t\t\tparts -> Mono.empty(),\n\t\t\t\t\t\tparts -> Flux.fromIterable(parts).flatMap(part -> part.delete().onErrorComplete())\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn Mono.empty();\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate List<Part> collectParts(MultiValueMap<String, Part> multipartData) {\n\t\treturn multipartData.values().stream().flatMap(List::stream).collect(Collectors.toList());\n\t}\n\n\t@Override\n\tpublic LocaleContext getLocaleContext() {\n\t\treturn this.localeContextResolver.resolveLocaleContext(this);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic ApplicationContext getApplicationContext() {\n\t\treturn this.applicationContext;\n\t}\n\n\t@Override\n\tpublic boolean isNotModified() {\n\t\treturn this.notModified;\n\t}\n\n\t@Override\n\tpublic boolean checkNotModified(Instant lastModified) {\n\t\treturn checkNotModified(null, lastModified);\n\t}\n\n\t@Override\n\tpublic boolean checkNotModified(String etag) {\n\t\treturn checkNotModified(etag, Instant.MIN);\n\t}\n\n\t@Override\n\tpublic boolean checkNotModified(@Nullable String eTag, Instant lastModified) {\n\t\tHttpStatusCode status = getResponse().getStatusCode();\n\t\tif (this.notModified || (status != null && !HttpStatus.OK.equals(status))) {\n\t\t\treturn this.notModified;\n\t\t}\n\t\t// Evaluate conditions in order of precedence.\n\t\t// See https://datatracker.ietf.org/doc/html/rfc9110#section-13.2.2\n\t\t// 1) If-Match\n\t\tif (validateIfMatch(eTag)) {\n\t\t\tupdateResponseStateChanging(eTag, lastModified);\n\t\t\treturn this.notModified;\n\t\t}\n\t\t// 2) If-Unmodified-Since\n\t\telse if (validateIfUnmodifiedSince(lastModified)) {\n\t\t\tupdateResponseStateChanging(eTag, lastModified);\n\t\t\treturn this.notModified;\n\t\t}\n\t\t// 3) If-None-Match\n\t\tif (!validateIfNoneMatch(eTag)) {\n\t\t\t// 4) If-Modified-Since\n\t\t\tvalidateIfModifiedSince(lastModified);\n\t\t}\n\t\tupdateResponseIdempotent(eTag, lastModified);\n\t\treturn this.notModified;\n\t}\n\n\tprivate boolean validateIfMatch(@Nullable String eTag) {\n\t\ttry {\n\t\t\tif (SAFE_METHODS.contains(getRequest().getMethod())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (CollectionUtils.isEmpty(getRequestHeaders().get(HttpHeaders.IF_MATCH))) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis.notModified = matchRequestedETags(getRequestHeaders().getIfMatch(), eTag, false);\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate boolean matchRequestedETags(List<String> requestedETags, @Nullable String eTag, boolean weakCompare) {\n\t\teTag = padEtagIfNecessary(eTag);\n\t\tfor (String clientEtag : requestedETags) {\n\t\t\t// only consider \"lost updates\" checks for unsafe HTTP methods\n\t\t\tif (\"*\".equals(clientEtag) && StringUtils.hasLength(eTag)\n\t\t\t\t\t&& !SAFE_METHODS.contains(getRequest().getMethod())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// Compare weak/strong ETags as per https://datatracker.ietf.org/doc/html/rfc9110#section-8.8.3\n\t\t\tif (weakCompare) {\n\t\t\t\tif (eTagWeakMatch(eTag, clientEtag)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (eTagStrongMatch(eTag, clientEtag)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Nullable\n\tprivate String padEtagIfNecessary(@Nullable String etag) {\n\t\tif (!StringUtils.hasLength(etag)) {\n\t\t\treturn etag;\n\t\t}\n\t\tif ((etag.startsWith(\"\\\"\") || etag.startsWith(\"W/\\\"\")) && etag.endsWith(\"\\\"\")) {\n\t\t\treturn etag;\n\t\t}\n\t\treturn \"\\\"\" + etag + \"\\\"\";\n\t}\n\n\tprivate boolean eTagStrongMatch(@Nullable String first, @Nullable String second) {\n\t\tif (!StringUtils.hasLength(first) || first.startsWith(\"W/\")) {\n\t\t\treturn false;\n\t\t}\n\t\treturn first.equals(second);\n\t}\n\n\tprivate boolean eTagWeakMatch(@Nullable String first, @Nullable String second) {\n\t\tif (!StringUtils.hasLength(first) || !StringUtils.hasLength(second)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (first.startsWith(\"W/\")) {\n\t\t\tfirst = first.substring(2);\n\t\t}\n\t\tif (second.startsWith(\"W/\")) {\n\t\t\tsecond = second.substring(2);\n\t\t}\n\t\treturn first.equals(second);\n\t}\n\n\tprivate void updateResponseStateChanging(@Nullable String eTag, Instant lastModified) {\n\t\tif (this.notModified) {\n\t\t\tgetResponse().setStatusCode(HttpStatus.PRECONDITION_FAILED);\n\t\t}\n\t\telse {\n\t\t\taddCachingResponseHeaders(eTag, lastModified);\n\t\t}\n\t}\n\n\tprivate boolean validateIfNoneMatch(@Nullable String eTag) {\n\t\ttry {\n\t\t\tif (CollectionUtils.isEmpty(getRequestHeaders().get(HttpHeaders.IF_NONE_MATCH))) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis.notModified = !matchRequestedETags(getRequestHeaders().getIfNoneMatch(), eTag, true);\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate void updateResponseIdempotent(@Nullable String eTag, Instant lastModified) {\n\t\tboolean isSafeMethod = SAFE_METHODS.contains(getRequest().getMethod());\n\t\tif (this.notModified) {\n\t\t\tgetResponse().setStatusCode(isSafeMethod ?\n\t\t\t\t\tHttpStatus.NOT_MODIFIED : HttpStatus.PRECONDITION_FAILED);\n\t\t}\n\t\taddCachingResponseHeaders(eTag, lastModified);\n\t}\n\n\tprivate void addCachingResponseHeaders(@Nullable String eTag, Instant lastModified) {\n\t\tif (SAFE_METHODS.contains(getRequest().getMethod())) {\n\t\t\tif (lastModified.isAfter(Instant.EPOCH) && getResponseHeaders().getLastModified() == -1) {\n\t\t\t\tgetResponseHeaders().setLastModified(lastModified.toEpochMilli());\n\t\t\t}\n\t\t\tif (StringUtils.hasLength(eTag) && getResponseHeaders().getETag() == null) {\n\t\t\t\tgetResponseHeaders().setETag(padEtagIfNecessary(eTag));\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean validateIfUnmodifiedSince(Instant lastModified) {\n\t\tif (lastModified.isBefore(Instant.EPOCH)) {\n\t\t\treturn false;\n\t\t}\n\t\tlong ifUnmodifiedSince = getRequestHeaders().getIfUnmodifiedSince();\n\t\tif (ifUnmodifiedSince == -1) {\n\t\t\treturn false;\n\t\t}\n\t\tInstant sinceInstant = Instant.ofEpochMilli(ifUnmodifiedSince);\n\t\tthis.notModified = sinceInstant.isBefore(lastModified.truncatedTo(ChronoUnit.SECONDS));\n\t\treturn true;\n\t}\n\n\tprivate void validateIfModifiedSince(Instant lastModified) {\n\t\tif (lastModified.isBefore(Instant.EPOCH)) {\n\t\t\treturn;\n\t\t}\n\t\tlong ifModifiedSince = getRequestHeaders().getIfModifiedSince();\n\t\tif (ifModifiedSince != -1) {\n\t\t\t// We will perform this validation...\n\t\t\tthis.notModified = ChronoUnit.SECONDS.between(lastModified, Instant.ofEpochMilli(ifModifiedSince)) >= 0;\n\t\t}\n\t}\n\n\t@Override\n\tpublic String transformUrl(String url) {\n\t\treturn this.urlTransformer.apply(url);\n\t}\n\n\t@Override\n\tpublic void addUrlTransformer(Function<String, String> transformer) {\n\t\tAssert.notNull(transformer, \"'encoder' must not be null\");\n\t\tthis.urlTransformer = this.urlTransformer.andThen(transformer);\n\t}\n\n\t@Override\n\tpublic String getLogPrefix() {\n\t\tObject value = getAttribute(LOG_ID_ATTRIBUTE);\n\t\tif (this.logId != value) {\n\t\t\tthis.logId = value;\n\t\t\tthis.logPrefix = value != null ? \"[\" + value + \"] \" : \"\";\n\t\t}\n\t\treturn this.logPrefix;\n\t}\n\n}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#addUrlTransformer(Function<String,transformer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<String",
      "transformer"
    ],
    "position": {
      "column": 1,
      "line": 469
    },
    "return": "void",
    "signature": "public void addUrlTransformer(Function<String, String> transformer)",
    "source_code": "\tpublic void addUrlTransformer(Function<String, String> transformer) {\n\t\tAssert.notNull(transformer, \"'encoder' must not be null\");\n\t\tthis.urlTransformer = this.urlTransformer.andThen(transformer);\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#checkNotModified(eTag,lastModified)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "eTag",
      "lastModified"
    ],
    "position": {
      "column": 1,
      "line": 301
    },
    "return": "boolean",
    "signature": "public boolean checkNotModified(@Nullable String eTag, Instant lastModified)",
    "source_code": "\tpublic boolean checkNotModified(@Nullable String eTag, Instant lastModified) {\n\t\tHttpStatusCode status = getResponse().getStatusCode();\n\t\tif (this.notModified || (status != null && !HttpStatus.OK.equals(status))) {\n\t\t\treturn this.notModified;\n\t\t}\n\t\t// Evaluate conditions in order of precedence.\n\t\t// See https://datatracker.ietf.org/doc/html/rfc9110#section-13.2.2\n\t\t// 1) If-Match\n\t\tif (validateIfMatch(eTag)) {\n\t\t\tupdateResponseStateChanging(eTag, lastModified);\n\t\t\treturn this.notModified;\n\t\t}\n\t\t// 2) If-Unmodified-Since\n\t\telse if (validateIfUnmodifiedSince(lastModified)) {\n\t\t\tupdateResponseStateChanging(eTag, lastModified);\n\t\t\treturn this.notModified;\n\t\t}\n\t\t// 3) If-None-Match\n\t\tif (!validateIfNoneMatch(eTag)) {\n\t\t\t// 4) If-Modified-Since\n\t\t\tvalidateIfModifiedSince(lastModified);\n\t\t}\n\t\tupdateResponseIdempotent(eTag, lastModified);\n\t\treturn this.notModified;\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#checkNotModified(etag)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "etag"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "boolean",
    "signature": "public boolean checkNotModified(String etag)",
    "source_code": "\tpublic boolean checkNotModified(String etag) {\n\t\treturn checkNotModified(etag, Instant.MIN);\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#checkNotModified(lastModified)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lastModified"
    ],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "boolean",
    "signature": "public boolean checkNotModified(Instant lastModified)",
    "source_code": "\tpublic boolean checkNotModified(Instant lastModified) {\n\t\treturn checkNotModified(null, lastModified);\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#cleanupMultipart()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> cleanupMultipart()",
    "source_code": "\tpublic Mono<Void> cleanupMultipart() {\n\t\treturn Mono.defer(() -> {\n\t\t\tif (this.multipartRead) {\n\t\t\t\treturn Mono.usingWhen(getMultipartData().onErrorComplete().map(this::collectParts),\n\t\t\t\t\t\tparts -> Mono.empty(),\n\t\t\t\t\t\tparts -> Flux.fromIterable(parts).flatMap(part -> part.delete().onErrorComplete())\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn Mono.empty();\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#getApplicationContext()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "ApplicationContext",
    "signature": "public ApplicationContext getApplicationContext()",
    "source_code": "\tpublic ApplicationContext getApplicationContext() {\n\t\treturn this.applicationContext;\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#getAttributes()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 231
    },
    "return": "Object>",
    "signature": "public Object> getAttributes()",
    "source_code": "\tpublic Map<String, Object> getAttributes() {\n\t\treturn this.attributes;\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#getFormData()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "String>>",
    "signature": "public String>> getFormData()",
    "source_code": "\tpublic Mono<MultiValueMap<String, String>> getFormData() {\n\t\treturn this.formDataMono;\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#getLocaleContext()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 275
    },
    "return": "LocaleContext",
    "signature": "public LocaleContext getLocaleContext()",
    "source_code": "\tpublic LocaleContext getLocaleContext() {\n\t\treturn this.localeContextResolver.resolveLocaleContext(this);\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#getLogPrefix()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 475
    },
    "return": "String",
    "signature": "public String getLogPrefix()",
    "source_code": "\tpublic String getLogPrefix() {\n\t\tObject value = getAttribute(LOG_ID_ATTRIBUTE);\n\t\tif (this.logId != value) {\n\t\t\tthis.logId = value;\n\t\t\tthis.logPrefix = value != null ? \"[\" + value + \"] \" : \"\";\n\t\t}\n\t\treturn this.logPrefix;\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#getMultipartData()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "Part>>",
    "signature": "public Part>> getMultipartData()",
    "source_code": "\tpublic Mono<MultiValueMap<String, Part>> getMultipartData() {\n\t\treturn this.multipartDataMono;\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#getPrincipal()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> getPrincipal()",
    "source_code": "\tpublic <T extends Principal> Mono<T> getPrincipal() {\n\t\treturn Mono.empty();\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#getRequest()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "ServerHttpRequest",
    "signature": "public ServerHttpRequest getRequest()",
    "source_code": "\tpublic ServerHttpRequest getRequest() {\n\t\treturn this.request;\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#getResponse()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "ServerHttpResponse",
    "signature": "public ServerHttpResponse getResponse()",
    "source_code": "\tpublic ServerHttpResponse getResponse() {\n\t\treturn this.response;\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#getSession()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "Mono<WebSession>",
    "signature": "public Mono<WebSession> getSession()",
    "source_code": "\tpublic Mono<WebSession> getSession() {\n\t\treturn this.sessionMono;\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#isNotModified()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "boolean",
    "signature": "public boolean isNotModified()",
    "source_code": "\tpublic boolean isNotModified() {\n\t\treturn this.notModified;\n\t}"
  },
  "org.springframework.web.server.adapter.DefaultServerWebExchange#transformUrl(url)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url"
    ],
    "position": {
      "column": 1,
      "line": 464
    },
    "return": "String",
    "signature": "public String transformUrl(String url)",
    "source_code": "\tpublic String transformUrl(String url) {\n\t\treturn this.urlTransformer.apply(url);\n\t}"
  },
  "org.springframework.web.server.adapter.FORWARDED_HEADER_TRANSFORMER_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Well-known name for the ForwardedHeaderTransformer in the bean factory. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "signature": "public String FORWARDED_HEADER_TRANSFORMER_BEAN_NAME",
    "source_code": "\tpublic static final String FORWARDED_HEADER_TRANSFORMER_BEAN_NAME = \"forwardedHeaderTransformer\";",
    "type": "String"
  },
  "org.springframework.web.server.adapter.LOCALE_CONTEXT_RESOLVER_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Well-known name for the LocaleContextResolver in the bean factory. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "signature": "public String LOCALE_CONTEXT_RESOLVER_BEAN_NAME",
    "source_code": "\tpublic static final String LOCALE_CONTEXT_RESOLVER_BEAN_NAME = \"localeContextResolver\";",
    "type": "String"
  },
  "org.springframework.web.server.adapter.SERVER_CODEC_CONFIGURER_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Well-known name for the ServerCodecConfigurer in the bean factory. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "signature": "public String SERVER_CODEC_CONFIGURER_BEAN_NAME",
    "source_code": "\tpublic static final String SERVER_CODEC_CONFIGURER_BEAN_NAME = \"serverCodecConfigurer\";",
    "type": "String"
  },
  "org.springframework.web.server.adapter.SpringWebBlockHoundIntegration": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@code BlockHoundIntegration} for spring-web classes.\n\t * @since 5.3.6\n\t */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 475
    },
    "signature": "public class SpringWebBlockHoundIntegration",
    "source_code": "\tpublic static class SpringWebBlockHoundIntegration implements BlockHoundIntegration {\n\n\t\t@Override\n\t\tpublic void applyTo(BlockHound.Builder builder) {\n\n\t\t\t// Avoid hard references potentially anywhere in spring-web (no need for structural dependency)\n\n\t\t\tbuilder.allowBlockingCallsInside(\"org.springframework.http.MediaTypeFactory\", \"<clinit>\");\n\t\t\tbuilder.allowBlockingCallsInside(\"org.springframework.web.util.HtmlUtils\", \"<clinit>\");\n\t\t}\n\t}"
  },
  "org.springframework.web.server.adapter.WEB_HANDLER_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Well-known name for the target WebHandler in the bean factory. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "signature": "public String WEB_HANDLER_BEAN_NAME",
    "source_code": "\tpublic static final String WEB_HANDLER_BEAN_NAME = \"webHandler\";",
    "type": "String"
  },
  "org.springframework.web.server.adapter.WEB_SESSION_MANAGER_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Well-known name for the WebSessionManager in the bean factory. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "signature": "public String WEB_SESSION_MANAGER_BEAN_NAME",
    "source_code": "\tpublic static final String WEB_SESSION_MANAGER_BEAN_NAME = \"webSessionManager\";",
    "type": "String"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * This builder has two purposes:\n *\n * <p>One is to assemble a processing chain that consists of a target {@link WebHandler},\n * then decorated with a set of {@link WebFilter WebFilters}, then further decorated with\n * a set of {@link WebExceptionHandler WebExceptionHandlers}.\n *\n * <p>The second purpose is to adapt the resulting processing chain to an {@link HttpHandler}:\n * the lowest-level reactive HTTP handling abstraction which can then be used with any of the\n * supported runtimes. The adaptation is done with the help of {@link HttpWebHandlerAdapter}.\n *\n * <p>The processing chain can be assembled manually via builder methods, or detected from\n * a Spring {@link ApplicationContext} via {@link #applicationContext}, or a mix of both.\n *\n * @author Rossen Stoyanchev\n * @author Sebastien Deleuze\n * @since 5.0\n * @see HttpWebHandlerAdapter\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "signature": "public class WebHttpHandlerBuilder",
    "source_code": "public final class WebHttpHandlerBuilder {\n\n\t/** Well-known name for the target WebHandler in the bean factory. */\n\tpublic static final String WEB_HANDLER_BEAN_NAME = \"webHandler\";\n\n\t/** Well-known name for the WebSessionManager in the bean factory. */\n\tpublic static final String WEB_SESSION_MANAGER_BEAN_NAME = \"webSessionManager\";\n\n\t/** Well-known name for the ServerCodecConfigurer in the bean factory. */\n\tpublic static final String SERVER_CODEC_CONFIGURER_BEAN_NAME = \"serverCodecConfigurer\";\n\n\t/** Well-known name for the LocaleContextResolver in the bean factory. */\n\tpublic static final String LOCALE_CONTEXT_RESOLVER_BEAN_NAME = \"localeContextResolver\";\n\n\t/** Well-known name for the ForwardedHeaderTransformer in the bean factory. */\n\tpublic static final String FORWARDED_HEADER_TRANSFORMER_BEAN_NAME = \"forwardedHeaderTransformer\";\n\n\tprivate final WebHandler webHandler;\n\n\t@Nullable\n\tprivate final ApplicationContext applicationContext;\n\n\tprivate final List<WebFilter> filters = new ArrayList<>();\n\n\tprivate final List<WebExceptionHandler> exceptionHandlers = new ArrayList<>();\n\n\t@Nullable\n\tprivate Function<HttpHandler, HttpHandler> httpHandlerDecorator;\n\n\t@Nullable\n\tprivate WebSessionManager sessionManager;\n\n\t@Nullable\n\tprivate ServerCodecConfigurer codecConfigurer;\n\n\t@Nullable\n\tprivate LocaleContextResolver localeContextResolver;\n\n\t@Nullable\n\tprivate ForwardedHeaderTransformer forwardedHeaderTransformer;\n\n\t@Nullable\n\tprivate ObservationRegistry observationRegistry;\n\n\t@Nullable\n\tprivate ServerRequestObservationConvention observationConvention;\n\n\n\t/**\n\t * Private constructor to use when initialized from an ApplicationContext.\n\t */\n\tprivate WebHttpHandlerBuilder(WebHandler webHandler, @Nullable ApplicationContext applicationContext) {\n\t\tAssert.notNull(webHandler, \"WebHandler must not be null\");\n\t\tthis.webHandler = webHandler;\n\t\tthis.applicationContext = applicationContext;\n\t}\n\n\t/**\n\t * Copy constructor.\n\t */\n\tprivate WebHttpHandlerBuilder(WebHttpHandlerBuilder other) {\n\t\tthis.webHandler = other.webHandler;\n\t\tthis.applicationContext = other.applicationContext;\n\t\tthis.filters.addAll(other.filters);\n\t\tthis.exceptionHandlers.addAll(other.exceptionHandlers);\n\t\tthis.sessionManager = other.sessionManager;\n\t\tthis.codecConfigurer = other.codecConfigurer;\n\t\tthis.localeContextResolver = other.localeContextResolver;\n\t\tthis.forwardedHeaderTransformer = other.forwardedHeaderTransformer;\n\t\tthis.observationRegistry = other.observationRegistry;\n\t\tthis.observationConvention = other.observationConvention;\n\t\tthis.httpHandlerDecorator = other.httpHandlerDecorator;\n\t}\n\n\n\t/**\n\t * Static factory method to create a new builder instance.\n\t * @param webHandler the target handler for the request\n\t * @return the prepared builder\n\t */\n\tpublic static WebHttpHandlerBuilder webHandler(WebHandler webHandler) {\n\t\treturn new WebHttpHandlerBuilder(webHandler, null);\n\t}\n\n\t/**\n\t * Static factory method to create a new builder instance by detecting beans\n\t * in an {@link ApplicationContext}. The following are detected:\n\t * <ul>\n\t * <li>{@link WebHandler} [1] -- looked up by the name\n\t * {@link #WEB_HANDLER_BEAN_NAME}.\n\t * <li>{@link WebFilter} [0..N] -- detected by type and ordered,\n\t * see {@link AnnotationAwareOrderComparator}.\n\t * <li>{@link WebExceptionHandler} [0..N] -- detected by type and\n\t * ordered.\n\t * <li>{@link HttpHandlerDecoratorFactory} [0..N] -- detected by type and\n\t * ordered.\n\t * <li>{@link ObservationRegistry} -- detected by type and\n\t * configured if unique.\n\t * <li>{@link ServerRequestObservationConvention} -- detected by type and\n\t * configured if unique.\n\t * <li>{@link WebSessionManager} [0..1] -- looked up by the name\n\t * {@link #WEB_SESSION_MANAGER_BEAN_NAME}.\n\t * <li>{@link ServerCodecConfigurer} [0..1] -- looked up by the name\n\t * {@link #SERVER_CODEC_CONFIGURER_BEAN_NAME}.\n\t * <li>{@link LocaleContextResolver} [0..1] -- looked up by the name\n\t * {@link #LOCALE_CONTEXT_RESOLVER_BEAN_NAME}.\n\t * </ul>\n\t * @param context the application context to use for the lookup\n\t * @return the prepared builder\n\t */\n\tpublic static WebHttpHandlerBuilder applicationContext(ApplicationContext context) {\n\n\t\tWebHttpHandlerBuilder builder = new WebHttpHandlerBuilder(\n\t\t\t\tcontext.getBean(WEB_HANDLER_BEAN_NAME, WebHandler.class), context);\n\n\t\tList<WebFilter> webFilters = context\n\t\t\t\t.getBeanProvider(WebFilter.class)\n\t\t\t\t.orderedStream()\n\t\t\t\t.toList();\n\t\tbuilder.filters(filters -> filters.addAll(webFilters));\n\n\t\tList<WebExceptionHandler> exceptionHandlers = context\n\t\t\t\t.getBeanProvider(WebExceptionHandler.class)\n\t\t\t\t.orderedStream()\n\t\t\t\t.toList();\n\t\tbuilder.exceptionHandlers(handlers -> handlers.addAll(exceptionHandlers));\n\n\t\tcontext.getBeanProvider(HttpHandlerDecoratorFactory.class)\n\t\t\t\t.orderedStream()\n\t\t\t\t.forEach(builder::httpHandlerDecorator);\n\n\t\tcontext.getBeanProvider(ObservationRegistry.class).ifUnique(builder::observationRegistry);\n\t\tcontext.getBeanProvider(ServerRequestObservationConvention.class).ifAvailable(builder::observationConvention);\n\n\t\ttry {\n\t\t\tbuilder.sessionManager(\n\t\t\t\t\tcontext.getBean(WEB_SESSION_MANAGER_BEAN_NAME, WebSessionManager.class));\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Fall back on default\n\t\t}\n\n\t\ttry {\n\t\t\tbuilder.codecConfigurer(\n\t\t\t\t\tcontext.getBean(SERVER_CODEC_CONFIGURER_BEAN_NAME, ServerCodecConfigurer.class));\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Fall back on default\n\t\t}\n\n\t\ttry {\n\t\t\tbuilder.localeContextResolver(\n\t\t\t\t\tcontext.getBean(LOCALE_CONTEXT_RESOLVER_BEAN_NAME, LocaleContextResolver.class));\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Fall back on default\n\t\t}\n\n\t\ttry {\n\t\t\tbuilder.forwardedHeaderTransformer(\n\t\t\t\t\tcontext.getBean(FORWARDED_HEADER_TRANSFORMER_BEAN_NAME, ForwardedHeaderTransformer.class));\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Fall back on default\n\t\t}\n\n\t\treturn builder;\n\t}\n\n\n\t/**\n\t * Add the given filter(s).\n\t * @param filters the filter(s) to add that's\n\t */\n\tpublic WebHttpHandlerBuilder filter(WebFilter... filters) {\n\t\tif (!ObjectUtils.isEmpty(filters)) {\n\t\t\tthis.filters.addAll(Arrays.asList(filters));\n\t\t\tupdateFilters();\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Manipulate the \"live\" list of currently configured filters.\n\t * @param consumer the consumer to use\n\t */\n\tpublic WebHttpHandlerBuilder filters(Consumer<List<WebFilter>> consumer) {\n\t\tconsumer.accept(this.filters);\n\t\tupdateFilters();\n\t\treturn this;\n\t}\n\n\tprivate void updateFilters() {\n\t\tif (this.filters.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\tList<WebFilter> filtersToUse = this.filters.stream()\n\t\t\t\t.peek(filter -> {\n\t\t\t\t\tif (filter instanceof ForwardedHeaderTransformer forwardedHeaderTransformerFilter\n\t\t\t\t\t\t\t&& this.forwardedHeaderTransformer == null) {\n\t\t\t\t\t\tthis.forwardedHeaderTransformer = forwardedHeaderTransformerFilter;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.filter(filter -> !(filter instanceof ForwardedHeaderTransformer))\n\t\t\t\t.toList();\n\n\t\tthis.filters.clear();\n\t\tthis.filters.addAll(filtersToUse);\n\t}\n\n\t/**\n\t * Add the given exception handler(s).\n\t * @param handlers the exception handler(s)\n\t */\n\tpublic WebHttpHandlerBuilder exceptionHandler(WebExceptionHandler... handlers) {\n\t\tif (!ObjectUtils.isEmpty(handlers)) {\n\t\t\tthis.exceptionHandlers.addAll(Arrays.asList(handlers));\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Manipulate the \"live\" list of currently configured exception handlers.\n\t * @param consumer the consumer to use\n\t */\n\tpublic WebHttpHandlerBuilder exceptionHandlers(Consumer<List<WebExceptionHandler>> consumer) {\n\t\tconsumer.accept(this.exceptionHandlers);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Configure the {@link WebSessionManager} to set on the\n\t * {@link ServerWebExchange WebServerExchange}.\n\t * <p>By default {@link DefaultWebSessionManager} is used.\n\t * @param manager the session manager\n\t * @see HttpWebHandlerAdapter#setSessionManager(WebSessionManager)\n\t */\n\tpublic WebHttpHandlerBuilder sessionManager(WebSessionManager manager) {\n\t\tthis.sessionManager = manager;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Whether a {@code WebSessionManager} is configured or not, either detected from an\n\t * {@code ApplicationContext} or explicitly configured via {@link #sessionManager}.\n\t * @since 5.0.9\n\t */\n\tpublic boolean hasSessionManager() {\n\t\treturn (this.sessionManager != null);\n\t}\n\n\t/**\n\t * Configure the {@link ServerCodecConfigurer} to set on the {@code WebServerExchange}.\n\t * @param codecConfigurer the codec configurer\n\t */\n\tpublic WebHttpHandlerBuilder codecConfigurer(ServerCodecConfigurer codecConfigurer) {\n\t\tthis.codecConfigurer = codecConfigurer;\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Whether a {@code ServerCodecConfigurer} is configured or not, either detected from an\n\t * {@code ApplicationContext} or explicitly configured via {@link #codecConfigurer}.\n\t * @since 5.0.9\n\t */\n\tpublic boolean hasCodecConfigurer() {\n\t\treturn (this.codecConfigurer != null);\n\t}\n\n\t/**\n\t * Configure the {@link LocaleContextResolver} to set on the\n\t * {@link ServerWebExchange WebServerExchange}.\n\t * @param localeContextResolver the locale context resolver\n\t */\n\tpublic WebHttpHandlerBuilder localeContextResolver(LocaleContextResolver localeContextResolver) {\n\t\tthis.localeContextResolver = localeContextResolver;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Whether a {@code LocaleContextResolver} is configured or not, either detected from an\n\t * {@code ApplicationContext} or explicitly configured via {@link #localeContextResolver}.\n\t * @since 5.0.9\n\t */\n\tpublic boolean hasLocaleContextResolver() {\n\t\treturn (this.localeContextResolver != null);\n\t}\n\n\t/**\n\t * Configure the {@link ForwardedHeaderTransformer} for extracting and/or\n\t * removing forwarded headers.\n\t * @param transformer the transformer\n\t * @since 5.1\n\t */\n\tpublic WebHttpHandlerBuilder forwardedHeaderTransformer(ForwardedHeaderTransformer transformer) {\n\t\tthis.forwardedHeaderTransformer = transformer;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Whether a {@code ForwardedHeaderTransformer} is configured or not, either\n\t * detected from an {@code ApplicationContext} or explicitly configured via\n\t * {@link #forwardedHeaderTransformer(ForwardedHeaderTransformer)}.\n\t * @since 5.1\n\t */\n\tpublic boolean hasForwardedHeaderTransformer() {\n\t\treturn (this.forwardedHeaderTransformer != null);\n\t}\n\n\t/**\n\t * Configure an {@link ObservationRegistry} for recording server exchange observations.\n\t * By default, a {@link ObservationRegistry#NOOP no-op} registry will be configured.\n\t * @param observationRegistry the observation registry\n\t * @since 6.1\n\t */\n\tpublic WebHttpHandlerBuilder observationRegistry(ObservationRegistry observationRegistry) {\n\t\tthis.observationRegistry = observationRegistry;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Configure a {@link ServerRequestObservationConvention} to use for server observations.\n\t * By default, a {@link DefaultServerRequestObservationConvention} will be used.\n\t * @param observationConvention the convention to use for all recorded observations\n\t * @since 6.1\n\t */\n\tpublic WebHttpHandlerBuilder observationConvention(ServerRequestObservationConvention observationConvention) {\n\t\tthis.observationConvention = observationConvention;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Configure a {@link Function} to decorate the {@link HttpHandler} returned\n\t * by this builder which effectively wraps the entire\n\t * {@link WebExceptionHandler} - {@link WebFilter} - {@link WebHandler}\n\t * processing chain. This provides access to the request and response before\n\t * the entire chain and likewise the ability to observe the result of\n\t * the entire chain.\n\t * @param handlerDecorator the decorator to apply\n\t * @since 5.3\n\t */\n\tpublic WebHttpHandlerBuilder httpHandlerDecorator(Function<HttpHandler, HttpHandler> handlerDecorator) {\n\t\tthis.httpHandlerDecorator = (this.httpHandlerDecorator != null ?\n\t\t\t\thandlerDecorator.andThen(this.httpHandlerDecorator) : handlerDecorator);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Whether a decorator for {@link HttpHandler} is configured or not via\n\t * {@link #httpHandlerDecorator(Function)}.\n\t * @since 5.3\n\t */\n\tpublic boolean hasHttpHandlerDecorator() {\n\t\treturn (this.httpHandlerDecorator != null);\n\t}\n\n\t/**\n\t * Build the {@link HttpHandler}.\n\t */\n\tpublic HttpHandler build() {\n\t\tWebHandler decorated = new FilteringWebHandler(this.webHandler, this.filters);\n\t\tdecorated = new ExceptionHandlingWebHandler(decorated, this.exceptionHandlers);\n\n\t\tHttpWebHandlerAdapter adapted = new HttpWebHandlerAdapter(decorated);\n\t\tif (this.sessionManager != null) {\n\t\t\tadapted.setSessionManager(this.sessionManager);\n\t\t}\n\t\tif (this.codecConfigurer != null) {\n\t\t\tadapted.setCodecConfigurer(this.codecConfigurer);\n\t\t}\n\t\tif (this.localeContextResolver != null) {\n\t\t\tadapted.setLocaleContextResolver(this.localeContextResolver);\n\t\t}\n\t\tif (this.forwardedHeaderTransformer != null) {\n\t\t\tadapted.setForwardedHeaderTransformer(this.forwardedHeaderTransformer);\n\t\t}\n\t\tif (this.observationRegistry != null) {\n\t\t\tadapted.setObservationRegistry(this.observationRegistry);\n\t\t}\n\t\tif (this.observationConvention != null) {\n\t\t\tadapted.setObservationConvention(this.observationConvention);\n\t\t}\n\t\tif (this.applicationContext != null) {\n\t\t\tadapted.setApplicationContext(this.applicationContext);\n\t\t}\n\t\tadapted.afterPropertiesSet();\n\n\t\treturn (this.httpHandlerDecorator != null ? this.httpHandlerDecorator.apply(adapted) : adapted);\n\t}\n\n\t/**\n\t * Clone this {@link WebHttpHandlerBuilder}.\n\t * @return the cloned builder instance\n\t */\n\t@Override\n\tpublic WebHttpHandlerBuilder clone() {\n\t\treturn new WebHttpHandlerBuilder(this);\n\t}\n\n\n\t/**\n\t * {@code BlockHoundIntegration} for spring-web classes.\n\t * @since 5.3.6\n\t */\n\tpublic static class SpringWebBlockHoundIntegration implements BlockHoundIntegration {\n\n\t\t@Override\n\t\tpublic void applyTo(BlockHound.Builder builder) {\n\n\t\t\t// Avoid hard references potentially anywhere in spring-web (no need for structural dependency)\n\n\t\t\tbuilder.allowBlockingCallsInside(\"org.springframework.http.MediaTypeFactory\", \"<clinit>\");\n\t\t\tbuilder.allowBlockingCallsInside(\"org.springframework.web.util.HtmlUtils\", \"<clinit>\");\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#applicationContext(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create a new builder instance by detecting beans\n\t * in an {@link ApplicationContext}. The following are detected:\n\t * <ul>\n\t * <li>{@link WebHandler} [1] -- looked up by the name\n\t * {@link #WEB_HANDLER_BEAN_NAME}.\n\t * <li>{@link WebFilter} [0..N] -- detected by type and ordered,\n\t * see {@link AnnotationAwareOrderComparator}.\n\t * <li>{@link WebExceptionHandler} [0..N] -- detected by type and\n\t * ordered.\n\t * <li>{@link HttpHandlerDecoratorFactory} [0..N] -- detected by type and\n\t * ordered.\n\t * <li>{@link ObservationRegistry} -- detected by type and\n\t * configured if unique.\n\t * <li>{@link ServerRequestObservationConvention} -- detected by type and\n\t * configured if unique.\n\t * <li>{@link WebSessionManager} [0..1] -- looked up by the name\n\t * {@link #WEB_SESSION_MANAGER_BEAN_NAME}.\n\t * <li>{@link ServerCodecConfigurer} [0..1] -- looked up by the name\n\t * {@link #SERVER_CODEC_CONFIGURER_BEAN_NAME}.\n\t * <li>{@link LocaleContextResolver} [0..1] -- looked up by the name\n\t * {@link #LOCALE_CONTEXT_RESOLVER_BEAN_NAME}.\n\t * </ul>\n\t * @param context the application context to use for the lookup\n\t * @return the prepared builder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder applicationContext(ApplicationContext context)",
    "source_code": "\tpublic static WebHttpHandlerBuilder applicationContext(ApplicationContext context) {\n\n\t\tWebHttpHandlerBuilder builder = new WebHttpHandlerBuilder(\n\t\t\t\tcontext.getBean(WEB_HANDLER_BEAN_NAME, WebHandler.class), context);\n\n\t\tList<WebFilter> webFilters = context\n\t\t\t\t.getBeanProvider(WebFilter.class)\n\t\t\t\t.orderedStream()\n\t\t\t\t.toList();\n\t\tbuilder.filters(filters -> filters.addAll(webFilters));\n\n\t\tList<WebExceptionHandler> exceptionHandlers = context\n\t\t\t\t.getBeanProvider(WebExceptionHandler.class)\n\t\t\t\t.orderedStream()\n\t\t\t\t.toList();\n\t\tbuilder.exceptionHandlers(handlers -> handlers.addAll(exceptionHandlers));\n\n\t\tcontext.getBeanProvider(HttpHandlerDecoratorFactory.class)\n\t\t\t\t.orderedStream()\n\t\t\t\t.forEach(builder::httpHandlerDecorator);\n\n\t\tcontext.getBeanProvider(ObservationRegistry.class).ifUnique(builder::observationRegistry);\n\t\tcontext.getBeanProvider(ServerRequestObservationConvention.class).ifAvailable(builder::observationConvention);\n\n\t\ttry {\n\t\t\tbuilder.sessionManager(\n\t\t\t\t\tcontext.getBean(WEB_SESSION_MANAGER_BEAN_NAME, WebSessionManager.class));\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Fall back on default\n\t\t}\n\n\t\ttry {\n\t\t\tbuilder.codecConfigurer(\n\t\t\t\t\tcontext.getBean(SERVER_CODEC_CONFIGURER_BEAN_NAME, ServerCodecConfigurer.class));\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Fall back on default\n\t\t}\n\n\t\ttry {\n\t\t\tbuilder.localeContextResolver(\n\t\t\t\t\tcontext.getBean(LOCALE_CONTEXT_RESOLVER_BEAN_NAME, LocaleContextResolver.class));\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Fall back on default\n\t\t}\n\n\t\ttry {\n\t\t\tbuilder.forwardedHeaderTransformer(\n\t\t\t\t\tcontext.getBean(FORWARDED_HEADER_TRANSFORMER_BEAN_NAME, ForwardedHeaderTransformer.class));\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Fall back on default\n\t\t}\n\n\t\treturn builder;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#applyTo(builder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "builder"
    ],
    "position": {
      "column": 1,
      "line": 478
    },
    "return": "void",
    "signature": "public void applyTo(BlockHound.Builder builder)",
    "source_code": "\t\tpublic void applyTo(BlockHound.Builder builder) {\n\n\t\t\t// Avoid hard references potentially anywhere in spring-web (no need for structural dependency)\n\n\t\t\tbuilder.allowBlockingCallsInside(\"org.springframework.http.MediaTypeFactory\", \"<clinit>\");\n\t\t\tbuilder.allowBlockingCallsInside(\"org.springframework.web.util.HtmlUtils\", \"<clinit>\");\n\t\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#build()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build the {@link HttpHandler}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 430
    },
    "return": "HttpHandler",
    "signature": "public HttpHandler build()",
    "source_code": "\tpublic HttpHandler build() {\n\t\tWebHandler decorated = new FilteringWebHandler(this.webHandler, this.filters);\n\t\tdecorated = new ExceptionHandlingWebHandler(decorated, this.exceptionHandlers);\n\n\t\tHttpWebHandlerAdapter adapted = new HttpWebHandlerAdapter(decorated);\n\t\tif (this.sessionManager != null) {\n\t\t\tadapted.setSessionManager(this.sessionManager);\n\t\t}\n\t\tif (this.codecConfigurer != null) {\n\t\t\tadapted.setCodecConfigurer(this.codecConfigurer);\n\t\t}\n\t\tif (this.localeContextResolver != null) {\n\t\t\tadapted.setLocaleContextResolver(this.localeContextResolver);\n\t\t}\n\t\tif (this.forwardedHeaderTransformer != null) {\n\t\t\tadapted.setForwardedHeaderTransformer(this.forwardedHeaderTransformer);\n\t\t}\n\t\tif (this.observationRegistry != null) {\n\t\t\tadapted.setObservationRegistry(this.observationRegistry);\n\t\t}\n\t\tif (this.observationConvention != null) {\n\t\t\tadapted.setObservationConvention(this.observationConvention);\n\t\t}\n\t\tif (this.applicationContext != null) {\n\t\t\tadapted.setApplicationContext(this.applicationContext);\n\t\t}\n\t\tadapted.afterPropertiesSet();\n\n\t\treturn (this.httpHandlerDecorator != null ? this.httpHandlerDecorator.apply(adapted) : adapted);\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#clone()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Clone this {@link WebHttpHandlerBuilder}.\n\t * @return the cloned builder instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 466
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder clone()",
    "source_code": "\tpublic WebHttpHandlerBuilder clone() {\n\t\treturn new WebHttpHandlerBuilder(this);\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#codecConfigurer(codecConfigurer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@link ServerCodecConfigurer} to set on the {@code WebServerExchange}.\n\t * @param codecConfigurer the codec configurer\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "codecConfigurer"
    ],
    "position": {
      "column": 1,
      "line": 325
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder codecConfigurer(ServerCodecConfigurer codecConfigurer)",
    "source_code": "\tpublic WebHttpHandlerBuilder codecConfigurer(ServerCodecConfigurer codecConfigurer) {\n\t\tthis.codecConfigurer = codecConfigurer;\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#exceptionHandler(handlers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given exception handler(s).\n\t * @param handlers the exception handler(s)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handlers"
    ],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder exceptionHandler(WebExceptionHandler... handlers)",
    "source_code": "\tpublic WebHttpHandlerBuilder exceptionHandler(WebExceptionHandler... handlers) {\n\t\tif (!ObjectUtils.isEmpty(handlers)) {\n\t\t\tthis.exceptionHandlers.addAll(Arrays.asList(handlers));\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#exceptionHandlers(consumer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Manipulate the \"live\" list of currently configured exception handlers.\n\t * @param consumer the consumer to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "consumer"
    ],
    "position": {
      "column": 1,
      "line": 295
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder exceptionHandlers(Consumer<List<WebExceptionHandler>> consumer)",
    "source_code": "\tpublic WebHttpHandlerBuilder exceptionHandlers(Consumer<List<WebExceptionHandler>> consumer) {\n\t\tconsumer.accept(this.exceptionHandlers);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#filter(filters)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given filter(s).\n\t * @param filters the filter(s) to add that's\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "filters"
    ],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder filter(WebFilter... filters)",
    "source_code": "\tpublic WebHttpHandlerBuilder filter(WebFilter... filters) {\n\t\tif (!ObjectUtils.isEmpty(filters)) {\n\t\t\tthis.filters.addAll(Arrays.asList(filters));\n\t\t\tupdateFilters();\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#filters(consumer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Manipulate the \"live\" list of currently configured filters.\n\t * @param consumer the consumer to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "consumer"
    ],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder filters(Consumer<List<WebFilter>> consumer)",
    "source_code": "\tpublic WebHttpHandlerBuilder filters(Consumer<List<WebFilter>> consumer) {\n\t\tconsumer.accept(this.filters);\n\t\tupdateFilters();\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#forwardedHeaderTransformer(transformer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@link ForwardedHeaderTransformer} for extracting and/or\n\t * removing forwarded headers.\n\t * @param transformer the transformer\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "transformer"
    ],
    "position": {
      "column": 1,
      "line": 365
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder forwardedHeaderTransformer(ForwardedHeaderTransformer transformer)",
    "source_code": "\tpublic WebHttpHandlerBuilder forwardedHeaderTransformer(ForwardedHeaderTransformer transformer) {\n\t\tthis.forwardedHeaderTransformer = transformer;\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#hasCodecConfigurer()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether a {@code ServerCodecConfigurer} is configured or not, either detected from an\n\t * {@code ApplicationContext} or explicitly configured via {@link #codecConfigurer}.\n\t * @since 5.0.9\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 336
    },
    "return": "boolean",
    "signature": "public boolean hasCodecConfigurer()",
    "source_code": "\tpublic boolean hasCodecConfigurer() {\n\t\treturn (this.codecConfigurer != null);\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#hasForwardedHeaderTransformer()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether a {@code ForwardedHeaderTransformer} is configured or not, either\n\t * detected from an {@code ApplicationContext} or explicitly configured via\n\t * {@link #forwardedHeaderTransformer(ForwardedHeaderTransformer)}.\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 376
    },
    "return": "boolean",
    "signature": "public boolean hasForwardedHeaderTransformer()",
    "source_code": "\tpublic boolean hasForwardedHeaderTransformer() {\n\t\treturn (this.forwardedHeaderTransformer != null);\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#hasHttpHandlerDecorator()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether a decorator for {@link HttpHandler} is configured or not via\n\t * {@link #httpHandlerDecorator(Function)}.\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 423
    },
    "return": "boolean",
    "signature": "public boolean hasHttpHandlerDecorator()",
    "source_code": "\tpublic boolean hasHttpHandlerDecorator() {\n\t\treturn (this.httpHandlerDecorator != null);\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#hasLocaleContextResolver()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether a {@code LocaleContextResolver} is configured or not, either detected from an\n\t * {@code ApplicationContext} or explicitly configured via {@link #localeContextResolver}.\n\t * @since 5.0.9\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 355
    },
    "return": "boolean",
    "signature": "public boolean hasLocaleContextResolver()",
    "source_code": "\tpublic boolean hasLocaleContextResolver() {\n\t\treturn (this.localeContextResolver != null);\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#hasSessionManager()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether a {@code WebSessionManager} is configured or not, either detected from an\n\t * {@code ApplicationContext} or explicitly configured via {@link #sessionManager}.\n\t * @since 5.0.9\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 317
    },
    "return": "boolean",
    "signature": "public boolean hasSessionManager()",
    "source_code": "\tpublic boolean hasSessionManager() {\n\t\treturn (this.sessionManager != null);\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#httpHandlerDecorator(Function<HttpHandler,handlerDecorator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a {@link Function} to decorate the {@link HttpHandler} returned\n\t * by this builder which effectively wraps the entire\n\t * {@link WebExceptionHandler} - {@link WebFilter} - {@link WebHandler}\n\t * processing chain. This provides access to the request and response before\n\t * the entire chain and likewise the ability to observe the result of\n\t * the entire chain.\n\t * @param handlerDecorator the decorator to apply\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<HttpHandler",
      "handlerDecorator"
    ],
    "position": {
      "column": 1,
      "line": 412
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder httpHandlerDecorator(Function<HttpHandler, HttpHandler> handlerDecorator)",
    "source_code": "\tpublic WebHttpHandlerBuilder httpHandlerDecorator(Function<HttpHandler, HttpHandler> handlerDecorator) {\n\t\tthis.httpHandlerDecorator = (this.httpHandlerDecorator != null ?\n\t\t\t\thandlerDecorator.andThen(this.httpHandlerDecorator) : handlerDecorator);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#localeContextResolver(localeContextResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@link LocaleContextResolver} to set on the\n\t * {@link ServerWebExchange WebServerExchange}.\n\t * @param localeContextResolver the locale context resolver\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "localeContextResolver"
    ],
    "position": {
      "column": 1,
      "line": 345
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder localeContextResolver(LocaleContextResolver localeContextResolver)",
    "source_code": "\tpublic WebHttpHandlerBuilder localeContextResolver(LocaleContextResolver localeContextResolver) {\n\t\tthis.localeContextResolver = localeContextResolver;\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#observationConvention(observationConvention)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a {@link ServerRequestObservationConvention} to use for server observations.\n\t * By default, a {@link DefaultServerRequestObservationConvention} will be used.\n\t * @param observationConvention the convention to use for all recorded observations\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "observationConvention"
    ],
    "position": {
      "column": 1,
      "line": 397
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder observationConvention(ServerRequestObservationConvention observationConvention)",
    "source_code": "\tpublic WebHttpHandlerBuilder observationConvention(ServerRequestObservationConvention observationConvention) {\n\t\tthis.observationConvention = observationConvention;\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#observationRegistry(observationRegistry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure an {@link ObservationRegistry} for recording server exchange observations.\n\t * By default, a {@link ObservationRegistry#NOOP no-op} registry will be configured.\n\t * @param observationRegistry the observation registry\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "observationRegistry"
    ],
    "position": {
      "column": 1,
      "line": 386
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder observationRegistry(ObservationRegistry observationRegistry)",
    "source_code": "\tpublic WebHttpHandlerBuilder observationRegistry(ObservationRegistry observationRegistry) {\n\t\tthis.observationRegistry = observationRegistry;\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#sessionManager(manager)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@link WebSessionManager} to set on the\n\t * {@link ServerWebExchange WebServerExchange}.\n\t * <p>By default {@link DefaultWebSessionManager} is used.\n\t * @param manager the session manager\n\t * @see HttpWebHandlerAdapter#setSessionManager(WebSessionManager)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "manager"
    ],
    "position": {
      "column": 1,
      "line": 307
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder sessionManager(WebSessionManager manager)",
    "source_code": "\tpublic WebHttpHandlerBuilder sessionManager(WebSessionManager manager) {\n\t\tthis.sessionManager = manager;\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#webHandler(webHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create a new builder instance.\n\t * @param webHandler the target handler for the request\n\t * @return the prepared builder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webHandler"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder webHandler(WebHandler webHandler)",
    "source_code": "\tpublic static WebHttpHandlerBuilder webHandler(WebHandler webHandler) {\n\t\treturn new WebHttpHandlerBuilder(webHandler, null);\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#block()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "ServerResponse",
    "signature": "public ServerResponse block()",
    "source_code": "\tpublic ServerResponse block() {\n\t\ttry {\n\t\t\tif (this.timeout != null) {\n\t\t\t\treturn this.futureResponse.get(this.timeout.toMillis(), TimeUnit.MILLISECONDS);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn this.futureResponse.get();\n\t\t\t}\n\t\t}\n\t\tcatch (InterruptedException | ExecutionException | TimeoutException ex) {\n\t\t\tthrow new IllegalStateException(\"Failed to get future response\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#create(obj,timeout)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "AsyncServerResponse",
    "signature": "public AsyncServerResponse create(Object obj, @Nullable Duration timeout)",
    "source_code": "\tpublic static AsyncServerResponse create(Object obj, @Nullable Duration timeout) {\n\t\tAssert.notNull(obj, \"Argument to async must not be null\");\n\n\t\tif (obj instanceof CompletableFuture futureResponse) {\n\t\t\treturn new DefaultAsyncServerResponse(futureResponse, timeout);\n\t\t}\n\t\telse if (reactiveStreamsPresent) {\n\t\t\tReactiveAdapterRegistry registry = ReactiveAdapterRegistry.getSharedInstance();\n\t\t\tReactiveAdapter publisherAdapter = registry.getAdapter(obj.getClass());\n\t\t\tif (publisherAdapter != null) {\n\t\t\t\tPublisher<ServerResponse> publisher = publisherAdapter.toPublisher(obj);\n\t\t\t\tReactiveAdapter futureAdapter = registry.getAdapter(CompletableFuture.class);\n\t\t\t\tif (futureAdapter != null) {\n\t\t\t\t\tCompletableFuture<ServerResponse> futureResponse =\n\t\t\t\t\t\t\t(CompletableFuture<ServerResponse>) futureAdapter.fromPublisher(publisher);\n\t\t\t\t\treturn new DefaultAsyncServerResponse(futureResponse, timeout);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Asynchronous type not supported: \" + obj.getClass());\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#headers()": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders headers()",
    "source_code": "\tpublic HttpHeaders headers() {\n\t\treturn delegate(ServerResponse::headers);\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#rawStatusCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "int",
    "signature": "public int rawStatusCode()",
    "source_code": "\tpublic int rawStatusCode() {\n\t\treturn delegate(ServerResponse::rawStatusCode);\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#sendRedirect(location,sc,clearBuffer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location",
      "sc",
      "clearBuffer"
    ],
    "position": {
      "column": 1,
      "line": 683
    },
    "return": "void",
    "signature": "public void sendRedirect(String location, int sc, boolean clearBuffer)",
    "source_code": "\t\tpublic void sendRedirect(String location, int sc, boolean clearBuffer) throws IOException {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#statusCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "HttpStatusCode",
    "signature": "public HttpStatusCode statusCode()",
    "source_code": "\tpublic HttpStatusCode statusCode() {\n\t\treturn delegate(ServerResponse::statusCode);\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#writeTo(request,response,context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "ModelAndView",
    "signature": "public ModelAndView writeTo(HttpServletRequest request, HttpServletResponse response, Context context)",
    "source_code": "\tpublic ModelAndView writeTo(HttpServletRequest request, HttpServletResponse response, Context context)"
  },
  "org.springframework.web.servlet.function.AsyncServerResponse": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Asynchronous subtype of {@link ServerResponse} that exposes the future\n * response.\n *\n * @author Arjen Poutsma\n * @since 5.3.2\n * @see ServerResponse#async(Object)\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "signature": "public interface AsyncServerResponse",
    "source_code": "public interface AsyncServerResponse extends ServerResponse {\n\n\t/**\n\t * Blocks indefinitely until the future response is obtained.\n\t */\n\tServerResponse block();\n\n\n\t// Static creation methods\n\n\t/**\n\t * Create a {@code AsyncServerResponse} with the given asynchronous response.\n\t * Parameter {@code asyncResponse} can be a\n\t * {@link CompletableFuture CompletableFuture&lt;ServerResponse&gt;} or\n\t * {@link Publisher Publisher&lt;ServerResponse&gt;} (or any\n\t * asynchronous producer of a single {@code ServerResponse} that can be\n\t * adapted via the {@link ReactiveAdapterRegistry}).\n\t * @param asyncResponse a {@code CompletableFuture<ServerResponse>} or\n\t * {@code Publisher<ServerResponse>}\n\t * @return the asynchronous response\n\t */\n\tstatic AsyncServerResponse create(Object asyncResponse) {\n\t\treturn createInternal(asyncResponse, null);\n\t}\n\n\t/**\n\t * Create a (built) response with the given asynchronous response.\n\t * Parameter {@code asyncResponse} can be a\n\t * {@link CompletableFuture CompletableFuture&lt;ServerResponse&gt;} or\n\t * {@link Publisher Publisher&lt;ServerResponse&gt;} (or any\n\t * asynchronous producer of a single {@code ServerResponse} that can be\n\t * adapted via the {@link ReactiveAdapterRegistry}).\n\t * @param asyncResponse a {@code CompletableFuture<ServerResponse>} or\n\t * {@code Publisher<ServerResponse>}\n\t * @param timeout maximum time period to wait for before timing out\n\t * @return the asynchronous response\n\t */\n\tstatic AsyncServerResponse create(Object asyncResponse, Duration timeout) {\n\t\treturn createInternal(asyncResponse, timeout);\n\t}\n\n\tprivate static AsyncServerResponse createInternal(Object asyncResponse, @Nullable Duration timeout) {\n\t\tAssert.notNull(asyncResponse, \"AsyncResponse must not be null\");\n\n\t\tCompletableFuture<ServerResponse> futureResponse = toCompletableFuture(asyncResponse);\n\t\tif (futureResponse.isDone() &&\n\t\t\t\t!futureResponse.isCancelled() &&\n\t\t\t\t!futureResponse.isCompletedExceptionally()) {\n\n\t\t\ttry {\n\t\t\t\tServerResponse completedResponse = futureResponse.get();\n\t\t\t\treturn new CompletedAsyncServerResponse(completedResponse);\n\t\t\t}\n\t\t\tcatch (InterruptedException | ExecutionException ignored) {\n\t\t\t\t// fall through to use DefaultAsyncServerResponse\n\t\t\t}\n\t\t}\n\t\treturn new DefaultAsyncServerResponse(futureResponse, timeout);\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate static CompletableFuture<ServerResponse> toCompletableFuture(Object obj) {\n\t\tif (obj instanceof CompletableFuture<?> futureResponse) {\n\t\t\treturn (CompletableFuture<ServerResponse>) futureResponse;\n\t\t}\n\t\telse if (DefaultAsyncServerResponse.reactiveStreamsPresent) {\n\t\t\tReactiveAdapterRegistry registry = ReactiveAdapterRegistry.getSharedInstance();\n\t\t\tReactiveAdapter publisherAdapter = registry.getAdapter(obj.getClass());\n\t\t\tif (publisherAdapter != null) {\n\t\t\t\tPublisher<ServerResponse> publisher = publisherAdapter.toPublisher(obj);\n\t\t\t\tReactiveAdapter futureAdapter = registry.getAdapter(CompletableFuture.class);\n\t\t\t\tif (futureAdapter != null) {\n\t\t\t\t\treturn (CompletableFuture<ServerResponse>) futureAdapter.fromPublisher(publisher);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Asynchronous type not supported: \" + obj.getClass());\n\t}\n\n}"
  },
  "org.springframework.web.servlet.handler.AbstractHandlerMapping#handlePreFlight(request,response)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 744
    },
    "return": "void",
    "signature": "public void handlePreFlight(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\t\tpublic void handlePreFlight(HttpServletRequest request, HttpServletResponse response) throws IOException {\n\t\t\tinvokeCorsProcessor(request, response);\n\t\t}"
  },
  "org.springframework.web.servlet.handler.AbstractHandlerMapping#invokeCorsProcessor(request,response)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 723
    },
    "return": "boolean",
    "signature": "protected boolean invokeCorsProcessor(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\t\tprotected boolean invokeCorsProcessor("
  },
  "org.springframework.web.servlet.handler.AbstractUrlHandlerMapping#registerHandler(urlPath,handler)": {
    "change": "modifier_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Register the specified handler for the given URL path.\n\t * @param urlPath the URL the bean should be mapped to\n\t * @param handler the handler instance or handler bean name String\n\t * (a bean name will automatically be resolved into the corresponding handler bean)\n\t * @throws BeansException if the handler couldn't be registered\n\t * @throws IllegalStateException if there is a conflicting handler registered\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "urlPath",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 412
    },
    "return": "void",
    "signature": "protected void registerHandler(String urlPath, Object handler)",
    "source_code": "\tprotected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {\n\t\tAssert.notNull(urlPath, \"URL path must not be null\");\n\t\tAssert.notNull(handler, \"Handler object must not be null\");\n\t\tObject resolvedHandler = handler;\n\n\t\t// Eagerly resolve handler if referencing singleton via name.\n\t\tif (!this.lazyInitHandlers && handler instanceof String handlerName) {\n\t\t\tApplicationContext applicationContext = obtainApplicationContext();\n\t\t\tif (applicationContext.isSingleton(handlerName)) {\n\t\t\t\tresolvedHandler = applicationContext.getBean(handlerName);\n\t\t\t}\n\t\t}\n\n\t\tObject mappedHandler = this.handlerMap.get(urlPath);\n\t\tif (mappedHandler != null) {\n\t\t\tif (mappedHandler != resolvedHandler) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Cannot map \" + getHandlerDescription(handler) + \" to URL path [\" + urlPath +\n\t\t\t\t\t\t\"]: There is already \" + getHandlerDescription(mappedHandler) + \" mapped.\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (urlPath.equals(\"/\")) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Root mapping to \" + getHandlerDescription(handler));\n\t\t\t\t}\n\t\t\t\tsetRootHandler(resolvedHandler);\n\t\t\t}\n\t\t\telse if (urlPath.equals(\"/*\")) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Default mapping to \" + getHandlerDescription(handler));\n\t\t\t\t}\n\t\t\t\tsetDefaultHandler(resolvedHandler);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.handlerMap.put(urlPath, resolvedHandler);\n\t\t\t\tif (getPatternParser() != null) {\n\t\t\t\t\tthis.pathPatternHandlerMap.put(getPatternParser().parse(urlPath), resolvedHandler);\n\t\t\t\t}\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Mapped [\" + urlPath + \"] onto \" + getHandlerDescription(handler));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.AbstractUrlHandlerMapping#registerHandler(urlPaths,beanName)": {
    "change": "modifier_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Register the specified handler for the given URL paths.\n\t * @param urlPaths the URLs that the bean should be mapped to\n\t * @param beanName the name of the handler bean\n\t * @throws BeansException if the handler couldn't be registered\n\t * @throws IllegalStateException if there is a conflicting handler registered\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "urlPaths",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 397
    },
    "return": "void",
    "signature": "protected void registerHandler(String[] urlPaths, String beanName)",
    "source_code": "\tprotected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {\n\t\tAssert.notNull(urlPaths, \"URL path array must not be null\");\n\t\tfor (String urlPath : urlPaths) {\n\t\t\tregisterHandler(urlPath, beanName);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.AbstractUrlHandlerMapping#unregisterHandler(urlPath)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Remove the mapping for the handler registered for the given URL path.\n\t * @param urlPath the mapping to remove\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "urlPath"
    ],
    "position": {
      "column": 1,
      "line": 212
    },
    "return": "void",
    "signature": "public void unregisterHandler(String urlPath)",
    "source_code": "\tpublic void unregisterHandler(String urlPath) {\n\t\tAssert.notNull(urlPath, \"URL path must not be null\");\n\t\tif (urlPath.equals(\"/\")) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Removing root mapping: \" + getRootHandler());\n\t\t\t}\n\t\t\tsetRootHandler(null);\n\t\t}\n\t\telse if (urlPath.equals(\"/*\")) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Removing default mapping: \" + getDefaultHandler());\n\t\t\t}\n\t\t\tsetDefaultHandler(null);\n\t\t}\n\t\telse {\n\t\t\tObject mappedHandler = this.handlerMap.get(urlPath);\n\t\t\tif (mappedHandler == null) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"No mapping for [\" + urlPath + \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Removing mapping \\\"\" + urlPath + \"\\\": \" + getHandlerDescription(mappedHandler));\n\t\t\t\t}\n\t\t\t\tthis.handlerMap.remove(urlPath);\n\t\t\t\tif (getPatternParser() != null) {\n\t\t\t\t\tthis.pathPatternHandlerMap.remove(getPatternParser().parse(urlPath));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.HandlerMappingIntrospector#allHandlerMappingsUsePathPatternParser()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return {@code true} if all {@link HandlerMapping} beans\n\t * {@link HandlerMapping#usesPathPatterns() use parsed PathPatterns},\n\t * and {@code false} if any don't.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "boolean",
    "signature": "public boolean allHandlerMappingsUsePathPatternParser()",
    "source_code": "\tpublic boolean allHandlerMappingsUsePathPatternParser() {\n\t\tAssert.state(this.handlerMappings != null, \"Not yet initialized via afterPropertiesSet.\");\n\t\treturn getHandlerMappings().stream().allMatch(HandlerMapping::usesPathPatterns);\n\t}"
  },
  "org.springframework.web.servlet.handler.HandlerMappingIntrospector#handlePreFlight(request,response)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the matching {@link HandlerMapping} for the request, and invoke the\n\t * handler it returns as a {@link PreFlightRequestHandler}.\n\t * @throws NoHandlerFoundException if no handler matches the request\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "void",
    "signature": "public void handlePreFlight(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tpublic void handlePreFlight(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t\tAssert.state(this.handlerMappings != null, \"Not yet initialized via afterPropertiesSet.\");\n\t\tAssert.state(CorsUtils.isPreFlightRequest(request), \"Not a pre-flight request.\");\n\t\tRequestPath previousPath = (RequestPath) request.getAttribute(ServletRequestPathUtils.PATH_ATTRIBUTE);\n\t\ttry {\n\t\t\tServletRequestPathUtils.parseAndCache(request);\n\t\t\tfor (HandlerMapping mapping : this.handlerMappings) {\n\t\t\t\tHandlerExecutionChain chain = mapping.getHandler(request);\n\t\t\t\tif (chain != null) {\n\t\t\t\t\tObject handler = chain.getHandler();\n\t\t\t\t\tif (handler instanceof PreFlightRequestHandler preFlightHandler) {\n\t\t\t\t\t\tpreFlightHandler.handlePreFlight(request, response);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthrow new IllegalStateException(\"Expected PreFlightRequestHandler: \" + handler.getClass());\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new NoHandlerFoundException(\n\t\t\t\t\trequest.getMethod(), request.getRequestURI(), new ServletServerHttpRequest(request).getHeaders());\n\t\t}\n\t\tfinally {\n\t\t\tServletRequestPathUtils.setParsedRequestPath(previousPath, request);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor#invokeErrorResponseInterceptors(detail,errorResponse)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the configured {@link ErrorResponse.Interceptor}'s.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "detail",
      "errorResponse"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "void",
    "signature": "protected void invokeErrorResponseInterceptors(ProblemDetail detail, @Nullable ErrorResponse errorResponse)",
    "source_code": "\tprotected void invokeErrorResponseInterceptors(ProblemDetail detail, @Nullable ErrorResponse errorResponse) {\n\t\ttry {\n\t\t\tfor (ErrorResponse.Interceptor handler : this.errorResponseInterceptors) {\n\t\t\t\thandler.handleError(detail, errorResponse);\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\t// ignore\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#getExceptionHandlerMethod(handlerMethod,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find an {@code @ExceptionHandler} method for the given exception. The default\n\t * implementation searches methods in the class hierarchy of the controller first\n\t * and if not found, it continues searching for additional {@code @ExceptionHandler}\n\t * methods assuming some {@linkplain ControllerAdvice @ControllerAdvice}\n\t * Spring-managed beans were detected.\n\t * @param handlerMethod the method where the exception was raised (may be {@code null})\n\t * @param exception the raised exception\n\t * @return a method to handle the exception, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handlerMethod",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 477
    },
    "return": "ServletInvocableHandlerMethod",
    "signature": "protected ServletInvocableHandlerMethod getExceptionHandlerMethod(@Nullable HandlerMethod handlerMethod, Exception exception)",
    "source_code": "\tprotected ServletInvocableHandlerMethod getExceptionHandlerMethod("
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#getExceptionHandlerMethod(handlerMethod,exception,webRequest)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find an {@code @ExceptionHandler} method for the given exception. The default\n\t * implementation searches methods in the class hierarchy of the controller first\n\t * and if not found, it continues searching for additional {@code @ExceptionHandler}\n\t * methods assuming some {@linkplain ControllerAdvice @ControllerAdvice}\n\t * Spring-managed beans were detected.\n\t * @param handlerMethod the method where the exception was raised (may be {@code null})\n\t * @param exception the raised exception\n\t * @param webRequest the original web request that resulted in a handler error\n\t * @return a method to handle the exception, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handlerMethod",
      "exception",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 511
    },
    "return": "ServletInvocableHandlerMethod",
    "signature": "protected ServletInvocableHandlerMethod getExceptionHandlerMethod(@Nullable HandlerMethod handlerMethod, Exception exception, ServletWebRequest webRequest)",
    "source_code": "\tprotected ServletInvocableHandlerMethod getExceptionHandlerMethod("
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#setErrorResponseInterceptors(interceptors)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a list of {@link ErrorResponse.Interceptor}'s to apply when\n\t * rendering an RFC 7807 {@link org.springframework.http.ProblemDetail}\n\t * error response.\n\t * @param interceptors the handlers to use\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "interceptors"
    ],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "void",
    "signature": "public void setErrorResponseInterceptors(List<ErrorResponse.Interceptor> interceptors)",
    "source_code": "\tpublic void setErrorResponseInterceptors(List<ErrorResponse.Interceptor> interceptors) {\n\t\tthis.errorResponseInterceptors.clear();\n\t\tthis.errorResponseInterceptors.addAll(interceptors);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExtendedServletRequestDataBinder": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Subclass of {@link ServletRequestDataBinder} that adds URI template variables\n * to the values used for data binding.\n *\n * <p><strong>WARNING</strong>: Data binding can lead to security issues by exposing\n * parts of the object graph that are not meant to be accessed or modified by\n * external clients. Therefore the design and use of data binding should be considered\n * carefully with regard to security. For more details, please refer to the dedicated\n * sections on data binding for\n * <a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-initbinder-model-design\">Spring Web MVC</a> and\n * <a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-initbinder-model-design\">Spring WebFlux</a>\n * in the reference manual.\n *\n * @author Rossen Stoyanchev\n * @since 3.1\n * @see ServletRequestDataBinder\n * @see HandlerMapping#URI_TEMPLATE_VARIABLES_ATTRIBUTE\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "signature": "public class ExtendedServletRequestDataBinder",
    "source_code": "public class ExtendedServletRequestDataBinder extends ServletRequestDataBinder {\n\n\t/**\n\t * Create a new instance, with default object name.\n\t * @param target the target object to bind onto (or {@code null}\n\t * if the binder is just used to convert a plain parameter value)\n\t * @see #DEFAULT_OBJECT_NAME\n\t */\n\tpublic ExtendedServletRequestDataBinder(@Nullable Object target) {\n\t\tsuper(target);\n\t}\n\n\t/**\n\t * Create a new instance.\n\t * @param target the target object to bind onto (or {@code null}\n\t * if the binder is just used to convert a plain parameter value)\n\t * @param objectName the name of the target object\n\t * @see #DEFAULT_OBJECT_NAME\n\t */\n\tpublic ExtendedServletRequestDataBinder(@Nullable Object target, String objectName) {\n\t\tsuper(target, objectName);\n\t}\n\n\n\t@Override\n\tprotected ServletRequestValueResolver createValueResolver(ServletRequest request) {\n\t\treturn new ExtendedServletRequestValueResolver(request, this);\n\t}\n\n\t/**\n\t * Merge URI variables into the property values to use for data binding.\n\t */\n\t@Override\n\tprotected void addBindValues(MutablePropertyValues mpvs, ServletRequest request) {\n\t\tMap<String, String> uriVars = getUriVars(request);\n\t\tif (uriVars != null) {\n\t\t\turiVars.forEach((name, value) -> addValueIfNotPresent(mpvs, \"URI variable\", name, value));\n\t\t}\n\t\tif (request instanceof HttpServletRequest httpRequest) {\n\t\t\tEnumeration<String> names = httpRequest.getHeaderNames();\n\t\t\twhile (names.hasMoreElements()) {\n\t\t\t\tString name = names.nextElement();\n\t\t\t\tObject value = getHeaderValue(httpRequest, name);\n\t\t\t\tif (value != null) {\n\t\t\t\t\tname = name.replace(\"-\", \"\");\n\t\t\t\t\taddValueIfNotPresent(mpvs, \"Header\", name, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Nullable\n\tprivate static Map<String, String> getUriVars(ServletRequest request) {\n\t\treturn (Map<String, String>) request.getAttribute(HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE);\n\t}\n\n\tprivate static void addValueIfNotPresent(MutablePropertyValues mpvs, String label, String name, Object value) {\n\t\tif (mpvs.contains(name)) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(label + \" '\" + name + \"' overridden by request bind value.\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tmpvs.addPropertyValue(name, value);\n\t\t}\n\t}\n\n\t@Nullable\n\tprivate static Object getHeaderValue(HttpServletRequest request, String name) {\n\t\tEnumeration<String> valuesEnum = request.getHeaders(name);\n\t\tif (!valuesEnum.hasMoreElements()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString value = valuesEnum.nextElement();\n\t\tif (!valuesEnum.hasMoreElements()) {\n\t\t\treturn value;\n\t\t}\n\n\t\tList<Object> values = new ArrayList<>();\n\t\tvalues.add(value);\n\t\twhile (valuesEnum.hasMoreElements()) {\n\t\t\tvalues.add(valuesEnum.nextElement());\n\t\t}\n\t\treturn values;\n\t}\n\n\n\t/**\n\t * Resolver of values that looks up URI path variables.\n\t */\n\tprivate static class ExtendedServletRequestValueResolver extends ServletRequestValueResolver {\n\n\t\tExtendedServletRequestValueResolver(ServletRequest request, WebDataBinder dataBinder) {\n\t\t\tsuper(request, dataBinder);\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tprotected Object getRequestParameter(String name, Class<?> type) {\n\t\t\tObject value = super.getRequestParameter(name, type);\n\t\t\tif (value == null) {\n\t\t\t\tMap<String, String> uriVars = getUriVars(getRequest());\n\t\t\t\tif (uriVars != null) {\n\t\t\t\t\tvalue = uriVars.get(name);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Set<String> initParameterNames(ServletRequest request) {\n\t\t\tSet<String> set = super.initParameterNames(request);\n\t\t\tMap<String, String> uriVars = getUriVars(getRequest());\n\t\t\tif (uriVars != null) {\n\t\t\t\tset.addAll(uriVars.keySet());\n\t\t\t}\n\t\t\treturn set;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExtendedServletRequestDataBinder#addBindValues(mpvs,request)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Merge URI variables into the property values to use for data binding.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mpvs",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "void",
    "signature": "protected void addBindValues(MutablePropertyValues mpvs, ServletRequest request)",
    "source_code": "\tprotected void addBindValues(MutablePropertyValues mpvs, ServletRequest request) {\n\t\tMap<String, String> uriVars = getUriVars(request);\n\t\tif (uriVars != null) {\n\t\t\turiVars.forEach((name, value) -> addValueIfNotPresent(mpvs, \"URI variable\", name, value));\n\t\t}\n\t\tif (request instanceof HttpServletRequest httpRequest) {\n\t\t\tEnumeration<String> names = httpRequest.getHeaderNames();\n\t\t\twhile (names.hasMoreElements()) {\n\t\t\t\tString name = names.nextElement();\n\t\t\t\tObject value = getHeaderValue(httpRequest, name);\n\t\t\t\tif (value != null) {\n\t\t\t\t\tname = name.replace(\"-\", \"\");\n\t\t\t\t\taddValueIfNotPresent(mpvs, \"Header\", name, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExtendedServletRequestDataBinder#createValueResolver(request)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "ServletRequestValueResolver",
    "signature": "protected ServletRequestValueResolver createValueResolver(ServletRequest request)",
    "source_code": "\tprotected ServletRequestValueResolver createValueResolver(ServletRequest request) {\n\t\treturn new ExtendedServletRequestValueResolver(request, this);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExtendedServletRequestDataBinder#getRequestParameter(name,type)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "Object",
    "signature": "protected Object getRequestParameter(String name, Class<?> type)",
    "source_code": "\t\tprotected Object getRequestParameter(String name, Class<?> type) {\n\t\t\tObject value = super.getRequestParameter(name, type);\n\t\t\tif (value == null) {\n\t\t\t\tMap<String, String> uriVars = getUriVars(getRequest());\n\t\t\t\tif (uriVars != null) {\n\t\t\t\t\tvalue = uriVars.get(name);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExtendedServletRequestDataBinder#initParameterNames(request)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "Set<String>",
    "signature": "protected Set<String> initParameterNames(ServletRequest request)",
    "source_code": "\t\tprotected Set<String> initParameterNames(ServletRequest request) {\n\t\t\tSet<String> set = super.initParameterNames(request);\n\t\t\tMap<String, String> uriVars = getUriVars(getRequest());\n\t\t\tif (uriVars != null) {\n\t\t\t\tset.addAll(uriVars.keySet());\n\t\t\t}\n\t\t\treturn set;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#setErrorResponseInterceptors(interceptors)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a list of {@link ErrorResponse.Interceptor}'s to apply when\n\t * rendering an RFC 7807 {@link org.springframework.http.ProblemDetail}\n\t * error response.\n\t * @param interceptors the interceptors to use\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "interceptors"
    ],
    "position": {
      "column": 1,
      "line": 408
    },
    "return": "void",
    "signature": "public void setErrorResponseInterceptors(List<ErrorResponse.Interceptor> interceptors)",
    "source_code": "\tpublic void setErrorResponseInterceptors(List<ErrorResponse.Interceptor> interceptors) {\n\t\tthis.errorResponseInterceptors.clear();\n\t\tthis.errorResponseInterceptors.addAll(interceptors);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler#handleBindException(ex,headers,status,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link BindException}.\n\t * <p>By default this method creates a {@link ProblemDetail} with the status\n\t * and a short detail message, and then delegates to\n\t * {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @deprecated as of 6.0 since {@link org.springframework.web.method.annotation.ModelAttributeMethodProcessor}\n\t * now raises the {@link MethodArgumentNotValidException} subclass instead.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 568
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleBindException(BindException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleBindException("
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#handleBindException(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where an {@linkplain ModelAttribute @ModelAttribute} method\n\t * argument has binding or validation errors and is not followed by another\n\t * method argument of type {@link BindingResult}.\n\t * <p>By default, an HTTP 400 error is sent back to the client.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @deprecated as of 6.0 since {@link org.springframework.web.method.annotation.ModelAttributeMethodProcessor}\n\t * now raises the {@link MethodArgumentNotValidException} subclass instead.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 683
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleBindException(BindException ex, HttpServletRequest request,\n\t\t\tHttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleBindException(BindException ex, HttpServletRequest request,"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#getOutboundMessageSizeLimit()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the configured outbound message buffer size in bytes.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "Integer",
    "signature": "public Integer getOutboundMessageSizeLimit()",
    "source_code": "\tpublic Integer getOutboundMessageSizeLimit() {\n\t\treturn this.outboundMessageSizeLimit;\n\t}"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#hasSplittingEncoder()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 631
    },
    "return": "boolean",
    "signature": "public boolean hasSplittingEncoder()",
    "source_code": "\t\tpublic boolean hasSplittingEncoder() {\n\t\t\treturn (this.splittingEncoder != null);\n\t\t}"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#setOutboundMessageSizeLimit(outboundMessageSizeLimit)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the maximum size allowed for outbound STOMP message.\n\t * If STOMP message's size exceeds {@link WebSocketStompClient#outboundMessageSizeLimit},\n\t * STOMP message is split into multiple frames.\n\t * <p>By default this is not set in which case each STOMP message are not split.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outboundMessageSizeLimit"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "void",
    "signature": "public void setOutboundMessageSizeLimit(Integer outboundMessageSizeLimit)",
    "source_code": "\tpublic void setOutboundMessageSizeLimit(Integer outboundMessageSizeLimit) {\n\t\tthis.outboundMessageSizeLimit = outboundMessageSizeLimit;\n\t}"
  },
  "org.springframework.web.util.<unknown>#address()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 2218
    },
    "return": "IpAddress",
    "signature": "public IpAddress address()",
    "source_code": "\t\tpublic IpAddress address() {\n\t\t\treturn this.address;\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#append(codePoint)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "codePoint"
    ],
    "position": {
      "column": 1,
      "line": 2984
    },
    "return": "void",
    "signature": "public void append(int codePoint)",
    "source_code": "\t\tpublic void append(int codePoint) {\n\t\t\tthis.segments.add(new PathSegment(codePoint));\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#append(s)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "s"
    ],
    "position": {
      "column": 1,
      "line": 2901
    },
    "return": "void",
    "signature": "public void append(String s)",
    "source_code": "\t\tpublic void append(String s) {\n\t\t\tthis.segment = null;\n\t\t\tif (this.builder == null) {\n\t\t\t\tthis.builder = new StringBuilder(s);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.builder.append(s);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#append(segment)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "segment"
    ],
    "position": {
      "column": 1,
      "line": 2989
    },
    "return": "void",
    "signature": "public void append(String segment)",
    "source_code": "\t\tpublic void append(String segment) {\n\t\t\tthis.segments.add(new PathSegment(segment));\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#appendToUsername(s)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "s"
    ],
    "position": {
      "column": 1,
      "line": 1809
    },
    "return": "void",
    "signature": "public void appendToUsername(String s)",
    "source_code": "\t\tpublic void appendToUsername(String s) {\n\t\t\tif (this.username == null) {\n\t\t\t\tthis.username = new StringBuilder(s);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.username.append(s);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#clone()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 3025
    },
    "return": "Path",
    "signature": "public Path clone()",
    "source_code": "\t\tpublic Path clone() {\n\t\t\treturn new PathSegments(this.segments);\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#copyToUriComponentsBuilder(builder)": {
    "change": "modifier_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "builder"
    ],
    "position": {
      "column": 1,
      "line": 1063
    },
    "return": "void",
    "signature": "public void copyToUriComponentsBuilder(UriComponentsBuilder builder)",
    "source_code": "\t\tpublic void copyToUriComponentsBuilder(UriComponentsBuilder builder) {\n\t\t\tfor (PathComponent pathComponent : this.pathComponents) {\n\t\t\t\tpathComponent.copyToUriComponentsBuilder(builder);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#domain()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 2173
    },
    "return": "String",
    "signature": "public String domain()",
    "source_code": "\t\tpublic String domain() {\n\t\t\treturn this.domain;\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#encode(charset)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 283
    },
    "return": "HierarchicalUriComponents",
    "signature": "public HierarchicalUriComponents encode(Charset charset)",
    "source_code": "\tpublic HierarchicalUriComponents encode(Charset charset) {\n\t\tif (this.encodeState.isEncoded()) {\n\t\t\treturn this;\n\t\t}\n\t\tString scheme = getScheme();\n\t\tString fragment = getFragment();\n\t\tString schemeTo = (scheme != null ? encodeUriComponent(scheme, charset, Type.SCHEME) : null);\n\t\tString fragmentTo = (fragment != null ? encodeUriComponent(fragment, charset, Type.FRAGMENT) : null);\n\t\tString userInfoTo = (this.userInfo != null ? encodeUriComponent(this.userInfo, charset, Type.USER_INFO) : null);\n\t\tString hostTo = (this.host != null ? encodeUriComponent(this.host, charset, getHostType()) : null);\n\t\tBiFunction<String, Type, String> encoder = (s, type) -> encodeUriComponent(s, charset, type);\n\t\tPathComponent pathTo = this.path.encode(encoder);\n\t\tMultiValueMap<String, String> queryParamsTo = encodeQueryParams(encoder);\n\n\t\treturn new HierarchicalUriComponents(schemeTo, fragmentTo, userInfoTo,\n\t\t\t\thostTo, this.port, pathTo, queryParamsTo, EncodeState.FULLY_ENCODED, null);\n\t}"
  },
  "org.springframework.web.util.<unknown>#equals(o)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o"
    ],
    "position": {
      "column": 1,
      "line": 3040
    },
    "return": "boolean",
    "signature": "public boolean equals(Object o)",
    "source_code": "\t\tpublic boolean equals(Object o) {\n\t\t\tif (o == this) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (o instanceof PathSegments other) {\n\t\t\t\treturn this.segments.equals(other.segments);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#equals(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 2784
    },
    "return": "boolean",
    "signature": "public boolean equals(Object obj)",
    "source_code": "\t\tpublic boolean equals(Object obj) {\n\t\t\tif (obj == this) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (obj instanceof Ipv6Address other) {\n\t\t\t\treturn Arrays.equals(this.pieces, other.pieces);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#expandInternal(uriVariables)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 431
    },
    "return": "HierarchicalUriComponents",
    "signature": "protected HierarchicalUriComponents expandInternal(UriTemplateVariables uriVariables)",
    "source_code": "\tprotected HierarchicalUriComponents expandInternal(UriTemplateVariables uriVariables) {\n\t\tAssert.state(!this.encodeState.equals(EncodeState.FULLY_ENCODED),\n\t\t\t\t\"URI components already encoded, and could not possibly contain '{' or '}'.\");\n\n\t\t// Array-based vars rely on the order below...\n\t\tString schemeTo = expandUriComponent(getScheme(), uriVariables, this.variableEncoder);\n\t\tString userInfoTo = expandUriComponent(this.userInfo, uriVariables, this.variableEncoder);\n\t\tString hostTo = expandUriComponent(this.host, uriVariables, this.variableEncoder);\n\t\tString portTo = expandUriComponent(this.port, uriVariables, this.variableEncoder);\n\t\tPathComponent pathTo = this.path.expand(uriVariables, this.variableEncoder);\n\t\tMultiValueMap<String, String> queryParamsTo = expandQueryParams(uriVariables);\n\t\tString fragmentTo = expandUriComponent(getFragment(), uriVariables, this.variableEncoder);\n\n\t\treturn new HierarchicalUriComponents(schemeTo, fragmentTo, userInfoTo,\n\t\t\t\thostTo, portTo, pathTo, queryParamsTo, this.encodeState, this.variableEncoder);\n\t}"
  },
  "org.springframework.web.util.<unknown>#fragment()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * A URL\u2019s fragment is either {@code null}  or an ASCII string that can be used for further processing on the\n\t\t * resource the URL\u2019s other components identify. It is initially {@code null}.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1960
    },
    "return": "String",
    "signature": "public String fragment()",
    "source_code": "\t\tpublic String fragment() {\n\t\t\tif (this.fragment == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn this.fragment.toString();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#get(i)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "i"
    ],
    "position": {
      "column": 1,
      "line": 2997
    },
    "return": "String",
    "signature": "public String get(int i)",
    "source_code": "\t\tpublic String get(int i) {\n\t\t\treturn this.segments.get(i).segment();\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#handle(c,url,p)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "c",
      "url",
      "p"
    ],
    "position": {
      "column": 1,
      "line": 1686
    },
    "return": "void",
    "signature": "public void handle(int c, UrlRecord url, UrlParser p)",
    "source_code": "\t\tpublic abstract void handle(int c, UrlRecord url, UrlParser p);"
  },
  "org.springframework.web.util.<unknown>#hasOpaquePath()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * A URL has an opaque path if its path is a URL path segment.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1743
    },
    "return": "boolean",
    "signature": "public boolean hasOpaquePath()",
    "source_code": "\t\tpublic boolean hasOpaquePath() {\n\t\t\treturn path().isOpaque();\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#hash()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * The hash getter steps are:\n\t\t * If this\u2019s URL\u2019s fragment is either null or the empty string, then return the empty string.\n\t\t * Return U+0023 (#), followed by this\u2019s URL\u2019s fragment.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1974
    },
    "return": "String",
    "signature": "public String hash()",
    "source_code": "\t\tpublic String hash() {\n\t\t\tString fragment = fragment();\n\t\t\tif (fragment == null || fragment.isEmpty()) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn \"#\" + fragment;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#host()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * A URL\u2019s host is {@code null} or a {@linkplain Host host}. It is initially {@code null}.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1850
    },
    "return": "Host",
    "signature": "public Host host()",
    "source_code": "\t\tpublic Host host() {\n\t\t\treturn this.host;\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#hostString()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t *The host getter steps are:\n\t\t * Let url be this\u2019s URL.\n\t\t * If url\u2019s host is null, then return the empty string.\n\t\t * If url\u2019s port is null, return url\u2019s host, serialized.\n\t\t * Return url\u2019s host, serialized, followed by U+003A (:) and url\u2019s port, serialized.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1861
    },
    "return": "String",
    "signature": "public String hostString()",
    "source_code": "\t\tpublic String hostString() {\n\t\t\tif (host() == null) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t\tStringBuilder builder = new StringBuilder(hostname());\n\t\t\tPort port = port();\n\t\t\tif (port != null) {\n\t\t\t\tbuilder.append(':');\n\t\t\t\tbuilder.append(port);\n\t\t\t}\n\t\t\treturn builder.toString();\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#hostname()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1874
    },
    "return": "String",
    "signature": "public String hostname()",
    "source_code": "\t\tpublic String hostname() {\n\t\t\tHost host = host();\n\t\t\tif (host == null) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn host.toString();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#href()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1984
    },
    "return": "String",
    "signature": "public String href()",
    "source_code": "\t\tpublic String href() {\n\t\t\t// Let output be url\u2019s scheme and U+003A (:) concatenated.\n\t\t\tStringBuilder output = new StringBuilder(scheme());\n\t\t\toutput.append(':');\n\t\t\tHost host = host();\n\t\t\t// If url\u2019s host is non-null:\n\t\t\tif (host != null) {\n\t\t\t\t// Append \"//\" to output.\n\t\t\t\toutput.append(\"//\");\n\t\t\t\t// If url includes credentials, then:\n\t\t\t\tif (includesCredentials()) {\n\t\t\t\t\t// Append url\u2019s username to output.\n\t\t\t\t\toutput.append(username());\n\t\t\t\t\tString password = password();\n\t\t\t\t\t// If url\u2019s password is not the empty string, then append U+003A (:), followed by url\u2019s password, to output.\n\t\t\t\t\tif (!password.isEmpty()) {\n\t\t\t\t\t\toutput.append(':');\n\t\t\t\t\t\toutput.append(password);\n\t\t\t\t\t}\n\t\t\t\t\t// Append U+0040 (@) to output.\n\t\t\t\t\toutput.append('@');\n\t\t\t\t}\n\t\t\t\t// Append url\u2019s host, serialized, to output.\n\t\t\t\toutput.append(hostname());\n\t\t\t\tPort port = port();\n\t\t\t\t// If url\u2019s port is non-null, append U+003A (:) followed by url\u2019s port, serialized, to output.\n\t\t\t\tif (port != null) {\n\t\t\t\t\toutput.append(':');\n\t\t\t\t\toutput.append(port());\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If url\u2019s host is null, url does not have an opaque path, url\u2019s path\u2019s size is greater than 1, and url\u2019s path[0] is the empty string, then append U+002F (/) followed by U+002E (.) to output.\n\t\t\telse if (!hasOpaquePath() &&\n\t\t\t\t\tpath() instanceof PathSegments pathSegments &&\n\t\t\t\t\tpathSegments.size() > 1 &&\n\t\t\t\t\tpathSegments.get(0).isEmpty()) {\n\t\t\t\toutput.append(\"/.\");\n\t\t\t}\n\t\t\t// Append the result of URL path serializing url to output.\n\t\t\toutput.append(pathname());\n\t\t\t// If url\u2019s query is non-null, append U+003F (?), followed by url\u2019s query, to output.\n\t\t\tString query = query();\n\t\t\tif (query != null) {\n\t\t\t\toutput.append('?');\n\t\t\t\toutput.append(query);\n\t\t\t}\n\t\t\t// If exclude fragment is false and url\u2019s fragment is non-null, then append U+0023 (#), followed by url\u2019s fragment, to output.\n\t\t\tString fragment = fragment();\n\t\t\tif (fragment != null) {\n\t\t\t\toutput.append('#');\n\t\t\t\toutput.append(fragment);\n\t\t\t}\n\t\t\t// Return output.\n\t\t\treturn output.toString();\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#includesCredentials()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * A URL includes credentials if its username or password is not the empty string.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1736
    },
    "return": "boolean",
    "signature": "public boolean includesCredentials()",
    "source_code": "\t\tpublic boolean includesCredentials() {\n\t\t\treturn this.username != null && !this.username.isEmpty() || this.password != null && !this.password.isEmpty();\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#isEmpty()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 3002
    },
    "return": "boolean",
    "signature": "public boolean isEmpty()",
    "source_code": "\t\tpublic boolean isEmpty() {\n\t\t\treturn this.segments.isEmpty();\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#isOpaque()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 3020
    },
    "return": "boolean",
    "signature": "public boolean isOpaque()",
    "source_code": "\t\tpublic boolean isOpaque() {\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#isSpecial()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * A URL is special if its scheme is a special scheme. A URL is not special if its scheme is not a special scheme.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1728
    },
    "return": "boolean",
    "signature": "public boolean isSpecial()",
    "source_code": "\t\tpublic boolean isSpecial() {\n\t\t\treturn isSpecialScheme(this.scheme);\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#name()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 3030
    },
    "return": "String",
    "signature": "public String name()",
    "source_code": "\t\tpublic String name() {\n\t\t\tStringBuilder output = new StringBuilder();\n\t\t\tfor (PathSegment segment : this.segments) {\n\t\t\t\toutput.append('/');\n\t\t\t\toutput.append(segment.name());\n\t\t\t}\n\t\t\treturn output.toString();\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#origin()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * The serialization of an origin is the string obtained by applying the following algorithm to the given origin origin:\n\t\t * If origin is an opaque origin, then return \"null\".\n\t\t * Otherwise, let result be origin's scheme.\n\t\t * Append \"://\" to result.\n\t\t * Append origin's host, serialized, to result.\n\t\t * If origin's port is non-null, append a U+003A COLON character (:), and origin's port, serialized, to result.\n\t\t * Return result.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1757
    },
    "return": "String",
    "signature": "public String origin()",
    "source_code": "\t\tpublic String origin() {\n\t\t\tString scheme = scheme();\n\t\t\tif (scheme.equals(\"ftp\") || scheme.equals(\"http\") || scheme.equals(\"https\") || scheme.equals(\"ws\") || scheme.equals(\"wss\")) {\n\t\t\t\tStringBuilder builder = new StringBuilder(scheme);\n\t\t\t\tbuilder.append(\"://\");\n\t\t\t\tbuilder.append(host());\n\t\t\t\tPort port = port();\n\t\t\t\tif (port != null) {\n\t\t\t\t\tbuilder.append(':');\n\t\t\t\t\tbuilder.append(port);\n\t\t\t\t}\n\t\t\t\treturn builder.toString();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn \"null\";\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#parse(input)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * The IPv6 parser takes a scalar value string input and then runs these steps. They return failure or an IPv6 address.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "input"
    ],
    "position": {
      "column": 1,
      "line": 2540
    },
    "return": "Ipv6Address",
    "signature": "public Ipv6Address parse(String input)",
    "source_code": "\t\tpublic static Ipv6Address parse(String input) {\n\t\t\t// Let address be a new IPv6 address whose IPv6 pieces are all 0.\n\t\t\tint[] address = new int[8];\n\t\t\t// Let pieceIndex be 0.\n\t\t\tint pieceIndex = 0;\n\t\t\t// Let compress be null.\n\t\t\tInteger compress = null;\n\t\t\t// Let pointer be a pointer for input.\n\t\t\tint pointer = 0;\n\t\t\tint inputLength = input.length();\n\t\t\tint c = (inputLength > 0) ? input.codePointAt(0) : EOF;\n\t\t\t// If c is U+003A (:), then:\n\t\t\tif (c == ':') {\n\t\t\t\t// If remaining does not start with U+003A (:), IPv6-invalid-compression validation error, return failure.\n\t\t\t\tif (inputLength > 1 && input.codePointAt(1) != ':') {\n\t\t\t\t\tthrow new InvalidUrlException(\"IPv6 address begins with improper compression.\");\n\t\t\t\t}\n\t\t\t\t// Increase pointer by 2.\n\t\t\t\tpointer += 2;\n\t\t\t\t// Increase pieceIndex by 1 and then set compress to pieceIndex.\n\t\t\t\tpieceIndex++;\n\t\t\t\tcompress = pieceIndex;\n\t\t\t}\n\t\t\tc = (pointer < inputLength) ? input.codePointAt(pointer) : EOF;\n\t\t\t// While c is not the EOF code point:\n\t\t\twhile (c != EOF) {\n\t\t\t\t// If pieceIndex is 8, IPv6-too-many-pieces validation error, return failure.\n\t\t\t\tif (pieceIndex == 8) {\n\t\t\t\t\tthrow new InvalidUrlException(\"IPv6 address contains more than 8 pieces.\");\n\t\t\t\t}\n\t\t\t\t// If c is U+003A (:), then:\n\t\t\t\tif (c == ':') {\n\t\t\t\t\t// If compress is non-null, IPv6-multiple-compression validation error, return failure.\n\t\t\t\t\tif (compress != null) {\n\t\t\t\t\t\tthrow new InvalidUrlException(\"IPv6 address is compressed in more than one spot.\");\n\t\t\t\t\t}\n\t\t\t\t\t// Increase pointer and pieceIndex by 1, set compress to pieceIndex, and then continue.\n\t\t\t\t\tpointer++;\n\t\t\t\t\tpieceIndex++;\n\t\t\t\t\tcompress = pieceIndex;\n\t\t\t\t\tc = (pointer < inputLength) ? input.codePointAt(pointer) : EOF;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// Let value and length be 0.\n\t\t\t\tint value = 0;\n\t\t\t\tint length = 0;\n\t\t\t\t// While length is less than 4 and c is an ASCII hex digit, set value to value \u00d7 0x10 + c interpreted as hexadecimal number, and increase pointer and length by 1.\n\t\t\t\twhile (length < 4 && isAsciiHexDigit(c)) {\n\t\t\t\t\tint cHex = Character.digit(c, 16);\n\t\t\t\t\tvalue = (value * 0x10) + cHex;\n\t\t\t\t\tpointer++;\n\t\t\t\t\tlength++;\n\t\t\t\t\tc = (pointer < inputLength) ? input.codePointAt(pointer) : EOF;\n\t\t\t\t}\n\t\t\t\t// If c is U+002E (.), then:\n\t\t\t\tif (c == '.') {\n\t\t\t\t\t// If length is 0, IPv4-in-IPv6-invalid-code-point validation error, return failure.\n\t\t\t\t\tif (length == 0) {\n\t\t\t\t\t\tthrow new InvalidUrlException(\"IPv6 address with IPv4 address syntax: IPv4 part is empty.\");\n\t\t\t\t\t}\n\t\t\t\t\t// Decrease pointer by length.\n\t\t\t\t\tpointer -= length;\n\t\t\t\t\t// If pieceIndex is greater than 6, IPv4-in-IPv6-too-many-pieces validation error, return failure.\n\t\t\t\t\tif (pieceIndex > 6) {\n\t\t\t\t\t\tthrow new InvalidUrlException(\"IPv6 address with IPv4 address syntax: IPv6 address has more than 6 pieces.\");\n\t\t\t\t\t}\n\t\t\t\t\t// Let numbersSeen be 0.\n\t\t\t\t\tint numbersSeen = 0;\n\t\t\t\t\tc = (pointer < inputLength) ? input.codePointAt(pointer) : EOF;\n\t\t\t\t\t// While c is not the EOF code point:\n\t\t\t\t\twhile (c != EOF) {\n\t\t\t\t\t\t// Let ipv4Piece be null.\n\t\t\t\t\t\tInteger ipv4Piece = null;\n\t\t\t\t\t\t// If numbersSeen is greater than 0, then:\n\t\t\t\t\t\tif (numbersSeen > 0) {\n\t\t\t\t\t\t\t// If c is a U+002E (.) and numbersSeen is less than 4, then increase pointer by 1.\n\t\t\t\t\t\t\tif (c =='.' && numbersSeen < 4) {\n\t\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t\t\tc = (pointer < inputLength) ? input.codePointAt(pointer) : EOF;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Otherwise, IPv4-in-IPv6-invalid-code-point validation error, return failure.\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tthrow new InvalidUrlException(\"IPv6 address with IPv4 address syntax: \" +\n\t\t\t\t\t\t\t\t\t\t\"IPv4 part is empty or contains a non-ASCII digit.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// If c is not an ASCII digit, IPv4-in-IPv6-invalid-code-point validation error, return failure.\n\t\t\t\t\t\tif (!isAsciiDigit(c)) {\n\t\t\t\t\t\t\tthrow new InvalidUrlException(\"IPv6 address with IPv4 address syntax: IPv4 part contains a non-ASCII digit.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// While c is an ASCII digit:\n\t\t\t\t\t\twhile (isAsciiDigit(c)) {\n\t\t\t\t\t\t\t// Let number be c interpreted as decimal number.\n\t\t\t\t\t\t\tint number = Character.digit(c, 10);\n\t\t\t\t\t\t\t// If ipv4Piece is null, then set ipv4Piece to number.\n\t\t\t\t\t\t\tif (ipv4Piece == null) {\n\t\t\t\t\t\t\t\tipv4Piece = number;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Otherwise, if ipv4Piece is 0, IPv4-in-IPv6-invalid-code-point validation error, return failure.\n\t\t\t\t\t\t\telse if (ipv4Piece == 0) {\n\t\t\t\t\t\t\t\tthrow new InvalidUrlException(\"IPv6 address with IPv4 address syntax: IPv4 part contains a non-ASCII digit.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Otherwise, set ipv4Piece to ipv4Piece \u00d7 10 + number.\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tipv4Piece = ipv4Piece * 10 + number;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// If ipv4Piece is greater than 255, IPv4-in-IPv6-out-of-range-part validation error, return failure.\n\t\t\t\t\t\t\tif (ipv4Piece > 255) {\n\t\t\t\t\t\t\t\tthrow new InvalidUrlException(\"IPv6 address with IPv4 address syntax: IPv4 part exceeds 255.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Increase pointer by 1.\n\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t\tc = (pointer < inputLength) ? input.codePointAt(pointer) : EOF;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Set address[pieceIndex] to address[pieceIndex] \u00d7 0x100 + ipv4Piece.\n\t\t\t\t\t\taddress[pieceIndex] = address[pieceIndex] * 0x100 + (ipv4Piece != null ? ipv4Piece : 0);\n\t\t\t\t\t\t// Increase numbersSeen by 1.\n\t\t\t\t\t\tnumbersSeen++;\n\t\t\t\t\t\t// If numbersSeen is 2 or 4, then increase pieceIndex by 1.\n\t\t\t\t\t\tif (numbersSeen == 2 || numbersSeen == 4) {\n\t\t\t\t\t\t\tpieceIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc = (pointer < inputLength) ? input.codePointAt(pointer) : EOF;\n\t\t\t\t\t}\n\t\t\t\t\t// If numbersSeen is not 4, IPv4-in-IPv6-too-few-parts validation error, return failure.\n\t\t\t\t\tif (numbersSeen != 4) {\n\t\t\t\t\t\tthrow new InvalidUrlException(\"IPv6 address with IPv4 address syntax: IPv4 address contains too few parts.\");\n\t\t\t\t\t}\n\t\t\t\t\t// Break.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// Otherwise, if c is U+003A (:):\n\t\t\t\telse if (c == ':') {\n\t\t\t\t\t// Increase pointer by 1.\n\t\t\t\t\tpointer++;\n\t\t\t\t\tc = (pointer < inputLength) ? input.codePointAt(pointer) : EOF;\n\t\t\t\t\t// If c is the EOF code point, IPv6-invalid-code-point validation error, return failure.\n\t\t\t\t\tif (c == EOF) {\n\t\t\t\t\t\tthrow new InvalidUrlException(\"IPv6 address unexpectedly ends.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Otherwise, if c is not the EOF code point, IPv6-invalid-code-point validation error, return failure.\n\t\t\t\telse if (c != EOF) {\n\t\t\t\t\tthrow new InvalidUrlException(\"IPv6 address contains \\\"\" + Character.toString(c) + \"\\\", which is neither an ASCII hex digit nor a ':'.\");\n\t\t\t\t}\n\t\t\t\t// Set address[pieceIndex] to value.\n\t\t\t\taddress[pieceIndex] = value;\n\t\t\t\t// Increase pieceIndex by 1.\n\t\t\t\tpieceIndex++;\n\t\t\t}\n\t\t\t// If compress is non-null, then:\n\t\t\tif (compress != null) {\n\t\t\t\t// Let swaps be pieceIndex \u2212 compress.\n\t\t\t\tint swaps = pieceIndex - compress;\n\t\t\t\t// Set pieceIndex to 7.\n\t\t\t\tpieceIndex = 7;\n\t\t\t\t// While pieceIndex is not 0 and swaps is greater than 0, swap address[pieceIndex] with address[compress + swaps \u2212 1], and then decrease both pieceIndex and swaps by 1.\n\t\t\t\twhile (pieceIndex != 0 && swaps > 0) {\n\t\t\t\t\tint tmp = address[pieceIndex];\n\t\t\t\t\taddress[pieceIndex] = address[compress + swaps - 1];\n\t\t\t\t\taddress[compress + swaps - 1] = tmp;\n\t\t\t\t\tpieceIndex--;\n\t\t\t\t\tswaps--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Otherwise, if compress is null and pieceIndex is not 8, IPv6-too-few-pieces validation error, return failure.\n\t\t\telse if (compress == null && pieceIndex != 8) {\n\t\t\t\tthrow new InvalidUrlException(\"An uncompressed IPv6 address contains fewer than 8 pieces.\");\n\t\t\t}\n\t\t\t// Return address.\n\t\t\treturn new Ipv6Address(address);\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#parse(input,base,encoding,validationErrorHandler)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the given input into a URL record.\n\t * @param input the scalar value string\n\t * @param base the optional base URL to resolve relative URLs against. If\n\t * {@code null}, relative URLs cannot be parsed.\n\t * @param encoding the optional encoding to use. If {@code null}, no\n\t * encoding is performed.\n\t * @param validationErrorHandler optional consumer for non-fatal URL\n\t * validation messages\n\t * @return a URL record, as defined in the\n\t * <a href=\"https://url.spec.whatwg.org/#concept-url\">living URL\n\t * specification</a>\n\t * @throws InvalidUrlException if the {@code input} does not contain a\n\t * parsable URL\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "input",
      "base",
      "encoding",
      "validationErrorHandler"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "UrlRecord",
    "signature": "public UrlRecord parse(String input, @Nullable UrlRecord base,\n\t\t\t@Nullable Charset encoding, @Nullable Consumer<String> validationErrorHandler)",
    "source_code": "\tpublic static UrlRecord parse(String input, @Nullable UrlRecord base,"
  },
  "org.springframework.web.util.<unknown>#parse(input,p)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "input",
      "p"
    ],
    "position": {
      "column": 1,
      "line": 2366
    },
    "return": "Ipv4Address",
    "signature": "public Ipv4Address parse(String input, UrlParser p)",
    "source_code": "\t\tpublic static Ipv4Address parse(String input, UrlParser p) {\n\t\t\t// Let parts be the result of strictly splitting input on U+002E (.).\n\t\t\tList<String> parts = strictSplit(input, '.');\n\t\t\tint partsSize = parts.size();\n\t\t\t// If the last item in parts is the empty string, then:\n\t\t\tif (parts.get(partsSize - 1).isEmpty()) {\n\t\t\t\t// IPv4-empty-part validation error.\n\t\t\t\tp.validationError(\"IPv4 address ends with \\\".\\\"\");\n\t\t\t\t// If parts\u2019s size is greater than 1, then remove the last item from parts.\n\t\t\t\tif (partsSize > 1) {\n\t\t\t\t\tparts.remove(partsSize - 1);\n\t\t\t\t\tpartsSize--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If parts\u2019s size is greater than 4, IPv4-too-many-parts validation error, return failure.\n\t\t\tif (partsSize > 4) {\n\t\t\t\tthrow new InvalidUrlException(\"IPv4 address does not consist of exactly 4 parts.\");\n\t\t\t}\n\t\t\t// Let numbers be an empty list.\n\t\t\tList<Integer> numbers = new ArrayList<>(partsSize);\n\t\t\t// For each part of parts:\n\t\t\tfor (int i = 0; i < partsSize; i++) {\n\t\t\t\tString part = parts.get(i);\n\t\t\t\t// Let result be the result of parsing part.\n\t\t\t\tParseIpv4NumberResult result = parseIpv4Number(part);\n\t\t\t\t// If result is failure, IPv4-non-numeric-part validation error, return failure.\n\t\t\t\tif (result == ParseIpv4NumberFailure.INSTANCE) {\n\t\t\t\t\tp.failure(\"An IPv4 address part is not numeric.\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tParseIpv4NumberSuccess success = (ParseIpv4NumberSuccess) result;\n\t\t\t\t\tif (p.validate() && success.validationError()) {\n\t\t\t\t\t\tp.validationError(\"The IPv4 address contains numbers expressed using hexadecimal or octal digits.\");\n\t\t\t\t\t}\n\t\t\t\t\t// Append result to numbers.\n\t\t\t\t\tnumbers.add(success.number());\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (Iterator<Integer> iterator = numbers.iterator(); iterator.hasNext(); ) {\n\t\t\t\tInteger number = iterator.next();\n\t\t\t\t// If any item in numbers is greater than 255, IPv4-out-of-range-part validation error.\n\t\t\t\tif (p.validate() && number > 255) {\n\t\t\t\t\tp.validationError(\"An IPv4 address part exceeds 255.\");\n\t\t\t\t}\n\t\t\t\tif (iterator.hasNext()) {\n\t\t\t\t\t// If any but the last item in numbers is greater than 255, then return failure.\n\t\t\t\t\tif (number > 255) {\n\t\t\t\t\t\tthrow new InvalidUrlException(\"An IPv4 address part exceeds 255.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// If the last item in numbers is greater than or equal to 256^(5 \u2212 numbers\u2019s size), then return failure.\n\t\t\t\t\tdouble limit = Math.pow(256, (5 - numbers.size()));\n\t\t\t\t\tif (number >= limit) {\n\t\t\t\t\t\tthrow new InvalidUrlException(\"IPv4 address part \" + number + \" exceeds \" + limit + \".'\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Let ipv4 be the last item in numbers.\n\t\t\tint ipv4 = numbers.get(numbers.size() - 1);\n\t\t\t// Remove the last item from numbers.\n\t\t\tnumbers.remove(numbers.size() - 1);\n\t\t\t// Let counter be 0.\n\t\t\tint counter = 0;\n\t\t\t// For each n of numbers:\n\t\t\tfor (Integer n : numbers) {\n\t\t\t\t// Increment ipv4 by n \u00d7 256^(3 \u2212 counter).\n\t\t\t\tint increment = n * (int) Math.pow(256, 3 - counter);\n\t\t\t\tipv4 += increment;\n\t\t\t\t// Increment counter by 1.\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t\t// Return ipv4.\n\t\t\treturn new Ipv4Address(ipv4);\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#password()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * A URL\u2019s password is an ASCII string identifying a password. It is initially the empty string.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1821
    },
    "return": "String",
    "signature": "public String password()",
    "source_code": "\t\tpublic String password() {\n\t\t\tif (this.password != null) {\n\t\t\t\treturn this.password.toString();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#path()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * A URL\u2019s path is a URL {@linkplain Path path}, usually identifying a location. It is initially {@code \u00ab \u00bb}.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1905
    },
    "return": "Path",
    "signature": "public Path path()",
    "source_code": "\t\tpublic Path path() {\n\t\t\treturn this.path;\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#pathname()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1909
    },
    "return": "String",
    "signature": "public String pathname()",
    "source_code": "\t\tpublic String pathname() {\n\t\t\treturn path().name();\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#port()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * A URL\u2019s port is either null, a string representing a 16-bit unsigned integer  that identifies a networking\n\t\t * port, or a string containing a uri template . It is initially {@code null}.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1889
    },
    "return": "Port",
    "signature": "public Port port()",
    "source_code": "\t\tpublic Port port() {\n\t\t\treturn this.port;\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#portString()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1893
    },
    "return": "String",
    "signature": "public String portString()",
    "source_code": "\t\tpublic String portString() {\n\t\t\tif (port() == null) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn port().toString();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#protocol()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * The protocol getter steps are to return this\u2019s URL\u2019s scheme, followed by U+003A (:).\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1786
    },
    "return": "String",
    "signature": "public String protocol()",
    "source_code": "\t\tpublic String protocol() {\n\t\t\treturn scheme() + \":\";\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#query()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * A URL\u2019s query is either {@code null} or an ASCII string. It is initially {@code null}.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1931
    },
    "return": "String",
    "signature": "public String query()",
    "source_code": "\t\tpublic String query() {\n\t\t\tif (this.query == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn this.query.toString();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#scheme()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * A URL\u2019s scheme is an ASCII string that identifies the type of URL and can be used to dispatch a URL for\n\t\t * further processing after parsing. It is initially the empty string.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1779
    },
    "return": "String",
    "signature": "public String scheme()",
    "source_code": "\t\tpublic String scheme() {\n\t\t\treturn this.scheme;\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#search()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * The search getter steps are:\n\t\t * If this\u2019s URL\u2019s query is either null or the empty string, then return the empty string.\n\t\t * Return U+003F (?), followed by this\u2019s URL\u2019s query.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1945
    },
    "return": "String",
    "signature": "public String search()",
    "source_code": "\t\tpublic String search() {\n\t\t\tString query = query();\n\t\t\tif (query == null) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn \"?\" + query;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#segment()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 2881
    },
    "return": "String",
    "signature": "public String segment()",
    "source_code": "\t\tpublic String segment() {\n\t\t\tString result = this.segment;\n\t\t\tif (result == null) {\n\t\t\t\tAssert.state(this.builder != null, \"String nor StringBuilder available\");\n\t\t\t\tresult = this.builder.toString();\n\t\t\t\tthis.segment = result;\n\t\t\t}\n\t\t\treturn result;\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#shorten(scheme)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scheme"
    ],
    "position": {
      "column": 1,
      "line": 3007
    },
    "return": "void",
    "signature": "public void shorten(String scheme)",
    "source_code": "\t\tpublic void shorten(String scheme) {\n\t\t\tint size = size();\n\t\t\tif (\"file\".equals(scheme) &&\n\t\t\t\t\tsize == 1 &&\n\t\t\t\t\tisWindowsDriveLetter(get(0), true)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!isEmpty()) {\n\t\t\t\tthis.segments.remove(size - 1);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#shortenPath()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * To shorten a url\u2019s path:\n\t\t * <ol>\n\t \t * <li>Assert: url does not have an opaque path.</li>\n\t\t * <li>Let path be url\u2019s path.</li>\n\t\t * <li>If url\u2019s scheme is \"file\", path\u2019s size is 1, and path[0] is a\n\t\t * normalized Windows drive letter, then return.</li>\n\t\t * <li>Remove path\u2019s last item, if any.</li>\n\t\t * </ol>\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1923
    },
    "return": "void",
    "signature": "public void shortenPath()",
    "source_code": "\t\tpublic void shortenPath() {\n\t\t\tthis.path.shorten(this.scheme);\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#size()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 2993
    },
    "return": "int",
    "signature": "public int size()",
    "source_code": "\t\tpublic int size() {\n\t\t\treturn this.segments.size();\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#toString()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 3058
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\tStringBuilder output = new StringBuilder();\n\t\t\tfor (PathSegment segment : this.segments) {\n\t\t\t\toutput.append(segment);\n\t\t\t}\n\t\t\treturn output.toString();\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#username()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * A URL\u2019s username is an ASCII string identifying a username. It is initially the empty string.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1793
    },
    "return": "String",
    "signature": "public String username()",
    "source_code": "\t\tpublic String username() {\n\t\t\tif (this.username != null) {\n\t\t\t\treturn this.username.toString();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#value()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 2837
    },
    "return": "int",
    "signature": "public int value()",
    "source_code": "\t\tpublic int value() {\n\t\t\treturn this.port;\n\t\t}"
  },
  "org.springframework.web.util.INSTANCE": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 3076
    },
    "signature": "public ParseIpv4NumberFailure INSTANCE",
    "source_code": "\t\tpublic static final ParseIpv4NumberFailure INSTANCE = new ParseIpv4NumberFailure();",
    "type": "ParseIpv4NumberFailure"
  }
}