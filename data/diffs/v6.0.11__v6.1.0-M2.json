{
  "org.springframework.beans.AbstractNestablePropertyAccessor#getCollectionType(nestingLevel)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nestingLevel"
    ],
    "position": {
      "column": 1,
      "line": 1052
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getCollectionType(int nestingLevel)",
    "source_code": "\t\tpublic TypeDescriptor getCollectionType(int nestingLevel) {\n\t\t\treturn TypeDescriptor.valueOf(getResolvableType().getNested(nestingLevel).asCollection().resolveGeneric());\n\t\t}"
  },
  "org.springframework.beans.AbstractNestablePropertyAccessor#getMapKeyType(nestingLevel)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nestingLevel"
    ],
    "position": {
      "column": 1,
      "line": 1044
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getMapKeyType(int nestingLevel)",
    "source_code": "\t\tpublic TypeDescriptor getMapKeyType(int nestingLevel) {\n\t\t\treturn TypeDescriptor.valueOf(getResolvableType().getNested(nestingLevel).asMap().resolveGeneric(0));\n\t\t}"
  },
  "org.springframework.beans.AbstractNestablePropertyAccessor#getMapValueType(nestingLevel)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nestingLevel"
    ],
    "position": {
      "column": 1,
      "line": 1048
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getMapValueType(int nestingLevel)",
    "source_code": "\t\tpublic TypeDescriptor getMapValueType(int nestingLevel) {\n\t\t\treturn TypeDescriptor.valueOf(getResolvableType().getNested(nestingLevel).asMap().resolveGeneric(1));\n\t\t}"
  },
  "org.springframework.beans.BeanWrapperImpl#getCollectionType(nestingLevel)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nestingLevel"
    ],
    "position": {
      "column": 1,
      "line": 265
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getCollectionType(int nestingLevel)",
    "source_code": "\t\tpublic TypeDescriptor getCollectionType(int nestingLevel) {\n\t\t\treturn new TypeDescriptor(\n\t\t\t\t\tthis.typeDescriptor.getResolvableType().getNested(nestingLevel).asCollection().getGeneric(),\n\t\t\t\t\tnull, this.typeDescriptor.getAnnotations());\n\t\t}"
  },
  "org.springframework.beans.BeanWrapperImpl#getMapValueType(nestingLevel)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nestingLevel"
    ],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getMapValueType(int nestingLevel)",
    "source_code": "\t\tpublic TypeDescriptor getMapValueType(int nestingLevel) {\n\t\t\treturn new TypeDescriptor(\n\t\t\t\t\tthis.typeDescriptor.getResolvableType().getNested(nestingLevel).asMap().getGeneric(1),\n\t\t\t\t\tnull, this.typeDescriptor.getAnnotations());\n\t\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#hasConstructorWithOptionalParameter(beanClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass"
    ],
    "position": {
      "column": 1,
      "line": 359
    },
    "return": "boolean",
    "signature": "public boolean hasConstructorWithOptionalParameter(Class<?> beanClass)",
    "source_code": "\t\tpublic static boolean hasConstructorWithOptionalParameter(Class<?> beanClass) {\n\t\t\tif (KotlinDetector.isKotlinType(beanClass)) {\n\t\t\t\tKClass<?> kClass = JvmClassMappingKt.getKotlinClass(beanClass);\n\t\t\t\tfor (KFunction<?> constructor : kClass.getConstructors()) {\n\t\t\t\t\tfor (KParameter parameter : constructor.getParameters()) {\n\t\t\t\t\t\tif (parameter.isOptional()) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.beans.factory.config.YamlProcessor#isGlobalTagAllowed(tag)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "tag"
    ],
    "position": {
      "column": 1,
      "line": 435
    },
    "return": "boolean",
    "signature": "public boolean isGlobalTagAllowed(Tag tag)",
    "source_code": "\t\tpublic boolean isGlobalTagAllowed(Tag tag) {\n\t\t\treturn supportedTypes.contains(tag.getClassName());\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#await(destroyMethod,returnValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destroyMethod",
      "returnValue"
    ],
    "position": {
      "column": 1,
      "line": 494
    },
    "return": "boolean",
    "signature": "public boolean await(Method destroyMethod, Object returnValue)",
    "source_code": "\t\tpublic boolean await(Method destroyMethod, Object returnValue) throws InterruptedException {\n\t\t\tReactiveAdapter adapter = ReactiveAdapterRegistry.getSharedInstance().getAdapter(returnValue.getClass());\n\t\t\tif (adapter != null) {\n\t\t\t\tCountDownLatch latch = new CountDownLatch(1);\n\t\t\t\tadapter.toPublisher(returnValue).subscribe(new DestroyMethodSubscriber(destroyMethod, latch));\n\t\t\t\tlatch.await();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#onComplete()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 537
    },
    "return": "void",
    "signature": "public void onComplete()",
    "source_code": "\t\tpublic void onComplete() {\n\t\t\tthis.latch.countDown();\n\t\t\tlogDestroyMethodCompletion(this.destroyMethod, true);\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#onError(t)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "t"
    ],
    "position": {
      "column": 1,
      "line": 531
    },
    "return": "void",
    "signature": "public void onError(Throwable t)",
    "source_code": "\t\tpublic void onError(Throwable t) {\n\t\t\tthis.latch.countDown();\n\t\t\tlogDestroyMethodException(this.destroyMethod, t);\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#onNext(o)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o"
    ],
    "position": {
      "column": 1,
      "line": 527
    },
    "return": "void",
    "signature": "public void onNext(Object o)",
    "source_code": "\t\tpublic void onNext(Object o) {\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#onSubscribe(s)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "s"
    ],
    "position": {
      "column": 1,
      "line": 522
    },
    "return": "void",
    "signature": "public void onSubscribe(Subscription s)",
    "source_code": "\t\tpublic void onSubscribe(Subscription s) {\n\t\t\ts.request(Integer.MAX_VALUE);\n\t\t}"
  },
  "org.springframework.context.support.CHECKPOINT_ON_REFRESH_VALUE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Recognized value for the context checkpoint property: {@value}.\n\t * @since 6.1\n\t * @see #CHECKPOINT_PROPERTY_NAME\n\t * @see org.crac.Core#checkpointRestore()\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "signature": "public String CHECKPOINT_ON_REFRESH_VALUE",
    "source_code": "\tpublic static final String CHECKPOINT_ON_REFRESH_VALUE = \"onRefresh\";",
    "type": "String"
  },
  "org.springframework.context.support.CHECKPOINT_PROPERTY_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Property name for a common context checkpoint: {@value}.\n\t * @since 6.1\n\t * @see #CHECKPOINT_ON_REFRESH_VALUE\n\t * @see org.crac.Core#checkpointRestore()\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "signature": "public String CHECKPOINT_PROPERTY_NAME",
    "source_code": "\tpublic static final String CHECKPOINT_PROPERTY_NAME = \"spring.context.checkpoint\";",
    "type": "String"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#afterRestore(context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 545
    },
    "return": "void",
    "signature": "public void afterRestore(org.crac.Context<? extends org.crac.Resource> context)",
    "source_code": "\t\tpublic void afterRestore(org.crac.Context<? extends org.crac.Resource> context) {\n\t\t\tlong restartTime = System.nanoTime();\n\t\t\tlogger.info(\"Restarting Spring-managed lifecycle beans after JVM restore\");\n\t\t\trestartAfterStop();\n\n\t\t\t// Barrier for prevent-shutdown thread not needed anymore\n\t\t\tthis.barrier = null;\n\n\t\t\tDuration timeTakenToRestart = Duration.ofNanos(System.nanoTime() - restartTime);\n\t\t\tlogger.info(\"Spring-managed lifecycle restart completed in \" + timeTakenToRestart.toMillis() + \" ms\");\n\t\t}"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#beforeCheckpoint(context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 526
    },
    "return": "void",
    "signature": "public void beforeCheckpoint(org.crac.Context<? extends org.crac.Resource> context)",
    "source_code": "\t\tpublic void beforeCheckpoint(org.crac.Context<? extends org.crac.Resource> context) {\n\t\t\t// A non-daemon thread for preventing an accidental JVM shutdown before the checkpoint\n\t\t\tthis.barrier = new CyclicBarrier(2);\n\n\t\t\tThread thread = new Thread(() -> {\n\t\t\t\tawaitPreventShutdownBarrier();\n\t\t\t\t// Checkpoint happens here\n\t\t\t\tawaitPreventShutdownBarrier();\n\t\t\t}, \"prevent-shutdown\");\n\n\t\t\tthread.setDaemon(false);\n\t\t\tthread.start();\n\t\t\tawaitPreventShutdownBarrier();\n\n\t\t\tlogger.debug(\"Stopping Spring-managed lifecycle beans before JVM checkpoint\");\n\t\t\tstopForRestart();\n\t\t}"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#checkpointRestore()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 495
    },
    "return": "void",
    "signature": "public void checkpointRestore()",
    "source_code": "\t\tpublic void checkpointRestore() {\n\t\t\tlogger.info(\"Triggering JVM checkpoint/restore\");\n\t\t\ttry {\n\t\t\t\tCore.checkpointRestore();\n\t\t\t}\n\t\t\tcatch (UnsupportedOperationException ex) {\n\t\t\t\tthrow new ApplicationContextException(\"CRaC checkpoint not supported on current JVM\", ex);\n\t\t\t}\n\t\t\tcatch (CheckpointException ex) {\n\t\t\t\tthrow new ApplicationContextException(\"Failed to take CRaC checkpoint on refresh\", ex);\n\t\t\t}\n\t\t\tcatch (RestoreException ex) {\n\t\t\t\tthrow new ApplicationContextException(\"Failed to restore CRaC checkpoint on refresh\", ex);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#compareTo(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 411
    },
    "return": "int",
    "signature": "public int compareTo(LifecycleGroupMember other)",
    "source_code": "\t\tpublic int compareTo(LifecycleGroupMember other) {\n\t\t\tint thisPhase = getPhase(this.bean);\n\t\t\tint otherPhase = getPhase(other.bean);\n\t\t\treturn Integer.compare(thisPhase, otherPhase);\n\t\t}"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#registerResource()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 488
    },
    "return": "Object",
    "signature": "public Object registerResource()",
    "source_code": "\t\tpublic Object registerResource() {\n\t\t\tlogger.debug(\"Registering JVM checkpoint/restore callback for Spring-managed lifecycle beans\");\n\t\t\tCracResourceAdapter resourceAdapter = new CracResourceAdapter();\n\t\t\torg.crac.Core.getGlobalContext().register(resourceAdapter);\n\t\t\treturn resourceAdapter;\n\t\t}"
  },
  "org.springframework.context.support.ReloadableResourceBundleMessageSource#resolveResource(filename)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the specified bundle {@code filename} into a concrete {@link Resource},\n\t * potentially checking multiple sources or file extensions.\n\t * <p>If no suitable concrete {@code Resource} can be resolved, this method\n\t * returns a {@code Resource} for which {@link Resource#exists()} returns\n\t * {@code false}, which gets subsequently ignored.\n\t * <p>This can be leveraged to check the last modification timestamp or to load\n\t * properties from alternative sources &mdash; for example, from an XML BLOB\n\t * in a database, or from properties serialized using a custom format such as\n\t * JSON.\n\t * <p>The default implementation delegates to the configured\n\t * {@link #setResourceLoader(ResourceLoader) ResourceLoader} to resolve\n\t * resources, first checking for an existing {@code Resource} with a\n\t * {@code .properties} extension, and otherwise returning a {@code Resource}\n\t * with a {@code .xml} extension.\n\t * <p>When overriding this method, {@link #loadProperties(Resource, String)}\n\t * <strong>must</strong> be capable of loading properties from any type of\n\t * {@code Resource} returned by this method. As a consequence, implementors\n\t * are strongly encouraged to also override {@code loadProperties()}.\n\t * <p>As an alternative to overriding this method, you can configure a\n\t * {@link #setPropertiesPersister(PropertiesPersister) PropertiesPersister}\n\t * that is capable of dealing with all resources returned by this method.\n\t * Please note, however, that the default {@code loadProperties()} implementation\n\t * uses {@link PropertiesPersister#loadFromXml(Properties, InputStream) loadFromXml}\n\t * for XML resources and otherwise uses the two\n\t * {@link PropertiesPersister#load(Properties, InputStream) load} methods\n\t * for other types of resources.\n\t * @param filename the bundle filename (basename + Locale)\n\t * @return the {@code Resource} to use\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "filename"
    ],
    "position": {
      "column": 1,
      "line": 493
    },
    "return": "Resource",
    "signature": "protected Resource resolveResource(String filename)",
    "source_code": "\tprotected Resource resolveResource(String filename) {\n\t\tResource propertiesResource = this.resourceLoader.getResource(filename + PROPERTIES_SUFFIX);\n\t\tif (propertiesResource.exists()) {\n\t\t\treturn propertiesResource;\n\t\t}\n\t\treturn this.resourceLoader.getResource(filename + XML_SUFFIX);\n\t}"
  },
  "org.springframework.core.MethodParameter#forFieldAwareConstructor(ctor,parameterIndex,fieldName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new MethodParameter for the given field-aware constructor,\n\t * e.g. on a data class or record type.\n\t * <p>A field-aware method parameter will detect field annotations as well,\n\t * as long as the field name matches the parameter name.\n\t * @param ctor the Constructor to specify a parameter for\n\t * @param parameterIndex the index of the parameter\n\t * @param fieldName the name of the underlying field,\n\t * matching the constructor's parameter name\n\t * @return the corresponding MethodParameter instance\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ctor",
      "parameterIndex",
      "fieldName"
    ],
    "position": {
      "column": 1,
      "line": 878
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter forFieldAwareConstructor(Constructor<?> ctor, int parameterIndex, String fieldName)",
    "source_code": "\tpublic static MethodParameter forFieldAwareConstructor(Constructor<?> ctor, int parameterIndex, String fieldName) {\n\t\treturn new FieldAwareConstructorParameter(ctor, parameterIndex, fieldName);\n\t}"
  },
  "org.springframework.core.ResolvableType#equalsType(otherType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check for type-level equality with another {@code ResolvableType}.\n\t * <p>In contrast to {@link #equals(Object)} or {@link #isAssignableFrom(ResolvableType)},\n\t * this works between different sources as well, e.g. method parameters and return types.\n\t * @param otherType the {@code ResolvableType} to match against\n\t * @return whether the declared type and type variables match\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "otherType"
    ],
    "position": {
      "column": 1,
      "line": 952
    },
    "return": "boolean",
    "signature": "public boolean equalsType(ResolvableType otherType)",
    "source_code": "\tpublic boolean equalsType(ResolvableType otherType) {\n\t\treturn (ObjectUtils.nullSafeEquals(this.type, otherType.type) &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.componentType, otherType.componentType));\n\t}"
  },
  "org.springframework.core.io.ModuleResource": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link Resource} implementation for {@link java.lang.Module} resolution,\n * performing {@link #getInputStream()} access via {@link Module#getResourceAsStream}.\n *\n * <p>Alternatively, consider accessing resources in a module path layout via\n * {@link ClassPathResource} for exported resources, or specifically relative to\n * a {@code Class} via {@link ClassPathResource#ClassPathResource(String, Class)}\n * for local resolution within the containing module of that specific class.\n * In common scenarios, module resources will simply be transparently visible as\n * classpath resources and therefore do not need any special treatment at all.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 6.1\n * @see Module#getResourceAsStream\n * @see ClassPathResource\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "signature": "public class ModuleResource",
    "source_code": "public class ModuleResource extends AbstractResource {\n\n\tprivate final Module module;\n\n\tprivate final String path;\n\n\n\t/**\n\t * Create a new {@code ModuleResource} for the given {@link Module}\n\t * and the given resource path.\n\t * @param module the runtime module to search within\n\t * @param path the resource path within the module\n\t */\n\tpublic ModuleResource(Module module, String path) {\n\t\tAssert.notNull(module, \"Module must not be null\");\n\t\tAssert.notNull(path, \"Path must not be null\");\n\t\tthis.module = module;\n\t\tthis.path = path;\n\t}\n\n\n\t/**\n\t * Return the {@link Module} for this resource.\n\t */\n\tpublic final Module getModule() {\n\t\treturn this.module;\n\t}\n\n\t/**\n\t * Return the path for this resource.\n\t */\n\tpublic final String getPath() {\n\t\treturn this.path;\n\t}\n\n\n\t@Override\n\tpublic InputStream getInputStream() throws IOException {\n\t\tInputStream is = this.module.getResourceAsStream(this.path);\n\t\tif (is == null) {\n\t\t\tthrow new FileNotFoundException(getDescription() + \" cannot be opened because it does not exist\");\n\t\t}\n\t\treturn is;\n\t}\n\n\t@Override\n\tpublic Resource createRelative(String relativePath) {\n\t\tString pathToUse = StringUtils.applyRelativePath(this.path, relativePath);\n\t\treturn new ModuleResource(this.module, pathToUse);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic String getFilename() {\n\t\treturn StringUtils.getFilename(this.path);\n\t}\n\n\t@Override\n\tpublic String getDescription() {\n\t\treturn \"module resource [\" + this.path + \"]\" +\n\t\t\t\t(this.module.isNamed() ? \" from module [\" + this.module.getName() + \"]\" : \"\");\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof ModuleResource that &&\n\t\t\t\tthis.module.equals(that.module) && this.path.equals(that.path)));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.module.hashCode() * 31 + this.path.hashCode();\n\t}\n\n}"
  },
  "org.springframework.core.io.ModuleResource#createRelative(relativePath)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "relativePath"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "Resource",
    "signature": "public Resource createRelative(String relativePath)",
    "source_code": "\tpublic Resource createRelative(String relativePath) {\n\t\tString pathToUse = StringUtils.applyRelativePath(this.path, relativePath);\n\t\treturn new ModuleResource(this.module, pathToUse);\n\t}"
  },
  "org.springframework.core.io.ModuleResource#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof ModuleResource that &&\n\t\t\t\tthis.module.equals(that.module) && this.path.equals(that.path)));\n\t}"
  },
  "org.springframework.core.io.ModuleResource#getDescription()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "String",
    "signature": "public String getDescription()",
    "source_code": "\tpublic String getDescription() {\n\t\treturn \"module resource [\" + this.path + \"]\" +\n\t\t\t\t(this.module.isNamed() ? \" from module [\" + this.module.getName() + \"]\" : \"\");\n\t}"
  },
  "org.springframework.core.io.ModuleResource#getFilename()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "String",
    "signature": "public String getFilename()",
    "source_code": "\tpublic String getFilename() {\n\t\treturn StringUtils.getFilename(this.path);\n\t}"
  },
  "org.springframework.core.io.ModuleResource#getInputStream()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "InputStream",
    "signature": "public InputStream getInputStream()",
    "source_code": "\tpublic InputStream getInputStream() throws IOException {\n\t\tInputStream is = this.module.getResourceAsStream(this.path);\n\t\tif (is == null) {\n\t\t\tthrow new FileNotFoundException(getDescription() + \" cannot be opened because it does not exist\");\n\t\t}\n\t\treturn is;\n\t}"
  },
  "org.springframework.core.io.ModuleResource#getModule()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link Module} for this resource.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "Module",
    "signature": "public Module getModule()",
    "source_code": "\tpublic final Module getModule() {\n\t\treturn this.module;\n\t}"
  },
  "org.springframework.core.io.ModuleResource#getPath()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the path for this resource.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "String",
    "signature": "public String getPath()",
    "source_code": "\tpublic final String getPath() {\n\t\treturn this.path;\n\t}"
  },
  "org.springframework.core.io.ModuleResource#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.module.hashCode() * 31 + this.path.hashCode();\n\t}"
  },
  "org.springframework.core.task.TaskRejectedException": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Exception thrown when a {@link TaskExecutor} rejects to accept\n * a given task for execution.\n *\n * @author Juergen Hoeller\n * @since 2.0.1\n * @see TaskExecutor#execute(Runnable)\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 32
    },
    "signature": "public class TaskRejectedException",
    "source_code": "public class TaskRejectedException extends RejectedExecutionException {\n\n\t/**\n\t * Create a new {@code TaskRejectedException}\n\t * with the specified detail message and no root cause.\n\t * @param msg the detail message\n\t */\n\tpublic TaskRejectedException(String msg) {\n\t\tsuper(msg);\n\t}\n\n\t/**\n\t * Create a new {@code TaskRejectedException}\n\t * with the specified detail message and the given root cause.\n\t * @param msg the detail message\n\t * @param cause the root cause (usually from using an underlying\n\t * API such as the {@code java.util.concurrent} package)\n\t * @see java.util.concurrent.RejectedExecutionException\n\t */\n\tpublic TaskRejectedException(String msg, Throwable cause) {\n\t\tsuper(msg, cause);\n\t}\n\n\t/**\n\t * Create a new {@code TaskRejectedException}\n\t * with a default message for the given executor and task.\n\t * @param executor the {@code Executor} that rejected the task\n\t * @param task the task object that got rejected\n\t * @param cause the original {@link RejectedExecutionException}\n\t * @since 6.1\n\t * @see ExecutorService#isShutdown()\n\t * @see java.util.concurrent.RejectedExecutionException\n\t */\n\tpublic TaskRejectedException(Executor executor, Object task, RejectedExecutionException cause) {\n\t\tsuper(executorDescription(executor) + \" did not accept task: \" + task, cause);\n\t}\n\n\n\tprivate static String executorDescription(Executor executor) {\n\t\tif (executor instanceof ExecutorService executorService) {\n\t\t\treturn \"ExecutorService in \" + (executorService.isShutdown() ? \"shutdown\" : \"active\") + \" state\";\n\t\t}\n\t\treturn executor.toString();\n\t}\n\n}"
  },
  "org.springframework.core.task.support.TaskExecutorAdapter#execute(task,startTimeout)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "startTimeout"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "void",
    "signature": "public void execute(Runnable task, long startTimeout)",
    "source_code": "\tpublic void execute(Runnable task, long startTimeout) {\n\t\texecute(task);\n\t}"
  },
  "org.springframework.http.HttpMethod#resolve(method)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the given method value to an {@code HttpMethod}.\n\t * @param method the method value as a String\n\t * @return the corresponding {@code HttpMethod}, or {@code null} if not found\n\t * @since 4.2.4\n\t * @deprecated in favor of {@link #valueOf(String)}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "HttpMethod",
    "signature": "public HttpMethod resolve(@Nullable String method)",
    "source_code": "\tpublic static HttpMethod resolve(@Nullable String method) {\n\t\treturn (method != null ? valueOf(method) : null);\n\t}"
  },
  "org.springframework.http.client.<unknown>#close()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\tpublic void close() {\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tStreamUtils.drain(this.body);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.body.close();\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ignored) {\n\t\t}\n\t}"
  },
  "org.springframework.http.client.<unknown>#executeInternal(headers,body)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "headers",
      "body"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "ClientHttpResponse",
    "signature": "protected ClientHttpResponse executeInternal(HttpHeaders headers, @Nullable Body body)",
    "source_code": "\tprotected ClientHttpResponse executeInternal(HttpHeaders headers, @Nullable Body body) throws IOException {\n\t\tif (!headers.isEmpty()) {\n\t\t\tthis.request.headers(httpFields -> {\n\t\t\t\theaders.forEach((headerName, headerValues) -> {\n\t\t\t\t\tfor (String headerValue : headerValues) {\n\t\t\t\t\t\thttpFields.add(headerName, headerValue);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\tString contentType = null;\n\t\tif (headers.getContentType() != null) {\n\t\t\tcontentType = headers.getContentType().toString();\n\t\t}\n\t\ttry {\n\t\t\tInputStreamResponseListener responseListener = new InputStreamResponseListener();\n\t\t\tif (body != null) {\n\t\t\t\tOutputStreamRequestContent requestContent = new OutputStreamRequestContent(contentType);\n\t\t\t\tthis.request.body(requestContent)\n\t\t\t\t\t\t.send(responseListener);\n\t\t\t\ttry (OutputStream outputStream = requestContent.getOutputStream()) {\n\t\t\t\t\tbody.writeTo(StreamUtils.nonClosing(outputStream));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.request.send(responseListener);\n\t\t\t}\n\t\t\tResponse response = responseListener.get(this.readTimeout, TimeUnit.MILLISECONDS);\n\t\t\treturn new JettyClientHttpResponse(response, responseListener.getInputStream());\n\t\t}\n\t\tcatch (InterruptedException ex) {\n\t\t\tThread.currentThread().interrupt();\n\t\t\tthrow new IOException(\"Request was interrupted: \" + ex.getMessage(), ex);\n\t\t}\n\t\tcatch (ExecutionException ex) {\n\t\t\tThrowable cause = ex.getCause();\n\n\t\t\tif (cause instanceof UncheckedIOException uioEx) {\n\t\t\t\tthrow uioEx.getCause();\n\t\t\t}\n\t\t\tif (cause instanceof RuntimeException rtEx) {\n\t\t\t\tthrow rtEx;\n\t\t\t}\n\t\t\telse if (cause instanceof IOException ioEx) {\n\t\t\t\tthrow ioEx;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IOException(cause.getMessage(), cause);\n\t\t\t}\n\t\t}\n\t\tcatch (TimeoutException ex) {\n\t\t\tthrow new IOException(\"Request timed out: \" + ex.getMessage(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.http.client.<unknown>#getBody()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "InputStream",
    "signature": "public InputStream getBody()",
    "source_code": "\tpublic InputStream getBody() throws IOException {\n\t\treturn this.body;\n\t}"
  },
  "org.springframework.http.client.<unknown>#getHeaders()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders getHeaders()",
    "source_code": "\tpublic HttpHeaders getHeaders() {\n\t\treturn this.headers;\n\t}"
  },
  "org.springframework.http.client.<unknown>#getStatusCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "HttpStatusCode",
    "signature": "public HttpStatusCode getStatusCode()",
    "source_code": "\tpublic HttpStatusCode getStatusCode() {\n\t\treturn HttpStatusCode.valueOf(this.response.statusCode());\n\t}"
  },
  "org.springframework.http.client.<unknown>#getStatusText()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "String",
    "signature": "public String getStatusText()",
    "source_code": "\tpublic String getStatusText() {\n\t\t// HttpResponse does not expose status text\n\t\tif (getStatusCode() instanceof HttpStatus status) {\n\t\t\treturn status.getReasonPhrase();\n\t\t}\n\t\telse {\n\t\t\treturn \"\";\n\t\t}\n\t}"
  },
  "org.springframework.http.client.<unknown>#map(b)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "ByteBuf",
    "signature": "public ByteBuf map(int b)",
    "source_code": "\t\tpublic ByteBuf map(int b) {\n\t\t\tByteBuf byteBuf = this.allocator.buffer(1);\n\t\t\tbyteBuf.writeByte(b);\n\t\t\treturn byteBuf;\n\t\t}"
  },
  "org.springframework.http.client.<unknown>#map(b,off,len)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b",
      "off",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "ByteBuf",
    "signature": "public ByteBuf map(byte[] b, int off, int len)",
    "source_code": "\t\tpublic ByteBuf map(byte[] b, int off, int len) {\n\t\t\tByteBuf byteBuf = this.allocator.buffer(len);\n\t\t\tbyteBuf.writeBytes(b, off, len);\n\t\t\treturn byteBuf;\n\t\t}"
  },
  "org.springframework.http.client.HttpComponentsClientHttpRequestFactory#setReadTimeout(timeout)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * As of version 6.0, setting this property has no effect.\n\t * <p>To change the socket read timeout, use {@link SocketConfig.Builder#setSoTimeout(Timeout)},\n\t * supply the resulting {@link SocketConfig} to\n\t * {@link org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManagerBuilder#setDefaultSocketConfig(SocketConfig)},\n\t * use the resulting connection manager for\n\t * {@link org.apache.hc.client5.http.impl.classic.HttpClientBuilder#setConnectionManager(HttpClientConnectionManager)},\n\t * and supply the built {@link HttpClient} to {@link #HttpComponentsClientHttpRequestFactory(HttpClient)}.\n\t * @deprecated as of 6.0, in favor of {@link SocketConfig.Builder#setSoTimeout(Timeout)}, see above.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "void",
    "signature": "public void setReadTimeout(int timeout)",
    "source_code": "\tpublic void setReadTimeout(int timeout) {\n\t\tlogger.warn(\"HttpComponentsClientHttpRequestFactory.setReadTimeout has no effect\");\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#add(key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "void",
    "signature": "public void add(String key, @Nullable String value)",
    "source_code": "\tpublic void add(String key, @Nullable String value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tmutableHttpFields.add(key, value);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#addAll(MultiValueMap<String,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this::addAll);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#addAll(key,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "public void addAll(String key, List<? extends String> values)",
    "source_code": "\tpublic void addAll(String key, List<? extends String> values) {\n\t\tvalues.forEach(value -> add(key, value));\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#clear()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\tpublic void clear() {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tmutableHttpFields.clear();\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#containsKey(key)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "boolean",
    "signature": "public boolean containsKey(Object key)",
    "source_code": "\tpublic boolean containsKey(Object key) {\n\t\treturn (key instanceof String headerName && this.headers.contains(headerName));\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#containsValue(value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "boolean",
    "signature": "public boolean containsValue(Object value)",
    "source_code": "\tpublic boolean containsValue(Object value) {\n\t\treturn (value instanceof String searchString &&\n\t\t\t\tthis.headers.stream().anyMatch(field -> field.contains(searchString)));\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#entrySet()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "List<String>>>",
    "signature": "public List<String>>> entrySet()",
    "source_code": "\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn new AbstractSet<>() {\n\t\t\t@Override\n\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn headers.size();\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#get(key)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "List<String>",
    "signature": "public List<String> get(Object key)",
    "source_code": "\tpublic List<String> get(Object key) {\n\t\tif (containsKey(key)) {\n\t\t\treturn this.headers.getValuesList((String) key);\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#getFirst(key)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "String",
    "signature": "public String getFirst(String key)",
    "source_code": "\tpublic String getFirst(String key) {\n\t\treturn this.headers.get(key);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#getKey()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "String",
    "signature": "public String getKey()",
    "source_code": "\t\tpublic String getKey() {\n\t\t\treturn this.key;\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#getValue()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "List<String>",
    "signature": "public List<String> getValue()",
    "source_code": "\t\tpublic List<String> getValue() {\n\t\t\treturn headers.getValuesList(this.key);\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#hasNext()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 275
    },
    "return": "boolean",
    "signature": "public boolean hasNext()",
    "source_code": "\t\tpublic boolean hasNext() {\n\t\t\treturn this.iterator.hasNext();\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#isEmpty()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "boolean",
    "signature": "public boolean isEmpty()",
    "source_code": "\tpublic boolean isEmpty() {\n\t\treturn (this.headers.size() == 0);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#iterator()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "Iterator<String>",
    "signature": "public Iterator<String> iterator()",
    "source_code": "\t\tpublic Iterator<String> iterator() {\n\t\t\treturn new HeaderNamesIterator(headers.getFieldNamesCollection().iterator());\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#keySet()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "Set<String>",
    "signature": "public Set<String> keySet()",
    "source_code": "\tpublic Set<String> keySet() {\n\t\treturn new HeaderNames();\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#next()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "String",
    "signature": "public String next()",
    "source_code": "\t\tpublic String next() {\n\t\t\tthis.currentName = this.iterator.next();\n\t\t\treturn this.currentName;\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#put(key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> value)",
    "source_code": "\tpublic List<String> put(String key, List<String> value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tList<String> oldValues = get(key);\n\t\tmutableHttpFields.put(key, value);\n\t\treturn oldValues;\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#put(key,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> values)",
    "source_code": "\tpublic List<String> put(String key, List<String> values) {\n\t\tList<String> oldValues = remove(key);\n\t\tvalues.forEach(value -> add(key, value));\n\t\treturn oldValues;\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#putAll(String,map)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this::put);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#remove()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "void",
    "signature": "public void remove()",
    "source_code": "\t\tpublic void remove() {\n\t\t\tif (!(headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t\t}\n\t\t\tif (this.currentName == null) {\n\t\t\t\tthrow new IllegalStateException(\"No current Header in iterator\");\n\t\t\t}\n\t\t\tif (!headers.contains(this.currentName)) {\n\t\t\t\tthrow new IllegalStateException(\"Header not present: \" + this.currentName);\n\t\t\t}\n\t\t\tmutableHttpFields.remove(this.currentName);\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#remove(key)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "List<String>",
    "signature": "public List<String> remove(Object key)",
    "source_code": "\tpublic List<String> remove(Object key) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tif (key instanceof String name) {\n\t\t\tList<String> oldValues = get(key);\n\t\t\tmutableHttpFields.remove(name);\n\t\t\treturn oldValues;\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#set(key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "public void set(String key, @Nullable String value)",
    "source_code": "\tpublic void set(String key, @Nullable String value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tmutableHttpFields.put(key, value);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#setAll(Map<String,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this::set);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#setValue(value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "List<String>",
    "signature": "public List<String> setValue(List<String> value)",
    "source_code": "\t\tpublic List<String> setValue(List<String> value) {\n\t\t\tif (!(headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t\t}\n\t\t\tList<String> previousValues = headers.getValuesList(this.key);\n\t\t\tmutableHttpFields.put(this.key, value);\n\t\t\treturn previousValues;\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#size()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 257
    },
    "return": "int",
    "signature": "public int size()",
    "source_code": "\t\tpublic int size() {\n\t\t\treturn headers.getFieldNamesCollection().size();\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#toSingleValueMap()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "String>",
    "signature": "public String> toSingleValueMap()",
    "source_code": "\tpublic Map<String, String> toSingleValueMap() {\n\t\tMap<String, String> singleValueMap = CollectionUtils.newLinkedHashMap(this.headers.size());\n\t\tIterator<HttpField> iterator = this.headers.iterator();\n\t\titerator.forEachRemaining(field -> {\n\t\t\tif (!singleValueMap.containsKey(field.getName())) {\n\t\t\t\tsingleValueMap.put(field.getName(), field.getValue());\n\t\t\t}\n\t\t});\n\t\treturn singleValueMap;\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#values()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "Collection<List<String>>",
    "signature": "public Collection<List<String>> values()",
    "source_code": "\tpublic Collection<List<String>> values() {\n\t\treturn this.headers.getFieldNamesCollection().stream()\n\t\t\t\t.map(this.headers::getValuesList).toList();\n\t}"
  },
  "org.springframework.http.codec.xml.Jaxb2XmlEncoder": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Encode from single value to a byte stream containing XML elements.\n *\n * <p>{@link jakarta.xml.bind.annotation.XmlElements @XmlElements} and\n * {@link jakarta.xml.bind.annotation.XmlElement @XmlElement} can be used\n * to specify how collections should be marshalled.\n *\n * @author Sebastien Deleuze\n * @author Arjen Poutsma\n * @since 5.0\n * @see Jaxb2XmlDecoder\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "signature": "public class Jaxb2XmlEncoder",
    "source_code": "public class Jaxb2XmlEncoder extends AbstractSingleValueEncoder<Object> {\n\n\tprivate final JaxbContextContainer jaxbContexts = new JaxbContextContainer();\n\n\tprivate Function<Marshaller, Marshaller> marshallerProcessor = Function.identity();\n\n\n\tpublic Jaxb2XmlEncoder() {\n\t\tsuper(MimeTypeUtils.APPLICATION_XML, MimeTypeUtils.TEXT_XML, new MediaType(\"application\", \"*+xml\"));\n\t}\n\n\n\t/**\n\t * Configure a processor function to customize Marshaller instances.\n\t * @param processor the function to use\n\t * @since 5.1.3\n\t */\n\tpublic void setMarshallerProcessor(Function<Marshaller, Marshaller> processor) {\n\t\tthis.marshallerProcessor = this.marshallerProcessor.andThen(processor);\n\t}\n\n\t/**\n\t * Return the configured processor for customizing Marshaller instances.\n\t * @since 5.1.3\n\t */\n\tpublic Function<Marshaller, Marshaller> getMarshallerProcessor() {\n\t\treturn this.marshallerProcessor;\n\t}\n\n\n\t@Override\n\tpublic boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType) {\n\t\tif (super.canEncode(elementType, mimeType)) {\n\t\t\tClass<?> outputClass = elementType.toClass();\n\t\t\treturn (outputClass.isAnnotationPresent(XmlRootElement.class) ||\n\t\t\t\t\toutputClass.isAnnotationPresent(XmlType.class));\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Override\n\tprotected Flux<DataBuffer> encode(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\t// we're relying on doOnDiscard in base class\n\t\treturn Mono.fromCallable(() -> encodeValue(value, bufferFactory, valueType, mimeType, hints)).flux();\n\t}\n\n\t@Override\n\tpublic DataBuffer encodeValue(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tif (!Hints.isLoggingSuppressed(hints)) {\n\t\t\tLogFormatUtils.traceDebug(logger, traceOn -> {\n\t\t\t\tString formatted = LogFormatUtils.formatValue(value, !traceOn);\n\t\t\t\treturn Hints.getLogPrefix(hints) + \"Encoding [\" + formatted + \"]\";\n\t\t\t});\n\t\t}\n\n\t\tboolean release = true;\n\t\tDataBuffer buffer = bufferFactory.allocateBuffer(1024);\n\t\ttry {\n\t\t\tOutputStream outputStream = buffer.asOutputStream();\n\t\t\tClass<?> clazz = getMarshallerType(value);\n\t\t\tMarshaller marshaller = initMarshaller(clazz);\n\t\t\tmarshaller.marshal(value, outputStream);\n\t\t\trelease = false;\n\t\t\treturn buffer;\n\t\t}\n\t\tcatch (MarshalException ex) {\n\t\t\tthrow new EncodingException(\"Could not marshal \" + value.getClass() + \" to XML\", ex);\n\t\t}\n\t\tcatch (JAXBException ex) {\n\t\t\tthrow new CodecException(\"Invalid JAXB configuration\", ex);\n\t\t}\n\t\tfinally {\n\t\t\tif (release) {\n\t\t\t\tDataBufferUtils.release(buffer);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static Class<?> getMarshallerType(Object value) {\n\t\tif (value instanceof JAXBElement<?> jaxbElement) {\n\t\t\treturn jaxbElement.getDeclaredType();\n\t\t}\n\t\telse {\n\t\t\treturn ClassUtils.getUserClass(value);\n\t\t}\n\t}\n\n\tprivate Marshaller initMarshaller(Class<?> clazz) throws CodecException, JAXBException {\n\t\tMarshaller marshaller = this.jaxbContexts.createMarshaller(clazz);\n\t\tmarshaller.setProperty(Marshaller.JAXB_ENCODING, StandardCharsets.UTF_8.name());\n\t\tmarshaller = this.marshallerProcessor.apply(marshaller);\n\t\treturn marshaller;\n\t}\n\n}"
  },
  "org.springframework.http.codec.xml.Jaxb2XmlEncoder#canEncode(elementType,mimeType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "boolean",
    "signature": "public boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType)",
    "source_code": "\tpublic boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType) {\n\t\tif (super.canEncode(elementType, mimeType)) {\n\t\t\tClass<?> outputClass = elementType.toClass();\n\t\t\treturn (outputClass.isAnnotationPresent(XmlRootElement.class) ||\n\t\t\t\t\toutputClass.isAnnotationPresent(XmlType.class));\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.xml.Jaxb2XmlEncoder#encode(value,bufferFactory,valueType,mimeType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "bufferFactory",
      "valueType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "Flux<DataBuffer>",
    "signature": "protected Flux<DataBuffer> encode(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tprotected Flux<DataBuffer> encode(Object value, DataBufferFactory bufferFactory,"
  },
  "org.springframework.http.codec.xml.Jaxb2XmlEncoder#encodeValue(value,bufferFactory,valueType,mimeType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "bufferFactory",
      "valueType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer encodeValue(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic DataBuffer encodeValue(Object value, DataBufferFactory bufferFactory,"
  },
  "org.springframework.http.codec.xml.Jaxb2XmlEncoder#getMarshallerProcessor()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured processor for customizing Marshaller instances.\n\t * @since 5.1.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "Marshaller>",
    "signature": "public Marshaller> getMarshallerProcessor()",
    "source_code": "\tpublic Function<Marshaller, Marshaller> getMarshallerProcessor() {\n\t\treturn this.marshallerProcessor;\n\t}"
  },
  "org.springframework.http.codec.xml.Jaxb2XmlEncoder#setMarshallerProcessor(Function<Marshaller,processor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a processor function to customize Marshaller instances.\n\t * @param processor the function to use\n\t * @since 5.1.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<Marshaller",
      "processor"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "void",
    "signature": "public void setMarshallerProcessor(Function<Marshaller, Marshaller> processor)",
    "source_code": "\tpublic void setMarshallerProcessor(Function<Marshaller, Marshaller> processor) {\n\t\tthis.marshallerProcessor = this.marshallerProcessor.andThen(processor);\n\t}"
  },
  "org.springframework.http.converter.FormHttpMessageConverter#close()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 681
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\t\tpublic void close() {\n\t\t}"
  },
  "org.springframework.http.converter.FormHttpMessageConverter#flush()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 677
    },
    "return": "void",
    "signature": "public void flush()",
    "source_code": "\t\tpublic void flush() {\n\t\t}"
  },
  "org.springframework.http.converter.FormHttpMessageConverter#write(b,off,let)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b",
      "off",
      "let"
    ],
    "position": {
      "column": 1,
      "line": 672
    },
    "return": "void",
    "signature": "public void write(byte[] b, int off, int let)",
    "source_code": "\t\tpublic void write(byte[] b, int off, int let) throws IOException {\n\t\t\tthis.out.write(b, off, let);\n\t\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code MultiValueMap} implementation for wrapping Apache HttpComponents\n * HttpClient headers.\n *\n * @author Rossen Stoyanchev\n * @since 6.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "signature": "public class HttpComponentsHeadersAdapter",
    "source_code": "public final class HttpComponentsHeadersAdapter implements MultiValueMap<String, String> {\n\n\tprivate final HttpMessage message;\n\n\n\t/**\n\t * Create a new {@code HttpComponentsHeadersAdapter} based on the given\n\t * {@code HttpMessage}.\n\t */\n\tpublic HttpComponentsHeadersAdapter(HttpMessage message) {\n\t\tAssert.notNull(message, \"Message must not be null\");\n\t\tthis.message = message;\n\t}\n\n\n\t@Override\n\t@Nullable\n\tpublic String getFirst(String key) {\n\t\tHeader header = this.message.getFirstHeader(key);\n\t\treturn (header != null ? header.getValue() : null);\n\t}\n\n\t@Override\n\tpublic void add(String key, @Nullable String value) {\n\t\tthis.message.addHeader(key, value);\n\t}\n\n\t@Override\n\tpublic void addAll(String key, List<? extends String> values) {\n\t\tvalues.forEach(value -> add(key, value));\n\t}\n\n\t@Override\n\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this::addAll);\n\t}\n\n\t@Override\n\tpublic void set(String key, @Nullable String value) {\n\t\tthis.message.setHeader(key, value);\n\t}\n\n\t@Override\n\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this::set);\n\t}\n\n\t@Override\n\tpublic Map<String, String> toSingleValueMap() {\n\t\tMap<String, String> map = CollectionUtils.newLinkedHashMap(size());\n\t\tthis.message.headerIterator().forEachRemaining(h -> map.putIfAbsent(h.getName(), h.getValue()));\n\t\treturn map;\n\t}\n\n\t@Override\n\tpublic int size() {\n\t\treturn this.message.getHeaders().length;\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn (this.message.getHeaders().length == 0);\n\t}\n\n\t@Override\n\tpublic boolean containsKey(Object key) {\n\t\treturn (key instanceof String headerName && this.message.containsHeader(headerName));\n\t}\n\n\t@Override\n\tpublic boolean containsValue(Object value) {\n\t\treturn (value instanceof String &&\n\t\t\t\tArrays.stream(this.message.getHeaders()).anyMatch(h -> h.getValue().equals(value)));\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> get(Object key) {\n\t\tList<String> values = null;\n\t\tif (containsKey(key)) {\n\t\t\tHeader[] headers = this.message.getHeaders((String) key);\n\t\t\tvalues = new ArrayList<>(headers.length);\n\t\t\tfor (Header header : headers) {\n\t\t\t\tvalues.add(header.getValue());\n\t\t\t}\n\t\t}\n\t\treturn values;\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> put(String key, List<String> values) {\n\t\tList<String> oldValues = remove(key);\n\t\tvalues.forEach(value -> add(key, value));\n\t\treturn oldValues;\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> remove(Object key) {\n\t\tif (key instanceof String headerName) {\n\t\t\tList<String> oldValues = get(key);\n\t\t\tthis.message.removeHeaders(headerName);\n\t\t\treturn oldValues;\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this::put);\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\tthis.message.setHeaders();\n\t}\n\n\t@Override\n\tpublic Set<String> keySet() {\n\t\tSet<String> keys = new LinkedHashSet<>(size());\n\t\tfor (Header header : this.message.getHeaders()) {\n\t\t\tkeys.add(header.getName());\n\t\t}\n\t\treturn keys;\n\t}\n\n\t@Override\n\tpublic Collection<List<String>> values() {\n\t\tCollection<List<String>> values = new ArrayList<>(size());\n\t\tfor (Header header : this.message.getHeaders()) {\n\t\t\tvalues.add(get(header.getName()));\n\t\t}\n\t\treturn values;\n\t}\n\n\t@Override\n\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn new AbstractSet<>() {\n\t\t\t@Override\n\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn HttpComponentsHeadersAdapter.this.size();\n\t\t\t}\n\t\t};\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn HttpHeaders.formatHeaders(this);\n\t}\n\n\n\tprivate class EntryIterator implements Iterator<Entry<String, List<String>>> {\n\n\t\tprivate final Iterator<Header> iterator = message.headerIterator();\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn this.iterator.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic Entry<String, List<String>> next() {\n\t\t\treturn new HeaderEntry(this.iterator.next().getName());\n\t\t}\n\t}\n\n\n\tprivate class HeaderEntry implements Entry<String, List<String>> {\n\n\t\tprivate final String key;\n\n\t\tHeaderEntry(String key) {\n\t\t\tthis.key = key;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getKey() {\n\t\t\treturn this.key;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> getValue() {\n\t\t\tList<String> values = HttpComponentsHeadersAdapter.this.get(this.key);\n\t\t\treturn values != null ? values : Collections.emptyList();\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> setValue(List<String> value) {\n\t\t\tList<String> previousValues = getValue();\n\t\t\tHttpComponentsHeadersAdapter.this.put(this.key, value);\n\t\t\treturn previousValues;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#add(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "public void add(String key, @Nullable String value)",
    "source_code": "\tpublic void add(String key, @Nullable String value) {\n\t\tthis.message.addHeader(key, value);\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#addAll(MultiValueMap<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this::addAll);\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#addAll(key,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "public void addAll(String key, List<? extends String> values)",
    "source_code": "\tpublic void addAll(String key, List<? extends String> values) {\n\t\tvalues.forEach(value -> add(key, value));\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#clear()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\tpublic void clear() {\n\t\tthis.message.setHeaders();\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#containsKey(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "boolean",
    "signature": "public boolean containsKey(Object key)",
    "source_code": "\tpublic boolean containsKey(Object key) {\n\t\treturn (key instanceof String headerName && this.message.containsHeader(headerName));\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#containsValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "boolean",
    "signature": "public boolean containsValue(Object value)",
    "source_code": "\tpublic boolean containsValue(Object value) {\n\t\treturn (value instanceof String &&\n\t\t\t\tArrays.stream(this.message.getHeaders()).anyMatch(h -> h.getValue().equals(value)));\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#entrySet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "List<String>>>",
    "signature": "public List<String>>> entrySet()",
    "source_code": "\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn new AbstractSet<>() {\n\t\t\t@Override\n\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn HttpComponentsHeadersAdapter.this.size();\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#get(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "List<String>",
    "signature": "public List<String> get(Object key)",
    "source_code": "\tpublic List<String> get(Object key) {\n\t\tList<String> values = null;\n\t\tif (containsKey(key)) {\n\t\t\tHeader[] headers = this.message.getHeaders((String) key);\n\t\t\tvalues = new ArrayList<>(headers.length);\n\t\t\tfor (Header header : headers) {\n\t\t\t\tvalues.add(header.getValue());\n\t\t\t}\n\t\t}\n\t\treturn values;\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#getFirst(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "String",
    "signature": "public String getFirst(String key)",
    "source_code": "\tpublic String getFirst(String key) {\n\t\tHeader header = this.message.getFirstHeader(key);\n\t\treturn (header != null ? header.getValue() : null);\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#getKey()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "String",
    "signature": "public String getKey()",
    "source_code": "\t\tpublic String getKey() {\n\t\t\treturn this.key;\n\t\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#getValue()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 234
    },
    "return": "List<String>",
    "signature": "public List<String> getValue()",
    "source_code": "\t\tpublic List<String> getValue() {\n\t\t\tList<String> values = HttpComponentsHeadersAdapter.this.get(this.key);\n\t\t\treturn values != null ? values : Collections.emptyList();\n\t\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#hasNext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "boolean",
    "signature": "public boolean hasNext()",
    "source_code": "\t\tpublic boolean hasNext() {\n\t\t\treturn this.iterator.hasNext();\n\t\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#isEmpty()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "boolean",
    "signature": "public boolean isEmpty()",
    "source_code": "\tpublic boolean isEmpty() {\n\t\treturn (this.message.getHeaders().length == 0);\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#iterator()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "List<String>>>",
    "signature": "public List<String>>> iterator()",
    "source_code": "\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#keySet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "Set<String>",
    "signature": "public Set<String> keySet()",
    "source_code": "\tpublic Set<String> keySet() {\n\t\tSet<String> keys = new LinkedHashSet<>(size());\n\t\tfor (Header header : this.message.getHeaders()) {\n\t\t\tkeys.add(header.getName());\n\t\t}\n\t\treturn keys;\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#next()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "List<String>>",
    "signature": "public List<String>> next()",
    "source_code": "\t\tpublic Entry<String, List<String>> next() {\n\t\t\treturn new HeaderEntry(this.iterator.next().getName());\n\t\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#put(key,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> values)",
    "source_code": "\tpublic List<String> put(String key, List<String> values) {\n\t\tList<String> oldValues = remove(key);\n\t\tvalues.forEach(value -> add(key, value));\n\t\treturn oldValues;\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#putAll(String,map)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this::put);\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#remove(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "List<String>",
    "signature": "public List<String> remove(Object key)",
    "source_code": "\tpublic List<String> remove(Object key) {\n\t\tif (key instanceof String headerName) {\n\t\t\tList<String> oldValues = get(key);\n\t\t\tthis.message.removeHeaders(headerName);\n\t\t\treturn oldValues;\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#set(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "void",
    "signature": "public void set(String key, @Nullable String value)",
    "source_code": "\tpublic void set(String key, @Nullable String value) {\n\t\tthis.message.setHeader(key, value);\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#setAll(Map<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this::set);\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#setValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "List<String>",
    "signature": "public List<String> setValue(List<String> value)",
    "source_code": "\t\tpublic List<String> setValue(List<String> value) {\n\t\t\tList<String> previousValues = getValue();\n\t\t\tHttpComponentsHeadersAdapter.this.put(this.key, value);\n\t\t\treturn previousValues;\n\t\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#size()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "int",
    "signature": "public int size()",
    "source_code": "\t\t\tpublic int size() {\n\t\t\t\treturn HttpComponentsHeadersAdapter.this.size();\n\t\t\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#toSingleValueMap()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "String>",
    "signature": "public String> toSingleValueMap()",
    "source_code": "\tpublic Map<String, String> toSingleValueMap() {\n\t\tMap<String, String> map = CollectionUtils.newLinkedHashMap(size());\n\t\tthis.message.headerIterator().forEachRemaining(h -> map.putIfAbsent(h.getName(), h.getValue()));\n\t\treturn map;\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn HttpHeaders.formatHeaders(this);\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#values()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "Collection<List<String>>",
    "signature": "public Collection<List<String>> values()",
    "source_code": "\tpublic Collection<List<String>> values() {\n\t\tCollection<List<String>> values = new ArrayList<>(size());\n\t\tfor (Header header : this.message.getHeaders()) {\n\t\t\tvalues.add(get(header.getName()));\n\t\t}\n\t\treturn values;\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code MultiValueMap} implementation for wrapping Jetty HTTP headers.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 6.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "signature": "public class JettyHeadersAdapter",
    "source_code": "public final class JettyHeadersAdapter implements MultiValueMap<String, String> {\n\n\tprivate final HttpFields headers;\n\n\tprivate static final String IMMUTABLE_HEADER_ERROR = \"Immutable headers\";\n\n\n\t/**\n\t * Creates a new {@code JettyHeadersAdapter} based on the given\n\t * {@code HttpFields} instance.\n\t * @param headers the {@code HttpFields} to base this adapter on\n\t */\n\tpublic JettyHeadersAdapter(HttpFields headers) {\n\t\tAssert.notNull(headers, \"Headers must not be null\");\n\t\tthis.headers = headers;\n\t}\n\n\n\t@Override\n\tpublic String getFirst(String key) {\n\t\treturn this.headers.get(key);\n\t}\n\n\t@Override\n\tpublic void add(String key, @Nullable String value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tmutableHttpFields.add(key, value);\n\t}\n\n\t@Override\n\tpublic void addAll(String key, List<? extends String> values) {\n\t\tvalues.forEach(value -> add(key, value));\n\t}\n\n\t@Override\n\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this::addAll);\n\t}\n\n\t@Override\n\tpublic void set(String key, @Nullable String value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tmutableHttpFields.put(key, value);\n\t}\n\n\t@Override\n\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this::set);\n\t}\n\n\t@Override\n\tpublic Map<String, String> toSingleValueMap() {\n\t\tMap<String, String> singleValueMap = CollectionUtils.newLinkedHashMap(this.headers.size());\n\t\tIterator<HttpField> iterator = this.headers.iterator();\n\t\titerator.forEachRemaining(field -> {\n\t\t\tif (!singleValueMap.containsKey(field.getName())) {\n\t\t\t\tsingleValueMap.put(field.getName(), field.getValue());\n\t\t\t}\n\t\t});\n\t\treturn singleValueMap;\n\t}\n\n\t@Override\n\tpublic int size() {\n\t\treturn this.headers.getFieldNamesCollection().size();\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn (this.headers.size() == 0);\n\t}\n\n\t@Override\n\tpublic boolean containsKey(Object key) {\n\t\treturn (key instanceof String headerName && this.headers.contains(headerName));\n\t}\n\n\t@Override\n\tpublic boolean containsValue(Object value) {\n\t\treturn (value instanceof String searchString &&\n\t\t\t\tthis.headers.stream().anyMatch(field -> field.contains(searchString)));\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> get(Object key) {\n\t\tif (containsKey(key)) {\n\t\t\treturn this.headers.getValuesList((String) key);\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> put(String key, List<String> value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tList<String> oldValues = get(key);\n\t\tmutableHttpFields.put(key, value);\n\t\treturn oldValues;\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> remove(Object key) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tif (key instanceof String name) {\n\t\t\tList<String> oldValues = get(key);\n\t\t\tmutableHttpFields.remove(name);\n\t\t\treturn oldValues;\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this::put);\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tmutableHttpFields.clear();\n\t}\n\n\t@Override\n\tpublic Set<String> keySet() {\n\t\treturn new HeaderNames();\n\t}\n\n\t@Override\n\tpublic Collection<List<String>> values() {\n\t\treturn this.headers.getFieldNamesCollection().stream()\n\t\t\t\t.map(this.headers::getValuesList).toList();\n\t}\n\n\t@Override\n\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn new AbstractSet<>() {\n\t\t\t@Override\n\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn headers.size();\n\t\t\t}\n\t\t};\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn HttpHeaders.formatHeaders(this);\n\t}\n\n\n\tprivate class EntryIterator implements Iterator<Entry<String, List<String>>> {\n\n\t\tprivate final Iterator<String> names = headers.getFieldNamesCollection().iterator();\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn this.names.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic Entry<String, List<String>> next() {\n\t\t\treturn new HeaderEntry(this.names.next());\n\t\t}\n\t}\n\n\n\tprivate class HeaderEntry implements Entry<String, List<String>> {\n\n\t\tprivate final String key;\n\n\t\tHeaderEntry(String key) {\n\t\t\tthis.key = key;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getKey() {\n\t\t\treturn this.key;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> getValue() {\n\t\t\treturn headers.getValuesList(this.key);\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> setValue(List<String> value) {\n\t\t\tif (!(headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t\t}\n\t\t\tList<String> previousValues = headers.getValuesList(this.key);\n\t\t\tmutableHttpFields.put(this.key, value);\n\t\t\treturn previousValues;\n\t\t}\n\t}\n\n\n\tprivate class HeaderNames extends AbstractSet<String> {\n\n\t\t@Override\n\t\tpublic Iterator<String> iterator() {\n\t\t\treturn new HeaderNamesIterator(headers.getFieldNamesCollection().iterator());\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn headers.getFieldNamesCollection().size();\n\t\t}\n\t}\n\n\n\tprivate final class HeaderNamesIterator implements Iterator<String> {\n\n\t\tprivate final Iterator<String> iterator;\n\n\t\t@Nullable\n\t\tprivate String currentName;\n\n\t\tprivate HeaderNamesIterator(Iterator<String> iterator) {\n\t\t\tthis.iterator = iterator;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn this.iterator.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic String next() {\n\t\t\tthis.currentName = this.iterator.next();\n\t\t\treturn this.currentName;\n\t\t}\n\n\t\t@Override\n\t\tpublic void remove() {\n\t\t\tif (!(headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t\t}\n\t\t\tif (this.currentName == null) {\n\t\t\t\tthrow new IllegalStateException(\"No current Header in iterator\");\n\t\t\t}\n\t\t\tif (!headers.contains(this.currentName)) {\n\t\t\t\tthrow new IllegalStateException(\"Header not present: \" + this.currentName);\n\t\t\t}\n\t\t\tmutableHttpFields.remove(this.currentName);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#add(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "void",
    "signature": "public void add(String key, @Nullable String value)",
    "source_code": "\tpublic void add(String key, @Nullable String value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tmutableHttpFields.add(key, value);\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#addAll(MultiValueMap<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this::addAll);\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#addAll(key,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "void",
    "signature": "public void addAll(String key, List<? extends String> values)",
    "source_code": "\tpublic void addAll(String key, List<? extends String> values) {\n\t\tvalues.forEach(value -> add(key, value));\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#clear()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\tpublic void clear() {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tmutableHttpFields.clear();\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#containsKey(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "boolean",
    "signature": "public boolean containsKey(Object key)",
    "source_code": "\tpublic boolean containsKey(Object key) {\n\t\treturn (key instanceof String headerName && this.headers.contains(headerName));\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#containsValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "boolean",
    "signature": "public boolean containsValue(Object value)",
    "source_code": "\tpublic boolean containsValue(Object value) {\n\t\treturn (value instanceof String searchString &&\n\t\t\t\tthis.headers.stream().anyMatch(field -> field.contains(searchString)));\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#entrySet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "List<String>>>",
    "signature": "public List<String>>> entrySet()",
    "source_code": "\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn new AbstractSet<>() {\n\t\t\t@Override\n\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn headers.size();\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#get(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "List<String>",
    "signature": "public List<String> get(Object key)",
    "source_code": "\tpublic List<String> get(Object key) {\n\t\tif (containsKey(key)) {\n\t\t\treturn this.headers.getValuesList((String) key);\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#getFirst(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "String",
    "signature": "public String getFirst(String key)",
    "source_code": "\tpublic String getFirst(String key) {\n\t\treturn this.headers.get(key);\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#getKey()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 234
    },
    "return": "String",
    "signature": "public String getKey()",
    "source_code": "\t\tpublic String getKey() {\n\t\t\treturn this.key;\n\t\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#getValue()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "List<String>",
    "signature": "public List<String> getValue()",
    "source_code": "\t\tpublic List<String> getValue() {\n\t\t\treturn headers.getValuesList(this.key);\n\t\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#hasNext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "boolean",
    "signature": "public boolean hasNext()",
    "source_code": "\t\tpublic boolean hasNext() {\n\t\t\treturn this.iterator.hasNext();\n\t\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#isEmpty()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "boolean",
    "signature": "public boolean isEmpty()",
    "source_code": "\tpublic boolean isEmpty() {\n\t\treturn (this.headers.size() == 0);\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#iterator()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "Iterator<String>",
    "signature": "public Iterator<String> iterator()",
    "source_code": "\t\tpublic Iterator<String> iterator() {\n\t\t\treturn new HeaderNamesIterator(headers.getFieldNamesCollection().iterator());\n\t\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#keySet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "Set<String>",
    "signature": "public Set<String> keySet()",
    "source_code": "\tpublic Set<String> keySet() {\n\t\treturn new HeaderNames();\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#next()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "String",
    "signature": "public String next()",
    "source_code": "\t\tpublic String next() {\n\t\t\tthis.currentName = this.iterator.next();\n\t\t\treturn this.currentName;\n\t\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> value)",
    "source_code": "\tpublic List<String> put(String key, List<String> value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tList<String> oldValues = get(key);\n\t\tmutableHttpFields.put(key, value);\n\t\treturn oldValues;\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#putAll(String,map)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this::put);\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#remove()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "void",
    "signature": "public void remove()",
    "source_code": "\t\tpublic void remove() {\n\t\t\tif (!(headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t\t}\n\t\t\tif (this.currentName == null) {\n\t\t\t\tthrow new IllegalStateException(\"No current Header in iterator\");\n\t\t\t}\n\t\t\tif (!headers.contains(this.currentName)) {\n\t\t\t\tthrow new IllegalStateException(\"Header not present: \" + this.currentName);\n\t\t\t}\n\t\t\tmutableHttpFields.remove(this.currentName);\n\t\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#remove(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "List<String>",
    "signature": "public List<String> remove(Object key)",
    "source_code": "\tpublic List<String> remove(Object key) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tif (key instanceof String name) {\n\t\t\tList<String> oldValues = get(key);\n\t\t\tmutableHttpFields.remove(name);\n\t\t\treturn oldValues;\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#set(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "void",
    "signature": "public void set(String key, @Nullable String value)",
    "source_code": "\tpublic void set(String key, @Nullable String value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tmutableHttpFields.put(key, value);\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#setAll(Map<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this::set);\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#setValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "List<String>",
    "signature": "public List<String> setValue(List<String> value)",
    "source_code": "\t\tpublic List<String> setValue(List<String> value) {\n\t\t\tif (!(headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t\t}\n\t\t\tList<String> previousValues = headers.getValuesList(this.key);\n\t\t\tmutableHttpFields.put(this.key, value);\n\t\t\treturn previousValues;\n\t\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#size()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "int",
    "signature": "public int size()",
    "source_code": "\t\tpublic int size() {\n\t\t\treturn headers.getFieldNamesCollection().size();\n\t\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#toSingleValueMap()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "String>",
    "signature": "public String> toSingleValueMap()",
    "source_code": "\tpublic Map<String, String> toSingleValueMap() {\n\t\tMap<String, String> singleValueMap = CollectionUtils.newLinkedHashMap(this.headers.size());\n\t\tIterator<HttpField> iterator = this.headers.iterator();\n\t\titerator.forEachRemaining(field -> {\n\t\t\tif (!singleValueMap.containsKey(field.getName())) {\n\t\t\t\tsingleValueMap.put(field.getName(), field.getValue());\n\t\t\t}\n\t\t});\n\t\treturn singleValueMap;\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn HttpHeaders.formatHeaders(this);\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#values()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "Collection<List<String>>",
    "signature": "public Collection<List<String>> values()",
    "source_code": "\tpublic Collection<List<String>> values() {\n\t\treturn this.headers.getFieldNamesCollection().stream()\n\t\t\t\t.map(this.headers::getValuesList).toList();\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code MultiValueMap} implementation for wrapping Netty 4 HTTP headers.\n *\n * @author Rossen Stoyanchev\n * @author Sam Brannen\n * @since 6.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 40
    },
    "signature": "public class Netty4HeadersAdapter",
    "source_code": "public final class Netty4HeadersAdapter implements MultiValueMap<String, String> {\n\n\tprivate final HttpHeaders headers;\n\n\n\t/**\n\t * Creates a new {@code Netty4HeadersAdapter} based on the given\n\t * {@code HttpHeaders}.\n\t */\n\tpublic Netty4HeadersAdapter(HttpHeaders headers) {\n\t\tAssert.notNull(headers, \"Headers must not be null\");\n\t\tthis.headers = headers;\n\t}\n\n\n\t@Override\n\t@Nullable\n\tpublic String getFirst(String key) {\n\t\treturn this.headers.get(key);\n\t}\n\n\t@Override\n\tpublic void add(String key, @Nullable String value) {\n\t\tif (value != null) {\n\t\t\tthis.headers.add(key, value);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addAll(String key, List<? extends String> values) {\n\t\tthis.headers.add(key, values);\n\t}\n\n\t@Override\n\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this.headers::add);\n\t}\n\n\t@Override\n\tpublic void set(String key, @Nullable String value) {\n\t\tif (value != null) {\n\t\t\tthis.headers.set(key, value);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this.headers::set);\n\t}\n\n\t@Override\n\tpublic Map<String, String> toSingleValueMap() {\n\t\tMap<String, String> singleValueMap = CollectionUtils.newLinkedHashMap(this.headers.size());\n\t\tthis.headers.entries()\n\t\t\t\t.forEach(entry -> {\n\t\t\t\t\tif (!singleValueMap.containsKey(entry.getKey())) {\n\t\t\t\t\t\tsingleValueMap.put(entry.getKey(), entry.getValue());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\treturn singleValueMap;\n\t}\n\n\t@Override\n\tpublic int size() {\n\t\treturn this.headers.names().size();\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn this.headers.isEmpty();\n\t}\n\n\t@Override\n\tpublic boolean containsKey(Object key) {\n\t\treturn (key instanceof String headerName && this.headers.contains(headerName));\n\t}\n\n\t@Override\n\tpublic boolean containsValue(Object value) {\n\t\treturn (value instanceof String &&\n\t\t\t\tthis.headers.entries().stream()\n\t\t\t\t\t\t.anyMatch(entry -> value.equals(entry.getValue())));\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic List<String> get(Object key) {\n\t\tif (containsKey(key)) {\n\t\t\treturn this.headers.getAll((String) key);\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> put(String key, @Nullable List<String> value) {\n\t\tList<String> previousValues = this.headers.getAll(key);\n\t\tthis.headers.set(key, value);\n\t\treturn previousValues;\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> remove(Object key) {\n\t\tif (key instanceof String headerName) {\n\t\t\tList<String> previousValues = this.headers.getAll(headerName);\n\t\t\tthis.headers.remove(headerName);\n\t\t\treturn previousValues;\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this.headers::set);\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\tthis.headers.clear();\n\t}\n\n\t@Override\n\tpublic Set<String> keySet() {\n\t\treturn new HeaderNames();\n\t}\n\n\t@Override\n\tpublic Collection<List<String>> values() {\n\t\treturn this.headers.names().stream()\n\t\t\t\t.map(this.headers::getAll).toList();\n\t}\n\n\t@Override\n\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn new AbstractSet<>() {\n\t\t\t@Override\n\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn headers.size();\n\t\t\t}\n\t\t};\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn org.springframework.http.HttpHeaders.formatHeaders(this);\n\t}\n\n\n\tprivate class EntryIterator implements Iterator<Entry<String, List<String>>> {\n\n\t\tprivate final Iterator<String> names = headers.names().iterator();\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn this.names.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic Entry<String, List<String>> next() {\n\t\t\treturn new HeaderEntry(this.names.next());\n\t\t}\n\t}\n\n\n\tprivate class HeaderEntry implements Entry<String, List<String>> {\n\n\t\tprivate final String key;\n\n\t\tHeaderEntry(String key) {\n\t\t\tthis.key = key;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getKey() {\n\t\t\treturn this.key;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> getValue() {\n\t\t\treturn headers.getAll(this.key);\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> setValue(List<String> value) {\n\t\t\tList<String> previousValues = headers.getAll(this.key);\n\t\t\theaders.set(this.key, value);\n\t\t\treturn previousValues;\n\t\t}\n\t}\n\n\n\tprivate class HeaderNames extends AbstractSet<String> {\n\n\t\t@Override\n\t\tpublic Iterator<String> iterator() {\n\t\t\treturn new HeaderNamesIterator(headers.names().iterator());\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn headers.names().size();\n\t\t}\n\t}\n\n\tprivate final class HeaderNamesIterator implements Iterator<String> {\n\n\t\tprivate final Iterator<String> iterator;\n\n\t\t@Nullable\n\t\tprivate String currentName;\n\n\t\tprivate HeaderNamesIterator(Iterator<String> iterator) {\n\t\t\tthis.iterator = iterator;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn this.iterator.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic String next() {\n\t\t\tthis.currentName = this.iterator.next();\n\t\t\treturn this.currentName;\n\t\t}\n\n\t\t@Override\n\t\tpublic void remove() {\n\t\t\tif (this.currentName == null) {\n\t\t\t\tthrow new IllegalStateException(\"No current Header in iterator\");\n\t\t\t}\n\t\t\tif (!headers.contains(this.currentName)) {\n\t\t\t\tthrow new IllegalStateException(\"Header not present: \" + this.currentName);\n\t\t\t}\n\t\t\theaders.remove(this.currentName);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#add(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "void",
    "signature": "public void add(String key, @Nullable String value)",
    "source_code": "\tpublic void add(String key, @Nullable String value) {\n\t\tif (value != null) {\n\t\t\tthis.headers.add(key, value);\n\t\t}\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#addAll(MultiValueMap<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this.headers::add);\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#addAll(key,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "public void addAll(String key, List<? extends String> values)",
    "source_code": "\tpublic void addAll(String key, List<? extends String> values) {\n\t\tthis.headers.add(key, values);\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#clear()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\tpublic void clear() {\n\t\tthis.headers.clear();\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#containsKey(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "boolean",
    "signature": "public boolean containsKey(Object key)",
    "source_code": "\tpublic boolean containsKey(Object key) {\n\t\treturn (key instanceof String headerName && this.headers.contains(headerName));\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#containsValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "boolean",
    "signature": "public boolean containsValue(Object value)",
    "source_code": "\tpublic boolean containsValue(Object value) {\n\t\treturn (value instanceof String &&\n\t\t\t\tthis.headers.entries().stream()\n\t\t\t\t\t\t.anyMatch(entry -> value.equals(entry.getValue())));\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#entrySet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "List<String>>>",
    "signature": "public List<String>>> entrySet()",
    "source_code": "\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn new AbstractSet<>() {\n\t\t\t@Override\n\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn headers.size();\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#get(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "List<String>",
    "signature": "public List<String> get(Object key)",
    "source_code": "\tpublic List<String> get(Object key) {\n\t\tif (containsKey(key)) {\n\t\t\treturn this.headers.getAll((String) key);\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#getFirst(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "String",
    "signature": "public String getFirst(String key)",
    "source_code": "\tpublic String getFirst(String key) {\n\t\treturn this.headers.get(key);\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#getKey()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "String",
    "signature": "public String getKey()",
    "source_code": "\t\tpublic String getKey() {\n\t\t\treturn this.key;\n\t\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#getValue()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "List<String>",
    "signature": "public List<String> getValue()",
    "source_code": "\t\tpublic List<String> getValue() {\n\t\t\treturn headers.getAll(this.key);\n\t\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#hasNext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "boolean",
    "signature": "public boolean hasNext()",
    "source_code": "\t\tpublic boolean hasNext() {\n\t\t\treturn this.iterator.hasNext();\n\t\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#isEmpty()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "boolean",
    "signature": "public boolean isEmpty()",
    "source_code": "\tpublic boolean isEmpty() {\n\t\treturn this.headers.isEmpty();\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#iterator()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "Iterator<String>",
    "signature": "public Iterator<String> iterator()",
    "source_code": "\t\tpublic Iterator<String> iterator() {\n\t\t\treturn new HeaderNamesIterator(headers.names().iterator());\n\t\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#keySet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "Set<String>",
    "signature": "public Set<String> keySet()",
    "source_code": "\tpublic Set<String> keySet() {\n\t\treturn new HeaderNames();\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#next()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 268
    },
    "return": "String",
    "signature": "public String next()",
    "source_code": "\t\tpublic String next() {\n\t\t\tthis.currentName = this.iterator.next();\n\t\t\treturn this.currentName;\n\t\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, @Nullable List<String> value)",
    "source_code": "\tpublic List<String> put(String key, @Nullable List<String> value) {\n\t\tList<String> previousValues = this.headers.getAll(key);\n\t\tthis.headers.set(key, value);\n\t\treturn previousValues;\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#putAll(String,map)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this.headers::set);\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#remove()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "void",
    "signature": "public void remove()",
    "source_code": "\t\tpublic void remove() {\n\t\t\tif (this.currentName == null) {\n\t\t\t\tthrow new IllegalStateException(\"No current Header in iterator\");\n\t\t\t}\n\t\t\tif (!headers.contains(this.currentName)) {\n\t\t\t\tthrow new IllegalStateException(\"Header not present: \" + this.currentName);\n\t\t\t}\n\t\t\theaders.remove(this.currentName);\n\t\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#remove(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "List<String>",
    "signature": "public List<String> remove(Object key)",
    "source_code": "\tpublic List<String> remove(Object key) {\n\t\tif (key instanceof String headerName) {\n\t\t\tList<String> previousValues = this.headers.getAll(headerName);\n\t\t\tthis.headers.remove(headerName);\n\t\t\treturn previousValues;\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#set(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "public void set(String key, @Nullable String value)",
    "source_code": "\tpublic void set(String key, @Nullable String value) {\n\t\tif (value != null) {\n\t\t\tthis.headers.set(key, value);\n\t\t}\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#setAll(Map<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this.headers::set);\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#setValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "List<String>",
    "signature": "public List<String> setValue(List<String> value)",
    "source_code": "\t\tpublic List<String> setValue(List<String> value) {\n\t\t\tList<String> previousValues = headers.getAll(this.key);\n\t\t\theaders.set(this.key, value);\n\t\t\treturn previousValues;\n\t\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#size()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "int",
    "signature": "public int size()",
    "source_code": "\t\tpublic int size() {\n\t\t\treturn headers.names().size();\n\t\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#toSingleValueMap()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "String>",
    "signature": "public String> toSingleValueMap()",
    "source_code": "\tpublic Map<String, String> toSingleValueMap() {\n\t\tMap<String, String> singleValueMap = CollectionUtils.newLinkedHashMap(this.headers.size());\n\t\tthis.headers.entries()\n\t\t\t\t.forEach(entry -> {\n\t\t\t\t\tif (!singleValueMap.containsKey(entry.getKey())) {\n\t\t\t\t\t\tsingleValueMap.put(entry.getKey(), entry.getValue());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\treturn singleValueMap;\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn org.springframework.http.HttpHeaders.formatHeaders(this);\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#values()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "Collection<List<String>>",
    "signature": "public Collection<List<String>> values()",
    "source_code": "\tpublic Collection<List<String>> values() {\n\t\treturn this.headers.names().stream()\n\t\t\t\t.map(this.headers::getAll).toList();\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code MultiValueMap} implementation for wrapping Netty HTTP headers.\n *\n * @author Violeta Georgieva\n * @since 6.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public class Netty5HeadersAdapter",
    "source_code": "public final class Netty5HeadersAdapter implements MultiValueMap<String, String> {\n\n\tprivate final HttpHeaders headers;\n\n\n\t/**\n\t * Create a new {@code Netty5HeadersAdapter} based on the given\n\t * {@code HttpHeaders}.\n\t */\n\tpublic Netty5HeadersAdapter(HttpHeaders headers) {\n\t\tAssert.notNull(headers, \"Headers must not be null\");\n\t\tthis.headers = headers;\n\t}\n\n\n\t@Override\n\t@Nullable\n\tpublic String getFirst(String key) {\n\t\tCharSequence value = this.headers.get(key);\n\t\treturn (value != null ? value.toString() : null);\n\t}\n\n\t@Override\n\tpublic void add(String key, @Nullable String value) {\n\t\tif (value != null) {\n\t\t\tthis.headers.add(key, value);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addAll(String key, List<? extends String> values) {\n\t\tthis.headers.add(key, values);\n\t}\n\n\t@Override\n\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this.headers::add);\n\t}\n\n\t@Override\n\tpublic void set(String key, @Nullable String value) {\n\t\tif (value != null) {\n\t\t\tthis.headers.set(key, value);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this.headers::set);\n\t}\n\n\t@Override\n\tpublic Map<String, String> toSingleValueMap() {\n\t\tMap<String, String> singleValueMap = CollectionUtils.newLinkedHashMap(this.headers.size());\n\t\tthis.headers.forEach(entry -> singleValueMap.putIfAbsent(\n\t\t\t\tentry.getKey().toString(), entry.getValue().toString()));\n\t\treturn singleValueMap;\n\t}\n\n\t@Override\n\tpublic int size() {\n\t\treturn this.headers.names().size();\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn this.headers.isEmpty();\n\t}\n\n\t@Override\n\tpublic boolean containsKey(Object key) {\n\t\treturn (key instanceof String headerName && this.headers.contains(headerName));\n\t}\n\n\t@Override\n\tpublic boolean containsValue(Object value) {\n\t\treturn (value instanceof String &&\n\t\t\t\tStreamSupport.stream(this.headers.spliterator(), false)\n\t\t\t\t\t\t.anyMatch(entry -> value.equals(entry.getValue())));\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic List<String> get(Object key) {\n\t\tIterator<CharSequence> iterator = this.headers.valuesIterator((CharSequence) key);\n\t\tif (iterator.hasNext()) {\n\t\t\tList<String> result = new ArrayList<>();\n\t\t\titerator.forEachRemaining(value -> result.add(value.toString()));\n\t\t\treturn result;\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> put(String key, @Nullable List<String> value) {\n\t\tList<String> previousValues = get(key);\n\t\tthis.headers.set(key, value);\n\t\treturn previousValues;\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> remove(Object key) {\n\t\tif (key instanceof String headerName) {\n\t\t\tList<String> previousValues = get(headerName);\n\t\t\tthis.headers.remove(headerName);\n\t\t\treturn previousValues;\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this.headers::set);\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\tthis.headers.clear();\n\t}\n\n\t@Override\n\tpublic Set<String> keySet() {\n\t\treturn new HeaderNames();\n\t}\n\n\t@Override\n\tpublic Collection<List<String>> values() {\n\t\tList<List<String>> result = new ArrayList<>(this.headers.size());\n\t\tforEach((key, value) -> result.add(value));\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn new AbstractSet<>() {\n\t\t\t@Override\n\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn headers.size();\n\t\t\t}\n\t\t};\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn org.springframework.http.HttpHeaders.formatHeaders(this);\n\t}\n\n\n\tprivate class EntryIterator implements Iterator<Entry<String, List<String>>> {\n\n\t\tprivate final Iterator<CharSequence> names = headers.names().iterator();\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn this.names.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic Entry<String, List<String>> next() {\n\t\t\treturn new HeaderEntry(this.names.next());\n\t\t}\n\t}\n\n\n\tprivate class HeaderEntry implements Entry<String, List<String>> {\n\n\t\tprivate final CharSequence key;\n\n\t\tHeaderEntry(CharSequence key) {\n\t\t\tthis.key = key;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getKey() {\n\t\t\treturn this.key.toString();\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> getValue() {\n\t\t\tList<String> values = get(this.key);\n\t\t\treturn (values != null ? values : Collections.emptyList());\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> setValue(List<String> value) {\n\t\t\tList<String> previousValues = getValue();\n\t\t\theaders.set(this.key, value);\n\t\t\treturn previousValues;\n\t\t}\n\t}\n\n\tprivate class HeaderNames extends AbstractSet<String> {\n\n\t\t@Override\n\t\tpublic Iterator<String> iterator() {\n\t\t\treturn new HeaderNamesIterator(headers.names().iterator());\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn headers.names().size();\n\t\t}\n\t}\n\n\tprivate final class HeaderNamesIterator implements Iterator<String> {\n\n\t\tprivate final Iterator<CharSequence> iterator;\n\n\t\t@Nullable\n\t\tprivate CharSequence currentName;\n\n\t\tprivate HeaderNamesIterator(Iterator<CharSequence> iterator) {\n\t\t\tthis.iterator = iterator;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn this.iterator.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic String next() {\n\t\t\tthis.currentName = this.iterator.next();\n\t\t\treturn this.currentName.toString();\n\t\t}\n\n\t\t@Override\n\t\tpublic void remove() {\n\t\t\tif (this.currentName == null) {\n\t\t\t\tthrow new IllegalStateException(\"No current Header in iterator\");\n\t\t\t}\n\t\t\tif (!headers.contains(this.currentName)) {\n\t\t\t\tthrow new IllegalStateException(\"Header not present: \" + this.currentName);\n\t\t\t}\n\t\t\theaders.remove(this.currentName);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#add(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "void",
    "signature": "public void add(String key, @Nullable String value)",
    "source_code": "\tpublic void add(String key, @Nullable String value) {\n\t\tif (value != null) {\n\t\t\tthis.headers.add(key, value);\n\t\t}\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#addAll(MultiValueMap<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this.headers::add);\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#addAll(key,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "void",
    "signature": "public void addAll(String key, List<? extends String> values)",
    "source_code": "\tpublic void addAll(String key, List<? extends String> values) {\n\t\tthis.headers.add(key, values);\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#clear()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\tpublic void clear() {\n\t\tthis.headers.clear();\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#containsKey(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "boolean",
    "signature": "public boolean containsKey(Object key)",
    "source_code": "\tpublic boolean containsKey(Object key) {\n\t\treturn (key instanceof String headerName && this.headers.contains(headerName));\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#containsValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "boolean",
    "signature": "public boolean containsValue(Object value)",
    "source_code": "\tpublic boolean containsValue(Object value) {\n\t\treturn (value instanceof String &&\n\t\t\t\tStreamSupport.stream(this.headers.spliterator(), false)\n\t\t\t\t\t\t.anyMatch(entry -> value.equals(entry.getValue())));\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#entrySet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "List<String>>>",
    "signature": "public List<String>>> entrySet()",
    "source_code": "\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn new AbstractSet<>() {\n\t\t\t@Override\n\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn headers.size();\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#get(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "List<String>",
    "signature": "public List<String> get(Object key)",
    "source_code": "\tpublic List<String> get(Object key) {\n\t\tIterator<CharSequence> iterator = this.headers.valuesIterator((CharSequence) key);\n\t\tif (iterator.hasNext()) {\n\t\t\tList<String> result = new ArrayList<>();\n\t\t\titerator.forEachRemaining(value -> result.add(value.toString()));\n\t\t\treturn result;\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#getFirst(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "String",
    "signature": "public String getFirst(String key)",
    "source_code": "\tpublic String getFirst(String key) {\n\t\tCharSequence value = this.headers.get(key);\n\t\treturn (value != null ? value.toString() : null);\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#getKey()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "String",
    "signature": "public String getKey()",
    "source_code": "\t\tpublic String getKey() {\n\t\t\treturn this.key.toString();\n\t\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#getValue()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "List<String>",
    "signature": "public List<String> getValue()",
    "source_code": "\t\tpublic List<String> getValue() {\n\t\t\tList<String> values = get(this.key);\n\t\t\treturn (values != null ? values : Collections.emptyList());\n\t\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#hasNext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "boolean",
    "signature": "public boolean hasNext()",
    "source_code": "\t\tpublic boolean hasNext() {\n\t\t\treturn this.iterator.hasNext();\n\t\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#isEmpty()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "boolean",
    "signature": "public boolean isEmpty()",
    "source_code": "\tpublic boolean isEmpty() {\n\t\treturn this.headers.isEmpty();\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#iterator()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "Iterator<String>",
    "signature": "public Iterator<String> iterator()",
    "source_code": "\t\tpublic Iterator<String> iterator() {\n\t\t\treturn new HeaderNamesIterator(headers.names().iterator());\n\t\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#keySet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "Set<String>",
    "signature": "public Set<String> keySet()",
    "source_code": "\tpublic Set<String> keySet() {\n\t\treturn new HeaderNames();\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#next()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "String",
    "signature": "public String next()",
    "source_code": "\t\tpublic String next() {\n\t\t\tthis.currentName = this.iterator.next();\n\t\t\treturn this.currentName.toString();\n\t\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, @Nullable List<String> value)",
    "source_code": "\tpublic List<String> put(String key, @Nullable List<String> value) {\n\t\tList<String> previousValues = get(key);\n\t\tthis.headers.set(key, value);\n\t\treturn previousValues;\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#putAll(String,map)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this.headers::set);\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#remove()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 277
    },
    "return": "void",
    "signature": "public void remove()",
    "source_code": "\t\tpublic void remove() {\n\t\t\tif (this.currentName == null) {\n\t\t\t\tthrow new IllegalStateException(\"No current Header in iterator\");\n\t\t\t}\n\t\t\tif (!headers.contains(this.currentName)) {\n\t\t\t\tthrow new IllegalStateException(\"Header not present: \" + this.currentName);\n\t\t\t}\n\t\t\theaders.remove(this.currentName);\n\t\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#remove(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "List<String>",
    "signature": "public List<String> remove(Object key)",
    "source_code": "\tpublic List<String> remove(Object key) {\n\t\tif (key instanceof String headerName) {\n\t\t\tList<String> previousValues = get(headerName);\n\t\t\tthis.headers.remove(headerName);\n\t\t\treturn previousValues;\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#set(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "void",
    "signature": "public void set(String key, @Nullable String value)",
    "source_code": "\tpublic void set(String key, @Nullable String value) {\n\t\tif (value != null) {\n\t\t\tthis.headers.set(key, value);\n\t\t}\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#setAll(Map<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this.headers::set);\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#setValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 234
    },
    "return": "List<String>",
    "signature": "public List<String> setValue(List<String> value)",
    "source_code": "\t\tpublic List<String> setValue(List<String> value) {\n\t\t\tList<String> previousValues = getValue();\n\t\t\theaders.set(this.key, value);\n\t\t\treturn previousValues;\n\t\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#size()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "int",
    "signature": "public int size()",
    "source_code": "\t\tpublic int size() {\n\t\t\treturn headers.names().size();\n\t\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#toSingleValueMap()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "String>",
    "signature": "public String> toSingleValueMap()",
    "source_code": "\tpublic Map<String, String> toSingleValueMap() {\n\t\tMap<String, String> singleValueMap = CollectionUtils.newLinkedHashMap(this.headers.size());\n\t\tthis.headers.forEach(entry -> singleValueMap.putIfAbsent(\n\t\t\t\tentry.getKey().toString(), entry.getValue().toString()));\n\t\treturn singleValueMap;\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn org.springframework.http.HttpHeaders.formatHeaders(this);\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#values()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "Collection<List<String>>",
    "signature": "public Collection<List<String>> values()",
    "source_code": "\tpublic Collection<List<String>> values() {\n\t\tList<List<String>> result = new ArrayList<>(this.headers.size());\n\t\tforEach((key, value) -> result.add(value));\n\t\treturn result;\n\t}"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils#containsSqlScriptDelimiters(script,delimiter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the provided SQL script contains the specified delimiter.\n\t * <p>This method is intended to be used to find the string delimiting each\n\t * SQL statement &mdash; for example, a ';' character.\n\t * <p>Any occurrence of the delimiter within the script will be ignored if it\n\t * is within a <em>literal</em> block of text enclosed in single quotes\n\t * ({@code '}) or double quotes ({@code \"}), if it is escaped with a backslash\n\t * ({@code \\}), or if it is within a single-line comment or block comment.\n\t * @param script the SQL script to search within\n\t * @param delimiter the statement delimiter to search for\n\t * @see #DEFAULT_COMMENT_PREFIXES\n\t * @see #DEFAULT_BLOCK_COMMENT_START_DELIMITER\n\t * @see #DEFAULT_BLOCK_COMMENT_END_DELIMITER\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "script",
      "delimiter"
    ],
    "position": {
      "column": 1,
      "line": 430
    },
    "return": "boolean",
    "signature": "public boolean containsSqlScriptDelimiters(String script, String delimiter)",
    "source_code": "\tpublic static boolean containsSqlScriptDelimiters(String script, String delimiter) {\n\t\treturn containsStatementSeparator(null, script, delimiter, DEFAULT_COMMENT_PREFIXES,\n\t\t\tDEFAULT_BLOCK_COMMENT_START_DELIMITER, DEFAULT_BLOCK_COMMENT_END_DELIMITER);\n\t}"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils#readScript(lineNumberReader,commentPrefix,separator,blockCommentEndDelimiter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Read a script from the provided {@code LineNumberReader}, using the supplied\n\t * comment prefix and statement separator, and build a {@code String} containing\n\t * the lines.\n\t * <p>Lines <em>beginning</em> with the comment prefix are excluded from the\n\t * results; however, line comments anywhere else &mdash; for example, within\n\t * a statement &mdash; will be included in the results.\n\t * @param lineNumberReader the {@code LineNumberReader} containing the script\n\t * to be processed\n\t * @param commentPrefix the prefix that identifies comments in the SQL script\n\t * (typically \"--\")\n\t * @param separator the statement separator in the SQL script (typically \";\")\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter\n\t * @return a {@code String} containing the script lines\n\t * @throws IOException in case of I/O errors\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lineNumberReader",
      "commentPrefix",
      "separator",
      "blockCommentEndDelimiter"
    ],
    "position": {
      "column": 1,
      "line": 352
    },
    "return": "String",
    "signature": "public String readScript(LineNumberReader lineNumberReader, @Nullable String commentPrefix,\n\t\t\t@Nullable String separator, @Nullable String blockCommentEndDelimiter)",
    "source_code": "\tpublic static String readScript(LineNumberReader lineNumberReader, @Nullable String commentPrefix,"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils#readScript(lineNumberReader,commentPrefixes,separator,blockCommentEndDelimiter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Read a script from the provided {@code LineNumberReader}, using the supplied\n\t * comment prefixes and statement separator, and build a {@code String} containing\n\t * the lines.\n\t * <p>Lines <em>beginning</em> with one of the comment prefixes are excluded\n\t * from the results; however, line comments anywhere else &mdash; for example,\n\t * within a statement &mdash; will be included in the results.\n\t * @param lineNumberReader the {@code LineNumberReader} containing the script\n\t * to be processed\n\t * @param commentPrefixes the prefixes that identify comments in the SQL script\n\t * (typically \"--\")\n\t * @param separator the statement separator in the SQL script (typically \";\")\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter\n\t * @return a {@code String} containing the script lines\n\t * @throws IOException in case of I/O errors\n\t * @since 5.2\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lineNumberReader",
      "commentPrefixes",
      "separator",
      "blockCommentEndDelimiter"
    ],
    "position": {
      "column": 1,
      "line": 379
    },
    "return": "String",
    "signature": "public String readScript(LineNumberReader lineNumberReader, @Nullable String[] commentPrefixes,\n\t\t\t@Nullable String separator, @Nullable String blockCommentEndDelimiter)",
    "source_code": "\tpublic static String readScript(LineNumberReader lineNumberReader, @Nullable String[] commentPrefixes,"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils#splitSqlScript(resource,script,separator,commentPrefix,blockCommentStartDelimiter,blockCommentEndDelimiter,statements)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Split an SQL script into separate statements delimited by the provided\n\t * separator string. Each individual statement will be added to the provided\n\t * {@code List}.\n\t * <p>Within the script, the provided {@code commentPrefix} will be honored:\n\t * any text beginning with the comment prefix and extending to the end of the\n\t * line will be omitted from the output. Similarly, the provided\n\t * {@code blockCommentStartDelimiter} and {@code blockCommentEndDelimiter}\n\t * delimiters will be honored: any text enclosed in a block comment will be\n\t * omitted from the output. In addition, multiple adjacent whitespace characters\n\t * will be collapsed into a single space.\n\t * @param resource the resource from which the script was read\n\t * @param script the SQL script\n\t * @param separator text separating each statement\n\t * (typically a ';' or newline character)\n\t * @param commentPrefix the prefix that identifies SQL line comments\n\t * (typically \"--\")\n\t * @param blockCommentStartDelimiter the <em>start</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param statements the list that will contain the individual statements\n\t * @throws ScriptException if an error occurred while splitting the SQL script\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resource",
      "script",
      "separator",
      "commentPrefix",
      "blockCommentStartDelimiter",
      "blockCommentEndDelimiter",
      "statements"
    ],
    "position": {
      "column": 1,
      "line": 595
    },
    "return": "void",
    "signature": "public void splitSqlScript(@Nullable EncodedResource resource, String script,\n\t\t\tString separator, String commentPrefix, String blockCommentStartDelimiter,\n\t\t\tString blockCommentEndDelimiter, List<String> statements)",
    "source_code": "\tpublic static void splitSqlScript(@Nullable EncodedResource resource, String script,"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils#splitSqlScript(resource,script,separator,commentPrefixes,blockCommentStartDelimiter,blockCommentEndDelimiter,statements)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Split an SQL script into separate statements delimited by the provided\n\t * separator string. Each individual statement will be added to the provided\n\t * {@code List}.\n\t * <p>Within the script, the provided {@code commentPrefixes} will be honored:\n\t * any text beginning with one of the comment prefixes and extending to the\n\t * end of the line will be omitted from the output. Similarly, the provided\n\t * {@code blockCommentStartDelimiter} and {@code blockCommentEndDelimiter}\n\t * delimiters will be honored: any text enclosed in a block comment will be\n\t * omitted from the output. In addition, multiple adjacent whitespace characters\n\t * will be collapsed into a single space.\n\t * @param resource the resource from which the script was read\n\t * @param script the SQL script\n\t * @param separator text separating each statement\n\t * (typically a ';' or newline character)\n\t * @param commentPrefixes the prefixes that identify SQL line comments\n\t * (typically \"--\")\n\t * @param blockCommentStartDelimiter the <em>start</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param statements the list that will contain the individual statements\n\t * @throws ScriptException if an error occurred while splitting the SQL script\n\t * @since 5.2\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resource",
      "script",
      "separator",
      "commentPrefixes",
      "blockCommentStartDelimiter",
      "blockCommentEndDelimiter",
      "statements"
    ],
    "position": {
      "column": 1,
      "line": 632
    },
    "return": "void",
    "signature": "public void splitSqlScript(@Nullable EncodedResource resource, String script,\n\t\t\tString separator, String[] commentPrefixes, String blockCommentStartDelimiter,\n\t\t\tString blockCommentEndDelimiter, List<String> statements)",
    "source_code": "\tpublic static void splitSqlScript(@Nullable EncodedResource resource, String script,"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils#splitSqlScript(script,separator,statements)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Split an SQL script into separate statements delimited by the provided\n\t * separator string. Each individual statement will be added to the\n\t * provided {@code List}.\n\t * <p>Within the script, {@value #DEFAULT_COMMENT_PREFIX} will be used as the\n\t * comment prefix; any text beginning with the comment prefix and extending to\n\t * the end of the line will be omitted from the output. Similarly,\n\t * {@value #DEFAULT_BLOCK_COMMENT_START_DELIMITER} and\n\t * {@value #DEFAULT_BLOCK_COMMENT_END_DELIMITER} will be used as the\n\t * <em>start</em> and <em>end</em> block comment delimiters: any text enclosed\n\t * in a block comment will be omitted from the output. In addition, multiple\n\t * adjacent whitespace characters will be collapsed into a single space.\n\t * @param script the SQL script\n\t * @param separator text separating each statement\n\t * (typically a ';' or newline character)\n\t * @param statements the list that will contain the individual statements\n\t * @throws ScriptException if an error occurred while splitting the SQL script\n\t * @see #splitSqlScript(String, char, List)\n\t * @see #splitSqlScript(EncodedResource, String, String, String, String, String, List)\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "script",
      "separator",
      "statements"
    ],
    "position": {
      "column": 1,
      "line": 563
    },
    "return": "void",
    "signature": "public void splitSqlScript(String script, String separator, List<String> statements)",
    "source_code": "\tpublic static void splitSqlScript(String script, String separator, List<String> statements) throws ScriptException {\n\t\tsplitSqlScript(null, script, separator, DEFAULT_COMMENT_PREFIX, DEFAULT_BLOCK_COMMENT_START_DELIMITER,\n\t\t\t\tDEFAULT_BLOCK_COMMENT_END_DELIMITER, statements);\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#isRunning()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether there is currently an underlying connection.\n\t * @since 6.1\n\t * @see #start()\n\t * @see #stop()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 388
    },
    "return": "boolean",
    "signature": "public boolean isRunning()",
    "source_code": "\tpublic boolean isRunning() {\n\t\tsynchronized (this.connectionMonitor) {\n\t\t\treturn (this.connection != null);\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#start()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the underlying shared connection on start.\n\t * @since 6.1\n\t * @see #initConnection()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 362
    },
    "return": "void",
    "signature": "public void start()",
    "source_code": "\tpublic void start() {\n\t\ttry {\n\t\t\tinitConnection();\n\t\t}\n\t\tcatch (JMSException ex) {\n\t\t\tlogger.info(\"Start attempt failed for shared JMS Connection\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#stop()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Reset the underlying shared connection on stop.\n\t * @since 6.1\n\t * @see #resetConnection()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 377
    },
    "return": "void",
    "signature": "public void stop()",
    "source_code": "\tpublic void stop() {\n\t\tresetConnection();\n\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#clone()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 432
    },
    "return": "ReturnValueMethodParameter",
    "signature": "public ReturnValueMethodParameter clone()",
    "source_code": "\t\tpublic ReturnValueMethodParameter clone() {\n\t\t\treturn new ReturnValueMethodParameter(this);\n\t\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#findProvidedArgument(parameter,providedArgs)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 325
    },
    "return": "Object",
    "signature": "protected Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs)",
    "source_code": "\tprotected static Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs) {\n\t\tif (!ObjectUtils.isEmpty(providedArgs)) {\n\t\t\tfor (Object providedArg : providedArgs) {\n\t\t\t\tif (parameter.getParameterType().isInstance(providedArg)) {\n\t\t\t\t\treturn providedArg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#formatArgumentError(param,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "param",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 336
    },
    "return": "String",
    "signature": "protected String formatArgumentError(MethodParameter param, String message)",
    "source_code": "\tprotected static String formatArgumentError(MethodParameter param, String message) {\n\t\treturn \"Could not resolve parameter [\" + param.getParameterIndex() + \"] in \" +\n\t\t\t\tparam.getExecutable().toGenericString() + (StringUtils.hasText(message) ? \": \" + message : \"\");\n\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#getBridgedMethod()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * If the bean method is a bridge method, this method returns the bridged\n\t * (user-defined) method. Otherwise, it returns the same method as {@link #getMethod()}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "Method",
    "signature": "protected Method getBridgedMethod()",
    "source_code": "\tprotected Method getBridgedMethod() {\n\t\treturn this.bridgedMethod;\n\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#getMethod()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the method for this handler method.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "Method",
    "signature": "public Method getMethod()",
    "source_code": "\tpublic Method getMethod() {\n\t\treturn this.method;\n\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#getMethodAnnotation(annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 392
    },
    "return": "T",
    "signature": "public T getMethodAnnotation(Class<T> annotationType)",
    "source_code": "\t\tpublic <T extends Annotation> T getMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn HandlerMethod.this.getMethodAnnotation(annotationType);\n\t\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#getMethodParameters()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the method parameters for this handler method.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "MethodParameter[]",
    "signature": "public MethodParameter[] getMethodParameters()",
    "source_code": "\tpublic MethodParameter[] getMethodParameters() {\n\t\treturn this.parameters;\n\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#getReturnType()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the HandlerMethod return type.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 231
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter getReturnType()",
    "source_code": "\tpublic MethodParameter getReturnType() {\n\t\treturn new HandlerMethodParameter(-1);\n\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#getReturnValueType(returnValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the actual return value type.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue"
    ],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter getReturnValueType(@Nullable Object returnValue)",
    "source_code": "\tpublic MethodParameter getReturnValueType(@Nullable Object returnValue) {\n\t\treturn new ReturnValueMethodParameter(returnValue);\n\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#hasMethodAnnotation(annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 397
    },
    "return": "boolean",
    "signature": "public boolean hasMethodAnnotation(Class<T> annotationType)",
    "source_code": "\t\tpublic <T extends Annotation> boolean hasMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn HandlerMethod.this.hasMethodAnnotation(annotationType);\n\t\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#isVoid()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return {@code true} if the method return type is void, {@code false} otherwise.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 245
    },
    "return": "boolean",
    "signature": "public boolean isVoid()",
    "source_code": "\tpublic boolean isVoid() {\n\t\treturn Void.TYPE.equals(getReturnType().getParameterType());\n\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#toString()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 317
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn this.method.toGenericString();\n\t}"
  },
  "org.springframework.messaging.handler.HandlerMethodParameter": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * A MethodParameter with HandlerMethod-specific behavior.\n\t */",
    "kind": "class",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 376
    },
    "signature": "protected class HandlerMethodParameter",
    "source_code": "\tprotected class HandlerMethodParameter extends SynthesizingMethodParameter {\n\n\t\tpublic HandlerMethodParameter(int index) {\n\t\t\tsuper(HandlerMethod.this.bridgedMethod, index);\n\t\t}\n\n\t\tprotected HandlerMethodParameter(HandlerMethodParameter original) {\n\t\t\tsuper(original);\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<?> getContainingClass() {\n\t\t\treturn HandlerMethod.this.getBeanType();\n\t\t}\n\n\t\t@Override\n\t\tpublic <T extends Annotation> T getMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn HandlerMethod.this.getMethodAnnotation(annotationType);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T extends Annotation> boolean hasMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn HandlerMethod.this.hasMethodAnnotation(annotationType);\n\t\t}\n\n\t\t@Override\n\t\tpublic HandlerMethodParameter clone() {\n\t\t\treturn new HandlerMethodParameter(this);\n\t\t}\n\t}"
  },
  "org.springframework.mock.http.client.MockClientHttpResponse#getRawStatusCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "int",
    "signature": "public int getRawStatusCode()",
    "source_code": "\tpublic int getRawStatusCode() {\n\t\treturn this.statusCode.value();\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "signature": "public class BeanPropertyRowMapper",
    "source_code": "public class BeanPropertyRowMapper<T> implements Function<Readable, T> {\n\n\t/** Logger available to subclasses. */\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\t/** The class we are mapping to. */\n\t@Nullable\n\tprivate Class<T> mappedClass;\n\n\t/** Whether we're strictly validating. */\n\tprivate boolean checkFullyPopulated = false;\n\n\t/**\n\t * Whether {@code NULL} database values should be ignored for primitive\n\t * properties in the target class.\n\t * @see #setPrimitivesDefaultedForNullValue(boolean)\n\t */\n\tprivate boolean primitivesDefaultedForNullValue = false;\n\n\t/** ConversionService for binding R2DBC values to bean properties. */\n\t@Nullable\n\tprivate ConversionService conversionService = DefaultConversionService.getSharedInstance();\n\n\t/** Map of the properties we provide mapping for. */\n\t@Nullable\n\tprivate Map<String, PropertyDescriptor> mappedProperties;\n\n\t/** Set of bean property names we provide mapping for. */\n\t@Nullable\n\tprivate Set<String> mappedPropertyNames;\n\n\t/**\n\t * Create a new {@code BeanPropertyRowMapper}, accepting unpopulated\n\t * properties in the target bean.\n\t * @param mappedClass the class that each row/outParameters should be mapped to\n\t */\n\tpublic BeanPropertyRowMapper(Class<T> mappedClass) {\n\t\tinitialize(mappedClass);\n\t}\n\n\t/**\n\t * Create a new {@code BeanPropertyRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t * @param checkFullyPopulated whether we're strictly validating that\n\t * all bean properties have been mapped from corresponding database columns or\n\t * out-parameters\n\t */\n\tpublic BeanPropertyRowMapper(Class<T> mappedClass, boolean checkFullyPopulated) {\n\t\tinitialize(mappedClass);\n\t\tthis.checkFullyPopulated = checkFullyPopulated;\n\t}\n\n\n\t/**\n\t * Get the class that we are mapping to.\n\t */\n\t@Nullable\n\tpublic final Class<T> getMappedClass() {\n\t\treturn this.mappedClass;\n\t}\n\n\t/**\n\t * Set whether we're strictly validating that all bean properties have been mapped\n\t * from corresponding database columns or out-parameters.\n\t * <p>Default is {@code false}, accepting unpopulated properties in the target bean.\n\t */\n\tpublic void setCheckFullyPopulated(boolean checkFullyPopulated) {\n\t\tthis.checkFullyPopulated = checkFullyPopulated;\n\t}\n\n\t/**\n\t * Return whether we're strictly validating that all bean properties have been\n\t * mapped from corresponding database columns or out-parameters.\n\t */\n\tpublic boolean isCheckFullyPopulated() {\n\t\treturn this.checkFullyPopulated;\n\t}\n\n\t/**\n\t * Set whether a {@code NULL} database column or out-parameter value should\n\t * be ignored when mapping to a corresponding primitive property in the target class.\n\t * <p>Default is {@code false}, throwing an exception when nulls are mapped\n\t * to Java primitives.\n\t * <p>If this flag is set to {@code true} and you use an <em>ignored</em>\n\t * primitive property value from the mapped bean to update the database, the\n\t * value in the database will be changed from {@code NULL} to the current value\n\t * of that primitive property. That value may be the property's initial value\n\t * (potentially Java's default value for the respective primitive type), or\n\t * it may be some other value set for the property in the default constructor\n\t * (or initialization block) or as a side effect of setting some other property\n\t * in the mapped bean.\n\t */\n\tpublic void setPrimitivesDefaultedForNullValue(boolean primitivesDefaultedForNullValue) {\n\t\tthis.primitivesDefaultedForNullValue = primitivesDefaultedForNullValue;\n\t}\n\n\t/**\n\t * Get the value of the {@code primitivesDefaultedForNullValue} flag.\n\t * @see #setPrimitivesDefaultedForNullValue(boolean)\n\t */\n\tpublic boolean isPrimitivesDefaultedForNullValue() {\n\t\treturn this.primitivesDefaultedForNullValue;\n\t}\n\n\t/**\n\t * Set a {@link ConversionService} for binding R2DBC values to bean properties,\n\t * or {@code null} for none.\n\t * <p>Default is a {@link DefaultConversionService}. This provides support for\n\t * {@code java.time} conversion and other special types.\n\t * @see #initBeanWrapper(BeanWrapper)\n\t */\n\tpublic void setConversionService(@Nullable ConversionService conversionService) {\n\t\tthis.conversionService = conversionService;\n\t}\n\n\t/**\n\t * Return a {@link ConversionService} for binding R2DBC values to bean properties,\n\t * or {@code null} if none.\n\t */\n\t@Nullable\n\tpublic ConversionService getConversionService() {\n\t\treturn this.conversionService;\n\t}\n\n\n\t/**\n\t * Initialize the mapping meta-data for the given class.\n\t * @param mappedClass the mapped class\n\t */\n\tprotected void initialize(Class<T> mappedClass) {\n\t\tthis.mappedClass = mappedClass;\n\t\tthis.mappedProperties = new HashMap<>();\n\t\tthis.mappedPropertyNames = new HashSet<>();\n\n\t\tfor (PropertyDescriptor pd : BeanUtils.getPropertyDescriptors(mappedClass)) {\n\t\t\tif (pd.getWriteMethod() != null) {\n\t\t\t\tString lowerCaseName = lowerCaseName(pd.getName());\n\t\t\t\tthis.mappedProperties.put(lowerCaseName, pd);\n\t\t\t\tString underscoreName = underscoreName(pd.getName());\n\t\t\t\tif (!lowerCaseName.equals(underscoreName)) {\n\t\t\t\t\tthis.mappedProperties.put(underscoreName, pd);\n\t\t\t\t}\n\t\t\t\tthis.mappedPropertyNames.add(pd.getName());\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Remove the specified property from the mapped properties.\n\t * @param propertyName the property name (as used by property descriptors)\n\t */\n\tprotected void suppressProperty(String propertyName) {\n\t\tif (this.mappedProperties != null) {\n\t\t\tthis.mappedProperties.remove(lowerCaseName(propertyName));\n\t\t\tthis.mappedProperties.remove(underscoreName(propertyName));\n\t\t}\n\t}\n\n\t/**\n\t * Convert the given name to lower case.\n\t * <p>By default, conversions will happen within the US locale.\n\t * @param name the original name\n\t * @return the converted name\n\t */\n\tprotected String lowerCaseName(String name) {\n\t\treturn name.toLowerCase(Locale.US);\n\t}\n\n\t/**\n\t * Convert a name in camelCase to an underscored name in lower case.\n\t * <p>Any upper case letters are converted to lower case with a preceding underscore.\n\t * @param name the original name\n\t * @return the converted name\n\t * @see #lowerCaseName\n\t */\n\tprotected String underscoreName(String name) {\n\t\tif (!StringUtils.hasLength(name)) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tStringBuilder result = new StringBuilder();\n\t\tresult.append(Character.toLowerCase(name.charAt(0)));\n\t\tfor (int i = 1; i < name.length(); i++) {\n\t\t\tchar c = name.charAt(i);\n\t\t\tif (Character.isUpperCase(c)) {\n\t\t\t\tresult.append('_').append(Character.toLowerCase(c));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.append(c);\n\t\t\t}\n\t\t}\n\t\treturn result.toString();\n\t}\n\n\t/**\n\t * Extract the values for the current {@link Readable}: all columns in case\n\t * of a {@link Row} or all parameters in case of an {@link OutParameters}.\n\t * <p>Utilizes public setters and derives meta-data from the concrete type.\n\t * @throws IllegalArgumentException in case the concrete type is neither\n\t * {@code Row} nor {@code OutParameters}\n\t * @see RowMetadata\n\t * @see OutParametersMetadata\n\t */\n\t@Override\n\tpublic T apply(Readable readable) {\n\t\tif (readable instanceof Row row) {\n\t\t\treturn mapForReadable(row, row.getMetadata().getColumnMetadatas());\n\t\t}\n\t\tif (readable instanceof OutParameters out) {\n\t\t\treturn mapForReadable(out, out.getMetadata().getParameterMetadatas());\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Can only map Readable Row or OutParameters, got \" + readable.getClass().getName());\n\t}\n\n\tprivate <R extends Readable> T mapForReadable(R readable, List<? extends ReadableMetadata> readableMetadatas) {\n\t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n\t\tinitBeanWrapper(bw);\n\n\t\tT mappedObject = constructMappedInstance(readable, readableMetadatas, bw);\n\t\tbw.setBeanInstance(mappedObject);\n\n\t\tSet<String> populatedProperties = (isCheckFullyPopulated() ? new HashSet<>() : null);\n\t\tint readableItemCount = readableMetadatas.size();\n\t\tfor(int itemIndex = 0; itemIndex < readableItemCount; itemIndex++) {\n\t\t\tReadableMetadata itemMetadata = readableMetadatas.get(itemIndex);\n\t\t\tString itemName = itemMetadata.getName();\n\t\t\tString property = lowerCaseName(StringUtils.delete(itemName, \" \"));\n\t\t\tPropertyDescriptor pd = (this.mappedProperties != null ? this.mappedProperties.get(property) : null);\n\t\t\tif (pd != null) {\n\t\t\t\tObject value = getItemValue(readable, itemIndex, pd);\n\t\t\t\t// Implementation note: the JDBC mapper can log the column mapping details each time row 0 is encountered\n\t\t\t\t// but unfortunately this is not possible in R2DBC as row number is not provided. The BiFunction#apply\n\t\t\t\t// cannot be stateful as it could be applied to a different row set, e.g. when resubscribing.\n\t\t\t\ttry {\n\t\t\t\t\tbw.setPropertyValue(pd.getName(), value);\n\t\t\t\t}\n\t\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\t\tif (value == null && this.primitivesDefaultedForNullValue) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tString propertyType = ClassUtils.getQualifiedName(pd.getPropertyType());\n\t\t\t\t\t\t\t//here too, we miss the rowNumber information\n\t\t\t\t\t\t\tlogger.debug(\"\"\"\n\t\t\t\t\t\t\t\t\t\tIgnoring intercepted TypeMismatchException for item '%s' \\\n\t\t\t\t\t\t\t\t\t\twith null value when setting property '%s' of type '%s' on object: %s\"\n\t\t\t\t\t\t\t\t\t\t\"\"\".formatted(itemName, pd.getName(), propertyType, mappedObject), ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (populatedProperties != null) {\n\t\t\t\t\tpopulatedProperties.add(pd.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (populatedProperties != null && !populatedProperties.equals(this.mappedPropertyNames)) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\"Given readable does not contain all items \" +\n\t\t\t\t\t\"necessary to populate object of \" + this.mappedClass + \": \" + this.mappedPropertyNames);\n\t\t}\n\n\t\treturn mappedObject;\n\t}\n\n\t/**\n\t * Construct an instance of the mapped class for the current {@code Readable}.\n\t * <p>The default implementation simply instantiates the mapped class. Can be\n\t * overridden in subclasses.\n\t * @param readable the {@code Readable} being mapped (a {@code Row} or {@code OutParameters})\n\t * @param itemMetadatas the list of item {@code ReadableMetadata} (either\n\t * {@code ColumnMetadata} or {@code OutParameterMetadata})\n\t * @param tc a TypeConverter with this row mapper's conversion service\n\t * @return a corresponding instance of the mapped class\n\t */\n\tprotected T constructMappedInstance(Readable readable, List<? extends ReadableMetadata> itemMetadatas, TypeConverter tc) {\n\t\tAssert.state(this.mappedClass != null, \"Mapped class was not specified\");\n\t\treturn BeanUtils.instantiateClass(this.mappedClass);\n\t}\n\n\t/**\n\t * Initialize the given BeanWrapper to be used for row mapping or outParameters\n\t * mapping.\n\t * <p>To be called for each Readable.\n\t * <p>The default implementation applies the configured {@link ConversionService},\n\t * if any. Can be overridden in subclasses.\n\t * @param bw the BeanWrapper to initialize\n\t * @see #getConversionService()\n\t * @see BeanWrapper#setConversionService\n\t */\n\tprotected void initBeanWrapper(BeanWrapper bw) {\n\t\tConversionService cs = getConversionService();\n\t\tif (cs != null) {\n\t\t\tbw.setConversionService(cs);\n\t\t}\n\t}\n\n\t/**\n\t * Retrieve an R2DBC object value for the specified item index (a column or an\n\t * out-parameter).\n\t * <p>The default implementation delegates to\n\t * {@link #getItemValue(Readable, int, Class)}.\n\t * @param readable is the {@code Row} or {@code OutParameters} holding the data\n\t * @param itemIndex is the column index or out-parameter index\n\t * @param pd the bean property that each result object is expected to match\n\t * @return the Object value\n\t * @see #getItemValue(Readable, int, Class)\n\t */\n\t@Nullable\n\tprotected Object getItemValue(Readable readable, int itemIndex, PropertyDescriptor pd) {\n\t\treturn getItemValue(readable, itemIndex, pd.getPropertyType());\n\t}\n\n\t/**\n\t * Retrieve an R2DBC object value for the specified item index (a column or\n\t * an out-parameter).\n\t * <p>The default implementation calls {@link Readable#get(int, Class)} then\n\t * falls back to {@link Readable#get(int)} in case of an exception.\n\t * Subclasses may override this to check specific value types upfront,\n\t * or to post-process values returned from {@code get}.\n\t * @param readable is the {@code Row} or {@code OutParameters} holding the data\n\t * @param itemIndex is the column index or out-parameter index\n\t * @param paramType the target parameter type\n\t * @return the Object value\n\t * @see Readable#get(int, Class)\n\t * @see Readable#get(int)\n\t */\n\t@Nullable\n\tprotected Object getItemValue(Readable readable, int itemIndex, Class<?> paramType) {\n\t\ttry {\n\t\t\treturn readable.get(itemIndex, paramType);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\treturn readable.get(itemIndex);\n\t\t}\n\t}\n\n\n\t/**\n\t * Static factory method to create a new {@code BeanPropertyRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t * @see #newInstance(Class, ConversionService)\n\t */\n\tpublic static <T> BeanPropertyRowMapper<T> newInstance(Class<T> mappedClass) {\n\t\treturn new BeanPropertyRowMapper<>(mappedClass);\n\t}\n\n\t/**\n\t * Static factory method to create a new {@code BeanPropertyRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t * @param conversionService the {@link ConversionService} for binding\n\t * R2DBC values to bean properties, or {@code null} for none\n\t * @see #newInstance(Class)\n\t * @see #setConversionService\n\t */\n\tpublic static <T> BeanPropertyRowMapper<T> newInstance(\n\t\t\tClass<T> mappedClass, @Nullable ConversionService conversionService) {\n\n\t\tBeanPropertyRowMapper<T> rowMapper = newInstance(mappedClass);\n\t\trowMapper.setConversionService(conversionService);\n\t\treturn rowMapper;\n\t}\n\n}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#apply(readable)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extract the values for the current {@link Readable}: all columns in case\n\t * of a {@link Row} or all parameters in case of an {@link OutParameters}.\n\t * <p>Utilizes public setters and derives meta-data from the concrete type.\n\t * @throws IllegalArgumentException in case the concrete type is neither\n\t * {@code Row} nor {@code OutParameters}\n\t * @see RowMetadata\n\t * @see OutParametersMetadata\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "readable"
    ],
    "position": {
      "column": 1,
      "line": 300
    },
    "return": "T",
    "signature": "public T apply(Readable readable)",
    "source_code": "\tpublic T apply(Readable readable) {\n\t\tif (readable instanceof Row row) {\n\t\t\treturn mapForReadable(row, row.getMetadata().getColumnMetadatas());\n\t\t}\n\t\tif (readable instanceof OutParameters out) {\n\t\t\treturn mapForReadable(out, out.getMetadata().getParameterMetadatas());\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Can only map Readable Row or OutParameters, got \" + readable.getClass().getName());\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#constructMappedInstance(readable,itemMetadatas,tc)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Construct an instance of the mapped class for the current {@code Readable}.\n\t * <p>The default implementation simply instantiates the mapped class. Can be\n\t * overridden in subclasses.\n\t * @param readable the {@code Readable} being mapped (a {@code Row} or {@code OutParameters})\n\t * @param itemMetadatas the list of item {@code ReadableMetadata} (either\n\t * {@code ColumnMetadata} or {@code OutParameterMetadata})\n\t * @param tc a TypeConverter with this row mapper's conversion service\n\t * @return a corresponding instance of the mapped class\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "readable",
      "itemMetadatas",
      "tc"
    ],
    "position": {
      "column": 1,
      "line": 371
    },
    "return": "T",
    "signature": "protected T constructMappedInstance(Readable readable, List<? extends ReadableMetadata> itemMetadatas, TypeConverter tc)",
    "source_code": "\tprotected T constructMappedInstance(Readable readable, List<? extends ReadableMetadata> itemMetadatas, TypeConverter tc) {\n\t\tAssert.state(this.mappedClass != null, \"Mapped class was not specified\");\n\t\treturn BeanUtils.instantiateClass(this.mappedClass);\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#getConversionService()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ConversionService} for binding R2DBC values to bean properties,\n\t * or {@code null} if none.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "ConversionService",
    "signature": "public ConversionService getConversionService()",
    "source_code": "\tpublic ConversionService getConversionService() {\n\t\treturn this.conversionService;\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#getItemValue(readable,itemIndex,paramType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve an R2DBC object value for the specified item index (a column or\n\t * an out-parameter).\n\t * <p>The default implementation calls {@link Readable#get(int, Class)} then\n\t * falls back to {@link Readable#get(int)} in case of an exception.\n\t * Subclasses may override this to check specific value types upfront,\n\t * or to post-process values returned from {@code get}.\n\t * @param readable is the {@code Row} or {@code OutParameters} holding the data\n\t * @param itemIndex is the column index or out-parameter index\n\t * @param paramType the target parameter type\n\t * @return the Object value\n\t * @see Readable#get(int, Class)\n\t * @see Readable#get(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "readable",
      "itemIndex",
      "paramType"
    ],
    "position": {
      "column": 1,
      "line": 424
    },
    "return": "Object",
    "signature": "protected Object getItemValue(Readable readable, int itemIndex, Class<?> paramType)",
    "source_code": "\tprotected Object getItemValue(Readable readable, int itemIndex, Class<?> paramType) {\n\t\ttry {\n\t\t\treturn readable.get(itemIndex, paramType);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\treturn readable.get(itemIndex);\n\t\t}\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#getItemValue(readable,itemIndex,pd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve an R2DBC object value for the specified item index (a column or an\n\t * out-parameter).\n\t * <p>The default implementation delegates to\n\t * {@link #getItemValue(Readable, int, Class)}.\n\t * @param readable is the {@code Row} or {@code OutParameters} holding the data\n\t * @param itemIndex is the column index or out-parameter index\n\t * @param pd the bean property that each result object is expected to match\n\t * @return the Object value\n\t * @see #getItemValue(Readable, int, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "readable",
      "itemIndex",
      "pd"
    ],
    "position": {
      "column": 1,
      "line": 405
    },
    "return": "Object",
    "signature": "protected Object getItemValue(Readable readable, int itemIndex, PropertyDescriptor pd)",
    "source_code": "\tprotected Object getItemValue(Readable readable, int itemIndex, PropertyDescriptor pd) {\n\t\treturn getItemValue(readable, itemIndex, pd.getPropertyType());\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#getMappedClass()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the class that we are mapping to.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "Class<T>",
    "signature": "public Class<T> getMappedClass()",
    "source_code": "\tpublic final Class<T> getMappedClass() {\n\t\treturn this.mappedClass;\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#initBeanWrapper(bw)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the given BeanWrapper to be used for row mapping or outParameters\n\t * mapping.\n\t * <p>To be called for each Readable.\n\t * <p>The default implementation applies the configured {@link ConversionService},\n\t * if any. Can be overridden in subclasses.\n\t * @param bw the BeanWrapper to initialize\n\t * @see #getConversionService()\n\t * @see BeanWrapper#setConversionService\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bw"
    ],
    "position": {
      "column": 1,
      "line": 386
    },
    "return": "void",
    "signature": "protected void initBeanWrapper(BeanWrapper bw)",
    "source_code": "\tprotected void initBeanWrapper(BeanWrapper bw) {\n\t\tConversionService cs = getConversionService();\n\t\tif (cs != null) {\n\t\t\tbw.setConversionService(cs);\n\t\t}\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#initialize(mappedClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the mapping meta-data for the given class.\n\t * @param mappedClass the mapped class\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mappedClass"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "void",
    "signature": "protected void initialize(Class<T> mappedClass)",
    "source_code": "\tprotected void initialize(Class<T> mappedClass) {\n\t\tthis.mappedClass = mappedClass;\n\t\tthis.mappedProperties = new HashMap<>();\n\t\tthis.mappedPropertyNames = new HashSet<>();\n\n\t\tfor (PropertyDescriptor pd : BeanUtils.getPropertyDescriptors(mappedClass)) {\n\t\t\tif (pd.getWriteMethod() != null) {\n\t\t\t\tString lowerCaseName = lowerCaseName(pd.getName());\n\t\t\t\tthis.mappedProperties.put(lowerCaseName, pd);\n\t\t\t\tString underscoreName = underscoreName(pd.getName());\n\t\t\t\tif (!lowerCaseName.equals(underscoreName)) {\n\t\t\t\t\tthis.mappedProperties.put(underscoreName, pd);\n\t\t\t\t}\n\t\t\t\tthis.mappedPropertyNames.add(pd.getName());\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#isCheckFullyPopulated()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether we're strictly validating that all bean properties have been\n\t * mapped from corresponding database columns or out-parameters.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "boolean",
    "signature": "public boolean isCheckFullyPopulated()",
    "source_code": "\tpublic boolean isCheckFullyPopulated() {\n\t\treturn this.checkFullyPopulated;\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#isPrimitivesDefaultedForNullValue()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the value of the {@code primitivesDefaultedForNullValue} flag.\n\t * @see #setPrimitivesDefaultedForNullValue(boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "boolean",
    "signature": "public boolean isPrimitivesDefaultedForNullValue()",
    "source_code": "\tpublic boolean isPrimitivesDefaultedForNullValue() {\n\t\treturn this.primitivesDefaultedForNullValue;\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#lowerCaseName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given name to lower case.\n\t * <p>By default, conversions will happen within the US locale.\n\t * @param name the original name\n\t * @return the converted name\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "String",
    "signature": "protected String lowerCaseName(String name)",
    "source_code": "\tprotected String lowerCaseName(String name) {\n\t\treturn name.toLowerCase(Locale.US);\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#newInstance(mappedClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create a new {@code BeanPropertyRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t * @see #newInstance(Class, ConversionService)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedClass"
    ],
    "position": {
      "column": 1,
      "line": 439
    },
    "return": "BeanPropertyRowMapper<T>",
    "signature": "public BeanPropertyRowMapper<T> newInstance(Class<T> mappedClass)",
    "source_code": "\tpublic static <T> BeanPropertyRowMapper<T> newInstance(Class<T> mappedClass) {\n\t\treturn new BeanPropertyRowMapper<>(mappedClass);\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#newInstance(mappedClass,conversionService)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create a new {@code BeanPropertyRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t * @param conversionService the {@link ConversionService} for binding\n\t * R2DBC values to bean properties, or {@code null} for none\n\t * @see #newInstance(Class)\n\t * @see #setConversionService\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedClass",
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 451
    },
    "return": "BeanPropertyRowMapper<T>",
    "signature": "public BeanPropertyRowMapper<T> newInstance(Class<T> mappedClass, @Nullable ConversionService conversionService)",
    "source_code": "\tpublic static <T> BeanPropertyRowMapper<T> newInstance("
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#setCheckFullyPopulated(checkFullyPopulated)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether we're strictly validating that all bean properties have been mapped\n\t * from corresponding database columns or out-parameters.\n\t * <p>Default is {@code false}, accepting unpopulated properties in the target bean.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "checkFullyPopulated"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "void",
    "signature": "public void setCheckFullyPopulated(boolean checkFullyPopulated)",
    "source_code": "\tpublic void setCheckFullyPopulated(boolean checkFullyPopulated) {\n\t\tthis.checkFullyPopulated = checkFullyPopulated;\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#setConversionService(conversionService)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a {@link ConversionService} for binding R2DBC values to bean properties,\n\t * or {@code null} for none.\n\t * <p>Default is a {@link DefaultConversionService}. This provides support for\n\t * {@code java.time} conversion and other special types.\n\t * @see #initBeanWrapper(BeanWrapper)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "void",
    "signature": "public void setConversionService(@Nullable ConversionService conversionService)",
    "source_code": "\tpublic void setConversionService(@Nullable ConversionService conversionService) {\n\t\tthis.conversionService = conversionService;\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#setPrimitivesDefaultedForNullValue(primitivesDefaultedForNullValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether a {@code NULL} database column or out-parameter value should\n\t * be ignored when mapping to a corresponding primitive property in the target class.\n\t * <p>Default is {@code false}, throwing an exception when nulls are mapped\n\t * to Java primitives.\n\t * <p>If this flag is set to {@code true} and you use an <em>ignored</em>\n\t * primitive property value from the mapped bean to update the database, the\n\t * value in the database will be changed from {@code NULL} to the current value\n\t * of that primitive property. That value may be the property's initial value\n\t * (potentially Java's default value for the respective primitive type), or\n\t * it may be some other value set for the property in the default constructor\n\t * (or initialization block) or as a side effect of setting some other property\n\t * in the mapped bean.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "primitivesDefaultedForNullValue"
    ],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "void",
    "signature": "public void setPrimitivesDefaultedForNullValue(boolean primitivesDefaultedForNullValue)",
    "source_code": "\tpublic void setPrimitivesDefaultedForNullValue(boolean primitivesDefaultedForNullValue) {\n\t\tthis.primitivesDefaultedForNullValue = primitivesDefaultedForNullValue;\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#suppressProperty(propertyName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Remove the specified property from the mapped properties.\n\t * @param propertyName the property name (as used by property descriptors)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "propertyName"
    ],
    "position": {
      "column": 1,
      "line": 247
    },
    "return": "void",
    "signature": "protected void suppressProperty(String propertyName)",
    "source_code": "\tprotected void suppressProperty(String propertyName) {\n\t\tif (this.mappedProperties != null) {\n\t\t\tthis.mappedProperties.remove(lowerCaseName(propertyName));\n\t\t\tthis.mappedProperties.remove(underscoreName(propertyName));\n\t\t}\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#underscoreName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a name in camelCase to an underscored name in lower case.\n\t * <p>Any upper case letters are converted to lower case with a preceding underscore.\n\t * @param name the original name\n\t * @return the converted name\n\t * @see #lowerCaseName\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "String",
    "signature": "protected String underscoreName(String name)",
    "source_code": "\tprotected String underscoreName(String name) {\n\t\tif (!StringUtils.hasLength(name)) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tStringBuilder result = new StringBuilder();\n\t\tresult.append(Character.toLowerCase(name.charAt(0)));\n\t\tfor (int i = 1; i < name.length(); i++) {\n\t\t\tchar c = name.charAt(i);\n\t\t\tif (Character.isUpperCase(c)) {\n\t\t\t\tresult.append('_').append(Character.toLowerCase(c));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.append(c);\n\t\t\t}\n\t\t}\n\t\treturn result.toString();\n\t}"
  },
  "org.springframework.r2dbc.core.logger": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Logger available to subclasses. */",
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.scheduling.annotation.<unknown>#createSubscriptionRunnable(method,targetBean,scheduled,observationRegistrySupplier,subscriptionTrackerRegistry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link Runnable} for the Scheduled infrastructure, allowing for scheduled\n\t * subscription to the publisher produced by a reactive method.\n\t * <p>Note that the reactive method is invoked once, but the resulting {@code Publisher}\n\t * is subscribed to repeatedly, once per each invocation of the {@code Runnable}.\n\t * <p>In the case of a fixed-delay configuration, the subscription inside the\n\t * {@link Runnable} is turned into a blocking call in order to maintain fixed-delay\n\t * semantics (i.e. the task blocks until completion of the Publisher, and the\n\t * delay is applied until the next iteration).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetBean",
      "scheduled",
      "observationRegistrySupplier",
      "subscriptionTrackerRegistry"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "Runnable",
    "signature": "public Runnable createSubscriptionRunnable(Method method, Object targetBean, Scheduled scheduled,\n\t\t\tSupplier<ObservationRegistry> observationRegistrySupplier, List<Runnable> subscriptionTrackerRegistry)",
    "source_code": "\tpublic static Runnable createSubscriptionRunnable(Method method, Object targetBean, Scheduled scheduled,"
  },
  "org.springframework.scheduling.annotation.<unknown>#getQualifier()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "String",
    "signature": "public String getQualifier()",
    "source_code": "\t\tpublic String getQualifier() {\n\t\t\treturn this.qualifier;\n\t\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#isReactive(method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Checks that if the method is reactive, it can be scheduled. Methods are considered\n\t * eligible for reactive scheduling if they either return an instance of a type that\n\t * can be converted to {@code Publisher} or are a Kotlin suspending function.\n\t * If the method doesn't match these criteria, this check returns {@code false}.\n\t * <p>For scheduling of Kotlin suspending functions, the Coroutine-Reactor bridge\n\t * {@code kotlinx.coroutines.reactor} must be present at runtime (in order to invoke\n\t * suspending functions as a {@code Publisher}). Provided that is the case, this\n\t * method returns {@code true}. Otherwise, it throws an {@code IllegalStateException}.\n\t * @throws IllegalStateException if the method is reactive but Reactor and/or the\n\t * Kotlin coroutines bridge are not present at runtime\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "boolean",
    "signature": "public boolean isReactive(Method method)",
    "source_code": "\tpublic static boolean isReactive(Method method) {\n\t\tif (KotlinDetector.isKotlinPresent() && KotlinDetector.isSuspendingFunction(method)) {\n\t\t\t// Note that suspending functions declared without args have a single Continuation\n\t\t\t// parameter in reflective inspection\n\t\t\tAssert.isTrue(method.getParameterCount() == 1,\n\t\t\t\t\t\"Kotlin suspending functions may only be annotated with @Scheduled if declared without arguments\");\n\t\t\tAssert.isTrue(coroutinesReactorPresent, \"Kotlin suspending functions may only be annotated with \" +\n\t\t\t\t\t\"@Scheduled if the Coroutine-Reactor bridge (kotlinx.coroutines.reactor) is present at runtime\");\n\t\t\treturn true;\n\t\t}\n\t\tReactiveAdapterRegistry registry = ReactiveAdapterRegistry.getSharedInstance();\n\t\tif (!registry.hasAdapters()) {\n\t\t\treturn false;\n\t\t}\n\t\tClass<?> returnType = method.getReturnType();\n\t\tReactiveAdapter candidateAdapter = registry.getAdapter(returnType);\n\t\tif (candidateAdapter == null) {\n\t\t\treturn false;\n\t\t}\n\t\tAssert.isTrue(method.getParameterCount() == 0,\n\t\t\t\t\"Reactive methods may only be annotated with @Scheduled if declared without arguments\");\n\t\tAssert.isTrue(candidateAdapter.getDescriptor().isDeferred(),\n\t\t\t\t\"Reactive methods may only be annotated with @Scheduled if the return type supports deferred execution\");\n\t\treturn true;\n\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#onComplete()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 324
    },
    "return": "void",
    "signature": "public void onComplete()",
    "source_code": "\t\tpublic void onComplete() {\n\t\t\tthis.subscriptionTrackerRegistry.remove(this);\n\t\t\tif (this.observation.getContext() instanceof ScheduledTaskObservationContext context) {\n\t\t\t\tcontext.setComplete(true);\n\t\t\t}\n\t\t\tthis.observation.stop();\n\t\t\tif (this.blockingLatch != null) {\n\t\t\t\tthis.blockingLatch.countDown();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#onError(ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 313
    },
    "return": "void",
    "signature": "public void onError(Throwable ex)",
    "source_code": "\t\tpublic void onError(Throwable ex) {\n\t\t\tthis.subscriptionTrackerRegistry.remove(this);\n\t\t\tlogger.warn(\"Unexpected error occurred in scheduled reactive task\", ex);\n\t\t\tthis.observation.error(ex);\n\t\t\tthis.observation.stop();\n\t\t\tif (this.blockingLatch != null) {\n\t\t\t\tthis.blockingLatch.countDown();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#onNext(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "void",
    "signature": "public void onNext(Object obj)",
    "source_code": "\t\tpublic void onNext(Object obj) {\n\t\t\t// no-op\n\t\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#onSubscribe(subscription)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "subscription"
    ],
    "position": {
      "column": 1,
      "line": 301
    },
    "return": "void",
    "signature": "public void onSubscribe(Subscription subscription)",
    "source_code": "\t\tpublic void onSubscribe(Subscription subscription) {\n\t\t\tthis.subscription = subscription;\n\t\t\tthis.observation.start();\n\t\t\tsubscription.request(Integer.MAX_VALUE);\n\t\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#run()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "void",
    "signature": "public void run()",
    "source_code": "\t\tpublic void run() {\n\t\t\tif (this.subscription != null) {\n\t\t\t\tthis.subscription.cancel();\n\t\t\t\tthis.observation.stop();\n\t\t\t}\n\t\t\tif (this.blockingLatch != null) {\n\t\t\t\tthis.blockingLatch.countDown();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor#createRunnable(target,method,qualifier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link Runnable} for the given bean instance,\n\t * calling the specified scheduled method.\n\t * <p>The default implementation creates a {@link ScheduledMethodRunnable}.\n\t * @param target the target bean instance\n\t * @param method the scheduled method to call\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target",
      "method",
      "qualifier"
    ],
    "position": {
      "column": 1,
      "line": 526
    },
    "return": "Runnable",
    "signature": "protected Runnable createRunnable(Object target, Method method, @Nullable String qualifier)",
    "source_code": "\tprotected Runnable createRunnable(Object target, Method method, @Nullable String qualifier) {\n\t\tRunnable runnable = createRunnable(target, method);\n\t\tif (runnable != null) {\n\t\t\treturn runnable;\n\t\t}\n\t\tAssert.isTrue(method.getParameterCount() == 0, \"Only no-arg methods may be annotated with @Scheduled\");\n\t\tMethod invocableMethod = AopUtils.selectInvocableMethod(method, target.getClass());\n\t\treturn new ScheduledMethodRunnable(target, invocableMethod, qualifier, this.registrar::getObservationRegistry);\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#afterExecute(task,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An after-execute callback for framework subclasses to delegate to\n\t * (for start/stop handling), and possibly also for custom subclasses\n\t * to extend (making sure to call this implementation as well).\n\t * @param task the task that has been executed\n\t * @param ex the exception thrown during execution, if any\n\t * @since 6.1\n\t * @see ThreadPoolExecutor#afterExecute(Runnable, Throwable)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 469
    },
    "return": "void",
    "signature": "protected void afterExecute(Runnable task, @Nullable Throwable ex)",
    "source_code": "\tprotected void afterExecute(Runnable task, @Nullable Throwable ex) {\n\t\tthis.pauseLock.lock();\n\t\ttry {\n\t\t\tthis.executingTaskCount--;\n\t\t\tif (this.executingTaskCount == 0) {\n\t\t\t\tRunnable callback = this.stopCallback;\n\t\t\t\tif (callback != null) {\n\t\t\t\t\tcallback.run();\n\t\t\t\t\tthis.stopCallback = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tthis.pauseLock.unlock();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#beforeExecute(thread,task)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A before-execute callback for framework subclasses to delegate to\n\t * (for start/stop handling), and possibly also for custom subclasses\n\t * to extend (making sure to call this implementation as well).\n\t * @param thread the thread to run the task\n\t * @param task the task to be executed\n\t * @since 6.1\n\t * @see ThreadPoolExecutor#beforeExecute(Thread, Runnable)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "thread",
      "task"
    ],
    "position": {
      "column": 1,
      "line": 444
    },
    "return": "void",
    "signature": "protected void beforeExecute(Thread thread, Runnable task)",
    "source_code": "\tprotected void beforeExecute(Thread thread, Runnable task) {\n\t\tthis.pauseLock.lock();\n\t\ttry {\n\t\t\twhile (this.paused && this.executor != null && !this.executor.isShutdown()) {\n\t\t\t\tthis.unpaused.await();\n\t\t\t}\n\t\t}\n\t\tcatch (InterruptedException ex) {\n\t\t\tthread.interrupt();\n\t\t}\n\t\tfinally {\n\t\t\tthis.executingTaskCount++;\n\t\t\tthis.pauseLock.unlock();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#getPhase()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the lifecycle phase for pausing and resuming this executor.\n\t * @since 6.1\n\t * @see #setPhase\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 226
    },
    "return": "int",
    "signature": "public int getPhase()",
    "source_code": "\tpublic int getPhase() {\n\t\treturn this.phase;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#initiateShutdown()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initiate a shutdown on the underlying ExecutorService,\n\t * rejecting further task submissions.\n\t * <p>The executor will not accept further tasks and will prevent further\n\t * scheduling of periodic tasks, letting existing tasks complete still.\n\t * This step is non-blocking and can be applied as an early shutdown signal\n\t * before following up with a full {@link #shutdown()} call later on.\n\t * @since 6.1\n\t * @see #shutdown()\n\t * @see java.util.concurrent.ExecutorService#shutdown()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 295
    },
    "return": "void",
    "signature": "public void initiateShutdown()",
    "source_code": "\tpublic void initiateShutdown() {\n\t\tif (this.executor != null) {\n\t\t\tthis.executor.shutdown();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#isRunning()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether this executor is not paused and has not been shut down either.\n\t * @since 6.1\n\t * @see #start()\n\t * @see #stop()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 431
    },
    "return": "boolean",
    "signature": "public boolean isRunning()",
    "source_code": "\tpublic boolean isRunning() {\n\t\treturn (this.executor != null && !this.executor.isShutdown() & !this.paused);\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#onApplicationEvent(event)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@link ContextClosedEvent} handler for initiating an early shutdown.\n\t * @since 6.1\n\t * @see #initiateShutdown()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "event"
    ],
    "position": {
      "column": 1,
      "line": 492
    },
    "return": "void",
    "signature": "public void onApplicationEvent(ContextClosedEvent event)",
    "source_code": "\tpublic void onApplicationEvent(ContextClosedEvent event) {\n\t\tif (event.getApplicationContext() == this.applicationContext && !this.acceptTasksAfterContextClose) {\n\t\t\t// Early shutdown signal: accept no further tasks, let existing tasks complete\n\t\t\t// before hitting the actual destruction step in the shutdown() method above.\n\t\t\tinitiateShutdown();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#setAcceptTasksAfterContextClose(acceptTasksAfterContextClose)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to accept further tasks after the application context close phase\n\t * has begun.\n\t * <p>Default is {@code false} as of 6.1, triggering an early soft shutdown of\n\t * the executor and therefore rejecting any further task submissions. Switch this\n\t * to {@code true} in order to let other components submit tasks even during their\n\t * own destruction callbacks, at the expense of a longer shutdown phase.\n\t * This will usually go along with\n\t * {@link #setWaitForTasksToCompleteOnShutdown \"waitForTasksToCompleteOnShutdown\"}.\n\t * <p>This flag will only have effect when the executor is running in a Spring\n\t * application context and able to receive the {@link ContextClosedEvent}.\n\t * @since 6.1\n\t * @see org.springframework.context.ConfigurableApplicationContext#close()\n\t * @see DisposableBean#destroy()\n\t * @see #shutdown()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "acceptTasksAfterContextClose"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "void",
    "signature": "public void setAcceptTasksAfterContextClose(boolean acceptTasksAfterContextClose)",
    "source_code": "\tpublic void setAcceptTasksAfterContextClose(boolean acceptTasksAfterContextClose) {\n\t\tthis.acceptTasksAfterContextClose = acceptTasksAfterContextClose;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#setApplicationContext(applicationContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "applicationContext"
    ],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "void",
    "signature": "public void setApplicationContext(ApplicationContext applicationContext)",
    "source_code": "\tpublic void setApplicationContext(ApplicationContext applicationContext) {\n\t\tthis.applicationContext = applicationContext;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#setPhase(phase)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the lifecycle phase for pausing and resuming this executor.\n\t * The default is {@link #DEFAULT_PHASE}.\n\t * @since 6.1\n\t * @see SmartLifecycle#getPhase()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "phase"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "void",
    "signature": "public void setPhase(int phase)",
    "source_code": "\tpublic void setPhase(int phase) {\n\t\tthis.phase = phase;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#start()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resume this executor if paused before (otherwise a no-op).\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 374
    },
    "return": "void",
    "signature": "public void start()",
    "source_code": "\tpublic void start() {\n\t\tthis.pauseLock.lock();\n\t\ttry {\n\t\t\tthis.paused = false;\n\t\t\tthis.unpaused.signalAll();\n\t\t}\n\t\tfinally {\n\t\t\tthis.pauseLock.unlock();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#stop()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Pause this executor, not waiting for tasks to complete.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 390
    },
    "return": "void",
    "signature": "public void stop()",
    "source_code": "\tpublic void stop() {\n\t\tthis.pauseLock.lock();\n\t\ttry {\n\t\t\tthis.paused = true;\n\t\t\tthis.stopCallback = null;\n\t\t}\n\t\tfinally {\n\t\t\tthis.pauseLock.unlock();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#stop(callback)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Pause this executor, triggering the given callback\n\t * once all currently executing tasks have completed.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 407
    },
    "return": "void",
    "signature": "public void stop(Runnable callback)",
    "source_code": "\tpublic void stop(Runnable callback) {\n\t\tthis.pauseLock.lock();\n\t\ttry {\n\t\t\tthis.paused = true;\n\t\t\tif (this.executingTaskCount == 0) {\n\t\t\t\tthis.stopCallback = null;\n\t\t\t\tcallback.run();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.stopCallback = callback;\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tthis.pauseLock.unlock();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean#afterExecute(task,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "void",
    "signature": "protected void afterExecute(Runnable task, Throwable ex)",
    "source_code": "\t\t\tprotected void afterExecute(Runnable task, Throwable ex) {\n\t\t\t\tScheduledExecutorFactoryBean.this.afterExecute(task, ex);\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean#beforeExecute(thread,task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "thread",
      "task"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "void",
    "signature": "protected void beforeExecute(Thread thread, Runnable task)",
    "source_code": "\t\t\tprotected void beforeExecute(Thread thread, Runnable task) {\n\t\t\t\tScheduledExecutorFactoryBean.this.beforeExecute(thread, task);\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#afterExecute(task,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "void",
    "signature": "protected void afterExecute(Runnable task, Throwable ex)",
    "source_code": "\t\t\tprotected void afterExecute(Runnable task, Throwable ex) {\n\t\t\t\tThreadPoolTaskExecutor.this.afterExecute(task, ex);\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#beforeExecute(thread,task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "thread",
      "task"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "void",
    "signature": "protected void beforeExecute(Thread thread, Runnable task)",
    "source_code": "\t\t\tprotected void beforeExecute(Thread thread, Runnable task) {\n\t\t\t\tThreadPoolTaskExecutor.this.beforeExecute(thread, task);\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#execute(task,startTimeout)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "startTimeout"
    ],
    "position": {
      "column": 1,
      "line": 369
    },
    "return": "void",
    "signature": "public void execute(Runnable task, long startTimeout)",
    "source_code": "\tpublic void execute(Runnable task, long startTimeout) {\n\t\texecute(task);\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#afterExecute(task,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "void",
    "signature": "protected void afterExecute(Runnable task, Throwable ex)",
    "source_code": "\t\t\tprotected void afterExecute(Runnable task, Throwable ex) {\n\t\t\t\tThreadPoolTaskScheduler.this.afterExecute(task, ex);\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#beforeExecute(thread,task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "thread",
      "task"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "void",
    "signature": "protected void beforeExecute(Thread thread, Runnable task)",
    "source_code": "\t\t\tprotected void beforeExecute(Thread thread, Runnable task) {\n\t\t\t\tThreadPoolTaskScheduler.this.beforeExecute(thread, task);\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#execute(task,startTimeout)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "startTimeout"
    ],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "void",
    "signature": "public void execute(Runnable task, long startTimeout)",
    "source_code": "\tpublic void execute(Runnable task, long startTimeout) {\n\t\texecute(task);\n\t}"
  },
  "org.springframework.scheduling.config.DEFAULT_TASK_SCHEDULER_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The default name of the {@link TaskScheduler} bean to pick up: {@value}.\n\t * <p>Note that the initial lookup happens by type; this is just the fallback\n\t * in case of multiple scheduler beans found in the context.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "signature": "public String DEFAULT_TASK_SCHEDULER_BEAN_NAME",
    "source_code": "\tpublic static final String DEFAULT_TASK_SCHEDULER_BEAN_NAME = \"taskScheduler\";",
    "type": "String"
  },
  "org.springframework.scheduling.config.ScheduledTaskRegistrar#getObservationRegistry()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link ObservationRegistry} for this registrar.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "ObservationRegistry",
    "signature": "public ObservationRegistry getObservationRegistry()",
    "source_code": "\tpublic ObservationRegistry getObservationRegistry() {\n\t\treturn this.observationRegistry;\n\t}"
  },
  "org.springframework.scheduling.config.ScheduledTaskRegistrar#setObservationRegistry(observationRegistry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure an {@link ObservationRegistry} to record observations for scheduled tasks.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "observationRegistry"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "void",
    "signature": "public void setObservationRegistry(@Nullable ObservationRegistry observationRegistry)",
    "source_code": "\tpublic void setObservationRegistry(@Nullable ObservationRegistry observationRegistry) {\n\t\tthis.observationRegistry = observationRegistry;\n\t}"
  },
  "org.springframework.scheduling.config.TaskSchedulerRouter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A routing implementation of the {@link TaskScheduler} interface,\n * delegating to a target scheduler based on an identified qualifier\n * or using a default scheduler otherwise.\n *\n * @author Juergen Hoeller\n * @since 6.1\n * @see SchedulingAwareRunnable#getQualifier()\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "signature": "public class TaskSchedulerRouter",
    "source_code": "public class TaskSchedulerRouter implements TaskScheduler, BeanNameAware, BeanFactoryAware, DisposableBean {\n\n\t/**\n\t * The default name of the {@link TaskScheduler} bean to pick up: {@value}.\n\t * <p>Note that the initial lookup happens by type; this is just the fallback\n\t * in case of multiple scheduler beans found in the context.\n\t */\n\tpublic static final String DEFAULT_TASK_SCHEDULER_BEAN_NAME = \"taskScheduler\";\n\n\n\tprotected static final Log logger = LogFactory.getLog(TaskSchedulerRouter.class);\n\n\t@Nullable\n\tprivate String beanName;\n\n\t@Nullable\n\tprivate BeanFactory beanFactory;\n\n\t@Nullable\n\tprivate StringValueResolver embeddedValueResolver;\n\n\tprivate final Supplier<TaskScheduler> defaultScheduler = SingletonSupplier.of(this::determineDefaultScheduler);\n\n\t@Nullable\n\tprivate volatile ScheduledExecutorService localExecutor;\n\n\n\t/**\n\t * The bean name for this router, or the bean name of the containing\n\t * bean if the router instance is internally held.\n\t */\n\t@Override\n\tpublic void setBeanName(@Nullable String name) {\n\t\tthis.beanName = name;\n\t}\n\n\t/**\n\t * The bean factory for scheduler lookups.\n\t */\n\t@Override\n\tpublic void setBeanFactory(@Nullable BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t\tif (beanFactory instanceof ConfigurableBeanFactory configurableBeanFactory) {\n\t\t\tthis.embeddedValueResolver = new EmbeddedValueResolver(configurableBeanFactory);\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic ScheduledFuture<?> schedule(Runnable task, Trigger trigger) {\n\t\treturn determineTargetScheduler(task).schedule(task, trigger);\n\t}\n\n\t@Override\n\tpublic ScheduledFuture<?> schedule(Runnable task, Instant startTime) {\n\t\treturn determineTargetScheduler(task).schedule(task, startTime);\n\t}\n\n\t@Override\n\tpublic ScheduledFuture<?> scheduleAtFixedRate(Runnable task, Instant startTime, Duration period) {\n\t\treturn determineTargetScheduler(task).scheduleAtFixedRate(task, startTime, period);\n\t}\n\n\t@Override\n\tpublic ScheduledFuture<?> scheduleAtFixedRate(Runnable task, Duration period) {\n\t\treturn determineTargetScheduler(task).scheduleAtFixedRate(task, period);\n\t}\n\n\t@Override\n\tpublic ScheduledFuture<?> scheduleWithFixedDelay(Runnable task, Instant startTime, Duration delay) {\n\t\treturn determineTargetScheduler(task).scheduleWithFixedDelay(task, startTime, delay);\n\t}\n\n\t@Override\n\tpublic ScheduledFuture<?> scheduleWithFixedDelay(Runnable task, Duration delay) {\n\t\treturn determineTargetScheduler(task).scheduleWithFixedDelay(task, delay);\n\t}\n\n\n\tprotected TaskScheduler determineTargetScheduler(Runnable task) {\n\t\tString qualifier = determineQualifier(task);\n\t\tif (this.embeddedValueResolver != null && StringUtils.hasLength(qualifier)) {\n\t\t\tqualifier = this.embeddedValueResolver.resolveStringValue(qualifier);\n\t\t}\n\t\tif (StringUtils.hasLength(qualifier)) {\n\t\t\treturn determineQualifiedScheduler(qualifier);\n\t\t}\n\t\telse {\n\t\t\treturn this.defaultScheduler.get();\n\t\t}\n\t}\n\n\t@Nullable\n\tprotected String determineQualifier(Runnable task) {\n\t\treturn (task instanceof SchedulingAwareRunnable sar ? sar.getQualifier() : null);\n\t}\n\n\tprotected TaskScheduler determineQualifiedScheduler(String qualifier) {\n\t\tAssert.state(this.beanFactory != null, \"BeanFactory must be set to find qualified scheduler\");\n\t\ttry {\n\t\t\treturn BeanFactoryAnnotationUtils.qualifiedBeanOfType(this.beanFactory, TaskScheduler.class, qualifier);\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException | BeanNotOfRequiredTypeException ex) {\n\t\t\treturn new ConcurrentTaskScheduler(BeanFactoryAnnotationUtils.qualifiedBeanOfType(\n\t\t\t\t\tthis.beanFactory, ScheduledExecutorService.class, qualifier));\n\t\t}\n\t}\n\n\tprotected TaskScheduler determineDefaultScheduler() {\n\t\tAssert.state(this.beanFactory != null, \"BeanFactory must be set to find default scheduler\");\n\t\ttry {\n\t\t\t// Search for TaskScheduler bean...\n\t\t\treturn resolveSchedulerBean(this.beanFactory, TaskScheduler.class, false);\n\t\t}\n\t\tcatch (NoUniqueBeanDefinitionException ex) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Could not find unique TaskScheduler bean - attempting to resolve by name: \" +\n\t\t\t\t\t\tex.getMessage());\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn resolveSchedulerBean(this.beanFactory, TaskScheduler.class, true);\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex2) {\n\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\tlogger.info(\"More than one TaskScheduler bean exists within the context, and \" +\n\t\t\t\t\t\t\t\"none is named 'taskScheduler'. Mark one of them as primary or name it 'taskScheduler' \" +\n\t\t\t\t\t\t\t\"(possibly as an alias); or implement the SchedulingConfigurer interface and call \" +\n\t\t\t\t\t\t\t\"ScheduledTaskRegistrar#setScheduler explicitly within the configureTasks() callback: \" +\n\t\t\t\t\t\t\tex.getBeanNamesFound());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Could not find default TaskScheduler bean - attempting to find ScheduledExecutorService: \" +\n\t\t\t\t\t\tex.getMessage());\n\t\t\t}\n\t\t\t// Search for ScheduledExecutorService bean next...\n\t\t\ttry {\n\t\t\t\treturn new ConcurrentTaskScheduler(resolveSchedulerBean(this.beanFactory, ScheduledExecutorService.class, false));\n\t\t\t}\n\t\t\tcatch (NoUniqueBeanDefinitionException ex2) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Could not find unique ScheduledExecutorService bean - attempting to resolve by name: \" +\n\t\t\t\t\t\t\tex2.getMessage());\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\treturn new ConcurrentTaskScheduler(resolveSchedulerBean(this.beanFactory, ScheduledExecutorService.class, true));\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchBeanDefinitionException ex3) {\n\t\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\t\tlogger.info(\"More than one ScheduledExecutorService bean exists within the context, and \" +\n\t\t\t\t\t\t\t\t\"none is named 'taskScheduler'. Mark one of them as primary or name it 'taskScheduler' \" +\n\t\t\t\t\t\t\t\t\"(possibly as an alias); or implement the SchedulingConfigurer interface and call \" +\n\t\t\t\t\t\t\t\t\"ScheduledTaskRegistrar#setScheduler explicitly within the configureTasks() callback: \" +\n\t\t\t\t\t\t\t\tex2.getBeanNamesFound());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex2) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Could not find default ScheduledExecutorService bean - falling back to default: \" +\n\t\t\t\t\t\t\tex2.getMessage());\n\t\t\t\t}\n\t\t\t\tlogger.info(\"No TaskScheduler/ScheduledExecutorService bean found for scheduled processing\");\n\t\t\t}\n\t\t}\n\t\tScheduledExecutorService localExecutor = Executors.newSingleThreadScheduledExecutor();\n\t\tthis.localExecutor = localExecutor;\n\t\treturn new ConcurrentTaskScheduler(localExecutor);\n\t}\n\n\tprivate <T> T resolveSchedulerBean(BeanFactory beanFactory, Class<T> schedulerType, boolean byName) {\n\t\tif (byName) {\n\t\t\tT scheduler = beanFactory.getBean(DEFAULT_TASK_SCHEDULER_BEAN_NAME, schedulerType);\n\t\t\tif (this.beanName != null && this.beanFactory instanceof ConfigurableBeanFactory cbf) {\n\t\t\t\tcbf.registerDependentBean(DEFAULT_TASK_SCHEDULER_BEAN_NAME, this.beanName);\n\t\t\t}\n\t\t\treturn scheduler;\n\t\t}\n\t\telse if (beanFactory instanceof AutowireCapableBeanFactory acbf) {\n\t\t\tNamedBeanHolder<T> holder = acbf.resolveNamedBean(schedulerType);\n\t\t\tif (this.beanName != null && beanFactory instanceof ConfigurableBeanFactory cbf) {\n\t\t\t\tcbf.registerDependentBean(holder.getBeanName(), this.beanName);\n\t\t\t}\n\t\t\treturn holder.getBeanInstance();\n\t\t}\n\t\telse {\n\t\t\treturn beanFactory.getBean(schedulerType);\n\t\t}\n\t}\n\n\n\t/**\n\t * Destroy the local default executor, if any.\n\t */\n\t@Override\n\tpublic void destroy() {\n\t\tScheduledExecutorService localExecutor = this.localExecutor;\n\t\tif (localExecutor != null) {\n\t\t\tlocalExecutor.shutdownNow();\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.scheduling.config.TaskSchedulerRouter#destroy()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Destroy the local default executor, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 257
    },
    "return": "void",
    "signature": "public void destroy()",
    "source_code": "\tpublic void destroy() {\n\t\tScheduledExecutorService localExecutor = this.localExecutor;\n\t\tif (localExecutor != null) {\n\t\t\tlocalExecutor.shutdownNow();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.config.TaskSchedulerRouter#determineDefaultScheduler()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "TaskScheduler",
    "signature": "protected TaskScheduler determineDefaultScheduler()",
    "source_code": "\tprotected TaskScheduler determineDefaultScheduler() {\n\t\tAssert.state(this.beanFactory != null, \"BeanFactory must be set to find default scheduler\");\n\t\ttry {\n\t\t\t// Search for TaskScheduler bean...\n\t\t\treturn resolveSchedulerBean(this.beanFactory, TaskScheduler.class, false);\n\t\t}\n\t\tcatch (NoUniqueBeanDefinitionException ex) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Could not find unique TaskScheduler bean - attempting to resolve by name: \" +\n\t\t\t\t\t\tex.getMessage());\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn resolveSchedulerBean(this.beanFactory, TaskScheduler.class, true);\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex2) {\n\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\tlogger.info(\"More than one TaskScheduler bean exists within the context, and \" +\n\t\t\t\t\t\t\t\"none is named 'taskScheduler'. Mark one of them as primary or name it 'taskScheduler' \" +\n\t\t\t\t\t\t\t\"(possibly as an alias); or implement the SchedulingConfigurer interface and call \" +\n\t\t\t\t\t\t\t\"ScheduledTaskRegistrar#setScheduler explicitly within the configureTasks() callback: \" +\n\t\t\t\t\t\t\tex.getBeanNamesFound());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Could not find default TaskScheduler bean - attempting to find ScheduledExecutorService: \" +\n\t\t\t\t\t\tex.getMessage());\n\t\t\t}\n\t\t\t// Search for ScheduledExecutorService bean next...\n\t\t\ttry {\n\t\t\t\treturn new ConcurrentTaskScheduler(resolveSchedulerBean(this.beanFactory, ScheduledExecutorService.class, false));\n\t\t\t}\n\t\t\tcatch (NoUniqueBeanDefinitionException ex2) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Could not find unique ScheduledExecutorService bean - attempting to resolve by name: \" +\n\t\t\t\t\t\t\tex2.getMessage());\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\treturn new ConcurrentTaskScheduler(resolveSchedulerBean(this.beanFactory, ScheduledExecutorService.class, true));\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchBeanDefinitionException ex3) {\n\t\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\t\tlogger.info(\"More than one ScheduledExecutorService bean exists within the context, and \" +\n\t\t\t\t\t\t\t\t\"none is named 'taskScheduler'. Mark one of them as primary or name it 'taskScheduler' \" +\n\t\t\t\t\t\t\t\t\"(possibly as an alias); or implement the SchedulingConfigurer interface and call \" +\n\t\t\t\t\t\t\t\t\"ScheduledTaskRegistrar#setScheduler explicitly within the configureTasks() callback: \" +\n\t\t\t\t\t\t\t\tex2.getBeanNamesFound());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex2) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Could not find default ScheduledExecutorService bean - falling back to default: \" +\n\t\t\t\t\t\t\tex2.getMessage());\n\t\t\t\t}\n\t\t\t\tlogger.info(\"No TaskScheduler/ScheduledExecutorService bean found for scheduled processing\");\n\t\t\t}\n\t\t}\n\t\tScheduledExecutorService localExecutor = Executors.newSingleThreadScheduledExecutor();\n\t\tthis.localExecutor = localExecutor;\n\t\treturn new ConcurrentTaskScheduler(localExecutor);\n\t}"
  },
  "org.springframework.scheduling.config.TaskSchedulerRouter#determineQualifiedScheduler(qualifier)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "qualifier"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "TaskScheduler",
    "signature": "protected TaskScheduler determineQualifiedScheduler(String qualifier)",
    "source_code": "\tprotected TaskScheduler determineQualifiedScheduler(String qualifier) {\n\t\tAssert.state(this.beanFactory != null, \"BeanFactory must be set to find qualified scheduler\");\n\t\ttry {\n\t\t\treturn BeanFactoryAnnotationUtils.qualifiedBeanOfType(this.beanFactory, TaskScheduler.class, qualifier);\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException | BeanNotOfRequiredTypeException ex) {\n\t\t\treturn new ConcurrentTaskScheduler(BeanFactoryAnnotationUtils.qualifiedBeanOfType(\n\t\t\t\t\tthis.beanFactory, ScheduledExecutorService.class, qualifier));\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.config.TaskSchedulerRouter#determineQualifier(task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "String",
    "signature": "protected String determineQualifier(Runnable task)",
    "source_code": "\tprotected String determineQualifier(Runnable task) {\n\t\treturn (task instanceof SchedulingAwareRunnable sar ? sar.getQualifier() : null);\n\t}"
  },
  "org.springframework.scheduling.config.TaskSchedulerRouter#determineTargetScheduler(task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "TaskScheduler",
    "signature": "protected TaskScheduler determineTargetScheduler(Runnable task)",
    "source_code": "\tprotected TaskScheduler determineTargetScheduler(Runnable task) {\n\t\tString qualifier = determineQualifier(task);\n\t\tif (this.embeddedValueResolver != null && StringUtils.hasLength(qualifier)) {\n\t\t\tqualifier = this.embeddedValueResolver.resolveStringValue(qualifier);\n\t\t}\n\t\tif (StringUtils.hasLength(qualifier)) {\n\t\t\treturn determineQualifiedScheduler(qualifier);\n\t\t}\n\t\telse {\n\t\t\treturn this.defaultScheduler.get();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.config.TaskSchedulerRouter#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The bean factory for scheduler lookups.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "public void setBeanFactory(@Nullable BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(@Nullable BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t\tif (beanFactory instanceof ConfigurableBeanFactory configurableBeanFactory) {\n\t\t\tthis.embeddedValueResolver = new EmbeddedValueResolver(configurableBeanFactory);\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.config.TaskSchedulerRouter#setBeanName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The bean name for this router, or the bean name of the containing\n\t * bean if the router instance is internally held.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "void",
    "signature": "public void setBeanName(@Nullable String name)",
    "source_code": "\tpublic void setBeanName(@Nullable String name) {\n\t\tthis.beanName = name;\n\t}"
  },
  "org.springframework.scheduling.config.logger": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected static final Log logger = LogFactory.getLog(TaskSchedulerRouter.class);",
    "type": "Log"
  },
  "org.springframework.scheduling.support.CronSequenceGenerator": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Date sequence generator for a\n * <a href=\"https://www.manpagez.com/man/5/crontab/\">Crontab pattern</a>,\n * allowing clients to specify a pattern that the sequence matches.\n *\n * <p>The pattern is a list of six single space-separated fields: representing\n * second, minute, hour, day, month, weekday. Month and weekday names can be\n * given as the first three letters of the English names.\n *\n * <p>Example patterns:\n * <ul>\n * <li>\"0 0 * * * *\" = the top of every hour of every day.</li>\n * <li>\"*&#47;10 * * * * *\" = every ten seconds.</li>\n * <li>\"0 0 8-10 * * *\" = 8, 9 and 10 o'clock of every day.</li>\n * <li>\"0 0 6,19 * * *\" = 6:00 AM and 7:00 PM every day.</li>\n * <li>\"0 0/30 8-10 * * *\" = 8:00, 8:30, 9:00, 9:30, 10:00 and 10:30 every day.</li>\n * <li>\"0 0 9-17 * * MON-FRI\" = on the hour nine-to-five weekdays</li>\n * <li>\"0 0 0 25 12 ?\" = every Christmas Day at midnight</li>\n * </ul>\n *\n * @author Dave Syer\n * @author Juergen Hoeller\n * @author Ruslan Sibgatullin\n * @since 3.0\n * @see CronTrigger\n * @deprecated as of 5.3, in favor of {@link CronExpression}\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "signature": "public class CronSequenceGenerator",
    "source_code": "public class CronSequenceGenerator {\n\n\tprivate final String expression;\n\n\t@Nullable\n\tprivate final TimeZone timeZone;\n\n\tprivate final BitSet months = new BitSet(12);\n\n\tprivate final BitSet daysOfMonth = new BitSet(31);\n\n\tprivate final BitSet daysOfWeek = new BitSet(7);\n\n\tprivate final BitSet hours = new BitSet(24);\n\n\tprivate final BitSet minutes = new BitSet(60);\n\n\tprivate final BitSet seconds = new BitSet(60);\n\n\n\t/**\n\t * Construct a {@code CronSequenceGenerator} from the pattern provided,\n\t * using the default {@link TimeZone}.\n\t * @param expression a space-separated list of time fields\n\t * @throws IllegalArgumentException if the pattern cannot be parsed\n\t * @see java.util.TimeZone#getDefault()\n\t * @deprecated as of 5.3, in favor of {@link CronExpression#parse(String)}\n\t */\n\t@Deprecated(since = \"5.3\", forRemoval = true)\n\tpublic CronSequenceGenerator(String expression) {\n\t\tthis(expression, TimeZone.getDefault());\n\t}\n\n\t/**\n\t * Construct a {@code CronSequenceGenerator} from the pattern provided,\n\t * using the specified {@link TimeZone}.\n\t * @param expression a space-separated list of time fields\n\t * @param timeZone the TimeZone to use for generated trigger times\n\t * @throws IllegalArgumentException if the pattern cannot be parsed\n\t * @deprecated as of 5.3, in favor of {@link CronExpression#parse(String)}\n\t */\n\t@Deprecated\n\tpublic CronSequenceGenerator(String expression, TimeZone timeZone) {\n\t\tthis.expression = expression;\n\t\tthis.timeZone = timeZone;\n\t\tparse(expression);\n\t}\n\n\tprivate CronSequenceGenerator(String expression, String[] fields) {\n\t\tthis.expression = expression;\n\t\tthis.timeZone = null;\n\t\tdoParse(fields);\n\t}\n\n\n\t/**\n\t * Return the cron pattern that this sequence generator has been built for.\n\t */\n\tString getExpression() {\n\t\treturn this.expression;\n\t}\n\n\n\t/**\n\t * Get the next {@link Date} in the sequence matching the Cron pattern and\n\t * after the value provided. The return value will have a whole number of\n\t * seconds, and will be after the input value.\n\t * @param date a seed value\n\t * @return the next value matching the pattern\n\t */\n\tpublic Date next(Date date) {\n\t\t/*\n\t\tThe plan:\n\n\t\t1 Start with whole second (rounding up if necessary)\n\n\t\t2 If seconds match move on, otherwise find the next match:\n\t\t2.1 If next match is in the next minute then roll forwards\n\n\t\t3 If minute matches move on, otherwise find the next match\n\t\t3.1 If next match is in the next hour then roll forwards\n\t\t3.2 Reset the seconds and go to 2\n\n\t\t4 If hour matches move on, otherwise find the next match\n\t\t4.1 If next match is in the next day then roll forwards,\n\t\t4.2 Reset the minutes and seconds and go to 2\n\t\t*/\n\n\t\tCalendar calendar = new GregorianCalendar();\n\t\tcalendar.setTimeZone(this.timeZone);\n\t\tcalendar.setTime(date);\n\n\t\t// First, just reset the milliseconds and try to calculate from there...\n\t\tcalendar.set(Calendar.MILLISECOND, 0);\n\t\tlong originalTimestamp = calendar.getTimeInMillis();\n\t\tdoNext(calendar, calendar.get(Calendar.YEAR));\n\n\t\tif (calendar.getTimeInMillis() == originalTimestamp) {\n\t\t\t// We arrived at the original timestamp - round up to the next whole second and try again...\n\t\t\tcalendar.add(Calendar.SECOND, 1);\n\t\t\tdoNext(calendar, calendar.get(Calendar.YEAR));\n\t\t}\n\n\t\treturn calendar.getTime();\n\t}\n\n\tprivate void doNext(Calendar calendar, int dot) {\n\t\tList<Integer> resets = new ArrayList<>();\n\n\t\tint second = calendar.get(Calendar.SECOND);\n\t\tList<Integer> emptyList = Collections.emptyList();\n\t\tint updateSecond = findNext(this.seconds, second, calendar, Calendar.SECOND, Calendar.MINUTE, emptyList);\n\t\tif (second == updateSecond) {\n\t\t\tresets.add(Calendar.SECOND);\n\t\t}\n\n\t\tint minute = calendar.get(Calendar.MINUTE);\n\t\tint updateMinute = findNext(this.minutes, minute, calendar, Calendar.MINUTE, Calendar.HOUR_OF_DAY, resets);\n\t\tif (minute == updateMinute) {\n\t\t\tresets.add(Calendar.MINUTE);\n\t\t}\n\t\telse {\n\t\t\tdoNext(calendar, dot);\n\t\t}\n\n\t\tint hour = calendar.get(Calendar.HOUR_OF_DAY);\n\t\tint updateHour = findNext(this.hours, hour, calendar, Calendar.HOUR_OF_DAY, Calendar.DAY_OF_WEEK, resets);\n\t\tif (hour == updateHour) {\n\t\t\tresets.add(Calendar.HOUR_OF_DAY);\n\t\t}\n\t\telse {\n\t\t\tdoNext(calendar, dot);\n\t\t}\n\n\t\tint dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);\n\t\tint dayOfMonth = calendar.get(Calendar.DAY_OF_MONTH);\n\t\tint updateDayOfMonth = findNextDay(calendar, this.daysOfMonth, dayOfMonth, this.daysOfWeek, dayOfWeek, resets);\n\t\tif (dayOfMonth == updateDayOfMonth) {\n\t\t\tresets.add(Calendar.DAY_OF_MONTH);\n\t\t}\n\t\telse {\n\t\t\tdoNext(calendar, dot);\n\t\t}\n\n\t\tint month = calendar.get(Calendar.MONTH);\n\t\tint updateMonth = findNext(this.months, month, calendar, Calendar.MONTH, Calendar.YEAR, resets);\n\t\tif (month != updateMonth) {\n\t\t\tif (calendar.get(Calendar.YEAR) - dot > 4) {\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid cron expression \\\"\" + this.expression +\n\t\t\t\t\t\t\"\\\" led to runaway search for next trigger\");\n\t\t\t}\n\t\t\tdoNext(calendar, dot);\n\t\t}\n\n\t}\n\n\tprivate int findNextDay(Calendar calendar, BitSet daysOfMonth, int dayOfMonth, BitSet daysOfWeek, int dayOfWeek,\n\t\t\tList<Integer> resets) {\n\n\t\tint count = 0;\n\t\tint max = 366;\n\t\t// the DAY_OF_WEEK values in java.util.Calendar start with 1 (Sunday),\n\t\t// but in the cron pattern, they start with 0, so we subtract 1 here\n\t\twhile ((!daysOfMonth.get(dayOfMonth) || !daysOfWeek.get(dayOfWeek - 1)) && count++ < max) {\n\t\t\tcalendar.add(Calendar.DAY_OF_MONTH, 1);\n\t\t\tdayOfMonth = calendar.get(Calendar.DAY_OF_MONTH);\n\t\t\tdayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);\n\t\t\treset(calendar, resets);\n\t\t}\n\t\tif (count >= max) {\n\t\t\tthrow new IllegalArgumentException(\"Overflow in day for expression \\\"\" + this.expression + \"\\\"\");\n\t\t}\n\t\treturn dayOfMonth;\n\t}\n\n\t/**\n\t * Search the bits provided for the next set bit after the value provided,\n\t * and reset the calendar.\n\t * @param bits a {@link BitSet} representing the allowed values of the field\n\t * @param value the current value of the field\n\t * @param calendar the calendar to increment as we move through the bits\n\t * @param field the field to increment in the calendar (@see\n\t * {@link Calendar} for the static constants defining valid fields)\n\t * @param lowerOrders the Calendar field ids that should be reset (i.e. the\n\t * ones of lower significance than the field of interest)\n\t * @return the value of the calendar field that is next in the sequence\n\t */\n\tprivate int findNext(BitSet bits, int value, Calendar calendar, int field, int nextField, List<Integer> lowerOrders) {\n\t\tint nextValue = bits.nextSetBit(value);\n\t\t// roll over if needed\n\t\tif (nextValue == -1) {\n\t\t\tcalendar.add(nextField, 1);\n\t\t\treset(calendar, Collections.singletonList(field));\n\t\t\tnextValue = bits.nextSetBit(0);\n\t\t}\n\t\tif (nextValue != value) {\n\t\t\tcalendar.set(field, nextValue);\n\t\t\treset(calendar, lowerOrders);\n\t\t}\n\t\treturn nextValue;\n\t}\n\n\t/**\n\t * Reset the calendar setting all the fields provided to zero.\n\t */\n\tprivate void reset(Calendar calendar, List<Integer> fields) {\n\t\tfor (int field : fields) {\n\t\t\tcalendar.set(field, field == Calendar.DAY_OF_MONTH ? 1 : 0);\n\t\t}\n\t}\n\n\n\t// Parsing logic invoked by the constructor\n\n\t/**\n\t * Parse the given pattern expression.\n\t */\n\tprivate void parse(String expression) throws IllegalArgumentException {\n\t\tString[] fields = StringUtils.tokenizeToStringArray(expression, \" \");\n\t\tif (!areValidCronFields(fields)) {\n\t\t\tthrow new IllegalArgumentException(String.format(\n\t\t\t\t\t\"Cron expression must consist of 6 fields (found %d in \\\"%s\\\")\", fields.length, expression));\n\t\t}\n\t\tdoParse(fields);\n\t}\n\n\tprivate void doParse(String[] fields) {\n\t\tsetNumberHits(this.seconds, fields[0], 0, 60);\n\t\tsetNumberHits(this.minutes, fields[1], 0, 60);\n\t\tsetNumberHits(this.hours, fields[2], 0, 24);\n\t\tsetDaysOfMonth(this.daysOfMonth, fields[3]);\n\t\tsetMonths(this.months, fields[4]);\n\t\tsetDays(this.daysOfWeek, replaceOrdinals(fields[5], \"SUN,MON,TUE,WED,THU,FRI,SAT\"), 8);\n\n\t\tif (this.daysOfWeek.get(7)) {\n\t\t\t// Sunday can be represented as 0 or 7\n\t\t\tthis.daysOfWeek.set(0);\n\t\t\tthis.daysOfWeek.clear(7);\n\t\t}\n\t}\n\n\t/**\n\t * Replace the values in the comma-separated list (case-insensitive)\n\t * with their index in the list.\n\t * @return a new String with the values from the list replaced\n\t */\n\tprivate String replaceOrdinals(String value, String commaSeparatedList) {\n\t\tString[] list = StringUtils.commaDelimitedListToStringArray(commaSeparatedList);\n\t\tfor (int i = 0; i < list.length; i++) {\n\t\t\tString item = list[i].toUpperCase();\n\t\t\tvalue = StringUtils.replace(value.toUpperCase(), item, \"\" + i);\n\t\t}\n\t\treturn value;\n\t}\n\n\tprivate void setDaysOfMonth(BitSet bits, String field) {\n\t\tint max = 31;\n\t\t// Days of month start with 1 (in Cron and Calendar) so add one\n\t\tsetDays(bits, field, max + 1);\n\t\t// ... and remove it from the front\n\t\tbits.clear(0);\n\t}\n\n\tprivate void setDays(BitSet bits, String field, int max) {\n\t\tif (field.contains(\"?\")) {\n\t\t\tfield = \"*\";\n\t\t}\n\t\tsetNumberHits(bits, field, 0, max);\n\t}\n\n\tprivate void setMonths(BitSet bits, String value) {\n\t\tint max = 12;\n\t\tvalue = replaceOrdinals(value, \"FOO,JAN,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC\");\n\t\tBitSet months = new BitSet(13);\n\t\t// Months start with 1 in Cron and 0 in Calendar, so push the values first into a longer bit set\n\t\tsetNumberHits(months, value, 1, max + 1);\n\t\t// ... and then rotate it to the front of the months\n\t\tfor (int i = 1; i <= max; i++) {\n\t\t\tif (months.get(i)) {\n\t\t\t\tbits.set(i - 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void setNumberHits(BitSet bits, String value, int min, int max) {\n\t\tString[] fields = StringUtils.delimitedListToStringArray(value, \",\");\n\t\tfor (String field : fields) {\n\t\t\tif (!field.contains(\"/\")) {\n\t\t\t\t// Not an incrementer so it must be a range (possibly empty)\n\t\t\t\tint[] range = getRange(field, min, max);\n\t\t\t\tbits.set(range[0], range[1] + 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString[] split = StringUtils.delimitedListToStringArray(field, \"/\");\n\t\t\t\tif (split.length > 2) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Incrementer has more than two fields: '\" +\n\t\t\t\t\t\t\tfield + \"' in expression \\\"\" + this.expression + \"\\\"\");\n\t\t\t\t}\n\t\t\t\tint[] range = getRange(split[0], min, max);\n\t\t\t\tif (!split[0].contains(\"-\")) {\n\t\t\t\t\trange[1] = max - 1;\n\t\t\t\t}\n\t\t\t\tint delta = Integer.parseInt(split[1]);\n\t\t\t\tif (delta <= 0) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Incrementer delta must be 1 or higher: '\" +\n\t\t\t\t\t\t\tfield + \"' in expression \\\"\" + this.expression + \"\\\"\");\n\t\t\t\t}\n\t\t\t\tfor (int i = range[0]; i <= range[1]; i += delta) {\n\t\t\t\t\tbits.set(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int[] getRange(String field, int min, int max) {\n\t\tint[] result = new int[2];\n\t\tif (field.contains(\"*\")) {\n\t\t\tresult[0] = min;\n\t\t\tresult[1] = max - 1;\n\t\t\treturn result;\n\t\t}\n\t\tif (!field.contains(\"-\")) {\n\t\t\tresult[0] = result[1] = Integer.parseInt(field);\n\t\t}\n\t\telse {\n\t\t\tString[] split = StringUtils.delimitedListToStringArray(field, \"-\");\n\t\t\tif (split.length > 2) {\n\t\t\t\tthrow new IllegalArgumentException(\"Range has more than two fields: '\" +\n\t\t\t\t\t\tfield + \"' in expression \\\"\" + this.expression + \"\\\"\");\n\t\t\t}\n\t\t\tresult[0] = Integer.parseInt(split[0]);\n\t\t\tresult[1] = Integer.parseInt(split[1]);\n\t\t}\n\t\tif (result[0] >= max || result[1] >= max) {\n\t\t\tthrow new IllegalArgumentException(\"Range exceeds maximum (\" + max + \"): '\" +\n\t\t\t\t\tfield + \"' in expression \\\"\" + this.expression + \"\\\"\");\n\t\t}\n\t\tif (result[0] < min || result[1] < min) {\n\t\t\tthrow new IllegalArgumentException(\"Range less than minimum (\" + min + \"): '\" +\n\t\t\t\t\tfield + \"' in expression \\\"\" + this.expression + \"\\\"\");\n\t\t}\n\t\tif (result[0] > result[1]) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid inverted range: '\" + field +\n\t\t\t\t\t\"' in expression \\\"\" + this.expression + \"\\\"\");\n\t\t}\n\t\treturn result;\n\t}\n\n\n\t/**\n\t * Determine whether the specified expression represents a valid cron pattern.\n\t * @param expression the expression to evaluate\n\t * @return {@code true} if the given expression is a valid cron expression\n\t * @since 4.3\n\t */\n\tpublic static boolean isValidExpression(@Nullable String expression) {\n\t\tif (expression == null) {\n\t\t\treturn false;\n\t\t}\n\t\tString[] fields = StringUtils.tokenizeToStringArray(expression, \" \");\n\t\tif (!areValidCronFields(fields)) {\n\t\t\treturn false;\n\t\t}\n\t\ttry {\n\t\t\tnew CronSequenceGenerator(expression, fields);\n\t\t\treturn true;\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate static boolean areValidCronFields(@Nullable String[] fields) {\n\t\treturn (fields != null && fields.length == 6);\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!(other instanceof CronSequenceGenerator otherCron)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (this.months.equals(otherCron.months) && this.daysOfMonth.equals(otherCron.daysOfMonth) &&\n\t\t\t\tthis.daysOfWeek.equals(otherCron.daysOfWeek) && this.hours.equals(otherCron.hours) &&\n\t\t\t\tthis.minutes.equals(otherCron.minutes) && this.seconds.equals(otherCron.seconds));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn (17 * this.months.hashCode() + 29 * this.daysOfMonth.hashCode() + 37 * this.daysOfWeek.hashCode() +\n\t\t\t\t41 * this.hours.hashCode() + 53 * this.minutes.hashCode() + 61 * this.seconds.hashCode());\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \": \" + this.expression;\n\t}\n\n}"
  },
  "org.springframework.scheduling.support.CronSequenceGenerator#equals(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 437
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!(other instanceof CronSequenceGenerator otherCron)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (this.months.equals(otherCron.months) && this.daysOfMonth.equals(otherCron.daysOfMonth) &&\n\t\t\t\tthis.daysOfWeek.equals(otherCron.daysOfWeek) && this.hours.equals(otherCron.hours) &&\n\t\t\t\tthis.minutes.equals(otherCron.minutes) && this.seconds.equals(otherCron.seconds));\n\t}"
  },
  "org.springframework.scheduling.support.CronSequenceGenerator#hashCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 450
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn (17 * this.months.hashCode() + 29 * this.daysOfMonth.hashCode() + 37 * this.daysOfWeek.hashCode() +\n\t\t\t\t41 * this.hours.hashCode() + 53 * this.minutes.hashCode() + 61 * this.seconds.hashCode());\n\t}"
  },
  "org.springframework.scheduling.support.CronSequenceGenerator#isValidExpression(expression)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the specified expression represents a valid cron pattern.\n\t * @param expression the expression to evaluate\n\t * @return {@code true} if the given expression is a valid cron expression\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expression"
    ],
    "position": {
      "column": 1,
      "line": 414
    },
    "return": "boolean",
    "signature": "public boolean isValidExpression(@Nullable String expression)",
    "source_code": "\tpublic static boolean isValidExpression(@Nullable String expression) {\n\t\tif (expression == null) {\n\t\t\treturn false;\n\t\t}\n\t\tString[] fields = StringUtils.tokenizeToStringArray(expression, \" \");\n\t\tif (!areValidCronFields(fields)) {\n\t\t\treturn false;\n\t\t}\n\t\ttry {\n\t\t\tnew CronSequenceGenerator(expression, fields);\n\t\t\treturn true;\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\treturn false;\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.support.CronSequenceGenerator#next(date)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the next {@link Date} in the sequence matching the Cron pattern and\n\t * after the value provided. The return value will have a whole number of\n\t * seconds, and will be after the input value.\n\t * @param date a seed value\n\t * @return the next value matching the pattern\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "date"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "Date",
    "signature": "public Date next(Date date)",
    "source_code": "\tpublic Date next(Date date) {\n\t\t/*\n\t\tThe plan:\n\n\t\t1 Start with whole second (rounding up if necessary)\n\n\t\t2 If seconds match move on, otherwise find the next match:\n\t\t2.1 If next match is in the next minute then roll forwards\n\n\t\t3 If minute matches move on, otherwise find the next match\n\t\t3.1 If next match is in the next hour then roll forwards\n\t\t3.2 Reset the seconds and go to 2\n\n\t\t4 If hour matches move on, otherwise find the next match\n\t\t4.1 If next match is in the next day then roll forwards,\n\t\t4.2 Reset the minutes and seconds and go to 2\n\t\t*/\n\n\t\tCalendar calendar = new GregorianCalendar();\n\t\tcalendar.setTimeZone(this.timeZone);\n\t\tcalendar.setTime(date);\n\n\t\t// First, just reset the milliseconds and try to calculate from there...\n\t\tcalendar.set(Calendar.MILLISECOND, 0);\n\t\tlong originalTimestamp = calendar.getTimeInMillis();\n\t\tdoNext(calendar, calendar.get(Calendar.YEAR));\n\n\t\tif (calendar.getTimeInMillis() == originalTimestamp) {\n\t\t\t// We arrived at the original timestamp - round up to the next whole second and try again...\n\t\t\tcalendar.add(Calendar.SECOND, 1);\n\t\t\tdoNext(calendar, calendar.get(Calendar.YEAR));\n\t\t}\n\n\t\treturn calendar.getTime();\n\t}"
  },
  "org.springframework.scheduling.support.CronSequenceGenerator#toString()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 456
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \": \" + this.expression;\n\t}"
  },
  "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#closeContext(mergedConfig,hierarchyMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedConfig",
      "hierarchyMode"
    ],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "void",
    "signature": "public void closeContext(MergedContextConfiguration mergedConfig, @Nullable HierarchyMode hierarchyMode)",
    "source_code": "\tpublic void closeContext(MergedContextConfiguration mergedConfig, @Nullable HierarchyMode hierarchyMode) {\n\t\tmergedConfig = replaceIfNecessary(mergedConfig);\n\t\tsynchronized (this.contextCache) {\n\t\t\tthis.contextCache.remove(mergedConfig, hierarchyMode);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#closeContext(mergedContextConfiguration,hierarchyMode)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedContextConfiguration",
      "hierarchyMode"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "void",
    "signature": "public void closeContext(MergedContextConfiguration mergedContextConfiguration, @Nullable HierarchyMode hierarchyMode)",
    "source_code": "\tpublic void closeContext(MergedContextConfiguration mergedContextConfiguration, @Nullable HierarchyMode hierarchyMode) {\n\t\tsynchronized (this.contextCache) {\n\t\t\tthis.contextCache.remove(replaceIfNecessary(mergedContextConfiguration), hierarchyMode);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#isContextLoaded(mergedConfig)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedConfig"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "boolean",
    "signature": "public boolean isContextLoaded(MergedContextConfiguration mergedConfig)",
    "source_code": "\tpublic boolean isContextLoaded(MergedContextConfiguration mergedConfig) {\n\t\tmergedConfig = replaceIfNecessary(mergedConfig);\n\t\tsynchronized (this.contextCache) {\n\t\t\treturn this.contextCache.contains(mergedConfig);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#isContextLoaded(mergedContextConfiguration)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedContextConfiguration"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "boolean",
    "signature": "public boolean isContextLoaded(MergedContextConfiguration mergedContextConfiguration)",
    "source_code": "\tpublic boolean isContextLoaded(MergedContextConfiguration mergedContextConfiguration) {\n\t\tsynchronized (this.contextCache) {\n\t\t\treturn this.contextCache.contains(replaceIfNecessary(mergedContextConfiguration));\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#loadContext(mergedConfig)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedConfig"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "ApplicationContext",
    "signature": "public ApplicationContext loadContext(MergedContextConfiguration mergedConfig)",
    "source_code": "\tpublic ApplicationContext loadContext(MergedContextConfiguration mergedConfig) {\n\t\tmergedConfig = replaceIfNecessary(mergedConfig);\n\t\tsynchronized (this.contextCache) {\n\t\t\tApplicationContext context = this.contextCache.get(mergedConfig);\n\t\t\ttry {\n\t\t\t\tif (context == null) {\n\t\t\t\t\tInteger failureCount = this.contextCache.getFailureCount(mergedConfig);\n\t\t\t\t\tif (failureCount >= this.failureThreshold) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\t\t\t\t\tApplicationContext failure threshold (%d) exceeded: \\\n\t\t\t\t\t\t\t\tskipping repeated attempt to load context for %s\"\"\"\n\t\t\t\t\t\t\t\t\t.formatted(this.failureThreshold, mergedConfig));\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (mergedConfig instanceof AotMergedContextConfiguration aotMergedConfig) {\n\t\t\t\t\t\t\tcontext = loadContextInAotMode(aotMergedConfig);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcontext = loadContextInternal(mergedConfig);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Storing ApplicationContext [%s] in cache under key %s\".formatted(\n\t\t\t\t\t\t\t\t\tSystem.identityHashCode(context), mergedConfig));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.contextCache.put(mergedConfig, context);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Incrementing ApplicationContext failure count for \" + mergedConfig);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.contextCache.incrementFailureCount(mergedConfig);\n\t\t\t\t\t\tThrowable cause = ex;\n\t\t\t\t\t\tif (ex instanceof ContextLoadException cle) {\n\t\t\t\t\t\t\tcause = cle.getCause();\n\t\t\t\t\t\t\tfor (ApplicationContextFailureProcessor contextFailureProcessor : this.contextFailureProcessors) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tcontextFailureProcessor.processLoadFailure(cle.getApplicationContext(), cause);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch (Throwable throwable) {\n\t\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\t\tlogger.debug(\"Ignoring exception thrown from ApplicationContextFailureProcessor [%s]: %s\"\n\t\t\t\t\t\t\t\t\t\t\t\t.formatted(contextFailureProcessor, throwable));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\t\"Failed to load ApplicationContext for \" + mergedConfig, cause);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Retrieved ApplicationContext [%s] from cache with key %s\".formatted(\n\t\t\t\t\t\t\t\tSystem.identityHashCode(context), mergedConfig));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.contextCache.logStatistics();\n\t\t\t}\n\n\t\t\treturn context;\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#loadContext(mergedContextConfiguration)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedContextConfiguration"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "ApplicationContext",
    "signature": "public ApplicationContext loadContext(MergedContextConfiguration mergedContextConfiguration)",
    "source_code": "\tpublic ApplicationContext loadContext(MergedContextConfiguration mergedContextConfiguration) {\n\t\tmergedContextConfiguration = replaceIfNecessary(mergedContextConfiguration);\n\t\tsynchronized (this.contextCache) {\n\t\t\tApplicationContext context = this.contextCache.get(mergedContextConfiguration);\n\t\t\ttry {\n\t\t\t\tif (context == null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (mergedContextConfiguration instanceof AotMergedContextConfiguration aotMergedConfig) {\n\t\t\t\t\t\t\tcontext = loadContextInAotMode(aotMergedConfig);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcontext = loadContextInternal(mergedContextConfiguration);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Storing ApplicationContext [%s] in cache under key %s\".formatted(\n\t\t\t\t\t\t\t\t\tSystem.identityHashCode(context), mergedContextConfiguration));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.contextCache.put(mergedContextConfiguration, context);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\tThrowable cause = ex;\n\t\t\t\t\t\tif (ex instanceof ContextLoadException cle) {\n\t\t\t\t\t\t\tcause = cle.getCause();\n\t\t\t\t\t\t\tfor (ApplicationContextFailureProcessor contextFailureProcessor : this.contextFailureProcessors) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tcontextFailureProcessor.processLoadFailure(cle.getApplicationContext(), cause);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch (Throwable throwable) {\n\t\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\t\tlogger.debug(\"Ignoring exception thrown from ApplicationContextFailureProcessor [%s]: %s\"\n\t\t\t\t\t\t\t\t\t\t\t\t.formatted(contextFailureProcessor, throwable));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\t\"Failed to load ApplicationContext for \" + mergedContextConfiguration, cause);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Retrieved ApplicationContext [%s] from cache with key %s\".formatted(\n\t\t\t\t\t\t\t\tSystem.identityHashCode(context), mergedContextConfiguration));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.contextCache.logStatistics();\n\t\t\t}\n\n\t\t\treturn context;\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#loadContextInternal(mergedConfig)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Load the {@code ApplicationContext} for the supplied merged context configuration.\n\t * <p>Supports both the {@link SmartContextLoader} and {@link ContextLoader} SPIs.\n\t * @throws Exception if an error occurs while loading the application context\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mergedConfig"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "ApplicationContext",
    "signature": "protected ApplicationContext loadContextInternal(MergedContextConfiguration mergedConfig)",
    "source_code": "\tprotected ApplicationContext loadContextInternal(MergedContextConfiguration mergedConfig)"
  },
  "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#loadContextInternal(mergedContextConfiguration)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Load the {@code ApplicationContext} for the supplied merged context configuration.\n\t * <p>Supports both the {@link SmartContextLoader} and {@link ContextLoader} SPIs.\n\t * @throws Exception if an error occurs while loading the application context\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mergedContextConfiguration"
    ],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "ApplicationContext",
    "signature": "protected ApplicationContext loadContextInternal(MergedContextConfiguration mergedContextConfiguration)",
    "source_code": "\tprotected ApplicationContext loadContextInternal(MergedContextConfiguration mergedContextConfiguration)"
  },
  "org.springframework.test.context.cache.DefaultContextCache#getFailureCount(key)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "int",
    "signature": "public int getFailureCount(MergedContextConfiguration key)",
    "source_code": "\tpublic int getFailureCount(MergedContextConfiguration key) {\n\t\treturn this.failureCounts.getOrDefault(key, 0);\n\t}"
  },
  "org.springframework.test.context.cache.DefaultContextCache#incrementFailureCount(key)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "void",
    "signature": "public void incrementFailureCount(MergedContextConfiguration key)",
    "source_code": "\tpublic void incrementFailureCount(MergedContextConfiguration key) {\n\t\tthis.totalFailureCount.incrementAndGet();\n\t\tthis.failureCounts.merge(key, 1, Integer::sum);\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code SpringExtension} integrates the <em>Spring TestContext Framework</em>\n * into JUnit 5's <em>Jupiter</em> programming model.\n *\n * <p>To use this extension, simply annotate a JUnit Jupiter based test class with\n * {@code @ExtendWith(SpringExtension.class)}, {@code @SpringJUnitConfig}, or\n * {@code @SpringJUnitWebConfig}.\n *\n * @author Sam Brannen\n * @author Simon Basl\u00e9\n * @since 5.0\n * @see org.springframework.test.context.junit.jupiter.EnabledIf\n * @see org.springframework.test.context.junit.jupiter.DisabledIf\n * @see org.springframework.test.context.junit.jupiter.SpringJUnitConfig\n * @see org.springframework.test.context.junit.jupiter.web.SpringJUnitWebConfig\n * @see org.springframework.test.context.TestContextManager\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "signature": "public class SpringExtension",
    "source_code": "public class SpringExtension implements BeforeAllCallback, AfterAllCallback, TestInstancePostProcessor,"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#afterAll(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@link TestContextManager#afterTestClass}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "void",
    "signature": "public void afterAll(ExtensionContext context)",
    "source_code": "\tpublic void afterAll(ExtensionContext context) throws Exception {\n\t\ttry {\n\t\t\tgetTestContextManager(context).afterTestClass();\n\t\t}\n\t\tfinally {\n\t\t\tgetStore(context).remove(context.getRequiredTestClass());\n\t\t}\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#afterEach(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@link TestContextManager#afterTestMethod}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "void",
    "signature": "public void afterEach(ExtensionContext context)",
    "source_code": "\tpublic void afterEach(ExtensionContext context) throws Exception {\n\t\tObject testInstance = context.getRequiredTestInstance();\n\t\tMethod testMethod = context.getRequiredTestMethod();\n\t\tThrowable testException = context.getExecutionException().orElse(null);\n\t\tgetTestContextManager(context).afterTestMethod(testInstance, testMethod, testException);\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#afterTestExecution(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@link TestContextManager#afterTestExecution}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "void",
    "signature": "public void afterTestExecution(ExtensionContext context)",
    "source_code": "\tpublic void afterTestExecution(ExtensionContext context) throws Exception {\n\t\tObject testInstance = context.getRequiredTestInstance();\n\t\tMethod testMethod = context.getRequiredTestMethod();\n\t\tThrowable testException = context.getExecutionException().orElse(null);\n\t\tgetTestContextManager(context).afterTestExecution(testInstance, testMethod, testException);\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#beforeAll(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@link TestContextManager#beforeTestClass}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "void",
    "signature": "public void beforeAll(ExtensionContext context)",
    "source_code": "\tpublic void beforeAll(ExtensionContext context) throws Exception {\n\t\tgetTestContextManager(context).beforeTestClass();\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#beforeEach(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@link TestContextManager#beforeTestMethod}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "void",
    "signature": "public void beforeEach(ExtensionContext context)",
    "source_code": "\tpublic void beforeEach(ExtensionContext context) throws Exception {\n\t\tObject testInstance = context.getRequiredTestInstance();\n\t\tMethod testMethod = context.getRequiredTestMethod();\n\t\tgetTestContextManager(context).beforeTestMethod(testInstance, testMethod);\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#beforeTestExecution(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@link TestContextManager#beforeTestExecution}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "void",
    "signature": "public void beforeTestExecution(ExtensionContext context)",
    "source_code": "\tpublic void beforeTestExecution(ExtensionContext context) throws Exception {\n\t\tObject testInstance = context.getRequiredTestInstance();\n\t\tMethod testMethod = context.getRequiredTestMethod();\n\t\tgetTestContextManager(context).beforeTestExecution(testInstance, testMethod);\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#getApplicationContext(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the {@link ApplicationContext} associated with the supplied {@code ExtensionContext}.\n\t * @param context the current {@code ExtensionContext} (never {@code null})\n\t * @return the application context\n\t * @throws IllegalStateException if an error occurs while retrieving the application context\n\t * @see org.springframework.test.context.TestContext#getApplicationContext()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "ApplicationContext",
    "signature": "public ApplicationContext getApplicationContext(ExtensionContext context)",
    "source_code": "\tpublic static ApplicationContext getApplicationContext(ExtensionContext context) {\n\t\treturn getTestContextManager(context).getTestContext().getApplicationContext();\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#postProcessTestInstance(testInstance,context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@link TestContextManager#prepareTestInstance}.\n\t * <p>As of Spring Framework 5.3.2, this method also validates that test\n\t * methods and test lifecycle methods are not annotated with\n\t * {@link Autowired @Autowired}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testInstance",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "public void postProcessTestInstance(Object testInstance, ExtensionContext context)",
    "source_code": "\tpublic void postProcessTestInstance(Object testInstance, ExtensionContext context) throws Exception {\n\t\tvalidateAutowiredConfig(context);\n\t\tvalidateRecordApplicationEventsConfig(context);\n\t\tgetTestContextManager(context).prepareTestInstance(testInstance);\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#resolveParameter(parameterContext,extensionContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve a value for the {@link Parameter} in the supplied {@link ParameterContext} by\n\t * retrieving the corresponding dependency from the test's {@link ApplicationContext}.\n\t * <p>Delegates to {@link ParameterResolutionDelegate#resolveDependency}.\n\t * @see #supportsParameter\n\t * @see ParameterResolutionDelegate#resolveDependency\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterContext",
      "extensionContext"
    ],
    "position": {
      "column": 1,
      "line": 317
    },
    "return": "Object",
    "signature": "public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext)",
    "source_code": "\tpublic Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {\n\t\tParameter parameter = parameterContext.getParameter();\n\t\tint index = parameterContext.getIndex();\n\t\tClass<?> testClass = extensionContext.getRequiredTestClass();\n\t\tApplicationContext applicationContext = getApplicationContext(extensionContext);\n\t\treturn ParameterResolutionDelegate.resolveDependency(parameter, index, testClass,\n\t\t\t\tapplicationContext.getAutowireCapableBeanFactory());\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#supportsParameter(parameterContext,extensionContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the value for the {@link Parameter} in the supplied {@link ParameterContext}\n\t * should be autowired from the test's {@link ApplicationContext}.\n\t * <p>A parameter is considered to be autowirable if one of the following\n\t * conditions is {@code true}.\n\t * <ol>\n\t * <li>The {@linkplain ParameterContext#getDeclaringExecutable() declaring\n\t * executable} is a {@link Constructor} and\n\t * {@link TestConstructorUtils#isAutowirableConstructor(Constructor, Class, PropertyProvider)}\n\t * returns {@code true}. Note that {@code isAutowirableConstructor()} will be\n\t * invoked with a fallback {@link PropertyProvider} that delegates its lookup\n\t * to {@link ExtensionContext#getConfigurationParameter(String)}.</li>\n\t * <li>The parameter is of type {@link ApplicationContext} or a sub-type thereof.</li>\n\t * <li>The parameter is of type {@link ApplicationEvents} or a sub-type thereof.</li>\n\t * <li>{@link ParameterResolutionDelegate#isAutowirable} returns {@code true}.</li>\n\t * </ol>\n\t * <p><strong>WARNING</strong>: If a test class {@code Constructor} is annotated\n\t * with {@code @Autowired} or automatically autowirable (see {@link TestConstructor}),\n\t * Spring will assume the responsibility for resolving all parameters in the\n\t * constructor. Consequently, no other registered {@link ParameterResolver}\n\t * will be able to resolve parameters.\n\t * @see #resolveParameter\n\t * @see TestConstructorUtils#isAutowirableConstructor(Constructor, Class)\n\t * @see ParameterResolutionDelegate#isAutowirable\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterContext",
      "extensionContext"
    ],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "boolean",
    "signature": "public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext)",
    "source_code": "\tpublic boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {\n\t\tParameter parameter = parameterContext.getParameter();\n\t\tExecutable executable = parameter.getDeclaringExecutable();\n\t\tClass<?> testClass = extensionContext.getRequiredTestClass();\n\t\tPropertyProvider junitPropertyProvider = propertyName ->\n\t\t\t\textensionContext.getConfigurationParameter(propertyName).orElse(null);\n\t\treturn (TestConstructorUtils.isAutowirableConstructor(executable, testClass, junitPropertyProvider) ||\n\t\t\t\tApplicationContext.class.isAssignableFrom(parameter.getType()) ||\n\t\t\t\tsupportsApplicationEvents(parameterContext) ||\n\t\t\t\tParameterResolutionDelegate.isAutowirable(parameter, parameterContext.getIndex()));\n\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#configureBlockingExecution(configurer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "configurer"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "void",
    "signature": "public void configureBlockingExecution(BlockingExecutionConfigurer configurer)",
    "source_code": "\t\tpublic void configureBlockingExecution(BlockingExecutionConfigurer configurer) {\n\t\t\tif (this.executionConsumer != null) {\n\t\t\t\tthis.executionConsumer.accept(configurer);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.ExchangeResult#getRawStatusCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the HTTP status code as an integer.\n\t * @since 5.1.10\n\t * @deprecated as of 6.0, in favor of {@link #getStatus()}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "int",
    "signature": "public int getRawStatusCode()",
    "source_code": "\tpublic int getRawStatusCode() {\n\t\treturn getStatus().value();\n\t}"
  },
  "org.springframework.util.xml.<unknown>#endPrefixMapping(prefix)": {
    "change": "modifier_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * End the prefix mapping for the given prefix.\n\t * @see org.xml.sax.ContentHandler#endPrefixMapping(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "prefix"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "void",
    "signature": "protected void endPrefixMapping(String prefix)",
    "source_code": "\tprotected void endPrefixMapping(String prefix) throws SAXException {\n\t\tif (getContentHandler() != null && this.namespaces.containsKey(prefix)) {\n\t\t\tgetContentHandler().endPrefixMapping(prefix);\n\t\t\tthis.namespaces.remove(prefix);\n\t\t}\n\t}"
  },
  "org.springframework.validation.DataBinder#construct(valueResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the target with constructor injection of values. It is expected that\n\t * {@link #setTargetType(ResolvableType)} was previously called and that\n\t * {@link #getTarget()} is {@code null}.\n\t * <p>Uses a public, no-arg constructor if available in the target object type,\n\t * also supporting a \"primary constructor\" approach for data classes as follows:\n\t * It understands the JavaBeans {@code ConstructorProperties} annotation as\n\t * well as runtime-retained parameter names in the bytecode, associating\n\t * input values with constructor arguments by name. If no such constructor is\n\t * found, the default constructor will be used (even if not public), assuming\n\t * subsequent bean property bindings through setter methods.\n\t * <p>After the call, use {@link #getBindingResult()} to check for failures\n\t * to bind to, and/or validate constructor arguments. If there are no errors,\n\t * the target is set, and {@link #doBind(MutablePropertyValues)} can be used\n\t * for further initialization via setters.\n\t * @param valueResolver to resolve constructor argument values with\n\t * @throws BeanInstantiationException in case of constructor failure\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "valueResolver"
    ],
    "position": {
      "column": 1,
      "line": 849
    },
    "return": "void",
    "signature": "public void construct(ValueResolver valueResolver)",
    "source_code": "\tpublic final void construct(ValueResolver valueResolver) {\n\t\tAssert.state(this.target == null, \"Target instance already available\");\n\t\tAssert.state(this.targetType != null, \"Target type not set\");\n\n\t\tthis.target = createObject(this.targetType, \"\", valueResolver);\n\n\t\tif (!getBindingResult().hasErrors()) {\n\t\t\tthis.bindingResult = null;\n\t\t\tif (this.typeConverter != null) {\n\t\t\t\tthis.typeConverter.registerCustomEditors(getPropertyAccessor());\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.validation.DataBinder#getTargetType()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link #setTargetType configured} type for the target object.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType getTargetType()",
    "source_code": "\tpublic ResolvableType getTargetType() {\n\t\treturn this.targetType;\n\t}"
  },
  "org.springframework.validation.DataBinder#getValidatorsToApply()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the Validators to apply after data binding. This includes the\n\t * configured {@link #getValidators() validators} filtered by the\n\t * {@link #setExcludedValidators(Predicate) exclude predicate}.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 694
    },
    "return": "List<Validator>",
    "signature": "public List<Validator> getValidatorsToApply()",
    "source_code": "\tpublic List<Validator> getValidatorsToApply() {\n\t\treturn (this.excludedValidators != null ?\n\t\t\t\tthis.validators.stream().filter(validator -> !this.excludedValidators.test(validator)).toList() :\n\t\t\t\tCollections.unmodifiableList(this.validators));\n\t}"
  },
  "org.springframework.validation.DataBinder#registerCustomEditors(registry)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 1215
    },
    "return": "void",
    "signature": "public void registerCustomEditors(PropertyEditorRegistry registry)",
    "source_code": "\t\tpublic void registerCustomEditors(PropertyEditorRegistry registry) {\n\t\t\tcopyCustomEditorsTo(registry, null);\n\t\t}"
  },
  "org.springframework.validation.DataBinder#setExcludedValidators(predicate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a predicate to exclude validators.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate"
    ],
    "position": {
      "column": 1,
      "line": 648
    },
    "return": "void",
    "signature": "public void setExcludedValidators(Predicate<Validator> predicate)",
    "source_code": "\tpublic void setExcludedValidators(Predicate<Validator> predicate) {\n\t\tthis.excludedValidators = predicate;\n\t}"
  },
  "org.springframework.validation.DataBinder#setTargetType(targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the type for the target object. When the target is {@code null},\n\t * setting the targetType allows using {@link #construct(ValueResolver)} to\n\t * create the target.\n\t * @param targetType the type of the target object\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "void",
    "signature": "public void setTargetType(ResolvableType targetType)",
    "source_code": "\tpublic void setTargetType(ResolvableType targetType) {\n\t\tAssert.state(this.target == null, \"targetType is used to for target creation, but target is already set\");\n\t\tthis.targetType = targetType;\n\t}"
  },
  "org.springframework.validation.ValueResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Contract to resolve a value in {@link #construct(ValueResolver)}.\n\t */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 1194
    },
    "signature": "public interface ValueResolver",
    "source_code": "\tpublic interface ValueResolver {\n\n\t\t/**\n\t\t * Look up the value for a constructor argument.\n\t\t * @param name the argument name\n\t\t * @param type the argument type\n\t\t * @return the resolved value, possibly {@code null}\n\t\t */\n\t\t@Nullable\n\t\tObject resolveValue(String name, Class<?> type);\n\n\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link MethodValidator} that uses a Bean Validation\n * {@link jakarta.validation.Validator} for validation, and adapts\n * {@link ConstraintViolation}s to {@link MethodValidationResult}.\n *\n * @author Rossen Stoyanchev\n * @since 6.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "signature": "public class MethodValidationAdapter",
    "source_code": "public class MethodValidationAdapter implements MethodValidator {\n\n\tprivate static final MethodValidationResult emptyValidationResult = MethodValidationResult.emptyResult();\n\n\tprivate static final ObjectNameResolver defaultObjectNameResolver = new DefaultObjectNameResolver();\n\n\tprivate static final Comparator<ParameterValidationResult> resultComparator = new ResultComparator();\n\n\n\tprivate final Supplier<Validator> validator;\n\n\tprivate final Supplier<SpringValidatorAdapter> validatorAdapter;\n\n\tprivate MessageCodesResolver messageCodesResolver = new DefaultMessageCodesResolver();\n\n\tprivate ParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer();\n\n\tprivate ObjectNameResolver objectNameResolver = defaultObjectNameResolver;\n\n\n\t/**\n\t * Create an instance using a default JSR-303 validator underneath.\n\t */\n\t@SuppressWarnings(\"DataFlowIssue\")\n\tpublic MethodValidationAdapter() {\n\t\tthis.validator = SingletonSupplier.of(() -> Validation.buildDefaultValidatorFactory().getValidator());\n\t\tthis.validatorAdapter = SingletonSupplier.of(() -> new SpringValidatorAdapter(this.validator.get()));\n\t}\n\n\t/**\n\t * Create an instance using the given JSR-303 ValidatorFactory.\n\t * @param validatorFactory the JSR-303 ValidatorFactory to use\n\t */\n\t@SuppressWarnings(\"DataFlowIssue\")\n\tpublic MethodValidationAdapter(ValidatorFactory validatorFactory) {\n\t\tthis.validator = SingletonSupplier.of(validatorFactory::getValidator);\n\t\tthis.validatorAdapter = SingletonSupplier.of(() -> new SpringValidatorAdapter(this.validator.get()));\n\t}\n\n\t/**\n\t * Create an instance using the given JSR-303 Validator.\n\t * @param validator the JSR-303 Validator to use\n\t */\n\tpublic MethodValidationAdapter(Validator validator) {\n\t\tthis.validator = () -> validator;\n\t\tthis.validatorAdapter = () -> new SpringValidatorAdapter(validator);\n\t}\n\n\t/**\n\t * Create an instance for the supplied (potentially lazily initialized) Validator.\n\t * @param validator a Supplier for the Validator to use\n\t */\n\tpublic MethodValidationAdapter(Supplier<Validator> validator) {\n\t\tthis.validator = validator;\n\t\tthis.validatorAdapter = () -> new SpringValidatorAdapter(this.validator.get());\n\t}\n\n\n\t/**\n\t * Set the strategy to use to determine message codes for violations.\n\t * <p>Default is a DefaultMessageCodesResolver.\n\t */\n\tpublic void setMessageCodesResolver(MessageCodesResolver messageCodesResolver) {\n\t\tthis.messageCodesResolver = messageCodesResolver;\n\t}\n\n\t/**\n\t * Return the {@link #setMessageCodesResolver(MessageCodesResolver) configured}\n\t * {@code MessageCodesResolver}.\n\t */\n\tpublic MessageCodesResolver getMessageCodesResolver() {\n\t\treturn this.messageCodesResolver;\n\t}\n\n\t/**\n\t * Set the {@code ParameterNameDiscoverer} to discover method parameter names\n\t * with to create error codes for {@link MessageSourceResolvable}. Used only\n\t * when {@link MethodParameter}s are not passed into\n\t * {@link #validateArguments} or {@link #validateReturnValue}.\n\t * <p>Default is {@link org.springframework.core.DefaultParameterNameDiscoverer}.\n\t */\n\tpublic void setParameterNameDiscoverer(ParameterNameDiscoverer parameterNameDiscoverer) {\n\t\tthis.parameterNameDiscoverer = parameterNameDiscoverer;\n\t}\n\n\t/**\n\t * Return the {@link #setParameterNameDiscoverer configured}\n\t * {@code ParameterNameDiscoverer}.\n\t */\n\tpublic ParameterNameDiscoverer getParameterNameDiscoverer() {\n\t\treturn this.parameterNameDiscoverer;\n\t}\n\n\t/**\n\t * Configure a resolver to determine the name of an {@code @Valid} method\n\t * parameter to use for its {@link BindingResult}. This allows aligning with\n\t * a higher level programming model such as to resolve the name of an\n\t * {@code @ModelAttribute} method parameter in Spring MVC.\n\t * <p>By default, the object name is resolved through:\n\t * <ul>\n\t * <li>{@link MethodParameter#getParameterName()} for input parameters\n\t * <li>{@link Conventions#getVariableNameForReturnType(Method, Class, Object)}\n\t * for a return type\n\t * </ul>\n\t * If a name cannot be determined, e.g. a return value with insufficient\n\t * type information, then it defaults to one of:\n\t * <ul>\n\t * <li>{@code \"{methodName}.arg{index}\"} for input parameters\n\t * <li>{@code \"{methodName}.returnValue\"} for a return type\n\t * </ul>\n\t */\n\tpublic void setObjectNameResolver(ObjectNameResolver nameResolver) {\n\t\tthis.objectNameResolver = nameResolver;\n\t}\n\n\n\t/**\n\t * {@inheritDoc}.\n\t * <p>Default are the validation groups as specified in the {@link Validated}\n\t * annotation on the method, or on the containing target class of the method,\n\t * or for an AOP proxy without a target (with all behavior in advisors), also\n\t * check on proxied interfaces.\n\t */\n\t@Override\n\tpublic Class<?>[] determineValidationGroups(Object target, Method method) {\n\t\tValidated validatedAnn = AnnotationUtils.findAnnotation(method, Validated.class);\n\t\tif (validatedAnn == null) {\n\t\t\tif (AopUtils.isAopProxy(target)) {\n\t\t\t\tfor (Class<?> type : AopProxyUtils.proxiedUserInterfaces(target)) {\n\t\t\t\t\tvalidatedAnn = AnnotationUtils.findAnnotation(type, Validated.class);\n\t\t\t\t\tif (validatedAnn != null) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalidatedAnn = AnnotationUtils.findAnnotation(target.getClass(), Validated.class);\n\t\t\t}\n\t\t}\n\t\treturn (validatedAnn != null ? validatedAnn.value() : new Class<?>[0]);\n\t}\n\n\t@Override\n\tpublic final MethodValidationResult validateArguments(\n\t\t\tObject target, Method method, @Nullable MethodParameter[] parameters, Object[] arguments,\n\t\t\tClass<?>[] groups) {\n\n\t\tSet<ConstraintViolation<Object>> violations =\n\t\t\t\tinvokeValidatorForArguments(target, method, arguments, groups);\n\n\t\tif (violations.isEmpty()) {\n\t\t\treturn emptyValidationResult;\n\t\t}\n\n\t\treturn adaptViolations(target, method, violations,\n\t\t\t\ti -> parameters != null ? parameters[i] : initMethodParameter(method, i),\n\t\t\t\ti -> arguments[i]);\n\t}\n\n\t/**\n\t * Invoke the validator, and return the resulting violations.\n\t */\n\tpublic final Set<ConstraintViolation<Object>> invokeValidatorForArguments(\n\t\t\tObject target, Method method, Object[] arguments, Class<?>[] groups) {\n\n\t\tExecutableValidator execVal = this.validator.get().forExecutables();\n\t\tSet<ConstraintViolation<Object>> violations;\n\t\ttry {\n\t\t\tviolations = execVal.validateParameters(target, method, arguments, groups);\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\t// Probably a generic type mismatch between interface and impl as reported in SPR-12237 / HV-1011\n\t\t\t// Let's try to find the bridged method on the implementation class...\n\t\t\tMethod mostSpecificMethod = ClassUtils.getMostSpecificMethod(method, target.getClass());\n\t\t\tMethod bridgedMethod = BridgeMethodResolver.findBridgedMethod(mostSpecificMethod);\n\t\t\tviolations = execVal.validateParameters(target, bridgedMethod, arguments, groups);\n\t\t}\n\t\treturn violations;\n\t}\n\n\t@Override\n\tpublic final MethodValidationResult validateReturnValue(\n\t\t\tObject target, Method method, @Nullable MethodParameter returnType, @Nullable Object returnValue,\n\t\t\tClass<?>[] groups) {\n\n\t\tSet<ConstraintViolation<Object>> violations =\n\t\t\t\tinvokeValidatorForReturnValue(target, method, returnValue, groups);\n\n\t\tif (violations.isEmpty()) {\n\t\t\treturn emptyValidationResult;\n\t\t}\n\n\t\treturn adaptViolations(target, method, violations,\n\t\t\t\ti -> returnType != null ? returnType : initMethodParameter(method, -1),\n\t\t\t\ti -> returnValue);\n\t}\n\n\t/**\n\t * Invoke the validator, and return the resulting violations.\n\t */\n\tpublic final Set<ConstraintViolation<Object>> invokeValidatorForReturnValue(\n\t\t\tObject target, Method method, @Nullable Object returnValue, Class<?>[] groups) {\n\n\t\tExecutableValidator execVal = this.validator.get().forExecutables();\n\t\treturn execVal.validateReturnValue(target, method, returnValue, groups);\n\t}\n\n\tprivate MethodValidationResult adaptViolations(\n\t\t\tObject target, Method method, Set<ConstraintViolation<Object>> violations,\n\t\t\tFunction<Integer, MethodParameter> parameterFunction,\n\t\t\tFunction<Integer, Object> argumentFunction) {\n\n\t\tMap<MethodParameter, ValueResultBuilder> parameterViolations = new LinkedHashMap<>();\n\t\tMap<Path.Node, BeanResultBuilder> cascadedViolations = new LinkedHashMap<>();\n\n\t\tfor (ConstraintViolation<Object> violation : violations) {\n\t\t\tIterator<Path.Node> itr = violation.getPropertyPath().iterator();\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tPath.Node node = itr.next();\n\n\t\t\t\tMethodParameter parameter;\n\t\t\t\tif (node.getKind().equals(ElementKind.PARAMETER)) {\n\t\t\t\t\tint index = node.as(Path.ParameterNode.class).getParameterIndex();\n\t\t\t\t\tparameter = parameterFunction.apply(index);\n\t\t\t\t}\n\t\t\t\telse if (node.getKind().equals(ElementKind.RETURN_VALUE)) {\n\t\t\t\t\tparameter = parameterFunction.apply(-1);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tObject argument = argumentFunction.apply(parameter.getParameterIndex());\n\t\t\t\tif (!itr.hasNext()) {\n\t\t\t\t\tparameterViolations\n\t\t\t\t\t\t\t.computeIfAbsent(parameter, p -> new ValueResultBuilder(target, parameter, argument))\n\t\t\t\t\t\t\t.addViolation(violation);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcascadedViolations\n\t\t\t\t\t\t\t.computeIfAbsent(node, n -> new BeanResultBuilder(parameter, argument, itr.next()))\n\t\t\t\t\t\t\t.addViolation(violation);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tList<ParameterValidationResult> validatonResultList = new ArrayList<>();\n\t\tparameterViolations.forEach((parameter, builder) -> validatonResultList.add(builder.build()));\n\t\tcascadedViolations.forEach((node, builder) -> validatonResultList.add(builder.build()));\n\t\tvalidatonResultList.sort(resultComparator);\n\n\t\treturn MethodValidationResult.create(target, method, validatonResultList);\n\t}\n\n\tprivate MethodParameter initMethodParameter(Method method, int index) {\n\t\tMethodParameter\tparameter = new MethodParameter(method, index);\n\t\tparameter.initParameterNameDiscovery(this.parameterNameDiscoverer);\n\t\treturn parameter;\n\t}\n\n\tprivate MessageSourceResolvable createMessageSourceResolvable(\n\t\t\tObject target, MethodParameter parameter, ConstraintViolation<Object> violation) {\n\n\t\tString objectName = Conventions.getVariableName(target) + \"#\" + parameter.getExecutable().getName();\n\t\tString paramName = (parameter.getParameterName() != null ? parameter.getParameterName() : \"\");\n\t\tClass<?> parameterType = parameter.getParameterType();\n\n\t\tConstraintDescriptor<?> descriptor = violation.getConstraintDescriptor();\n\t\tString code = descriptor.getAnnotation().annotationType().getSimpleName();\n\t\tString[] codes = this.messageCodesResolver.resolveMessageCodes(code, objectName, paramName, parameterType);\n\t\tObject[] arguments = this.validatorAdapter.get().getArgumentsForConstraint(objectName, paramName, descriptor);\n\n\t\treturn new DefaultMessageSourceResolvable(codes, arguments, violation.getMessage());\n\t}\n\n\tprivate BindingResult createBindingResult(MethodParameter parameter, @Nullable Object argument) {\n\t\tString objectName = this.objectNameResolver.resolveName(parameter, argument);\n\t\tBeanPropertyBindingResult result = new BeanPropertyBindingResult(argument, objectName);\n\t\tresult.setMessageCodesResolver(this.messageCodesResolver);\n\t\treturn result;\n\t}\n\n\n\t/**\n\t * Strategy to resolve the name of an {@code @Valid} method parameter to\n\t * use for its {@link BindingResult}.\n\t */\n\tpublic interface ObjectNameResolver {\n\n\t\t/**\n\t\t * Determine the name for the given method argument.\n\t\t * @param parameter the method parameter\n\t\t * @param value the argument value or return value\n\t\t * @return the name to use\n\t\t */\n\t\tString resolveName(MethodParameter parameter, @Nullable Object value);\n\n\t}\n\n\n\t/**\n\t * Builds a validation result for a value method parameter with constraints\n\t * declared directly on it.\n\t */\n\tprivate final class ValueResultBuilder {\n\n\t\tprivate final Object target;\n\n\t\tprivate final MethodParameter parameter;\n\n\t\t@Nullable\n\t\tprivate final Object argument;\n\n\t\tprivate final List<MessageSourceResolvable> resolvableErrors = new ArrayList<>();\n\n\t\tpublic ValueResultBuilder(Object target, MethodParameter parameter, @Nullable Object argument) {\n\t\t\tthis.target = target;\n\t\t\tthis.parameter = parameter;\n\t\t\tthis.argument = argument;\n\t\t}\n\n\t\tpublic void addViolation(ConstraintViolation<Object> violation) {\n\t\t\tthis.resolvableErrors.add(createMessageSourceResolvable(this.target, this.parameter, violation));\n\t\t}\n\n\t\tpublic ParameterValidationResult build() {\n\t\t\treturn new ParameterValidationResult(this.parameter, this.argument, this.resolvableErrors);\n\t\t}\n\n\t}\n\n\n\t/**\n\t * Builds a validation result for an {@link jakarta.validation.Valid @Valid}\n\t * annotated bean method parameter with cascaded constraints.\n\t */\n\tprivate final class BeanResultBuilder {\n\n\t\tprivate final MethodParameter parameter;\n\n\t\t@Nullable\n\t\tprivate final Object argument;\n\n\t\t@Nullable\n\t\tprivate final Object container;\n\n\t\t@Nullable\n\t\tprivate final Integer containerIndex;\n\n\t\t@Nullable\n\t\tprivate final Object containerKey;\n\n\t\tprivate final Errors errors;\n\n\t\tprivate final Set<ConstraintViolation<Object>> violations = new LinkedHashSet<>();\n\n\t\tpublic BeanResultBuilder(MethodParameter parameter, @Nullable Object argument, Path.Node node) {\n\t\t\tthis.parameter = parameter;\n\n\t\t\tthis.containerIndex = node.getIndex();\n\t\t\tthis.containerKey = node.getKey();\n\t\t\tif (argument instanceof List<?> list && this.containerIndex != null) {\n\t\t\t\tthis.container = list;\n\t\t\t\targument = list.get(this.containerIndex);\n\t\t\t}\n\t\t\telse if (argument instanceof Map<?, ?> map && this.containerKey != null) {\n\t\t\t\tthis.container = map;\n\t\t\t\targument = map.get(this.containerKey);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.container = null;\n\t\t\t}\n\n\t\t\tthis.argument = argument;\n\t\t\tthis.errors = createBindingResult(parameter, argument);\n\t\t}\n\n\t\tpublic void addViolation(ConstraintViolation<Object> violation) {\n\t\t\tthis.violations.add(violation);\n\t\t}\n\n\t\tpublic ParameterErrors build() {\n\t\t\tvalidatorAdapter.get().processConstraintViolations(this.violations, this.errors);\n\t\t\treturn new ParameterErrors(\n\t\t\t\t\tthis.parameter, this.argument, this.errors, this.container,\n\t\t\t\t\tthis.containerIndex, this.containerKey);\n\t\t}\n\t}\n\n\n\t/**\n\t * Default algorithm to select an object name, as described in\n\t * {@link #setObjectNameResolver(ObjectNameResolver)}.\n\t */\n\tprivate static class DefaultObjectNameResolver implements ObjectNameResolver {\n\n\t\t@Override\n\t\tpublic String resolveName(MethodParameter parameter, @Nullable Object value) {\n\t\t\tString objectName = null;\n\t\t\tif (parameter.getParameterIndex() != -1) {\n\t\t\t\tobjectName = parameter.getParameterName();\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\tMethod method = parameter.getMethod();\n\t\t\t\t\tif (method != null) {\n\t\t\t\t\t\tClass<?> containingClass = parameter.getContainingClass();\n\t\t\t\t\t\tClass<?> resolvedType = GenericTypeResolver.resolveReturnType(method, containingClass);\n\t\t\t\t\t\tobjectName = Conventions.getVariableNameForReturnType(method, resolvedType, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\t// insufficient type information\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (objectName == null) {\n\t\t\t\tint index = parameter.getParameterIndex();\n\t\t\t\tobjectName = (parameter.getExecutable().getName() + (index != -1 ? \".arg\" + index : \".returnValue\"));\n\t\t\t}\n\t\t\treturn objectName;\n\t\t}\n\t}\n\n\n\t/**\n\t * Comparator for validation results, sorted by method parameter index first,\n\t * also falling back on container indexes if necessary for cascaded\n\t * constraints on a List container.\n\t */\n\tprivate final static class ResultComparator implements Comparator<ParameterValidationResult> {\n\n\t\t@Override\n\t\tpublic int compare(ParameterValidationResult result1, ParameterValidationResult result2) {\n\t\t\tint index1 = result1.getMethodParameter().getParameterIndex();\n\t\t\tint index2 = result2.getMethodParameter().getParameterIndex();\n\t\t\tint i = Integer.compare(index1, index2);\n\t\t\tif (i != 0) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\tif (result1 instanceof ParameterErrors errors1 && result2 instanceof ParameterErrors errors2) {\n\t\t\t\tInteger containerIndex1 = errors1.getContainerIndex();\n\t\t\t\tInteger containerIndex2 = errors2.getContainerIndex();\n\t\t\t\tif (containerIndex1 != null && containerIndex2 != null) {\n\t\t\t\t\ti = Integer.compare(containerIndex1, containerIndex2);\n\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti = compareKeys(errors1, errors2);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tprivate <E> int compareKeys(ParameterErrors errors1, ParameterErrors errors2) {\n\t\t\tObject key1 = errors1.getContainerKey();\n\t\t\tObject key2 = errors2.getContainerKey();\n\t\t\tif (key1 instanceof Comparable<?> && key2 instanceof Comparable<?>) {\n\t\t\t\treturn ((Comparable<E>) key1).compareTo((E) key2);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#addViolation(violation)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "violation"
    ],
    "position": {
      "column": 1,
      "line": 451
    },
    "return": "void",
    "signature": "public void addViolation(ConstraintViolation<Object> violation)",
    "source_code": "\t\tpublic void addViolation(ConstraintViolation<Object> violation) {\n\t\t\tthis.violations.add(violation);\n\t\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#build()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 455
    },
    "return": "ParameterErrors",
    "signature": "public ParameterErrors build()",
    "source_code": "\t\tpublic ParameterErrors build() {\n\t\t\tvalidatorAdapter.get().processConstraintViolations(this.violations, this.errors);\n\t\t\treturn new ParameterErrors(\n\t\t\t\t\tthis.parameter, this.argument, this.errors, this.container,\n\t\t\t\t\tthis.containerIndex, this.containerKey);\n\t\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#compare(result1,result2)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "result1",
      "result2"
    ],
    "position": {
      "column": 1,
      "line": 506
    },
    "return": "int",
    "signature": "public int compare(ParameterValidationResult result1, ParameterValidationResult result2)",
    "source_code": "\t\tpublic int compare(ParameterValidationResult result1, ParameterValidationResult result2) {\n\t\t\tint index1 = result1.getMethodParameter().getParameterIndex();\n\t\t\tint index2 = result2.getMethodParameter().getParameterIndex();\n\t\t\tint i = Integer.compare(index1, index2);\n\t\t\tif (i != 0) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\tif (result1 instanceof ParameterErrors errors1 && result2 instanceof ParameterErrors errors2) {\n\t\t\t\tInteger containerIndex1 = errors1.getContainerIndex();\n\t\t\t\tInteger containerIndex2 = errors2.getContainerIndex();\n\t\t\t\tif (containerIndex1 != null && containerIndex2 != null) {\n\t\t\t\t\ti = Integer.compare(containerIndex1, containerIndex2);\n\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti = compareKeys(errors1, errors2);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#getMessageCodesResolver()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link #setMessageCodesResolver(MessageCodesResolver) configured}\n\t * {@code MessageCodesResolver}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "MessageCodesResolver",
    "signature": "public MessageCodesResolver getMessageCodesResolver()",
    "source_code": "\tpublic MessageCodesResolver getMessageCodesResolver() {\n\t\treturn this.messageCodesResolver;\n\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#getParameterNameDiscoverer()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link #setParameterNameDiscoverer configured}\n\t * {@code ParameterNameDiscoverer}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "ParameterNameDiscoverer",
    "signature": "public ParameterNameDiscoverer getParameterNameDiscoverer()",
    "source_code": "\tpublic ParameterNameDiscoverer getParameterNameDiscoverer() {\n\t\treturn this.parameterNameDiscoverer;\n\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#invokeValidatorForArguments(target,method,arguments,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the validator, and return the resulting violations.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "arguments",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "Set<ConstraintViolation<Object>>",
    "signature": "public Set<ConstraintViolation<Object>> invokeValidatorForArguments(Object target, Method method, Object[] arguments, Class<?>[] groups)",
    "source_code": "\tpublic final Set<ConstraintViolation<Object>> invokeValidatorForArguments("
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#invokeValidatorForReturnValue(target,method,returnValue,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the validator, and return the resulting violations.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "returnValue",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "Set<ConstraintViolation<Object>>",
    "signature": "public Set<ConstraintViolation<Object>> invokeValidatorForReturnValue(Object target, Method method, @Nullable Object returnValue, Class<?>[] groups)",
    "source_code": "\tpublic final Set<ConstraintViolation<Object>> invokeValidatorForReturnValue("
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#resolveName(parameter,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 471
    },
    "return": "String",
    "signature": "public String resolveName(MethodParameter parameter, @Nullable Object value)",
    "source_code": "\t\tpublic String resolveName(MethodParameter parameter, @Nullable Object value) {\n\t\t\tString objectName = null;\n\t\t\tif (parameter.getParameterIndex() != -1) {\n\t\t\t\tobjectName = parameter.getParameterName();\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\tMethod method = parameter.getMethod();\n\t\t\t\t\tif (method != null) {\n\t\t\t\t\t\tClass<?> containingClass = parameter.getContainingClass();\n\t\t\t\t\t\tClass<?> resolvedType = GenericTypeResolver.resolveReturnType(method, containingClass);\n\t\t\t\t\t\tobjectName = Conventions.getVariableNameForReturnType(method, resolvedType, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\t// insufficient type information\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (objectName == null) {\n\t\t\t\tint index = parameter.getParameterIndex();\n\t\t\t\tobjectName = (parameter.getExecutable().getName() + (index != -1 ? \".arg\" + index : \".returnValue\"));\n\t\t\t}\n\t\t\treturn objectName;\n\t\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#setMessageCodesResolver(messageCodesResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the strategy to use to determine message codes for violations.\n\t * <p>Default is a DefaultMessageCodesResolver.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageCodesResolver"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "void",
    "signature": "public void setMessageCodesResolver(MessageCodesResolver messageCodesResolver)",
    "source_code": "\tpublic void setMessageCodesResolver(MessageCodesResolver messageCodesResolver) {\n\t\tthis.messageCodesResolver = messageCodesResolver;\n\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#setObjectNameResolver(nameResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a resolver to determine the name of an {@code @Valid} method\n\t * parameter to use for its {@link BindingResult}. This allows aligning with\n\t * a higher level programming model such as to resolve the name of an\n\t * {@code @ModelAttribute} method parameter in Spring MVC.\n\t * <p>By default, the object name is resolved through:\n\t * <ul>\n\t * <li>{@link MethodParameter#getParameterName()} for input parameters\n\t * <li>{@link Conventions#getVariableNameForReturnType(Method, Class, Object)}\n\t * for a return type\n\t * </ul>\n\t * If a name cannot be determined, e.g. a return value with insufficient\n\t * type information, then it defaults to one of:\n\t * <ul>\n\t * <li>{@code \"{methodName}.arg{index}\"} for input parameters\n\t * <li>{@code \"{methodName}.returnValue\"} for a return type\n\t * </ul>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nameResolver"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "void",
    "signature": "public void setObjectNameResolver(ObjectNameResolver nameResolver)",
    "source_code": "\tpublic void setObjectNameResolver(ObjectNameResolver nameResolver) {\n\t\tthis.objectNameResolver = nameResolver;\n\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#setParameterNameDiscoverer(parameterNameDiscoverer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@code ParameterNameDiscoverer} to discover method parameter names\n\t * with to create error codes for {@link MessageSourceResolvable}. Used only\n\t * when {@link MethodParameter}s are not passed into\n\t * {@link #validateArguments} or {@link #validateReturnValue}.\n\t * <p>Default is {@link org.springframework.core.DefaultParameterNameDiscoverer}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterNameDiscoverer"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "void",
    "signature": "public void setParameterNameDiscoverer(ParameterNameDiscoverer parameterNameDiscoverer)",
    "source_code": "\tpublic void setParameterNameDiscoverer(ParameterNameDiscoverer parameterNameDiscoverer) {\n\t\tthis.parameterNameDiscoverer = parameterNameDiscoverer;\n\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#validateArguments(target,method,parameters,arguments,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "parameters",
      "arguments",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "MethodValidationResult",
    "signature": "public MethodValidationResult validateArguments(Object target, Method method, @Nullable MethodParameter[] parameters, Object[] arguments,\n\t\t\tClass<?>[] groups)",
    "source_code": "\tpublic final MethodValidationResult validateArguments("
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#validateReturnValue(target,method,returnType,returnValue,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "returnType",
      "returnValue",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "MethodValidationResult",
    "signature": "public MethodValidationResult validateReturnValue(Object target, Method method, @Nullable MethodParameter returnType, @Nullable Object returnValue,\n\t\t\tClass<?>[] groups)",
    "source_code": "\tpublic final MethodValidationResult validateReturnValue("
  },
  "org.springframework.validation.beanvalidation.ObjectNameResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Strategy to resolve the name of an {@code @Valid} method parameter to\n\t * use for its {@link BindingResult}.\n\t */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 361
    },
    "signature": "public interface ObjectNameResolver",
    "source_code": "\tpublic interface ObjectNameResolver {\n\n\t\t/**\n\t\t * Determine the name for the given method argument.\n\t\t * @param parameter the method parameter\n\t\t * @param value the argument value or return value\n\t\t * @return the name to use\n\t\t */\n\t\tString resolveName(MethodParameter parameter, @Nullable Object value);\n\n\t}"
  },
  "org.springframework.web.bind.MethodArgumentNotValidException": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Exception to be thrown when validation on an argument annotated with {@code @Valid} fails.\n * Extends {@link BindException} as of 5.3.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Sebastien Deleuze\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "public class MethodArgumentNotValidException",
    "source_code": "public class MethodArgumentNotValidException extends BindException implements ErrorResponse {\n\n\t@Nullable\n\tprivate final MethodParameter parameter;\n\n\t@Nullable\n\tprivate final Executable executable;\n\n\tprivate final ProblemDetail body;\n\n\n\t/**\n\t * Constructor for {@link MethodArgumentNotValidException}.\n\t * @param parameter the parameter that failed validation\n\t * @param bindingResult the results of the validation\n\t */\n\tpublic MethodArgumentNotValidException(MethodParameter parameter, BindingResult bindingResult) {\n\t\tsuper(bindingResult);\n\t\tthis.parameter = parameter;\n\t\tthis.executable = null;\n\t\tthis.body = ProblemDetail.forStatusAndDetail(getStatusCode(), \"Invalid request content.\");\n\t}\n\n\t/**\n\t * Constructor for {@link MethodArgumentNotValidException}.\n\t * @param executable the executable that failed validation\n\t * @param bindingResult the results of the validation\n\t * @since 6.0.5\n\t * @deprecated in favor of {@link #MethodArgumentNotValidException(MethodParameter, BindingResult)}\n\t */\n\t@Deprecated(since = \"6.0.10\", forRemoval = true)\n\tpublic MethodArgumentNotValidException(Executable executable, BindingResult bindingResult) {\n\t\tsuper(bindingResult);\n\t\tthis.parameter = null;\n\t\tthis.executable = executable;\n\t\tthis.body = ProblemDetail.forStatusAndDetail(getStatusCode(), \"Invalid request content.\");\n\t}\n\n\n\t@Override\n\tpublic HttpStatusCode getStatusCode() {\n\t\treturn HttpStatus.BAD_REQUEST;\n\t}\n\n\t@Override\n\tpublic ProblemDetail getBody() {\n\t\treturn this.body;\n\t}\n\n\t/**\n\t * Return the method parameter that failed validation.\n\t */\n\tpublic final MethodParameter getParameter() {\n\t\treturn this.parameter;\n\t}\n\n\t@Override\n\tpublic String getMessage() {\n\t\tStringBuilder sb = new StringBuilder(\"Validation failed \");\n\t\tif (this.parameter != null) {\n\t\t\tsb.append(\"for argument [\")\n\t\t\t\t\t.append(this.parameter.getParameterIndex()).append(\"] in \")\n\t\t\t\t\t.append(this.parameter.getExecutable().toGenericString());\n\t\t}\n\t\telse {\n\t\t\tsb.append(\"in \")\n\t\t\t\t\t.append(this.executable.toGenericString());\n\t\t}\n\t\tBindingResult bindingResult = getBindingResult();\n\t\tif (bindingResult.getErrorCount() > 1) {\n\t\t\tsb.append(\" with \").append(bindingResult.getErrorCount()).append(\" errors\");\n\t\t}\n\t\tsb.append(\": \");\n\t\tfor (ObjectError error : bindingResult.getAllErrors()) {\n\t\t\tsb.append('[').append(error).append(\"] \");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\t@Override\n\tpublic Object[] getDetailMessageArguments() {\n\t\treturn new Object[] {errorsToStringList(getGlobalErrors()), errorsToStringList(getFieldErrors())};\n\t}\n\n\t@Override\n\tpublic Object[] getDetailMessageArguments(MessageSource messageSource, Locale locale) {\n\t\treturn new Object[] {\n\t\t\t\terrorsToStringList(getGlobalErrors(), messageSource, locale),\n\t\t\t\terrorsToStringList(getFieldErrors(), messageSource, locale)\n\t\t};\n\t}\n\n\t/**\n\t * Resolve global and field errors to messages with the given\n\t * {@link MessageSource} and {@link Locale}.\n\t * @return a Map with errors as key and resolved messages as value\n\t * @since 6.0.3\n\t */\n\tpublic Map<ObjectError, String> resolveErrorMessages(MessageSource messageSource, Locale locale) {\n\t\tMap<ObjectError, String> map = new LinkedHashMap<>();\n\t\taddMessages(map, getGlobalErrors(), messageSource, locale);\n\t\taddMessages(map, getFieldErrors(), messageSource, locale);\n\t\treturn map;\n\t}\n\n\tprivate static void addMessages(\n\t\t\tMap<ObjectError, String> map, List<? extends ObjectError> errors,\n\t\t\tMessageSource messageSource, Locale locale) {\n\n\t\tList<String> messages = errorsToStringList(errors, messageSource, locale);\n\t\tfor (int i = 0; i < errors.size(); i++) {\n\t\t\tmap.put(errors.get(i), messages.get(i));\n\t\t}\n\t}\n\n\n\t/**\n\t * Convert each given {@link ObjectError} to a String in single quotes, taking\n\t * either the error's default message, or its error code.\n\t * @since 6.0\n\t */\n\tpublic static List<String> errorsToStringList(List<? extends ObjectError> errors) {\n\t\treturn errorsToStringList(errors, error ->\n\t\t\t\terror.getDefaultMessage() != null ? error.getDefaultMessage() : error.getCode());\n\t}\n\n\t/**\n\t * Variant of {@link #errorsToStringList(List)} that uses a\n\t * {@link MessageSource} to resolve the message code of the error, or fall\n\t * back on the error's default message.\n\t * @since 6.0\n\t */\n\tpublic static List<String> errorsToStringList(\n\t\t\tList<? extends ObjectError> errors, @Nullable MessageSource source, Locale locale) {\n\n\t\treturn (source != null ?\n\t\t\t\terrorsToStringList(errors, error -> source.getMessage(error, locale)) :\n\t\t\t\terrorsToStringList(errors));\n\t}\n\n\tprivate static List<String> errorsToStringList(\n\t\t\tList<? extends ObjectError> errors, Function<ObjectError, String> formatter) {\n\n\t\tList<String> result = new ArrayList<>(errors.size());\n\t\tfor (ObjectError error : errors) {\n\t\t\tString value = formatter.apply(error);\n\t\t\tif (StringUtils.hasText(value)) {\n\t\t\t\tresult.add(error instanceof FieldError fieldError ?\n\t\t\t\t\t\tfieldError.getField() + \": '\" + value + \"'\" : \"'\" + value + \"'\");\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n}"
  },
  "org.springframework.web.bind.MethodArgumentNotValidException#errorsToStringList(errors)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert each given {@link ObjectError} to a String in single quotes, taking\n\t * either the error's default message, or its error code.\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "List<String>",
    "signature": "public List<String> errorsToStringList(List<? extends ObjectError> errors)",
    "source_code": "\tpublic static List<String> errorsToStringList(List<? extends ObjectError> errors) {\n\t\treturn errorsToStringList(errors, error ->\n\t\t\t\terror.getDefaultMessage() != null ? error.getDefaultMessage() : error.getCode());\n\t}"
  },
  "org.springframework.web.bind.MethodArgumentNotValidException#errorsToStringList(errors,source,locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #errorsToStringList(List)} that uses a\n\t * {@link MessageSource} to resolve the message code of the error, or fall\n\t * back on the error's default message.\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors",
      "source",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "List<String>",
    "signature": "public List<String> errorsToStringList(List<? extends ObjectError> errors, @Nullable MessageSource source, Locale locale)",
    "source_code": "\tpublic static List<String> errorsToStringList("
  },
  "org.springframework.web.bind.MethodArgumentNotValidException#getBody()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "ProblemDetail",
    "signature": "public ProblemDetail getBody()",
    "source_code": "\tpublic ProblemDetail getBody() {\n\t\treturn this.body;\n\t}"
  },
  "org.springframework.web.bind.MethodArgumentNotValidException#getDetailMessageArguments()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "Object[]",
    "signature": "public Object[] getDetailMessageArguments()",
    "source_code": "\tpublic Object[] getDetailMessageArguments() {\n\t\treturn new Object[] {errorsToStringList(getGlobalErrors()), errorsToStringList(getFieldErrors())};\n\t}"
  },
  "org.springframework.web.bind.MethodArgumentNotValidException#getDetailMessageArguments(messageSource,locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSource",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "Object[]",
    "signature": "public Object[] getDetailMessageArguments(MessageSource messageSource, Locale locale)",
    "source_code": "\tpublic Object[] getDetailMessageArguments(MessageSource messageSource, Locale locale) {\n\t\treturn new Object[] {\n\t\t\t\terrorsToStringList(getGlobalErrors(), messageSource, locale),\n\t\t\t\terrorsToStringList(getFieldErrors(), messageSource, locale)\n\t\t};\n\t}"
  },
  "org.springframework.web.bind.MethodArgumentNotValidException#getMessage()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "String",
    "signature": "public String getMessage()",
    "source_code": "\tpublic String getMessage() {\n\t\tStringBuilder sb = new StringBuilder(\"Validation failed \");\n\t\tif (this.parameter != null) {\n\t\t\tsb.append(\"for argument [\")\n\t\t\t\t\t.append(this.parameter.getParameterIndex()).append(\"] in \")\n\t\t\t\t\t.append(this.parameter.getExecutable().toGenericString());\n\t\t}\n\t\telse {\n\t\t\tsb.append(\"in \")\n\t\t\t\t\t.append(this.executable.toGenericString());\n\t\t}\n\t\tBindingResult bindingResult = getBindingResult();\n\t\tif (bindingResult.getErrorCount() > 1) {\n\t\t\tsb.append(\" with \").append(bindingResult.getErrorCount()).append(\" errors\");\n\t\t}\n\t\tsb.append(\": \");\n\t\tfor (ObjectError error : bindingResult.getAllErrors()) {\n\t\t\tsb.append('[').append(error).append(\"] \");\n\t\t}\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.web.bind.MethodArgumentNotValidException#getParameter()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the method parameter that failed validation.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter getParameter()",
    "source_code": "\tpublic final MethodParameter getParameter() {\n\t\treturn this.parameter;\n\t}"
  },
  "org.springframework.web.bind.MethodArgumentNotValidException#getStatusCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "HttpStatusCode",
    "signature": "public HttpStatusCode getStatusCode()",
    "source_code": "\tpublic HttpStatusCode getStatusCode() {\n\t\treturn HttpStatus.BAD_REQUEST;\n\t}"
  },
  "org.springframework.web.bind.MethodArgumentNotValidException#resolveErrorMessages(messageSource,locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve global and field errors to messages with the given\n\t * {@link MessageSource} and {@link Locale}.\n\t * @return a Map with errors as key and resolved messages as value\n\t * @since 6.0.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSource",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "String>",
    "signature": "public String> resolveErrorMessages(MessageSource messageSource, Locale locale)",
    "source_code": "\tpublic Map<ObjectError, String> resolveErrorMessages(MessageSource messageSource, Locale locale) {\n\t\tMap<ObjectError, String> map = new LinkedHashMap<>();\n\t\taddMessages(map, getGlobalErrors(), messageSource, locale);\n\t\taddMessages(map, getFieldErrors(), messageSource, locale);\n\t\treturn map;\n\t}"
  },
  "org.springframework.web.bind.support.DefaultDataBinderFactory": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Create a {@link WebRequestDataBinder} instance and initialize it with a\n * {@link WebBindingInitializer}.\n *\n * @author Rossen Stoyanchev\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 35
    },
    "signature": "public class DefaultDataBinderFactory",
    "source_code": "public class DefaultDataBinderFactory implements WebDataBinderFactory {\n\n\t@Nullable\n\tprivate final WebBindingInitializer initializer;\n\n\tprivate boolean methodValidationApplicable;\n\n\n\t/**\n\t * Create a new {@code DefaultDataBinderFactory} instance.\n\t * @param initializer for global data binder initialization\n\t * (or {@code null} if none)\n\t */\n\tpublic DefaultDataBinderFactory(@Nullable WebBindingInitializer initializer) {\n\t\tthis.initializer = initializer;\n\t}\n\n\n\t/**\n\t * Configure flag to signal whether validation will be applied to handler\n\t * method arguments, which is the case if Bean Validation is enabled in\n\t * Spring MVC, and method parameters have {@code @Constraint} annotations.\n\t * @since 6.1\n\t */\n\tpublic void setMethodValidationApplicable(boolean methodValidationApplicable) {\n\t\tthis.methodValidationApplicable = methodValidationApplicable;\n\t}\n\n\n\t/**\n\t * Create a new {@link WebDataBinder} for the given target object and\n\t * initialize it through a {@link WebBindingInitializer}.\n\t * @throws Exception in case of invalid state or arguments\n\t */\n\t@Override\n\tpublic final WebDataBinder createBinder(\n\t\t\tNativeWebRequest webRequest, @Nullable Object target, String objectName) throws Exception {\n\n\t\treturn createBinderInternal(webRequest, target, objectName, null);\n\t}\n\n\t/**\n\t * {@inheritDoc}.\n\t * <p>By default, if the parameter has {@code @Valid}, Bean Validation is\n\t * excluded, deferring to method validation.\n\t */\n\t@Override\n\tpublic final WebDataBinder createBinder(\n\t\t\tNativeWebRequest webRequest, @Nullable Object target, String objectName,\n\t\t\tResolvableType type) throws Exception {\n\n\t\treturn createBinderInternal(webRequest, target, objectName, type);\n\t}\n\n\tprivate WebDataBinder createBinderInternal(\n\t\t\tNativeWebRequest webRequest, @Nullable Object target, String objectName,\n\t\t\t@Nullable ResolvableType type) throws Exception {\n\n\t\tWebDataBinder dataBinder = createBinderInstance(target, objectName, webRequest);\n\n\t\tif (target == null && type != null) {\n\t\t\tdataBinder.setTargetType(type);\n\t\t}\n\n\t\tif (this.initializer != null) {\n\t\t\tthis.initializer.initBinder(dataBinder);\n\t\t}\n\t\tinitBinder(dataBinder, webRequest);\n\n\t\tif (this.methodValidationApplicable && type != null) {\n\t\t\tif (type.getSource() instanceof MethodParameter parameter) {\n\t\t\t\tMethodValidationInitializer.initBinder(dataBinder, parameter);\n\t\t\t}\n\t\t}\n\n\t\treturn dataBinder;\n\t}\n\n\t/**\n\t * Extension point to create the WebDataBinder instance.\n\t * By default this is {@code WebRequestDataBinder}.\n\t * @param target the binding target or {@code null} for type conversion only\n\t * @param objectName the binding target object name\n\t * @param webRequest the current request\n\t * @throws Exception in case of invalid state or arguments\n\t */\n\tprotected WebDataBinder createBinderInstance(\n\t\t\t@Nullable Object target, String objectName, NativeWebRequest webRequest) throws Exception {\n\n\t\treturn new WebRequestDataBinder(target, objectName);\n\t}\n\n\t/**\n\t * Extension point to further initialize the created data binder instance\n\t * (e.g. with {@code @InitBinder} methods) after \"global\" initialization\n\t * via {@link WebBindingInitializer}.\n\t * @param dataBinder the data binder instance to customize\n\t * @param webRequest the current request\n\t * @throws Exception if initialization fails\n\t */\n\tprotected void initBinder(WebDataBinder dataBinder, NativeWebRequest webRequest)\n\t\t\tthrows Exception {\n\n\t}\n\n\n\t/**\n\t * Excludes Bean Validation if the method parameter has {@code @Valid}.\n\t */\n\tprivate static class MethodValidationInitializer {\n\n\t\tpublic static void initBinder(DataBinder binder, MethodParameter parameter) {\n\t\t\tfor (Annotation annotation : parameter.getParameterAnnotations()) {\n\t\t\t\tif (annotation.annotationType().getName().equals(\"jakarta.validation.Valid\")) {\n\t\t\t\t\tbinder.setExcludedValidators(validator -> validator instanceof jakarta.validation.Validator);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.bind.support.DefaultDataBinderFactory#createBinder(webRequest,target,objectName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link WebDataBinder} for the given target object and\n\t * initialize it through a {@link WebBindingInitializer}.\n\t * @throws Exception in case of invalid state or arguments\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webRequest",
      "target",
      "objectName"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "WebDataBinder",
    "signature": "public WebDataBinder createBinder(NativeWebRequest webRequest, @Nullable Object target, String objectName)",
    "source_code": "\tpublic final WebDataBinder createBinder("
  },
  "org.springframework.web.bind.support.DefaultDataBinderFactory#createBinder(webRequest,target,objectName,type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}.\n\t * <p>By default, if the parameter has {@code @Valid}, Bean Validation is\n\t * excluded, deferring to method validation.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webRequest",
      "target",
      "objectName",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "WebDataBinder",
    "signature": "public WebDataBinder createBinder(NativeWebRequest webRequest, @Nullable Object target, String objectName,\n\t\t\tResolvableType type)",
    "source_code": "\tpublic final WebDataBinder createBinder("
  },
  "org.springframework.web.bind.support.DefaultDataBinderFactory#createBinderInstance(target,objectName,webRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extension point to create the WebDataBinder instance.\n\t * By default this is {@code WebRequestDataBinder}.\n\t * @param target the binding target or {@code null} for type conversion only\n\t * @param objectName the binding target object name\n\t * @param webRequest the current request\n\t * @throws Exception in case of invalid state or arguments\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target",
      "objectName",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "WebDataBinder",
    "signature": "protected WebDataBinder createBinderInstance(@Nullable Object target, String objectName, NativeWebRequest webRequest)",
    "source_code": "\tprotected WebDataBinder createBinderInstance("
  },
  "org.springframework.web.bind.support.DefaultDataBinderFactory#initBinder(binder,parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "binder",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "void",
    "signature": "public void initBinder(DataBinder binder, MethodParameter parameter)",
    "source_code": "\t\tpublic static void initBinder(DataBinder binder, MethodParameter parameter) {\n\t\t\tfor (Annotation annotation : parameter.getParameterAnnotations()) {\n\t\t\t\tif (annotation.annotationType().getName().equals(\"jakarta.validation.Valid\")) {\n\t\t\t\t\tbinder.setExcludedValidators(validator -> validator instanceof jakarta.validation.Validator);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.bind.support.DefaultDataBinderFactory#initBinder(dataBinder,webRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extension point to further initialize the created data binder instance\n\t * (e.g. with {@code @InitBinder} methods) after \"global\" initialization\n\t * via {@link WebBindingInitializer}.\n\t * @param dataBinder the data binder instance to customize\n\t * @param webRequest the current request\n\t * @throws Exception if initialization fails\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "dataBinder",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "void",
    "signature": "protected void initBinder(WebDataBinder dataBinder, NativeWebRequest webRequest)",
    "source_code": "\tprotected void initBinder(WebDataBinder dataBinder, NativeWebRequest webRequest)"
  },
  "org.springframework.web.bind.support.DefaultDataBinderFactory#setMethodValidationApplicable(methodValidationApplicable)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure flag to signal whether validation will be applied to handler\n\t * method arguments, which is the case if Bean Validation is enabled in\n\t * Spring MVC, and method parameters have {@code @Constraint} annotations.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodValidationApplicable"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "void",
    "signature": "public void setMethodValidationApplicable(boolean methodValidationApplicable)",
    "source_code": "\tpublic void setMethodValidationApplicable(boolean methodValidationApplicable) {\n\t\tthis.methodValidationApplicable = methodValidationApplicable;\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeDataBinder#construct(exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Use a default or single data constructor to create the target by\n\t * binding request parameters, multipart files, or parts to constructor args.\n\t * <p>After the call, use {@link #getBindingResult()} to check for bind errors.\n\t * If there are none, the target is set, and {@link #bind} can be called for\n\t * further initialization via setters.\n\t * @param exchange the request to bind\n\t * @return a {@code Mono<Void>} that completes when the target is created\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> construct(ServerWebExchange exchange)",
    "source_code": "\tpublic Mono<Void> construct(ServerWebExchange exchange) {\n\t\treturn getValuesToBind(exchange)\n\t\t\t\t.doOnNext(map -> construct(new MapValueResolver(map)))\n\t\t\t\t.then();\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeDataBinder#resolveValue(name,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "Object",
    "signature": "public Object resolveValue(String name, Class<?> type)",
    "source_code": "\t\tpublic Object resolveValue(String name, Class<?> type) {\n\t\t\treturn this.map.get(name);\n\t\t}"
  },
  "org.springframework.web.bind.support.WebRequestDataBinder#construct(request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Use a default or single data constructor to create the target by\n\t * binding request parameters, multipart files, or parts to constructor args.\n\t * <p>After the call, use {@link #getBindingResult()} to check for bind errors.\n\t * If there are none, the target is set, and {@link #bind(WebRequest)}\n\t * can be called for further initialization via setters.\n\t * @param request the request to bind\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "public void construct(WebRequest request)",
    "source_code": "\tpublic void construct(WebRequest request) {\n\t\tif (request instanceof NativeWebRequest nativeRequest) {\n\t\t\tServletRequest servletRequest = nativeRequest.getNativeRequest(ServletRequest.class);\n\t\t\tif (servletRequest != null) {\n\t\t\t\tconstruct(ServletRequestDataBinder.valueResolver(servletRequest, this));\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.client.<unknown>#accept(acceptableMediaTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "acceptableMediaTypes"
    ],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec accept(MediaType... acceptableMediaTypes)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec accept(MediaType... acceptableMediaTypes) {\n\t\t\tgetHeaders().setAccept(Arrays.asList(acceptableMediaTypes));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#acceptCharset(acceptableCharsets)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "acceptableCharsets"
    ],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec acceptCharset(Charset... acceptableCharsets)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec acceptCharset(Charset... acceptableCharsets) {\n\t\t\tgetHeaders().setAcceptCharset(Arrays.asList(acceptableCharsets));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#attribute(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec attribute(String name, Object value)",
    "source_code": "\t\tpublic RequestBodySpec attribute(String name, Object value) {\n\t\t\tthis.attributes.put(name, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#attributes(Consumer<Map<String,attributesConsumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Consumer<Map<String",
      "attributesConsumer"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec attributes(Consumer<Map<String, Object>> attributesConsumer)",
    "source_code": "\t\tpublic RequestBodySpec attributes(Consumer<Map<String, Object>> attributesConsumer) {\n\t\t\tattributesConsumer.accept(this.attributes);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#body(body)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body"
    ],
    "position": {
      "column": 1,
      "line": 307
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec body(StreamingHttpOutputMessage.Body body)",
    "source_code": "\t\tpublic RequestBodySpec body(StreamingHttpOutputMessage.Body body) {\n\t\t\tthis.body = request -> body.writeTo(request.getBody());\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#body(body,bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 301
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec body(T body, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\t\tpublic <T> RequestBodySpec body(T body, ParameterizedTypeReference<T> bodyType) {\n\t\t\tthis.body = clientHttpRequest -> writeWithMessageConverters(body, bodyType.getType(), clientHttpRequest);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#body(bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 508
    },
    "return": "T",
    "signature": "public T body(ParameterizedTypeReference<T> bodyType)",
    "source_code": "\t\tpublic <T> T body(ParameterizedTypeReference<T> bodyType) {\n\t\t\tType type = bodyType.getType();\n\t\t\tClass<T> bodyClass = bodyClass(type);\n\t\t\treturn readWithMessageConverters(type, bodyClass);\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#build()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 344
    },
    "return": "RestClient",
    "signature": "public RestClient build()",
    "source_code": "\tpublic RestClient build() {\n\t\tClientHttpRequestFactory requestFactory = initRequestFactory();\n\t\tUriBuilderFactory uriBuilderFactory = initUriBuilderFactory();\n\t\tHttpHeaders defaultHeaders = copyDefaultHeaders();\n\t\tList<HttpMessageConverter<?>> messageConverters = (this.messageConverters != null ?\n\t\t\t\tthis.messageConverters : initMessageConverters());\n\t\treturn new DefaultRestClient(requestFactory,\n\t\t\t\tthis.interceptors, this.initializers, uriBuilderFactory,\n\t\t\t\tdefaultHeaders,\n\t\t\t\tthis.statusHandlers,\n\t\t\t\tmessageConverters,\n\t\t\t\tnew DefaultRestClientBuilder(this)\n\t\t\t\t);\n\t}"
  },
  "org.springframework.web.client.<unknown>#contentLength(contentLength)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentLength"
    ],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec contentLength(long contentLength)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec contentLength(long contentLength) {\n\t\t\tgetHeaders().setContentLength(contentLength);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#contentType(contentType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec contentType(MediaType contentType)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec contentType(MediaType contentType) {\n\t\t\tgetHeaders().setContentType(contentType);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#exchange(exchangeFunction,close)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchangeFunction",
      "close"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "T",
    "signature": "public T exchange(ExchangeFunction<T> exchangeFunction, boolean close)",
    "source_code": "\t\tpublic <T> T exchange(ExchangeFunction<T> exchangeFunction, boolean close) {\n\t\t\treturn exchangeInternal(exchangeFunction, close);\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#header(headerName,headerValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 226
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec header(String headerName, String... headerValues)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec header(String headerName, String... headerValues) {\n\t\t\tfor (String headerValue : headerValues) {\n\t\t\t\tgetHeaders().add(headerName, headerValue);\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#headers(headersConsumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headersConsumer"
    ],
    "position": {
      "column": 1,
      "line": 234
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec headers(Consumer<HttpHeaders> headersConsumer)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec headers(Consumer<HttpHeaders> headersConsumer) {\n\t\t\theadersConsumer.accept(getHeaders());\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#httpRequest(requestConsumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestConsumer"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec httpRequest(Consumer<ClientHttpRequest> requestConsumer)",
    "source_code": "\t\tpublic RequestBodySpec httpRequest(Consumer<ClientHttpRequest> requestConsumer) {\n\t\t\tthis.httpRequestConsumer = (this.httpRequestConsumer != null ?\n\t\t\t\t\tthis.httpRequestConsumer.andThen(requestConsumer) : requestConsumer);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#ifModifiedSince(ifModifiedSince)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ifModifiedSince"
    ],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec ifModifiedSince(ZonedDateTime ifModifiedSince)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec ifModifiedSince(ZonedDateTime ifModifiedSince) {\n\t\t\tgetHeaders().setIfModifiedSince(ifModifiedSince);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#ifNoneMatch(ifNoneMatches)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ifNoneMatches"
    ],
    "position": {
      "column": 1,
      "line": 270
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec ifNoneMatch(String... ifNoneMatches)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec ifNoneMatch(String... ifNoneMatches) {\n\t\t\tgetHeaders().setIfNoneMatch(Arrays.asList(ifNoneMatches));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#method(method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "RequestBodyUriSpec",
    "signature": "public RequestBodyUriSpec method(HttpMethod method)",
    "source_code": "\tpublic RequestBodyUriSpec method(HttpMethod method) {\n\t\tAssert.notNull(method, \"HttpMethod must not be null\");\n\t\treturn methodInternal(method);\n\t}"
  },
  "org.springframework.web.client.<unknown>#mutate()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "Builder",
    "signature": "public Builder mutate()",
    "source_code": "\tpublic Builder mutate() {\n\t\treturn new DefaultRestClientBuilder(this.builder);\n\t}"
  },
  "org.springframework.web.client.<unknown>#onStatus(errorHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorHandler"
    ],
    "position": {
      "column": 1,
      "line": 488
    },
    "return": "ResponseSpec",
    "signature": "public ResponseSpec onStatus(ResponseErrorHandler errorHandler)",
    "source_code": "\t\tpublic ResponseSpec onStatus(ResponseErrorHandler errorHandler) {\n\t\t\tAssert.notNull(errorHandler, \"ResponseErrorHandler must not be null\");\n\n\t\t\treturn onStatusInternal(StatusHandler.fromErrorHandler(errorHandler));\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#onStatus(statusPredicate,errorHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusPredicate",
      "errorHandler"
    ],
    "position": {
      "column": 1,
      "line": 480
    },
    "return": "ResponseSpec",
    "signature": "public ResponseSpec onStatus(Predicate<HttpStatusCode> statusPredicate, ErrorHandler errorHandler)",
    "source_code": "\t\tpublic ResponseSpec onStatus(Predicate<HttpStatusCode> statusPredicate, ErrorHandler errorHandler) {\n\t\t\tAssert.notNull(statusPredicate, \"StatusPredicate must not be null\");\n\t\t\tAssert.notNull(errorHandler, \"ErrorHandler must not be null\");\n\n\t\t\treturn onStatusInternal(StatusHandler.of(statusPredicate, errorHandler));\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#patch()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "RequestBodyUriSpec",
    "signature": "public RequestBodyUriSpec patch()",
    "source_code": "\tpublic RequestBodyUriSpec patch() {\n\t\treturn methodInternal(HttpMethod.PATCH);\n\t}"
  },
  "org.springframework.web.client.<unknown>#post()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "RequestBodyUriSpec",
    "signature": "public RequestBodyUriSpec post()",
    "source_code": "\tpublic RequestBodyUriSpec post() {\n\t\treturn methodInternal(HttpMethod.POST);\n\t}"
  },
  "org.springframework.web.client.<unknown>#put()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "RequestBodyUriSpec",
    "signature": "public RequestBodyUriSpec put()",
    "source_code": "\tpublic RequestBodyUriSpec put() {\n\t\treturn methodInternal(HttpMethod.PUT);\n\t}"
  },
  "org.springframework.web.client.<unknown>#retrieve()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 358
    },
    "return": "ResponseSpec",
    "signature": "public ResponseSpec retrieve()",
    "source_code": "\t\tpublic ResponseSpec retrieve() {\n\t\t\treturn exchangeInternal(DefaultResponseSpec::new, false);\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#toBodilessEntity()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 539
    },
    "return": "ResponseEntity<Void>",
    "signature": "public ResponseEntity<Void> toBodilessEntity()",
    "source_code": "\t\tpublic ResponseEntity<Void> toBodilessEntity() {\n\t\t\ttry (this.clientResponse) {\n\t\t\t\tapplyStatusHandlers(this.clientRequest, this.clientResponse);\n\t\t\t\treturn ResponseEntity.status(this.clientResponse.getStatusCode())\n\t\t\t\t\t\t.headers(this.clientResponse.getHeaders())\n\t\t\t\t\t\t.build();\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new ResourceAccessException(\"Could not retrieve response status code: \" + ex.getMessage(), ex);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#toEntity(bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 520
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> toEntity(ParameterizedTypeReference<T> bodyType)",
    "source_code": "\t\tpublic <T> ResponseEntity<T> toEntity(ParameterizedTypeReference<T> bodyType) {\n\t\t\tType type = bodyType.getType();\n\t\t\tClass<T> bodyClass = bodyClass(type);\n\t\t\treturn toEntityInternal(type, bodyClass);\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#uri(Function<UriBuilder,uriFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<UriBuilder",
      "uriFunction"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(Function<UriBuilder, URI> uriFunction)",
    "source_code": "\t\tpublic RequestBodySpec uri(Function<UriBuilder, URI> uriFunction) {\n\t\t\treturn uri(uriFunction.apply(DefaultRestClient.this.uriBuilderFactory.builder()));\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#uri(uri)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uri"
    ],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(URI uri)",
    "source_code": "\t\tpublic RequestBodySpec uri(URI uri) {\n\t\t\tthis.uri = uri;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#uri(uriTemplate,Function<UriBuilder,uriFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "Function<UriBuilder",
      "uriFunction"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, Function<UriBuilder, URI> uriFunction)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, Function<UriBuilder, URI> uriFunction) {\n\t\t\tattribute(URI_TEMPLATE_ATTRIBUTE, uriTemplate);\n\t\t\treturn uri(uriFunction.apply(DefaultRestClient.this.uriBuilderFactory.uriString(uriTemplate)));\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#uri(uriTemplate,Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, Map<String, ?> uriVariables)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, Map<String, ?> uriVariables) {\n\t\t\tattribute(URI_TEMPLATE_ATTRIBUTE, uriTemplate);\n\t\t\treturn uri(DefaultRestClient.this.uriBuilderFactory.expand(uriTemplate, uriVariables));\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#uri(uriTemplate,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, Object... uriVariables)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, Object... uriVariables) {\n\t\t\tattribute(URI_TEMPLATE_ATTRIBUTE, uriTemplate);\n\t\t\treturn uri(DefaultRestClient.this.uriBuilderFactory.expand(uriTemplate, uriVariables));\n\t\t}"
  },
  "org.springframework.web.method.HandlerMethod#checkArguments(beanType,parameters)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanType",
      "parameters"
    ],
    "position": {
      "column": 1,
      "line": 392
    },
    "return": "boolean",
    "signature": "public boolean checkArguments(Class<?> beanType, MethodParameter[] parameters)",
    "source_code": "\t\tpublic static boolean checkArguments(Class<?> beanType, MethodParameter[] parameters) {\n\t\t\tif (AnnotationUtils.findAnnotation(beanType, Validated.class) == null) {\n\t\t\t\tfor (MethodParameter parameter : parameters) {\n\t\t\t\t\tMergedAnnotations merged = MergedAnnotations.from(parameter.getParameterAnnotations());\n\t\t\t\t\tif (merged.stream().anyMatch(INPUT_PREDICATE)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.web.method.HandlerMethod#checkReturnValue(beanType,method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanType",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 404
    },
    "return": "boolean",
    "signature": "public boolean checkReturnValue(Class<?> beanType, Method method)",
    "source_code": "\t\tpublic static boolean checkReturnValue(Class<?> beanType, Method method) {\n\t\t\tif (AnnotationUtils.findAnnotation(beanType, Validated.class) == null) {\n\t\t\t\tMergedAnnotations merged = MergedAnnotations.from(method, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY);\n\t\t\t\treturn merged.stream().anyMatch(OUTPUT_PREDICATE);\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.web.method.HandlerMethod#clone()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 597
    },
    "return": "ReturnValueMethodParameter",
    "signature": "public ReturnValueMethodParameter clone()",
    "source_code": "\t\tpublic ReturnValueMethodParameter clone() {\n\t\t\treturn new ReturnValueMethodParameter(this);\n\t\t}"
  },
  "org.springframework.web.method.HandlerMethod#findProvidedArgument(parameter,providedArgs)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 446
    },
    "return": "Object",
    "signature": "protected Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs)",
    "source_code": "\tprotected static Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs) {\n\t\tif (!ObjectUtils.isEmpty(providedArgs)) {\n\t\t\tfor (Object providedArg : providedArgs) {\n\t\t\t\tif (parameter.getParameterType().isInstance(providedArg)) {\n\t\t\t\t\treturn providedArg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.method.HandlerMethod#formatArgumentError(param,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "param",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 457
    },
    "return": "String",
    "signature": "protected String formatArgumentError(MethodParameter param, String message)",
    "source_code": "\tprotected static String formatArgumentError(MethodParameter param, String message) {\n\t\treturn \"Could not resolve parameter [\" + param.getParameterIndex() + \"] in \" +\n\t\t\t\tparam.getExecutable().toGenericString() + (StringUtils.hasText(message) ? \": \" + message : \"\");\n\t}"
  },
  "org.springframework.web.method.HandlerMethod#getBridgedMethod()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * If the bean method is a bridge method, this method returns the bridged\n\t * (user-defined) method. Otherwise, it returns the same method as {@link #getMethod()}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 283
    },
    "return": "Method",
    "signature": "protected Method getBridgedMethod()",
    "source_code": "\tprotected Method getBridgedMethod() {\n\t\treturn this.bridgedMethod;\n\t}"
  },
  "org.springframework.web.method.HandlerMethod#getMethod()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 512
    },
    "return": "Method",
    "signature": "public Method getMethod()",
    "source_code": "\t\tpublic Method getMethod() {\n\t\t\treturn HandlerMethod.this.bridgedMethod;\n\t\t}"
  },
  "org.springframework.web.method.HandlerMethod#getMethodAnnotation(annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 522
    },
    "return": "T",
    "signature": "public T getMethodAnnotation(Class<T> annotationType)",
    "source_code": "\t\tpublic <T extends Annotation> T getMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn HandlerMethod.this.getMethodAnnotation(annotationType);\n\t\t}"
  },
  "org.springframework.web.method.HandlerMethod#getMethodParameters()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the method parameters for this handler method.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "MethodParameter[]",
    "signature": "public MethodParameter[] getMethodParameters()",
    "source_code": "\tpublic MethodParameter[] getMethodParameters() {\n\t\treturn this.parameters;\n\t}"
  },
  "org.springframework.web.method.HandlerMethod#getParameterAnnotations()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 532
    },
    "return": "Annotation[]",
    "signature": "public Annotation[] getParameterAnnotations()",
    "source_code": "\t\tpublic Annotation[] getParameterAnnotations() {\n\t\t\tAnnotation[] anns = this.combinedAnnotations;\n\t\t\tif (anns == null) {\n\t\t\t\tanns = super.getParameterAnnotations();\n\t\t\t\tint index = getParameterIndex();\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tfor (Annotation[][] ifcAnns : getInterfaceParameterAnnotations()) {\n\t\t\t\t\t\tif (index < ifcAnns.length) {\n\t\t\t\t\t\t\tAnnotation[] paramAnns = ifcAnns[index];\n\t\t\t\t\t\t\tif (paramAnns.length > 0) {\n\t\t\t\t\t\t\t\tList<Annotation> merged = new ArrayList<>(anns.length + paramAnns.length);\n\t\t\t\t\t\t\t\tmerged.addAll(Arrays.asList(anns));\n\t\t\t\t\t\t\t\tfor (Annotation paramAnn : paramAnns) {\n\t\t\t\t\t\t\t\t\tboolean existingType = false;\n\t\t\t\t\t\t\t\t\tfor (Annotation ann : anns) {\n\t\t\t\t\t\t\t\t\t\tif (ann.annotationType() == paramAnn.annotationType()) {\n\t\t\t\t\t\t\t\t\t\t\texistingType = true;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!existingType) {\n\t\t\t\t\t\t\t\t\t\tmerged.add(adaptAnnotation(paramAnn));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tanns = merged.toArray(new Annotation[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.combinedAnnotations = anns;\n\t\t\t}\n\t\t\treturn anns;\n\t\t}"
  },
  "org.springframework.web.method.HandlerMethod#getReturnType()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the HandlerMethod return type.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 317
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter getReturnType()",
    "source_code": "\tpublic MethodParameter getReturnType() {\n\t\treturn new HandlerMethodParameter(-1);\n\t}"
  },
  "org.springframework.web.method.HandlerMethod#getReturnValueType(returnValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the actual return value type.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue"
    ],
    "position": {
      "column": 1,
      "line": 324
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter getReturnValueType(@Nullable Object returnValue)",
    "source_code": "\tpublic MethodParameter getReturnValueType(@Nullable Object returnValue) {\n\t\treturn new ReturnValueMethodParameter(returnValue);\n\t}"
  },
  "org.springframework.web.method.HandlerMethod#hasMethodAnnotation(annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 527
    },
    "return": "boolean",
    "signature": "public boolean hasMethodAnnotation(Class<T> annotationType)",
    "source_code": "\t\tpublic <T extends Annotation> boolean hasMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn HandlerMethod.this.hasMethodAnnotation(annotationType);\n\t\t}"
  },
  "org.springframework.web.method.HandlerMethod#isVoid()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return {@code true} if the method return type is void, {@code false} otherwise.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 331
    },
    "return": "boolean",
    "signature": "public boolean isVoid()",
    "source_code": "\tpublic boolean isVoid() {\n\t\treturn Void.TYPE.equals(getReturnType().getParameterType());\n\t}"
  },
  "org.springframework.web.method.HandlerMethod#shouldValidateArguments()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the method arguments are a candidate for method validation, which\n\t * is the case when there are parameter {@code jakarta.validation.Constraint}\n\t * annotations.\n\t * <p>The presence of {@code jakarta.validation.Valid} by itself does not\n\t * trigger method validation since such parameters are already validated at\n\t * the level of argument resolvers.\n\t * <p><strong>Note:</strong> if the class is annotated with {@link Validated},\n\t * this method returns false, deferring to method validation via AOP proxy.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "boolean",
    "signature": "public boolean shouldValidateArguments()",
    "source_code": "\tpublic boolean shouldValidateArguments() {\n\t\treturn this.validateArguments;\n\t}"
  },
  "org.springframework.web.method.HandlerMethod#shouldValidateReturnValue()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the method return value is a candidate for method validation, which\n\t * is the case when there are method {@code jakarta.validation.Constraint}\n\t * or {@code jakarta.validation.Valid} annotations.\n\t * <p><strong>Note:</strong> if the class is annotated with {@link Validated},\n\t * this method returns false, deferring to method validation via AOP proxy.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "boolean",
    "signature": "public boolean shouldValidateReturnValue()",
    "source_code": "\tpublic boolean shouldValidateReturnValue() {\n\t\treturn this.validateReturnValue;\n\t}"
  },
  "org.springframework.web.method.HandlerMethodParameter": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * A MethodParameter with HandlerMethod-specific behavior.\n\t */",
    "kind": "class",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 497
    },
    "signature": "protected class HandlerMethodParameter",
    "source_code": "\tprotected class HandlerMethodParameter extends SynthesizingMethodParameter {\n\n\t\t@Nullable\n\t\tprivate volatile Annotation[] combinedAnnotations;\n\n\t\tpublic HandlerMethodParameter(int index) {\n\t\t\tsuper(HandlerMethod.this.bridgedMethod, index);\n\t\t}\n\n\t\tprotected HandlerMethodParameter(HandlerMethodParameter original) {\n\t\t\tsuper(original);\n\t\t}\n\n\t\t@Override\n\t\t@NonNull\n\t\tpublic Method getMethod() {\n\t\t\treturn HandlerMethod.this.bridgedMethod;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<?> getContainingClass() {\n\t\t\treturn HandlerMethod.this.getBeanType();\n\t\t}\n\n\t\t@Override\n\t\tpublic <T extends Annotation> T getMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn HandlerMethod.this.getMethodAnnotation(annotationType);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T extends Annotation> boolean hasMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn HandlerMethod.this.hasMethodAnnotation(annotationType);\n\t\t}\n\n\t\t@Override\n\t\tpublic Annotation[] getParameterAnnotations() {\n\t\t\tAnnotation[] anns = this.combinedAnnotations;\n\t\t\tif (anns == null) {\n\t\t\t\tanns = super.getParameterAnnotations();\n\t\t\t\tint index = getParameterIndex();\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tfor (Annotation[][] ifcAnns : getInterfaceParameterAnnotations()) {\n\t\t\t\t\t\tif (index < ifcAnns.length) {\n\t\t\t\t\t\t\tAnnotation[] paramAnns = ifcAnns[index];\n\t\t\t\t\t\t\tif (paramAnns.length > 0) {\n\t\t\t\t\t\t\t\tList<Annotation> merged = new ArrayList<>(anns.length + paramAnns.length);\n\t\t\t\t\t\t\t\tmerged.addAll(Arrays.asList(anns));\n\t\t\t\t\t\t\t\tfor (Annotation paramAnn : paramAnns) {\n\t\t\t\t\t\t\t\t\tboolean existingType = false;\n\t\t\t\t\t\t\t\t\tfor (Annotation ann : anns) {\n\t\t\t\t\t\t\t\t\t\tif (ann.annotationType() == paramAnn.annotationType()) {\n\t\t\t\t\t\t\t\t\t\t\texistingType = true;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!existingType) {\n\t\t\t\t\t\t\t\t\t\tmerged.add(adaptAnnotation(paramAnn));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tanns = merged.toArray(new Annotation[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.combinedAnnotations = anns;\n\t\t\t}\n\t\t\treturn anns;\n\t\t}\n\n\t\t@Override\n\t\tpublic HandlerMethodParameter clone() {\n\t\t\treturn new HandlerMethodParameter(this);\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.HandlerMethodValidator": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link MethodValidator} that\n * uses Bean Validation to validate {@code @RequestMapping} method arguments.\n *\n * <p>Handles validation results by populating {@link BindingResult} method\n * arguments with errors from {@link MethodValidationResult#getBeanResults()\n * beanResults}. Also, helps to determine parameter names for\n * {@code @ModelAttribute} and {@code @RequestBody} parameters.\n *\n * @author Rossen Stoyanchev\n * @since 6.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "public class HandlerMethodValidator",
    "source_code": "public final class HandlerMethodValidator implements MethodValidator {\n\n\tprivate static final MethodValidationAdapter.ObjectNameResolver objectNameResolver = new WebObjectNameResolver();\n\n\n\tprivate final MethodValidationAdapter validationAdapter;\n\n\tprivate final Predicate<MethodParameter> modelAttribitePredicate;\n\n\tprivate final Predicate<MethodParameter> requestParamPredicate;\n\n\n\tprivate HandlerMethodValidator(MethodValidationAdapter validationAdapter,\n\t\t\tPredicate<MethodParameter> modelAttribitePredicate, Predicate<MethodParameter> requestParamPredicate) {\n\n\t\tthis.validationAdapter = validationAdapter;\n\t\tthis.modelAttribitePredicate = modelAttribitePredicate;\n\t\tthis.requestParamPredicate = requestParamPredicate;\n\t}\n\n\n\t@Override\n\tpublic Class<?>[] determineValidationGroups(Object target, Method method) {\n\t\treturn this.validationAdapter.determineValidationGroups(target, method);\n\t}\n\n\t@Override\n\tpublic void applyArgumentValidation(\n\t\t\tObject target, Method method, @Nullable MethodParameter[] parameters,\n\t\t\tObject[] arguments, Class<?>[] groups) {\n\n\t\tMethodValidationResult result = validateArguments(target, method, parameters, arguments, groups);\n\t\tif (!result.hasErrors()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!result.getBeanResults().isEmpty()) {\n\t\t\tint bindingResultCount = 0;\n\t\t\tfor (ParameterErrors errors : result.getBeanResults()) {\n\t\t\t\tfor (Object arg : arguments) {\n\t\t\t\t\tif (arg instanceof BindingResult bindingResult) {\n\t\t\t\t\t\tif (bindingResult.getObjectName().equals(errors.getObjectName())) {\n\t\t\t\t\t\t\tbindingResult.addAllErrors(errors);\n\t\t\t\t\t\t\tbindingResultCount++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result.getAllValidationResults().size() == bindingResultCount) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthrow new HandlerMethodValidationException(\n\t\t\t\tresult, this.modelAttribitePredicate, this.requestParamPredicate);\n\t}\n\n\t@Override\n\tpublic MethodValidationResult validateArguments(\n\t\t\tObject target, Method method, @Nullable MethodParameter[] parameters,\n\t\t\tObject[] arguments, Class<?>[] groups) {\n\n\t\treturn this.validationAdapter.validateArguments(target, method, parameters, arguments, groups);\n\t}\n\n\t@Override\n\tpublic void applyReturnValueValidation(\n\t\t\tObject target, Method method, @Nullable MethodParameter returnType,\n\t\t\t@Nullable Object returnValue, Class<?>[] groups) {\n\n\t\tMethodValidationResult result = validateReturnValue(target, method, returnType, returnValue, groups);\n\t\tif (result.hasErrors()) {\n\t\t\tthrow new HandlerMethodValidationException(result);\n\t\t}\n\t}\n\n\t@Override\n\tpublic MethodValidationResult validateReturnValue(Object target, Method method,\n\t\t\t@Nullable MethodParameter returnType, @Nullable Object returnValue, Class<?>[] groups) {\n\n\t\treturn this.validationAdapter.validateReturnValue(target, method, returnType, returnValue, groups);\n\t}\n\n\n\t/**\n\t * Static factory method to create a {@link HandlerMethodValidator} when Bean\n\t * Validation is enabled for use via {@link ConfigurableWebBindingInitializer},\n\t * for example in Spring MVC or WebFlux config.\n\t */\n\t@Nullable\n\tpublic static MethodValidator from(\n\t\t\t@Nullable WebBindingInitializer initializer, @Nullable ParameterNameDiscoverer paramNameDiscoverer,\n\t\t\tPredicate<MethodParameter> modelAttribitePredicate, Predicate<MethodParameter> requestParamPredicate) {\n\n\t\tif (initializer instanceof ConfigurableWebBindingInitializer configurableInitializer) {\n\t\t\tif (configurableInitializer.getValidator() instanceof Validator validator) {\n\t\t\t\tMethodValidationAdapter adapter = new MethodValidationAdapter(validator);\n\t\t\t\tadapter.setObjectNameResolver(objectNameResolver);\n\t\t\t\tif (paramNameDiscoverer != null) {\n\t\t\t\t\tadapter.setParameterNameDiscoverer(paramNameDiscoverer);\n\t\t\t\t}\n\t\t\t\tMessageCodesResolver codesResolver = configurableInitializer.getMessageCodesResolver();\n\t\t\t\tif (codesResolver != null) {\n\t\t\t\t\tadapter.setMessageCodesResolver(codesResolver);\n\t\t\t\t}\n\t\t\t\treturn new HandlerMethodValidator(adapter, modelAttribitePredicate, requestParamPredicate);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\n\t/**\n\t * ObjectNameResolver for web controller methods.\n\t */\n\tprivate static class WebObjectNameResolver implements MethodValidationAdapter.ObjectNameResolver {\n\n\t\t@Override\n\t\tpublic String resolveName(MethodParameter param, @Nullable Object value) {\n\t\t\tif (param.hasParameterAnnotation(RequestBody.class) || param.hasParameterAnnotation(RequestPart.class)) {\n\t\t\t\treturn Conventions.getVariableNameForParameter(param);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn (param.getParameterIndex() != -1 ?\n\t\t\t\t\t\tModelFactory.getNameForParameter(param) :\n\t\t\t\t\t\tModelFactory.getNameForReturnValue(value, param));\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.method.annotation.HandlerMethodValidator#applyArgumentValidation(target,method,parameters,arguments,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "parameters",
      "arguments",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "void",
    "signature": "public void applyArgumentValidation(Object target, Method method, @Nullable MethodParameter[] parameters,\n\t\t\tObject[] arguments, Class<?>[] groups)",
    "source_code": "\tpublic void applyArgumentValidation("
  },
  "org.springframework.web.method.annotation.HandlerMethodValidator#applyReturnValueValidation(target,method,returnType,returnValue,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "returnType",
      "returnValue",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "void",
    "signature": "public void applyReturnValueValidation(Object target, Method method, @Nullable MethodParameter returnType,\n\t\t\t@Nullable Object returnValue, Class<?>[] groups)",
    "source_code": "\tpublic void applyReturnValueValidation("
  },
  "org.springframework.web.method.annotation.HandlerMethodValidator#from(initializer,paramNameDiscoverer,modelAttribitePredicate,requestParamPredicate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create a {@link HandlerMethodValidator} when Bean\n\t * Validation is enabled for use via {@link ConfigurableWebBindingInitializer},\n\t * for example in Spring MVC or WebFlux config.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "initializer",
      "paramNameDiscoverer",
      "modelAttribitePredicate",
      "requestParamPredicate"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "MethodValidator",
    "signature": "public MethodValidator from(@Nullable WebBindingInitializer initializer, @Nullable ParameterNameDiscoverer paramNameDiscoverer,\n\t\t\tPredicate<MethodParameter> modelAttribitePredicate, Predicate<MethodParameter> requestParamPredicate)",
    "source_code": "\tpublic static MethodValidator from("
  },
  "org.springframework.web.method.annotation.HandlerMethodValidator#resolveName(param,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "param",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "String",
    "signature": "public String resolveName(MethodParameter param, @Nullable Object value)",
    "source_code": "\t\tpublic String resolveName(MethodParameter param, @Nullable Object value) {\n\t\t\tif (param.hasParameterAnnotation(RequestBody.class) || param.hasParameterAnnotation(RequestPart.class)) {\n\t\t\t\treturn Conventions.getVariableNameForParameter(param);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn (param.getParameterIndex() != -1 ?\n\t\t\t\t\t\tModelFactory.getNameForParameter(param) :\n\t\t\t\t\t\tModelFactory.getNameForReturnValue(value, param));\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.method.annotation.HandlerMethodValidator#validateArguments(target,method,parameters,arguments,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "parameters",
      "arguments",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "MethodValidationResult",
    "signature": "public MethodValidationResult validateArguments(Object target, Method method, @Nullable MethodParameter[] parameters,\n\t\t\tObject[] arguments, Class<?>[] groups)",
    "source_code": "\tpublic MethodValidationResult validateArguments("
  },
  "org.springframework.web.method.annotation.HandlerMethodValidator#validateReturnValue(target,method,returnType,returnValue,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "returnType",
      "returnValue",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "MethodValidationResult",
    "signature": "public MethodValidationResult validateReturnValue(Object target, Method method,\n\t\t\t@Nullable MethodParameter returnType, @Nullable Object returnValue, Class<?>[] groups)",
    "source_code": "\tpublic MethodValidationResult validateReturnValue(Object target, Method method,"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Resolve {@code @ModelAttribute} annotated method arguments and handle\n * return values from {@code @ModelAttribute} annotated methods.\n *\n * <p>Model attributes are obtained from the model or created with a default\n * constructor (and then added to the model). Once created the attribute is\n * populated via data binding to Servlet request parameters. Validation may be\n * applied if the argument is annotated with {@code @jakarta.validation.Valid}.\n * or Spring's own {@code @org.springframework.validation.annotation.Validated}.\n *\n * <p>When this handler is created with {@code annotationNotRequired=true}\n * any non-simple type argument and return value is regarded as a model\n * attribute with or without the presence of an {@code @ModelAttribute}.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Sebastien Deleuze\n * @author Vladislav Kisel\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "signature": "public class ModelAttributeMethodProcessor",
    "source_code": "public class ModelAttributeMethodProcessor implements HandlerMethodArgumentResolver, HandlerMethodReturnValueHandler {\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\tprivate final boolean annotationNotRequired;\n\n\n\t/**\n\t * Class constructor.\n\t * @param annotationNotRequired if \"true\", non-simple method arguments and\n\t * return values are considered model attributes with or without a\n\t * {@code @ModelAttribute} annotation\n\t */\n\tpublic ModelAttributeMethodProcessor(boolean annotationNotRequired) {\n\t\tthis.annotationNotRequired = annotationNotRequired;\n\t}\n\n\n\t/**\n\t * Returns {@code true} if the parameter is annotated with\n\t * {@link ModelAttribute} or, if in default resolution mode, for any\n\t * method parameter that is not a simple type.\n\t */\n\t@Override\n\tpublic boolean supportsParameter(MethodParameter parameter) {\n\t\treturn (parameter.hasParameterAnnotation(ModelAttribute.class) ||\n\t\t\t\t(this.annotationNotRequired && !BeanUtils.isSimpleProperty(parameter.getParameterType())));\n\t}\n\n\t/**\n\t * Resolve the argument from the model or if not found instantiate it with\n\t * its default if it is available. The model attribute is then populated\n\t * with request values via data binding and optionally validated\n\t * if {@code @java.validation.Valid} is present on the argument.\n\t * @throws BindException if data binding and validation result in an error\n\t * and the next method parameter is not of type {@link Errors}\n\t * @throws Exception if WebDataBinder initialization fails\n\t */\n\t@Override\n\t@Nullable\n\tpublic final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {\n\n\t\tAssert.state(mavContainer != null, \"ModelAttributeMethodProcessor requires ModelAndViewContainer\");\n\t\tAssert.state(binderFactory != null, \"ModelAttributeMethodProcessor requires WebDataBinderFactory\");\n\n\t\tString name = ModelFactory.getNameForParameter(parameter);\n\t\tModelAttribute ann = parameter.getParameterAnnotation(ModelAttribute.class);\n\t\tif (ann != null) {\n\t\t\tmavContainer.setBinding(name, ann.binding());\n\t\t}\n\n\t\tObject attribute = null;\n\t\tBindingResult bindingResult = null;\n\n\t\tif (mavContainer.containsAttribute(name)) {\n\t\t\tattribute = mavContainer.getModel().get(name);\n\t\t}\n\t\telse {\n\t\t\t// Create attribute instance\n\t\t\ttry {\n\t\t\t\tattribute = createAttribute(name, parameter, binderFactory, webRequest);\n\t\t\t}\n\t\t\tcatch (MethodArgumentNotValidException ex) {\n\t\t\t\tif (isBindExceptionRequired(parameter)) {\n\t\t\t\t\t// No BindingResult parameter -> fail with BindException\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\t// Otherwise, expose null/empty value and associated BindingResult\n\t\t\t\tif (parameter.getParameterType() == Optional.class) {\n\t\t\t\t\tattribute = Optional.empty();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tattribute = ex.getTarget();\n\t\t\t\t}\n\t\t\t\tbindingResult = ex.getBindingResult();\n\t\t\t}\n\t\t}\n\n\t\tif (bindingResult == null) {\n\t\t\t// Bean property binding and validation;\n\t\t\t// skipped in case of binding failure on construction.\n\t\t\tWebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);\n\t\t\tif (binder.getTarget() != null) {\n\t\t\t\tif (!mavContainer.isBindingDisabled(name)) {\n\t\t\t\t\tbindRequestParameters(binder, webRequest);\n\t\t\t\t}\n\t\t\t\tvalidateIfApplicable(binder, parameter);\n\t\t\t\tif (binder.getBindingResult().hasErrors() && isBindExceptionRequired(binder, parameter)) {\n\t\t\t\t\tthrow new MethodArgumentNotValidException(parameter, binder.getBindingResult());\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Value type adaptation, also covering java.util.Optional\n\t\t\tif (!parameter.getParameterType().isInstance(attribute)) {\n\t\t\t\tattribute = binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);\n\t\t\t}\n\t\t\tbindingResult = binder.getBindingResult();\n\t\t}\n\n\t\t// Add resolved attribute and BindingResult at the end of the model\n\t\tMap<String, Object> bindingResultModel = bindingResult.getModel();\n\t\tmavContainer.removeAttributes(bindingResultModel);\n\t\tmavContainer.addAllAttributes(bindingResultModel);\n\n\t\treturn attribute;\n\t}\n\n\t/**\n\t * Extension point to create the model attribute if not found in the model,\n\t * with subsequent parameter binding through bean properties (unless suppressed).\n\t * <p>The default implementation typically uses the unique public no-arg constructor\n\t * if available but also handles a \"primary constructor\" approach for data classes:\n\t * It understands the JavaBeans {@code ConstructorProperties} annotation as well as\n\t * runtime-retained parameter names in the bytecode, associating request parameters\n\t * with constructor arguments by name. If no such constructor is found, the default\n\t * constructor will be used (even if not public), assuming subsequent bean property\n\t * bindings through setter methods.\n\t * @param attributeName the name of the attribute (never {@code null})\n\t * @param parameter the method parameter declaration\n\t * @param binderFactory for creating WebDataBinder instance\n\t * @param webRequest the current request\n\t * @return the created model attribute (never {@code null})\n\t * @throws BindException in case of constructor argument binding failure\n\t * @throws Exception in case of constructor invocation failure\n\t * @see #constructAttribute(Constructor, String, MethodParameter, WebDataBinderFactory, NativeWebRequest)\n\t * @see BeanUtils#findPrimaryConstructor(Class)\n\t */\n\tprotected Object createAttribute(String attributeName, MethodParameter parameter,\n\t\t\tWebDataBinderFactory binderFactory, NativeWebRequest webRequest) throws Exception {\n\n\t\tMethodParameter nestedParameter = parameter.nestedIfOptional();\n\t\tClass<?> clazz = nestedParameter.getNestedParameterType();\n\n\t\tConstructor<?> ctor = BeanUtils.getResolvableConstructor(clazz);\n\t\tObject attribute = constructAttribute(ctor, attributeName, parameter, binderFactory, webRequest);\n\t\tif (parameter != nestedParameter) {\n\t\t\tattribute = Optional.of(attribute);\n\t\t}\n\t\treturn attribute;\n\t}\n\n\t/**\n\t * Construct a new attribute instance with the given constructor.\n\t * <p>Called from\n\t * {@link #createAttribute(String, MethodParameter, WebDataBinderFactory, NativeWebRequest)}\n\t * after constructor resolution.\n\t * @param ctor the constructor to use\n\t * @param attributeName the name of the attribute (never {@code null})\n\t * @param parameter the method parameter declaration\n\t * @param binderFactory for creating WebDataBinder instance\n\t * @param webRequest the current request\n\t * @return the created model attribute (never {@code null})\n\t * @throws BindException in case of constructor argument binding failure\n\t * @throws Exception in case of constructor invocation failure\n\t * @since 5.1\n\t */\n\t@SuppressWarnings(\"serial\")\n\tprotected Object constructAttribute(Constructor<?> ctor, String attributeName, MethodParameter parameter,\n\t\t\tWebDataBinderFactory binderFactory, NativeWebRequest webRequest) throws Exception {\n\n\t\tif (ctor.getParameterCount() == 0) {\n\t\t\t// A single default constructor -> clearly a standard JavaBeans arrangement.\n\t\t\treturn BeanUtils.instantiateClass(ctor);\n\t\t}\n\n\t\t// A single data class constructor -> resolve constructor arguments from request parameters.\n\t\tString[] paramNames = BeanUtils.getParameterNames(ctor);\n\t\tClass<?>[] paramTypes = ctor.getParameterTypes();\n\t\tObject[] args = new Object[paramTypes.length];\n\t\tWebDataBinder binder = binderFactory.createBinder(webRequest, null, attributeName);\n\t\tString fieldDefaultPrefix = binder.getFieldDefaultPrefix();\n\t\tString fieldMarkerPrefix = binder.getFieldMarkerPrefix();\n\t\tboolean bindingFailure = false;\n\t\tSet<String> failedParams = new HashSet<>(4);\n\n\t\tfor (int i = 0; i < paramNames.length; i++) {\n\t\t\tString paramName = paramNames[i];\n\t\t\tClass<?> paramType = paramTypes[i];\n\t\t\tObject value = webRequest.getParameterValues(paramName);\n\n\t\t\t// Since WebRequest#getParameter exposes a single-value parameter as an array\n\t\t\t// with a single element, we unwrap the single value in such cases, analogous\n\t\t\t// to WebExchangeDataBinder.addBindValue(Map<String, Object>, String, List<?>).\n\t\t\tif (ObjectUtils.isArray(value) && Array.getLength(value) == 1) {\n\t\t\t\tvalue = Array.get(value, 0);\n\t\t\t}\n\n\t\t\tif (value == null) {\n\t\t\t\tif (fieldDefaultPrefix != null) {\n\t\t\t\t\tvalue = webRequest.getParameter(fieldDefaultPrefix + paramName);\n\t\t\t\t}\n\t\t\t\tif (value == null) {\n\t\t\t\t\tif (fieldMarkerPrefix != null && webRequest.getParameter(fieldMarkerPrefix + paramName) != null) {\n\t\t\t\t\t\tvalue = binder.getEmptyValue(paramType);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvalue = resolveConstructorArgument(paramName, paramType, webRequest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tMethodParameter methodParam = new FieldAwareConstructorParameter(ctor, i, paramName);\n\t\t\t\tif (value == null && methodParam.isOptional()) {\n\t\t\t\t\targs[i] = (methodParam.getParameterType() == Optional.class ? Optional.empty() : null);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\targs[i] = binder.convertIfNecessary(value, paramType, methodParam);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tex.initPropertyName(paramName);\n\t\t\t\targs[i] = null;\n\t\t\t\tfailedParams.add(paramName);\n\t\t\t\tbinder.getBindingResult().recordFieldValue(paramName, paramType, value);\n\t\t\t\tbinder.getBindingErrorProcessor().processPropertyAccessException(ex, binder.getBindingResult());\n\t\t\t\tbindingFailure = true;\n\t\t\t}\n\t\t}\n\n\t\tif (bindingFailure) {\n\t\t\tBindingResult result = binder.getBindingResult();\n\t\t\tfor (int i = 0; i < paramNames.length; i++) {\n\t\t\t\tString paramName = paramNames[i];\n\t\t\t\tif (!failedParams.contains(paramName)) {\n\t\t\t\t\tObject value = args[i];\n\t\t\t\t\tresult.recordFieldValue(paramName, paramTypes[i], value);\n\t\t\t\t\tvalidateValueIfApplicable(binder, parameter, ctor.getDeclaringClass(), paramName, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!parameter.isOptional()) {\n\t\t\t\ttry {\n\t\t\t\t\tObject target = BeanUtils.instantiateClass(ctor, args);\n\t\t\t\t\tthrow new MethodArgumentNotValidException(parameter, result) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic Object getTarget() {\n\t\t\t\t\t\t\treturn target;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcatch (BeanInstantiationException ex) {\n\t\t\t\t\t// swallow and proceed without target instance\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new MethodArgumentNotValidException(parameter, result);\n\t\t}\n\n\t\ttry {\n\t\t\treturn BeanUtils.instantiateClass(ctor, args);\n\t\t}\n\t\tcatch (BeanInstantiationException ex) {\n\t\t\tif (KotlinDetector.isKotlinType(ctor.getDeclaringClass()) &&\n\t\t\t\t\tex.getCause() instanceof NullPointerException cause) {\n\t\t\t\tBindingResult result = binder.getBindingResult();\n\t\t\t\tObjectError error = new ObjectError(ctor.getName(), cause.getMessage());\n\t\t\t\tresult.addError(error);\n\t\t\t\tthrow new MethodArgumentNotValidException(parameter, result);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Extension point to bind the request to the target object.\n\t * @param binder the data binder instance to use for the binding\n\t * @param request the current request\n\t */\n\tprotected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) {\n\t\t((WebRequestDataBinder) binder).bind(request);\n\t}\n\n\t@Nullable\n\tpublic Object resolveConstructorArgument(String paramName, Class<?> paramType, NativeWebRequest request)\n\t\t\tthrows Exception {\n\n\t\tMultipartRequest multipartRequest = request.getNativeRequest(MultipartRequest.class);\n\t\tif (multipartRequest != null) {\n\t\t\tList<MultipartFile> files = multipartRequest.getFiles(paramName);\n\t\t\tif (!files.isEmpty()) {\n\t\t\t\treturn (files.size() == 1 ? files.get(0) : files);\n\t\t\t}\n\t\t}\n\t\telse if (StringUtils.startsWithIgnoreCase(\n\t\t\t\trequest.getHeader(HttpHeaders.CONTENT_TYPE), MediaType.MULTIPART_FORM_DATA_VALUE)) {\n\t\t\tHttpServletRequest servletRequest = request.getNativeRequest(HttpServletRequest.class);\n\t\t\tif (servletRequest != null && HttpMethod.POST.matches(servletRequest.getMethod())) {\n\t\t\t\tList<Part> parts = StandardServletPartUtils.getParts(servletRequest, paramName);\n\t\t\t\tif (!parts.isEmpty()) {\n\t\t\t\t\treturn (parts.size() == 1 ? parts.get(0) : parts);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Validate the model attribute if applicable.\n\t * <p>The default implementation checks for {@code @jakarta.validation.Valid},\n\t * Spring's {@link org.springframework.validation.annotation.Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param binder the DataBinder to be used\n\t * @param parameter the method parameter declaration\n\t * @see WebDataBinder#validate(Object...)\n\t * @see SmartValidator#validate(Object, Errors, Object...)\n\t */\n\tprotected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter) {\n\t\tfor (Annotation ann : parameter.getParameterAnnotations()) {\n\t\t\tObject[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);\n\t\t\tif (validationHints != null) {\n\t\t\t\tbinder.validate(validationHints);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Validate the specified candidate value if applicable.\n\t * <p>The default implementation checks for {@code @jakarta.validation.Valid},\n\t * Spring's {@link org.springframework.validation.annotation.Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param binder the DataBinder to be used\n\t * @param parameter the method parameter declaration\n\t * @param targetType the target type\n\t * @param fieldName the name of the field\n\t * @param value the candidate value\n\t * @since 5.1\n\t * @see #validateIfApplicable(WebDataBinder, MethodParameter)\n\t * @see SmartValidator#validateValue(Class, String, Object, Errors, Object...)\n\t */\n\tprotected void validateValueIfApplicable(WebDataBinder binder, MethodParameter parameter,\n\t\t\tClass<?> targetType, String fieldName, @Nullable Object value) {\n\n\t\tfor (Annotation ann : parameter.getParameterAnnotations()) {\n\t\t\tObject[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);\n\t\t\tif (validationHints != null) {\n\t\t\t\tfor (Validator validator : binder.getValidators()) {\n\t\t\t\t\tif (validator instanceof SmartValidator smartValidator) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tsmartValidator.validateValue(targetType, fieldName, value,\n\t\t\t\t\t\t\t\t\tbinder.getBindingResult(), validationHints);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\t\t\t// No corresponding field on the target class...\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Whether to raise a fatal bind exception on validation errors.\n\t * <p>The default implementation delegates to {@link #isBindExceptionRequired(MethodParameter)}.\n\t * @param binder the data binder used to perform data binding\n\t * @param parameter the method parameter declaration\n\t * @return {@code true} if the next method parameter is not of type {@link Errors}\n\t * @see #isBindExceptionRequired(MethodParameter)\n\t */\n\tprotected boolean isBindExceptionRequired(WebDataBinder binder, MethodParameter parameter) {\n\t\treturn isBindExceptionRequired(parameter);\n\t}\n\n\t/**\n\t * Whether to raise a fatal bind exception on validation errors.\n\t * @param parameter the method parameter declaration\n\t * @return {@code true} if the next method parameter is not of type {@link Errors}\n\t * @since 5.0\n\t */\n\tprotected boolean isBindExceptionRequired(MethodParameter parameter) {\n\t\tint i = parameter.getParameterIndex();\n\t\tClass<?>[] paramTypes = parameter.getExecutable().getParameterTypes();\n\t\tboolean hasBindingResult = (paramTypes.length > (i + 1) && Errors.class.isAssignableFrom(paramTypes[i + 1]));\n\t\treturn !hasBindingResult;\n\t}\n\n\t/**\n\t * Return {@code true} if there is a method-level {@code @ModelAttribute}\n\t * or, in default resolution mode, for any return value type that is not\n\t * a simple type.\n\t */\n\t@Override\n\tpublic boolean supportsReturnType(MethodParameter returnType) {\n\t\treturn (returnType.hasMethodAnnotation(ModelAttribute.class) ||\n\t\t\t\t(this.annotationNotRequired && !BeanUtils.isSimpleProperty(returnType.getParameterType())));\n\t}\n\n\t/**\n\t * Add non-null return values to the {@link ModelAndViewContainer}.\n\t */\n\t@Override\n\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {\n\n\t\tif (returnValue != null) {\n\t\t\tString name = ModelFactory.getNameForReturnValue(returnValue, returnType);\n\t\t\tmavContainer.addAttribute(name, returnValue);\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link MethodParameter} subclass which detects field annotations as well.\n\t * @since 5.1\n\t */\n\tprivate static class FieldAwareConstructorParameter extends MethodParameter {\n\n\t\tprivate final String parameterName;\n\n\t\t@Nullable\n\t\tprivate volatile Annotation[] combinedAnnotations;\n\n\t\tpublic FieldAwareConstructorParameter(Constructor<?> constructor, int parameterIndex, String parameterName) {\n\t\t\tsuper(constructor, parameterIndex);\n\t\t\tthis.parameterName = parameterName;\n\t\t}\n\n\t\t@Override\n\t\tpublic Annotation[] getParameterAnnotations() {\n\t\t\tAnnotation[] anns = this.combinedAnnotations;\n\t\t\tif (anns == null) {\n\t\t\t\tanns = super.getParameterAnnotations();\n\t\t\t\ttry {\n\t\t\t\t\tField field = getDeclaringClass().getDeclaredField(this.parameterName);\n\t\t\t\t\tAnnotation[] fieldAnns = field.getAnnotations();\n\t\t\t\t\tif (fieldAnns.length > 0) {\n\t\t\t\t\t\tList<Annotation> merged = new ArrayList<>(anns.length + fieldAnns.length);\n\t\t\t\t\t\tmerged.addAll(Arrays.asList(anns));\n\t\t\t\t\t\tfor (Annotation fieldAnn : fieldAnns) {\n\t\t\t\t\t\t\tboolean existingType = false;\n\t\t\t\t\t\t\tfor (Annotation ann : anns) {\n\t\t\t\t\t\t\t\tif (ann.annotationType() == fieldAnn.annotationType()) {\n\t\t\t\t\t\t\t\t\texistingType = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!existingType) {\n\t\t\t\t\t\t\t\tmerged.add(fieldAnn);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tanns = merged.toArray(new Annotation[0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchFieldException | SecurityException ex) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t\tthis.combinedAnnotations = anns;\n\t\t\t}\n\t\t\treturn anns;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getParameterName() {\n\t\t\treturn this.parameterName;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#bindRequestParameters(binder,request)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Extension point to bind the request to the target object.\n\t * @param binder the data binder instance to use for the binding\n\t * @param request the current request\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 357
    },
    "return": "void",
    "signature": "protected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request)",
    "source_code": "\tprotected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) {\n\t\t((WebRequestDataBinder) binder).bind(request);\n\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#constructAttribute(ctor,attributeName,parameter,binderFactory,webRequest)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Construct a new attribute instance with the given constructor.\n\t * <p>Called from\n\t * {@link #createAttribute(String, MethodParameter, WebDataBinderFactory, NativeWebRequest)}\n\t * after constructor resolution.\n\t * @param ctor the constructor to use\n\t * @param attributeName the name of the attribute (never {@code null})\n\t * @param parameter the method parameter declaration\n\t * @param binderFactory for creating WebDataBinder instance\n\t * @param webRequest the current request\n\t * @return the created model attribute (never {@code null})\n\t * @throws BindException in case of constructor argument binding failure\n\t * @throws Exception in case of constructor invocation failure\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ctor",
      "attributeName",
      "parameter",
      "binderFactory",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 245
    },
    "return": "Object",
    "signature": "protected Object constructAttribute(Constructor<?> ctor, String attributeName, MethodParameter parameter,\n\t\t\tWebDataBinderFactory binderFactory, NativeWebRequest webRequest)",
    "source_code": "\tprotected Object constructAttribute(Constructor<?> ctor, String attributeName, MethodParameter parameter,"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#createAttribute(attributeName,parameter,binderFactory,webRequest)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Extension point to create the model attribute if not found in the model,\n\t * with subsequent parameter binding through bean properties (unless suppressed).\n\t * <p>The default implementation typically uses the unique public no-arg constructor\n\t * if available but also handles a \"primary constructor\" approach for data classes:\n\t * It understands the JavaBeans {@code ConstructorProperties} annotation as well as\n\t * runtime-retained parameter names in the bytecode, associating request parameters\n\t * with constructor arguments by name. If no such constructor is found, the default\n\t * constructor will be used (even if not public), assuming subsequent bean property\n\t * bindings through setter methods.\n\t * @param attributeName the name of the attribute (never {@code null})\n\t * @param parameter the method parameter declaration\n\t * @param binderFactory for creating WebDataBinder instance\n\t * @param webRequest the current request\n\t * @return the created model attribute (never {@code null})\n\t * @throws BindException in case of constructor argument binding failure\n\t * @throws Exception in case of constructor invocation failure\n\t * @see #constructAttribute(Constructor, String, MethodParameter, WebDataBinderFactory, NativeWebRequest)\n\t * @see BeanUtils#findPrimaryConstructor(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "attributeName",
      "parameter",
      "binderFactory",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "Object",
    "signature": "protected Object createAttribute(String attributeName, MethodParameter parameter,\n\t\t\tWebDataBinderFactory binderFactory, NativeWebRequest webRequest)",
    "source_code": "\tprotected Object createAttribute(String attributeName, MethodParameter parameter,"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#getParameterAnnotations()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 508
    },
    "return": "Annotation[]",
    "signature": "public Annotation[] getParameterAnnotations()",
    "source_code": "\t\tpublic Annotation[] getParameterAnnotations() {\n\t\t\tAnnotation[] anns = this.combinedAnnotations;\n\t\t\tif (anns == null) {\n\t\t\t\tanns = super.getParameterAnnotations();\n\t\t\t\ttry {\n\t\t\t\t\tField field = getDeclaringClass().getDeclaredField(this.parameterName);\n\t\t\t\t\tAnnotation[] fieldAnns = field.getAnnotations();\n\t\t\t\t\tif (fieldAnns.length > 0) {\n\t\t\t\t\t\tList<Annotation> merged = new ArrayList<>(anns.length + fieldAnns.length);\n\t\t\t\t\t\tmerged.addAll(Arrays.asList(anns));\n\t\t\t\t\t\tfor (Annotation fieldAnn : fieldAnns) {\n\t\t\t\t\t\t\tboolean existingType = false;\n\t\t\t\t\t\t\tfor (Annotation ann : anns) {\n\t\t\t\t\t\t\t\tif (ann.annotationType() == fieldAnn.annotationType()) {\n\t\t\t\t\t\t\t\t\texistingType = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!existingType) {\n\t\t\t\t\t\t\t\tmerged.add(fieldAnn);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tanns = merged.toArray(new Annotation[0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchFieldException | SecurityException ex) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t\tthis.combinedAnnotations = anns;\n\t\t\t}\n\t\t\treturn anns;\n\t\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#getParameterName()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 542
    },
    "return": "String",
    "signature": "public String getParameterName()",
    "source_code": "\t\tpublic String getParameterName() {\n\t\t\treturn this.parameterName;\n\t\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#getTarget()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "Object",
    "signature": "public Object getTarget()",
    "source_code": "\t\t\t\t\t\tpublic Object getTarget() {\n\t\t\t\t\t\t\treturn target;\n\t\t\t\t\t\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#handleReturnValue(returnValue,returnType,mavContainer,webRequest)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add non-null return values to the {@link ModelAndViewContainer}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "mavContainer",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 481
    },
    "return": "void",
    "signature": "public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest)",
    "source_code": "\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#isBindExceptionRequired(binder,parameter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to raise a fatal bind exception on validation errors.\n\t * <p>The default implementation delegates to {@link #isBindExceptionRequired(MethodParameter)}.\n\t * @param binder the data binder used to perform data binding\n\t * @param parameter the method parameter declaration\n\t * @return {@code true} if the next method parameter is not of type {@link Errors}\n\t * @see #isBindExceptionRequired(MethodParameter)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 449
    },
    "return": "boolean",
    "signature": "protected boolean isBindExceptionRequired(WebDataBinder binder, MethodParameter parameter)",
    "source_code": "\tprotected boolean isBindExceptionRequired(WebDataBinder binder, MethodParameter parameter) {\n\t\treturn isBindExceptionRequired(parameter);\n\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#isBindExceptionRequired(parameter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to raise a fatal bind exception on validation errors.\n\t * @param parameter the method parameter declaration\n\t * @return {@code true} if the next method parameter is not of type {@link Errors}\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 459
    },
    "return": "boolean",
    "signature": "protected boolean isBindExceptionRequired(MethodParameter parameter)",
    "source_code": "\tprotected boolean isBindExceptionRequired(MethodParameter parameter) {\n\t\tint i = parameter.getParameterIndex();\n\t\tClass<?>[] paramTypes = parameter.getExecutable().getParameterTypes();\n\t\tboolean hasBindingResult = (paramTypes.length > (i + 1) && Errors.class.isAssignableFrom(paramTypes[i + 1]));\n\t\treturn !hasBindingResult;\n\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#resolveArgument(parameter,mavContainer,webRequest,binderFactory)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the argument from the model or if not found instantiate it with\n\t * its default if it is available. The model attribute is then populated\n\t * with request values via data binding and optionally validated\n\t * if {@code @java.validation.Valid} is present on the argument.\n\t * @throws BindException if data binding and validation result in an error\n\t * and the next method parameter is not of type {@link Errors}\n\t * @throws Exception if WebDataBinder initialization fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "mavContainer",
      "webRequest",
      "binderFactory"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "Object",
    "signature": "public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)",
    "source_code": "\tpublic final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#resolveConstructorArgument(paramName,paramType,request)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName",
      "paramType",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 362
    },
    "return": "Object",
    "signature": "public Object resolveConstructorArgument(String paramName, Class<?> paramType, NativeWebRequest request)",
    "source_code": "\tpublic Object resolveConstructorArgument(String paramName, Class<?> paramType, NativeWebRequest request)"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#supportsParameter(parameter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns {@code true} if the parameter is annotated with\n\t * {@link ModelAttribute} or, if in default resolution mode, for any\n\t * method parameter that is not a simple type.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "boolean",
    "signature": "public boolean supportsParameter(MethodParameter parameter)",
    "source_code": "\tpublic boolean supportsParameter(MethodParameter parameter) {\n\t\treturn (parameter.hasParameterAnnotation(ModelAttribute.class) ||\n\t\t\t\t(this.annotationNotRequired && !BeanUtils.isSimpleProperty(parameter.getParameterType())));\n\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#supportsReturnType(returnType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return {@code true} if there is a method-level {@code @ModelAttribute}\n\t * or, in default resolution mode, for any return value type that is not\n\t * a simple type.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnType"
    ],
    "position": {
      "column": 1,
      "line": 472
    },
    "return": "boolean",
    "signature": "public boolean supportsReturnType(MethodParameter returnType)",
    "source_code": "\tpublic boolean supportsReturnType(MethodParameter returnType) {\n\t\treturn (returnType.hasMethodAnnotation(ModelAttribute.class) ||\n\t\t\t\t(this.annotationNotRequired && !BeanUtils.isSimpleProperty(returnType.getParameterType())));\n\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#validateIfApplicable(binder,parameter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Validate the model attribute if applicable.\n\t * <p>The default implementation checks for {@code @jakarta.validation.Valid},\n\t * Spring's {@link org.springframework.validation.annotation.Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param binder the DataBinder to be used\n\t * @param parameter the method parameter declaration\n\t * @see WebDataBinder#validate(Object...)\n\t * @see SmartValidator#validate(Object, Errors, Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 395
    },
    "return": "void",
    "signature": "protected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter)",
    "source_code": "\tprotected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter) {\n\t\tfor (Annotation ann : parameter.getParameterAnnotations()) {\n\t\t\tObject[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);\n\t\t\tif (validationHints != null) {\n\t\t\t\tbinder.validate(validationHints);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#validateValueIfApplicable(binder,parameter,targetType,fieldName,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Validate the specified candidate value if applicable.\n\t * <p>The default implementation checks for {@code @jakarta.validation.Valid},\n\t * Spring's {@link org.springframework.validation.annotation.Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param binder the DataBinder to be used\n\t * @param parameter the method parameter declaration\n\t * @param targetType the target type\n\t * @param fieldName the name of the field\n\t * @param value the candidate value\n\t * @since 5.1\n\t * @see #validateIfApplicable(WebDataBinder, MethodParameter)\n\t * @see SmartValidator#validateValue(Class, String, Object, Errors, Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "parameter",
      "targetType",
      "fieldName",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 419
    },
    "return": "void",
    "signature": "protected void validateValueIfApplicable(WebDataBinder binder, MethodParameter parameter,\n\t\t\tClass<?> targetType, String fieldName, @Nullable Object value)",
    "source_code": "\tprotected void validateValueIfApplicable(WebDataBinder binder, MethodParameter parameter,"
  },
  "org.springframework.web.method.annotation.logger": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.web.method.support.InvocableHandlerMethod#invokeFunction(method,target,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "target",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 300
    },
    "return": "Object",
    "signature": "public Object invokeFunction(Method method, Object target, Object[] args)",
    "source_code": "\t\tpublic static Object invokeFunction(Method method, Object target, Object[] args) {\n\t\t\tKFunction<?> function = Objects.requireNonNull(ReflectJvmMapping.getKotlinFunction(method));\n\t\t\tif (method.isAccessible() && !KCallablesJvm.isAccessible(function)) {\n\t\t\t\tKCallablesJvm.setAccessible(function, true);\n\t\t\t}\n\t\t\tMap<KParameter, Object> argMap = CollectionUtils.newHashMap(args.length + 1);\n\t\t\tint index = 0;\n\t\t\tfor (KParameter parameter : function.getParameters()) {\n\t\t\t\tswitch (parameter.getKind()) {\n\t\t\t\t\tcase INSTANCE -> argMap.put(parameter, target);\n\t\t\t\t\tcase VALUE -> {\n\t\t\t\t\t\tif (!parameter.isOptional() || args[index] != null) {\n\t\t\t\t\t\t\targMap.put(parameter, args[index]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn function.callBy(argMap);\n\t\t}"
  },
  "org.springframework.web.method.support.InvocableHandlerMethod#setMethodValidator(methodValidator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link MethodValidator} to perform method validation with if the\n\t * controller method {@link #shouldValidateArguments()} or\n\t * {@link #shouldValidateReturnValue()}.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodValidator"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "void",
    "signature": "public void setMethodValidator(@Nullable MethodValidator methodValidator)",
    "source_code": "\tpublic void setMethodValidator(@Nullable MethodValidator methodValidator) {\n\t\tthis.methodValidator = methodValidator;\n\t}"
  },
  "org.springframework.web.reactive.BindingContext": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Context to assist with binding request data onto Objects and provide access\n * to a shared {@link Model} with controller-specific attributes.\n *\n * <p>Provides  methods to create a {@link WebExchangeDataBinder} for a specific\n * target, command Object to apply data binding and validation to, or without a\n * target Object for simple type conversion from request values.\n *\n * <p>Container for the default model for the request.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "signature": "public class BindingContext",
    "source_code": "public class BindingContext {\n\n\t@Nullable\n\tprivate final WebBindingInitializer initializer;\n\n\tprivate final Model model = new BindingAwareConcurrentModel();\n\n\tprivate boolean methodValidationApplicable;\n\n\tprivate final ReactiveAdapterRegistry reactiveAdapterRegistry;\n\n\n\t/**\n\t * Create an instance without an initializer.\n\t */\n\tpublic BindingContext() {\n\t\tthis(null);\n\t}\n\n\t/**\n\t * Create an instance with the given initializer, which may be {@code null}.\n\t */\n\tpublic BindingContext(@Nullable WebBindingInitializer initializer) {\n\t\tthis(initializer, ReactiveAdapterRegistry.getSharedInstance());\n\t}\n\n\t/**\n\t * Create an instance with the given initializer and {@code ReactiveAdapterRegistry}.\n\t * @since 6.1\n\t */\n\tpublic BindingContext(@Nullable WebBindingInitializer initializer, ReactiveAdapterRegistry registry) {\n\t\tthis.initializer = initializer;\n\t\tthis.reactiveAdapterRegistry = new ReactiveAdapterRegistry();\n\t}\n\n\n\t/**\n\t * Return the default model.\n\t */\n\tpublic Model getModel() {\n\t\treturn this.model;\n\t}\n\n\t/**\n\t * Configure flag to signal whether validation will be applied to handler\n\t * method arguments, which is the case if Bean Validation is enabled in\n\t * Spring MVC, and method parameters have {@code @Constraint} annotations.\n\t * @since 6.1\n\t */\n\tpublic void setMethodValidationApplicable(boolean methodValidationApplicable) {\n\t\tthis.methodValidationApplicable = methodValidationApplicable;\n\t}\n\n\n\t/**\n\t * Create a binder with a target object.\n\t * @param exchange the current exchange\n\t * @param target the object to create a data binder for\n\t * @param name the name of the target object\n\t * @return the created data binder\n\t * @throws ServerErrorException if {@code @InitBinder} method invocation fails\n\t */\n\tpublic WebExchangeDataBinder createDataBinder(ServerWebExchange exchange, @Nullable Object target, String name) {\n\t\treturn createDataBinder(exchange, target, name, null);\n\t}\n\n\t/**\n\t * Shortcut method to create a binder without a target object.\n\t * @param exchange the current exchange\n\t * @param name the name of the target object\n\t * @return the created data binder\n\t * @throws ServerErrorException if {@code @InitBinder} method invocation fails\n\t */\n\tpublic WebExchangeDataBinder createDataBinder(ServerWebExchange exchange, String name) {\n\t\treturn createDataBinder(exchange, null, name, null);\n\t}\n\n\t/**\n\t * Create a binder with a target object and a {@link ResolvableType targetType}.\n\t * If the target is {@code null}, then\n\t * {@link WebExchangeDataBinder#setTargetType targetType} is set.\n\t * @since 6.1\n\t */\n\tpublic WebExchangeDataBinder createDataBinder(\n\t\t\tServerWebExchange exchange, @Nullable Object target, String name, @Nullable ResolvableType targetType) {\n\n\t\tWebExchangeDataBinder dataBinder = new ExtendedWebExchangeDataBinder(target, name);\n\t\tif (target == null && targetType != null) {\n\t\t\tdataBinder.setTargetType(targetType);\n\t\t}\n\n\t\tif (this.initializer != null) {\n\t\t\tthis.initializer.initBinder(dataBinder);\n\t\t}\n\t\tdataBinder = initDataBinder(dataBinder, exchange);\n\n\t\tif (this.methodValidationApplicable && targetType != null) {\n\t\t\tif (targetType.getSource() instanceof MethodParameter parameter) {\n\t\t\t\tMethodValidationInitializer.initBinder(dataBinder, parameter);\n\t\t\t}\n\t\t}\n\n\t\treturn dataBinder;\n\t}\n\n\t/**\n\t * Initialize the data binder instance for the given exchange.\n\t * @throws ServerErrorException if {@code @InitBinder} method invocation fails\n\t */\n\tprotected WebExchangeDataBinder initDataBinder(WebExchangeDataBinder binder, ServerWebExchange exchange) {\n\t\treturn binder;\n\t}\n\n\t/**\n\t * Invoked before rendering to add {@link BindingResult} attributes where\n\t * necessary, and also to promote model attributes listed as\n\t * {@code @SessionAttributes} to the session.\n\t * @param exchange the current exchange\n\t * @since 6.1\n\t */\n\tpublic void updateModel(ServerWebExchange exchange) {\n\t\tMap<String, Object> model = getModel().asMap();\n\t\tfor (Map.Entry<String, Object> entry : model.entrySet()) {\n\t\t\tString name = entry.getKey();\n\t\t\tObject value = entry.getValue();\n\t\t\tif (isBindingCandidate(name, value)) {\n\t\t\t\tif (!model.containsKey(BindingResult.MODEL_KEY_PREFIX + name)) {\n\t\t\t\t\tWebExchangeDataBinder binder = createDataBinder(exchange, value, name);\n\t\t\t\t\tmodel.put(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean isBindingCandidate(String name, @Nullable Object value) {\n\t\treturn (!name.startsWith(BindingResult.MODEL_KEY_PREFIX) && value != null &&\n\t\t\t\t!value.getClass().isArray() && !(value instanceof Collection) && !(value instanceof Map) &&\n\t\t\t\tthis.reactiveAdapterRegistry.getAdapter(null, value) == null &&\n\t\t\t\t!BeanUtils.isSimpleValueType(value.getClass()));\n\t}\n\n\n\t/**\n\t * Extended variant of {@link WebExchangeDataBinder}, adding path variables.\n\t */\n\tprivate static class ExtendedWebExchangeDataBinder extends WebExchangeDataBinder {\n\n\t\tpublic ExtendedWebExchangeDataBinder(@Nullable Object target, String objectName) {\n\t\t\tsuper(target, objectName);\n\t\t}\n\n\t\t@Override\n\t\tpublic Mono<Map<String, Object>> getValuesToBind(ServerWebExchange exchange) {\n\t\t\treturn super.getValuesToBind(exchange).doOnNext(map ->\n\t\t\t\t\tmap.putAll(exchange.<Map<String, String>>getAttributeOrDefault(\n\t\t\t\t\t\t\tHandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE, Collections.emptyMap())));\n\t\t}\n\t}\n\n\n\t/**\n\t * Excludes Bean Validation if the method parameter has {@code @Valid}.\n\t */\n\tprivate static class MethodValidationInitializer {\n\n\t\tpublic static void initBinder(DataBinder binder, MethodParameter parameter) {\n\t\t\tif (ReactiveAdapterRegistry.getSharedInstance().getAdapter(parameter.getParameterType()) == null) {\n\t\t\t\tfor (Annotation annotation : parameter.getParameterAnnotations()) {\n\t\t\t\t\tif (annotation.annotationType().getName().equals(\"jakarta.validation.Valid\")) {\n\t\t\t\t\t\tbinder.setExcludedValidators(validator -> validator instanceof jakarta.validation.Validator);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.reactive.BindingContext#createDataBinder(exchange,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Shortcut method to create a binder without a target object.\n\t * @param exchange the current exchange\n\t * @param name the name of the target object\n\t * @return the created data binder\n\t * @throws ServerErrorException if {@code @InitBinder} method invocation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "WebExchangeDataBinder",
    "signature": "public WebExchangeDataBinder createDataBinder(ServerWebExchange exchange, String name)",
    "source_code": "\tpublic WebExchangeDataBinder createDataBinder(ServerWebExchange exchange, String name) {\n\t\treturn createDataBinder(exchange, null, name, null);\n\t}"
  },
  "org.springframework.web.reactive.BindingContext#createDataBinder(exchange,target,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a binder with a target object.\n\t * @param exchange the current exchange\n\t * @param target the object to create a data binder for\n\t * @param name the name of the target object\n\t * @return the created data binder\n\t * @throws ServerErrorException if {@code @InitBinder} method invocation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "WebExchangeDataBinder",
    "signature": "public WebExchangeDataBinder createDataBinder(ServerWebExchange exchange, @Nullable Object target, String name)",
    "source_code": "\tpublic WebExchangeDataBinder createDataBinder(ServerWebExchange exchange, @Nullable Object target, String name) {\n\t\treturn createDataBinder(exchange, target, name, null);\n\t}"
  },
  "org.springframework.web.reactive.BindingContext#createDataBinder(exchange,target,name,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a binder with a target object and a {@link ResolvableType targetType}.\n\t * If the target is {@code null}, then\n\t * {@link WebExchangeDataBinder#setTargetType targetType} is set.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "target",
      "name",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "WebExchangeDataBinder",
    "signature": "public WebExchangeDataBinder createDataBinder(ServerWebExchange exchange, @Nullable Object target, String name, @Nullable ResolvableType targetType)",
    "source_code": "\tpublic WebExchangeDataBinder createDataBinder("
  },
  "org.springframework.web.reactive.BindingContext#getModel()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the default model.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "Model",
    "signature": "public Model getModel()",
    "source_code": "\tpublic Model getModel() {\n\t\treturn this.model;\n\t}"
  },
  "org.springframework.web.reactive.BindingContext#getValuesToBind(exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "Object>>",
    "signature": "public Object>> getValuesToBind(ServerWebExchange exchange)",
    "source_code": "\t\tpublic Mono<Map<String, Object>> getValuesToBind(ServerWebExchange exchange) {\n\t\t\treturn super.getValuesToBind(exchange).doOnNext(map ->\n\t\t\t\t\tmap.putAll(exchange.<Map<String, String>>getAttributeOrDefault(\n\t\t\t\t\t\t\tHandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE, Collections.emptyMap())));\n\t\t}"
  },
  "org.springframework.web.reactive.BindingContext#initBinder(binder,parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "binder",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "void",
    "signature": "public void initBinder(DataBinder binder, MethodParameter parameter)",
    "source_code": "\t\tpublic static void initBinder(DataBinder binder, MethodParameter parameter) {\n\t\t\tif (ReactiveAdapterRegistry.getSharedInstance().getAdapter(parameter.getParameterType()) == null) {\n\t\t\t\tfor (Annotation annotation : parameter.getParameterAnnotations()) {\n\t\t\t\t\tif (annotation.annotationType().getName().equals(\"jakarta.validation.Valid\")) {\n\t\t\t\t\t\tbinder.setExcludedValidators(validator -> validator instanceof jakarta.validation.Validator);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.reactive.BindingContext#initDataBinder(binder,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the data binder instance for the given exchange.\n\t * @throws ServerErrorException if {@code @InitBinder} method invocation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "WebExchangeDataBinder",
    "signature": "protected WebExchangeDataBinder initDataBinder(WebExchangeDataBinder binder, ServerWebExchange exchange)",
    "source_code": "\tprotected WebExchangeDataBinder initDataBinder(WebExchangeDataBinder binder, ServerWebExchange exchange) {\n\t\treturn binder;\n\t}"
  },
  "org.springframework.web.reactive.BindingContext#setMethodValidationApplicable(methodValidationApplicable)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure flag to signal whether validation will be applied to handler\n\t * method arguments, which is the case if Bean Validation is enabled in\n\t * Spring MVC, and method parameters have {@code @Constraint} annotations.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodValidationApplicable"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "void",
    "signature": "public void setMethodValidationApplicable(boolean methodValidationApplicable)",
    "source_code": "\tpublic void setMethodValidationApplicable(boolean methodValidationApplicable) {\n\t\tthis.methodValidationApplicable = methodValidationApplicable;\n\t}"
  },
  "org.springframework.web.reactive.BindingContext#updateModel(exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked before rendering to add {@link BindingResult} attributes where\n\t * necessary, and also to promote model attributes listed as\n\t * {@code @SessionAttributes} to the session.\n\t * @param exchange the current exchange\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "void",
    "signature": "public void updateModel(ServerWebExchange exchange)",
    "source_code": "\tpublic void updateModel(ServerWebExchange exchange) {\n\t\tMap<String, Object> model = getModel().asMap();\n\t\tfor (Map.Entry<String, Object> entry : model.entrySet()) {\n\t\t\tString name = entry.getKey();\n\t\t\tObject value = entry.getValue();\n\t\t\tif (isBindingCandidate(name, value)) {\n\t\t\t\tif (!model.containsKey(BindingResult.MODEL_KEY_PREFIX + name)) {\n\t\t\t\t\tWebExchangeDataBinder binder = createDataBinder(exchange, value, name);\n\t\t\t\t\tmodel.put(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.WebClientAdapter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link ReactorHttpExchangeAdapter} that enables an {@link HttpServiceProxyFactory}\n * to use {@link WebClient} for request execution.\n *\n * <p>Use static factory methods in this class to create an\n * {@code HttpServiceProxyFactory} configured with a given {@code WebClient}.\n *\n * @author Rossen Stoyanchev\n * @since 6.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "signature": "public class WebClientAdapter",
    "source_code": "public final class WebClientAdapter extends AbstractReactorHttpExchangeAdapter {\n\n\tprivate final WebClient webClient;\n\n\n\t/**\n\t * Package private constructor. See static factory methods.\n\t */\n\tprivate WebClientAdapter(WebClient webClient) {\n\t\tthis.webClient = webClient;\n\t}\n\n\n\t@Override\n\tpublic boolean supportsRequestAttributes() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic Mono<Void> exchangeForMono(HttpRequestValues requestValues) {\n\t\treturn newRequest(requestValues).retrieve().toBodilessEntity().then();\n\t}\n\n\t@Override\n\tpublic Mono<HttpHeaders> exchangeForHeadersMono(HttpRequestValues requestValues) {\n\t\treturn newRequest(requestValues).retrieve().toBodilessEntity().map(ResponseEntity::getHeaders);\n\t}\n\n\t@Override\n\tpublic <T> Mono<T> exchangeForBodyMono(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(requestValues).retrieve().bodyToMono(bodyType);\n\t}\n\n\t@Override\n\tpublic <T> Flux<T> exchangeForBodyFlux(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(requestValues).retrieve().bodyToFlux(bodyType);\n\t}\n\n\t@Override\n\tpublic Mono<ResponseEntity<Void>> exchangeForBodilessEntityMono(HttpRequestValues requestValues) {\n\t\treturn newRequest(requestValues).retrieve().toBodilessEntity();\n\t}\n\n\t@Override\n\tpublic <T> Mono<ResponseEntity<T>> exchangeForEntityMono(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(requestValues).retrieve().toEntity(bodyType);\n\t}\n\n\t@Override\n\tpublic <T> Mono<ResponseEntity<Flux<T>>> exchangeForEntityFlux(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(requestValues).retrieve().toEntityFlux(bodyType);\n\t}\n\n\t@SuppressWarnings(\"ReactiveStreamsUnusedPublisher\")\n\tprivate WebClient.RequestBodySpec newRequest(HttpRequestValues requestValues) {\n\n\t\tHttpMethod httpMethod = requestValues.getHttpMethod();\n\t\tAssert.notNull(httpMethod, \"HttpMethod is required\");\n\n\t\tWebClient.RequestBodyUriSpec uriSpec = this.webClient.method(httpMethod);\n\n\t\tWebClient.RequestBodySpec bodySpec;\n\t\tif (requestValues.getUri() != null) {\n\t\t\tbodySpec = uriSpec.uri(requestValues.getUri());\n\t\t}\n\t\telse if (requestValues.getUriTemplate() != null) {\n\t\t\tbodySpec = uriSpec.uri(requestValues.getUriTemplate(), requestValues.getUriVariables());\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\"Neither full URL nor URI template\");\n\t\t}\n\n\t\tbodySpec.headers(headers -> headers.putAll(requestValues.getHeaders()));\n\t\tbodySpec.cookies(cookies -> cookies.putAll(requestValues.getCookies()));\n\t\tbodySpec.attributes(attributes -> attributes.putAll(requestValues.getAttributes()));\n\n\t\tif (requestValues.getBodyValue() != null) {\n\t\t\tbodySpec.bodyValue(requestValues.getBodyValue());\n\t\t}\n\t\telse if (requestValues instanceof ReactiveHttpRequestValues reactiveRequestValues) {\n\t\t\tPublisher<?> body = reactiveRequestValues.getBodyPublisher();\n\t\t\tif (body != null) {\n\t\t\t\tParameterizedTypeReference<?> elementType = reactiveRequestValues.getBodyPublisherElementType();\n\t\t\t\tAssert.notNull(elementType, \"Publisher body element type is required\");\n\t\t\t\tbodySpec.body(body, elementType);\n\t\t\t}\n\t\t}\n\n\t\treturn bodySpec;\n\t}\n\n\n\t/**\n\t * Create a {@link WebClientAdapter} for the given {@code WebClient} instance.\n\t * @param webClient the client to use\n\t * @return the created adapter instance\n\t */\n\tpublic static WebClientAdapter forClient(WebClient webClient) {\n\t\treturn new WebClientAdapter(webClient);\n\t}\n\n}"
  },
  "org.springframework.web.reactive.function.client.support.WebClientAdapter#exchangeForBodilessEntityMono(requestValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "Mono<ResponseEntity<Void>>",
    "signature": "public Mono<ResponseEntity<Void>> exchangeForBodilessEntityMono(HttpRequestValues requestValues)",
    "source_code": "\tpublic Mono<ResponseEntity<Void>> exchangeForBodilessEntityMono(HttpRequestValues requestValues) {\n\t\treturn newRequest(requestValues).retrieve().toBodilessEntity();\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.WebClientAdapter#exchangeForBodyFlux(requestValues,bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestValues",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "Flux<T>",
    "signature": "public Flux<T> exchangeForBodyFlux(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic <T> Flux<T> exchangeForBodyFlux(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(requestValues).retrieve().bodyToFlux(bodyType);\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.WebClientAdapter#exchangeForBodyMono(requestValues,bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestValues",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> exchangeForBodyMono(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic <T> Mono<T> exchangeForBodyMono(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(requestValues).retrieve().bodyToMono(bodyType);\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.WebClientAdapter#exchangeForEntityFlux(requestValues,bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestValues",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "Mono<ResponseEntity<Flux<T>>>",
    "signature": "public Mono<ResponseEntity<Flux<T>>> exchangeForEntityFlux(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic <T> Mono<ResponseEntity<Flux<T>>> exchangeForEntityFlux(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(requestValues).retrieve().toEntityFlux(bodyType);\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.WebClientAdapter#exchangeForEntityMono(requestValues,bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestValues",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "Mono<ResponseEntity<T>>",
    "signature": "public Mono<ResponseEntity<T>> exchangeForEntityMono(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic <T> Mono<ResponseEntity<T>> exchangeForEntityMono(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(requestValues).retrieve().toEntity(bodyType);\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.WebClientAdapter#exchangeForHeadersMono(requestValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "Mono<HttpHeaders>",
    "signature": "public Mono<HttpHeaders> exchangeForHeadersMono(HttpRequestValues requestValues)",
    "source_code": "\tpublic Mono<HttpHeaders> exchangeForHeadersMono(HttpRequestValues requestValues) {\n\t\treturn newRequest(requestValues).retrieve().toBodilessEntity().map(ResponseEntity::getHeaders);\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.WebClientAdapter#exchangeForMono(requestValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> exchangeForMono(HttpRequestValues requestValues)",
    "source_code": "\tpublic Mono<Void> exchangeForMono(HttpRequestValues requestValues) {\n\t\treturn newRequest(requestValues).retrieve().toBodilessEntity().then();\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.WebClientAdapter#forClient(webClient)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link WebClientAdapter} for the given {@code WebClient} instance.\n\t * @param webClient the client to use\n\t * @return the created adapter instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webClient"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "WebClientAdapter",
    "signature": "public WebClientAdapter forClient(WebClient webClient)",
    "source_code": "\tpublic static WebClientAdapter forClient(WebClient webClient) {\n\t\treturn new WebClientAdapter(webClient);\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.WebClientAdapter#supportsRequestAttributes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "boolean",
    "signature": "public boolean supportsRequestAttributes()",
    "source_code": "\tpublic boolean supportsRequestAttributes() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#build()": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> build()",
    "source_code": "\tpublic Mono<ServerResponse> build() {\n\t\treturn build((exchange, handlerStrategies) -> exchange.getResponse().setComplete());\n\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#bind(bindType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bindType"
    ],
    "position": {
      "column": 1,
      "line": 1049
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> bind(Class<T> bindType)",
    "source_code": "\t\tpublic <T> Mono<T> bind(Class<T> bindType) {\n\t\t\treturn this.request.bind(bindType);\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#bind(bindType,dataBinderCustomizer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bindType",
      "dataBinderCustomizer"
    ],
    "position": {
      "column": 1,
      "line": 1054
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> bind(Class<T> bindType, Consumer<WebDataBinder> dataBinderCustomizer)",
    "source_code": "\t\tpublic <T> Mono<T> bind(Class<T> bindType, Consumer<WebDataBinder> dataBinderCustomizer) {\n\t\t\treturn this.request.bind(bindType, dataBinderCustomizer);\n\t\t}"
  },
  "org.springframework.web.reactive.result.method.InvocableHandlerMethod#invokeFunction(method,target,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "target",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 300
    },
    "return": "Object",
    "signature": "public Object invokeFunction(Method method, Object target, Object[] args)",
    "source_code": "\t\tpublic static Object invokeFunction(Method method, Object target, Object[] args) {\n\t\t\tKFunction<?> function = Objects.requireNonNull(ReflectJvmMapping.getKotlinFunction(method));\n\t\t\tif (method.isAccessible() && !KCallablesJvm.isAccessible(function)) {\n\t\t\t\tKCallablesJvm.setAccessible(function, true);\n\t\t\t}\n\t\t\tMap<KParameter, Object> argMap = CollectionUtils.newHashMap(args.length + 1);\n\t\t\tint index = 0;\n\t\t\tfor (KParameter parameter : function.getParameters()) {\n\t\t\t\tswitch (parameter.getKind()) {\n\t\t\t\t\tcase INSTANCE -> argMap.put(parameter, target);\n\t\t\t\t\tcase VALUE -> {\n\t\t\t\t\t\tif (!parameter.isOptional() || args[index] != null) {\n\t\t\t\t\t\t\targMap.put(parameter, args[index]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn function.callBy(argMap);\n\t\t}"
  },
  "org.springframework.web.reactive.result.method.InvocableHandlerMethod#setMethodValidator(methodValidator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link MethodValidator} to perform method validation with if the\n\t * controller method {@link #shouldValidateArguments()} or\n\t * {@link #shouldValidateReturnValue()}.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodValidator"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "void",
    "signature": "public void setMethodValidator(@Nullable MethodValidator methodValidator)",
    "source_code": "\tpublic void setMethodValidator(@Nullable MethodValidator methodValidator) {\n\t\tthis.methodValidator = methodValidator;\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolver": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Resolve {@code @ModelAttribute} annotated method arguments.\n *\n * <p>Model attributes are sourced from the model, or created using a default\n * constructor and then added to the model. Once created the attribute is\n * populated via data binding to the request (form data, query params).\n * Validation also may be applied if the argument is annotated with\n * {@code @jakarta.validation.Valid} or Spring's own\n * {@code @org.springframework.validation.annotation.Validated}.\n *\n * <p>When this handler is created with {@code useDefaultResolution=true}\n * any non-simple type argument and return value is regarded as a model\n * attribute with or without the presence of an {@code @ModelAttribute}.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "signature": "public class ModelAttributeMethodArgumentResolver",
    "source_code": "public class ModelAttributeMethodArgumentResolver extends HandlerMethodArgumentResolverSupport {\n\n\tprivate final boolean useDefaultResolution;\n\n\n\t/**\n\t * Class constructor with a default resolution mode flag.\n\t * @param adapterRegistry for adapting to other reactive types from and to Mono\n\t * @param useDefaultResolution if \"true\", non-simple method arguments and\n\t * return values are considered model attributes with or without a\n\t * {@code @ModelAttribute} annotation present.\n\t */\n\tpublic ModelAttributeMethodArgumentResolver(ReactiveAdapterRegistry adapterRegistry,\n\t\t\tboolean useDefaultResolution) {\n\n\t\tsuper(adapterRegistry);\n\t\tthis.useDefaultResolution = useDefaultResolution;\n\t}\n\n\n\t@Override\n\tpublic boolean supportsParameter(MethodParameter parameter) {\n\t\tif (parameter.hasParameterAnnotation(ModelAttribute.class)) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (this.useDefaultResolution) {\n\t\t\treturn checkParameterType(parameter, type -> !BeanUtils.isSimpleProperty(type));\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Mono<Object> resolveArgument(\n\t\t\tMethodParameter parameter, BindingContext context, ServerWebExchange exchange) {\n\n\t\tResolvableType type = ResolvableType.forMethodParameter(parameter);\n\t\tClass<?> resolvedType = type.resolve();\n\t\tReactiveAdapter adapter = (resolvedType != null ? getAdapterRegistry().getAdapter(resolvedType) : null);\n\t\tResolvableType valueType = (adapter != null ? type.getGeneric() : type);\n\n\t\tAssert.state(adapter == null || !adapter.isMultiValue(),\n\t\t\t\t() -> getClass().getSimpleName() + \" does not support multi-value reactive type wrapper: \" +\n\t\t\t\t\t\tparameter.getGenericParameterType());\n\n\t\tString name = ModelInitializer.getNameForParameter(parameter);\n\t\tMono<?> valueMono = prepareAttributeMono(name, valueType, context, exchange);\n\n\t\t// unsafe(): we're intercepting, already serialized Publisher signals\n\t\tSinks.One<BindingResult> bindingResultSink = Sinks.unsafe().one();\n\n\t\tMap<String, Object> model = context.getModel().asMap();\n\t\tmodel.put(BindingResult.MODEL_KEY_PREFIX + name, bindingResultSink.asMono());\n\n\t\treturn valueMono.flatMap(value -> {\n\t\t\tWebExchangeDataBinder binder = context.createDataBinder(exchange, value, name);\n\t\t\treturn (bindingDisabled(parameter) ? Mono.empty() : bindRequestParameters(binder, exchange))\n\t\t\t\t\t.doOnError(bindingResultSink::tryEmitError)\n\t\t\t\t\t.doOnSuccess(aVoid -> {\n\t\t\t\t\t\tvalidateIfApplicable(binder, parameter, exchange);\n\t\t\t\t\t\tBindingResult bindingResult = binder.getBindingResult();\n\t\t\t\t\t\tmodel.put(BindingResult.MODEL_KEY_PREFIX + name, bindingResult);\n\t\t\t\t\t\tmodel.put(name, value);\n\t\t\t\t\t\t// Ignore result: serialized and buffered (should never fail)\n\t\t\t\t\t\tbindingResultSink.tryEmitValue(bindingResult);\n\t\t\t\t\t})\n\t\t\t\t\t.then(Mono.fromCallable(() -> {\n\t\t\t\t\t\tBindingResult errors = binder.getBindingResult();\n\t\t\t\t\t\tif (adapter != null) {\n\t\t\t\t\t\t\treturn adapter.fromPublisher(errors.hasErrors() ?\n\t\t\t\t\t\t\t\t\tMono.error(new WebExchangeBindException(parameter, errors)) : valueMono);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (errors.hasErrors() && !hasErrorsArgument(parameter)) {\n\t\t\t\t\t\t\t\tthrow new WebExchangeBindException(parameter, errors);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t});\n\t}\n\n\t/**\n\t * Determine if binding should be disabled for the supplied {@link MethodParameter},\n\t * based on the {@link ModelAttribute#binding} annotation attribute.\n\t * @since 5.2.15\n\t */\n\tprivate boolean bindingDisabled(MethodParameter parameter) {\n\t\tModelAttribute modelAttribute = parameter.getParameterAnnotation(ModelAttribute.class);\n\t\treturn (modelAttribute != null && !modelAttribute.binding());\n\t}\n\n\t/**\n\t * Extension point to bind the request to the target object.\n\t * @param binder the data binder instance to use for the binding\n\t * @param exchange the current request\n\t * @since 5.2.6\n\t */\n\tprotected Mono<Void> bindRequestParameters(WebExchangeDataBinder binder, ServerWebExchange exchange) {\n\t\treturn binder.bind(exchange);\n\t}\n\n\tprivate Mono<?> prepareAttributeMono(String attributeName, ResolvableType attributeType,\n\t\t\tBindingContext context, ServerWebExchange exchange) {\n\n\t\tObject attribute = context.getModel().asMap().get(attributeName);\n\n\t\tif (attribute == null) {\n\t\t\tattribute = findAndRemoveReactiveAttribute(context.getModel(), attributeName);\n\t\t}\n\n\t\tif (attribute == null) {\n\t\t\treturn createAttribute(attributeName, attributeType.toClass(), context, exchange);\n\t\t}\n\n\t\tReactiveAdapter adapter = getAdapterRegistry().getAdapter(null, attribute);\n\t\tif (adapter != null) {\n\t\t\tAssert.isTrue(!adapter.isMultiValue(), \"Data binding only supports single-value async types\");\n\t\t\treturn Mono.from(adapter.toPublisher(attribute));\n\t\t}\n\t\telse {\n\t\t\treturn Mono.justOrEmpty(attribute);\n\t\t}\n\t}\n\n\t@Nullable\n\tprivate Object findAndRemoveReactiveAttribute(Model model, String attributeName) {\n\t\treturn model.asMap().entrySet().stream()\n\t\t\t\t.filter(entry -> {\n\t\t\t\t\tif (!entry.getKey().startsWith(attributeName)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tReactiveAdapter adapter = getAdapterRegistry().getAdapter(null, entry.getValue());\n\t\t\t\t\tif (adapter == null) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tString name = attributeName + ClassUtils.getShortName(adapter.getReactiveType());\n\t\t\t\t\treturn entry.getKey().equals(name);\n\t\t\t\t})\n\t\t\t\t.findFirst()\n\t\t\t\t.map(entry -> {\n\t\t\t\t\t// Remove since we will be re-inserting the resolved attribute value\n\t\t\t\t\tmodel.asMap().remove(entry.getKey());\n\t\t\t\t\treturn entry.getValue();\n\t\t\t\t})\n\t\t\t\t.orElse(null);\n\t}\n\n\tprivate Mono<?> createAttribute(\n\t\t\tString attributeName, Class<?> clazz, BindingContext context, ServerWebExchange exchange) {\n\n\t\tConstructor<?> ctor = BeanUtils.getResolvableConstructor(clazz);\n\t\treturn constructAttribute(ctor, attributeName, context, exchange);\n\t}\n\n\tprivate Mono<?> constructAttribute(Constructor<?> ctor, String attributeName,\n\t\t\tBindingContext context, ServerWebExchange exchange) {\n\n\t\tif (ctor.getParameterCount() == 0) {\n\t\t\t// A single default constructor -> clearly a standard JavaBeans arrangement.\n\t\t\treturn Mono.just(BeanUtils.instantiateClass(ctor));\n\t\t}\n\n\t\t// A single data class constructor -> resolve constructor arguments from request parameters.\n\t\tWebExchangeDataBinder binder = context.createDataBinder(exchange, null, attributeName);\n\t\treturn getValuesToBind(binder, exchange).map(bindValues -> {\n\t\t\tString[] paramNames = BeanUtils.getParameterNames(ctor);\n\t\t\tClass<?>[] paramTypes = ctor.getParameterTypes();\n\t\t\tObject[] args = new Object[paramTypes.length];\n\t\t\tString fieldDefaultPrefix = binder.getFieldDefaultPrefix();\n\t\t\tString fieldMarkerPrefix = binder.getFieldMarkerPrefix();\n\t\t\tfor (int i = 0; i < paramNames.length; i++) {\n\t\t\t\tString paramName = paramNames[i];\n\t\t\t\tClass<?> paramType = paramTypes[i];\n\t\t\t\tObject value = bindValues.get(paramName);\n\t\t\t\tif (value == null) {\n\t\t\t\t\tif (fieldDefaultPrefix != null) {\n\t\t\t\t\t\tvalue = bindValues.get(fieldDefaultPrefix + paramName);\n\t\t\t\t\t}\n\t\t\t\t\tif (value == null && fieldMarkerPrefix != null) {\n\t\t\t\t\t\tif (bindValues.get(fieldMarkerPrefix + paramName) != null) {\n\t\t\t\t\t\t\tvalue = binder.getEmptyValue(paramType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvalue = (value instanceof List<?> list ? list.toArray() : value);\n\t\t\t\tMethodParameter methodParam = new MethodParameter(ctor, i);\n\t\t\t\tif (value == null && methodParam.isOptional()) {\n\t\t\t\t\targs[i] = (methodParam.getParameterType() == Optional.class ? Optional.empty() : null);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\targs[i] = binder.convertIfNecessary(value, paramTypes[i], methodParam);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn BeanUtils.instantiateClass(ctor, args);\n\t\t});\n\t}\n\n\t/**\n\t * Protected method to obtain the values for data binding. By default this\n\t * method delegates to {@link WebExchangeDataBinder#getValuesToBind}.\n\t * @param binder the data binder in use\n\t * @param exchange the current exchange\n\t * @return a map of bind values\n\t * @since 5.3\n\t */\n\tpublic Mono<Map<String, Object>> getValuesToBind(WebExchangeDataBinder binder, ServerWebExchange exchange) {\n\t\treturn binder.getValuesToBind(exchange);\n\t}\n\n\tprivate boolean hasErrorsArgument(MethodParameter parameter) {\n\t\tint i = parameter.getParameterIndex();\n\t\tClass<?>[] paramTypes = parameter.getExecutable().getParameterTypes();\n\t\treturn (paramTypes.length > i + 1 && Errors.class.isAssignableFrom(paramTypes[i + 1]));\n\t}\n\n\tprivate void validateIfApplicable(WebExchangeDataBinder binder, MethodParameter parameter, ServerWebExchange exchange) {\n\t\tLocaleContext localeContext = null;\n\t\ttry {\n\t\t\tfor (Annotation ann : parameter.getParameterAnnotations()) {\n\t\t\t\tObject[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);\n\t\t\t\tif (validationHints != null) {\n\t\t\t\t\tif (localeContext == null) {\n\t\t\t\t\t\tlocaleContext = exchange.getLocaleContext();\n\t\t\t\t\t\tLocaleContextHolder.setLocaleContext(localeContext);\n\t\t\t\t\t}\n\t\t\t\t\tbinder.validate(validationHints);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (localeContext != null) {\n\t\t\t\tLocaleContextHolder.resetLocaleContext();\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolver#bindRequestParameters(binder,exchange)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Extension point to bind the request to the target object.\n\t * @param binder the data binder instance to use for the binding\n\t * @param exchange the current request\n\t * @since 5.2.6\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> bindRequestParameters(WebExchangeDataBinder binder, ServerWebExchange exchange)",
    "source_code": "\tprotected Mono<Void> bindRequestParameters(WebExchangeDataBinder binder, ServerWebExchange exchange) {\n\t\treturn binder.bind(exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolver#getValuesToBind(binder,exchange)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Protected method to obtain the values for data binding. By default this\n\t * method delegates to {@link WebExchangeDataBinder#getValuesToBind}.\n\t * @param binder the data binder in use\n\t * @param exchange the current exchange\n\t * @return a map of bind values\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "binder",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "Object>>",
    "signature": "public Object>> getValuesToBind(WebExchangeDataBinder binder, ServerWebExchange exchange)",
    "source_code": "\tpublic Mono<Map<String, Object>> getValuesToBind(WebExchangeDataBinder binder, ServerWebExchange exchange) {\n\t\treturn binder.getValuesToBind(exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolver#resolveArgument(parameter,context,exchange)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "context",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "Mono<Object>",
    "signature": "public Mono<Object> resolveArgument(MethodParameter parameter, BindingContext context, ServerWebExchange exchange)",
    "source_code": "\tpublic Mono<Object> resolveArgument("
  },
  "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolver#supportsParameter(parameter)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "boolean",
    "signature": "public boolean supportsParameter(MethodParameter parameter)",
    "source_code": "\tpublic boolean supportsParameter(MethodParameter parameter) {\n\t\tif (parameter.hasParameterAnnotation(ModelAttribute.class)) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (this.useDefaultResolution) {\n\t\t\treturn checkParameterType(parameter, type -> !BeanUtils.isSimpleProperty(type));\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter#setBlockingExecutor(executor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure an executor to invoke blocking controller methods with.\n\t * <p>By default, this is not set in which case controller methods are\n\t * invoked without the use of an Executor.\n\t * @param executor the task executor to use\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "executor"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "void",
    "signature": "public void setBlockingExecutor(@Nullable Executor executor)",
    "source_code": "\tpublic void setBlockingExecutor(@Nullable Executor executor) {\n\t\tthis.scheduler = (executor != null ? Schedulers.fromExecutor(executor) : null);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter#setBlockingMethodPredicate(predicate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide a predicate to decide which controller methods to invoke through\n\t * the configured {@link #setBlockingExecutor blockingExecutor}.\n\t * <p>If an executor is configured, the default predicate matches controller\n\t * methods whose return type not recognized by the configured\n\t * {@link org.springframework.core.ReactiveAdapterRegistry}.\n\t * @param predicate the predicate to use\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "void",
    "signature": "public void setBlockingMethodPredicate(Predicate<HandlerMethod> predicate)",
    "source_code": "\tpublic void setBlockingMethodPredicate(Predicate<HandlerMethod> predicate) {\n\t\tthis.blockingMethodPredicate = predicate;\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter#test(handlerMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 324
    },
    "return": "boolean",
    "signature": "public boolean test(HandlerMethod handlerMethod)",
    "source_code": "\t\tpublic boolean test(HandlerMethod handlerMethod) {\n\t\t\tClass<?> returnType = handlerMethod.getReturnType().getParameterType();\n\t\t\treturn (this.adapterRegistry.getAdapter(returnType) == null);\n\t\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.ResponseEntityExceptionHandler#handleHandlerMethodValidationException(ex,headers,status,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link HandlerMethodValidationException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the {@code ResponseEntity} for the response\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> handleHandlerMethodValidationException(HandlerMethodValidationException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> handleHandlerMethodValidationException("
  },
  "org.springframework.web.reactive.result.method.annotation.ResponseEntityExceptionHandler#handleMethodValidationException(ex,status,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link MethodValidationException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the {@code ResponseEntity} for the response\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> handleMethodValidationException(MethodValidationException ex, HttpStatus status, ServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> handleMethodValidationException("
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#observationConvention(observationConvention)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a {@link ServerRequestObservationConvention} to use for server observations.\n\t * By default, a {@link DefaultServerRequestObservationConvention} will be used.\n\t * @param observationConvention the convention to use for all recorded observations\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "observationConvention"
    ],
    "position": {
      "column": 1,
      "line": 390
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder observationConvention(ServerRequestObservationConvention observationConvention)",
    "source_code": "\tpublic WebHttpHandlerBuilder observationConvention(ServerRequestObservationConvention observationConvention) {\n\t\tthis.observationConvention = observationConvention;\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#observationRegistry(observationRegistry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure an {@link ObservationRegistry} for recording server exchange observations.\n\t * By default, a {@link ObservationRegistry#NOOP no-op} registry will be configured.\n\t * @param observationRegistry the observation registry\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "observationRegistry"
    ],
    "position": {
      "column": 1,
      "line": 379
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder observationRegistry(ObservationRegistry observationRegistry)",
    "source_code": "\tpublic WebHttpHandlerBuilder observationRegistry(ObservationRegistry observationRegistry) {\n\t\tthis.observationRegistry = observationRegistry;\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#create(client,method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Create the {@code ResponseFunction} that matches the method return type.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "client",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 379
    },
    "return": "ResponseFunction",
    "signature": "public ResponseFunction create(ReactorHttpExchangeAdapter client, Method method)",
    "source_code": "\t\tpublic static ResponseFunction create(ReactorHttpExchangeAdapter client, Method method) {\n\t\t\tMethodParameter returnParam = new MethodParameter(method, -1);\n\t\t\tClass<?> returnType = returnParam.getParameterType();\n\t\t\tboolean isSuspending = KotlinDetector.isSuspendingFunction(method);\n\t\t\tif (isSuspending) {\n\t\t\t\treturnType = Mono.class;\n\t\t\t}\n\n\t\t\tReactiveAdapter reactiveAdapter = client.getReactiveAdapterRegistry().getAdapter(returnType);\n\n\t\t\tMethodParameter actualParam = (reactiveAdapter != null ? returnParam.nested() : returnParam.nestedIfOptional());\n\t\t\tClass<?> actualType = isSuspending ? actualParam.getParameterType() : actualParam.getNestedParameterType();\n\n\t\t\tFunction<HttpRequestValues, Publisher<?>> responseFunction;\n\t\t\tif (actualType.equals(void.class) || actualType.equals(Void.class)) {\n\t\t\t\tresponseFunction = client::exchangeForMono;\n\t\t\t}\n\t\t\telse if (reactiveAdapter != null && reactiveAdapter.isNoValue()) {\n\t\t\t\tresponseFunction = client::exchangeForMono;\n\t\t\t}\n\t\t\telse if (actualType.equals(HttpHeaders.class)) {\n\t\t\t\tresponseFunction = client::exchangeForHeadersMono;\n\t\t\t}\n\t\t\telse if (actualType.equals(ResponseEntity.class)) {\n\t\t\t\tMethodParameter bodyParam = isSuspending ? actualParam : actualParam.nested();\n\t\t\t\tClass<?> bodyType = bodyParam.getNestedParameterType();\n\t\t\t\tif (bodyType.equals(Void.class)) {\n\t\t\t\t\tresponseFunction = client::exchangeForBodilessEntityMono;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tReactiveAdapter bodyAdapter = client.getReactiveAdapterRegistry().getAdapter(bodyType);\n\t\t\t\t\tresponseFunction = initResponseEntityFunction(client, bodyParam, bodyAdapter, isSuspending);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresponseFunction = initBodyFunction(client, actualParam, reactiveAdapter, isSuspending);\n\t\t\t}\n\n\t\t\treturn new ReactorExchangeResponseFunction(\n\t\t\t\t\tresponseFunction, reactiveAdapter, returnType.equals(Optional.class), client.getBlockTimeout());\n\t\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#create(client,method,reactiveRegistry,blockTimeout)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Create the {@code ResponseFunction} that matches the method's return type.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "client",
      "method",
      "reactiveRegistry",
      "blockTimeout"
    ],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "ResponseFunction",
    "signature": "public ResponseFunction create(HttpClientAdapter client, Method method, ReactiveAdapterRegistry reactiveRegistry,\n\t\t\t\tDuration blockTimeout)",
    "source_code": "\t\tpublic static ResponseFunction create("
  },
  "org.springframework.web.service.invoker.<unknown>#create(method,containingClass,embeddedValueResolver)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Introspect the method and create the request factory for it.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "containingClass",
      "embeddedValueResolver"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "HttpRequestValuesInitializer",
    "signature": "public HttpRequestValuesInitializer create(Method method, Class<?> containingClass, @Nullable StringValueResolver embeddedValueResolver)",
    "source_code": "\t\tpublic static HttpRequestValuesInitializer create("
  },
  "org.springframework.web.service.invoker.<unknown>#create(method,containingClass,embeddedValueResolver,requestValuesSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Introspect the method and create the request factory for it.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "containingClass",
      "embeddedValueResolver",
      "requestValuesSupplier"
    ],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "HttpRequestValuesInitializer",
    "signature": "public HttpRequestValuesInitializer create(Method method, Class<?> containingClass, @Nullable StringValueResolver embeddedValueResolver,\n\t\t\t\tSupplier<HttpRequestValues.Builder> requestValuesSupplier)",
    "source_code": "\t\tpublic static HttpRequestValuesInitializer create("
  },
  "org.springframework.web.service.invoker.HttpServiceProxyFactory#builderFor(exchangeAdapter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a builder that's initialized with the given client.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchangeAdapter"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "Builder",
    "signature": "public Builder builderFor(HttpExchangeAdapter exchangeAdapter)",
    "source_code": "\tpublic static Builder builderFor(HttpExchangeAdapter exchangeAdapter) {\n\t\treturn new Builder().exchangeAdapter(exchangeAdapter);\n\t}"
  },
  "org.springframework.web.service.invoker.HttpServiceProxyFactory#exchangeAdapter(adapter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Provide the HTTP client to perform requests through.\n\t\t * @param adapter a client adapted to {@link HttpExchangeAdapter}\n\t\t * @return this same builder instance\n\t\t * @since 6.1\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "adapter"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "Builder",
    "signature": "public Builder exchangeAdapter(HttpExchangeAdapter adapter)",
    "source_code": "\t\tpublic Builder exchangeAdapter(HttpExchangeAdapter adapter) {\n\t\t\tthis.exchangeAdapter = adapter;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.service.invoker.RequestBodyArgumentResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link HttpServiceArgumentResolver} for {@link RequestBody @RequestBody}\n * annotated arguments.\n *\n * @author Rossen Stoyanchev\n * @since 6.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 35
    },
    "signature": "public class RequestBodyArgumentResolver",
    "source_code": "public class RequestBodyArgumentResolver implements HttpServiceArgumentResolver {\n\n\tprivate static final boolean REACTOR_PRESENT =\n\t\t\tClassUtils.isPresent(\"reactor.core.publisher.Mono\", RequestBodyArgumentResolver.class.getClassLoader());\n\n\n\t@Nullable\n\tprivate final ReactiveAdapterRegistry reactiveAdapterRegistry;\n\n\n\t/**\n\t * Constructor with a {@link HttpExchangeAdapter}, for access to config settings.\n\t * @since 6.1\n\t */\n\tpublic RequestBodyArgumentResolver(HttpExchangeAdapter exchangeAdapter) {\n\t\tif (REACTOR_PRESENT) {\n\t\t\tthis.reactiveAdapterRegistry =\n\t\t\t\t\t(exchangeAdapter instanceof ReactorHttpExchangeAdapter reactorAdapter ?\n\t\t\t\t\t\t\treactorAdapter.getReactiveAdapterRegistry() :\n\t\t\t\t\t\t\tReactiveAdapterRegistry.getSharedInstance());\n\t\t}\n\t\telse {\n\t\t\tthis.reactiveAdapterRegistry = null;\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic boolean resolve(\n\t\t\t@Nullable Object argument, MethodParameter parameter, HttpRequestValues.Builder requestValues) {\n\n\t\tRequestBody annot = parameter.getParameterAnnotation(RequestBody.class);\n\t\tif (annot == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (argument != null) {\n\t\t\tif (this.reactiveAdapterRegistry != null) {\n\t\t\t\tReactiveAdapter adapter = this.reactiveAdapterRegistry.getAdapter(parameter.getParameterType());\n\t\t\t\tif (adapter != null) {\n\t\t\t\t\tMethodParameter nestedParameter = parameter.nested();\n\n\t\t\t\t\tString message = \"Async type for @RequestBody should produce value(s)\";\n\t\t\t\t\tAssert.isTrue(!adapter.isNoValue(), message);\n\t\t\t\t\tAssert.isTrue(nestedParameter.getNestedParameterType() != Void.class, message);\n\n\t\t\t\t\tif (requestValues instanceof ReactiveHttpRequestValues.Builder reactiveRequestValues) {\n\t\t\t\t\t\treactiveRequestValues.setBodyPublisher(\n\t\t\t\t\t\t\t\tadapter.toPublisher(argument), asParameterizedTypeRef(nestedParameter));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\t\"RequestBody with a reactive type is only supported with reactive client\");\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Not a reactive type\n\t\t\trequestValues.setBodyValue(argument);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate static ParameterizedTypeReference<Object> asParameterizedTypeRef(MethodParameter nestedParam) {\n\t\treturn ParameterizedTypeReference.forType(nestedParam.getNestedGenericParameterType());\n\t}\n\n}"
  },
  "org.springframework.web.service.invoker.RequestBodyArgumentResolver#resolve(argument,parameter,requestValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argument",
      "parameter",
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "boolean",
    "signature": "public boolean resolve(@Nullable Object argument, MethodParameter parameter, HttpRequestValues.Builder requestValues)",
    "source_code": "\tpublic boolean resolve("
  },
  "org.springframework.web.service.invoker.RequestPartArgumentResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link HttpServiceArgumentResolver} for {@link RequestPart @RequestPart}\n * annotated arguments.\n *\n * <p>The argument may be:\n * <ul>\n * <li>String -- form field\n * <li>{@link org.springframework.core.io.Resource Resource} -- file part\n * <li>Object -- content to be encoded (e.g. to JSON)\n * <li>{@link HttpEntity} -- part content and headers although generally it's\n * easier to add headers through the returned builder\n * <li>{@link Part} -- a part from a server request\n * <li>{@link Publisher} of any of the above\n * </ul>\n *\n * @author Rossen Stoyanchev\n * @since 6.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "public class RequestPartArgumentResolver",
    "source_code": "public class RequestPartArgumentResolver extends AbstractNamedValueArgumentResolver {\n\n\tprivate static final boolean REACTOR_PRESENT =\n\t\t\tClassUtils.isPresent(\"reactor.core.publisher.Mono\", RequestPartArgumentResolver.class.getClassLoader());\n\n\n\t@Nullable\n\tprivate final ReactiveAdapterRegistry reactiveAdapterRegistry;\n\n\n\t/**\n\t * Constructor with a {@link HttpExchangeAdapter}, for access to config settings.\n\t * @since 6.1\n\t */\n\tpublic RequestPartArgumentResolver(HttpExchangeAdapter exchangeAdapter) {\n\t\tif (REACTOR_PRESENT) {\n\t\t\tthis.reactiveAdapterRegistry =\n\t\t\t\t\t(exchangeAdapter instanceof ReactorHttpExchangeAdapter reactorAdapter ?\n\t\t\t\t\t\t\treactorAdapter.getReactiveAdapterRegistry() :\n\t\t\t\t\t\t\tReactiveAdapterRegistry.getSharedInstance());\n\t\t}\n\t\telse {\n\t\t\tthis.reactiveAdapterRegistry = null;\n\t\t}\n\t}\n\n\n\t@Override\n\tprotected NamedValueInfo createNamedValueInfo(MethodParameter parameter) {\n\t\tRequestPart annot = parameter.getParameterAnnotation(RequestPart.class);\n\t\treturn (annot == null ? null :\n\t\t\t\tnew NamedValueInfo(annot.name(), annot.required(), null, \"request part\", true));\n\t}\n\n\t@Override\n\tprotected void addRequestValue(\n\t\t\tString name, Object value, MethodParameter parameter, HttpRequestValues.Builder requestValues) {\n\n\t\tif (this.reactiveAdapterRegistry != null) {\n\t\t\tClass<?> type = parameter.getParameterType();\n\t\t\tReactiveAdapter adapter = this.reactiveAdapterRegistry.getAdapter(type);\n\t\t\tif (adapter != null) {\n\t\t\t\tMethodParameter nestedParameter = parameter.nested();\n\n\t\t\t\tString message = \"Async type for @RequestPart should produce value(s)\";\n\t\t\t\tAssert.isTrue(!adapter.isNoValue(), message);\n\t\t\t\tAssert.isTrue(nestedParameter.getNestedParameterType() != Void.class, message);\n\n\t\t\t\tif (requestValues instanceof ReactiveHttpRequestValues.Builder reactiveValues) {\n\t\t\t\t\treactiveValues.addRequestPartPublisher(\n\t\t\t\t\t\t\tname, adapter.toPublisher(value), asParameterizedTypeRef(nestedParameter));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\"RequestPart with a reactive type is only supported with reactive client\");\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\trequestValues.addRequestPart(name, value);\n\t}\n\n\tprivate static ParameterizedTypeReference<Object> asParameterizedTypeRef(MethodParameter nestedParam) {\n\t\treturn ParameterizedTypeReference.forType(nestedParam.getNestedGenericParameterType());\n\t}\n\n}"
  },
  "org.springframework.web.service.invoker.RequestPartArgumentResolver#addRequestValue(name,value,parameter,requestValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "value",
      "parameter",
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "void",
    "signature": "protected void addRequestValue(String name, Object value, MethodParameter parameter, HttpRequestValues.Builder requestValues)",
    "source_code": "\tprotected void addRequestValue("
  },
  "org.springframework.web.service.invoker.RequestPartArgumentResolver#createNamedValueInfo(parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "NamedValueInfo",
    "signature": "protected NamedValueInfo createNamedValueInfo(MethodParameter parameter)",
    "source_code": "\tprotected NamedValueInfo createNamedValueInfo(MethodParameter parameter) {\n\t\tRequestPart annot = parameter.getParameterAnnotation(RequestPart.class);\n\t\treturn (annot == null ? null :\n\t\t\t\tnew NamedValueInfo(annot.name(), annot.required(), null, \"request part\", true));\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#bind(bindType,dataBinderCustomizer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bindType",
      "dataBinderCustomizer"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "T",
    "signature": "public T bind(Class<T> bindType, Consumer<WebDataBinder> dataBinderCustomizer)",
    "source_code": "\t\tpublic <T> T bind(Class<T> bindType, Consumer<WebDataBinder> dataBinderCustomizer) throws BindException {\n\t\t\tAssert.notNull(bindType, \"BindType must not be null\");\n\t\t\tAssert.notNull(dataBinderCustomizer, \"DataBinderCustomizer must not be null\");\n\n\t\t\tServletRequestDataBinder dataBinder = new ServletRequestDataBinder(null);\n\t\t\tdataBinder.setTargetType(ResolvableType.forClass(bindType));\n\t\t\tdataBinderCustomizer.accept(dataBinder);\n\n\t\t\tHttpServletRequest servletRequest = servletRequest();\n\t\t\tdataBinder.construct(servletRequest);\n\t\t\tdataBinder.bind(servletRequest);\n\n\t\t\tBindingResult bindingResult = dataBinder.getBindingResult();\n\t\t\tif (bindingResult.hasErrors()) {\n\t\t\t\tthrow new BindException(bindingResult);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tT result = (T) bindingResult.getTarget();\n\t\t\t\tif (result != null) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalStateException(\"Binding result has neither target nor errors\");\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.function.RequestPredicates#bind(bindType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bindType"
    ],
    "position": {
      "column": 1,
      "line": 1024
    },
    "return": "T",
    "signature": "public T bind(Class<T> bindType)",
    "source_code": "\t\tpublic <T> T bind(Class<T> bindType) throws BindException {\n\t\t\treturn this.request.bind(bindType);\n\t\t}"
  },
  "org.springframework.web.servlet.function.RequestPredicates#bind(bindType,dataBinderCustomizer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bindType",
      "dataBinderCustomizer"
    ],
    "position": {
      "column": 1,
      "line": 1029
    },
    "return": "T",
    "signature": "public T bind(Class<T> bindType, Consumer<WebDataBinder> dataBinderCustomizer)",
    "source_code": "\t\tpublic <T> T bind(Class<T> bindType, Consumer<WebDataBinder> dataBinderCustomizer) throws BindException {\n\t\t\treturn this.request.bind(bindType, dataBinderCustomizer);\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler#handleHandlerMethodValidationException(ex,headers,status,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link HandlerMethodValidationException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to be written to the response\n\t * @param status the selected response status\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 360
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleHandlerMethodValidationException(HandlerMethodValidationException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleHandlerMethodValidationException("
  },
  "org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler#handleMethodValidationException(ex,headers,status,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link MethodValidationException}.\n\t * <p>By default this method creates a {@link ProblemDetail} with the status\n\t * and a short detail message, and also looks up an override for the detail\n\t * via {@link MessageSource}, before delegating to\n\t * {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 568
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleMethodValidationException(MethodValidationException ex, HttpHeaders headers, HttpStatus status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleMethodValidationException("
  },
  "org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler#handleNoResourceFoundException(ex,headers,status,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link NoResourceFoundException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 396
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleNoResourceFoundException(NoResourceFoundException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleNoResourceFoundException("
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#handleHandlerMethodValidationException(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where method validation for a controller method failed.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the exception to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 428
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleHandlerMethodValidationException(HandlerMethodValidationException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleHandlerMethodValidationException(HandlerMethodValidationException ex,"
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#handleMethodValidationException(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where method validation failed on a component that is\n\t * not a web controller, e.g. on some underlying service.\n\t * <p>The default implementation sends an HTTP 500 error, and returns an empty {@code ModelAndView}.\n\t * Alternatively, a fallback view could be chosen, or the HttpMessageNotWritableException could\n\t * be rethrown as-is.\n\t * @param ex the exception to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 626
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleMethodValidationException(MethodValidationException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleMethodValidationException(MethodValidationException ex,"
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#handleNoResourceFoundException(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where no static resource was found.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the {@link NoResourceFoundException} to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the resource handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 470
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleNoResourceFoundException(NoResourceFoundException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleNoResourceFoundException(NoResourceFoundException ex,"
  },
  "org.springframework.web.util.BindErrorUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Utility methods to resolve a list of {@link MessageSourceResolvable}s, and\n * optionally join them.\n *\n * @author Rossen Stoyanchev\n * @since 6.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "signature": "public class BindErrorUtils",
    "source_code": "public abstract class BindErrorUtils {\n\n\tprivate final static MessageSource defaultMessageSource = new MethodArgumentErrorMessageSource();\n\n\n\t/**\n\t * Shortcut for {@link #resolveAndJoin(List, MessageSource, Locale)} with\n\t * an empty {@link MessageSource} that simply formats the default message,\n\t * or first error code, also prepending the field name for field errors.\n\t */\n\tpublic static String resolveAndJoin(List<? extends MessageSourceResolvable> errors) {\n\t\treturn resolveAndJoin(errors, defaultMessageSource, Locale.getDefault());\n\t}\n\n\t/**\n\t * Shortcut for {@link #resolveAndJoin(CharSequence, CharSequence, CharSequence, List, MessageSource, Locale)}\n\t * with {@code \", and \"} as delimiter, and an empty prefix and suffix.\n\t */\n\tpublic static String resolveAndJoin(\n\t\t\tList<? extends MessageSourceResolvable> errors, MessageSource messageSource, Locale locale) {\n\n\t\treturn resolveAndJoin(\", and \", \"\", \"\", errors, messageSource, locale);\n\t}\n\n\t/**\n\t * Resolve all errors through the given {@link MessageSource} and join them.\n\t * @param delimiter the delimiter to use between each error\n\t * @param prefix characters to insert at the beginning\n\t * @param suffix characters to insert at the end\n\t * @param errors the errors to resolve and join\n\t * @param messageSource the {@code MessageSource} to resolve with\n\t * @param locale the locale to resolve with\n\t * @return the resolved errors formatted as a string\n\t */\n\tpublic static String resolveAndJoin(\n\t\t\tCharSequence delimiter, CharSequence prefix, CharSequence suffix,\n\t\t\tList<? extends MessageSourceResolvable> errors, MessageSource messageSource, Locale locale) {\n\n\t\treturn errors.stream()\n\t\t\t\t.map(error -> messageSource.getMessage(error, locale))\n\t\t\t\t.filter(StringUtils::hasText)\n\t\t\t\t.collect(Collectors.joining(delimiter, prefix, suffix));\n\t}\n\n\t/**\n\t * Shortcut for {@link #resolve(List, MessageSource, Locale)} with an empty\n\t * {@link MessageSource} that simply formats the default message, or first\n\t * error code, also prepending the field name for field errors.\n\t */\n\tpublic static <E extends MessageSourceResolvable> Map<E, String> resolve(List<E> errors) {\n\t\treturn resolve(errors, defaultMessageSource, Locale.getDefault());\n\t}\n\n\t/**\n\t * Resolve all errors through the given {@link MessageSource}.\n\t * @param errors the errors to resolve\n\t * @param messageSource the {@code MessageSource} to resolve with\n\t * @param locale the locale to resolve with an empty {@link MessageSource}\n\t * @return map with resolved errors as values, in the order of the input list\n\t */\n\tpublic static <E extends MessageSourceResolvable> Map<E, String> resolve(\n\t\t\tList<E> errors, MessageSource messageSource, Locale locale) {\n\n\t\tMap<E, String> map = new LinkedHashMap<>(errors.size());\n\t\terrors.forEach(error -> map.put(error, messageSource.getMessage(error, locale)));\n\t\treturn map;\n\t}\n\n\n\t/**\n\t * {@code MessageSource} for default error formatting.\n\t */\n\tprivate static class MethodArgumentErrorMessageSource extends StaticMessageSource {\n\n\t\tMethodArgumentErrorMessageSource() {\n\t\t\tsetUseCodeAsDefaultMessage(true);\n\t\t}\n\n\t\t@Override\n\t\tprotected String getDefaultMessage(MessageSourceResolvable resolvable, Locale locale) {\n\t\t\tString message = super.getDefaultMessage(resolvable, locale);\n\t\t\treturn (resolvable instanceof FieldError error ? error.getField() + \": \" + message : message);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.util.BindErrorUtils#getDefaultMessage(resolvable,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resolvable",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "String",
    "signature": "protected String getDefaultMessage(MessageSourceResolvable resolvable, Locale locale)",
    "source_code": "\t\tprotected String getDefaultMessage(MessageSourceResolvable resolvable, Locale locale) {\n\t\t\tString message = super.getDefaultMessage(resolvable, locale);\n\t\t\treturn (resolvable instanceof FieldError error ? error.getField() + \": \" + message : message);\n\t\t}"
  },
  "org.springframework.web.util.BindErrorUtils#resolve(errors)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Shortcut for {@link #resolve(List, MessageSource, Locale)} with an empty\n\t * {@link MessageSource} that simply formats the default message, or first\n\t * error code, also prepending the field name for field errors.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "String>",
    "signature": "public String> resolve(List<E> errors)",
    "source_code": "\tpublic static <E extends MessageSourceResolvable> Map<E, String> resolve(List<E> errors) {\n\t\treturn resolve(errors, defaultMessageSource, Locale.getDefault());\n\t}"
  },
  "org.springframework.web.util.BindErrorUtils#resolve(errors,messageSource,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve all errors through the given {@link MessageSource}.\n\t * @param errors the errors to resolve\n\t * @param messageSource the {@code MessageSource} to resolve with\n\t * @param locale the locale to resolve with an empty {@link MessageSource}\n\t * @return map with resolved errors as values, in the order of the input list\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors",
      "messageSource",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "String>",
    "signature": "public String> resolve(List<E> errors, MessageSource messageSource, Locale locale)",
    "source_code": "\tpublic static <E extends MessageSourceResolvable> Map<E, String> resolve("
  },
  "org.springframework.web.util.BindErrorUtils#resolveAndJoin(delimiter,prefix,suffix,errors,messageSource,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve all errors through the given {@link MessageSource} and join them.\n\t * @param delimiter the delimiter to use between each error\n\t * @param prefix characters to insert at the beginning\n\t * @param suffix characters to insert at the end\n\t * @param errors the errors to resolve and join\n\t * @param messageSource the {@code MessageSource} to resolve with\n\t * @param locale the locale to resolve with\n\t * @return the resolved errors formatted as a string\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "delimiter",
      "prefix",
      "suffix",
      "errors",
      "messageSource",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "String",
    "signature": "public String resolveAndJoin(CharSequence delimiter, CharSequence prefix, CharSequence suffix,\n\t\t\tList<? extends MessageSourceResolvable> errors, MessageSource messageSource, Locale locale)",
    "source_code": "\tpublic static String resolveAndJoin("
  },
  "org.springframework.web.util.BindErrorUtils#resolveAndJoin(errors)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Shortcut for {@link #resolveAndJoin(List, MessageSource, Locale)} with\n\t * an empty {@link MessageSource} that simply formats the default message,\n\t * or first error code, also prepending the field name for field errors.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "return": "String",
    "signature": "public String resolveAndJoin(List<? extends MessageSourceResolvable> errors)",
    "source_code": "\tpublic static String resolveAndJoin(List<? extends MessageSourceResolvable> errors) {\n\t\treturn resolveAndJoin(errors, defaultMessageSource, Locale.getDefault());\n\t}"
  },
  "org.springframework.web.util.BindErrorUtils#resolveAndJoin(errors,messageSource,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Shortcut for {@link #resolveAndJoin(CharSequence, CharSequence, CharSequence, List, MessageSource, Locale)}\n\t * with {@code \", and \"} as delimiter, and an empty prefix and suffix.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors",
      "messageSource",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "String",
    "signature": "public String resolveAndJoin(List<? extends MessageSourceResolvable> errors, MessageSource messageSource, Locale locale)",
    "source_code": "\tpublic static String resolveAndJoin("
  }
}