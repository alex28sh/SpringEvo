{
  "org.springframework.beans.factory.config.YamlProcessor#isGlobalTagAllowed(tag)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "tag"
    ],
    "position": {
      "column": 1,
      "line": 435
    },
    "return": "boolean",
    "signature": "public boolean isGlobalTagAllowed(Tag tag)",
    "source_code": "\t\tpublic boolean isGlobalTagAllowed(Tag tag) {\n\t\t\treturn supportedTypes.contains(tag.getClassName());\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#await(destroyMethod,returnValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destroyMethod",
      "returnValue"
    ],
    "position": {
      "column": 1,
      "line": 492
    },
    "return": "boolean",
    "signature": "public boolean await(Method destroyMethod, Object returnValue)",
    "source_code": "\t\tpublic boolean await(Method destroyMethod, Object returnValue) throws InterruptedException {\n\t\t\tReactiveAdapter adapter = ReactiveAdapterRegistry.getSharedInstance().getAdapter(returnValue.getClass());\n\t\t\tif (adapter != null) {\n\t\t\t\tCountDownLatch latch = new CountDownLatch(1);\n\t\t\t\tadapter.toPublisher(returnValue).subscribe(new DestroyMethodSubscriber(destroyMethod, latch));\n\t\t\t\tlatch.await();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#onComplete()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 535
    },
    "return": "void",
    "signature": "public void onComplete()",
    "source_code": "\t\tpublic void onComplete() {\n\t\t\tthis.latch.countDown();\n\t\t\tlogDestroyMethodCompletion(this.destroyMethod, true);\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#onError(t)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "t"
    ],
    "position": {
      "column": 1,
      "line": 529
    },
    "return": "void",
    "signature": "public void onError(Throwable t)",
    "source_code": "\t\tpublic void onError(Throwable t) {\n\t\t\tthis.latch.countDown();\n\t\t\tlogDestroyMethodException(this.destroyMethod, t);\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#onNext(o)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o"
    ],
    "position": {
      "column": 1,
      "line": 525
    },
    "return": "void",
    "signature": "public void onNext(Object o)",
    "source_code": "\t\tpublic void onNext(Object o) {\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#onSubscribe(s)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "s"
    ],
    "position": {
      "column": 1,
      "line": 520
    },
    "return": "void",
    "signature": "public void onSubscribe(Subscription s)",
    "source_code": "\t\tpublic void onSubscribe(Subscription s) {\n\t\t\ts.request(Integer.MAX_VALUE);\n\t\t}"
  },
  "org.springframework.context.support.CHECKPOINT_ON_REFRESH_VALUE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Recognized value for the context checkpoint property: {@value}.\n\t * @since 6.1\n\t * @see #CHECKPOINT_PROPERTY_NAME\n\t * @see org.crac.Core#checkpointRestore()\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "signature": "public String CHECKPOINT_ON_REFRESH_VALUE",
    "source_code": "\tpublic static final String CHECKPOINT_ON_REFRESH_VALUE = \"onRefresh\";",
    "type": "String"
  },
  "org.springframework.context.support.CHECKPOINT_PROPERTY_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Property name for a common context checkpoint: {@value}.\n\t * @since 6.1\n\t * @see #CHECKPOINT_ON_REFRESH_VALUE\n\t * @see org.crac.Core#checkpointRestore()\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "signature": "public String CHECKPOINT_PROPERTY_NAME",
    "source_code": "\tpublic static final String CHECKPOINT_PROPERTY_NAME = \"spring.context.checkpoint\";",
    "type": "String"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#afterRestore(context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 544
    },
    "return": "void",
    "signature": "public void afterRestore(org.crac.Context<? extends org.crac.Resource> context)",
    "source_code": "\t\tpublic void afterRestore(org.crac.Context<? extends org.crac.Resource> context) {\n\t\t\tlong restartTime = System.nanoTime();\n\t\t\tlogger.debug(\"Restarting Spring-managed lifecycle beans after JVM restore\");\n\t\t\trestartAfterStop();\n\n\t\t\t// Barrier for prevent-shutdown thread not needed anymore\n\t\t\tthis.barrier = null;\n\n\t\t\tDuration timeTakenToRestart = Duration.ofNanos(System.nanoTime() - restartTime);\n\t\t\tlogger.debug(\"Restart complete in \" + timeTakenToRestart.toMillis() + \" ms\");\n\t\t}"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#beforeCheckpoint(context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 525
    },
    "return": "void",
    "signature": "public void beforeCheckpoint(org.crac.Context<? extends org.crac.Resource> context)",
    "source_code": "\t\tpublic void beforeCheckpoint(org.crac.Context<? extends org.crac.Resource> context) {\n\t\t\t// A non-daemon thread for preventing an accidental JVM shutdown before the checkpoint\n\t\t\tthis.barrier = new CyclicBarrier(2);\n\n\t\t\tThread thread = new Thread(() -> {\n\t\t\t\tawaitPreventShutdownBarrier();\n\t\t\t\t// Checkpoint happens here\n\t\t\t\tawaitPreventShutdownBarrier();\n\t\t\t}, \"prevent-shutdown\");\n\n\t\t\tthread.setDaemon(false);\n\t\t\tthread.start();\n\t\t\tawaitPreventShutdownBarrier();\n\n\t\t\tlogger.debug(\"Stopping Spring-managed lifecycle beans before JVM checkpoint\");\n\t\t\tstopForRestart();\n\t\t}"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#checkpointRestore()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 494
    },
    "return": "void",
    "signature": "public void checkpointRestore()",
    "source_code": "\t\tpublic void checkpointRestore() {\n\t\t\tlogger.info(\"Triggering JVM checkpoint/restore\");\n\t\t\ttry {\n\t\t\t\tCore.checkpointRestore();\n\t\t\t}\n\t\t\tcatch (UnsupportedOperationException ex) {\n\t\t\t\tthrow new ApplicationContextException(\"CRaC checkpoint not supported on current JVM\", ex);\n\t\t\t}\n\t\t\tcatch (CheckpointException ex) {\n\t\t\t\tthrow new ApplicationContextException(\"Failed to take CRaC checkpoint on refresh\", ex);\n\t\t\t}\n\t\t\tcatch (RestoreException ex) {\n\t\t\t\tthrow new ApplicationContextException(\"Failed to restore CRaC checkpoint on refresh\", ex);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#compareTo(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 410
    },
    "return": "int",
    "signature": "public int compareTo(LifecycleGroupMember other)",
    "source_code": "\t\tpublic int compareTo(LifecycleGroupMember other) {\n\t\t\tint thisPhase = getPhase(this.bean);\n\t\t\tint otherPhase = getPhase(other.bean);\n\t\t\treturn Integer.compare(thisPhase, otherPhase);\n\t\t}"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#registerResource()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 487
    },
    "return": "Object",
    "signature": "public Object registerResource()",
    "source_code": "\t\tpublic Object registerResource() {\n\t\t\tlogger.debug(\"Registering JVM checkpoint/restore callback for Spring-managed lifecycle beans\");\n\t\t\tCracResourceAdapter resourceAdapter = new CracResourceAdapter();\n\t\t\torg.crac.Core.getGlobalContext().register(resourceAdapter);\n\t\t\treturn resourceAdapter;\n\t\t}"
  },
  "org.springframework.context.support.ReloadableResourceBundleMessageSource#resolveResource(filename)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the specified bundle {@code filename} into a concrete {@link Resource},\n\t * potentially checking multiple sources or file extensions.\n\t * <p>If no suitable concrete {@code Resource} can be resolved, this method\n\t * returns a {@code Resource} for which {@link Resource#exists()} returns\n\t * {@code false}, which gets subsequently ignored.\n\t * <p>This can be leveraged to check the last modification timestamp or to load\n\t * properties from alternative sources &mdash; for example, from an XML BLOB\n\t * in a database, or from properties serialized using a custom format such as\n\t * JSON.\n\t * <p>The default implementation delegates to the configured\n\t * {@link #setResourceLoader(ResourceLoader) ResourceLoader} to resolve\n\t * resources, first checking for an existing {@code Resource} with a\n\t * {@code .properties} extension, and otherwise returning a {@code Resource}\n\t * with a {@code .xml} extension.\n\t * <p>When overriding this method, {@link #loadProperties(Resource, String)}\n\t * <strong>must</strong> be capable of loading properties from any type of\n\t * {@code Resource} returned by this method. As a consequence, implementors\n\t * are strongly encouraged to also override {@code loadProperties()}.\n\t * <p>As an alternative to overriding this method, you can configure a\n\t * {@link #setPropertiesPersister(PropertiesPersister) PropertiesPersister}\n\t * that is capable of dealing with all resources returned by this method.\n\t * Please note, however, that the default {@code loadProperties()} implementation\n\t * uses {@link PropertiesPersister#loadFromXml(Properties, InputStream) loadFromXml}\n\t * for XML resources and otherwise uses the two\n\t * {@link PropertiesPersister#load(Properties, InputStream) load} methods\n\t * for other types of resources.\n\t * @param filename the bundle filename (basename + Locale)\n\t * @return the {@code Resource} to use\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "filename"
    ],
    "position": {
      "column": 1,
      "line": 493
    },
    "return": "Resource",
    "signature": "protected Resource resolveResource(String filename)",
    "source_code": "\tprotected Resource resolveResource(String filename) {\n\t\tResource propertiesResource = this.resourceLoader.getResource(filename + PROPERTIES_SUFFIX);\n\t\tif (propertiesResource.exists()) {\n\t\t\treturn propertiesResource;\n\t\t}\n\t\treturn this.resourceLoader.getResource(filename + XML_SUFFIX);\n\t}"
  },
  "org.springframework.core.MethodParameter#forFieldAwareConstructor(ctor,parameterIndex,fieldName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new MethodParameter for the given field-aware constructor,\n\t * e.g. on a data class or record type.\n\t * <p>A field-aware method parameter will detect field annotations as well,\n\t * as long as the field name matches the parameter name.\n\t * @param ctor the Constructor to specify a parameter for\n\t * @param parameterIndex the index of the parameter\n\t * @param fieldName the name of the underlying field,\n\t * matching the constructor's parameter name\n\t * @return the corresponding MethodParameter instance\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ctor",
      "parameterIndex",
      "fieldName"
    ],
    "position": {
      "column": 1,
      "line": 878
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter forFieldAwareConstructor(Constructor<?> ctor, int parameterIndex, String fieldName)",
    "source_code": "\tpublic static MethodParameter forFieldAwareConstructor(Constructor<?> ctor, int parameterIndex, String fieldName) {\n\t\treturn new FieldAwareConstructorParameter(ctor, parameterIndex, fieldName);\n\t}"
  },
  "org.springframework.core.task.support.TaskExecutorAdapter#execute(task,startTimeout)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "startTimeout"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "void",
    "signature": "public void execute(Runnable task, long startTimeout)",
    "source_code": "\tpublic void execute(Runnable task, long startTimeout) {\n\t\texecute(task);\n\t}"
  },
  "org.springframework.http.HttpMethod#resolve(method)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the given method value to an {@code HttpMethod}.\n\t * @param method the method value as a String\n\t * @return the corresponding {@code HttpMethod}, or {@code null} if not found\n\t * @since 4.2.4\n\t * @deprecated in favor of {@link #valueOf(String)}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "HttpMethod",
    "signature": "public HttpMethod resolve(@Nullable String method)",
    "source_code": "\tpublic static HttpMethod resolve(@Nullable String method) {\n\t\treturn (method != null ? valueOf(method) : null);\n\t}"
  },
  "org.springframework.http.client.HttpComponentsClientHttpRequestFactory#setReadTimeout(timeout)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * As of version 6.0, setting this property has no effect.\n\t * <p>To change the socket read timeout, use {@link SocketConfig.Builder#setSoTimeout(Timeout)},\n\t * supply the resulting {@link SocketConfig} to\n\t * {@link org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManagerBuilder#setDefaultSocketConfig(SocketConfig)},\n\t * use the resulting connection manager for\n\t * {@link org.apache.hc.client5.http.impl.classic.HttpClientBuilder#setConnectionManager(HttpClientConnectionManager)},\n\t * and supply the built {@link HttpClient} to {@link #HttpComponentsClientHttpRequestFactory(HttpClient)}.\n\t * @deprecated as of 6.0, in favor of {@link SocketConfig.Builder#setSoTimeout(Timeout)}, see above.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "void",
    "signature": "public void setReadTimeout(int timeout)",
    "source_code": "\tpublic void setReadTimeout(int timeout) {\n\t\tlogger.warn(\"HttpComponentsClientHttpRequestFactory.setReadTimeout has no effect\");\n\t}"
  },
  "org.springframework.http.client.JettyHeadersAdapter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code MultiValueMap} implementation for wrapping Jetty HTTP headers.\n *\n * <p>There is a duplicate of this class in the server package!\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 5.3\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "signature": "public class JettyHeadersAdapter",
    "source_code": "public final class JettyHeadersAdapter implements MultiValueMap<String, String> {\n\n\tprivate final HttpFields headers;\n\n\tprivate static final String IMMUTABLE_HEADER_ERROR = \"Immutable headers\";\n\n\n\t/**\n\t * Creates a new {@code JettyHeadersAdapter} based on the given\n\t * {@code HttpFields} instance.\n\t * @param headers the {@code HttpFields} to base this adapter on\n\t */\n\tpublic JettyHeadersAdapter(HttpFields headers) {\n\t\tAssert.notNull(headers, \"Headers must not be null\");\n\t\tthis.headers = headers;\n\t}\n\n\n\t@Override\n\tpublic String getFirst(String key) {\n\t\treturn this.headers.get(key);\n\t}\n\n\t@Override\n\tpublic void add(String key, @Nullable String value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tmutableHttpFields.add(key, value);\n\t}\n\n\t@Override\n\tpublic void addAll(String key, List<? extends String> values) {\n\t\tvalues.forEach(value -> add(key, value));\n\t}\n\n\t@Override\n\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this::addAll);\n\t}\n\n\t@Override\n\tpublic void set(String key, @Nullable String value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tmutableHttpFields.put(key, value);\n\t}\n\n\t@Override\n\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this::set);\n\t}\n\n\t@Override\n\tpublic Map<String, String> toSingleValueMap() {\n\t\tMap<String, String> singleValueMap = CollectionUtils.newLinkedHashMap(this.headers.size());\n\t\tIterator<HttpField> iterator = this.headers.iterator();\n\t\titerator.forEachRemaining(field -> {\n\t\t\tif (!singleValueMap.containsKey(field.getName())) {\n\t\t\t\tsingleValueMap.put(field.getName(), field.getValue());\n\t\t\t}\n\t\t});\n\t\treturn singleValueMap;\n\t}\n\n\t@Override\n\tpublic int size() {\n\t\treturn this.headers.getFieldNamesCollection().size();\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn (this.headers.size() == 0);\n\t}\n\n\t@Override\n\tpublic boolean containsKey(Object key) {\n\t\treturn (key instanceof String headerName && this.headers.contains(headerName));\n\t}\n\n\t@Override\n\tpublic boolean containsValue(Object value) {\n\t\treturn (value instanceof String searchString &&\n\t\t\t\tthis.headers.stream().anyMatch(field -> field.contains(searchString)));\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> get(Object key) {\n\t\tif (containsKey(key)) {\n\t\t\treturn this.headers.getValuesList((String) key);\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> put(String key, List<String> value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tList<String> oldValues = get(key);\n\t\tmutableHttpFields.put(key, value);\n\t\treturn oldValues;\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> remove(Object key) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tif (key instanceof String name) {\n\t\t\tList<String> oldValues = get(key);\n\t\t\tmutableHttpFields.remove(name);\n\t\t\treturn oldValues;\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this::put);\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tmutableHttpFields.clear();\n\t}\n\n\t@Override\n\tpublic Set<String> keySet() {\n\t\treturn new HeaderNames();\n\t}\n\n\t@Override\n\tpublic Collection<List<String>> values() {\n\t\treturn this.headers.getFieldNamesCollection().stream()\n\t\t\t\t.map(this.headers::getValuesList).toList();\n\t}\n\n\t@Override\n\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn new AbstractSet<>() {\n\t\t\t@Override\n\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn headers.size();\n\t\t\t}\n\t\t};\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn HttpHeaders.formatHeaders(this);\n\t}\n\n\n\tprivate class EntryIterator implements Iterator<Entry<String, List<String>>> {\n\n\t\tprivate final Iterator<String> names = headers.getFieldNamesCollection().iterator();\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn this.names.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic Entry<String, List<String>> next() {\n\t\t\treturn new HeaderEntry(this.names.next());\n\t\t}\n\t}\n\n\n\tprivate class HeaderEntry implements Entry<String, List<String>> {\n\n\t\tprivate final String key;\n\n\t\tHeaderEntry(String key) {\n\t\t\tthis.key = key;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getKey() {\n\t\t\treturn this.key;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> getValue() {\n\t\t\treturn headers.getValuesList(this.key);\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> setValue(List<String> value) {\n\t\t\tif (!(headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t\t}\n\t\t\tList<String> previousValues = headers.getValuesList(this.key);\n\t\t\tmutableHttpFields.put(this.key, value);\n\t\t\treturn previousValues;\n\t\t}\n\t}\n\n\n\tprivate class HeaderNames extends AbstractSet<String> {\n\n\t\t@Override\n\t\tpublic Iterator<String> iterator() {\n\t\t\treturn new HeaderNamesIterator(headers.getFieldNamesCollection().iterator());\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn headers.getFieldNamesCollection().size();\n\t\t}\n\t}\n\n\n\tprivate final class HeaderNamesIterator implements Iterator<String> {\n\n\t\tprivate final Iterator<String> iterator;\n\n\t\t@Nullable\n\t\tprivate String currentName;\n\n\t\tprivate HeaderNamesIterator(Iterator<String> iterator) {\n\t\t\tthis.iterator = iterator;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn this.iterator.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic String next() {\n\t\t\tthis.currentName = this.iterator.next();\n\t\t\treturn this.currentName;\n\t\t}\n\n\t\t@Override\n\t\tpublic void remove() {\n\t\t\tif (!(headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t\t}\n\t\t\tif (this.currentName == null) {\n\t\t\t\tthrow new IllegalStateException(\"No current Header in iterator\");\n\t\t\t}\n\t\t\tif (!headers.contains(this.currentName)) {\n\t\t\t\tthrow new IllegalStateException(\"Header not present: \" + this.currentName);\n\t\t\t}\n\t\t\tmutableHttpFields.remove(this.currentName);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.http.client.JettyHeadersAdapter#add(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "public void add(String key, @Nullable String value)",
    "source_code": "\tpublic void add(String key, @Nullable String value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tmutableHttpFields.add(key, value);\n\t}"
  },
  "org.springframework.http.client.JettyHeadersAdapter#addAll(MultiValueMap<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this::addAll);\n\t}"
  },
  "org.springframework.http.client.JettyHeadersAdapter#addAll(key,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "void",
    "signature": "public void addAll(String key, List<? extends String> values)",
    "source_code": "\tpublic void addAll(String key, List<? extends String> values) {\n\t\tvalues.forEach(value -> add(key, value));\n\t}"
  },
  "org.springframework.http.client.JettyHeadersAdapter#clear()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\tpublic void clear() {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tmutableHttpFields.clear();\n\t}"
  },
  "org.springframework.http.client.JettyHeadersAdapter#containsKey(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "boolean",
    "signature": "public boolean containsKey(Object key)",
    "source_code": "\tpublic boolean containsKey(Object key) {\n\t\treturn (key instanceof String headerName && this.headers.contains(headerName));\n\t}"
  },
  "org.springframework.http.client.JettyHeadersAdapter#containsValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "boolean",
    "signature": "public boolean containsValue(Object value)",
    "source_code": "\tpublic boolean containsValue(Object value) {\n\t\treturn (value instanceof String searchString &&\n\t\t\t\tthis.headers.stream().anyMatch(field -> field.contains(searchString)));\n\t}"
  },
  "org.springframework.http.client.JettyHeadersAdapter#entrySet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "List<String>>>",
    "signature": "public List<String>>> entrySet()",
    "source_code": "\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn new AbstractSet<>() {\n\t\t\t@Override\n\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn headers.size();\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.http.client.JettyHeadersAdapter#get(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "List<String>",
    "signature": "public List<String> get(Object key)",
    "source_code": "\tpublic List<String> get(Object key) {\n\t\tif (containsKey(key)) {\n\t\t\treturn this.headers.getValuesList((String) key);\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.client.JettyHeadersAdapter#getFirst(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "String",
    "signature": "public String getFirst(String key)",
    "source_code": "\tpublic String getFirst(String key) {\n\t\treturn this.headers.get(key);\n\t}"
  },
  "org.springframework.http.client.JettyHeadersAdapter#getKey()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "String",
    "signature": "public String getKey()",
    "source_code": "\t\tpublic String getKey() {\n\t\t\treturn this.key;\n\t\t}"
  },
  "org.springframework.http.client.JettyHeadersAdapter#getValue()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "List<String>",
    "signature": "public List<String> getValue()",
    "source_code": "\t\tpublic List<String> getValue() {\n\t\t\treturn headers.getValuesList(this.key);\n\t\t}"
  },
  "org.springframework.http.client.JettyHeadersAdapter#hasNext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 283
    },
    "return": "boolean",
    "signature": "public boolean hasNext()",
    "source_code": "\t\tpublic boolean hasNext() {\n\t\t\treturn this.iterator.hasNext();\n\t\t}"
  },
  "org.springframework.http.client.JettyHeadersAdapter#isEmpty()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "boolean",
    "signature": "public boolean isEmpty()",
    "source_code": "\tpublic boolean isEmpty() {\n\t\treturn (this.headers.size() == 0);\n\t}"
  },
  "org.springframework.http.client.JettyHeadersAdapter#iterator()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "Iterator<String>",
    "signature": "public Iterator<String> iterator()",
    "source_code": "\t\tpublic Iterator<String> iterator() {\n\t\t\treturn new HeaderNamesIterator(headers.getFieldNamesCollection().iterator());\n\t\t}"
  },
  "org.springframework.http.client.JettyHeadersAdapter#keySet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "Set<String>",
    "signature": "public Set<String> keySet()",
    "source_code": "\tpublic Set<String> keySet() {\n\t\treturn new HeaderNames();\n\t}"
  },
  "org.springframework.http.client.JettyHeadersAdapter#next()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "String",
    "signature": "public String next()",
    "source_code": "\t\tpublic String next() {\n\t\t\tthis.currentName = this.iterator.next();\n\t\t\treturn this.currentName;\n\t\t}"
  },
  "org.springframework.http.client.JettyHeadersAdapter#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> value)",
    "source_code": "\tpublic List<String> put(String key, List<String> value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tList<String> oldValues = get(key);\n\t\tmutableHttpFields.put(key, value);\n\t\treturn oldValues;\n\t}"
  },
  "org.springframework.http.client.JettyHeadersAdapter#putAll(String,map)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this::put);\n\t}"
  },
  "org.springframework.http.client.JettyHeadersAdapter#remove()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 294
    },
    "return": "void",
    "signature": "public void remove()",
    "source_code": "\t\tpublic void remove() {\n\t\t\tif (!(headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t\t}\n\t\t\tif (this.currentName == null) {\n\t\t\t\tthrow new IllegalStateException(\"No current Header in iterator\");\n\t\t\t}\n\t\t\tif (!headers.contains(this.currentName)) {\n\t\t\t\tthrow new IllegalStateException(\"Header not present: \" + this.currentName);\n\t\t\t}\n\t\t\tmutableHttpFields.remove(this.currentName);\n\t\t}"
  },
  "org.springframework.http.client.JettyHeadersAdapter#remove(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "List<String>",
    "signature": "public List<String> remove(Object key)",
    "source_code": "\tpublic List<String> remove(Object key) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tif (key instanceof String name) {\n\t\t\tList<String> oldValues = get(key);\n\t\t\tmutableHttpFields.remove(name);\n\t\t\treturn oldValues;\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.client.JettyHeadersAdapter#set(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "void",
    "signature": "public void set(String key, @Nullable String value)",
    "source_code": "\tpublic void set(String key, @Nullable String value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tmutableHttpFields.put(key, value);\n\t}"
  },
  "org.springframework.http.client.JettyHeadersAdapter#setAll(Map<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this::set);\n\t}"
  },
  "org.springframework.http.client.JettyHeadersAdapter#setValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "List<String>",
    "signature": "public List<String> setValue(List<String> value)",
    "source_code": "\t\tpublic List<String> setValue(List<String> value) {\n\t\t\tif (!(headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t\t}\n\t\t\tList<String> previousValues = headers.getValuesList(this.key);\n\t\t\tmutableHttpFields.put(this.key, value);\n\t\t\treturn previousValues;\n\t\t}"
  },
  "org.springframework.http.client.JettyHeadersAdapter#size()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 265
    },
    "return": "int",
    "signature": "public int size()",
    "source_code": "\t\tpublic int size() {\n\t\t\treturn headers.getFieldNamesCollection().size();\n\t\t}"
  },
  "org.springframework.http.client.JettyHeadersAdapter#toSingleValueMap()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "String>",
    "signature": "public String> toSingleValueMap()",
    "source_code": "\tpublic Map<String, String> toSingleValueMap() {\n\t\tMap<String, String> singleValueMap = CollectionUtils.newLinkedHashMap(this.headers.size());\n\t\tIterator<HttpField> iterator = this.headers.iterator();\n\t\titerator.forEachRemaining(field -> {\n\t\t\tif (!singleValueMap.containsKey(field.getName())) {\n\t\t\t\tsingleValueMap.put(field.getName(), field.getValue());\n\t\t\t}\n\t\t});\n\t\treturn singleValueMap;\n\t}"
  },
  "org.springframework.http.client.JettyHeadersAdapter#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn HttpHeaders.formatHeaders(this);\n\t}"
  },
  "org.springframework.http.client.JettyHeadersAdapter#values()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "Collection<List<String>>",
    "signature": "public Collection<List<String>> values()",
    "source_code": "\tpublic Collection<List<String>> values() {\n\t\treturn this.headers.getFieldNamesCollection().stream()\n\t\t\t\t.map(this.headers::getValuesList).toList();\n\t}"
  },
  "org.springframework.http.codec.xml.Jaxb2XmlEncoder": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Encode from single value to a byte stream containing XML elements.\n *\n * <p>{@link jakarta.xml.bind.annotation.XmlElements @XmlElements} and\n * {@link jakarta.xml.bind.annotation.XmlElement @XmlElement} can be used\n * to specify how collections should be marshalled.\n *\n * @author Sebastien Deleuze\n * @author Arjen Poutsma\n * @since 5.0\n * @see Jaxb2XmlDecoder\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "signature": "public class Jaxb2XmlEncoder",
    "source_code": "public class Jaxb2XmlEncoder extends AbstractSingleValueEncoder<Object> {\n\n\tprivate final JaxbContextContainer jaxbContexts = new JaxbContextContainer();\n\n\tprivate Function<Marshaller, Marshaller> marshallerProcessor = Function.identity();\n\n\n\tpublic Jaxb2XmlEncoder() {\n\t\tsuper(MimeTypeUtils.APPLICATION_XML, MimeTypeUtils.TEXT_XML, new MediaType(\"application\", \"*+xml\"));\n\t}\n\n\n\t/**\n\t * Configure a processor function to customize Marshaller instances.\n\t * @param processor the function to use\n\t * @since 5.1.3\n\t */\n\tpublic void setMarshallerProcessor(Function<Marshaller, Marshaller> processor) {\n\t\tthis.marshallerProcessor = this.marshallerProcessor.andThen(processor);\n\t}\n\n\t/**\n\t * Return the configured processor for customizing Marshaller instances.\n\t * @since 5.1.3\n\t */\n\tpublic Function<Marshaller, Marshaller> getMarshallerProcessor() {\n\t\treturn this.marshallerProcessor;\n\t}\n\n\n\t@Override\n\tpublic boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType) {\n\t\tif (super.canEncode(elementType, mimeType)) {\n\t\t\tClass<?> outputClass = elementType.toClass();\n\t\t\treturn (outputClass.isAnnotationPresent(XmlRootElement.class) ||\n\t\t\t\t\toutputClass.isAnnotationPresent(XmlType.class));\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Override\n\tprotected Flux<DataBuffer> encode(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\t// we're relying on doOnDiscard in base class\n\t\treturn Mono.fromCallable(() -> encodeValue(value, bufferFactory, valueType, mimeType, hints)).flux();\n\t}\n\n\t@Override\n\tpublic DataBuffer encodeValue(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tif (!Hints.isLoggingSuppressed(hints)) {\n\t\t\tLogFormatUtils.traceDebug(logger, traceOn -> {\n\t\t\t\tString formatted = LogFormatUtils.formatValue(value, !traceOn);\n\t\t\t\treturn Hints.getLogPrefix(hints) + \"Encoding [\" + formatted + \"]\";\n\t\t\t});\n\t\t}\n\n\t\tboolean release = true;\n\t\tDataBuffer buffer = bufferFactory.allocateBuffer(1024);\n\t\ttry {\n\t\t\tOutputStream outputStream = buffer.asOutputStream();\n\t\t\tClass<?> clazz = getMarshallerType(value);\n\t\t\tMarshaller marshaller = initMarshaller(clazz);\n\t\t\tmarshaller.marshal(value, outputStream);\n\t\t\trelease = false;\n\t\t\treturn buffer;\n\t\t}\n\t\tcatch (MarshalException ex) {\n\t\t\tthrow new EncodingException(\"Could not marshal \" + value.getClass() + \" to XML\", ex);\n\t\t}\n\t\tcatch (JAXBException ex) {\n\t\t\tthrow new CodecException(\"Invalid JAXB configuration\", ex);\n\t\t}\n\t\tfinally {\n\t\t\tif (release) {\n\t\t\t\tDataBufferUtils.release(buffer);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static Class<?> getMarshallerType(Object value) {\n\t\tif (value instanceof JAXBElement<?> jaxbElement) {\n\t\t\treturn jaxbElement.getDeclaredType();\n\t\t}\n\t\telse {\n\t\t\treturn ClassUtils.getUserClass(value);\n\t\t}\n\t}\n\n\tprivate Marshaller initMarshaller(Class<?> clazz) throws CodecException, JAXBException {\n\t\tMarshaller marshaller = this.jaxbContexts.createMarshaller(clazz);\n\t\tmarshaller.setProperty(Marshaller.JAXB_ENCODING, StandardCharsets.UTF_8.name());\n\t\tmarshaller = this.marshallerProcessor.apply(marshaller);\n\t\treturn marshaller;\n\t}\n\n}"
  },
  "org.springframework.http.codec.xml.Jaxb2XmlEncoder#canEncode(elementType,mimeType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "boolean",
    "signature": "public boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType)",
    "source_code": "\tpublic boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType) {\n\t\tif (super.canEncode(elementType, mimeType)) {\n\t\t\tClass<?> outputClass = elementType.toClass();\n\t\t\treturn (outputClass.isAnnotationPresent(XmlRootElement.class) ||\n\t\t\t\t\toutputClass.isAnnotationPresent(XmlType.class));\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.xml.Jaxb2XmlEncoder#encode(value,bufferFactory,valueType,mimeType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "bufferFactory",
      "valueType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "Flux<DataBuffer>",
    "signature": "protected Flux<DataBuffer> encode(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tprotected Flux<DataBuffer> encode(Object value, DataBufferFactory bufferFactory,"
  },
  "org.springframework.http.codec.xml.Jaxb2XmlEncoder#encodeValue(value,bufferFactory,valueType,mimeType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "bufferFactory",
      "valueType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer encodeValue(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic DataBuffer encodeValue(Object value, DataBufferFactory bufferFactory,"
  },
  "org.springframework.http.codec.xml.Jaxb2XmlEncoder#getMarshallerProcessor()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured processor for customizing Marshaller instances.\n\t * @since 5.1.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "Marshaller>",
    "signature": "public Marshaller> getMarshallerProcessor()",
    "source_code": "\tpublic Function<Marshaller, Marshaller> getMarshallerProcessor() {\n\t\treturn this.marshallerProcessor;\n\t}"
  },
  "org.springframework.http.codec.xml.Jaxb2XmlEncoder#setMarshallerProcessor(Function<Marshaller,processor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a processor function to customize Marshaller instances.\n\t * @param processor the function to use\n\t * @since 5.1.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<Marshaller",
      "processor"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "void",
    "signature": "public void setMarshallerProcessor(Function<Marshaller, Marshaller> processor)",
    "source_code": "\tpublic void setMarshallerProcessor(Function<Marshaller, Marshaller> processor) {\n\t\tthis.marshallerProcessor = this.marshallerProcessor.andThen(processor);\n\t}"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils#containsSqlScriptDelimiters(script,delimiter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the provided SQL script contains the specified delimiter.\n\t * <p>This method is intended to be used to find the string delimiting each\n\t * SQL statement &mdash; for example, a ';' character.\n\t * <p>Any occurrence of the delimiter within the script will be ignored if it\n\t * is within a <em>literal</em> block of text enclosed in single quotes\n\t * ({@code '}) or double quotes ({@code \"}), if it is escaped with a backslash\n\t * ({@code \\}), or if it is within a single-line comment or block comment.\n\t * @param script the SQL script to search within\n\t * @param delimiter the statement delimiter to search for\n\t * @see #DEFAULT_COMMENT_PREFIXES\n\t * @see #DEFAULT_BLOCK_COMMENT_START_DELIMITER\n\t * @see #DEFAULT_BLOCK_COMMENT_END_DELIMITER\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "script",
      "delimiter"
    ],
    "position": {
      "column": 1,
      "line": 430
    },
    "return": "boolean",
    "signature": "public boolean containsSqlScriptDelimiters(String script, String delimiter)",
    "source_code": "\tpublic static boolean containsSqlScriptDelimiters(String script, String delimiter) {\n\t\treturn containsStatementSeparator(null, script, delimiter, DEFAULT_COMMENT_PREFIXES,\n\t\t\tDEFAULT_BLOCK_COMMENT_START_DELIMITER, DEFAULT_BLOCK_COMMENT_END_DELIMITER);\n\t}"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils#readScript(lineNumberReader,commentPrefix,separator,blockCommentEndDelimiter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Read a script from the provided {@code LineNumberReader}, using the supplied\n\t * comment prefix and statement separator, and build a {@code String} containing\n\t * the lines.\n\t * <p>Lines <em>beginning</em> with the comment prefix are excluded from the\n\t * results; however, line comments anywhere else &mdash; for example, within\n\t * a statement &mdash; will be included in the results.\n\t * @param lineNumberReader the {@code LineNumberReader} containing the script\n\t * to be processed\n\t * @param commentPrefix the prefix that identifies comments in the SQL script\n\t * (typically \"--\")\n\t * @param separator the statement separator in the SQL script (typically \";\")\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter\n\t * @return a {@code String} containing the script lines\n\t * @throws IOException in case of I/O errors\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lineNumberReader",
      "commentPrefix",
      "separator",
      "blockCommentEndDelimiter"
    ],
    "position": {
      "column": 1,
      "line": 352
    },
    "return": "String",
    "signature": "public String readScript(LineNumberReader lineNumberReader, @Nullable String commentPrefix,\n\t\t\t@Nullable String separator, @Nullable String blockCommentEndDelimiter)",
    "source_code": "\tpublic static String readScript(LineNumberReader lineNumberReader, @Nullable String commentPrefix,"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils#readScript(lineNumberReader,commentPrefixes,separator,blockCommentEndDelimiter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Read a script from the provided {@code LineNumberReader}, using the supplied\n\t * comment prefixes and statement separator, and build a {@code String} containing\n\t * the lines.\n\t * <p>Lines <em>beginning</em> with one of the comment prefixes are excluded\n\t * from the results; however, line comments anywhere else &mdash; for example,\n\t * within a statement &mdash; will be included in the results.\n\t * @param lineNumberReader the {@code LineNumberReader} containing the script\n\t * to be processed\n\t * @param commentPrefixes the prefixes that identify comments in the SQL script\n\t * (typically \"--\")\n\t * @param separator the statement separator in the SQL script (typically \";\")\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter\n\t * @return a {@code String} containing the script lines\n\t * @throws IOException in case of I/O errors\n\t * @since 5.2\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lineNumberReader",
      "commentPrefixes",
      "separator",
      "blockCommentEndDelimiter"
    ],
    "position": {
      "column": 1,
      "line": 379
    },
    "return": "String",
    "signature": "public String readScript(LineNumberReader lineNumberReader, @Nullable String[] commentPrefixes,\n\t\t\t@Nullable String separator, @Nullable String blockCommentEndDelimiter)",
    "source_code": "\tpublic static String readScript(LineNumberReader lineNumberReader, @Nullable String[] commentPrefixes,"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils#splitSqlScript(resource,script,separator,commentPrefix,blockCommentStartDelimiter,blockCommentEndDelimiter,statements)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Split an SQL script into separate statements delimited by the provided\n\t * separator string. Each individual statement will be added to the provided\n\t * {@code List}.\n\t * <p>Within the script, the provided {@code commentPrefix} will be honored:\n\t * any text beginning with the comment prefix and extending to the end of the\n\t * line will be omitted from the output. Similarly, the provided\n\t * {@code blockCommentStartDelimiter} and {@code blockCommentEndDelimiter}\n\t * delimiters will be honored: any text enclosed in a block comment will be\n\t * omitted from the output. In addition, multiple adjacent whitespace characters\n\t * will be collapsed into a single space.\n\t * @param resource the resource from which the script was read\n\t * @param script the SQL script\n\t * @param separator text separating each statement\n\t * (typically a ';' or newline character)\n\t * @param commentPrefix the prefix that identifies SQL line comments\n\t * (typically \"--\")\n\t * @param blockCommentStartDelimiter the <em>start</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param statements the list that will contain the individual statements\n\t * @throws ScriptException if an error occurred while splitting the SQL script\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resource",
      "script",
      "separator",
      "commentPrefix",
      "blockCommentStartDelimiter",
      "blockCommentEndDelimiter",
      "statements"
    ],
    "position": {
      "column": 1,
      "line": 595
    },
    "return": "void",
    "signature": "public void splitSqlScript(@Nullable EncodedResource resource, String script,\n\t\t\tString separator, String commentPrefix, String blockCommentStartDelimiter,\n\t\t\tString blockCommentEndDelimiter, List<String> statements)",
    "source_code": "\tpublic static void splitSqlScript(@Nullable EncodedResource resource, String script,"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils#splitSqlScript(resource,script,separator,commentPrefixes,blockCommentStartDelimiter,blockCommentEndDelimiter,statements)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Split an SQL script into separate statements delimited by the provided\n\t * separator string. Each individual statement will be added to the provided\n\t * {@code List}.\n\t * <p>Within the script, the provided {@code commentPrefixes} will be honored:\n\t * any text beginning with one of the comment prefixes and extending to the\n\t * end of the line will be omitted from the output. Similarly, the provided\n\t * {@code blockCommentStartDelimiter} and {@code blockCommentEndDelimiter}\n\t * delimiters will be honored: any text enclosed in a block comment will be\n\t * omitted from the output. In addition, multiple adjacent whitespace characters\n\t * will be collapsed into a single space.\n\t * @param resource the resource from which the script was read\n\t * @param script the SQL script\n\t * @param separator text separating each statement\n\t * (typically a ';' or newline character)\n\t * @param commentPrefixes the prefixes that identify SQL line comments\n\t * (typically \"--\")\n\t * @param blockCommentStartDelimiter the <em>start</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param statements the list that will contain the individual statements\n\t * @throws ScriptException if an error occurred while splitting the SQL script\n\t * @since 5.2\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resource",
      "script",
      "separator",
      "commentPrefixes",
      "blockCommentStartDelimiter",
      "blockCommentEndDelimiter",
      "statements"
    ],
    "position": {
      "column": 1,
      "line": 632
    },
    "return": "void",
    "signature": "public void splitSqlScript(@Nullable EncodedResource resource, String script,\n\t\t\tString separator, String[] commentPrefixes, String blockCommentStartDelimiter,\n\t\t\tString blockCommentEndDelimiter, List<String> statements)",
    "source_code": "\tpublic static void splitSqlScript(@Nullable EncodedResource resource, String script,"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils#splitSqlScript(script,separator,statements)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Split an SQL script into separate statements delimited by the provided\n\t * separator string. Each individual statement will be added to the\n\t * provided {@code List}.\n\t * <p>Within the script, {@value #DEFAULT_COMMENT_PREFIX} will be used as the\n\t * comment prefix; any text beginning with the comment prefix and extending to\n\t * the end of the line will be omitted from the output. Similarly,\n\t * {@value #DEFAULT_BLOCK_COMMENT_START_DELIMITER} and\n\t * {@value #DEFAULT_BLOCK_COMMENT_END_DELIMITER} will be used as the\n\t * <em>start</em> and <em>end</em> block comment delimiters: any text enclosed\n\t * in a block comment will be omitted from the output. In addition, multiple\n\t * adjacent whitespace characters will be collapsed into a single space.\n\t * @param script the SQL script\n\t * @param separator text separating each statement\n\t * (typically a ';' or newline character)\n\t * @param statements the list that will contain the individual statements\n\t * @throws ScriptException if an error occurred while splitting the SQL script\n\t * @see #splitSqlScript(String, char, List)\n\t * @see #splitSqlScript(EncodedResource, String, String, String, String, String, List)\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "script",
      "separator",
      "statements"
    ],
    "position": {
      "column": 1,
      "line": 563
    },
    "return": "void",
    "signature": "public void splitSqlScript(String script, String separator, List<String> statements)",
    "source_code": "\tpublic static void splitSqlScript(String script, String separator, List<String> statements) throws ScriptException {\n\t\tsplitSqlScript(null, script, separator, DEFAULT_COMMENT_PREFIX, DEFAULT_BLOCK_COMMENT_START_DELIMITER,\n\t\t\t\tDEFAULT_BLOCK_COMMENT_END_DELIMITER, statements);\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#isRunning()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether there is currently an underlying connection.\n\t * @since 6.1\n\t * @see #start()\n\t * @see #stop()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 388
    },
    "return": "boolean",
    "signature": "public boolean isRunning()",
    "source_code": "\tpublic boolean isRunning() {\n\t\tsynchronized (this.connectionMonitor) {\n\t\t\treturn (this.connection != null);\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#start()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the underlying shared connection on start.\n\t * @since 6.1\n\t * @see #initConnection()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 362
    },
    "return": "void",
    "signature": "public void start()",
    "source_code": "\tpublic void start() {\n\t\ttry {\n\t\t\tinitConnection();\n\t\t}\n\t\tcatch (JMSException ex) {\n\t\t\tlogger.info(\"Start attempt failed for shared JMS Connection\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#stop()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Reset the underlying shared connection on stop.\n\t * @since 6.1\n\t * @see #resetConnection()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 377
    },
    "return": "void",
    "signature": "public void stop()",
    "source_code": "\tpublic void stop() {\n\t\tresetConnection();\n\t}"
  },
  "org.springframework.mock.http.client.MockClientHttpResponse#getRawStatusCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "int",
    "signature": "public int getRawStatusCode()",
    "source_code": "\tpublic int getRawStatusCode() {\n\t\treturn this.statusCode.value();\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "signature": "public class BeanPropertyRowMapper",
    "source_code": "public class BeanPropertyRowMapper<T> implements Function<Readable, T> {\n\n\t/** Logger available to subclasses. */\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\t/** The class we are mapping to. */\n\t@Nullable\n\tprivate Class<T> mappedClass;\n\n\t/** Whether we're strictly validating. */\n\tprivate boolean checkFullyPopulated = false;\n\n\t/**\n\t * Whether {@code NULL} database values should be ignored for primitive\n\t * properties in the target class.\n\t * @see #setPrimitivesDefaultedForNullValue(boolean)\n\t */\n\tprivate boolean primitivesDefaultedForNullValue = false;\n\n\t/** ConversionService for binding R2DBC values to bean properties. */\n\t@Nullable\n\tprivate ConversionService conversionService = DefaultConversionService.getSharedInstance();\n\n\t/** Map of the properties we provide mapping for. */\n\t@Nullable\n\tprivate Map<String, PropertyDescriptor> mappedProperties;\n\n\t/** Set of bean property names we provide mapping for. */\n\t@Nullable\n\tprivate Set<String> mappedPropertyNames;\n\n\t/**\n\t * Create a new {@code BeanPropertyRowMapper}, accepting unpopulated\n\t * properties in the target bean.\n\t * @param mappedClass the class that each row/outParameters should be mapped to\n\t */\n\tpublic BeanPropertyRowMapper(Class<T> mappedClass) {\n\t\tinitialize(mappedClass);\n\t}\n\n\t/**\n\t * Create a new {@code BeanPropertyRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t * @param checkFullyPopulated whether we're strictly validating that\n\t * all bean properties have been mapped from corresponding database columns or\n\t * out-parameters\n\t */\n\tpublic BeanPropertyRowMapper(Class<T> mappedClass, boolean checkFullyPopulated) {\n\t\tinitialize(mappedClass);\n\t\tthis.checkFullyPopulated = checkFullyPopulated;\n\t}\n\n\n\t/**\n\t * Get the class that we are mapping to.\n\t */\n\t@Nullable\n\tpublic final Class<T> getMappedClass() {\n\t\treturn this.mappedClass;\n\t}\n\n\t/**\n\t * Set whether we're strictly validating that all bean properties have been mapped\n\t * from corresponding database columns or out-parameters.\n\t * <p>Default is {@code false}, accepting unpopulated properties in the target bean.\n\t */\n\tpublic void setCheckFullyPopulated(boolean checkFullyPopulated) {\n\t\tthis.checkFullyPopulated = checkFullyPopulated;\n\t}\n\n\t/**\n\t * Return whether we're strictly validating that all bean properties have been\n\t * mapped from corresponding database columns or out-parameters.\n\t */\n\tpublic boolean isCheckFullyPopulated() {\n\t\treturn this.checkFullyPopulated;\n\t}\n\n\t/**\n\t * Set whether a {@code NULL} database column or out-parameter value should\n\t * be ignored when mapping to a corresponding primitive property in the target class.\n\t * <p>Default is {@code false}, throwing an exception when nulls are mapped\n\t * to Java primitives.\n\t * <p>If this flag is set to {@code true} and you use an <em>ignored</em>\n\t * primitive property value from the mapped bean to update the database, the\n\t * value in the database will be changed from {@code NULL} to the current value\n\t * of that primitive property. That value may be the property's initial value\n\t * (potentially Java's default value for the respective primitive type), or\n\t * it may be some other value set for the property in the default constructor\n\t * (or initialization block) or as a side effect of setting some other property\n\t * in the mapped bean.\n\t */\n\tpublic void setPrimitivesDefaultedForNullValue(boolean primitivesDefaultedForNullValue) {\n\t\tthis.primitivesDefaultedForNullValue = primitivesDefaultedForNullValue;\n\t}\n\n\t/**\n\t * Get the value of the {@code primitivesDefaultedForNullValue} flag.\n\t * @see #setPrimitivesDefaultedForNullValue(boolean)\n\t */\n\tpublic boolean isPrimitivesDefaultedForNullValue() {\n\t\treturn this.primitivesDefaultedForNullValue;\n\t}\n\n\t/**\n\t * Set a {@link ConversionService} for binding R2DBC values to bean properties,\n\t * or {@code null} for none.\n\t * <p>Default is a {@link DefaultConversionService}. This provides support for\n\t * {@code java.time} conversion and other special types.\n\t * @see #initBeanWrapper(BeanWrapper)\n\t */\n\tpublic void setConversionService(@Nullable ConversionService conversionService) {\n\t\tthis.conversionService = conversionService;\n\t}\n\n\t/**\n\t * Return a {@link ConversionService} for binding R2DBC values to bean properties,\n\t * or {@code null} if none.\n\t */\n\t@Nullable\n\tpublic ConversionService getConversionService() {\n\t\treturn this.conversionService;\n\t}\n\n\n\t/**\n\t * Initialize the mapping meta-data for the given class.\n\t * @param mappedClass the mapped class\n\t */\n\tprotected void initialize(Class<T> mappedClass) {\n\t\tthis.mappedClass = mappedClass;\n\t\tthis.mappedProperties = new HashMap<>();\n\t\tthis.mappedPropertyNames = new HashSet<>();\n\n\t\tfor (PropertyDescriptor pd : BeanUtils.getPropertyDescriptors(mappedClass)) {\n\t\t\tif (pd.getWriteMethod() != null) {\n\t\t\t\tString lowerCaseName = lowerCaseName(pd.getName());\n\t\t\t\tthis.mappedProperties.put(lowerCaseName, pd);\n\t\t\t\tString underscoreName = underscoreName(pd.getName());\n\t\t\t\tif (!lowerCaseName.equals(underscoreName)) {\n\t\t\t\t\tthis.mappedProperties.put(underscoreName, pd);\n\t\t\t\t}\n\t\t\t\tthis.mappedPropertyNames.add(pd.getName());\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Remove the specified property from the mapped properties.\n\t * @param propertyName the property name (as used by property descriptors)\n\t */\n\tprotected void suppressProperty(String propertyName) {\n\t\tif (this.mappedProperties != null) {\n\t\t\tthis.mappedProperties.remove(lowerCaseName(propertyName));\n\t\t\tthis.mappedProperties.remove(underscoreName(propertyName));\n\t\t}\n\t}\n\n\t/**\n\t * Convert the given name to lower case.\n\t * <p>By default, conversions will happen within the US locale.\n\t * @param name the original name\n\t * @return the converted name\n\t */\n\tprotected String lowerCaseName(String name) {\n\t\treturn name.toLowerCase(Locale.US);\n\t}\n\n\t/**\n\t * Convert a name in camelCase to an underscored name in lower case.\n\t * <p>Any upper case letters are converted to lower case with a preceding underscore.\n\t * @param name the original name\n\t * @return the converted name\n\t * @see #lowerCaseName\n\t */\n\tprotected String underscoreName(String name) {\n\t\tif (!StringUtils.hasLength(name)) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tStringBuilder result = new StringBuilder();\n\t\tresult.append(Character.toLowerCase(name.charAt(0)));\n\t\tfor (int i = 1; i < name.length(); i++) {\n\t\t\tchar c = name.charAt(i);\n\t\t\tif (Character.isUpperCase(c)) {\n\t\t\t\tresult.append('_').append(Character.toLowerCase(c));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.append(c);\n\t\t\t}\n\t\t}\n\t\treturn result.toString();\n\t}\n\n\t/**\n\t * Extract the values for the current {@link Readable}: all columns in case\n\t * of a {@link Row} or all parameters in case of an {@link OutParameters}.\n\t * <p>Utilizes public setters and derives meta-data from the concrete type.\n\t * @throws IllegalArgumentException in case the concrete type is neither\n\t * {@code Row} nor {@code OutParameters}\n\t * @see RowMetadata\n\t * @see OutParametersMetadata\n\t */\n\t@Override\n\tpublic T apply(Readable readable) {\n\t\tif (readable instanceof Row row) {\n\t\t\treturn mapForReadable(row, row.getMetadata().getColumnMetadatas());\n\t\t}\n\t\tif (readable instanceof OutParameters out) {\n\t\t\treturn mapForReadable(out, out.getMetadata().getParameterMetadatas());\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Can only map Readable Row or OutParameters, got \" + readable.getClass().getName());\n\t}\n\n\tprivate <R extends Readable> T mapForReadable(R readable, List<? extends ReadableMetadata> readableMetadatas) {\n\t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n\t\tinitBeanWrapper(bw);\n\n\t\tT mappedObject = constructMappedInstance(readable, readableMetadatas, bw);\n\t\tbw.setBeanInstance(mappedObject);\n\n\t\tSet<String> populatedProperties = (isCheckFullyPopulated() ? new HashSet<>() : null);\n\t\tint readableItemCount = readableMetadatas.size();\n\t\tfor(int itemIndex = 0; itemIndex < readableItemCount; itemIndex++) {\n\t\t\tReadableMetadata itemMetadata = readableMetadatas.get(itemIndex);\n\t\t\tString itemName = itemMetadata.getName();\n\t\t\tString property = lowerCaseName(StringUtils.delete(itemName, \" \"));\n\t\t\tPropertyDescriptor pd = (this.mappedProperties != null ? this.mappedProperties.get(property) : null);\n\t\t\tif (pd != null) {\n\t\t\t\tObject value = getItemValue(readable, itemIndex, pd);\n\t\t\t\t// Implementation note: the JDBC mapper can log the column mapping details each time row 0 is encountered\n\t\t\t\t// but unfortunately this is not possible in R2DBC as row number is not provided. The BiFunction#apply\n\t\t\t\t// cannot be stateful as it could be applied to a different row set, e.g. when resubscribing.\n\t\t\t\ttry {\n\t\t\t\t\tbw.setPropertyValue(pd.getName(), value);\n\t\t\t\t}\n\t\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\t\tif (value == null && this.primitivesDefaultedForNullValue) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tString propertyType = ClassUtils.getQualifiedName(pd.getPropertyType());\n\t\t\t\t\t\t\t//here too, we miss the rowNumber information\n\t\t\t\t\t\t\tlogger.debug(\"\"\"\n\t\t\t\t\t\t\t\t\t\tIgnoring intercepted TypeMismatchException for item '%s' \\\n\t\t\t\t\t\t\t\t\t\twith null value when setting property '%s' of type '%s' on object: %s\"\n\t\t\t\t\t\t\t\t\t\t\"\"\".formatted(itemName, pd.getName(), propertyType, mappedObject), ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (populatedProperties != null) {\n\t\t\t\t\tpopulatedProperties.add(pd.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (populatedProperties != null && !populatedProperties.equals(this.mappedPropertyNames)) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\"Given readable does not contain all items \" +\n\t\t\t\t\t\"necessary to populate object of \" + this.mappedClass + \": \" + this.mappedPropertyNames);\n\t\t}\n\n\t\treturn mappedObject;\n\t}\n\n\t/**\n\t * Construct an instance of the mapped class for the current {@code Readable}.\n\t * <p>The default implementation simply instantiates the mapped class. Can be\n\t * overridden in subclasses.\n\t * @param readable the {@code Readable} being mapped (a {@code Row} or {@code OutParameters})\n\t * @param itemMetadatas the list of item {@code ReadableMetadata} (either\n\t * {@code ColumnMetadata} or {@code OutParameterMetadata})\n\t * @param tc a TypeConverter with this row mapper's conversion service\n\t * @return a corresponding instance of the mapped class\n\t */\n\tprotected T constructMappedInstance(Readable readable, List<? extends ReadableMetadata> itemMetadatas, TypeConverter tc) {\n\t\tAssert.state(this.mappedClass != null, \"Mapped class was not specified\");\n\t\treturn BeanUtils.instantiateClass(this.mappedClass);\n\t}\n\n\t/**\n\t * Initialize the given BeanWrapper to be used for row mapping or outParameters\n\t * mapping.\n\t * <p>To be called for each Readable.\n\t * <p>The default implementation applies the configured {@link ConversionService},\n\t * if any. Can be overridden in subclasses.\n\t * @param bw the BeanWrapper to initialize\n\t * @see #getConversionService()\n\t * @see BeanWrapper#setConversionService\n\t */\n\tprotected void initBeanWrapper(BeanWrapper bw) {\n\t\tConversionService cs = getConversionService();\n\t\tif (cs != null) {\n\t\t\tbw.setConversionService(cs);\n\t\t}\n\t}\n\n\t/**\n\t * Retrieve an R2DBC object value for the specified item index (a column or an\n\t * out-parameter).\n\t * <p>The default implementation delegates to\n\t * {@link #getItemValue(Readable, int, Class)}.\n\t * @param readable is the {@code Row} or {@code OutParameters} holding the data\n\t * @param itemIndex is the column index or out-parameter index\n\t * @param pd the bean property that each result object is expected to match\n\t * @return the Object value\n\t * @see #getItemValue(Readable, int, Class)\n\t */\n\t@Nullable\n\tprotected Object getItemValue(Readable readable, int itemIndex, PropertyDescriptor pd) {\n\t\treturn getItemValue(readable, itemIndex, pd.getPropertyType());\n\t}\n\n\t/**\n\t * Retrieve an R2DBC object value for the specified item index (a column or\n\t * an out-parameter).\n\t * <p>The default implementation calls {@link Readable#get(int, Class)} then\n\t * falls back to {@link Readable#get(int)} in case of an exception.\n\t * Subclasses may override this to check specific value types upfront,\n\t * or to post-process values returned from {@code get}.\n\t * @param readable is the {@code Row} or {@code OutParameters} holding the data\n\t * @param itemIndex is the column index or out-parameter index\n\t * @param paramType the target parameter type\n\t * @return the Object value\n\t * @see Readable#get(int, Class)\n\t * @see Readable#get(int)\n\t */\n\t@Nullable\n\tprotected Object getItemValue(Readable readable, int itemIndex, Class<?> paramType) {\n\t\ttry {\n\t\t\treturn readable.get(itemIndex, paramType);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\treturn readable.get(itemIndex);\n\t\t}\n\t}\n\n\n\t/**\n\t * Static factory method to create a new {@code BeanPropertyRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t * @see #newInstance(Class, ConversionService)\n\t */\n\tpublic static <T> BeanPropertyRowMapper<T> newInstance(Class<T> mappedClass) {\n\t\treturn new BeanPropertyRowMapper<>(mappedClass);\n\t}\n\n\t/**\n\t * Static factory method to create a new {@code BeanPropertyRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t * @param conversionService the {@link ConversionService} for binding\n\t * R2DBC values to bean properties, or {@code null} for none\n\t * @see #newInstance(Class)\n\t * @see #setConversionService\n\t */\n\tpublic static <T> BeanPropertyRowMapper<T> newInstance(\n\t\t\tClass<T> mappedClass, @Nullable ConversionService conversionService) {\n\n\t\tBeanPropertyRowMapper<T> rowMapper = newInstance(mappedClass);\n\t\trowMapper.setConversionService(conversionService);\n\t\treturn rowMapper;\n\t}\n\n}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#apply(readable)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extract the values for the current {@link Readable}: all columns in case\n\t * of a {@link Row} or all parameters in case of an {@link OutParameters}.\n\t * <p>Utilizes public setters and derives meta-data from the concrete type.\n\t * @throws IllegalArgumentException in case the concrete type is neither\n\t * {@code Row} nor {@code OutParameters}\n\t * @see RowMetadata\n\t * @see OutParametersMetadata\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "readable"
    ],
    "position": {
      "column": 1,
      "line": 300
    },
    "return": "T",
    "signature": "public T apply(Readable readable)",
    "source_code": "\tpublic T apply(Readable readable) {\n\t\tif (readable instanceof Row row) {\n\t\t\treturn mapForReadable(row, row.getMetadata().getColumnMetadatas());\n\t\t}\n\t\tif (readable instanceof OutParameters out) {\n\t\t\treturn mapForReadable(out, out.getMetadata().getParameterMetadatas());\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Can only map Readable Row or OutParameters, got \" + readable.getClass().getName());\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#constructMappedInstance(readable,itemMetadatas,tc)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Construct an instance of the mapped class for the current {@code Readable}.\n\t * <p>The default implementation simply instantiates the mapped class. Can be\n\t * overridden in subclasses.\n\t * @param readable the {@code Readable} being mapped (a {@code Row} or {@code OutParameters})\n\t * @param itemMetadatas the list of item {@code ReadableMetadata} (either\n\t * {@code ColumnMetadata} or {@code OutParameterMetadata})\n\t * @param tc a TypeConverter with this row mapper's conversion service\n\t * @return a corresponding instance of the mapped class\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "readable",
      "itemMetadatas",
      "tc"
    ],
    "position": {
      "column": 1,
      "line": 371
    },
    "return": "T",
    "signature": "protected T constructMappedInstance(Readable readable, List<? extends ReadableMetadata> itemMetadatas, TypeConverter tc)",
    "source_code": "\tprotected T constructMappedInstance(Readable readable, List<? extends ReadableMetadata> itemMetadatas, TypeConverter tc) {\n\t\tAssert.state(this.mappedClass != null, \"Mapped class was not specified\");\n\t\treturn BeanUtils.instantiateClass(this.mappedClass);\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#getConversionService()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ConversionService} for binding R2DBC values to bean properties,\n\t * or {@code null} if none.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "ConversionService",
    "signature": "public ConversionService getConversionService()",
    "source_code": "\tpublic ConversionService getConversionService() {\n\t\treturn this.conversionService;\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#getItemValue(readable,itemIndex,paramType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve an R2DBC object value for the specified item index (a column or\n\t * an out-parameter).\n\t * <p>The default implementation calls {@link Readable#get(int, Class)} then\n\t * falls back to {@link Readable#get(int)} in case of an exception.\n\t * Subclasses may override this to check specific value types upfront,\n\t * or to post-process values returned from {@code get}.\n\t * @param readable is the {@code Row} or {@code OutParameters} holding the data\n\t * @param itemIndex is the column index or out-parameter index\n\t * @param paramType the target parameter type\n\t * @return the Object value\n\t * @see Readable#get(int, Class)\n\t * @see Readable#get(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "readable",
      "itemIndex",
      "paramType"
    ],
    "position": {
      "column": 1,
      "line": 424
    },
    "return": "Object",
    "signature": "protected Object getItemValue(Readable readable, int itemIndex, Class<?> paramType)",
    "source_code": "\tprotected Object getItemValue(Readable readable, int itemIndex, Class<?> paramType) {\n\t\ttry {\n\t\t\treturn readable.get(itemIndex, paramType);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\treturn readable.get(itemIndex);\n\t\t}\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#getItemValue(readable,itemIndex,pd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve an R2DBC object value for the specified item index (a column or an\n\t * out-parameter).\n\t * <p>The default implementation delegates to\n\t * {@link #getItemValue(Readable, int, Class)}.\n\t * @param readable is the {@code Row} or {@code OutParameters} holding the data\n\t * @param itemIndex is the column index or out-parameter index\n\t * @param pd the bean property that each result object is expected to match\n\t * @return the Object value\n\t * @see #getItemValue(Readable, int, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "readable",
      "itemIndex",
      "pd"
    ],
    "position": {
      "column": 1,
      "line": 405
    },
    "return": "Object",
    "signature": "protected Object getItemValue(Readable readable, int itemIndex, PropertyDescriptor pd)",
    "source_code": "\tprotected Object getItemValue(Readable readable, int itemIndex, PropertyDescriptor pd) {\n\t\treturn getItemValue(readable, itemIndex, pd.getPropertyType());\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#getMappedClass()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the class that we are mapping to.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "Class<T>",
    "signature": "public Class<T> getMappedClass()",
    "source_code": "\tpublic final Class<T> getMappedClass() {\n\t\treturn this.mappedClass;\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#initBeanWrapper(bw)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the given BeanWrapper to be used for row mapping or outParameters\n\t * mapping.\n\t * <p>To be called for each Readable.\n\t * <p>The default implementation applies the configured {@link ConversionService},\n\t * if any. Can be overridden in subclasses.\n\t * @param bw the BeanWrapper to initialize\n\t * @see #getConversionService()\n\t * @see BeanWrapper#setConversionService\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bw"
    ],
    "position": {
      "column": 1,
      "line": 386
    },
    "return": "void",
    "signature": "protected void initBeanWrapper(BeanWrapper bw)",
    "source_code": "\tprotected void initBeanWrapper(BeanWrapper bw) {\n\t\tConversionService cs = getConversionService();\n\t\tif (cs != null) {\n\t\t\tbw.setConversionService(cs);\n\t\t}\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#initialize(mappedClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the mapping meta-data for the given class.\n\t * @param mappedClass the mapped class\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mappedClass"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "void",
    "signature": "protected void initialize(Class<T> mappedClass)",
    "source_code": "\tprotected void initialize(Class<T> mappedClass) {\n\t\tthis.mappedClass = mappedClass;\n\t\tthis.mappedProperties = new HashMap<>();\n\t\tthis.mappedPropertyNames = new HashSet<>();\n\n\t\tfor (PropertyDescriptor pd : BeanUtils.getPropertyDescriptors(mappedClass)) {\n\t\t\tif (pd.getWriteMethod() != null) {\n\t\t\t\tString lowerCaseName = lowerCaseName(pd.getName());\n\t\t\t\tthis.mappedProperties.put(lowerCaseName, pd);\n\t\t\t\tString underscoreName = underscoreName(pd.getName());\n\t\t\t\tif (!lowerCaseName.equals(underscoreName)) {\n\t\t\t\t\tthis.mappedProperties.put(underscoreName, pd);\n\t\t\t\t}\n\t\t\t\tthis.mappedPropertyNames.add(pd.getName());\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#isCheckFullyPopulated()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether we're strictly validating that all bean properties have been\n\t * mapped from corresponding database columns or out-parameters.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "boolean",
    "signature": "public boolean isCheckFullyPopulated()",
    "source_code": "\tpublic boolean isCheckFullyPopulated() {\n\t\treturn this.checkFullyPopulated;\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#isPrimitivesDefaultedForNullValue()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the value of the {@code primitivesDefaultedForNullValue} flag.\n\t * @see #setPrimitivesDefaultedForNullValue(boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "boolean",
    "signature": "public boolean isPrimitivesDefaultedForNullValue()",
    "source_code": "\tpublic boolean isPrimitivesDefaultedForNullValue() {\n\t\treturn this.primitivesDefaultedForNullValue;\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#lowerCaseName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given name to lower case.\n\t * <p>By default, conversions will happen within the US locale.\n\t * @param name the original name\n\t * @return the converted name\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "String",
    "signature": "protected String lowerCaseName(String name)",
    "source_code": "\tprotected String lowerCaseName(String name) {\n\t\treturn name.toLowerCase(Locale.US);\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#newInstance(mappedClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create a new {@code BeanPropertyRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t * @see #newInstance(Class, ConversionService)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedClass"
    ],
    "position": {
      "column": 1,
      "line": 439
    },
    "return": "BeanPropertyRowMapper<T>",
    "signature": "public BeanPropertyRowMapper<T> newInstance(Class<T> mappedClass)",
    "source_code": "\tpublic static <T> BeanPropertyRowMapper<T> newInstance(Class<T> mappedClass) {\n\t\treturn new BeanPropertyRowMapper<>(mappedClass);\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#newInstance(mappedClass,conversionService)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create a new {@code BeanPropertyRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t * @param conversionService the {@link ConversionService} for binding\n\t * R2DBC values to bean properties, or {@code null} for none\n\t * @see #newInstance(Class)\n\t * @see #setConversionService\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedClass",
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 451
    },
    "return": "BeanPropertyRowMapper<T>",
    "signature": "public BeanPropertyRowMapper<T> newInstance(Class<T> mappedClass, @Nullable ConversionService conversionService)",
    "source_code": "\tpublic static <T> BeanPropertyRowMapper<T> newInstance("
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#setCheckFullyPopulated(checkFullyPopulated)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether we're strictly validating that all bean properties have been mapped\n\t * from corresponding database columns or out-parameters.\n\t * <p>Default is {@code false}, accepting unpopulated properties in the target bean.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "checkFullyPopulated"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "void",
    "signature": "public void setCheckFullyPopulated(boolean checkFullyPopulated)",
    "source_code": "\tpublic void setCheckFullyPopulated(boolean checkFullyPopulated) {\n\t\tthis.checkFullyPopulated = checkFullyPopulated;\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#setConversionService(conversionService)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a {@link ConversionService} for binding R2DBC values to bean properties,\n\t * or {@code null} for none.\n\t * <p>Default is a {@link DefaultConversionService}. This provides support for\n\t * {@code java.time} conversion and other special types.\n\t * @see #initBeanWrapper(BeanWrapper)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "void",
    "signature": "public void setConversionService(@Nullable ConversionService conversionService)",
    "source_code": "\tpublic void setConversionService(@Nullable ConversionService conversionService) {\n\t\tthis.conversionService = conversionService;\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#setPrimitivesDefaultedForNullValue(primitivesDefaultedForNullValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether a {@code NULL} database column or out-parameter value should\n\t * be ignored when mapping to a corresponding primitive property in the target class.\n\t * <p>Default is {@code false}, throwing an exception when nulls are mapped\n\t * to Java primitives.\n\t * <p>If this flag is set to {@code true} and you use an <em>ignored</em>\n\t * primitive property value from the mapped bean to update the database, the\n\t * value in the database will be changed from {@code NULL} to the current value\n\t * of that primitive property. That value may be the property's initial value\n\t * (potentially Java's default value for the respective primitive type), or\n\t * it may be some other value set for the property in the default constructor\n\t * (or initialization block) or as a side effect of setting some other property\n\t * in the mapped bean.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "primitivesDefaultedForNullValue"
    ],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "void",
    "signature": "public void setPrimitivesDefaultedForNullValue(boolean primitivesDefaultedForNullValue)",
    "source_code": "\tpublic void setPrimitivesDefaultedForNullValue(boolean primitivesDefaultedForNullValue) {\n\t\tthis.primitivesDefaultedForNullValue = primitivesDefaultedForNullValue;\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#suppressProperty(propertyName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Remove the specified property from the mapped properties.\n\t * @param propertyName the property name (as used by property descriptors)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "propertyName"
    ],
    "position": {
      "column": 1,
      "line": 247
    },
    "return": "void",
    "signature": "protected void suppressProperty(String propertyName)",
    "source_code": "\tprotected void suppressProperty(String propertyName) {\n\t\tif (this.mappedProperties != null) {\n\t\t\tthis.mappedProperties.remove(lowerCaseName(propertyName));\n\t\t\tthis.mappedProperties.remove(underscoreName(propertyName));\n\t\t}\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#underscoreName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a name in camelCase to an underscored name in lower case.\n\t * <p>Any upper case letters are converted to lower case with a preceding underscore.\n\t * @param name the original name\n\t * @return the converted name\n\t * @see #lowerCaseName\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "String",
    "signature": "protected String underscoreName(String name)",
    "source_code": "\tprotected String underscoreName(String name) {\n\t\tif (!StringUtils.hasLength(name)) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tStringBuilder result = new StringBuilder();\n\t\tresult.append(Character.toLowerCase(name.charAt(0)));\n\t\tfor (int i = 1; i < name.length(); i++) {\n\t\t\tchar c = name.charAt(i);\n\t\t\tif (Character.isUpperCase(c)) {\n\t\t\t\tresult.append('_').append(Character.toLowerCase(c));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.append(c);\n\t\t\t}\n\t\t}\n\t\treturn result.toString();\n\t}"
  },
  "org.springframework.r2dbc.core.logger": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Logger available to subclasses. */",
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor#processScheduledAsync(scheduled,method,bean)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Process the given {@code @Scheduled} bean method declaration which returns\n\t * a {@code Publisher}, or the given Kotlin suspending function converted to a\n\t * {@code Publisher}. A {@code Runnable} which subscribes to that publisher is\n\t * then repeatedly scheduled according to the annotation configuration.\n\t * <p>Note that for fixed delay configuration, the subscription is turned into a blocking\n\t * call instead. Types for which a {@code ReactiveAdapter} is registered but which cannot\n\t * be deferred (i.e. not a {@code Publisher}) are not supported.\n\t * @param scheduled the {@code @Scheduled} annotation\n\t * @param method the method that the annotation has been declared on, which\n\t * must either return a Publisher-adaptable type or be a Kotlin suspending function\n\t * @param bean the target bean instance\n\t * @see ScheduledAnnotationReactiveSupport\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "scheduled",
      "method",
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 577
    },
    "return": "void",
    "signature": "protected void processScheduledAsync(Scheduled scheduled, Method method, Object bean)",
    "source_code": "\tprotected void processScheduledAsync(Scheduled scheduled, Method method, Object bean) {\n\t\tRunnable task;\n\t\ttry {\n\t\t\ttask = ScheduledAnnotationReactiveSupport.createSubscriptionRunnable(method, bean, scheduled,\n\t\t\t\t\tthis.reactiveSubscriptions.computeIfAbsent(bean, k -> new CopyOnWriteArrayList<>()));\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\tthrow new IllegalStateException(\"Could not create recurring task for @Scheduled method '\" + method.getName() + \"': \" + ex.getMessage());\n\t\t}\n\t\tprocessScheduledTask(scheduled, task, method, bean);\n\t}"
  },
  "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor#processScheduledSync(scheduled,method,bean)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Process the given {@code @Scheduled} method declaration on the given bean,\n\t * as a synchronous method. The method must accept no arguments. Its return value\n\t * is ignored (if any), and the scheduled invocations of the method take place\n\t * using the underlying {@link TaskScheduler} infrastructure.\n\t * @param scheduled the {@code @Scheduled} annotation\n\t * @param method the method that the annotation has been declared on\n\t * @param bean the target bean instance\n\t * @see #createRunnable(Object, Method)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "scheduled",
      "method",
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 552
    },
    "return": "void",
    "signature": "protected void processScheduledSync(Scheduled scheduled, Method method, Object bean)",
    "source_code": "\tprotected void processScheduledSync(Scheduled scheduled, Method method, Object bean) {\n\t\tRunnable task;\n\t\ttry {\n\t\t\ttask = createRunnable(bean, method);\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\tthrow new IllegalStateException(\"Could not create recurring task for @Scheduled method '\" + method.getName() + \"': \" + ex.getMessage());\n\t\t}\n\t\tprocessScheduledTask(scheduled, task, method, bean);\n\t}"
  },
  "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor#processScheduledTask(scheduled,runnable,method,bean)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the {@code Scheduled} annotation and schedule the provided {@code Runnable}\n\t * accordingly. The Runnable can represent either a synchronous method invocation\n\t * (see {@link #processScheduledSync(Scheduled, Method, Object)}) or an asynchronous\n\t * one (see {@link #processScheduledAsync(Scheduled, Method, Object)}).\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "scheduled",
      "runnable",
      "method",
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 418
    },
    "return": "void",
    "signature": "protected void processScheduledTask(Scheduled scheduled, Runnable runnable, Method method, Object bean)",
    "source_code": "\tprotected void processScheduledTask(Scheduled scheduled, Runnable runnable, Method method, Object bean) {\n\t\ttry {\n\t\t\tboolean processedSchedule = false;\n\t\t\tString errorMessage =\n\t\t\t\t\t\"Exactly one of the 'cron', 'fixedDelay(String)', or 'fixedRate(String)' attributes is required\";\n\n\t\t\tSet<ScheduledTask> tasks = new LinkedHashSet<>(4);\n\n\t\t\t// Determine initial delay\n\t\t\tDuration initialDelay = toDuration(scheduled.initialDelay(), scheduled.timeUnit());\n\t\t\tString initialDelayString = scheduled.initialDelayString();\n\t\t\tif (StringUtils.hasText(initialDelayString)) {\n\t\t\t\tAssert.isTrue(initialDelay.isNegative(), \"Specify 'initialDelay' or 'initialDelayString', not both\");\n\t\t\t\tif (this.embeddedValueResolver != null) {\n\t\t\t\t\tinitialDelayString = this.embeddedValueResolver.resolveStringValue(initialDelayString);\n\t\t\t\t}\n\t\t\t\tif (StringUtils.hasLength(initialDelayString)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tinitialDelay = toDuration(initialDelayString, scheduled.timeUnit());\n\t\t\t\t\t}\n\t\t\t\t\tcatch (RuntimeException ex) {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\t\t\"Invalid initialDelayString value \\\"\" + initialDelayString + \"\\\" - cannot parse into long\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check cron expression\n\t\t\tString cron = scheduled.cron();\n\t\t\tif (StringUtils.hasText(cron)) {\n\t\t\t\tString zone = scheduled.zone();\n\t\t\t\tif (this.embeddedValueResolver != null) {\n\t\t\t\t\tcron = this.embeddedValueResolver.resolveStringValue(cron);\n\t\t\t\t\tzone = this.embeddedValueResolver.resolveStringValue(zone);\n\t\t\t\t}\n\t\t\t\tif (StringUtils.hasLength(cron)) {\n\t\t\t\t\tAssert.isTrue(initialDelay.isNegative(), \"'initialDelay' not supported for cron triggers\");\n\t\t\t\t\tprocessedSchedule = true;\n\t\t\t\t\tif (!Scheduled.CRON_DISABLED.equals(cron)) {\n\t\t\t\t\t\tTimeZone timeZone;\n\t\t\t\t\t\tif (StringUtils.hasText(zone)) {\n\t\t\t\t\t\t\ttimeZone = StringUtils.parseTimeZoneString(zone);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttimeZone = TimeZone.getDefault();\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttasks.add(this.registrar.scheduleCronTask(new CronTask(runnable, new CronTrigger(cron, timeZone))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// At this point we don't need to differentiate between initial delay set or not anymore\n\t\t\tif (initialDelay.isNegative()) {\n\t\t\t\tinitialDelay = Duration.ZERO;\n\t\t\t}\n\n\t\t\t// Check fixed delay\n\t\t\tDuration fixedDelay = toDuration(scheduled.fixedDelay(), scheduled.timeUnit());\n\t\t\tif (!fixedDelay.isNegative()) {\n\t\t\t\tAssert.isTrue(!processedSchedule, errorMessage);\n\t\t\t\tprocessedSchedule = true;\n\t\t\t\ttasks.add(this.registrar.scheduleFixedDelayTask(new FixedDelayTask(runnable, fixedDelay, initialDelay)));\n\t\t\t}\n\n\t\t\tString fixedDelayString = scheduled.fixedDelayString();\n\t\t\tif (StringUtils.hasText(fixedDelayString)) {\n\t\t\t\tif (this.embeddedValueResolver != null) {\n\t\t\t\t\tfixedDelayString = this.embeddedValueResolver.resolveStringValue(fixedDelayString);\n\t\t\t\t}\n\t\t\t\tif (StringUtils.hasLength(fixedDelayString)) {\n\t\t\t\t\tAssert.isTrue(!processedSchedule, errorMessage);\n\t\t\t\t\tprocessedSchedule = true;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfixedDelay = toDuration(fixedDelayString, scheduled.timeUnit());\n\t\t\t\t\t}\n\t\t\t\t\tcatch (RuntimeException ex) {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\t\t\"Invalid fixedDelayString value \\\"\" + fixedDelayString + \"\\\" - cannot parse into long\");\n\t\t\t\t\t}\n\t\t\t\t\ttasks.add(this.registrar.scheduleFixedDelayTask(new FixedDelayTask(runnable, fixedDelay, initialDelay)));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check fixed rate\n\t\t\tDuration fixedRate = toDuration(scheduled.fixedRate(), scheduled.timeUnit());\n\t\t\tif (!fixedRate.isNegative()) {\n\t\t\t\tAssert.isTrue(!processedSchedule, errorMessage);\n\t\t\t\tprocessedSchedule = true;\n\t\t\t\ttasks.add(this.registrar.scheduleFixedRateTask(new FixedRateTask(runnable, fixedRate, initialDelay)));\n\t\t\t}\n\t\t\tString fixedRateString = scheduled.fixedRateString();\n\t\t\tif (StringUtils.hasText(fixedRateString)) {\n\t\t\t\tif (this.embeddedValueResolver != null) {\n\t\t\t\t\tfixedRateString = this.embeddedValueResolver.resolveStringValue(fixedRateString);\n\t\t\t\t}\n\t\t\t\tif (StringUtils.hasLength(fixedRateString)) {\n\t\t\t\t\tAssert.isTrue(!processedSchedule, errorMessage);\n\t\t\t\t\tprocessedSchedule = true;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfixedRate = toDuration(fixedRateString, scheduled.timeUnit());\n\t\t\t\t\t}\n\t\t\t\t\tcatch (RuntimeException ex) {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\t\t\"Invalid fixedRateString value \\\"\" + fixedRateString + \"\\\" - cannot parse into long\");\n\t\t\t\t\t}\n\t\t\t\t\ttasks.add(this.registrar.scheduleFixedRateTask(new FixedRateTask(runnable, fixedRate, initialDelay)));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check whether we had any attribute set\n\t\t\tAssert.isTrue(processedSchedule, errorMessage);\n\n\t\t\t// Finally register the scheduled tasks\n\t\t\tsynchronized (this.scheduledTasks) {\n\t\t\t\tSet<ScheduledTask> regTasks = this.scheduledTasks.computeIfAbsent(bean, key -> new LinkedHashSet<>(4));\n\t\t\t\tregTasks.addAll(tasks);\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Encountered invalid @Scheduled method '\" + method.getName() + \"': \" + ex.getMessage());\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#execute(task,startTimeout)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "startTimeout"
    ],
    "position": {
      "column": 1,
      "line": 369
    },
    "return": "void",
    "signature": "public void execute(Runnable task, long startTimeout)",
    "source_code": "\tpublic void execute(Runnable task, long startTimeout) {\n\t\texecute(task);\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#execute(task,startTimeout)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "startTimeout"
    ],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "void",
    "signature": "public void execute(Runnable task, long startTimeout)",
    "source_code": "\tpublic void execute(Runnable task, long startTimeout) {\n\t\texecute(task);\n\t}"
  },
  "org.springframework.scheduling.support.CronSequenceGenerator": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Date sequence generator for a\n * <a href=\"https://www.manpagez.com/man/5/crontab/\">Crontab pattern</a>,\n * allowing clients to specify a pattern that the sequence matches.\n *\n * <p>The pattern is a list of six single space-separated fields: representing\n * second, minute, hour, day, month, weekday. Month and weekday names can be\n * given as the first three letters of the English names.\n *\n * <p>Example patterns:\n * <ul>\n * <li>\"0 0 * * * *\" = the top of every hour of every day.</li>\n * <li>\"*&#47;10 * * * * *\" = every ten seconds.</li>\n * <li>\"0 0 8-10 * * *\" = 8, 9 and 10 o'clock of every day.</li>\n * <li>\"0 0 6,19 * * *\" = 6:00 AM and 7:00 PM every day.</li>\n * <li>\"0 0/30 8-10 * * *\" = 8:00, 8:30, 9:00, 9:30, 10:00 and 10:30 every day.</li>\n * <li>\"0 0 9-17 * * MON-FRI\" = on the hour nine-to-five weekdays</li>\n * <li>\"0 0 0 25 12 ?\" = every Christmas Day at midnight</li>\n * </ul>\n *\n * @author Dave Syer\n * @author Juergen Hoeller\n * @author Ruslan Sibgatullin\n * @since 3.0\n * @see CronTrigger\n * @deprecated as of 5.3, in favor of {@link CronExpression}\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "signature": "public class CronSequenceGenerator",
    "source_code": "public class CronSequenceGenerator {\n\n\tprivate final String expression;\n\n\t@Nullable\n\tprivate final TimeZone timeZone;\n\n\tprivate final BitSet months = new BitSet(12);\n\n\tprivate final BitSet daysOfMonth = new BitSet(31);\n\n\tprivate final BitSet daysOfWeek = new BitSet(7);\n\n\tprivate final BitSet hours = new BitSet(24);\n\n\tprivate final BitSet minutes = new BitSet(60);\n\n\tprivate final BitSet seconds = new BitSet(60);\n\n\n\t/**\n\t * Construct a {@code CronSequenceGenerator} from the pattern provided,\n\t * using the default {@link TimeZone}.\n\t * @param expression a space-separated list of time fields\n\t * @throws IllegalArgumentException if the pattern cannot be parsed\n\t * @see java.util.TimeZone#getDefault()\n\t * @deprecated as of 5.3, in favor of {@link CronExpression#parse(String)}\n\t */\n\t@Deprecated(since = \"5.3\", forRemoval = true)\n\tpublic CronSequenceGenerator(String expression) {\n\t\tthis(expression, TimeZone.getDefault());\n\t}\n\n\t/**\n\t * Construct a {@code CronSequenceGenerator} from the pattern provided,\n\t * using the specified {@link TimeZone}.\n\t * @param expression a space-separated list of time fields\n\t * @param timeZone the TimeZone to use for generated trigger times\n\t * @throws IllegalArgumentException if the pattern cannot be parsed\n\t * @deprecated as of 5.3, in favor of {@link CronExpression#parse(String)}\n\t */\n\t@Deprecated\n\tpublic CronSequenceGenerator(String expression, TimeZone timeZone) {\n\t\tthis.expression = expression;\n\t\tthis.timeZone = timeZone;\n\t\tparse(expression);\n\t}\n\n\tprivate CronSequenceGenerator(String expression, String[] fields) {\n\t\tthis.expression = expression;\n\t\tthis.timeZone = null;\n\t\tdoParse(fields);\n\t}\n\n\n\t/**\n\t * Return the cron pattern that this sequence generator has been built for.\n\t */\n\tString getExpression() {\n\t\treturn this.expression;\n\t}\n\n\n\t/**\n\t * Get the next {@link Date} in the sequence matching the Cron pattern and\n\t * after the value provided. The return value will have a whole number of\n\t * seconds, and will be after the input value.\n\t * @param date a seed value\n\t * @return the next value matching the pattern\n\t */\n\tpublic Date next(Date date) {\n\t\t/*\n\t\tThe plan:\n\n\t\t1 Start with whole second (rounding up if necessary)\n\n\t\t2 If seconds match move on, otherwise find the next match:\n\t\t2.1 If next match is in the next minute then roll forwards\n\n\t\t3 If minute matches move on, otherwise find the next match\n\t\t3.1 If next match is in the next hour then roll forwards\n\t\t3.2 Reset the seconds and go to 2\n\n\t\t4 If hour matches move on, otherwise find the next match\n\t\t4.1 If next match is in the next day then roll forwards,\n\t\t4.2 Reset the minutes and seconds and go to 2\n\t\t*/\n\n\t\tCalendar calendar = new GregorianCalendar();\n\t\tcalendar.setTimeZone(this.timeZone);\n\t\tcalendar.setTime(date);\n\n\t\t// First, just reset the milliseconds and try to calculate from there...\n\t\tcalendar.set(Calendar.MILLISECOND, 0);\n\t\tlong originalTimestamp = calendar.getTimeInMillis();\n\t\tdoNext(calendar, calendar.get(Calendar.YEAR));\n\n\t\tif (calendar.getTimeInMillis() == originalTimestamp) {\n\t\t\t// We arrived at the original timestamp - round up to the next whole second and try again...\n\t\t\tcalendar.add(Calendar.SECOND, 1);\n\t\t\tdoNext(calendar, calendar.get(Calendar.YEAR));\n\t\t}\n\n\t\treturn calendar.getTime();\n\t}\n\n\tprivate void doNext(Calendar calendar, int dot) {\n\t\tList<Integer> resets = new ArrayList<>();\n\n\t\tint second = calendar.get(Calendar.SECOND);\n\t\tList<Integer> emptyList = Collections.emptyList();\n\t\tint updateSecond = findNext(this.seconds, second, calendar, Calendar.SECOND, Calendar.MINUTE, emptyList);\n\t\tif (second == updateSecond) {\n\t\t\tresets.add(Calendar.SECOND);\n\t\t}\n\n\t\tint minute = calendar.get(Calendar.MINUTE);\n\t\tint updateMinute = findNext(this.minutes, minute, calendar, Calendar.MINUTE, Calendar.HOUR_OF_DAY, resets);\n\t\tif (minute == updateMinute) {\n\t\t\tresets.add(Calendar.MINUTE);\n\t\t}\n\t\telse {\n\t\t\tdoNext(calendar, dot);\n\t\t}\n\n\t\tint hour = calendar.get(Calendar.HOUR_OF_DAY);\n\t\tint updateHour = findNext(this.hours, hour, calendar, Calendar.HOUR_OF_DAY, Calendar.DAY_OF_WEEK, resets);\n\t\tif (hour == updateHour) {\n\t\t\tresets.add(Calendar.HOUR_OF_DAY);\n\t\t}\n\t\telse {\n\t\t\tdoNext(calendar, dot);\n\t\t}\n\n\t\tint dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);\n\t\tint dayOfMonth = calendar.get(Calendar.DAY_OF_MONTH);\n\t\tint updateDayOfMonth = findNextDay(calendar, this.daysOfMonth, dayOfMonth, this.daysOfWeek, dayOfWeek, resets);\n\t\tif (dayOfMonth == updateDayOfMonth) {\n\t\t\tresets.add(Calendar.DAY_OF_MONTH);\n\t\t}\n\t\telse {\n\t\t\tdoNext(calendar, dot);\n\t\t}\n\n\t\tint month = calendar.get(Calendar.MONTH);\n\t\tint updateMonth = findNext(this.months, month, calendar, Calendar.MONTH, Calendar.YEAR, resets);\n\t\tif (month != updateMonth) {\n\t\t\tif (calendar.get(Calendar.YEAR) - dot > 4) {\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid cron expression \\\"\" + this.expression +\n\t\t\t\t\t\t\"\\\" led to runaway search for next trigger\");\n\t\t\t}\n\t\t\tdoNext(calendar, dot);\n\t\t}\n\n\t}\n\n\tprivate int findNextDay(Calendar calendar, BitSet daysOfMonth, int dayOfMonth, BitSet daysOfWeek, int dayOfWeek,\n\t\t\tList<Integer> resets) {\n\n\t\tint count = 0;\n\t\tint max = 366;\n\t\t// the DAY_OF_WEEK values in java.util.Calendar start with 1 (Sunday),\n\t\t// but in the cron pattern, they start with 0, so we subtract 1 here\n\t\twhile ((!daysOfMonth.get(dayOfMonth) || !daysOfWeek.get(dayOfWeek - 1)) && count++ < max) {\n\t\t\tcalendar.add(Calendar.DAY_OF_MONTH, 1);\n\t\t\tdayOfMonth = calendar.get(Calendar.DAY_OF_MONTH);\n\t\t\tdayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);\n\t\t\treset(calendar, resets);\n\t\t}\n\t\tif (count >= max) {\n\t\t\tthrow new IllegalArgumentException(\"Overflow in day for expression \\\"\" + this.expression + \"\\\"\");\n\t\t}\n\t\treturn dayOfMonth;\n\t}\n\n\t/**\n\t * Search the bits provided for the next set bit after the value provided,\n\t * and reset the calendar.\n\t * @param bits a {@link BitSet} representing the allowed values of the field\n\t * @param value the current value of the field\n\t * @param calendar the calendar to increment as we move through the bits\n\t * @param field the field to increment in the calendar (@see\n\t * {@link Calendar} for the static constants defining valid fields)\n\t * @param lowerOrders the Calendar field ids that should be reset (i.e. the\n\t * ones of lower significance than the field of interest)\n\t * @return the value of the calendar field that is next in the sequence\n\t */\n\tprivate int findNext(BitSet bits, int value, Calendar calendar, int field, int nextField, List<Integer> lowerOrders) {\n\t\tint nextValue = bits.nextSetBit(value);\n\t\t// roll over if needed\n\t\tif (nextValue == -1) {\n\t\t\tcalendar.add(nextField, 1);\n\t\t\treset(calendar, Collections.singletonList(field));\n\t\t\tnextValue = bits.nextSetBit(0);\n\t\t}\n\t\tif (nextValue != value) {\n\t\t\tcalendar.set(field, nextValue);\n\t\t\treset(calendar, lowerOrders);\n\t\t}\n\t\treturn nextValue;\n\t}\n\n\t/**\n\t * Reset the calendar setting all the fields provided to zero.\n\t */\n\tprivate void reset(Calendar calendar, List<Integer> fields) {\n\t\tfor (int field : fields) {\n\t\t\tcalendar.set(field, field == Calendar.DAY_OF_MONTH ? 1 : 0);\n\t\t}\n\t}\n\n\n\t// Parsing logic invoked by the constructor\n\n\t/**\n\t * Parse the given pattern expression.\n\t */\n\tprivate void parse(String expression) throws IllegalArgumentException {\n\t\tString[] fields = StringUtils.tokenizeToStringArray(expression, \" \");\n\t\tif (!areValidCronFields(fields)) {\n\t\t\tthrow new IllegalArgumentException(String.format(\n\t\t\t\t\t\"Cron expression must consist of 6 fields (found %d in \\\"%s\\\")\", fields.length, expression));\n\t\t}\n\t\tdoParse(fields);\n\t}\n\n\tprivate void doParse(String[] fields) {\n\t\tsetNumberHits(this.seconds, fields[0], 0, 60);\n\t\tsetNumberHits(this.minutes, fields[1], 0, 60);\n\t\tsetNumberHits(this.hours, fields[2], 0, 24);\n\t\tsetDaysOfMonth(this.daysOfMonth, fields[3]);\n\t\tsetMonths(this.months, fields[4]);\n\t\tsetDays(this.daysOfWeek, replaceOrdinals(fields[5], \"SUN,MON,TUE,WED,THU,FRI,SAT\"), 8);\n\n\t\tif (this.daysOfWeek.get(7)) {\n\t\t\t// Sunday can be represented as 0 or 7\n\t\t\tthis.daysOfWeek.set(0);\n\t\t\tthis.daysOfWeek.clear(7);\n\t\t}\n\t}\n\n\t/**\n\t * Replace the values in the comma-separated list (case-insensitive)\n\t * with their index in the list.\n\t * @return a new String with the values from the list replaced\n\t */\n\tprivate String replaceOrdinals(String value, String commaSeparatedList) {\n\t\tString[] list = StringUtils.commaDelimitedListToStringArray(commaSeparatedList);\n\t\tfor (int i = 0; i < list.length; i++) {\n\t\t\tString item = list[i].toUpperCase();\n\t\t\tvalue = StringUtils.replace(value.toUpperCase(), item, \"\" + i);\n\t\t}\n\t\treturn value;\n\t}\n\n\tprivate void setDaysOfMonth(BitSet bits, String field) {\n\t\tint max = 31;\n\t\t// Days of month start with 1 (in Cron and Calendar) so add one\n\t\tsetDays(bits, field, max + 1);\n\t\t// ... and remove it from the front\n\t\tbits.clear(0);\n\t}\n\n\tprivate void setDays(BitSet bits, String field, int max) {\n\t\tif (field.contains(\"?\")) {\n\t\t\tfield = \"*\";\n\t\t}\n\t\tsetNumberHits(bits, field, 0, max);\n\t}\n\n\tprivate void setMonths(BitSet bits, String value) {\n\t\tint max = 12;\n\t\tvalue = replaceOrdinals(value, \"FOO,JAN,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC\");\n\t\tBitSet months = new BitSet(13);\n\t\t// Months start with 1 in Cron and 0 in Calendar, so push the values first into a longer bit set\n\t\tsetNumberHits(months, value, 1, max + 1);\n\t\t// ... and then rotate it to the front of the months\n\t\tfor (int i = 1; i <= max; i++) {\n\t\t\tif (months.get(i)) {\n\t\t\t\tbits.set(i - 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void setNumberHits(BitSet bits, String value, int min, int max) {\n\t\tString[] fields = StringUtils.delimitedListToStringArray(value, \",\");\n\t\tfor (String field : fields) {\n\t\t\tif (!field.contains(\"/\")) {\n\t\t\t\t// Not an incrementer so it must be a range (possibly empty)\n\t\t\t\tint[] range = getRange(field, min, max);\n\t\t\t\tbits.set(range[0], range[1] + 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString[] split = StringUtils.delimitedListToStringArray(field, \"/\");\n\t\t\t\tif (split.length > 2) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Incrementer has more than two fields: '\" +\n\t\t\t\t\t\t\tfield + \"' in expression \\\"\" + this.expression + \"\\\"\");\n\t\t\t\t}\n\t\t\t\tint[] range = getRange(split[0], min, max);\n\t\t\t\tif (!split[0].contains(\"-\")) {\n\t\t\t\t\trange[1] = max - 1;\n\t\t\t\t}\n\t\t\t\tint delta = Integer.parseInt(split[1]);\n\t\t\t\tif (delta <= 0) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Incrementer delta must be 1 or higher: '\" +\n\t\t\t\t\t\t\tfield + \"' in expression \\\"\" + this.expression + \"\\\"\");\n\t\t\t\t}\n\t\t\t\tfor (int i = range[0]; i <= range[1]; i += delta) {\n\t\t\t\t\tbits.set(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int[] getRange(String field, int min, int max) {\n\t\tint[] result = new int[2];\n\t\tif (field.contains(\"*\")) {\n\t\t\tresult[0] = min;\n\t\t\tresult[1] = max - 1;\n\t\t\treturn result;\n\t\t}\n\t\tif (!field.contains(\"-\")) {\n\t\t\tresult[0] = result[1] = Integer.parseInt(field);\n\t\t}\n\t\telse {\n\t\t\tString[] split = StringUtils.delimitedListToStringArray(field, \"-\");\n\t\t\tif (split.length > 2) {\n\t\t\t\tthrow new IllegalArgumentException(\"Range has more than two fields: '\" +\n\t\t\t\t\t\tfield + \"' in expression \\\"\" + this.expression + \"\\\"\");\n\t\t\t}\n\t\t\tresult[0] = Integer.parseInt(split[0]);\n\t\t\tresult[1] = Integer.parseInt(split[1]);\n\t\t}\n\t\tif (result[0] >= max || result[1] >= max) {\n\t\t\tthrow new IllegalArgumentException(\"Range exceeds maximum (\" + max + \"): '\" +\n\t\t\t\t\tfield + \"' in expression \\\"\" + this.expression + \"\\\"\");\n\t\t}\n\t\tif (result[0] < min || result[1] < min) {\n\t\t\tthrow new IllegalArgumentException(\"Range less than minimum (\" + min + \"): '\" +\n\t\t\t\t\tfield + \"' in expression \\\"\" + this.expression + \"\\\"\");\n\t\t}\n\t\tif (result[0] > result[1]) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid inverted range: '\" + field +\n\t\t\t\t\t\"' in expression \\\"\" + this.expression + \"\\\"\");\n\t\t}\n\t\treturn result;\n\t}\n\n\n\t/**\n\t * Determine whether the specified expression represents a valid cron pattern.\n\t * @param expression the expression to evaluate\n\t * @return {@code true} if the given expression is a valid cron expression\n\t * @since 4.3\n\t */\n\tpublic static boolean isValidExpression(@Nullable String expression) {\n\t\tif (expression == null) {\n\t\t\treturn false;\n\t\t}\n\t\tString[] fields = StringUtils.tokenizeToStringArray(expression, \" \");\n\t\tif (!areValidCronFields(fields)) {\n\t\t\treturn false;\n\t\t}\n\t\ttry {\n\t\t\tnew CronSequenceGenerator(expression, fields);\n\t\t\treturn true;\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate static boolean areValidCronFields(@Nullable String[] fields) {\n\t\treturn (fields != null && fields.length == 6);\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!(other instanceof CronSequenceGenerator otherCron)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (this.months.equals(otherCron.months) && this.daysOfMonth.equals(otherCron.daysOfMonth) &&\n\t\t\t\tthis.daysOfWeek.equals(otherCron.daysOfWeek) && this.hours.equals(otherCron.hours) &&\n\t\t\t\tthis.minutes.equals(otherCron.minutes) && this.seconds.equals(otherCron.seconds));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn (17 * this.months.hashCode() + 29 * this.daysOfMonth.hashCode() + 37 * this.daysOfWeek.hashCode() +\n\t\t\t\t41 * this.hours.hashCode() + 53 * this.minutes.hashCode() + 61 * this.seconds.hashCode());\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \": \" + this.expression;\n\t}\n\n}"
  },
  "org.springframework.scheduling.support.CronSequenceGenerator#equals(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 437
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!(other instanceof CronSequenceGenerator otherCron)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (this.months.equals(otherCron.months) && this.daysOfMonth.equals(otherCron.daysOfMonth) &&\n\t\t\t\tthis.daysOfWeek.equals(otherCron.daysOfWeek) && this.hours.equals(otherCron.hours) &&\n\t\t\t\tthis.minutes.equals(otherCron.minutes) && this.seconds.equals(otherCron.seconds));\n\t}"
  },
  "org.springframework.scheduling.support.CronSequenceGenerator#hashCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 450
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn (17 * this.months.hashCode() + 29 * this.daysOfMonth.hashCode() + 37 * this.daysOfWeek.hashCode() +\n\t\t\t\t41 * this.hours.hashCode() + 53 * this.minutes.hashCode() + 61 * this.seconds.hashCode());\n\t}"
  },
  "org.springframework.scheduling.support.CronSequenceGenerator#isValidExpression(expression)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the specified expression represents a valid cron pattern.\n\t * @param expression the expression to evaluate\n\t * @return {@code true} if the given expression is a valid cron expression\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expression"
    ],
    "position": {
      "column": 1,
      "line": 414
    },
    "return": "boolean",
    "signature": "public boolean isValidExpression(@Nullable String expression)",
    "source_code": "\tpublic static boolean isValidExpression(@Nullable String expression) {\n\t\tif (expression == null) {\n\t\t\treturn false;\n\t\t}\n\t\tString[] fields = StringUtils.tokenizeToStringArray(expression, \" \");\n\t\tif (!areValidCronFields(fields)) {\n\t\t\treturn false;\n\t\t}\n\t\ttry {\n\t\t\tnew CronSequenceGenerator(expression, fields);\n\t\t\treturn true;\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\treturn false;\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.support.CronSequenceGenerator#next(date)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the next {@link Date} in the sequence matching the Cron pattern and\n\t * after the value provided. The return value will have a whole number of\n\t * seconds, and will be after the input value.\n\t * @param date a seed value\n\t * @return the next value matching the pattern\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "date"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "Date",
    "signature": "public Date next(Date date)",
    "source_code": "\tpublic Date next(Date date) {\n\t\t/*\n\t\tThe plan:\n\n\t\t1 Start with whole second (rounding up if necessary)\n\n\t\t2 If seconds match move on, otherwise find the next match:\n\t\t2.1 If next match is in the next minute then roll forwards\n\n\t\t3 If minute matches move on, otherwise find the next match\n\t\t3.1 If next match is in the next hour then roll forwards\n\t\t3.2 Reset the seconds and go to 2\n\n\t\t4 If hour matches move on, otherwise find the next match\n\t\t4.1 If next match is in the next day then roll forwards,\n\t\t4.2 Reset the minutes and seconds and go to 2\n\t\t*/\n\n\t\tCalendar calendar = new GregorianCalendar();\n\t\tcalendar.setTimeZone(this.timeZone);\n\t\tcalendar.setTime(date);\n\n\t\t// First, just reset the milliseconds and try to calculate from there...\n\t\tcalendar.set(Calendar.MILLISECOND, 0);\n\t\tlong originalTimestamp = calendar.getTimeInMillis();\n\t\tdoNext(calendar, calendar.get(Calendar.YEAR));\n\n\t\tif (calendar.getTimeInMillis() == originalTimestamp) {\n\t\t\t// We arrived at the original timestamp - round up to the next whole second and try again...\n\t\t\tcalendar.add(Calendar.SECOND, 1);\n\t\t\tdoNext(calendar, calendar.get(Calendar.YEAR));\n\t\t}\n\n\t\treturn calendar.getTime();\n\t}"
  },
  "org.springframework.scheduling.support.CronSequenceGenerator#toString()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 456
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \": \" + this.expression;\n\t}"
  },
  "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#closeContext(mergedConfig,hierarchyMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedConfig",
      "hierarchyMode"
    ],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "void",
    "signature": "public void closeContext(MergedContextConfiguration mergedConfig, @Nullable HierarchyMode hierarchyMode)",
    "source_code": "\tpublic void closeContext(MergedContextConfiguration mergedConfig, @Nullable HierarchyMode hierarchyMode) {\n\t\tmergedConfig = replaceIfNecessary(mergedConfig);\n\t\tsynchronized (this.contextCache) {\n\t\t\tthis.contextCache.remove(mergedConfig, hierarchyMode);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#closeContext(mergedContextConfiguration,hierarchyMode)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedContextConfiguration",
      "hierarchyMode"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "void",
    "signature": "public void closeContext(MergedContextConfiguration mergedContextConfiguration, @Nullable HierarchyMode hierarchyMode)",
    "source_code": "\tpublic void closeContext(MergedContextConfiguration mergedContextConfiguration, @Nullable HierarchyMode hierarchyMode) {\n\t\tsynchronized (this.contextCache) {\n\t\t\tthis.contextCache.remove(replaceIfNecessary(mergedContextConfiguration), hierarchyMode);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#isContextLoaded(mergedConfig)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedConfig"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "boolean",
    "signature": "public boolean isContextLoaded(MergedContextConfiguration mergedConfig)",
    "source_code": "\tpublic boolean isContextLoaded(MergedContextConfiguration mergedConfig) {\n\t\tmergedConfig = replaceIfNecessary(mergedConfig);\n\t\tsynchronized (this.contextCache) {\n\t\t\treturn this.contextCache.contains(mergedConfig);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#isContextLoaded(mergedContextConfiguration)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedContextConfiguration"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "boolean",
    "signature": "public boolean isContextLoaded(MergedContextConfiguration mergedContextConfiguration)",
    "source_code": "\tpublic boolean isContextLoaded(MergedContextConfiguration mergedContextConfiguration) {\n\t\tsynchronized (this.contextCache) {\n\t\t\treturn this.contextCache.contains(replaceIfNecessary(mergedContextConfiguration));\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#loadContext(mergedConfig)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedConfig"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "ApplicationContext",
    "signature": "public ApplicationContext loadContext(MergedContextConfiguration mergedConfig)",
    "source_code": "\tpublic ApplicationContext loadContext(MergedContextConfiguration mergedConfig) {\n\t\tmergedConfig = replaceIfNecessary(mergedConfig);\n\t\tsynchronized (this.contextCache) {\n\t\t\tApplicationContext context = this.contextCache.get(mergedConfig);\n\t\t\ttry {\n\t\t\t\tif (context == null) {\n\t\t\t\t\tInteger failureCount = this.contextCache.getFailureCount(mergedConfig);\n\t\t\t\t\tif (failureCount >= this.failureThreshold) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\t\t\t\t\tApplicationContext failure threshold (%d) exceeded: \\\n\t\t\t\t\t\t\t\tskipping repeated attempt to load context for %s\"\"\"\n\t\t\t\t\t\t\t\t\t.formatted(this.failureThreshold, mergedConfig));\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (mergedConfig instanceof AotMergedContextConfiguration aotMergedConfig) {\n\t\t\t\t\t\t\tcontext = loadContextInAotMode(aotMergedConfig);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcontext = loadContextInternal(mergedConfig);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Storing ApplicationContext [%s] in cache under key %s\".formatted(\n\t\t\t\t\t\t\t\t\tSystem.identityHashCode(context), mergedConfig));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.contextCache.put(mergedConfig, context);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Incrementing ApplicationContext failure count for \" + mergedConfig);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.contextCache.incrementFailureCount(mergedConfig);\n\t\t\t\t\t\tThrowable cause = ex;\n\t\t\t\t\t\tif (ex instanceof ContextLoadException cle) {\n\t\t\t\t\t\t\tcause = cle.getCause();\n\t\t\t\t\t\t\tfor (ApplicationContextFailureProcessor contextFailureProcessor : this.contextFailureProcessors) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tcontextFailureProcessor.processLoadFailure(cle.getApplicationContext(), cause);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch (Throwable throwable) {\n\t\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\t\tlogger.debug(\"Ignoring exception thrown from ApplicationContextFailureProcessor [%s]: %s\"\n\t\t\t\t\t\t\t\t\t\t\t\t.formatted(contextFailureProcessor, throwable));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\t\"Failed to load ApplicationContext for \" + mergedConfig, cause);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Retrieved ApplicationContext [%s] from cache with key %s\".formatted(\n\t\t\t\t\t\t\t\tSystem.identityHashCode(context), mergedConfig));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.contextCache.logStatistics();\n\t\t\t}\n\n\t\t\treturn context;\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#loadContext(mergedContextConfiguration)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedContextConfiguration"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "ApplicationContext",
    "signature": "public ApplicationContext loadContext(MergedContextConfiguration mergedContextConfiguration)",
    "source_code": "\tpublic ApplicationContext loadContext(MergedContextConfiguration mergedContextConfiguration) {\n\t\tmergedContextConfiguration = replaceIfNecessary(mergedContextConfiguration);\n\t\tsynchronized (this.contextCache) {\n\t\t\tApplicationContext context = this.contextCache.get(mergedContextConfiguration);\n\t\t\ttry {\n\t\t\t\tif (context == null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (mergedContextConfiguration instanceof AotMergedContextConfiguration aotMergedConfig) {\n\t\t\t\t\t\t\tcontext = loadContextInAotMode(aotMergedConfig);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcontext = loadContextInternal(mergedContextConfiguration);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Storing ApplicationContext [%s] in cache under key %s\".formatted(\n\t\t\t\t\t\t\t\t\tSystem.identityHashCode(context), mergedContextConfiguration));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.contextCache.put(mergedContextConfiguration, context);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\tThrowable cause = ex;\n\t\t\t\t\t\tif (ex instanceof ContextLoadException cle) {\n\t\t\t\t\t\t\tcause = cle.getCause();\n\t\t\t\t\t\t\tfor (ApplicationContextFailureProcessor contextFailureProcessor : this.contextFailureProcessors) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tcontextFailureProcessor.processLoadFailure(cle.getApplicationContext(), cause);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch (Throwable throwable) {\n\t\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\t\tlogger.debug(\"Ignoring exception thrown from ApplicationContextFailureProcessor [%s]: %s\"\n\t\t\t\t\t\t\t\t\t\t\t\t.formatted(contextFailureProcessor, throwable));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\t\"Failed to load ApplicationContext for \" + mergedContextConfiguration, cause);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Retrieved ApplicationContext [%s] from cache with key %s\".formatted(\n\t\t\t\t\t\t\t\tSystem.identityHashCode(context), mergedContextConfiguration));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.contextCache.logStatistics();\n\t\t\t}\n\n\t\t\treturn context;\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#loadContextInternal(mergedConfig)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Load the {@code ApplicationContext} for the supplied merged context configuration.\n\t * <p>Supports both the {@link SmartContextLoader} and {@link ContextLoader} SPIs.\n\t * @throws Exception if an error occurs while loading the application context\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mergedConfig"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "ApplicationContext",
    "signature": "protected ApplicationContext loadContextInternal(MergedContextConfiguration mergedConfig)",
    "source_code": "\tprotected ApplicationContext loadContextInternal(MergedContextConfiguration mergedConfig)"
  },
  "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#loadContextInternal(mergedContextConfiguration)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Load the {@code ApplicationContext} for the supplied merged context configuration.\n\t * <p>Supports both the {@link SmartContextLoader} and {@link ContextLoader} SPIs.\n\t * @throws Exception if an error occurs while loading the application context\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mergedContextConfiguration"
    ],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "ApplicationContext",
    "signature": "protected ApplicationContext loadContextInternal(MergedContextConfiguration mergedContextConfiguration)",
    "source_code": "\tprotected ApplicationContext loadContextInternal(MergedContextConfiguration mergedContextConfiguration)"
  },
  "org.springframework.test.context.cache.DefaultContextCache#getFailureCount(key)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "int",
    "signature": "public int getFailureCount(MergedContextConfiguration key)",
    "source_code": "\tpublic int getFailureCount(MergedContextConfiguration key) {\n\t\treturn this.failureCounts.getOrDefault(key, 0);\n\t}"
  },
  "org.springframework.test.context.cache.DefaultContextCache#incrementFailureCount(key)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "void",
    "signature": "public void incrementFailureCount(MergedContextConfiguration key)",
    "source_code": "\tpublic void incrementFailureCount(MergedContextConfiguration key) {\n\t\tthis.totalFailureCount.incrementAndGet();\n\t\tthis.failureCounts.merge(key, 1, Integer::sum);\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code SpringExtension} integrates the <em>Spring TestContext Framework</em>\n * into JUnit 5's <em>Jupiter</em> programming model.\n *\n * <p>To use this extension, simply annotate a JUnit Jupiter based test class with\n * {@code @ExtendWith(SpringExtension.class)}, {@code @SpringJUnitConfig}, or\n * {@code @SpringJUnitWebConfig}.\n *\n * @author Sam Brannen\n * @author Simon Basl\u00e9\n * @since 5.0\n * @see org.springframework.test.context.junit.jupiter.EnabledIf\n * @see org.springframework.test.context.junit.jupiter.DisabledIf\n * @see org.springframework.test.context.junit.jupiter.SpringJUnitConfig\n * @see org.springframework.test.context.junit.jupiter.web.SpringJUnitWebConfig\n * @see org.springframework.test.context.TestContextManager\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "signature": "public class SpringExtension",
    "source_code": "public class SpringExtension implements BeforeAllCallback, AfterAllCallback, TestInstancePostProcessor,"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#afterAll(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@link TestContextManager#afterTestClass}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "void",
    "signature": "public void afterAll(ExtensionContext context)",
    "source_code": "\tpublic void afterAll(ExtensionContext context) throws Exception {\n\t\ttry {\n\t\t\tgetTestContextManager(context).afterTestClass();\n\t\t}\n\t\tfinally {\n\t\t\tgetStore(context).remove(context.getRequiredTestClass());\n\t\t}\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#afterEach(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@link TestContextManager#afterTestMethod}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "void",
    "signature": "public void afterEach(ExtensionContext context)",
    "source_code": "\tpublic void afterEach(ExtensionContext context) throws Exception {\n\t\tObject testInstance = context.getRequiredTestInstance();\n\t\tMethod testMethod = context.getRequiredTestMethod();\n\t\tThrowable testException = context.getExecutionException().orElse(null);\n\t\tgetTestContextManager(context).afterTestMethod(testInstance, testMethod, testException);\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#afterTestExecution(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@link TestContextManager#afterTestExecution}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "void",
    "signature": "public void afterTestExecution(ExtensionContext context)",
    "source_code": "\tpublic void afterTestExecution(ExtensionContext context) throws Exception {\n\t\tObject testInstance = context.getRequiredTestInstance();\n\t\tMethod testMethod = context.getRequiredTestMethod();\n\t\tThrowable testException = context.getExecutionException().orElse(null);\n\t\tgetTestContextManager(context).afterTestExecution(testInstance, testMethod, testException);\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#beforeAll(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@link TestContextManager#beforeTestClass}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "void",
    "signature": "public void beforeAll(ExtensionContext context)",
    "source_code": "\tpublic void beforeAll(ExtensionContext context) throws Exception {\n\t\tgetTestContextManager(context).beforeTestClass();\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#beforeEach(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@link TestContextManager#beforeTestMethod}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "void",
    "signature": "public void beforeEach(ExtensionContext context)",
    "source_code": "\tpublic void beforeEach(ExtensionContext context) throws Exception {\n\t\tObject testInstance = context.getRequiredTestInstance();\n\t\tMethod testMethod = context.getRequiredTestMethod();\n\t\tgetTestContextManager(context).beforeTestMethod(testInstance, testMethod);\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#beforeTestExecution(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@link TestContextManager#beforeTestExecution}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "void",
    "signature": "public void beforeTestExecution(ExtensionContext context)",
    "source_code": "\tpublic void beforeTestExecution(ExtensionContext context) throws Exception {\n\t\tObject testInstance = context.getRequiredTestInstance();\n\t\tMethod testMethod = context.getRequiredTestMethod();\n\t\tgetTestContextManager(context).beforeTestExecution(testInstance, testMethod);\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#getApplicationContext(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the {@link ApplicationContext} associated with the supplied {@code ExtensionContext}.\n\t * @param context the current {@code ExtensionContext} (never {@code null})\n\t * @return the application context\n\t * @throws IllegalStateException if an error occurs while retrieving the application context\n\t * @see org.springframework.test.context.TestContext#getApplicationContext()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "ApplicationContext",
    "signature": "public ApplicationContext getApplicationContext(ExtensionContext context)",
    "source_code": "\tpublic static ApplicationContext getApplicationContext(ExtensionContext context) {\n\t\treturn getTestContextManager(context).getTestContext().getApplicationContext();\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#postProcessTestInstance(testInstance,context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@link TestContextManager#prepareTestInstance}.\n\t * <p>As of Spring Framework 5.3.2, this method also validates that test\n\t * methods and test lifecycle methods are not annotated with\n\t * {@link Autowired @Autowired}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testInstance",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "public void postProcessTestInstance(Object testInstance, ExtensionContext context)",
    "source_code": "\tpublic void postProcessTestInstance(Object testInstance, ExtensionContext context) throws Exception {\n\t\tvalidateAutowiredConfig(context);\n\t\tvalidateRecordApplicationEventsConfig(context);\n\t\tgetTestContextManager(context).prepareTestInstance(testInstance);\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#resolveParameter(parameterContext,extensionContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve a value for the {@link Parameter} in the supplied {@link ParameterContext} by\n\t * retrieving the corresponding dependency from the test's {@link ApplicationContext}.\n\t * <p>Delegates to {@link ParameterResolutionDelegate#resolveDependency}.\n\t * @see #supportsParameter\n\t * @see ParameterResolutionDelegate#resolveDependency\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterContext",
      "extensionContext"
    ],
    "position": {
      "column": 1,
      "line": 317
    },
    "return": "Object",
    "signature": "public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext)",
    "source_code": "\tpublic Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {\n\t\tParameter parameter = parameterContext.getParameter();\n\t\tint index = parameterContext.getIndex();\n\t\tClass<?> testClass = extensionContext.getRequiredTestClass();\n\t\tApplicationContext applicationContext = getApplicationContext(extensionContext);\n\t\treturn ParameterResolutionDelegate.resolveDependency(parameter, index, testClass,\n\t\t\t\tapplicationContext.getAutowireCapableBeanFactory());\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#supportsParameter(parameterContext,extensionContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the value for the {@link Parameter} in the supplied {@link ParameterContext}\n\t * should be autowired from the test's {@link ApplicationContext}.\n\t * <p>A parameter is considered to be autowirable if one of the following\n\t * conditions is {@code true}.\n\t * <ol>\n\t * <li>The {@linkplain ParameterContext#getDeclaringExecutable() declaring\n\t * executable} is a {@link Constructor} and\n\t * {@link TestConstructorUtils#isAutowirableConstructor(Constructor, Class, PropertyProvider)}\n\t * returns {@code true}. Note that {@code isAutowirableConstructor()} will be\n\t * invoked with a fallback {@link PropertyProvider} that delegates its lookup\n\t * to {@link ExtensionContext#getConfigurationParameter(String)}.</li>\n\t * <li>The parameter is of type {@link ApplicationContext} or a sub-type thereof.</li>\n\t * <li>The parameter is of type {@link ApplicationEvents} or a sub-type thereof.</li>\n\t * <li>{@link ParameterResolutionDelegate#isAutowirable} returns {@code true}.</li>\n\t * </ol>\n\t * <p><strong>WARNING</strong>: If a test class {@code Constructor} is annotated\n\t * with {@code @Autowired} or automatically autowirable (see {@link TestConstructor}),\n\t * Spring will assume the responsibility for resolving all parameters in the\n\t * constructor. Consequently, no other registered {@link ParameterResolver}\n\t * will be able to resolve parameters.\n\t * @see #resolveParameter\n\t * @see TestConstructorUtils#isAutowirableConstructor(Constructor, Class)\n\t * @see ParameterResolutionDelegate#isAutowirable\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterContext",
      "extensionContext"
    ],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "boolean",
    "signature": "public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext)",
    "source_code": "\tpublic boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {\n\t\tParameter parameter = parameterContext.getParameter();\n\t\tExecutable executable = parameter.getDeclaringExecutable();\n\t\tClass<?> testClass = extensionContext.getRequiredTestClass();\n\t\tPropertyProvider junitPropertyProvider = propertyName ->\n\t\t\t\textensionContext.getConfigurationParameter(propertyName).orElse(null);\n\t\treturn (TestConstructorUtils.isAutowirableConstructor(executable, testClass, junitPropertyProvider) ||\n\t\t\t\tApplicationContext.class.isAssignableFrom(parameter.getType()) ||\n\t\t\t\tsupportsApplicationEvents(parameterContext) ||\n\t\t\t\tParameterResolutionDelegate.isAutowirable(parameter, parameterContext.getIndex()));\n\t}"
  },
  "org.springframework.test.web.reactive.server.ExchangeResult#getRawStatusCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the HTTP status code as an integer.\n\t * @since 5.1.10\n\t * @deprecated as of 6.0, in favor of {@link #getStatus()}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "int",
    "signature": "public int getRawStatusCode()",
    "source_code": "\tpublic int getRawStatusCode() {\n\t\treturn getStatus().value();\n\t}"
  },
  "org.springframework.util.xml.<unknown>#endPrefixMapping(prefix)": {
    "change": "modifier_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * End the prefix mapping for the given prefix.\n\t * @see org.xml.sax.ContentHandler#endPrefixMapping(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "prefix"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "void",
    "signature": "protected void endPrefixMapping(String prefix)",
    "source_code": "\tprotected void endPrefixMapping(String prefix) throws SAXException {\n\t\tif (getContentHandler() != null && this.namespaces.containsKey(prefix)) {\n\t\t\tgetContentHandler().endPrefixMapping(prefix);\n\t\t\tthis.namespaces.remove(prefix);\n\t\t}\n\t}"
  },
  "org.springframework.validation.DataBinder#getValidatorsToApply()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the Validators to apply after data binding. This includes the\n\t * configured {@link #getValidators() validators} filtered by the\n\t * {@link #setExcludedValidators(Predicate) exclude predicate}.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 637
    },
    "return": "List<Validator>",
    "signature": "public List<Validator> getValidatorsToApply()",
    "source_code": "\tpublic List<Validator> getValidatorsToApply() {\n\t\treturn (this.excludedValidators != null ?\n\t\t\t\tthis.validators.stream().filter(validator -> !this.excludedValidators.test(validator)).toList() :\n\t\t\t\tCollections.unmodifiableList(this.validators));\n\t}"
  },
  "org.springframework.validation.DataBinder#setExcludedValidators(predicate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a predicate to exclude validators.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate"
    ],
    "position": {
      "column": 1,
      "line": 591
    },
    "return": "void",
    "signature": "public void setExcludedValidators(Predicate<Validator> predicate)",
    "source_code": "\tpublic void setExcludedValidators(Predicate<Validator> predicate) {\n\t\tthis.excludedValidators = predicate;\n\t}"
  },
  "org.springframework.validation.beanvalidation.BindingResultNameResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Contract to determine the object name of an {@code @Valid} method parameter.\n\t */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 388
    },
    "signature": "public interface BindingResultNameResolver",
    "source_code": "\tpublic interface BindingResultNameResolver {\n\n\t\t/**\n\t\t * Determine the name for the given method parameter.\n\t\t * @param parameter the method parameter\n\t\t * @param value the argument or return value\n\t\t * @return the name to use\n\t\t */\n\t\tString resolveName(MethodParameter parameter, @Nullable Object value);\n\n\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Assist with applying method-level validation via\n * {@link jakarta.validation.Validator}, adapt each resulting\n * {@link ConstraintViolation} to {@link ParameterValidationResult}, and\n * raise {@link MethodValidationException}.\n *\n * <p>Used by {@link MethodValidationInterceptor}.\n *\n * @author Rossen Stoyanchev\n * @since 6.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "signature": "public class MethodValidationAdapter",
    "source_code": "public class MethodValidationAdapter {\n\n\tprivate static final Comparator<ParameterValidationResult> RESULT_COMPARATOR = new ResultComparator();\n\n\tprivate static final MethodValidationResult EMPTY_RESULT = new EmptyMethodValidationResult();\n\n\n\tprivate final Supplier<Validator> validator;\n\n\tprivate final Supplier<SpringValidatorAdapter> validatorAdapter;\n\n\tprivate MessageCodesResolver messageCodesResolver = new DefaultMessageCodesResolver();\n\n\tprivate ParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer();\n\n\t@Nullable\n\tprivate BindingResultNameResolver objectNameResolver;\n\n\n\t/**\n\t * Create an instance using a default JSR-303 validator underneath.\n\t */\n\t@SuppressWarnings(\"DataFlowIssue\")\n\tpublic MethodValidationAdapter() {\n\t\tthis.validator = SingletonSupplier.of(() -> Validation.buildDefaultValidatorFactory().getValidator());\n\t\tthis.validatorAdapter = SingletonSupplier.of(() -> new SpringValidatorAdapter(this.validator.get()));\n\t}\n\n\t/**\n\t * Create an instance using the given JSR-303 ValidatorFactory.\n\t * @param validatorFactory the JSR-303 ValidatorFactory to use\n\t */\n\t@SuppressWarnings(\"DataFlowIssue\")\n\tpublic MethodValidationAdapter(ValidatorFactory validatorFactory) {\n\t\tthis.validator = SingletonSupplier.of(validatorFactory::getValidator);\n\t\tthis.validatorAdapter = SingletonSupplier.of(() -> new SpringValidatorAdapter(this.validator.get()));\n\t}\n\n\t/**\n\t * Create an instance using the given JSR-303 Validator.\n\t * @param validator the JSR-303 Validator to use\n\t */\n\tpublic MethodValidationAdapter(Validator validator) {\n\t\tthis.validator = () -> validator;\n\t\tthis.validatorAdapter = () -> new SpringValidatorAdapter(validator);\n\t}\n\n\t/**\n\t * Create an instance for the supplied (potentially lazily initialized) Validator.\n\t * @param validator a Supplier for the Validator to use\n\t */\n\tpublic MethodValidationAdapter(Supplier<Validator> validator) {\n\t\tthis.validator = validator;\n\t\tthis.validatorAdapter = () -> new SpringValidatorAdapter(this.validator.get());\n\t}\n\n\n\t/**\n\t * Set the strategy to use to determine message codes for violations.\n\t * <p>Default is a DefaultMessageCodesResolver.\n\t */\n\tpublic void setMessageCodesResolver(MessageCodesResolver messageCodesResolver) {\n\t\tthis.messageCodesResolver = messageCodesResolver;\n\t}\n\n\t/**\n\t * Return the {@link #setMessageCodesResolver(MessageCodesResolver) configured}\n\t * {@code MessageCodesResolver}.\n\t */\n\tpublic MessageCodesResolver getMessageCodesResolver() {\n\t\treturn this.messageCodesResolver;\n\t}\n\n\t/**\n\t * Set the ParameterNameDiscoverer to use to resolve method parameter names\n\t * that is in turn used to create error codes for {@link MessageSourceResolvable}.\n\t * <p>Default is {@link org.springframework.core.DefaultParameterNameDiscoverer}.\n\t */\n\tpublic void setParameterNameDiscoverer(ParameterNameDiscoverer parameterNameDiscoverer) {\n\t\tthis.parameterNameDiscoverer = parameterNameDiscoverer;\n\t}\n\n\t/**\n\t * Return the {@link #setParameterNameDiscoverer(ParameterNameDiscoverer) configured}\n\t * {@code ParameterNameDiscoverer}.\n\t */\n\tpublic ParameterNameDiscoverer getParameterNameDiscoverer() {\n\t\treturn this.parameterNameDiscoverer;\n\t}\n\n\t/**\n\t * Configure a resolver for {@link BindingResult} method parameters to match\n\t * the behavior of the higher level programming model, e.g. how the name of\n\t * {@code @ModelAttribute} or {@code @RequestBody} is determined in Spring MVC.\n\t * <p>If this is not configured, then {@link #createBindingResult} will apply\n\t * default behavior to resolve the name to use.\n\t * behavior applies.\n\t * @param nameResolver the resolver to use\n\t */\n\tpublic void setBindingResultNameResolver(BindingResultNameResolver nameResolver) {\n\t\tthis.objectNameResolver = nameResolver;\n\t}\n\n\n\t/**\n\t * Use this method determine the validation groups to pass into\n\t * {@link #validateMethodArguments(Object, Method, MethodParameter[], Object[], Class[])} and\n\t * {@link #validateMethodReturnValue(Object, Method, MethodParameter, Object, Class[])}.\n\t * <p>Default are the validation groups as specified in the {@link Validated}\n\t * annotation on the method, or on the containing target class of the method,\n\t * or for an AOP proxy without a target (with all behavior in advisors), also\n\t * check on proxied interfaces.\n\t * @param target the target Object\n\t * @param method the target method\n\t * @return the applicable validation groups as a {@code Class} array\n\t */\n\tpublic static Class<?>[] determineValidationGroups(Object target, Method method) {\n\t\tValidated validatedAnn = AnnotationUtils.findAnnotation(method, Validated.class);\n\t\tif (validatedAnn == null) {\n\t\t\tif (AopUtils.isAopProxy(target)) {\n\t\t\t\tfor (Class<?> type : AopProxyUtils.proxiedUserInterfaces(target)) {\n\t\t\t\t\tvalidatedAnn = AnnotationUtils.findAnnotation(type, Validated.class);\n\t\t\t\t\tif (validatedAnn != null) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalidatedAnn = AnnotationUtils.findAnnotation(target.getClass(), Validated.class);\n\t\t\t}\n\t\t}\n\t\treturn (validatedAnn != null ? validatedAnn.value() : new Class<?>[0]);\n\t}\n\n\t/**\n\t * Validate the given method arguments and return the result of validation.\n\t * @param target the target Object\n\t * @param method the target method\n\t * @param parameters the parameters, if already created and available\n\t * @param arguments the candidate argument values to validate\n\t * @param groups groups for validation determined via\n\t * {@link #determineValidationGroups(Object, Method)}\n\t * @return a result with {@link ConstraintViolation violations} and\n\t * {@link ParameterValidationResult validationResults}, both possibly empty\n\t * in case there are no violations\n\t */\n\tpublic MethodValidationResult validateMethodArguments(\n\t\t\tObject target, Method method, @Nullable MethodParameter[] parameters, Object[] arguments,\n\t\t\tClass<?>[] groups) {\n\n\t\tExecutableValidator execVal = this.validator.get().forExecutables();\n\t\tSet<ConstraintViolation<Object>> result;\n\t\ttry {\n\t\t\tresult = execVal.validateParameters(target, method, arguments, groups);\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\t// Probably a generic type mismatch between interface and impl as reported in SPR-12237 / HV-1011\n\t\t\t// Let's try to find the bridged method on the implementation class...\n\t\t\tMethod mostSpecificMethod = ClassUtils.getMostSpecificMethod(method, target.getClass());\n\t\t\tMethod bridgedMethod = BridgeMethodResolver.findBridgedMethod(mostSpecificMethod);\n\t\t\tresult = execVal.validateParameters(target, bridgedMethod, arguments, groups);\n\t\t}\n\t\treturn (result.isEmpty() ? EMPTY_RESULT :\n\t\t\t\tcreateException(target, method, result,\n\t\t\t\t\t\ti -> parameters != null ? parameters[i] : new MethodParameter(method, i),\n\t\t\t\t\t\ti -> arguments[i],\n\t\t\t\t\t\tfalse));\n\t}\n\n\t/**\n\t * Validate the given return value and return the result of validation.\n\t * @param target the target Object\n\t * @param method the target method\n\t * @param returnType the return parameter, if already created and available\n\t * @param returnValue the return value to validate\n\t * @param groups groups for validation determined via\n\t * {@link #determineValidationGroups(Object, Method)}\n\t * @return a result with {@link ConstraintViolation violations} and\n\t * {@link ParameterValidationResult validationResults}, both possibly empty\n\t * in case there are no violations\n\t */\n\tpublic MethodValidationResult validateMethodReturnValue(\n\t\t\tObject target, Method method, @Nullable MethodParameter returnType, @Nullable Object returnValue,\n\t\t\tClass<?>[] groups) {\n\n\t\tExecutableValidator execVal = this.validator.get().forExecutables();\n\t\tSet<ConstraintViolation<Object>> result = execVal.validateReturnValue(target, method, returnValue, groups);\n\t\treturn (result.isEmpty() ? EMPTY_RESULT :\n\t\t\t\tcreateException(target, method, result,\n\t\t\t\t\t\ti -> returnType != null ? returnType : new MethodParameter(method, -1),\n\t\t\t\t\t\ti -> returnValue,\n\t\t\t\t\t\ttrue));\n\t}\n\n\tprivate MethodValidationException createException(\n\t\t\tObject target, Method method, Set<ConstraintViolation<Object>> violations,\n\t\t\tFunction<Integer, MethodParameter> parameterFunction, Function<Integer, Object> argumentFunction,\n\t\t\tboolean forReturnValue) {\n\n\t\tMap<MethodParameter, ValueResultBuilder> parameterViolations = new LinkedHashMap<>();\n\t\tMap<Path.Node, BeanResultBuilder> cascadedViolations = new LinkedHashMap<>();\n\n\t\tfor (ConstraintViolation<Object> violation : violations) {\n\t\t\tIterator<Path.Node> itr = violation.getPropertyPath().iterator();\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tPath.Node node = itr.next();\n\n\t\t\t\tMethodParameter parameter;\n\t\t\t\tif (node.getKind().equals(ElementKind.PARAMETER)) {\n\t\t\t\t\tint index = node.as(Path.ParameterNode.class).getParameterIndex();\n\t\t\t\t\tparameter = parameterFunction.apply(index);\n\t\t\t\t}\n\t\t\t\telse if (node.getKind().equals(ElementKind.RETURN_VALUE)) {\n\t\t\t\t\tparameter = parameterFunction.apply(-1);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tparameter.initParameterNameDiscovery(this.parameterNameDiscoverer);\n\n\t\t\t\tObject argument = argumentFunction.apply(parameter.getParameterIndex());\n\t\t\t\tif (!itr.hasNext()) {\n\t\t\t\t\tparameterViolations\n\t\t\t\t\t\t\t.computeIfAbsent(parameter, p -> new ValueResultBuilder(target, parameter, argument))\n\t\t\t\t\t\t\t.addViolation(violation);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcascadedViolations\n\t\t\t\t\t\t\t.computeIfAbsent(node, n -> new BeanResultBuilder(parameter, argument, itr.next()))\n\t\t\t\t\t\t\t.addViolation(violation);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tList<ParameterValidationResult> validatonResultList = new ArrayList<>();\n\t\tparameterViolations.forEach((parameter, builder) -> validatonResultList.add(builder.build()));\n\t\tcascadedViolations.forEach((node, builder) -> validatonResultList.add(builder.build()));\n\t\tvalidatonResultList.sort(RESULT_COMPARATOR);\n\n\t\treturn new MethodValidationException(target, method, violations, validatonResultList, forReturnValue);\n\t}\n\n\t/**\n\t * Create a {@link MessageSourceResolvable} for the given violation.\n\t * @param target target of the method invocation to which validation was applied\n\t * @param parameter the method parameter associated with the violation\n\t * @param violation the violation\n\t * @return the created {@code MessageSourceResolvable}\n\t */\n\tprivate MessageSourceResolvable createMessageSourceResolvable(\n\t\t\tObject target, MethodParameter parameter, ConstraintViolation<Object> violation) {\n\n\t\tString objectName = Conventions.getVariableName(target) + \"#\" + parameter.getExecutable().getName();\n\t\tString paramName = (parameter.getParameterName() != null ? parameter.getParameterName() : \"\");\n\t\tClass<?> parameterType = parameter.getParameterType();\n\n\t\tConstraintDescriptor<?> descriptor = violation.getConstraintDescriptor();\n\t\tString code = descriptor.getAnnotation().annotationType().getSimpleName();\n\t\tString[] codes = this.messageCodesResolver.resolveMessageCodes(code, objectName, paramName, parameterType);\n\t\tObject[] arguments = this.validatorAdapter.get().getArgumentsForConstraint(objectName, paramName, descriptor);\n\n\t\treturn new DefaultMessageSourceResolvable(codes, arguments, violation.getMessage());\n\t}\n\n\t/**\n\t * Select an object name and create a {@link BindingResult} for the argument.\n\t * You can configure a {@link #setBindingResultNameResolver(BindingResultNameResolver)\n\t * bindingResultNameResolver} to determine in a way that matches the specific\n\t * programming model, e.g. {@code @ModelAttribute} or {@code @RequestBody} arguments\n\t * in Spring MVC.\n\t * <p>By default, the name is based on the parameter name, or for a return type on\n\t * {@link Conventions#getVariableNameForReturnType(Method, Class, Object)}.\n\t * <p>If a name cannot be determined for any reason, e.g. a return value with\n\t * insufficient type information, then {@code \"{methodName}.arg{index}\"} is used.\n\t * @param parameter the method parameter\n\t * @param argument the argument value\n\t * @return the determined name\n\t */\n\tprivate BindingResult createBindingResult(MethodParameter parameter, @Nullable Object argument) {\n\t\tString objectName = null;\n\t\tif (this.objectNameResolver != null) {\n\t\t\tobjectName = this.objectNameResolver.resolveName(parameter, argument);\n\t\t}\n\t\telse {\n\t\t\tif (parameter.getParameterIndex() != -1) {\n\t\t\t\tobjectName = parameter.getParameterName();\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\tMethod method = parameter.getMethod();\n\t\t\t\t\tif (method != null) {\n\t\t\t\t\t\tClass<?> containingClass = parameter.getContainingClass();\n\t\t\t\t\t\tClass<?> resolvedType = GenericTypeResolver.resolveReturnType(method, containingClass);\n\t\t\t\t\t\tobjectName = Conventions.getVariableNameForReturnType(method, resolvedType, argument);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\t// insufficient type information\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (objectName == null) {\n\t\t\tint index = parameter.getParameterIndex();\n\t\t\tobjectName = (parameter.getExecutable().getName() + (index != -1 ? \".arg\" + index : \"\"));\n\t\t}\n\t\tBeanPropertyBindingResult result = new BeanPropertyBindingResult(argument, objectName);\n\t\tresult.setMessageCodesResolver(this.messageCodesResolver);\n\t\treturn result;\n\t}\n\n\n\t/**\n\t * Contract to determine the object name of an {@code @Valid} method parameter.\n\t */\n\tpublic interface BindingResultNameResolver {\n\n\t\t/**\n\t\t * Determine the name for the given method parameter.\n\t\t * @param parameter the method parameter\n\t\t * @param value the argument or return value\n\t\t * @return the name to use\n\t\t */\n\t\tString resolveName(MethodParameter parameter, @Nullable Object value);\n\n\t}\n\n\n\t/**\n\t * Builds a validation result for a value method parameter with constraints\n\t * declared directly on it.\n\t */\n\tprivate final class ValueResultBuilder {\n\n\t\tprivate final Object target;\n\n\t\tprivate final MethodParameter parameter;\n\n\t\t@Nullable\n\t\tprivate final Object argument;\n\n\t\tprivate final List<MessageSourceResolvable> resolvableErrors = new ArrayList<>();\n\n\t\tprivate final List<ConstraintViolation<Object>> violations = new ArrayList<>();\n\n\t\tpublic ValueResultBuilder(Object target, MethodParameter parameter, @Nullable Object argument) {\n\t\t\tthis.target = target;\n\t\t\tthis.parameter = parameter;\n\t\t\tthis.argument = argument;\n\t\t}\n\n\t\tpublic void addViolation(ConstraintViolation<Object> violation) {\n\t\t\tthis.resolvableErrors.add(createMessageSourceResolvable(this.target, this.parameter, violation));\n\t\t\tthis.violations.add(violation);\n\t\t}\n\n\t\tpublic ParameterValidationResult build() {\n\t\t\treturn new ParameterValidationResult(\n\t\t\t\t\tthis.parameter, this.argument, this.resolvableErrors, this.violations);\n\t\t}\n\n\t}\n\n\n\t/**\n\t * Builds a validation result for an {@link jakarta.validation.Valid @Valid}\n\t * annotated bean method parameter with cascaded constraints.\n\t */\n\tprivate final class BeanResultBuilder {\n\n\t\tprivate final MethodParameter parameter;\n\n\t\t@Nullable\n\t\tprivate final Object argument;\n\n\t\t@Nullable\n\t\tprivate final Object container;\n\n\t\t@Nullable\n\t\tprivate final Integer containerIndex;\n\n\t\t@Nullable\n\t\tprivate final Object containerKey;\n\n\t\tprivate final Errors errors;\n\n\t\tprivate final Set<ConstraintViolation<Object>> violations = new LinkedHashSet<>();\n\n\t\tpublic BeanResultBuilder(MethodParameter parameter, @Nullable Object argument, Path.Node node) {\n\t\t\tthis.parameter = parameter;\n\n\t\t\tthis.containerIndex = node.getIndex();\n\t\t\tthis.containerKey = node.getKey();\n\t\t\tif (argument instanceof List<?> list && this.containerIndex != null) {\n\t\t\t\tthis.container = list;\n\t\t\t\targument = list.get(this.containerIndex);\n\t\t\t}\n\t\t\telse if (argument instanceof Map<?, ?> map && this.containerKey != null) {\n\t\t\t\tthis.container = map;\n\t\t\t\targument = map.get(this.containerKey);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.container = null;\n\t\t\t}\n\n\t\t\tthis.argument = argument;\n\t\t\tthis.errors = createBindingResult(parameter, argument);\n\t\t}\n\n\t\tpublic void addViolation(ConstraintViolation<Object> violation) {\n\t\t\tthis.violations.add(violation);\n\t\t}\n\n\t\tpublic ParameterErrors build() {\n\t\t\tvalidatorAdapter.get().processConstraintViolations(this.violations, this.errors);\n\t\t\treturn new ParameterErrors(\n\t\t\t\t\tthis.parameter, this.argument, this.errors, this.violations,\n\t\t\t\t\tthis.container, this.containerIndex, this.containerKey);\n\t\t}\n\t}\n\n\n\t/**\n\t * Comparator for validation results, sorted by method parameter index first,\n\t * also falling back on container indexes if necessary for cascaded\n\t * constraints on a List container.\n\t */\n\tprivate final static class ResultComparator implements Comparator<ParameterValidationResult> {\n\n\t\t@Override\n\t\tpublic int compare(ParameterValidationResult result1, ParameterValidationResult result2) {\n\t\t\tint index1 = result1.getMethodParameter().getParameterIndex();\n\t\t\tint index2 = result2.getMethodParameter().getParameterIndex();\n\t\t\tint i = Integer.compare(index1, index2);\n\t\t\tif (i != 0) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\tif (result1 instanceof ParameterErrors errors1 && result2 instanceof ParameterErrors errors2) {\n\t\t\t\tInteger containerIndex1 = errors1.getContainerIndex();\n\t\t\t\tInteger containerIndex2 = errors2.getContainerIndex();\n\t\t\t\tif (containerIndex1 != null && containerIndex2 != null) {\n\t\t\t\t\ti = Integer.compare(containerIndex1, containerIndex2);\n\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti = compareKeys(errors1, errors2);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tprivate <E> int compareKeys(ParameterErrors errors1, ParameterErrors errors2) {\n\t\t\tObject key1 = errors1.getContainerKey();\n\t\t\tObject key2 = errors2.getContainerKey();\n\t\t\tif (key1 instanceof Comparable<?> && key2 instanceof Comparable<?>) {\n\t\t\t\treturn ((Comparable<E>) key1).compareTo((E) key2);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link MethodValidationResult} to use when there are no violations.\n\t */\n\tprivate static final class EmptyMethodValidationResult implements MethodValidationResult {\n\n\t\t@Override\n\t\tpublic Set<ConstraintViolation<?>> getConstraintViolations() {\n\t\t\treturn Collections.emptySet();\n\t\t}\n\n\t\t@Override\n\t\tpublic List<ParameterValidationResult> getAllValidationResults() {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\n\t\t@Override\n\t\tpublic List<ParameterValidationResult> getValueResults() {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\n\t\t@Override\n\t\tpublic List<ParameterErrors> getBeanResults() {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\n\t\t@Override\n\t\tpublic void throwIfViolationsPresent() {\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"MethodValidationResult (0 violations)\";\n\t\t}\n\n\t}\n\n}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#addViolation(violation)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "violation"
    ],
    "position": {
      "column": 1,
      "line": 482
    },
    "return": "void",
    "signature": "public void addViolation(ConstraintViolation<Object> violation)",
    "source_code": "\t\tpublic void addViolation(ConstraintViolation<Object> violation) {\n\t\t\tthis.violations.add(violation);\n\t\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#build()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 486
    },
    "return": "ParameterErrors",
    "signature": "public ParameterErrors build()",
    "source_code": "\t\tpublic ParameterErrors build() {\n\t\t\tvalidatorAdapter.get().processConstraintViolations(this.violations, this.errors);\n\t\t\treturn new ParameterErrors(\n\t\t\t\t\tthis.parameter, this.argument, this.errors, this.violations,\n\t\t\t\t\tthis.container, this.containerIndex, this.containerKey);\n\t\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#compare(result1,result2)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "result1",
      "result2"
    ],
    "position": {
      "column": 1,
      "line": 503
    },
    "return": "int",
    "signature": "public int compare(ParameterValidationResult result1, ParameterValidationResult result2)",
    "source_code": "\t\tpublic int compare(ParameterValidationResult result1, ParameterValidationResult result2) {\n\t\t\tint index1 = result1.getMethodParameter().getParameterIndex();\n\t\t\tint index2 = result2.getMethodParameter().getParameterIndex();\n\t\t\tint i = Integer.compare(index1, index2);\n\t\t\tif (i != 0) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\tif (result1 instanceof ParameterErrors errors1 && result2 instanceof ParameterErrors errors2) {\n\t\t\t\tInteger containerIndex1 = errors1.getContainerIndex();\n\t\t\t\tInteger containerIndex2 = errors2.getContainerIndex();\n\t\t\t\tif (containerIndex1 != null && containerIndex2 != null) {\n\t\t\t\t\ti = Integer.compare(containerIndex1, containerIndex2);\n\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti = compareKeys(errors1, errors2);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#getAllValidationResults()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 548
    },
    "return": "List<ParameterValidationResult>",
    "signature": "public List<ParameterValidationResult> getAllValidationResults()",
    "source_code": "\t\tpublic List<ParameterValidationResult> getAllValidationResults() {\n\t\t\treturn Collections.emptyList();\n\t\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#getBeanResults()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 558
    },
    "return": "List<ParameterErrors>",
    "signature": "public List<ParameterErrors> getBeanResults()",
    "source_code": "\t\tpublic List<ParameterErrors> getBeanResults() {\n\t\t\treturn Collections.emptyList();\n\t\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#getMessageCodesResolver()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link #setMessageCodesResolver(MessageCodesResolver) configured}\n\t * {@code MessageCodesResolver}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "MessageCodesResolver",
    "signature": "public MessageCodesResolver getMessageCodesResolver()",
    "source_code": "\tpublic MessageCodesResolver getMessageCodesResolver() {\n\t\treturn this.messageCodesResolver;\n\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#getParameterNameDiscoverer()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link #setParameterNameDiscoverer(ParameterNameDiscoverer) configured}\n\t * {@code ParameterNameDiscoverer}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "ParameterNameDiscoverer",
    "signature": "public ParameterNameDiscoverer getParameterNameDiscoverer()",
    "source_code": "\tpublic ParameterNameDiscoverer getParameterNameDiscoverer() {\n\t\treturn this.parameterNameDiscoverer;\n\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#getValueResults()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 553
    },
    "return": "List<ParameterValidationResult>",
    "signature": "public List<ParameterValidationResult> getValueResults()",
    "source_code": "\t\tpublic List<ParameterValidationResult> getValueResults() {\n\t\t\treturn Collections.emptyList();\n\t\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#setBindingResultNameResolver(nameResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a resolver for {@link BindingResult} method parameters to match\n\t * the behavior of the higher level programming model, e.g. how the name of\n\t * {@code @ModelAttribute} or {@code @RequestBody} is determined in Spring MVC.\n\t * <p>If this is not configured, then {@link #createBindingResult} will apply\n\t * default behavior to resolve the name to use.\n\t * behavior applies.\n\t * @param nameResolver the resolver to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nameResolver"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "void",
    "signature": "public void setBindingResultNameResolver(BindingResultNameResolver nameResolver)",
    "source_code": "\tpublic void setBindingResultNameResolver(BindingResultNameResolver nameResolver) {\n\t\tthis.objectNameResolver = nameResolver;\n\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#setMessageCodesResolver(messageCodesResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the strategy to use to determine message codes for violations.\n\t * <p>Default is a DefaultMessageCodesResolver.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageCodesResolver"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "void",
    "signature": "public void setMessageCodesResolver(MessageCodesResolver messageCodesResolver)",
    "source_code": "\tpublic void setMessageCodesResolver(MessageCodesResolver messageCodesResolver) {\n\t\tthis.messageCodesResolver = messageCodesResolver;\n\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#setParameterNameDiscoverer(parameterNameDiscoverer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the ParameterNameDiscoverer to use to resolve method parameter names\n\t * that is in turn used to create error codes for {@link MessageSourceResolvable}.\n\t * <p>Default is {@link org.springframework.core.DefaultParameterNameDiscoverer}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterNameDiscoverer"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "void",
    "signature": "public void setParameterNameDiscoverer(ParameterNameDiscoverer parameterNameDiscoverer)",
    "source_code": "\tpublic void setParameterNameDiscoverer(ParameterNameDiscoverer parameterNameDiscoverer) {\n\t\tthis.parameterNameDiscoverer = parameterNameDiscoverer;\n\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#throwIfViolationsPresent()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 563
    },
    "return": "void",
    "signature": "public void throwIfViolationsPresent()",
    "source_code": "\t\tpublic void throwIfViolationsPresent() {\n\t\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 567
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn \"MethodValidationResult (0 violations)\";\n\t\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#validateMethodArguments(target,method,parameters,arguments,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Validate the given method arguments and return the result of validation.\n\t * @param target the target Object\n\t * @param method the target method\n\t * @param parameters the parameters, if already created and available\n\t * @param arguments the candidate argument values to validate\n\t * @param groups groups for validation determined via\n\t * {@link #determineValidationGroups(Object, Method)}\n\t * @return a result with {@link ConstraintViolation violations} and\n\t * {@link ParameterValidationResult validationResults}, both possibly empty\n\t * in case there are no violations\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "parameters",
      "arguments",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "MethodValidationResult",
    "signature": "public MethodValidationResult validateMethodArguments(Object target, Method method, @Nullable MethodParameter[] parameters, Object[] arguments,\n\t\t\tClass<?>[] groups)",
    "source_code": "\tpublic MethodValidationResult validateMethodArguments("
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#validateMethodReturnValue(target,method,returnType,returnValue,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Validate the given return value and return the result of validation.\n\t * @param target the target Object\n\t * @param method the target method\n\t * @param returnType the return parameter, if already created and available\n\t * @param returnValue the return value to validate\n\t * @param groups groups for validation determined via\n\t * {@link #determineValidationGroups(Object, Method)}\n\t * @return a result with {@link ConstraintViolation violations} and\n\t * {@link ParameterValidationResult validationResults}, both possibly empty\n\t * in case there are no violations\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "returnType",
      "returnValue",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "MethodValidationResult",
    "signature": "public MethodValidationResult validateMethodReturnValue(Object target, Method method, @Nullable MethodParameter returnType, @Nullable Object returnValue,\n\t\t\tClass<?>[] groups)",
    "source_code": "\tpublic MethodValidationResult validateMethodReturnValue("
  },
  "org.springframework.web.bind.MethodArgumentNotValidException#formatErrors(errors,messageSource,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors",
      "messageSource",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "List<String>",
    "signature": "public List<String> formatErrors(List<? extends ObjectError> errors, @Nullable MessageSource messageSource, @Nullable Locale locale)",
    "source_code": "\tpublic static List<String> formatErrors("
  },
  "org.springframework.web.bind.MethodArgumentNotValidException#resolveErrorMessages(messageSource,locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve global and field errors to messages with the given\n\t * {@link MessageSource} and {@link Locale}.\n\t * @return a Map with errors as key and resolved messages as value\n\t * @since 6.0.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSource",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "String>",
    "signature": "public String> resolveErrorMessages(MessageSource messageSource, Locale locale)",
    "source_code": "\tpublic Map<ObjectError, String> resolveErrorMessages(MessageSource messageSource, Locale locale) {\n\t\tMap<ObjectError, String> map = new LinkedHashMap<>();\n\t\taddMessages(map, getGlobalErrors(), messageSource, locale);\n\t\taddMessages(map, getFieldErrors(), messageSource, locale);\n\t\treturn map;\n\t}"
  },
  "org.springframework.web.bind.MethodArgumentNotValidException#resolveErrorMessages(source,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve global and field errors to messages with the given\n\t * {@link MessageSource} and {@link Locale}.\n\t * @return a Map with errors as keys and resolved messages as values\n\t * @since 6.0.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "String>",
    "signature": "public String> resolveErrorMessages(MessageSource source, Locale locale)",
    "source_code": "\tpublic Map<ObjectError, String> resolveErrorMessages(MessageSource source, Locale locale) {\n\t\tMap<ObjectError, String> map = new LinkedHashMap<>(getErrorCount());\n\t\tgetGlobalErrors().forEach(error -> map.put(error, formatError(error, source, locale)));\n\t\tgetFieldErrors().forEach(error -> map.put(error, formatError(error, source, locale)));\n\t\treturn map;\n\t}"
  },
  "org.springframework.web.method.HandlerMethod#checkArguments(beanType,parameters)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanType",
      "parameters"
    ],
    "position": {
      "column": 1,
      "line": 666
    },
    "return": "boolean",
    "signature": "public boolean checkArguments(Class<?> beanType, MethodParameter[] parameters)",
    "source_code": "\t\tpublic static boolean checkArguments(Class<?> beanType, MethodParameter[] parameters) {\n\t\t\tif (AnnotationUtils.findAnnotation(beanType, Validated.class) == null) {\n\t\t\t\tfor (MethodParameter parameter : parameters) {\n\t\t\t\t\tMergedAnnotations merged = MergedAnnotations.from(parameter.getParameterAnnotations());\n\t\t\t\t\tif (merged.stream().anyMatch(INPUT_PREDICATE)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.web.method.HandlerMethod#checkReturnValue(beanType,method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanType",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 678
    },
    "return": "boolean",
    "signature": "public boolean checkReturnValue(Class<?> beanType, Method method)",
    "source_code": "\t\tpublic static boolean checkReturnValue(Class<?> beanType, Method method) {\n\t\t\tif (AnnotationUtils.findAnnotation(beanType, Validated.class) == null) {\n\t\t\t\tMergedAnnotations merged = MergedAnnotations.from(method, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY);\n\t\t\t\treturn merged.stream().anyMatch(OUTPUT_PREDICATE);\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.web.method.HandlerMethod#shouldValidateArguments()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the method arguments are a candidate for method validation, which\n\t * is the case when there are parameter {@code jakarta.validation.Constraint}\n\t * annotations.\n\t * <p>The presence of {@code jakarta.validation.Valid} by itself does not\n\t * trigger method validation since such parameters are already validated at\n\t * the level of argument resolvers.\n\t * <p><strong>Note:</strong> if the class is annotated with {@link Validated},\n\t * this method returns false, deferring to method validation via AOP proxy.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 324
    },
    "return": "boolean",
    "signature": "public boolean shouldValidateArguments()",
    "source_code": "\tpublic boolean shouldValidateArguments() {\n\t\treturn this.validateArguments;\n\t}"
  },
  "org.springframework.web.method.HandlerMethod#shouldValidateReturnValue()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the method return value is a candidate for method validation, which\n\t * is the case when there are method {@code jakarta.validation.Constraint}\n\t * or {@code jakarta.validation.Valid} annotations.\n\t * <p><strong>Note:</strong> if the class is annotated with {@link Validated},\n\t * this method returns false, deferring to method validation via AOP proxy.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 336
    },
    "return": "boolean",
    "signature": "public boolean shouldValidateReturnValue()",
    "source_code": "\tpublic boolean shouldValidateReturnValue() {\n\t\treturn this.validateReturnValue;\n\t}"
  },
  "org.springframework.web.method.annotation.HandlerMethodValidator": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link org.springframework.validation.beanvalidation.MethodValidator} for\n * use with {@code @RequestMapping} methods. Helps to determine object names\n * and populates {@link BindingResult} method arguments with errors from\n * {@link MethodValidationResult#getBeanResults() beanResults}.\n *\n * @author Rossen Stoyanchev\n * @since 6.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public class HandlerMethodValidator",
    "source_code": "public final class HandlerMethodValidator extends DefaultMethodValidator {\n\n\tprivate HandlerMethodValidator(MethodValidationAdapter adapter) {\n\t\tsuper(adapter);\n\t}\n\n\n\t@Override\n\tprotected void handleArgumentsValidationResult(\n\t\t\tObject bean, Method method, Object[] arguments, Class<?>[] groups, MethodValidationResult result) {\n\n\t\tif (result.getConstraintViolations().isEmpty()) {\n\t\t\treturn;\n\t\t}\n\t\tif (!result.getBeanResults().isEmpty()) {\n\t\t\tint bindingResultCount = 0;\n\t\t\tfor (ParameterErrors errors : result.getBeanResults()) {\n\t\t\t\tfor (Object arg : arguments) {\n\t\t\t\t\tif (arg instanceof BindingResult bindingResult) {\n\t\t\t\t\t\tif (bindingResult.getObjectName().equals(errors.getObjectName())) {\n\t\t\t\t\t\t\tbindingResult.addAllErrors(errors);\n\t\t\t\t\t\t\tbindingResultCount++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result.getAllValidationResults().size() == bindingResultCount) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tresult.throwIfViolationsPresent();\n\t}\n\n\tprivate String determineObjectName(MethodParameter param, @Nullable Object argument) {\n\t\tif (param.hasParameterAnnotation(RequestBody.class) || param.hasParameterAnnotation(RequestPart.class)) {\n\t\t\treturn Conventions.getVariableNameForParameter(param);\n\t\t}\n\t\telse {\n\t\t\treturn (param.getParameterIndex() != -1 ?\n\t\t\t\t\tModelFactory.getNameForParameter(param) :\n\t\t\t\t\tModelFactory.getNameForReturnValue(argument, param));\n\t\t}\n\t}\n\n\n\t/**\n\t * Static factory method to create a {@link HandlerMethodValidator} if Bean\n\t * Validation is enabled in Spring MVC or WebFlux.\n\t */\n\t@Nullable\n\tpublic static MethodValidator from(\n\t\t\t@Nullable WebBindingInitializer bindingInitializer,\n\t\t\t@Nullable ParameterNameDiscoverer parameterNameDiscoverer) {\n\n\t\tif (bindingInitializer instanceof ConfigurableWebBindingInitializer configurableInitializer) {\n\t\t\tif (configurableInitializer.getValidator() instanceof Validator validator) {\n\t\t\t\tMethodValidationAdapter adapter = new MethodValidationAdapter(validator);\n\t\t\t\tif (parameterNameDiscoverer != null) {\n\t\t\t\t\tadapter.setParameterNameDiscoverer(parameterNameDiscoverer);\n\t\t\t\t}\n\t\t\t\tMessageCodesResolver codesResolver = configurableInitializer.getMessageCodesResolver();\n\t\t\t\tif (codesResolver != null) {\n\t\t\t\t\tadapter.setMessageCodesResolver(codesResolver);\n\t\t\t\t}\n\t\t\t\tHandlerMethodValidator methodValidator = new HandlerMethodValidator(adapter);\n\t\t\t\tadapter.setBindingResultNameResolver(methodValidator::determineObjectName);\n\t\t\t\treturn methodValidator;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n}"
  },
  "org.springframework.web.method.annotation.HandlerMethodValidator#from(bindingInitializer,parameterNameDiscoverer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create a {@link HandlerMethodValidator} if Bean\n\t * Validation is enabled in Spring MVC or WebFlux.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bindingInitializer",
      "parameterNameDiscoverer"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "MethodValidator",
    "signature": "public MethodValidator from(@Nullable WebBindingInitializer bindingInitializer,\n\t\t\t@Nullable ParameterNameDiscoverer parameterNameDiscoverer)",
    "source_code": "\tpublic static MethodValidator from("
  },
  "org.springframework.web.method.annotation.HandlerMethodValidator#handleArgumentsValidationResult(bean,method,arguments,groups,result)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "method",
      "arguments",
      "groups",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "void",
    "signature": "protected void handleArgumentsValidationResult(Object bean, Method method, Object[] arguments, Class<?>[] groups, MethodValidationResult result)",
    "source_code": "\tprotected void handleArgumentsValidationResult("
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#getParameterAnnotations()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 508
    },
    "return": "Annotation[]",
    "signature": "public Annotation[] getParameterAnnotations()",
    "source_code": "\t\tpublic Annotation[] getParameterAnnotations() {\n\t\t\tAnnotation[] anns = this.combinedAnnotations;\n\t\t\tif (anns == null) {\n\t\t\t\tanns = super.getParameterAnnotations();\n\t\t\t\ttry {\n\t\t\t\t\tField field = getDeclaringClass().getDeclaredField(this.parameterName);\n\t\t\t\t\tAnnotation[] fieldAnns = field.getAnnotations();\n\t\t\t\t\tif (fieldAnns.length > 0) {\n\t\t\t\t\t\tList<Annotation> merged = new ArrayList<>(anns.length + fieldAnns.length);\n\t\t\t\t\t\tmerged.addAll(Arrays.asList(anns));\n\t\t\t\t\t\tfor (Annotation fieldAnn : fieldAnns) {\n\t\t\t\t\t\t\tboolean existingType = false;\n\t\t\t\t\t\t\tfor (Annotation ann : anns) {\n\t\t\t\t\t\t\t\tif (ann.annotationType() == fieldAnn.annotationType()) {\n\t\t\t\t\t\t\t\t\texistingType = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!existingType) {\n\t\t\t\t\t\t\t\tmerged.add(fieldAnn);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tanns = merged.toArray(new Annotation[0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchFieldException | SecurityException ex) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t\tthis.combinedAnnotations = anns;\n\t\t\t}\n\t\t\treturn anns;\n\t\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#getParameterName()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 542
    },
    "return": "String",
    "signature": "public String getParameterName()",
    "source_code": "\t\tpublic String getParameterName() {\n\t\t\treturn this.parameterName;\n\t\t}"
  },
  "org.springframework.web.method.support.InvocableHandlerMethod#setMethodValidator(methodValidator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link MethodValidator} to perform method validation with if the\n\t * controller method {@link #shouldValidateArguments()} or\n\t * {@link #shouldValidateReturnValue()}.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodValidator"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "void",
    "signature": "public void setMethodValidator(@Nullable MethodValidator methodValidator)",
    "source_code": "\tpublic void setMethodValidator(@Nullable MethodValidator methodValidator) {\n\t\tthis.methodValidator = methodValidator;\n\t}"
  },
  "org.springframework.web.reactive.result.method.InvocableHandlerMethod#setMethodValidator(methodValidator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link MethodValidator} to perform method validation with if the\n\t * controller method {@link #shouldValidateArguments()} or\n\t * {@link #shouldValidateReturnValue()}.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodValidator"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "void",
    "signature": "public void setMethodValidator(@Nullable MethodValidator methodValidator)",
    "source_code": "\tpublic void setMethodValidator(@Nullable MethodValidator methodValidator) {\n\t\tthis.methodValidator = methodValidator;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#observationConvention(observationConvention)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a {@link ServerRequestObservationConvention} to use for server observations.\n\t * By default, a {@link DefaultServerRequestObservationConvention} will be used.\n\t * @param observationConvention the convention to use for all recorded observations\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "observationConvention"
    ],
    "position": {
      "column": 1,
      "line": 390
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder observationConvention(ServerRequestObservationConvention observationConvention)",
    "source_code": "\tpublic WebHttpHandlerBuilder observationConvention(ServerRequestObservationConvention observationConvention) {\n\t\tthis.observationConvention = observationConvention;\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#observationRegistry(observationRegistry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a {@link ObservationRegistry} for recording server exchange observations.\n\t * By default, a {@link ObservationRegistry#NOOP no-op} registry will be configured.\n\t * @param observationRegistry the observation registry\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "observationRegistry"
    ],
    "position": {
      "column": 1,
      "line": 379
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder observationRegistry(ObservationRegistry observationRegistry)",
    "source_code": "\tpublic WebHttpHandlerBuilder observationRegistry(ObservationRegistry observationRegistry) {\n\t\tthis.observationRegistry = observationRegistry;\n\t\treturn this;\n\t}"
  }
}