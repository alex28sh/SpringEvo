{
  "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactory#findAspectJAnnotationOnMethod(method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find and return the first AspectJ annotation on the given method\n\t * (there <i>should</i> only be one anyway...).\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "AspectJAnnotation",
    "signature": "protected AspectJAnnotation findAspectJAnnotationOnMethod(Method method)",
    "source_code": "\tprotected static AspectJAnnotation findAspectJAnnotationOnMethod(Method method) {\n\t\tfor (Class<?> annotationType : ASPECTJ_ANNOTATION_CLASSES) {\n\t\t\tAspectJAnnotation annotation = findAnnotation(method, (Class<Annotation>) annotationType);\n\t\t\tif (annotation != null) {\n\t\t\t\treturn annotation;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactory#getAnnotation()": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "Annotation",
    "signature": "public Annotation getAnnotation()",
    "source_code": "\t\tpublic Annotation getAnnotation() {\n\t\t\treturn this.annotation;\n\t\t}"
  },
  "org.springframework.aop.framework.autoproxy.BeanFactoryAdvisorRetrievalHelper": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Helper for retrieving standard Spring Advisors from a BeanFactory,\n * for use with auto-proxying.\n *\n * @author Juergen Hoeller\n * @since 2.0.2\n * @see AbstractAdvisorAutoProxyCreator\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "signature": "public class BeanFactoryAdvisorRetrievalHelper",
    "source_code": "public class BeanFactoryAdvisorRetrievalHelper {\n\n\tprivate static final Log logger = LogFactory.getLog(BeanFactoryAdvisorRetrievalHelper.class);\n\n\tprivate final ConfigurableListableBeanFactory beanFactory;\n\n\t@Nullable\n\tprivate volatile String[] cachedAdvisorBeanNames;\n\n\n\t/**\n\t * Create a new BeanFactoryAdvisorRetrievalHelper for the given BeanFactory.\n\t * @param beanFactory the ListableBeanFactory to scan\n\t */\n\tpublic BeanFactoryAdvisorRetrievalHelper(ConfigurableListableBeanFactory beanFactory) {\n\t\tAssert.notNull(beanFactory, \"ListableBeanFactory must not be null\");\n\t\tthis.beanFactory = beanFactory;\n\t}\n\n\n\t/**\n\t * Find all eligible Advisor beans in the current bean factory,\n\t * ignoring FactoryBeans and excluding beans that are currently in creation.\n\t * @return the list of {@link org.springframework.aop.Advisor} beans\n\t * @see #isEligibleBean\n\t */\n\tpublic List<Advisor> findAdvisorBeans() {\n\t\t// Determine list of advisor bean names, if not cached already.\n\t\tString[] advisorNames = this.cachedAdvisorBeanNames;\n\t\tif (advisorNames == null) {\n\t\t\t// Do not initialize FactoryBeans here: We need to leave all regular beans\n\t\t\t// uninitialized to let the auto-proxy creator apply to them!\n\t\t\tadvisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(\n\t\t\t\t\tthis.beanFactory, Advisor.class, true, false);\n\t\t\tthis.cachedAdvisorBeanNames = advisorNames;\n\t\t}\n\t\tif (advisorNames.length == 0) {\n\t\t\treturn new ArrayList<>();\n\t\t}\n\n\t\tList<Advisor> advisors = new ArrayList<>();\n\t\tfor (String name : advisorNames) {\n\t\t\tif (isEligibleBean(name)) {\n\t\t\t\tif (this.beanFactory.isCurrentlyInCreation(name)) {\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Skipping currently created advisor '\" + name + \"'\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tadvisors.add(this.beanFactory.getBean(name, Advisor.class));\n\t\t\t\t\t}\n\t\t\t\t\tcatch (BeanCreationException ex) {\n\t\t\t\t\t\tThrowable rootCause = ex.getMostSpecificCause();\n\t\t\t\t\t\tif (rootCause instanceof BeanCurrentlyInCreationException bce) {\n\t\t\t\t\t\t\tString bceBeanName = bce.getBeanName();\n\t\t\t\t\t\t\tif (bceBeanName != null && this.beanFactory.isCurrentlyInCreation(bceBeanName)) {\n\t\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.trace(\"Skipping advisor '\" + name +\n\t\t\t\t\t\t\t\t\t\t\t\"' with dependency on currently created bean: \" + ex.getMessage());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Ignore: indicates a reference back to the bean we're trying to advise.\n\t\t\t\t\t\t\t\t// We want to find advisors other than the currently created bean itself.\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn advisors;\n\t}\n\n\t/**\n\t * Determine whether the aspect bean with the given name is eligible.\n\t * <p>The default implementation always returns {@code true}.\n\t * @param beanName the name of the aspect bean\n\t * @return whether the bean is eligible\n\t */\n\tprotected boolean isEligibleBean(String beanName) {\n\t\treturn true;\n\t}\n\n}"
  },
  "org.springframework.aop.framework.autoproxy.BeanFactoryAdvisorRetrievalHelper#findAdvisorBeans()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find all eligible Advisor beans in the current bean factory,\n\t * ignoring FactoryBeans and excluding beans that are currently in creation.\n\t * @return the list of {@link org.springframework.aop.Advisor} beans\n\t * @see #isEligibleBean\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "List<Advisor>",
    "signature": "public List<Advisor> findAdvisorBeans()",
    "source_code": "\tpublic List<Advisor> findAdvisorBeans() {\n\t\t// Determine list of advisor bean names, if not cached already.\n\t\tString[] advisorNames = this.cachedAdvisorBeanNames;\n\t\tif (advisorNames == null) {\n\t\t\t// Do not initialize FactoryBeans here: We need to leave all regular beans\n\t\t\t// uninitialized to let the auto-proxy creator apply to them!\n\t\t\tadvisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(\n\t\t\t\t\tthis.beanFactory, Advisor.class, true, false);\n\t\t\tthis.cachedAdvisorBeanNames = advisorNames;\n\t\t}\n\t\tif (advisorNames.length == 0) {\n\t\t\treturn new ArrayList<>();\n\t\t}\n\n\t\tList<Advisor> advisors = new ArrayList<>();\n\t\tfor (String name : advisorNames) {\n\t\t\tif (isEligibleBean(name)) {\n\t\t\t\tif (this.beanFactory.isCurrentlyInCreation(name)) {\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Skipping currently created advisor '\" + name + \"'\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tadvisors.add(this.beanFactory.getBean(name, Advisor.class));\n\t\t\t\t\t}\n\t\t\t\t\tcatch (BeanCreationException ex) {\n\t\t\t\t\t\tThrowable rootCause = ex.getMostSpecificCause();\n\t\t\t\t\t\tif (rootCause instanceof BeanCurrentlyInCreationException bce) {\n\t\t\t\t\t\t\tString bceBeanName = bce.getBeanName();\n\t\t\t\t\t\t\tif (bceBeanName != null && this.beanFactory.isCurrentlyInCreation(bceBeanName)) {\n\t\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.trace(\"Skipping advisor '\" + name +\n\t\t\t\t\t\t\t\t\t\t\t\"' with dependency on currently created bean: \" + ex.getMessage());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Ignore: indicates a reference back to the bean we're trying to advise.\n\t\t\t\t\t\t\t\t// We want to find advisors other than the currently created bean itself.\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn advisors;\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.BeanFactoryAdvisorRetrievalHelper#isEligibleBean(beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the aspect bean with the given name is eligible.\n\t * <p>The default implementation always returns {@code true}.\n\t * @param beanName the name of the aspect bean\n\t * @return whether the bean is eligible\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "boolean",
    "signature": "protected boolean isEligibleBean(String beanName)",
    "source_code": "\tprotected boolean isEligibleBean(String beanName) {\n\t\treturn true;\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#cloneBeanDefinition()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1935
    },
    "return": "RootBeanDefinition",
    "signature": "public RootBeanDefinition cloneBeanDefinition()",
    "source_code": "\t\tpublic RootBeanDefinition cloneBeanDefinition() {\n\t\t\treturn new CreateFromClassBeanDefinition(this);\n\t\t}"
  },
  "org.springframework.core.io.AbstractResource": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Convenience base class for {@link Resource} implementations,\n * pre-implementing typical behavior.\n *\n * <p>The \"exists\" method will check whether a File or InputStream can\n * be opened; \"isOpen\" will always return false; \"getURL\" and \"getFile\"\n * throw an exception; and \"toString\" will return the description.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 28.12.2003\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public class AbstractResource",
    "source_code": "public abstract class AbstractResource implements Resource {\n\n\t/**\n\t * This implementation checks whether a File can be opened,\n\t * falling back to whether an InputStream can be opened.\n\t * <p>This will cover both directories and content resources.\n\t */\n\t@Override\n\tpublic boolean exists() {\n\t\t// Try file existence: can we find the file in the file system?\n\t\tif (isFile()) {\n\t\t\ttry {\n\t\t\t\treturn getFile().exists();\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tdebug(() -> \"Could not retrieve File for existence check of \" + getDescription(), ex);\n\t\t\t}\n\t\t}\n\t\t// Fall back to stream existence: can we open the stream?\n\t\ttry {\n\t\t\tgetInputStream().close();\n\t\t\treturn true;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tdebug(() -> \"Could not retrieve InputStream for existence check of \" + getDescription(), ex);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * This implementation always returns {@code true} for a resource\n\t * that {@link #exists() exists} (revised as of 5.1).\n\t */\n\t@Override\n\tpublic boolean isReadable() {\n\t\treturn exists();\n\t}\n\n\t/**\n\t * This implementation always returns {@code false}.\n\t */\n\t@Override\n\tpublic boolean isOpen() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * This implementation always returns {@code false}.\n\t */\n\t@Override\n\tpublic boolean isFile() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * This implementation throws a FileNotFoundException, assuming\n\t * that the resource cannot be resolved to a URL.\n\t */\n\t@Override\n\tpublic URL getURL() throws IOException {\n\t\tthrow new FileNotFoundException(getDescription() + \" cannot be resolved to URL\");\n\t}\n\n\t/**\n\t * This implementation builds a URI based on the URL returned\n\t * by {@link #getURL()}.\n\t */\n\t@Override\n\tpublic URI getURI() throws IOException {\n\t\tURL url = getURL();\n\t\ttry {\n\t\t\treturn ResourceUtils.toURI(url);\n\t\t}\n\t\tcatch (URISyntaxException ex) {\n\t\t\tthrow new IOException(\"Invalid URI [\" + url + \"]\", ex);\n\t\t}\n\t}\n\n\t/**\n\t * This implementation throws a FileNotFoundException, assuming\n\t * that the resource cannot be resolved to an absolute file path.\n\t */\n\t@Override\n\tpublic File getFile() throws IOException {\n\t\tthrow new FileNotFoundException(getDescription() + \" cannot be resolved to absolute file path\");\n\t}\n\n\t/**\n\t * This implementation returns {@link Channels#newChannel(InputStream)}\n\t * with the result of {@link #getInputStream()}.\n\t * <p>This is the same as in {@link Resource}'s corresponding default method\n\t * but mirrored here for efficient JVM-level dispatching in a class hierarchy.\n\t */\n\t@Override\n\tpublic ReadableByteChannel readableChannel() throws IOException {\n\t\treturn Channels.newChannel(getInputStream());\n\t}\n\n\t/**\n\t * This method reads the entire InputStream to determine the content length.\n\t * <p>For a custom subclass of {@code InputStreamResource}, we strongly\n\t * recommend overriding this method with a more optimal implementation, e.g.\n\t * checking File length, or possibly simply returning -1 if the stream can\n\t * only be read once.\n\t * @see #getInputStream()\n\t */\n\t@Override\n\tpublic long contentLength() throws IOException {\n\t\tInputStream is = getInputStream();\n\t\ttry {\n\t\t\tlong size = 0;\n\t\t\tbyte[] buf = new byte[256];\n\t\t\tint read;\n\t\t\twhile ((read = is.read(buf)) != -1) {\n\t\t\t\tsize += read;\n\t\t\t}\n\t\t\treturn size;\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tis.close();\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tdebug(() -> \"Could not close content-length InputStream for \" + getDescription(), ex);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * This implementation checks the timestamp of the underlying File,\n\t * if available.\n\t * @see #getFileForLastModifiedCheck()\n\t */\n\t@Override\n\tpublic long lastModified() throws IOException {\n\t\tFile fileToCheck = getFileForLastModifiedCheck();\n\t\tlong lastModified = fileToCheck.lastModified();\n\t\tif (lastModified == 0L && !fileToCheck.exists()) {\n\t\t\tthrow new FileNotFoundException(getDescription() +\n\t\t\t\t\t\" cannot be resolved in the file system for checking its last-modified timestamp\");\n\t\t}\n\t\treturn lastModified;\n\t}\n\n\t/**\n\t * Determine the File to use for timestamp checking.\n\t * <p>The default implementation delegates to {@link #getFile()}.\n\t * @return the File to use for timestamp checking (never {@code null})\n\t * @throws FileNotFoundException if the resource cannot be resolved as\n\t * an absolute file path, i.e. is not available in a file system\n\t * @throws IOException in case of general resolution/reading failures\n\t */\n\tprotected File getFileForLastModifiedCheck() throws IOException {\n\t\treturn getFile();\n\t}\n\n\t/**\n\t * This implementation throws a FileNotFoundException, assuming\n\t * that relative resources cannot be created for this resource.\n\t */\n\t@Override\n\tpublic Resource createRelative(String relativePath) throws IOException {\n\t\tthrow new FileNotFoundException(\"Cannot create a relative resource for \" + getDescription());\n\t}\n\n\t/**\n\t * This implementation always returns {@code null},\n\t * assuming that this resource type does not have a filename.\n\t */\n\t@Override\n\t@Nullable\n\tpublic String getFilename() {\n\t\treturn null;\n\t}\n\n\n\t/**\n\t * This implementation compares description strings.\n\t * @see #getDescription()\n\t */\n\t@Override\n\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof Resource that &&\n\t\t\t\tgetDescription().equals(that.getDescription())));\n\t}\n\n\t/**\n\t * This implementation returns the description's hash code.\n\t * @see #getDescription()\n\t */\n\t@Override\n\tpublic int hashCode() {\n\t\treturn getDescription().hashCode();\n\t}\n\n\t/**\n\t * This implementation returns the description of this resource.\n\t * @see #getDescription()\n\t */\n\t@Override\n\tpublic String toString() {\n\t\treturn getDescription();\n\t}\n\n\tprivate void debug(Supplier<String> message, Throwable ex) {\n\t\tLog logger = LogFactory.getLog(getClass());\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(message.get(), ex);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.core.io.AbstractResource#contentLength()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This method reads the entire InputStream to determine the content length.\n\t * <p>For a custom subclass of {@code InputStreamResource}, we strongly\n\t * recommend overriding this method with a more optimal implementation, e.g.\n\t * checking File length, or possibly simply returning -1 if the stream can\n\t * only be read once.\n\t * @see #getInputStream()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "long",
    "signature": "public long contentLength()",
    "source_code": "\tpublic long contentLength() throws IOException {\n\t\tInputStream is = getInputStream();\n\t\ttry {\n\t\t\tlong size = 0;\n\t\t\tbyte[] buf = new byte[256];\n\t\t\tint read;\n\t\t\twhile ((read = is.read(buf)) != -1) {\n\t\t\t\tsize += read;\n\t\t\t}\n\t\t\treturn size;\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tis.close();\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tdebug(() -> \"Could not close content-length InputStream for \" + getDescription(), ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.core.io.AbstractResource#createRelative(relativePath)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation throws a FileNotFoundException, assuming\n\t * that relative resources cannot be created for this resource.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "relativePath"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "Resource",
    "signature": "public Resource createRelative(String relativePath)",
    "source_code": "\tpublic Resource createRelative(String relativePath) throws IOException {\n\t\tthrow new FileNotFoundException(\"Cannot create a relative resource for \" + getDescription());\n\t}"
  },
  "org.springframework.core.io.AbstractResource#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation compares description strings.\n\t * @see #getDescription()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof Resource that &&\n\t\t\t\tgetDescription().equals(that.getDescription())));\n\t}"
  },
  "org.springframework.core.io.AbstractResource#exists()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation checks whether a File can be opened,\n\t * falling back to whether an InputStream can be opened.\n\t * <p>This will cover both directories and content resources.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "boolean",
    "signature": "public boolean exists()",
    "source_code": "\tpublic boolean exists() {\n\t\t// Try file existence: can we find the file in the file system?\n\t\tif (isFile()) {\n\t\t\ttry {\n\t\t\t\treturn getFile().exists();\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tdebug(() -> \"Could not retrieve File for existence check of \" + getDescription(), ex);\n\t\t\t}\n\t\t}\n\t\t// Fall back to stream existence: can we open the stream?\n\t\ttry {\n\t\t\tgetInputStream().close();\n\t\t\treturn true;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tdebug(() -> \"Could not retrieve InputStream for existence check of \" + getDescription(), ex);\n\t\t\treturn false;\n\t\t}\n\t}"
  },
  "org.springframework.core.io.AbstractResource#getFile()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation throws a FileNotFoundException, assuming\n\t * that the resource cannot be resolved to an absolute file path.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "File",
    "signature": "public File getFile()",
    "source_code": "\tpublic File getFile() throws IOException {\n\t\tthrow new FileNotFoundException(getDescription() + \" cannot be resolved to absolute file path\");\n\t}"
  },
  "org.springframework.core.io.AbstractResource#getFileForLastModifiedCheck()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the File to use for timestamp checking.\n\t * <p>The default implementation delegates to {@link #getFile()}.\n\t * @return the File to use for timestamp checking (never {@code null})\n\t * @throws FileNotFoundException if the resource cannot be resolved as\n\t * an absolute file path, i.e. is not available in a file system\n\t * @throws IOException in case of general resolution/reading failures\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "File",
    "signature": "protected File getFileForLastModifiedCheck()",
    "source_code": "\tprotected File getFileForLastModifiedCheck() throws IOException {\n\t\treturn getFile();\n\t}"
  },
  "org.springframework.core.io.AbstractResource#getFilename()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation always returns {@code null},\n\t * assuming that this resource type does not have a filename.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "String",
    "signature": "public String getFilename()",
    "source_code": "\tpublic String getFilename() {\n\t\treturn null;\n\t}"
  },
  "org.springframework.core.io.AbstractResource#getURI()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation builds a URI based on the URL returned\n\t * by {@link #getURL()}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "URI",
    "signature": "public URI getURI()",
    "source_code": "\tpublic URI getURI() throws IOException {\n\t\tURL url = getURL();\n\t\ttry {\n\t\t\treturn ResourceUtils.toURI(url);\n\t\t}\n\t\tcatch (URISyntaxException ex) {\n\t\t\tthrow new IOException(\"Invalid URI [\" + url + \"]\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.core.io.AbstractResource#getURL()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation throws a FileNotFoundException, assuming\n\t * that the resource cannot be resolved to a URL.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "URL",
    "signature": "public URL getURL()",
    "source_code": "\tpublic URL getURL() throws IOException {\n\t\tthrow new FileNotFoundException(getDescription() + \" cannot be resolved to URL\");\n\t}"
  },
  "org.springframework.core.io.AbstractResource#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns the description's hash code.\n\t * @see #getDescription()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn getDescription().hashCode();\n\t}"
  },
  "org.springframework.core.io.AbstractResource#isFile()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation always returns {@code false}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "boolean",
    "signature": "public boolean isFile()",
    "source_code": "\tpublic boolean isFile() {\n\t\treturn false;\n\t}"
  },
  "org.springframework.core.io.AbstractResource#isOpen()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation always returns {@code false}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "boolean",
    "signature": "public boolean isOpen()",
    "source_code": "\tpublic boolean isOpen() {\n\t\treturn false;\n\t}"
  },
  "org.springframework.core.io.AbstractResource#isReadable()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation always returns {@code true} for a resource\n\t * that {@link #exists() exists} (revised as of 5.1).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "boolean",
    "signature": "public boolean isReadable()",
    "source_code": "\tpublic boolean isReadable() {\n\t\treturn exists();\n\t}"
  },
  "org.springframework.core.io.AbstractResource#lastModified()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation checks the timestamp of the underlying File,\n\t * if available.\n\t * @see #getFileForLastModifiedCheck()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "long",
    "signature": "public long lastModified()",
    "source_code": "\tpublic long lastModified() throws IOException {\n\t\tFile fileToCheck = getFileForLastModifiedCheck();\n\t\tlong lastModified = fileToCheck.lastModified();\n\t\tif (lastModified == 0L && !fileToCheck.exists()) {\n\t\t\tthrow new FileNotFoundException(getDescription() +\n\t\t\t\t\t\" cannot be resolved in the file system for checking its last-modified timestamp\");\n\t\t}\n\t\treturn lastModified;\n\t}"
  },
  "org.springframework.core.io.AbstractResource#readableChannel()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns {@link Channels#newChannel(InputStream)}\n\t * with the result of {@link #getInputStream()}.\n\t * <p>This is the same as in {@link Resource}'s corresponding default method\n\t * but mirrored here for efficient JVM-level dispatching in a class hierarchy.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "ReadableByteChannel",
    "signature": "public ReadableByteChannel readableChannel()",
    "source_code": "\tpublic ReadableByteChannel readableChannel() throws IOException {\n\t\treturn Channels.newChannel(getInputStream());\n\t}"
  },
  "org.springframework.core.io.AbstractResource#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns the description of this resource.\n\t * @see #getDescription()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn getDescription();\n\t}"
  },
  "org.springframework.core.io.ByteArrayResource": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link Resource} implementation for a given byte array.\n * <p>Creates a {@link ByteArrayInputStream} for the given byte array.\n *\n * <p>Useful for loading content from any given byte array,\n * without having to resort to a single-use {@link InputStreamResource}.\n * Particularly useful for creating mail attachments from local content,\n * where JavaMail needs to be able to read the stream multiple times.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 1.2.3\n * @see java.io.ByteArrayInputStream\n * @see InputStreamResource\n * @see org.springframework.mail.javamail.MimeMessageHelper#addAttachment(String, InputStreamSource)\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "signature": "public class ByteArrayResource",
    "source_code": "public class ByteArrayResource extends AbstractResource {\n\n\tprivate final byte[] byteArray;\n\n\tprivate final String description;\n\n\n\t/**\n\t * Create a new {@code ByteArrayResource}.\n\t * @param byteArray the byte array to wrap\n\t */\n\tpublic ByteArrayResource(byte[] byteArray) {\n\t\tthis(byteArray, \"resource loaded from byte array\");\n\t}\n\n\t/**\n\t * Create a new {@code ByteArrayResource} with a description.\n\t * @param byteArray the byte array to wrap\n\t * @param description where the byte array comes from\n\t */\n\tpublic ByteArrayResource(byte[] byteArray, @Nullable String description) {\n\t\tAssert.notNull(byteArray, \"Byte array must not be null\");\n\t\tthis.byteArray = byteArray;\n\t\tthis.description = (description != null ? description : \"\");\n\t}\n\n\n\t/**\n\t * Return the underlying byte array.\n\t */\n\tpublic final byte[] getByteArray() {\n\t\treturn this.byteArray;\n\t}\n\n\t/**\n\t * This implementation always returns {@code true}.\n\t */\n\t@Override\n\tpublic boolean exists() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * This implementation returns the length of the underlying byte array.\n\t */\n\t@Override\n\tpublic long contentLength() {\n\t\treturn this.byteArray.length;\n\t}\n\n\t/**\n\t * This implementation returns a ByteArrayInputStream for the\n\t * underlying byte array.\n\t * @see java.io.ByteArrayInputStream\n\t */\n\t@Override\n\tpublic InputStream getInputStream() throws IOException {\n\t\treturn new ByteArrayInputStream(this.byteArray);\n\t}\n\n\t@Override\n\tpublic byte[] getContentAsByteArray() throws IOException {\n\t\tint length = this.byteArray.length;\n\t\tbyte[] result = new byte[length];\n\t\tSystem.arraycopy(this.byteArray, 0, result, 0, length);\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic String getContentAsString(Charset charset) throws IOException {\n\t\treturn new String(this.byteArray, charset);\n\t}\n\n\t/**\n\t * This implementation returns a description that includes the passed-in\n\t * {@code description}, if any.\n\t */\n\t@Override\n\tpublic String getDescription() {\n\t\treturn \"Byte array resource [\" + this.description + \"]\";\n\t}\n\n\n\t/**\n\t * This implementation compares the underlying byte array.\n\t * @see java.util.Arrays#equals(byte[], byte[])\n\t */\n\t@Override\n\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof ByteArrayResource that &&\n\t\t\t\tArrays.equals(this.byteArray, that.byteArray)));\n\t}\n\n\t/**\n\t * This implementation returns the hash code based on the\n\t * underlying byte array.\n\t */\n\t@Override\n\tpublic int hashCode() {\n\t\treturn Arrays.hashCode(this.byteArray);\n\t}\n\n}"
  },
  "org.springframework.core.io.ByteArrayResource#contentLength()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns the length of the underlying byte array.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "long",
    "signature": "public long contentLength()",
    "source_code": "\tpublic long contentLength() {\n\t\treturn this.byteArray.length;\n\t}"
  },
  "org.springframework.core.io.ByteArrayResource#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation compares the underlying byte array.\n\t * @see java.util.Arrays#equals(byte[], byte[])\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof ByteArrayResource that &&\n\t\t\t\tArrays.equals(this.byteArray, that.byteArray)));\n\t}"
  },
  "org.springframework.core.io.ByteArrayResource#exists()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation always returns {@code true}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "boolean",
    "signature": "public boolean exists()",
    "source_code": "\tpublic boolean exists() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.core.io.ByteArrayResource#getByteArray()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the underlying byte array.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "byte[]",
    "signature": "public byte[] getByteArray()",
    "source_code": "\tpublic final byte[] getByteArray() {\n\t\treturn this.byteArray;\n\t}"
  },
  "org.springframework.core.io.ByteArrayResource#getContentAsByteArray()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "byte[]",
    "signature": "public byte[] getContentAsByteArray()",
    "source_code": "\tpublic byte[] getContentAsByteArray() throws IOException {\n\t\tint length = this.byteArray.length;\n\t\tbyte[] result = new byte[length];\n\t\tSystem.arraycopy(this.byteArray, 0, result, 0, length);\n\t\treturn result;\n\t}"
  },
  "org.springframework.core.io.ByteArrayResource#getContentAsString(charset)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "String",
    "signature": "public String getContentAsString(Charset charset)",
    "source_code": "\tpublic String getContentAsString(Charset charset) throws IOException {\n\t\treturn new String(this.byteArray, charset);\n\t}"
  },
  "org.springframework.core.io.ByteArrayResource#getDescription()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns a description that includes the passed-in\n\t * {@code description}, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "String",
    "signature": "public String getDescription()",
    "source_code": "\tpublic String getDescription() {\n\t\treturn \"Byte array resource [\" + this.description + \"]\";\n\t}"
  },
  "org.springframework.core.io.ByteArrayResource#getInputStream()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns a ByteArrayInputStream for the\n\t * underlying byte array.\n\t * @see java.io.ByteArrayInputStream\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "InputStream",
    "signature": "public InputStream getInputStream()",
    "source_code": "\tpublic InputStream getInputStream() throws IOException {\n\t\treturn new ByteArrayInputStream(this.byteArray);\n\t}"
  },
  "org.springframework.core.io.ByteArrayResource#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns the hash code based on the\n\t * underlying byte array.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn Arrays.hashCode(this.byteArray);\n\t}"
  },
  "org.springframework.core.io.DescriptiveResource": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Simple {@link Resource} implementation that holds a resource description\n * but does not point to an actually readable resource.\n *\n * <p>To be used as placeholder if a {@code Resource} argument is\n * expected by an API but not necessarily used for actual reading.\n *\n * @author Juergen Hoeller\n * @since 1.2.6\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 35
    },
    "signature": "public class DescriptiveResource",
    "source_code": "public class DescriptiveResource extends AbstractResource {\n\n\tprivate final String description;\n\n\n\t/**\n\t * Create a new DescriptiveResource.\n\t * @param description the resource description\n\t */\n\tpublic DescriptiveResource(@Nullable String description) {\n\t\tthis.description = (description != null ? description : \"\");\n\t}\n\n\n\t@Override\n\tpublic boolean exists() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isReadable() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic InputStream getInputStream() throws IOException {\n\t\tthrow new FileNotFoundException(\n\t\t\t\tgetDescription() + \" cannot be opened because it does not point to a readable resource\");\n\t}\n\n\t@Override\n\tpublic String getDescription() {\n\t\treturn this.description;\n\t}\n\n\n\t/**\n\t * This implementation compares the underlying description String.\n\t */\n\t@Override\n\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof DescriptiveResource that &&\n\t\t\t\tthis.description.equals(that.description)));\n\t}\n\n\t/**\n\t * This implementation returns the hash code of the underlying description String.\n\t */\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.description.hashCode();\n\t}\n\n}"
  },
  "org.springframework.core.io.DescriptiveResource#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation compares the underlying description String.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof DescriptiveResource that &&\n\t\t\t\tthis.description.equals(that.description)));\n\t}"
  },
  "org.springframework.core.io.DescriptiveResource#exists()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 50
    },
    "return": "boolean",
    "signature": "public boolean exists()",
    "source_code": "\tpublic boolean exists() {\n\t\treturn false;\n\t}"
  },
  "org.springframework.core.io.DescriptiveResource#getDescription()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "String",
    "signature": "public String getDescription()",
    "source_code": "\tpublic String getDescription() {\n\t\treturn this.description;\n\t}"
  },
  "org.springframework.core.io.DescriptiveResource#getInputStream()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "InputStream",
    "signature": "public InputStream getInputStream()",
    "source_code": "\tpublic InputStream getInputStream() throws IOException {\n\t\tthrow new FileNotFoundException(\n\t\t\t\tgetDescription() + \" cannot be opened because it does not point to a readable resource\");\n\t}"
  },
  "org.springframework.core.io.DescriptiveResource#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns the hash code of the underlying description String.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.description.hashCode();\n\t}"
  },
  "org.springframework.core.io.DescriptiveResource#isReadable()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 55
    },
    "return": "boolean",
    "signature": "public boolean isReadable()",
    "source_code": "\tpublic boolean isReadable() {\n\t\treturn false;\n\t}"
  },
  "org.springframework.core.io.InputStreamResource": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link Resource} implementation for a given {@link InputStream}.\n * <p>Should only be used if no other specific {@code Resource} implementation\n * is applicable. In particular, prefer {@link ByteArrayResource} or any of the\n * file-based {@code Resource} implementations where possible.\n *\n * <p>In contrast to other {@code Resource} implementations, this is a descriptor\n * for an <i>already opened</i> resource - therefore returning {@code true} from\n * {@link #isOpen()}. Do not use an {@code InputStreamResource} if you need to\n * keep the resource descriptor somewhere, or if you need to read from a stream\n * multiple times.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 28.12.2003\n * @see ByteArrayResource\n * @see ClassPathResource\n * @see FileSystemResource\n * @see UrlResource\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "signature": "public class InputStreamResource",
    "source_code": "public class InputStreamResource extends AbstractResource {\n\n\tprivate final InputStream inputStream;\n\n\tprivate final String description;\n\n\tprivate boolean read = false;\n\n\n\t/**\n\t * Create a new InputStreamResource.\n\t * @param inputStream the InputStream to use\n\t */\n\tpublic InputStreamResource(InputStream inputStream) {\n\t\tthis(inputStream, \"resource loaded through InputStream\");\n\t}\n\n\t/**\n\t * Create a new InputStreamResource.\n\t * @param inputStream the InputStream to use\n\t * @param description where the InputStream comes from\n\t */\n\tpublic InputStreamResource(InputStream inputStream, @Nullable String description) {\n\t\tAssert.notNull(inputStream, \"InputStream must not be null\");\n\t\tthis.inputStream = inputStream;\n\t\tthis.description = (description != null ? description : \"\");\n\t}\n\n\n\t/**\n\t * This implementation always returns {@code true}.\n\t */\n\t@Override\n\tpublic boolean exists() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * This implementation always returns {@code true}.\n\t */\n\t@Override\n\tpublic boolean isOpen() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * This implementation throws IllegalStateException if attempting to\n\t * read the underlying stream multiple times.\n\t */\n\t@Override\n\tpublic InputStream getInputStream() throws IOException, IllegalStateException {\n\t\tif (this.read) {\n\t\t\tthrow new IllegalStateException(\"InputStream has already been read - \" +\n\t\t\t\t\t\"do not use InputStreamResource if a stream needs to be read multiple times\");\n\t\t}\n\t\tthis.read = true;\n\t\treturn this.inputStream;\n\t}\n\n\t/**\n\t * This implementation returns a description that includes the passed-in\n\t * description, if any.\n\t */\n\t@Override\n\tpublic String getDescription() {\n\t\treturn \"InputStream resource [\" + this.description + \"]\";\n\t}\n\n\n\t/**\n\t * This implementation compares the underlying InputStream.\n\t */\n\t@Override\n\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof InputStreamResource that &&\n\t\t\t\tthis.inputStream.equals(that.inputStream)));\n\t}\n\n\t/**\n\t * This implementation returns the hash code of the underlying InputStream.\n\t */\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.inputStream.hashCode();\n\t}\n\n}"
  },
  "org.springframework.core.io.InputStreamResource#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation compares the underlying InputStream.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof InputStreamResource that &&\n\t\t\t\tthis.inputStream.equals(that.inputStream)));\n\t}"
  },
  "org.springframework.core.io.InputStreamResource#exists()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation always returns {@code true}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "boolean",
    "signature": "public boolean exists()",
    "source_code": "\tpublic boolean exists() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.core.io.InputStreamResource#getDescription()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns a description that includes the passed-in\n\t * description, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "String",
    "signature": "public String getDescription()",
    "source_code": "\tpublic String getDescription() {\n\t\treturn \"InputStream resource [\" + this.description + \"]\";\n\t}"
  },
  "org.springframework.core.io.InputStreamResource#getInputStream()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation throws IllegalStateException if attempting to\n\t * read the underlying stream multiple times.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "InputStream",
    "signature": "public InputStream getInputStream()",
    "source_code": "\tpublic InputStream getInputStream() throws IOException, IllegalStateException {\n\t\tif (this.read) {\n\t\t\tthrow new IllegalStateException(\"InputStream has already been read - \" +\n\t\t\t\t\t\"do not use InputStreamResource if a stream needs to be read multiple times\");\n\t\t}\n\t\tthis.read = true;\n\t\treturn this.inputStream;\n\t}"
  },
  "org.springframework.core.io.InputStreamResource#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns the hash code of the underlying InputStream.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.inputStream.hashCode();\n\t}"
  },
  "org.springframework.core.io.InputStreamResource#isOpen()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation always returns {@code true}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "boolean",
    "signature": "public boolean isOpen()",
    "source_code": "\tpublic boolean isOpen() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.core.io.PathResource": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link Resource} implementation for {@link java.nio.file.Path} handles,\n * performing all operations and transformations via the {@code Path} API.\n * Supports resolution as a {@link File} and also as a {@link URL}.\n * Implements the extended {@link WritableResource} interface.\n *\n * <p>Note: As of 5.1, {@link java.nio.file.Path} support is also available\n * in {@link FileSystemResource#FileSystemResource(Path) FileSystemResource},\n * applying Spring's standard String-based path transformations but\n * performing all operations via the {@link java.nio.file.Files} API.\n * This {@code PathResource} is effectively a pure {@code java.nio.path.Path}\n * based alternative with different {@code createRelative} behavior.\n *\n * @author Philippe Marschall\n * @author Juergen Hoeller\n * @since 4.0\n * @see java.nio.file.Path\n * @see java.nio.file.Files\n * @see FileSystemResource\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "signature": "public class PathResource",
    "source_code": "public class PathResource extends AbstractResource implements WritableResource {\n\n\tprivate final Path path;\n\n\n\t/**\n\t * Create a new PathResource from a Path handle.\n\t * <p>Note: Unlike {@link FileSystemResource}, when building relative resources\n\t * via {@link #createRelative}, the relative path will be built <i>underneath</i>\n\t * the given root: e.g. Paths.get(\"C:/dir1/\"), relative path \"dir2\" &rarr; \"C:/dir1/dir2\"!\n\t * @param path a Path handle\n\t */\n\tpublic PathResource(Path path) {\n\t\tAssert.notNull(path, \"Path must not be null\");\n\t\tthis.path = path.normalize();\n\t}\n\n\t/**\n\t * Create a new PathResource from a Path handle.\n\t * <p>Note: Unlike {@link FileSystemResource}, when building relative resources\n\t * via {@link #createRelative}, the relative path will be built <i>underneath</i>\n\t * the given root: e.g. Paths.get(\"C:/dir1/\"), relative path \"dir2\" &rarr; \"C:/dir1/dir2\"!\n\t * @param path a path\n\t * @see java.nio.file.Paths#get(String, String...)\n\t */\n\tpublic PathResource(String path) {\n\t\tAssert.notNull(path, \"Path must not be null\");\n\t\tthis.path = Paths.get(path).normalize();\n\t}\n\n\t/**\n\t * Create a new PathResource from a Path handle.\n\t * <p>Note: Unlike {@link FileSystemResource}, when building relative resources\n\t * via {@link #createRelative}, the relative path will be built <i>underneath</i>\n\t * the given root: e.g. Paths.get(\"C:/dir1/\"), relative path \"dir2\" &rarr; \"C:/dir1/dir2\"!\n\t * @param uri a path URI\n\t * @see java.nio.file.Paths#get(URI)\n\t */\n\tpublic PathResource(URI uri) {\n\t\tAssert.notNull(uri, \"URI must not be null\");\n\t\tthis.path = Paths.get(uri).normalize();\n\t}\n\n\n\t/**\n\t * Return the file path for this resource.\n\t */\n\tpublic final String getPath() {\n\t\treturn this.path.toString();\n\t}\n\n\t/**\n\t * This implementation returns whether the underlying file exists.\n\t * @see java.nio.file.Files#exists(Path, java.nio.file.LinkOption...)\n\t */\n\t@Override\n\tpublic boolean exists() {\n\t\treturn Files.exists(this.path);\n\t}\n\n\t/**\n\t * This implementation checks whether the underlying file is marked as readable\n\t * (and corresponds to an actual file with content, not to a directory).\n\t * @see java.nio.file.Files#isReadable(Path)\n\t * @see java.nio.file.Files#isDirectory(Path, java.nio.file.LinkOption...)\n\t */\n\t@Override\n\tpublic boolean isReadable() {\n\t\treturn (Files.isReadable(this.path) && !Files.isDirectory(this.path));\n\t}\n\n\t/**\n\t * This implementation opens a InputStream for the underlying file.\n\t * @see java.nio.file.spi.FileSystemProvider#newInputStream(Path, OpenOption...)\n\t */\n\t@Override\n\tpublic InputStream getInputStream() throws IOException {\n\t\tif (!exists()) {\n\t\t\tthrow new FileNotFoundException(getPath() + \" (no such file or directory)\");\n\t\t}\n\t\tif (Files.isDirectory(this.path)) {\n\t\t\tthrow new FileNotFoundException(getPath() + \" (is a directory)\");\n\t\t}\n\t\treturn Files.newInputStream(this.path);\n\t}\n\n\t@Override\n\tpublic byte[] getContentAsByteArray() throws IOException {\n\t\ttry {\n\t\t\treturn Files.readAllBytes(this.path);\n\t\t}\n\t\tcatch (NoSuchFileException ex) {\n\t\t\tthrow new FileNotFoundException(ex.getMessage());\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getContentAsString(Charset charset) throws IOException {\n\t\ttry {\n\t\t\treturn Files.readString(this.path, charset);\n\t\t}\n\t\tcatch (NoSuchFileException ex) {\n\t\t\tthrow new FileNotFoundException(ex.getMessage());\n\t\t}\n\t}\n\n\t/**\n\t * This implementation checks whether the underlying file is marked as writable\n\t * (and corresponds to an actual file with content, not to a directory).\n\t * @see java.nio.file.Files#isWritable(Path)\n\t * @see java.nio.file.Files#isDirectory(Path, java.nio.file.LinkOption...)\n\t */\n\t@Override\n\tpublic boolean isWritable() {\n\t\treturn (Files.isWritable(this.path) && !Files.isDirectory(this.path));\n\t}\n\n\t/**\n\t * This implementation opens a OutputStream for the underlying file.\n\t * @see java.nio.file.spi.FileSystemProvider#newOutputStream(Path, OpenOption...)\n\t */\n\t@Override\n\tpublic OutputStream getOutputStream() throws IOException {\n\t\tif (Files.isDirectory(this.path)) {\n\t\t\tthrow new FileNotFoundException(getPath() + \" (is a directory)\");\n\t\t}\n\t\treturn Files.newOutputStream(this.path);\n\t}\n\n\t/**\n\t * This implementation returns a URL for the underlying file.\n\t * @see java.nio.file.Path#toUri()\n\t * @see java.net.URI#toURL()\n\t */\n\t@Override\n\tpublic URL getURL() throws IOException {\n\t\treturn this.path.toUri().toURL();\n\t}\n\n\t/**\n\t * This implementation returns a URI for the underlying file.\n\t * @see java.nio.file.Path#toUri()\n\t */\n\t@Override\n\tpublic URI getURI() throws IOException {\n\t\treturn this.path.toUri();\n\t}\n\n\t/**\n\t * This implementation always indicates a file.\n\t */\n\t@Override\n\tpublic boolean isFile() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * This implementation returns the underlying File reference.\n\t */\n\t@Override\n\tpublic File getFile() throws IOException {\n\t\ttry {\n\t\t\treturn this.path.toFile();\n\t\t}\n\t\tcatch (UnsupportedOperationException ex) {\n\t\t\t// Only paths on the default file system can be converted to a File:\n\t\t\t// Do exception translation for cases where conversion is not possible.\n\t\t\tthrow new FileNotFoundException(this.path + \" cannot be resolved to absolute file path\");\n\t\t}\n\t}\n\n\t/**\n\t * This implementation opens a Channel for the underlying file.\n\t * @see Files#newByteChannel(Path, OpenOption...)\n\t */\n\t@Override\n\tpublic ReadableByteChannel readableChannel() throws IOException {\n\t\ttry {\n\t\t\treturn Files.newByteChannel(this.path, StandardOpenOption.READ);\n\t\t}\n\t\tcatch (NoSuchFileException ex) {\n\t\t\tthrow new FileNotFoundException(ex.getMessage());\n\t\t}\n\t}\n\n\t/**\n\t * This implementation opens a Channel for the underlying file.\n\t * @see Files#newByteChannel(Path, OpenOption...)\n\t */\n\t@Override\n\tpublic WritableByteChannel writableChannel() throws IOException {\n\t\treturn Files.newByteChannel(this.path, StandardOpenOption.WRITE);\n\t}\n\n\t/**\n\t * This implementation returns the underlying file's length.\n\t */\n\t@Override\n\tpublic long contentLength() throws IOException {\n\t\treturn Files.size(this.path);\n\t}\n\n\t/**\n\t * This implementation returns the underlying File's timestamp.\n\t * @see java.nio.file.Files#getLastModifiedTime(Path, java.nio.file.LinkOption...)\n\t */\n\t@Override\n\tpublic long lastModified() throws IOException {\n\t\t// We can not use the superclass method since it uses conversion to a File and\n\t\t// only a Path on the default file system can be converted to a File...\n\t\treturn Files.getLastModifiedTime(this.path).toMillis();\n\t}\n\n\t/**\n\t * This implementation creates a PathResource, applying the given path\n\t * relative to the path of the underlying file of this resource descriptor.\n\t * @see java.nio.file.Path#resolve(String)\n\t */\n\t@Override\n\tpublic Resource createRelative(String relativePath) {\n\t\treturn new PathResource(this.path.resolve(relativePath));\n\t}\n\n\t/**\n\t * This implementation returns the name of the file.\n\t * @see java.nio.file.Path#getFileName()\n\t */\n\t@Override\n\tpublic String getFilename() {\n\t\treturn this.path.getFileName().toString();\n\t}\n\n\t@Override\n\tpublic String getDescription() {\n\t\treturn \"path [\" + this.path.toAbsolutePath() + \"]\";\n\t}\n\n\n\t/**\n\t * This implementation compares the underlying Path references.\n\t */\n\t@Override\n\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof PathResource that && this.path.equals(that.path)));\n\t}\n\n\t/**\n\t * This implementation returns the hash code of the underlying Path reference.\n\t */\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.path.hashCode();\n\t}\n\n}"
  },
  "org.springframework.core.io.PathResource#contentLength()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns the underlying file's length.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 257
    },
    "return": "long",
    "signature": "public long contentLength()",
    "source_code": "\tpublic long contentLength() throws IOException {\n\t\treturn Files.size(this.path);\n\t}"
  },
  "org.springframework.core.io.PathResource#createRelative(relativePath)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation creates a PathResource, applying the given path\n\t * relative to the path of the underlying file of this resource descriptor.\n\t * @see java.nio.file.Path#resolve(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "relativePath"
    ],
    "position": {
      "column": 1,
      "line": 278
    },
    "return": "Resource",
    "signature": "public Resource createRelative(String relativePath)",
    "source_code": "\tpublic Resource createRelative(String relativePath) {\n\t\treturn new PathResource(this.path.resolve(relativePath));\n\t}"
  },
  "org.springframework.core.io.PathResource#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation compares the underlying Path references.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 301
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof PathResource that && this.path.equals(that.path)));\n\t}"
  },
  "org.springframework.core.io.PathResource#exists()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns whether the underlying file exists.\n\t * @see java.nio.file.Files#exists(Path, java.nio.file.LinkOption...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "boolean",
    "signature": "public boolean exists()",
    "source_code": "\tpublic boolean exists() {\n\t\treturn Files.exists(this.path);\n\t}"
  },
  "org.springframework.core.io.PathResource#getContentAsByteArray()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "byte[]",
    "signature": "public byte[] getContentAsByteArray()",
    "source_code": "\tpublic byte[] getContentAsByteArray() throws IOException {\n\t\ttry {\n\t\t\treturn Files.readAllBytes(this.path);\n\t\t}\n\t\tcatch (NoSuchFileException ex) {\n\t\t\tthrow new FileNotFoundException(ex.getMessage());\n\t\t}\n\t}"
  },
  "org.springframework.core.io.PathResource#getContentAsString(charset)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "String",
    "signature": "public String getContentAsString(Charset charset)",
    "source_code": "\tpublic String getContentAsString(Charset charset) throws IOException {\n\t\ttry {\n\t\t\treturn Files.readString(this.path, charset);\n\t\t}\n\t\tcatch (NoSuchFileException ex) {\n\t\t\tthrow new FileNotFoundException(ex.getMessage());\n\t\t}\n\t}"
  },
  "org.springframework.core.io.PathResource#getDescription()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "String",
    "signature": "public String getDescription()",
    "source_code": "\tpublic String getDescription() {\n\t\treturn \"path [\" + this.path.toAbsolutePath() + \"]\";\n\t}"
  },
  "org.springframework.core.io.PathResource#getFile()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns the underlying File reference.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "File",
    "signature": "public File getFile()",
    "source_code": "\tpublic File getFile() throws IOException {\n\t\ttry {\n\t\t\treturn this.path.toFile();\n\t\t}\n\t\tcatch (UnsupportedOperationException ex) {\n\t\t\t// Only paths on the default file system can be converted to a File:\n\t\t\t// Do exception translation for cases where conversion is not possible.\n\t\t\tthrow new FileNotFoundException(this.path + \" cannot be resolved to absolute file path\");\n\t\t}\n\t}"
  },
  "org.springframework.core.io.PathResource#getFilename()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns the name of the file.\n\t * @see java.nio.file.Path#getFileName()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "String",
    "signature": "public String getFilename()",
    "source_code": "\tpublic String getFilename() {\n\t\treturn this.path.getFileName().toString();\n\t}"
  },
  "org.springframework.core.io.PathResource#getInputStream()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation opens a InputStream for the underlying file.\n\t * @see java.nio.file.spi.FileSystemProvider#newInputStream(Path, OpenOption...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "InputStream",
    "signature": "public InputStream getInputStream()",
    "source_code": "\tpublic InputStream getInputStream() throws IOException {\n\t\tif (!exists()) {\n\t\t\tthrow new FileNotFoundException(getPath() + \" (no such file or directory)\");\n\t\t}\n\t\tif (Files.isDirectory(this.path)) {\n\t\t\tthrow new FileNotFoundException(getPath() + \" (is a directory)\");\n\t\t}\n\t\treturn Files.newInputStream(this.path);\n\t}"
  },
  "org.springframework.core.io.PathResource#getOutputStream()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation opens a OutputStream for the underlying file.\n\t * @see java.nio.file.spi.FileSystemProvider#newOutputStream(Path, OpenOption...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "OutputStream",
    "signature": "public OutputStream getOutputStream()",
    "source_code": "\tpublic OutputStream getOutputStream() throws IOException {\n\t\tif (Files.isDirectory(this.path)) {\n\t\t\tthrow new FileNotFoundException(getPath() + \" (is a directory)\");\n\t\t}\n\t\treturn Files.newOutputStream(this.path);\n\t}"
  },
  "org.springframework.core.io.PathResource#getPath()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the file path for this resource.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "String",
    "signature": "public String getPath()",
    "source_code": "\tpublic final String getPath() {\n\t\treturn this.path.toString();\n\t}"
  },
  "org.springframework.core.io.PathResource#getURI()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns a URI for the underlying file.\n\t * @see java.nio.file.Path#toUri()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "URI",
    "signature": "public URI getURI()",
    "source_code": "\tpublic URI getURI() throws IOException {\n\t\treturn this.path.toUri();\n\t}"
  },
  "org.springframework.core.io.PathResource#getURL()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns a URL for the underlying file.\n\t * @see java.nio.file.Path#toUri()\n\t * @see java.net.URI#toURL()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "URL",
    "signature": "public URL getURL()",
    "source_code": "\tpublic URL getURL() throws IOException {\n\t\treturn this.path.toUri().toURL();\n\t}"
  },
  "org.springframework.core.io.PathResource#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns the hash code of the underlying Path reference.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.path.hashCode();\n\t}"
  },
  "org.springframework.core.io.PathResource#isFile()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation always indicates a file.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "boolean",
    "signature": "public boolean isFile()",
    "source_code": "\tpublic boolean isFile() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.core.io.PathResource#isReadable()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation checks whether the underlying file is marked as readable\n\t * (and corresponds to an actual file with content, not to a directory).\n\t * @see java.nio.file.Files#isReadable(Path)\n\t * @see java.nio.file.Files#isDirectory(Path, java.nio.file.LinkOption...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "boolean",
    "signature": "public boolean isReadable()",
    "source_code": "\tpublic boolean isReadable() {\n\t\treturn (Files.isReadable(this.path) && !Files.isDirectory(this.path));\n\t}"
  },
  "org.springframework.core.io.PathResource#isWritable()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation checks whether the underlying file is marked as writable\n\t * (and corresponds to an actual file with content, not to a directory).\n\t * @see java.nio.file.Files#isWritable(Path)\n\t * @see java.nio.file.Files#isDirectory(Path, java.nio.file.LinkOption...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "boolean",
    "signature": "public boolean isWritable()",
    "source_code": "\tpublic boolean isWritable() {\n\t\treturn (Files.isWritable(this.path) && !Files.isDirectory(this.path));\n\t}"
  },
  "org.springframework.core.io.PathResource#lastModified()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns the underlying File's timestamp.\n\t * @see java.nio.file.Files#getLastModifiedTime(Path, java.nio.file.LinkOption...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "long",
    "signature": "public long lastModified()",
    "source_code": "\tpublic long lastModified() throws IOException {\n\t\t// We can not use the superclass method since it uses conversion to a File and\n\t\t// only a Path on the default file system can be converted to a File...\n\t\treturn Files.getLastModifiedTime(this.path).toMillis();\n\t}"
  },
  "org.springframework.core.io.PathResource#readableChannel()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation opens a Channel for the underlying file.\n\t * @see Files#newByteChannel(Path, OpenOption...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "ReadableByteChannel",
    "signature": "public ReadableByteChannel readableChannel()",
    "source_code": "\tpublic ReadableByteChannel readableChannel() throws IOException {\n\t\ttry {\n\t\t\treturn Files.newByteChannel(this.path, StandardOpenOption.READ);\n\t\t}\n\t\tcatch (NoSuchFileException ex) {\n\t\t\tthrow new FileNotFoundException(ex.getMessage());\n\t\t}\n\t}"
  },
  "org.springframework.core.io.PathResource#writableChannel()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation opens a Channel for the underlying file.\n\t * @see Files#newByteChannel(Path, OpenOption...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "WritableByteChannel",
    "signature": "public WritableByteChannel writableChannel()",
    "source_code": "\tpublic WritableByteChannel writableChannel() throws IOException {\n\t\treturn Files.newByteChannel(this.path, StandardOpenOption.WRITE);\n\t}"
  },
  "org.springframework.core.io.UrlResource#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation compares the underlying URL references.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 346
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof UrlResource that &&\n\t\t\t\tgetCleanedUrl().equals(that.getCleanedUrl())));\n\t}"
  },
  "org.springframework.core.io.UrlResource#equals(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation compares the underlying URL references.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 346
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof UrlResource resource &&\n\t\t\t\tgetCleanedUrl().equals(resource.getCleanedUrl())));\n\t}"
  },
  "org.springframework.core.io.VfsResource": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * JBoss VFS based {@link Resource} implementation.\n *\n * <p>As of Spring 4.0, this class supports VFS 3.x on JBoss AS 6+\n * (package {@code org.jboss.vfs}) and is in particular compatible with\n * JBoss AS 7 and WildFly 8+.\n *\n * @author Ales Justin\n * @author Juergen Hoeller\n * @author Costin Leau\n * @author Sam Brannen\n * @since 3.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public class VfsResource",
    "source_code": "public class VfsResource extends AbstractResource {\n\n\tprivate final Object resource;\n\n\n\t/**\n\t * Create a new {@code VfsResource} wrapping the given resource handle.\n\t * @param resource a {@code org.jboss.vfs.VirtualFile} instance\n\t * (untyped in order to avoid a static dependency on the VFS API)\n\t */\n\tpublic VfsResource(Object resource) {\n\t\tAssert.notNull(resource, \"VirtualFile must not be null\");\n\t\tthis.resource = resource;\n\t}\n\n\n\t@Override\n\tpublic InputStream getInputStream() throws IOException {\n\t\treturn VfsUtils.getInputStream(this.resource);\n\t}\n\n\t@Override\n\tpublic boolean exists() {\n\t\treturn VfsUtils.exists(this.resource);\n\t}\n\n\t@Override\n\tpublic boolean isReadable() {\n\t\treturn VfsUtils.isReadable(this.resource);\n\t}\n\n\t@Override\n\tpublic URL getURL() throws IOException {\n\t\ttry {\n\t\t\treturn VfsUtils.getURL(this.resource);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new IOException(\"Failed to obtain URL for file \" + this.resource, ex);\n\t\t}\n\t}\n\n\t@Override\n\tpublic URI getURI() throws IOException {\n\t\ttry {\n\t\t\treturn VfsUtils.getURI(this.resource);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new IOException(\"Failed to obtain URI for \" + this.resource, ex);\n\t\t}\n\t}\n\n\t@Override\n\tpublic File getFile() throws IOException {\n\t\treturn VfsUtils.getFile(this.resource);\n\t}\n\n\t@Override\n\tpublic long contentLength() throws IOException {\n\t\treturn VfsUtils.getSize(this.resource);\n\t}\n\n\t@Override\n\tpublic long lastModified() throws IOException {\n\t\treturn VfsUtils.getLastModified(this.resource);\n\t}\n\n\t@Override\n\tpublic Resource createRelative(String relativePath) throws IOException {\n\t\tif (!relativePath.startsWith(\".\") && relativePath.contains(\"/\")) {\n\t\t\ttry {\n\t\t\t\treturn new VfsResource(VfsUtils.getChild(this.resource, relativePath));\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\t// fall back to getRelative\n\t\t\t}\n\t\t}\n\n\t\treturn new VfsResource(VfsUtils.getRelative(ResourceUtils.toRelativeURL(getURL(), relativePath)));\n\t}\n\n\t@Override\n\tpublic String getFilename() {\n\t\treturn VfsUtils.getName(this.resource);\n\t}\n\n\t@Override\n\tpublic String getDescription() {\n\t\treturn \"VFS resource [\" + this.resource + \"]\";\n\t}\n\n\t@Override\n\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof VfsResource that &&\n\t\t\t\tthis.resource.equals(that.resource)));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.resource.hashCode();\n\t}\n\n}"
  },
  "org.springframework.core.io.VfsResource#contentLength()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "long",
    "signature": "public long contentLength()",
    "source_code": "\tpublic long contentLength() throws IOException {\n\t\treturn VfsUtils.getSize(this.resource);\n\t}"
  },
  "org.springframework.core.io.VfsResource#createRelative(relativePath)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "relativePath"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "Resource",
    "signature": "public Resource createRelative(String relativePath)",
    "source_code": "\tpublic Resource createRelative(String relativePath) throws IOException {\n\t\tif (!relativePath.startsWith(\".\") && relativePath.contains(\"/\")) {\n\t\t\ttry {\n\t\t\t\treturn new VfsResource(VfsUtils.getChild(this.resource, relativePath));\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\t// fall back to getRelative\n\t\t\t}\n\t\t}\n\n\t\treturn new VfsResource(VfsUtils.getRelative(ResourceUtils.toRelativeURL(getURL(), relativePath)));\n\t}"
  },
  "org.springframework.core.io.VfsResource#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof VfsResource that &&\n\t\t\t\tthis.resource.equals(that.resource)));\n\t}"
  },
  "org.springframework.core.io.VfsResource#exists()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "boolean",
    "signature": "public boolean exists()",
    "source_code": "\tpublic boolean exists() {\n\t\treturn VfsUtils.exists(this.resource);\n\t}"
  },
  "org.springframework.core.io.VfsResource#getDescription()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "String",
    "signature": "public String getDescription()",
    "source_code": "\tpublic String getDescription() {\n\t\treturn \"VFS resource [\" + this.resource + \"]\";\n\t}"
  },
  "org.springframework.core.io.VfsResource#getFile()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "File",
    "signature": "public File getFile()",
    "source_code": "\tpublic File getFile() throws IOException {\n\t\treturn VfsUtils.getFile(this.resource);\n\t}"
  },
  "org.springframework.core.io.VfsResource#getFilename()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "String",
    "signature": "public String getFilename()",
    "source_code": "\tpublic String getFilename() {\n\t\treturn VfsUtils.getName(this.resource);\n\t}"
  },
  "org.springframework.core.io.VfsResource#getInputStream()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "InputStream",
    "signature": "public InputStream getInputStream()",
    "source_code": "\tpublic InputStream getInputStream() throws IOException {\n\t\treturn VfsUtils.getInputStream(this.resource);\n\t}"
  },
  "org.springframework.core.io.VfsResource#getURI()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "URI",
    "signature": "public URI getURI()",
    "source_code": "\tpublic URI getURI() throws IOException {\n\t\ttry {\n\t\t\treturn VfsUtils.getURI(this.resource);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new IOException(\"Failed to obtain URI for \" + this.resource, ex);\n\t\t}\n\t}"
  },
  "org.springframework.core.io.VfsResource#getURL()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "URL",
    "signature": "public URL getURL()",
    "source_code": "\tpublic URL getURL() throws IOException {\n\t\ttry {\n\t\t\treturn VfsUtils.getURL(this.resource);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new IOException(\"Failed to obtain URL for file \" + this.resource, ex);\n\t\t}\n\t}"
  },
  "org.springframework.core.io.VfsResource#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.resource.hashCode();\n\t}"
  },
  "org.springframework.core.io.VfsResource#isReadable()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "boolean",
    "signature": "public boolean isReadable()",
    "source_code": "\tpublic boolean isReadable() {\n\t\treturn VfsUtils.isReadable(this.resource);\n\t}"
  },
  "org.springframework.core.io.VfsResource#lastModified()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "long",
    "signature": "public long lastModified()",
    "source_code": "\tpublic long lastModified() throws IOException {\n\t\treturn VfsUtils.getLastModified(this.resource);\n\t}"
  },
  "org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Bean post-processor that automatically applies persistence exception translation to any\n * bean marked with Spring's @{@link org.springframework.stereotype.Repository Repository}\n * annotation, adding a corresponding {@link PersistenceExceptionTranslationAdvisor} to\n * the exposed proxy (either an existing AOP proxy or a newly generated proxy that\n * implements all of the target's interfaces).\n *\n * <p>Translates native resource exceptions to Spring's\n * {@link org.springframework.dao.DataAccessException DataAccessException} hierarchy.\n * Autodetects beans that implement the\n * {@link org.springframework.dao.support.PersistenceExceptionTranslator\n * PersistenceExceptionTranslator} interface, which are subsequently asked to translate\n * candidate exceptions.\n *\n * <p>All of Spring's applicable resource factories (e.g.\n * {@link org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean})\n * implement the {@code PersistenceExceptionTranslator} interface out of the box.\n * As a consequence, all that is usually needed to enable automatic exception\n * translation is marking all affected beans (such as Repositories or DAOs)\n * with the {@code @Repository} annotation, along with defining this post-processor\n * as a bean in the application context.\n *\n * <p>As of 5.3, {@code PersistenceExceptionTranslator} beans will be sorted according\n * to Spring's dependency ordering rules: see {@link org.springframework.core.Ordered}\n * and {@link org.springframework.core.annotation.Order}. Note that such beans will\n * get retrieved from any scope, not just singleton scope, as of this 5.3 revision.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 2.0\n * @see PersistenceExceptionTranslationAdvisor\n * @see org.springframework.stereotype.Repository\n * @see org.springframework.dao.DataAccessException\n * @see org.springframework.dao.support.PersistenceExceptionTranslator\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "signature": "public class PersistenceExceptionTranslationPostProcessor",
    "source_code": "public class PersistenceExceptionTranslationPostProcessor extends AbstractBeanFactoryAwareAdvisingPostProcessor {\n\n\tprivate Class<? extends Annotation> repositoryAnnotationType = Repository.class;\n\n\n\t/**\n\t * Set the 'repository' annotation type.\n\t * The default repository annotation type is the {@link Repository} annotation.\n\t * <p>This setter property exists so that developers can provide their own\n\t * (non-Spring-specific) annotation type to indicate that a class has a\n\t * repository role.\n\t * @param repositoryAnnotationType the desired annotation type\n\t */\n\tpublic void setRepositoryAnnotationType(Class<? extends Annotation> repositoryAnnotationType) {\n\t\tAssert.notNull(repositoryAnnotationType, \"'repositoryAnnotationType' must not be null\");\n\t\tthis.repositoryAnnotationType = repositoryAnnotationType;\n\t}\n\n\t@Override\n\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tsuper.setBeanFactory(beanFactory);\n\n\t\tif (!(beanFactory instanceof ListableBeanFactory lbf)) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Cannot use PersistenceExceptionTranslator autodetection without ListableBeanFactory\");\n\t\t}\n\t\tthis.advisor = new PersistenceExceptionTranslationAdvisor(lbf, this.repositoryAnnotationType);\n\t}\n\n}"
  },
  "org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "void",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tsuper.setBeanFactory(beanFactory);\n\n\t\tif (!(beanFactory instanceof ListableBeanFactory lbf)) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Cannot use PersistenceExceptionTranslator autodetection without ListableBeanFactory\");\n\t\t}\n\t\tthis.advisor = new PersistenceExceptionTranslationAdvisor(lbf, this.repositoryAnnotationType);\n\t}"
  },
  "org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor#setRepositoryAnnotationType(repositoryAnnotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the 'repository' annotation type.\n\t * The default repository annotation type is the {@link Repository} annotation.\n\t * <p>This setter property exists so that developers can provide their own\n\t * (non-Spring-specific) annotation type to indicate that a class has a\n\t * repository role.\n\t * @param repositoryAnnotationType the desired annotation type\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "repositoryAnnotationType"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "void",
    "signature": "public void setRepositoryAnnotationType(Class<? extends Annotation> repositoryAnnotationType)",
    "source_code": "\tpublic void setRepositoryAnnotationType(Class<? extends Annotation> repositoryAnnotationType) {\n\t\tAssert.notNull(repositoryAnnotationType, \"'repositoryAnnotationType' must not be null\");\n\t\tthis.repositoryAnnotationType = repositoryAnnotationType;\n\t}"
  },
  "org.springframework.dao.support.DataAccessUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Miscellaneous utility methods for DAO implementations.\n * Useful with any data access technology.\n *\n * @author Juergen Hoeller\n * @since 1.0.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "signature": "public class DataAccessUtils",
    "source_code": "public abstract class DataAccessUtils {\n\n\t/**\n\t * Return a single result object from the given Collection.\n\t * <p>Returns {@code null} if 0 result objects found;\n\t * throws an exception if more than 1 element found.\n\t * @param results the result Collection (can be {@code null})\n\t * @return the single result object, or {@code null} if none\n\t * @throws IncorrectResultSizeDataAccessException if more than one\n\t * element has been found in the given Collection\n\t */\n\t@Nullable\n\tpublic static <T> T singleResult(@Nullable Collection<T> results) throws IncorrectResultSizeDataAccessException {\n\t\tif (CollectionUtils.isEmpty(results)) {\n\t\t\treturn null;\n\t\t}\n\t\tif (results.size() > 1) {\n\t\t\tthrow new IncorrectResultSizeDataAccessException(1, results.size());\n\t\t}\n\t\treturn results.iterator().next();\n\t}\n\n\t/**\n\t * Return a single result object from the given Collection.\n\t * <p>Throws an exception if 0 or more than 1 element found.\n\t * @param results the result Collection (can be {@code null}\n\t * but is not expected to contain {@code null} elements)\n\t * @return the single result object\n\t * @throws IncorrectResultSizeDataAccessException if more than one\n\t * element has been found in the given Collection\n\t * @throws EmptyResultDataAccessException if no element at all\n\t * has been found in the given Collection\n\t */\n\tpublic static <T> T requiredSingleResult(@Nullable Collection<T> results) throws IncorrectResultSizeDataAccessException {\n\t\tif (CollectionUtils.isEmpty(results)) {\n\t\t\tthrow new EmptyResultDataAccessException(1);\n\t\t}\n\t\tif (results.size() > 1) {\n\t\t\tthrow new IncorrectResultSizeDataAccessException(1, results.size());\n\t\t}\n\t\treturn results.iterator().next();\n\t}\n\n\t/**\n\t * Return a single result object from the given Collection.\n\t * <p>Throws an exception if 0 or more than 1 element found.\n\t * @param results the result Collection (can be {@code null}\n\t * and is also expected to contain {@code null} elements)\n\t * @return the single result object\n\t * @throws IncorrectResultSizeDataAccessException if more than one\n\t * element has been found in the given Collection\n\t * @throws EmptyResultDataAccessException if no element at all\n\t * has been found in the given Collection\n\t * @since 5.0.2\n\t */\n\t@Nullable\n\tpublic static <T> T nullableSingleResult(@Nullable Collection<T> results) throws IncorrectResultSizeDataAccessException {\n\t\t// This is identical to the requiredSingleResult implementation but differs in the\n\t\t// semantics of the incoming Collection (which we currently can't formally express)\n\t\tif (CollectionUtils.isEmpty(results)) {\n\t\t\tthrow new EmptyResultDataAccessException(1);\n\t\t}\n\t\tif (results.size() > 1) {\n\t\t\tthrow new IncorrectResultSizeDataAccessException(1, results.size());\n\t\t}\n\t\treturn results.iterator().next();\n\t}\n\n\t/**\n\t * Return a unique result object from the given Collection.\n\t * <p>Returns {@code null} if 0 result objects found;\n\t * throws an exception if more than 1 instance found.\n\t * @param results the result Collection (can be {@code null})\n\t * @return the unique result object, or {@code null} if none\n\t * @throws IncorrectResultSizeDataAccessException if more than one\n\t * result object has been found in the given Collection\n\t * @see org.springframework.util.CollectionUtils#hasUniqueObject\n\t */\n\t@Nullable\n\tpublic static <T> T uniqueResult(@Nullable Collection<T> results) throws IncorrectResultSizeDataAccessException {\n\t\tif (CollectionUtils.isEmpty(results)) {\n\t\t\treturn null;\n\t\t}\n\t\tif (!CollectionUtils.hasUniqueObject(results)) {\n\t\t\tthrow new IncorrectResultSizeDataAccessException(1, results.size());\n\t\t}\n\t\treturn results.iterator().next();\n\t}\n\n\t/**\n\t * Return a unique result object from the given Collection.\n\t * <p>Throws an exception if 0 or more than 1 instance found.\n\t * @param results the result Collection (can be {@code null}\n\t * but is not expected to contain {@code null} elements)\n\t * @return the unique result object\n\t * @throws IncorrectResultSizeDataAccessException if more than one\n\t * result object has been found in the given Collection\n\t * @throws EmptyResultDataAccessException if no result object at all\n\t * has been found in the given Collection\n\t * @see org.springframework.util.CollectionUtils#hasUniqueObject\n\t */\n\tpublic static <T> T requiredUniqueResult(@Nullable Collection<T> results) throws IncorrectResultSizeDataAccessException {\n\t\tif (CollectionUtils.isEmpty(results)) {\n\t\t\tthrow new EmptyResultDataAccessException(1);\n\t\t}\n\t\tif (!CollectionUtils.hasUniqueObject(results)) {\n\t\t\tthrow new IncorrectResultSizeDataAccessException(1, results.size());\n\t\t}\n\t\treturn results.iterator().next();\n\t}\n\n\t/**\n\t * Return a unique result object from the given Collection.\n\t * Throws an exception if 0 or more than 1 result objects found,\n\t * of if the unique result object is not convertible to the\n\t * specified required type.\n\t * @param results the result Collection (can be {@code null}\n\t * but is not expected to contain {@code null} elements)\n\t * @return the unique result object\n\t * @throws IncorrectResultSizeDataAccessException if more than one\n\t * result object has been found in the given Collection\n\t * @throws EmptyResultDataAccessException if no result object\n\t * at all has been found in the given Collection\n\t * @throws TypeMismatchDataAccessException if the unique object does\n\t * not match the specified required type\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <T> T objectResult(@Nullable Collection<?> results, @Nullable Class<T> requiredType)\n\t\t\tthrows IncorrectResultSizeDataAccessException, TypeMismatchDataAccessException {\n\n\t\tObject result = requiredUniqueResult(results);\n\t\tif (requiredType != null && !requiredType.isInstance(result)) {\n\t\t\tif (String.class == requiredType) {\n\t\t\t\tresult = result.toString();\n\t\t\t}\n\t\t\telse if (Number.class.isAssignableFrom(requiredType) && result instanceof Number number) {\n\t\t\t\ttry {\n\t\t\t\t\tresult = NumberUtils.convertNumberToTargetClass(number, (Class<? extends Number>) requiredType);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tthrow new TypeMismatchDataAccessException(ex.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new TypeMismatchDataAccessException(\n\t\t\t\t\t\t\"Result object is of type [\" + result.getClass().getName() +\n\t\t\t\t\t\t\"] and could not be converted to required type [\" + requiredType.getName() + \"]\");\n\t\t\t}\n\t\t}\n\t\treturn (T) result;\n\t}\n\n\t/**\n\t * Return a unique int result from the given Collection.\n\t * Throws an exception if 0 or more than 1 result objects found,\n\t * of if the unique result object is not convertible to an int.\n\t * @param results the result Collection (can be {@code null}\n\t * but is not expected to contain {@code null} elements)\n\t * @return the unique int result\n\t * @throws IncorrectResultSizeDataAccessException if more than one\n\t * result object has been found in the given Collection\n\t * @throws EmptyResultDataAccessException if no result object\n\t * at all has been found in the given Collection\n\t * @throws TypeMismatchDataAccessException if the unique object\n\t * in the collection is not convertible to an int\n\t */\n\tpublic static int intResult(@Nullable Collection<?> results)\n\t\t\tthrows IncorrectResultSizeDataAccessException, TypeMismatchDataAccessException {\n\n\t\treturn objectResult(results, Number.class).intValue();\n\t}\n\n\t/**\n\t * Return a unique long result from the given Collection.\n\t * Throws an exception if 0 or more than 1 result objects found,\n\t * of if the unique result object is not convertible to a long.\n\t * @param results the result Collection (can be {@code null}\n\t * but is not expected to contain {@code null} elements)\n\t * @return the unique long result\n\t * @throws IncorrectResultSizeDataAccessException if more than one\n\t * result object has been found in the given Collection\n\t * @throws EmptyResultDataAccessException if no result object\n\t * at all has been found in the given Collection\n\t * @throws TypeMismatchDataAccessException if the unique object\n\t * in the collection is not convertible to a long\n\t */\n\tpublic static long longResult(@Nullable Collection<?> results)\n\t\t\tthrows IncorrectResultSizeDataAccessException, TypeMismatchDataAccessException {\n\n\t\treturn objectResult(results, Number.class).longValue();\n\t}\n\n\n\t/**\n\t * Return a translated exception if this is appropriate,\n\t * otherwise return the given exception as-is.\n\t * @param rawException an exception that we may wish to translate\n\t * @param pet the PersistenceExceptionTranslator to use to perform the translation\n\t * @return a translated persistence exception if translation is possible,\n\t * or the raw exception if it is not\n\t */\n\tpublic static RuntimeException translateIfNecessary(\n\t\t\tRuntimeException rawException, PersistenceExceptionTranslator pet) {\n\n\t\tAssert.notNull(pet, \"PersistenceExceptionTranslator must not be null\");\n\t\tDataAccessException dae = pet.translateExceptionIfPossible(rawException);\n\t\treturn (dae != null ? dae : rawException);\n\t}\n\n}"
  },
  "org.springframework.dao.support.DataAccessUtils#intResult(results)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a unique int result from the given Collection.\n\t * Throws an exception if 0 or more than 1 result objects found,\n\t * of if the unique result object is not convertible to an int.\n\t * @param results the result Collection (can be {@code null}\n\t * but is not expected to contain {@code null} elements)\n\t * @return the unique int result\n\t * @throws IncorrectResultSizeDataAccessException if more than one\n\t * result object has been found in the given Collection\n\t * @throws EmptyResultDataAccessException if no result object\n\t * at all has been found in the given Collection\n\t * @throws TypeMismatchDataAccessException if the unique object\n\t * in the collection is not convertible to an int\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "results"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "int",
    "signature": "public int intResult(@Nullable Collection<?> results)",
    "source_code": "\tpublic static int intResult(@Nullable Collection<?> results)"
  },
  "org.springframework.dao.support.DataAccessUtils#longResult(results)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a unique long result from the given Collection.\n\t * Throws an exception if 0 or more than 1 result objects found,\n\t * of if the unique result object is not convertible to a long.\n\t * @param results the result Collection (can be {@code null}\n\t * but is not expected to contain {@code null} elements)\n\t * @return the unique long result\n\t * @throws IncorrectResultSizeDataAccessException if more than one\n\t * result object has been found in the given Collection\n\t * @throws EmptyResultDataAccessException if no result object\n\t * at all has been found in the given Collection\n\t * @throws TypeMismatchDataAccessException if the unique object\n\t * in the collection is not convertible to a long\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "results"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "long",
    "signature": "public long longResult(@Nullable Collection<?> results)",
    "source_code": "\tpublic static long longResult(@Nullable Collection<?> results)"
  },
  "org.springframework.dao.support.DataAccessUtils#nullableSingleResult(results)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a single result object from the given Collection.\n\t * <p>Throws an exception if 0 or more than 1 element found.\n\t * @param results the result Collection (can be {@code null}\n\t * and is also expected to contain {@code null} elements)\n\t * @return the single result object\n\t * @throws IncorrectResultSizeDataAccessException if more than one\n\t * element has been found in the given Collection\n\t * @throws EmptyResultDataAccessException if no element at all\n\t * has been found in the given Collection\n\t * @since 5.0.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "results"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "T",
    "signature": "public T nullableSingleResult(@Nullable Collection<T> results)",
    "source_code": "\tpublic static <T> T nullableSingleResult(@Nullable Collection<T> results) throws IncorrectResultSizeDataAccessException {\n\t\t// This is identical to the requiredSingleResult implementation but differs in the\n\t\t// semantics of the incoming Collection (which we currently can't formally express)\n\t\tif (CollectionUtils.isEmpty(results)) {\n\t\t\tthrow new EmptyResultDataAccessException(1);\n\t\t}\n\t\tif (results.size() > 1) {\n\t\t\tthrow new IncorrectResultSizeDataAccessException(1, results.size());\n\t\t}\n\t\treturn results.iterator().next();\n\t}"
  },
  "org.springframework.dao.support.DataAccessUtils#objectResult(results,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a unique result object from the given Collection.\n\t * Throws an exception if 0 or more than 1 result objects found,\n\t * of if the unique result object is not convertible to the\n\t * specified required type.\n\t * @param results the result Collection (can be {@code null}\n\t * but is not expected to contain {@code null} elements)\n\t * @return the unique result object\n\t * @throws IncorrectResultSizeDataAccessException if more than one\n\t * result object has been found in the given Collection\n\t * @throws EmptyResultDataAccessException if no result object\n\t * at all has been found in the given Collection\n\t * @throws TypeMismatchDataAccessException if the unique object does\n\t * not match the specified required type\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "results",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "T",
    "signature": "public T objectResult(@Nullable Collection<?> results, @Nullable Class<T> requiredType)",
    "source_code": "\tpublic static <T> T objectResult(@Nullable Collection<?> results, @Nullable Class<T> requiredType)"
  },
  "org.springframework.dao.support.DataAccessUtils#requiredSingleResult(results)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a single result object from the given Collection.\n\t * <p>Throws an exception if 0 or more than 1 element found.\n\t * @param results the result Collection (can be {@code null}\n\t * but is not expected to contain {@code null} elements)\n\t * @return the single result object\n\t * @throws IncorrectResultSizeDataAccessException if more than one\n\t * element has been found in the given Collection\n\t * @throws EmptyResultDataAccessException if no element at all\n\t * has been found in the given Collection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "results"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "T",
    "signature": "public T requiredSingleResult(@Nullable Collection<T> results)",
    "source_code": "\tpublic static <T> T requiredSingleResult(@Nullable Collection<T> results) throws IncorrectResultSizeDataAccessException {\n\t\tif (CollectionUtils.isEmpty(results)) {\n\t\t\tthrow new EmptyResultDataAccessException(1);\n\t\t}\n\t\tif (results.size() > 1) {\n\t\t\tthrow new IncorrectResultSizeDataAccessException(1, results.size());\n\t\t}\n\t\treturn results.iterator().next();\n\t}"
  },
  "org.springframework.dao.support.DataAccessUtils#requiredUniqueResult(results)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a unique result object from the given Collection.\n\t * <p>Throws an exception if 0 or more than 1 instance found.\n\t * @param results the result Collection (can be {@code null}\n\t * but is not expected to contain {@code null} elements)\n\t * @return the unique result object\n\t * @throws IncorrectResultSizeDataAccessException if more than one\n\t * result object has been found in the given Collection\n\t * @throws EmptyResultDataAccessException if no result object at all\n\t * has been found in the given Collection\n\t * @see org.springframework.util.CollectionUtils#hasUniqueObject\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "results"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "T",
    "signature": "public T requiredUniqueResult(@Nullable Collection<T> results)",
    "source_code": "\tpublic static <T> T requiredUniqueResult(@Nullable Collection<T> results) throws IncorrectResultSizeDataAccessException {\n\t\tif (CollectionUtils.isEmpty(results)) {\n\t\t\tthrow new EmptyResultDataAccessException(1);\n\t\t}\n\t\tif (!CollectionUtils.hasUniqueObject(results)) {\n\t\t\tthrow new IncorrectResultSizeDataAccessException(1, results.size());\n\t\t}\n\t\treturn results.iterator().next();\n\t}"
  },
  "org.springframework.dao.support.DataAccessUtils#singleResult(results)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a single result object from the given Collection.\n\t * <p>Returns {@code null} if 0 result objects found;\n\t * throws an exception if more than 1 element found.\n\t * @param results the result Collection (can be {@code null})\n\t * @return the single result object, or {@code null} if none\n\t * @throws IncorrectResultSizeDataAccessException if more than one\n\t * element has been found in the given Collection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "results"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "return": "T",
    "signature": "public T singleResult(@Nullable Collection<T> results)",
    "source_code": "\tpublic static <T> T singleResult(@Nullable Collection<T> results) throws IncorrectResultSizeDataAccessException {\n\t\tif (CollectionUtils.isEmpty(results)) {\n\t\t\treturn null;\n\t\t}\n\t\tif (results.size() > 1) {\n\t\t\tthrow new IncorrectResultSizeDataAccessException(1, results.size());\n\t\t}\n\t\treturn results.iterator().next();\n\t}"
  },
  "org.springframework.dao.support.DataAccessUtils#translateIfNecessary(rawException,pet)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a translated exception if this is appropriate,\n\t * otherwise return the given exception as-is.\n\t * @param rawException an exception that we may wish to translate\n\t * @param pet the PersistenceExceptionTranslator to use to perform the translation\n\t * @return a translated persistence exception if translation is possible,\n\t * or the raw exception if it is not\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rawException",
      "pet"
    ],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "RuntimeException",
    "signature": "public RuntimeException translateIfNecessary(RuntimeException rawException, PersistenceExceptionTranslator pet)",
    "source_code": "\tpublic static RuntimeException translateIfNecessary("
  },
  "org.springframework.dao.support.DataAccessUtils#uniqueResult(results)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a unique result object from the given Collection.\n\t * <p>Returns {@code null} if 0 result objects found;\n\t * throws an exception if more than 1 instance found.\n\t * @param results the result Collection (can be {@code null})\n\t * @return the unique result object, or {@code null} if none\n\t * @throws IncorrectResultSizeDataAccessException if more than one\n\t * result object has been found in the given Collection\n\t * @see org.springframework.util.CollectionUtils#hasUniqueObject\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "results"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "T",
    "signature": "public T uniqueResult(@Nullable Collection<T> results)",
    "source_code": "\tpublic static <T> T uniqueResult(@Nullable Collection<T> results) throws IncorrectResultSizeDataAccessException {\n\t\tif (CollectionUtils.isEmpty(results)) {\n\t\t\treturn null;\n\t\t}\n\t\tif (!CollectionUtils.hasUniqueObject(results)) {\n\t\t\tthrow new IncorrectResultSizeDataAccessException(1, results.size());\n\t\t}\n\t\treturn results.iterator().next();\n\t}"
  },
  "org.springframework.dao.support.PersistenceExceptionTranslationInterceptor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * AOP Alliance MethodInterceptor that provides persistence exception translation\n * based on a given PersistenceExceptionTranslator.\n *\n * <p>Delegates to the given {@link PersistenceExceptionTranslator} to translate\n * a RuntimeException thrown into Spring's DataAccessException hierarchy\n * (if appropriate). If the RuntimeException in question is declared on the\n * target method, it is always propagated as-is (with no translation applied).\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 2.0\n * @see PersistenceExceptionTranslator\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "signature": "public class PersistenceExceptionTranslationInterceptor",
    "source_code": "public class PersistenceExceptionTranslationInterceptor"
  },
  "org.springframework.dao.support.PersistenceExceptionTranslationInterceptor#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tif (this.persistenceExceptionTranslator == null && this.beanFactory == null) {\n\t\t\tthrow new IllegalArgumentException(\"Property 'persistenceExceptionTranslator' is required\");\n\t\t}\n\t}"
  },
  "org.springframework.dao.support.PersistenceExceptionTranslationInterceptor#detectPersistenceExceptionTranslators(bf)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Detect all PersistenceExceptionTranslators in the given BeanFactory.\n\t * @param bf the ListableBeanFactory to obtain PersistenceExceptionTranslators from\n\t * @return a chained PersistenceExceptionTranslator, combining all\n\t * PersistenceExceptionTranslators found in the given bean factory\n\t * @see ChainedPersistenceExceptionTranslator\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bf"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "PersistenceExceptionTranslator",
    "signature": "protected PersistenceExceptionTranslator detectPersistenceExceptionTranslators(ListableBeanFactory bf)",
    "source_code": "\tprotected PersistenceExceptionTranslator detectPersistenceExceptionTranslators(ListableBeanFactory bf) {\n\t\t// Find all translators, being careful not to activate FactoryBeans.\n\t\tChainedPersistenceExceptionTranslator cpet = new ChainedPersistenceExceptionTranslator();\n\t\tbf.getBeanProvider(PersistenceExceptionTranslator.class, false).orderedStream().forEach(cpet::addDelegate);\n\t\treturn cpet;\n\t}"
  },
  "org.springframework.dao.support.PersistenceExceptionTranslationInterceptor#invoke(mi)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mi"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "Object",
    "signature": "public Object invoke(MethodInvocation mi)",
    "source_code": "\tpublic Object invoke(MethodInvocation mi) throws Throwable {\n\t\ttry {\n\t\t\treturn mi.proceed();\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\t// Let it throw raw if the type of the exception is on the throws clause of the method.\n\t\t\tif (!this.alwaysTranslate && ReflectionUtils.declaresException(mi.getMethod(), ex.getClass())) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tPersistenceExceptionTranslator translator = this.persistenceExceptionTranslator;\n\t\t\t\tif (translator == null) {\n\t\t\t\t\tAssert.state(this.beanFactory != null,\n\t\t\t\t\t\t\t\"Cannot use PersistenceExceptionTranslator autodetection without ListableBeanFactory\");\n\t\t\t\t\ttranslator = detectPersistenceExceptionTranslators(this.beanFactory);\n\t\t\t\t\tthis.persistenceExceptionTranslator = translator;\n\t\t\t\t}\n\t\t\t\tthrow DataAccessUtils.translateIfNecessary(ex, translator);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.dao.support.PersistenceExceptionTranslationInterceptor#setAlwaysTranslate(alwaysTranslate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether to always translate the exception (\"true\"), or whether throw the\n\t * raw exception when declared, i.e. when the originating method signature's exception\n\t * declarations allow for the raw exception to be thrown (\"false\").\n\t * <p>Default is \"false\". Switch this flag to \"true\" in order to always translate\n\t * applicable exceptions, independent of the originating method signature.\n\t * <p>Note that the originating method does not have to declare the specific exception.\n\t * Any base class will do as well, even {@code throws Exception}: As long as the\n\t * originating method does explicitly declare compatible exceptions, the raw exception\n\t * will be rethrown. If you would like to avoid throwing raw exceptions in any case,\n\t * switch this flag to \"true\".\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "alwaysTranslate"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "void",
    "signature": "public void setAlwaysTranslate(boolean alwaysTranslate)",
    "source_code": "\tpublic void setAlwaysTranslate(boolean alwaysTranslate) {\n\t\tthis.alwaysTranslate = alwaysTranslate;\n\t}"
  },
  "org.springframework.dao.support.PersistenceExceptionTranslationInterceptor#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "void",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n\t\tif (this.persistenceExceptionTranslator == null) {\n\t\t\t// No explicit exception translator specified - perform autodetection.\n\t\t\tif (!(beanFactory instanceof ListableBeanFactory lbf)) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Cannot use PersistenceExceptionTranslator autodetection without ListableBeanFactory\");\n\t\t\t}\n\t\t\tthis.beanFactory = lbf;\n\t\t}\n\t}"
  },
  "org.springframework.dao.support.PersistenceExceptionTranslationInterceptor#setPersistenceExceptionTranslator(pet)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the PersistenceExceptionTranslator to use.\n\t * <p>Default is to autodetect all PersistenceExceptionTranslators\n\t * in the containing BeanFactory, using them in a chain.\n\t * @see #detectPersistenceExceptionTranslators\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pet"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "void",
    "signature": "public void setPersistenceExceptionTranslator(PersistenceExceptionTranslator pet)",
    "source_code": "\tpublic void setPersistenceExceptionTranslator(PersistenceExceptionTranslator pet) {\n\t\tthis.persistenceExceptionTranslator = pet;\n\t}"
  },
  "org.springframework.jca.endpoint.AbstractMessageEndpoint": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Inner class for actual endpoint implementations, based on template\n\t * method to allow for any kind of concrete endpoint implementation.\n\t */",
    "kind": "class",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "signature": "protected class AbstractMessageEndpoint",
    "source_code": "\tprotected abstract class AbstractMessageEndpoint implements MessageEndpoint {\n\n\t\t@Nullable\n\t\tprivate TransactionDelegate transactionDelegate;\n\n\t\tprivate boolean beforeDeliveryCalled = false;\n\n\t\t@Nullable\n\t\tprivate ClassLoader previousContextClassLoader;\n\n\t\t/**\n\t\t * Initialize this endpoint's TransactionDelegate.\n\t\t * @param xaResource the XAResource for this endpoint\n\t\t */\n\t\tvoid initXAResource(XAResource xaResource) {\n\t\t\tthis.transactionDelegate = new TransactionDelegate(xaResource);\n\t\t}\n\n\t\t/**\n\t\t * This {@code beforeDelivery} implementation starts a transaction,\n\t\t * if necessary, and exposes the endpoint ClassLoader as current\n\t\t * thread context ClassLoader.\n\t\t * <p>Note that the JCA 1.7 specification does not require a ResourceAdapter\n\t\t * to call this method before invoking the concrete endpoint. If this method\n\t\t * has not been called (check {@link #hasBeforeDeliveryBeenCalled()}), the\n\t\t * concrete endpoint method should call {@code beforeDelivery} and its\n\t\t * sibling {@link #afterDelivery()} explicitly, as part of its own processing.\n\t\t */\n\t\t@Override\n\t\tpublic void beforeDelivery(@Nullable Method method) throws ResourceException {\n\t\t\tthis.beforeDeliveryCalled = true;\n\t\t\tAssert.state(this.transactionDelegate != null, \"Not initialized\");\n\t\t\ttry {\n\t\t\t\tthis.transactionDelegate.beginTransaction();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new ApplicationServerInternalException(\"Failed to begin transaction\", ex);\n\t\t\t}\n\t\t\tThread currentThread = Thread.currentThread();\n\t\t\tthis.previousContextClassLoader = currentThread.getContextClassLoader();\n\t\t\tcurrentThread.setContextClassLoader(getEndpointClassLoader());\n\t\t}\n\n\t\t/**\n\t\t * Template method for exposing the endpoint's ClassLoader\n\t\t * (typically the ClassLoader that the message listener class\n\t\t * has been loaded with).\n\t\t * @return the endpoint ClassLoader (never {@code null})\n\t\t */\n\t\tprotected abstract ClassLoader getEndpointClassLoader();\n\n\t\t/**\n\t\t * Return whether the {@link #beforeDelivery} method of this endpoint\n\t\t * has already been called.\n\t\t */\n\t\tprotected final boolean hasBeforeDeliveryBeenCalled() {\n\t\t\treturn this.beforeDeliveryCalled;\n\t\t}\n\n\t\t/**\n\t\t * Callback method for notifying the endpoint base class\n\t\t * that the concrete endpoint invocation led to an exception.\n\t\t * <p>To be invoked by subclasses in case of the concrete\n\t\t * endpoint throwing an exception.\n\t\t * @param ex the exception thrown from the concrete endpoint\n\t\t */\n\t\tprotected void onEndpointException(Throwable ex) {\n\t\t\tAssert.state(this.transactionDelegate != null, \"Not initialized\");\n\t\t\tthis.transactionDelegate.setRollbackOnly();\n\t\t\tlogger.debug(\"Transaction marked as rollback-only after endpoint exception\", ex);\n\t\t}\n\n\t\t/**\n\t\t * This {@code afterDelivery} implementation resets the thread context\n\t\t * ClassLoader and completes the transaction, if any.\n\t\t * <p>Note that the JCA 1.7 specification does not require a ResourceAdapter\n\t\t * to call this method after invoking the concrete endpoint. See the\n\t\t * explanation in {@link #beforeDelivery}'s javadoc.\n\t\t */\n\t\t@Override\n\t\tpublic void afterDelivery() throws ResourceException {\n\t\t\tAssert.state(this.transactionDelegate != null, \"Not initialized\");\n\t\t\tthis.beforeDeliveryCalled = false;\n\t\t\tThread.currentThread().setContextClassLoader(this.previousContextClassLoader);\n\t\t\tthis.previousContextClassLoader = null;\n\t\t\ttry {\n\t\t\t\tthis.transactionDelegate.endTransaction();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tlogger.warn(\"Failed to complete transaction after endpoint delivery\", ex);\n\t\t\t\tthrow new ApplicationServerInternalException(\"Failed to complete transaction\", ex);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void release() {\n\t\t\tif (this.transactionDelegate != null) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.transactionDelegate.setRollbackOnly();\n\t\t\t\t\tthis.transactionDelegate.endTransaction();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tlogger.warn(\"Could not complete unfinished transaction on endpoint release\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jca.endpoint.AbstractMessageEndpointFactory": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract base implementation of the JCA 1.7\n * {@link jakarta.resource.spi.endpoint.MessageEndpointFactory} interface,\n * providing transaction management capabilities as well as ClassLoader\n * exposure for endpoint invocations.\n *\n * @author Juergen Hoeller\n * @since 2.5\n * @see #setTransactionManager\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "signature": "public class AbstractMessageEndpointFactory",
    "source_code": "public abstract class AbstractMessageEndpointFactory implements MessageEndpointFactory, BeanNameAware {\n\n\t/** Logger available to subclasses. */\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\t@Nullable\n\tprivate TransactionFactory transactionFactory;\n\n\t@Nullable\n\tprivate String transactionName;\n\n\tprivate int transactionTimeout = -1;\n\n\t@Nullable\n\tprivate String beanName;\n\n\n\t/**\n\t * Set the XA transaction manager to use for wrapping endpoint\n\t * invocations, enlisting the endpoint resource in each such transaction.\n\t * <p>The passed-in object may be a transaction manager which implements\n\t * Spring's {@link org.springframework.transaction.jta.TransactionFactory}\n\t * interface, or a plain {@link jakarta.transaction.TransactionManager}.\n\t * <p>If no transaction manager is specified, the endpoint invocation\n\t * will simply not be wrapped in an XA transaction. Check out your\n\t * resource provider's ActivationSpec documentation for local\n\t * transaction options of your particular provider.\n\t * @see #setTransactionName\n\t * @see #setTransactionTimeout\n\t */\n\tpublic void setTransactionManager(Object transactionManager) {\n\t\tif (transactionManager instanceof TransactionFactory factory) {\n\t\t\tthis.transactionFactory = factory;\n\t\t}\n\t\telse if (transactionManager instanceof TransactionManager manager) {\n\t\t\tthis.transactionFactory = new SimpleTransactionFactory(manager);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Transaction manager [\" + transactionManager +\n\t\t\t\t\t\"] is neither a [org.springframework.transaction.jta.TransactionFactory} nor a \" +\n\t\t\t\t\t\"[jakarta.transaction.TransactionManager]\");\n\t\t}\n\t}"
  },
  "org.springframework.jca.endpoint.AbstractMessageEndpointFactory#afterDelivery()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * This {@code afterDelivery} implementation resets the thread context\n\t\t * ClassLoader and completes the transaction, if any.\n\t\t * <p>Note that the JCA 1.7 specification does not require a ResourceAdapter\n\t\t * to call this method after invoking the concrete endpoint. See the\n\t\t * explanation in {@link #beforeDelivery}'s javadoc.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "void",
    "signature": "public void afterDelivery()",
    "source_code": "\t\tpublic void afterDelivery() throws ResourceException {\n\t\t\tAssert.state(this.transactionDelegate != null, \"Not initialized\");\n\t\t\tthis.beforeDeliveryCalled = false;\n\t\t\tThread.currentThread().setContextClassLoader(this.previousContextClassLoader);\n\t\t\tthis.previousContextClassLoader = null;\n\t\t\ttry {\n\t\t\t\tthis.transactionDelegate.endTransaction();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tlogger.warn(\"Failed to complete transaction after endpoint delivery\", ex);\n\t\t\t\tthrow new ApplicationServerInternalException(\"Failed to complete transaction\", ex);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.jca.endpoint.AbstractMessageEndpointFactory#beforeDelivery(method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * This {@code beforeDelivery} implementation starts a transaction,\n\t\t * if necessary, and exposes the endpoint ClassLoader as current\n\t\t * thread context ClassLoader.\n\t\t * <p>Note that the JCA 1.7 specification does not require a ResourceAdapter\n\t\t * to call this method before invoking the concrete endpoint. If this method\n\t\t * has not been called (check {@link #hasBeforeDeliveryBeenCalled()}), the\n\t\t * concrete endpoint method should call {@code beforeDelivery} and its\n\t\t * sibling {@link #afterDelivery()} explicitly, as part of its own processing.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "void",
    "signature": "public void beforeDelivery(@Nullable Method method)",
    "source_code": "\t\tpublic void beforeDelivery(@Nullable Method method) throws ResourceException {\n\t\t\tthis.beforeDeliveryCalled = true;\n\t\t\tAssert.state(this.transactionDelegate != null, \"Not initialized\");\n\t\t\ttry {\n\t\t\t\tthis.transactionDelegate.beginTransaction();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new ApplicationServerInternalException(\"Failed to begin transaction\", ex);\n\t\t\t}\n\t\t\tThread currentThread = Thread.currentThread();\n\t\t\tthis.previousContextClassLoader = currentThread.getContextClassLoader();\n\t\t\tcurrentThread.setContextClassLoader(getEndpointClassLoader());\n\t\t}"
  },
  "org.springframework.jca.endpoint.AbstractMessageEndpointFactory#beginTransaction()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 339
    },
    "return": "void",
    "signature": "public void beginTransaction()",
    "source_code": "\t\tpublic void beginTransaction() throws Exception {\n\t\t\tif (transactionFactory != null && this.xaResource != null) {\n\t\t\t\tthis.transaction = transactionFactory.createTransaction(transactionName, transactionTimeout);\n\t\t\t\tthis.transaction.enlistResource(this.xaResource);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.jca.endpoint.AbstractMessageEndpointFactory#createEndpoint(xaResource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The standard JCA 1.5 version of {@code createEndpoint}.\n\t * <p>This implementation delegates to {@link #createEndpointInternal()},\n\t * initializing the endpoint's XAResource before the endpoint gets invoked.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "xaResource"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "MessageEndpoint",
    "signature": "public MessageEndpoint createEndpoint(XAResource xaResource)",
    "source_code": "\tpublic MessageEndpoint createEndpoint(XAResource xaResource) throws UnavailableException {\n\t\tAbstractMessageEndpoint endpoint = createEndpointInternal();\n\t\tendpoint.initXAResource(xaResource);\n\t\treturn endpoint;\n\t}"
  },
  "org.springframework.jca.endpoint.AbstractMessageEndpointFactory#createEndpoint(xaResource,timeout)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The alternative JCA 1.6 version of {@code createEndpoint}.\n\t * <p>This implementation delegates to {@link #createEndpointInternal()},\n\t * ignoring the specified timeout. It is only here for JCA 1.6 compliance.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "xaResource",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "MessageEndpoint",
    "signature": "public MessageEndpoint createEndpoint(XAResource xaResource, long timeout)",
    "source_code": "\tpublic MessageEndpoint createEndpoint(XAResource xaResource, long timeout) throws UnavailableException {\n\t\tAbstractMessageEndpoint endpoint = createEndpointInternal();\n\t\tendpoint.initXAResource(xaResource);\n\t\treturn endpoint;\n\t}"
  },
  "org.springframework.jca.endpoint.AbstractMessageEndpointFactory#createEndpointInternal()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the actual endpoint instance, as a subclass of the\n\t * {@link AbstractMessageEndpoint} inner class of this factory.\n\t * @return the actual endpoint instance (never {@code null})\n\t * @throws UnavailableException if no endpoint is available at present\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "AbstractMessageEndpoint",
    "signature": "protected AbstractMessageEndpoint createEndpointInternal()",
    "source_code": "\tprotected abstract AbstractMessageEndpoint createEndpointInternal() throws UnavailableException;"
  },
  "org.springframework.jca.endpoint.AbstractMessageEndpointFactory#endTransaction()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 352
    },
    "return": "void",
    "signature": "public void endTransaction()",
    "source_code": "\t\tpublic void endTransaction() throws Exception {\n\t\t\tif (this.transaction != null) {\n\t\t\t\ttry {\n\t\t\t\t\tif (this.rollbackOnly) {\n\t\t\t\t\t\tthis.transaction.rollback();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.transaction.commit();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tthis.transaction = null;\n\t\t\t\t\tthis.rollbackOnly = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.jca.endpoint.AbstractMessageEndpointFactory#getActivationName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Implementation of the JCA 1.7 {@code #getActivationName()} method,\n\t * returning the bean name as set on this MessageEndpointFactory.\n\t * @see #setBeanName\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "String",
    "signature": "public String getActivationName()",
    "source_code": "\tpublic String getActivationName() {\n\t\treturn this.beanName;\n\t}"
  },
  "org.springframework.jca.endpoint.AbstractMessageEndpointFactory#getEndpointClassLoader()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Template method for exposing the endpoint's ClassLoader\n\t\t * (typically the ClassLoader that the message listener class\n\t\t * has been loaded with).\n\t\t * @return the endpoint ClassLoader (never {@code null})\n\t\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "ClassLoader",
    "signature": "protected ClassLoader getEndpointClassLoader()",
    "source_code": "\t\tprotected abstract ClassLoader getEndpointClassLoader();"
  },
  "org.springframework.jca.endpoint.AbstractMessageEndpointFactory#hasBeforeDeliveryBeenCalled()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return whether the {@link #beforeDelivery} method of this endpoint\n\t\t * has already been called.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "boolean",
    "signature": "protected boolean hasBeforeDeliveryBeenCalled()",
    "source_code": "\t\tprotected final boolean hasBeforeDeliveryBeenCalled() {\n\t\t\treturn this.beforeDeliveryCalled;\n\t\t}"
  },
  "org.springframework.jca.endpoint.AbstractMessageEndpointFactory#isDeliveryTransacted(method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns {@code true} if a transaction manager\n\t * has been specified; {@code false} otherwise.\n\t * @see #setTransactionManager\n\t * @see #setTransactionFactory\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "boolean",
    "signature": "public boolean isDeliveryTransacted(Method method)",
    "source_code": "\tpublic boolean isDeliveryTransacted(Method method) throws NoSuchMethodException {\n\t\treturn (this.transactionFactory != null);\n\t}"
  },
  "org.springframework.jca.endpoint.AbstractMessageEndpointFactory#onEndpointException(ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Callback method for notifying the endpoint base class\n\t\t * that the concrete endpoint invocation led to an exception.\n\t\t * <p>To be invoked by subclasses in case of the concrete\n\t\t * endpoint throwing an exception.\n\t\t * @param ex the exception thrown from the concrete endpoint\n\t\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "void",
    "signature": "protected void onEndpointException(Throwable ex)",
    "source_code": "\t\tprotected void onEndpointException(Throwable ex) {\n\t\t\tAssert.state(this.transactionDelegate != null, \"Not initialized\");\n\t\t\tthis.transactionDelegate.setRollbackOnly();\n\t\t\tlogger.debug(\"Transaction marked as rollback-only after endpoint exception\", ex);\n\t\t}"
  },
  "org.springframework.jca.endpoint.AbstractMessageEndpointFactory#release()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "void",
    "signature": "public void release()",
    "source_code": "\t\tpublic void release() {\n\t\t\tif (this.transactionDelegate != null) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.transactionDelegate.setRollbackOnly();\n\t\t\t\t\tthis.transactionDelegate.endTransaction();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tlogger.warn(\"Could not complete unfinished transaction on endpoint release\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.jca.endpoint.AbstractMessageEndpointFactory#setBeanName(beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of this message endpoint. Populated with the bean name\n\t * automatically when defined within Spring's bean factory.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "void",
    "signature": "public void setBeanName(String beanName)",
    "source_code": "\tpublic void setBeanName(String beanName) {\n\t\tthis.beanName = beanName;\n\t}"
  },
  "org.springframework.jca.endpoint.AbstractMessageEndpointFactory#setRollbackOnly()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 346
    },
    "return": "void",
    "signature": "public void setRollbackOnly()",
    "source_code": "\t\tpublic void setRollbackOnly() {\n\t\t\tif (this.transaction != null) {\n\t\t\t\tthis.rollbackOnly = true;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.jca.endpoint.AbstractMessageEndpointFactory#setTransactionFactory(transactionFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Spring TransactionFactory to use for wrapping endpoint\n\t * invocations, enlisting the endpoint resource in each such transaction.\n\t * <p>Alternatively, specify an appropriate transaction manager through\n\t * the {@link #setTransactionManager \"transactionManager\"} property.\n\t * <p>If no transaction factory is specified, the endpoint invocation\n\t * will simply not be wrapped in an XA transaction. Check out your\n\t * resource provider's ActivationSpec documentation for local\n\t * transaction options of your particular provider.\n\t * @see #setTransactionName\n\t * @see #setTransactionTimeout\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "transactionFactory"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "void",
    "signature": "public void setTransactionFactory(TransactionFactory transactionFactory)",
    "source_code": "\tpublic void setTransactionFactory(TransactionFactory transactionFactory) {\n\t\tthis.transactionFactory = transactionFactory;\n\t}"
  },
  "org.springframework.jca.endpoint.AbstractMessageEndpointFactory#setTransactionManager(transactionManager)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the XA transaction manager to use for wrapping endpoint\n\t * invocations, enlisting the endpoint resource in each such transaction.\n\t * <p>The passed-in object may be a transaction manager which implements\n\t * Spring's {@link org.springframework.transaction.jta.TransactionFactory}\n\t * interface, or a plain {@link jakarta.transaction.TransactionManager}.\n\t * <p>If no transaction manager is specified, the endpoint invocation\n\t * will simply not be wrapped in an XA transaction. Check out your\n\t * resource provider's ActivationSpec documentation for local\n\t * transaction options of your particular provider.\n\t * @see #setTransactionName\n\t * @see #setTransactionTimeout\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "transactionManager"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "public void setTransactionManager(Object transactionManager)",
    "source_code": "\tpublic void setTransactionManager(Object transactionManager) {\n\t\tif (transactionManager instanceof TransactionFactory factory) {\n\t\t\tthis.transactionFactory = factory;\n\t\t}\n\t\telse if (transactionManager instanceof TransactionManager manager) {\n\t\t\tthis.transactionFactory = new SimpleTransactionFactory(manager);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Transaction manager [\" + transactionManager +\n\t\t\t\t\t\"] is neither a [org.springframework.transaction.jta.TransactionFactory} nor a \" +\n\t\t\t\t\t\"[jakarta.transaction.TransactionManager]\");\n\t\t}"
  },
  "org.springframework.jca.endpoint.AbstractMessageEndpointFactory#setTransactionName(transactionName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the name of the transaction, if any.\n\t * <p>Default is none. A specified name will be passed on to the transaction\n\t * manager, allowing to identify the transaction in a transaction monitor.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "transactionName"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "void",
    "signature": "public void setTransactionName(String transactionName)",
    "source_code": "\tpublic void setTransactionName(String transactionName) {\n\t\tthis.transactionName = transactionName;\n\t}"
  },
  "org.springframework.jca.endpoint.AbstractMessageEndpointFactory#setTransactionTimeout(transactionTimeout)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the transaction timeout, if any.\n\t * <p>Default is -1: rely on the transaction manager's default timeout.\n\t * Specify a concrete timeout to restrict the maximum duration of each\n\t * endpoint invocation.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "transactionTimeout"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "void",
    "signature": "public void setTransactionTimeout(int transactionTimeout)",
    "source_code": "\tpublic void setTransactionTimeout(int transactionTimeout) {\n\t\tthis.transactionTimeout = transactionTimeout;\n\t}"
  },
  "org.springframework.jca.endpoint.logger": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Logger available to subclasses. */",
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.messaging.handler.annotation.<unknown>#couldBePayload(methodParameter)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "methodParameter"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "boolean",
    "signature": "protected boolean couldBePayload(MethodParameter methodParameter)",
    "source_code": "\tprotected boolean couldBePayload(MethodParameter methodParameter) {\n\t\treturn !methodParameter.hasParameterAnnotation(DestinationVariable.class) &&\n\t\t\t\t!methodParameter.hasParameterAnnotation(Header.class) &&\n\t\t\t\t!methodParameter.hasParameterAnnotation(Headers.class) &&\n\t\t\t\t!MessageHeaders.class.isAssignableFrom(methodParameter.getParameterType()) &&\n\t\t\t\t!MessageHeaderAccessor.class.isAssignableFrom(methodParameter.getParameterType()) &&\n\t\t\t\t!Principal.class.isAssignableFrom(methodParameter.nestedIfOptional().getNestedParameterType());\n\t}"
  },
  "org.springframework.messaging.handler.annotation.<unknown>#getMessageType(parameter)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "Type",
    "signature": "protected Type getMessageType(MethodParameter parameter)",
    "source_code": "\tprotected Type getMessageType(MethodParameter parameter) {\n\t\tMethodParameter nestedParameter = parameter.nested();\n\t\treturn (nestedParameter.getNestedParameterType() == nestedParameter.getParameterType() ?\n\t\t\t\tnull : nestedParameter.getNestedParameterType());\n\t}"
  },
  "org.springframework.messaging.handler.annotation.<unknown>#registerMethodHints(hints,method)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "void",
    "signature": "protected void registerMethodHints(ReflectionHints hints, Method method)",
    "source_code": "\tprotected void registerMethodHints(ReflectionHints hints, Method method) {\n\t\thints.registerMethod(method, ExecutableMode.INVOKE);\n\t\tregisterParameterHints(hints, method);\n\t\tregisterReturnValueHints(hints, method);\n\t}"
  },
  "org.springframework.messaging.handler.annotation.<unknown>#registerParameterHints(hints,method)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "protected void registerParameterHints(ReflectionHints hints, Method method)",
    "source_code": "\tprotected void registerParameterHints(ReflectionHints hints, Method method) {\n\t\thints.registerMethod(method, ExecutableMode.INVOKE);\n\t\tfor (Parameter parameter : method.getParameters()) {\n\t\t\tMethodParameter methodParameter = MethodParameter.forParameter(parameter);\n\t\t\tif (Message.class.isAssignableFrom(methodParameter.getParameterType())) {\n\t\t\t\tthis.bindingRegistrar.registerReflectionHints(hints, getMessageType(methodParameter));\n\t\t\t}\n\t\t\telse if (couldBePayload(methodParameter)) {\n\t\t\t\tthis.bindingRegistrar.registerReflectionHints(hints, methodParameter.getGenericParameterType());\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.annotation.<unknown>#registerReflectionHints(hints,element)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hints",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "return": "void",
    "signature": "public void registerReflectionHints(ReflectionHints hints, AnnotatedElement element)",
    "source_code": "\tpublic void registerReflectionHints(ReflectionHints hints, AnnotatedElement element) {\n\t\tif (element instanceof Class<?> type) {\n\t\t\tregisterTypeHints(hints, type);\n\t\t}\n\t\telse if (element instanceof Method method) {\n\t\t\tregisterMethodHints(hints, method);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.annotation.<unknown>#registerReturnValueHints(hints,method)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "protected void registerReturnValueHints(ReflectionHints hints, Method method)",
    "source_code": "\tprotected void registerReturnValueHints(ReflectionHints hints, Method method) {\n\t\tMethodParameter returnType = MethodParameter.forExecutable(method, -1);\n\t\tthis.bindingRegistrar.registerReflectionHints(hints, returnType.getGenericParameterType());\n\t}"
  },
  "org.springframework.messaging.handler.annotation.<unknown>#registerTypeHints(hints,type)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "void",
    "signature": "protected void registerTypeHints(ReflectionHints hints, Class<?> type)",
    "source_code": "\tprotected void registerTypeHints(ReflectionHints hints, Class<?> type) {\n\t\thints.registerType(type);\n\t}"
  },
  "org.springframework.messaging.handler.annotation.MessageMappingReflectiveProcessor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link ReflectiveProcessor} implementation for types annotated\n * with {@link MessageMapping @MessageMapping},\n * {@link org.springframework.messaging.simp.annotation.SubscribeMapping @SubscribeMapping}\n * and {@link MessageExceptionHandler @MessageExceptionHandler}.\n * In addition to registering reflection hints for invoking\n * the annotated method, this implementation handles:\n *\n * <ul>\n *     <li>Return types</li>\n *     <li>Parameters identified as potential payloads</li>\n *     <li>{@link Message} parameters</li>\n *     <li>Exception classes specified via {@link MessageExceptionHandler @MessageExceptionHandler}</li>\n * </ul>\n *\n * @author Sebastien Deleuze\n * @since 6.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "signature": "public class MessageMappingReflectiveProcessor",
    "source_code": "public class MessageMappingReflectiveProcessor implements ReflectiveProcessor {\n\n\tprivate final BindingReflectionHintsRegistrar bindingRegistrar = new BindingReflectionHintsRegistrar();\n\n\n\t@Override\n\tpublic void registerReflectionHints(ReflectionHints hints, AnnotatedElement element) {\n\t\tif (element instanceof Class<?> type) {\n\t\t\tregisterTypeHints(hints, type);\n\t\t}\n\t\telse if (element instanceof Method method) {\n\t\t\tregisterMethodHints(hints, method);\n\t\t\tif (element.isAnnotationPresent(MessageExceptionHandler.class)) {\n\t\t\t\tregisterMessageExceptionHandlerHints(hints, element.getAnnotation(MessageExceptionHandler.class));\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected void registerTypeHints(ReflectionHints hints, Class<?> type) {\n\t\thints.registerType(type);\n\t}\n\n\tprotected void registerMethodHints(ReflectionHints hints, Method method) {\n\t\thints.registerMethod(method, ExecutableMode.INVOKE);\n\t\tregisterParameterHints(hints, method);\n\t\tregisterReturnValueHints(hints, method);\n\t}\n\n\tprotected void registerParameterHints(ReflectionHints hints, Method method) {\n\t\thints.registerMethod(method, ExecutableMode.INVOKE);\n\t\tfor (Parameter parameter : method.getParameters()) {\n\t\t\tMethodParameter methodParameter = MethodParameter.forParameter(parameter);\n\t\t\tif (Message.class.isAssignableFrom(methodParameter.getParameterType())) {\n\t\t\t\tthis.bindingRegistrar.registerReflectionHints(hints, getMessageType(methodParameter));\n\t\t\t}\n\t\t\telse if (couldBePayload(methodParameter)) {\n\t\t\t\tthis.bindingRegistrar.registerReflectionHints(hints, methodParameter.getGenericParameterType());\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected void registerMessageExceptionHandlerHints(ReflectionHints hints, MessageExceptionHandler annotation) {\n\t\tfor (Class<?> exceptionClass : annotation.value()) {\n\t\t\thints.registerType(exceptionClass);\n\t\t}\n\t}\n\n\tprotected boolean couldBePayload(MethodParameter methodParameter) {\n\t\treturn !methodParameter.hasParameterAnnotation(DestinationVariable.class) &&\n\t\t\t\t!methodParameter.hasParameterAnnotation(Header.class) &&\n\t\t\t\t!methodParameter.hasParameterAnnotation(Headers.class) &&\n\t\t\t\t!MessageHeaders.class.isAssignableFrom(methodParameter.getParameterType()) &&\n\t\t\t\t!MessageHeaderAccessor.class.isAssignableFrom(methodParameter.getParameterType()) &&\n\t\t\t\t!Principal.class.isAssignableFrom(methodParameter.nestedIfOptional().getNestedParameterType());\n\t}\n\n\tprotected void registerReturnValueHints(ReflectionHints hints, Method method) {\n\t\tMethodParameter returnType = MethodParameter.forExecutable(method, -1);\n\t\tthis.bindingRegistrar.registerReflectionHints(hints, returnType.getGenericParameterType());\n\t}\n\n\t@Nullable\n\tprotected Type getMessageType(MethodParameter parameter) {\n\t\tMethodParameter nestedParameter = parameter.nested();\n\t\treturn (nestedParameter.getNestedParameterType() == nestedParameter.getParameterType() ?\n\t\t\t\tnull : nestedParameter.getNestedParameterType());\n\t}\n\n}"
  },
  "org.springframework.messaging.handler.annotation.MessageMappingReflectiveProcessor#couldBePayload(methodParameter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "methodParameter"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "boolean",
    "signature": "protected boolean couldBePayload(MethodParameter methodParameter)",
    "source_code": "\tprotected boolean couldBePayload(MethodParameter methodParameter) {\n\t\treturn !methodParameter.hasParameterAnnotation(DestinationVariable.class) &&\n\t\t\t\t!methodParameter.hasParameterAnnotation(Header.class) &&\n\t\t\t\t!methodParameter.hasParameterAnnotation(Headers.class) &&\n\t\t\t\t!MessageHeaders.class.isAssignableFrom(methodParameter.getParameterType()) &&\n\t\t\t\t!MessageHeaderAccessor.class.isAssignableFrom(methodParameter.getParameterType()) &&\n\t\t\t\t!Principal.class.isAssignableFrom(methodParameter.nestedIfOptional().getNestedParameterType());\n\t}"
  },
  "org.springframework.messaging.handler.annotation.MessageMappingReflectiveProcessor#getMessageType(parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "Type",
    "signature": "protected Type getMessageType(MethodParameter parameter)",
    "source_code": "\tprotected Type getMessageType(MethodParameter parameter) {\n\t\tMethodParameter nestedParameter = parameter.nested();\n\t\treturn (nestedParameter.getNestedParameterType() == nestedParameter.getParameterType() ?\n\t\t\t\tnull : nestedParameter.getNestedParameterType());\n\t}"
  },
  "org.springframework.messaging.handler.annotation.MessageMappingReflectiveProcessor#registerMessageExceptionHandlerHints(hints,annotation)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "annotation"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "void",
    "signature": "protected void registerMessageExceptionHandlerHints(ReflectionHints hints, MessageExceptionHandler annotation)",
    "source_code": "\tprotected void registerMessageExceptionHandlerHints(ReflectionHints hints, MessageExceptionHandler annotation) {\n\t\tfor (Class<?> exceptionClass : annotation.value()) {\n\t\t\thints.registerType(exceptionClass);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.annotation.MessageMappingReflectiveProcessor#registerMethodHints(hints,method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "void",
    "signature": "protected void registerMethodHints(ReflectionHints hints, Method method)",
    "source_code": "\tprotected void registerMethodHints(ReflectionHints hints, Method method) {\n\t\thints.registerMethod(method, ExecutableMode.INVOKE);\n\t\tregisterParameterHints(hints, method);\n\t\tregisterReturnValueHints(hints, method);\n\t}"
  },
  "org.springframework.messaging.handler.annotation.MessageMappingReflectiveProcessor#registerParameterHints(hints,method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "void",
    "signature": "protected void registerParameterHints(ReflectionHints hints, Method method)",
    "source_code": "\tprotected void registerParameterHints(ReflectionHints hints, Method method) {\n\t\thints.registerMethod(method, ExecutableMode.INVOKE);\n\t\tfor (Parameter parameter : method.getParameters()) {\n\t\t\tMethodParameter methodParameter = MethodParameter.forParameter(parameter);\n\t\t\tif (Message.class.isAssignableFrom(methodParameter.getParameterType())) {\n\t\t\t\tthis.bindingRegistrar.registerReflectionHints(hints, getMessageType(methodParameter));\n\t\t\t}\n\t\t\telse if (couldBePayload(methodParameter)) {\n\t\t\t\tthis.bindingRegistrar.registerReflectionHints(hints, methodParameter.getGenericParameterType());\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.annotation.MessageMappingReflectiveProcessor#registerReflectionHints(hints,element)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hints",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "void",
    "signature": "public void registerReflectionHints(ReflectionHints hints, AnnotatedElement element)",
    "source_code": "\tpublic void registerReflectionHints(ReflectionHints hints, AnnotatedElement element) {\n\t\tif (element instanceof Class<?> type) {\n\t\t\tregisterTypeHints(hints, type);\n\t\t}\n\t\telse if (element instanceof Method method) {\n\t\t\tregisterMethodHints(hints, method);\n\t\t\tif (element.isAnnotationPresent(MessageExceptionHandler.class)) {\n\t\t\t\tregisterMessageExceptionHandlerHints(hints, element.getAnnotation(MessageExceptionHandler.class));\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.annotation.MessageMappingReflectiveProcessor#registerReturnValueHints(hints,method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "void",
    "signature": "protected void registerReturnValueHints(ReflectionHints hints, Method method)",
    "source_code": "\tprotected void registerReturnValueHints(ReflectionHints hints, Method method) {\n\t\tMethodParameter returnType = MethodParameter.forExecutable(method, -1);\n\t\tthis.bindingRegistrar.registerReflectionHints(hints, returnType.getGenericParameterType());\n\t}"
  },
  "org.springframework.messaging.handler.annotation.MessageMappingReflectiveProcessor#registerTypeHints(hints,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "void",
    "signature": "protected void registerTypeHints(ReflectionHints hints, Class<?> type)",
    "source_code": "\tprotected void registerTypeHints(ReflectionHints hints, Class<?> type) {\n\t\thints.registerType(type);\n\t}"
  },
  "org.springframework.messaging.handler.annotation.reactive.PayloadMethodArgumentResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A resolver to extract and decode the payload of a message using a\n * {@link Decoder}, where the payload is expected to be a {@link Publisher} of\n * {@link DataBuffer DataBuffer}.\n *\n * <p>Validation is applied if the method argument is annotated with\n * {@code @jakarta.validation.Valid} or\n * {@link org.springframework.validation.annotation.Validated}. Validation\n * failure results in an {@link MethodArgumentNotValidException}.\n *\n * <p>This resolver should be ordered last if {@link #useDefaultResolution} is\n * set to {@code true} since in that case it supports all types and does not\n * require the presence of {@link Payload}.\n *\n * @author Rossen Stoyanchev\n * @since 5.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "signature": "public class PayloadMethodArgumentResolver",
    "source_code": "public class PayloadMethodArgumentResolver implements HandlerMethodArgumentResolver {\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\n\tprivate final List<Decoder<?>> decoders;\n\n\t@Nullable\n\tprivate final Validator validator;\n\n\tprivate final ReactiveAdapterRegistry adapterRegistry;\n\n\tprivate final boolean useDefaultResolution;\n\n\n\tpublic PayloadMethodArgumentResolver(List<? extends Decoder<?>> decoders, @Nullable Validator validator,\n\t\t\t@Nullable ReactiveAdapterRegistry registry, boolean useDefaultResolution) {\n\n\t\tAssert.isTrue(!CollectionUtils.isEmpty(decoders), \"At least one Decoder is required\");\n\t\tthis.decoders = Collections.unmodifiableList(new ArrayList<>(decoders));\n\t\tthis.validator = validator;\n\t\tthis.adapterRegistry = registry != null ? registry : ReactiveAdapterRegistry.getSharedInstance();\n\t\tthis.useDefaultResolution = useDefaultResolution;\n\t}\n\n\n\t/**\n\t * Return a read-only list of the configured decoders.\n\t */\n\tpublic List<Decoder<?>> getDecoders() {\n\t\treturn this.decoders;\n\t}\n\n\t/**\n\t * Return the configured validator, if any.\n\t */\n\t@Nullable\n\tpublic Validator getValidator() {\n\t\treturn this.validator;\n\t}\n\n\t/**\n\t * Return the configured {@link ReactiveAdapterRegistry}.\n\t */\n\tpublic ReactiveAdapterRegistry getAdapterRegistry() {\n\t\treturn this.adapterRegistry;\n\t}\n\n\t/**\n\t * Whether this resolver is configured to use default resolution, i.e.\n\t * works for any argument type regardless of whether {@code @Payload} is\n\t * present or not.\n\t */\n\tpublic boolean isUseDefaultResolution() {\n\t\treturn this.useDefaultResolution;\n\t}\n\n\n\t@Override\n\tpublic boolean supportsParameter(MethodParameter parameter) {\n\t\treturn parameter.hasParameterAnnotation(Payload.class) || this.useDefaultResolution;\n\t}\n\n\n\t/**\n\t * Decode the content of the given message payload through a compatible\n\t * {@link Decoder}.\n\t *\n\t * <p>Validation is applied if the method argument is annotated with\n\t * {@code @jakarta.validation.Valid} or\n\t * {@link org.springframework.validation.annotation.Validated}. Validation\n\t * failure results in an {@link MethodArgumentNotValidException}.\n\t * @param parameter the target method argument that we are decoding to\n\t * @param message the message from which the content was extracted\n\t * @return a Mono with the result of argument resolution\n\t * @see #extractContent(MethodParameter, Message)\n\t * @see #getMimeType(Message)\n\t */\n\t@Override\n\tpublic final Mono<Object> resolveArgument(MethodParameter parameter, Message<?> message) {\n\n\t\tPayload ann = parameter.getParameterAnnotation(Payload.class);\n\t\tif (ann != null && StringUtils.hasText(ann.expression())) {\n\t\t\tthrow new IllegalStateException(\"@Payload SpEL expressions not supported by this resolver\");\n\t\t}\n\n\t\tMimeType mimeType = getMimeType(message);\n\t\tmimeType = mimeType != null ? mimeType : MimeTypeUtils.APPLICATION_OCTET_STREAM;\n\n\t\tFlux<DataBuffer> content = extractContent(parameter, message);\n\t\treturn decodeContent(parameter, message, ann == null || ann.required(), content, mimeType);\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate Flux<DataBuffer> extractContent(MethodParameter parameter, Message<?> message) {\n\t\tObject payload = message.getPayload();\n\t\tif (payload instanceof DataBuffer dataBuffer) {\n\t\t\treturn Flux.just(dataBuffer);\n\t\t}\n\t\tif (payload instanceof Publisher<?> publisher) {\n\t\t\treturn Flux.from(publisher).map(value -> {\n\t\t\t\tif (value instanceof DataBuffer dataBuffer) {\n\t\t\t\t\treturn dataBuffer;\n\t\t\t\t}\n\t\t\t\tString className = value.getClass().getName();\n\t\t\t\tthrow getUnexpectedPayloadError(message, parameter, \"Publisher<\" + className + \">\");\n\t\t\t});\n\t\t}\n\t\treturn Flux.error(getUnexpectedPayloadError(message, parameter, payload.getClass().getName()));\n\t}\n\n\tprivate MethodArgumentResolutionException getUnexpectedPayloadError(\n\t\t\tMessage<?> message, MethodParameter parameter, String actualType) {\n\n\t\treturn new MethodArgumentResolutionException(message, parameter,\n\t\t\t\t\"Expected DataBuffer or Publisher<DataBuffer> for the Message payload, actual: \" + actualType);\n\t}\n\n\t/**\n\t * Return the mime type for the content. By default this method checks the\n\t * {@link MessageHeaders#CONTENT_TYPE} header expecting to find a\n\t * {@link MimeType} value or a String to parse to a {@link MimeType}.\n\t * @param message the input message\n\t */\n\t@Nullable\n\tprotected MimeType getMimeType(Message<?> message) {\n\t\tObject headerValue = message.getHeaders().get(MessageHeaders.CONTENT_TYPE);\n\t\tif (headerValue == null) {\n\t\t\treturn null;\n\t\t}\n\t\telse if (headerValue instanceof String stringHeader) {\n\t\t\treturn MimeTypeUtils.parseMimeType(stringHeader);\n\t\t}\n\t\telse if (headerValue instanceof MimeType mimeTypeHeader) {\n\t\t\treturn mimeTypeHeader;\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Unexpected MimeType value: \" + headerValue);\n\t\t}\n\t}\n\n\tprivate Mono<Object> decodeContent(MethodParameter parameter, Message<?> message,\n\t\t\tboolean isContentRequired, Flux<DataBuffer> content, MimeType mimeType) {\n\n\t\tResolvableType targetType = ResolvableType.forMethodParameter(parameter);\n\t\tClass<?> resolvedType = targetType.resolve();\n\t\tReactiveAdapter adapter = (resolvedType != null ? getAdapterRegistry().getAdapter(resolvedType) : null);\n\t\tResolvableType elementType = (adapter != null ? targetType.getGeneric() : targetType);\n\t\tisContentRequired = isContentRequired || (adapter != null && !adapter.supportsEmpty());\n\t\tConsumer<Object> validator = getValidator(message, parameter);\n\n\t\tMap<String, Object> hints = Collections.emptyMap();\n\n\t\tfor (Decoder<?> decoder : this.decoders) {\n\t\t\tif (decoder.canDecode(elementType, mimeType)) {\n\t\t\t\tif (adapter != null && adapter.isMultiValue()) {\n\t\t\t\t\tFlux<?> flux = content\n\t\t\t\t\t\t\t.filter(this::nonEmptyDataBuffer)\n\t\t\t\t\t\t\t.map(buffer -> decoder.decode(buffer, elementType, mimeType, hints))\n\t\t\t\t\t\t\t.onErrorResume(ex -> Flux.error(handleReadError(parameter, message, ex)));\n\t\t\t\t\tif (isContentRequired) {\n\t\t\t\t\t\tflux = flux.switchIfEmpty(Flux.error(() -> handleMissingBody(parameter, message)));\n\t\t\t\t\t}\n\t\t\t\t\tif (validator != null) {\n\t\t\t\t\t\tflux = flux.doOnNext(validator);\n\t\t\t\t\t}\n\t\t\t\t\treturn Mono.just(adapter.fromPublisher(flux));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Single-value (with or without reactive type wrapper)\n\t\t\t\t\tMono<?> mono = content.next()\n\t\t\t\t\t\t\t.filter(this::nonEmptyDataBuffer)\n\t\t\t\t\t\t\t.map(buffer -> decoder.decode(buffer, elementType, mimeType, hints))\n\t\t\t\t\t\t\t.onErrorResume(ex -> Mono.error(handleReadError(parameter, message, ex)));\n\t\t\t\t\tif (isContentRequired) {\n\t\t\t\t\t\tmono = mono.switchIfEmpty(Mono.error(() -> handleMissingBody(parameter, message)));\n\t\t\t\t\t}\n\t\t\t\t\tif (validator != null) {\n\t\t\t\t\t\tmono = mono.doOnNext(validator);\n\t\t\t\t\t}\n\t\t\t\t\treturn (adapter != null ? Mono.just(adapter.fromPublisher(mono)) : Mono.from(mono));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn Mono.error(new MethodArgumentResolutionException(\n\t\t\t\tmessage, parameter, \"Cannot decode to [\" + targetType + \"]\" + message));\n\t}\n\n\tprivate boolean nonEmptyDataBuffer(DataBuffer buffer) {\n\t\tif (buffer.readableByteCount() > 0) {\n\t\t\treturn true;\n\t\t}\n\t\tDataBufferUtils.release(buffer);\n\t\treturn false;\n\t}\n\n\tprivate Throwable handleReadError(MethodParameter parameter, Message<?> message, Throwable ex) {\n\t\treturn ex instanceof DecodingException ?\n\t\t\t\tnew MethodArgumentResolutionException(message, parameter, \"Failed to read HTTP message\", ex) : ex;\n\t}\n\n\tprivate MethodArgumentResolutionException handleMissingBody(MethodParameter param, Message<?> message) {\n\t\treturn new MethodArgumentResolutionException(message, param,\n\t\t\t\t\"Payload content is missing: \" + param.getExecutable().toGenericString());\n\t}\n\n\t@Nullable\n\tprivate Consumer<Object> getValidator(Message<?> message, MethodParameter parameter) {\n\t\tif (this.validator == null) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (Annotation ann : parameter.getParameterAnnotations()) {\n\t\t\tValidated validatedAnn = AnnotationUtils.getAnnotation(ann, Validated.class);\n\t\t\tif (validatedAnn != null || ann.annotationType().getSimpleName().startsWith(\"Valid\")) {\n\t\t\t\tObject hints = (validatedAnn != null ? validatedAnn.value() : AnnotationUtils.getValue(ann));\n\t\t\t\tObject[] validationHints = (hints instanceof Object[] objectHints ? objectHints : new Object[] {hints});\n\t\t\t\tString name = Conventions.getVariableNameForParameter(parameter);\n\t\t\t\treturn target -> {\n\t\t\t\t\tBeanPropertyBindingResult bindingResult = new BeanPropertyBindingResult(target, name);\n\t\t\t\t\tif (!ObjectUtils.isEmpty(validationHints) && this.validator instanceof SmartValidator sv) {\n\t\t\t\t\t\tsv.validate(target, bindingResult, validationHints);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.validator.validate(target, bindingResult);\n\t\t\t\t\t}\n\t\t\t\t\tif (bindingResult.hasErrors()) {\n\t\t\t\t\t\tthrow new MethodArgumentNotValidException(message, parameter, bindingResult);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n}"
  },
  "org.springframework.messaging.handler.annotation.reactive.PayloadMethodArgumentResolver#getAdapterRegistry()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured {@link ReactiveAdapterRegistry}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "ReactiveAdapterRegistry",
    "signature": "public ReactiveAdapterRegistry getAdapterRegistry()",
    "source_code": "\tpublic ReactiveAdapterRegistry getAdapterRegistry() {\n\t\treturn this.adapterRegistry;\n\t}"
  },
  "org.springframework.messaging.handler.annotation.reactive.PayloadMethodArgumentResolver#getMimeType(message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the mime type for the content. By default this method checks the\n\t * {@link MessageHeaders#CONTENT_TYPE} header expecting to find a\n\t * {@link MimeType} value or a String to parse to a {@link MimeType}.\n\t * @param message the input message\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "MimeType",
    "signature": "protected MimeType getMimeType(Message<?> message)",
    "source_code": "\tprotected MimeType getMimeType(Message<?> message) {\n\t\tObject headerValue = message.getHeaders().get(MessageHeaders.CONTENT_TYPE);\n\t\tif (headerValue == null) {\n\t\t\treturn null;\n\t\t}\n\t\telse if (headerValue instanceof String stringHeader) {\n\t\t\treturn MimeTypeUtils.parseMimeType(stringHeader);\n\t\t}\n\t\telse if (headerValue instanceof MimeType mimeTypeHeader) {\n\t\t\treturn mimeTypeHeader;\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Unexpected MimeType value: \" + headerValue);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.annotation.reactive.PayloadMethodArgumentResolver#getValidator()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured validator, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "Validator",
    "signature": "public Validator getValidator()",
    "source_code": "\tpublic Validator getValidator() {\n\t\treturn this.validator;\n\t}"
  },
  "org.springframework.messaging.handler.annotation.reactive.PayloadMethodArgumentResolver#isUseDefaultResolution()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether this resolver is configured to use default resolution, i.e.\n\t * works for any argument type regardless of whether {@code @Payload} is\n\t * present or not.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "boolean",
    "signature": "public boolean isUseDefaultResolution()",
    "source_code": "\tpublic boolean isUseDefaultResolution() {\n\t\treturn this.useDefaultResolution;\n\t}"
  },
  "org.springframework.messaging.handler.annotation.reactive.PayloadMethodArgumentResolver#resolveArgument(parameter,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Decode the content of the given message payload through a compatible\n\t * {@link Decoder}.\n\t *\n\t * <p>Validation is applied if the method argument is annotated with\n\t * {@code @jakarta.validation.Valid} or\n\t * {@link org.springframework.validation.annotation.Validated}. Validation\n\t * failure results in an {@link MethodArgumentNotValidException}.\n\t * @param parameter the target method argument that we are decoding to\n\t * @param message the message from which the content was extracted\n\t * @return a Mono with the result of argument resolution\n\t * @see #extractContent(MethodParameter, Message)\n\t * @see #getMimeType(Message)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "Mono<Object>",
    "signature": "public Mono<Object> resolveArgument(MethodParameter parameter, Message<?> message)",
    "source_code": "\tpublic final Mono<Object> resolveArgument(MethodParameter parameter, Message<?> message) {\n\n\t\tPayload ann = parameter.getParameterAnnotation(Payload.class);\n\t\tif (ann != null && StringUtils.hasText(ann.expression())) {\n\t\t\tthrow new IllegalStateException(\"@Payload SpEL expressions not supported by this resolver\");\n\t\t}\n\n\t\tMimeType mimeType = getMimeType(message);\n\t\tmimeType = mimeType != null ? mimeType : MimeTypeUtils.APPLICATION_OCTET_STREAM;\n\n\t\tFlux<DataBuffer> content = extractContent(parameter, message);\n\t\treturn decodeContent(parameter, message, ann == null || ann.required(), content, mimeType);\n\t}"
  },
  "org.springframework.messaging.handler.annotation.reactive.PayloadMethodArgumentResolver#supportsParameter(parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "boolean",
    "signature": "public boolean supportsParameter(MethodParameter parameter)",
    "source_code": "\tpublic boolean supportsParameter(MethodParameter parameter) {\n\t\treturn parameter.hasParameterAnnotation(Payload.class) || this.useDefaultResolution;\n\t}"
  },
  "org.springframework.messaging.handler.annotation.reactive.logger": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.transaction.interceptor.CoroutinesInvocationCallback": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Coroutines-supporting extension of the callback interface.\n\t */",
    "kind": "interface",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 818
    },
    "signature": "protected interface CoroutinesInvocationCallback",
    "source_code": "\tprotected interface CoroutinesInvocationCallback extends InvocationCallback {\n\n\t\tObject getTarget();\n\n\t\tObject[] getArguments();\n\n\t\tdefault Object getContinuation() {\n\t\t\tObject[] args = getArguments();\n\t\t\treturn args[args.length - 1];\n\t\t}\n\t}"
  },
  "org.springframework.transaction.interceptor.InvocationCallback": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Simple callback interface for proceeding with the target invocation.\n\t * Concrete interceptors/aspects adapt this to their invocation mechanism.\n\t */",
    "kind": "interface",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 808
    },
    "signature": "protected interface InvocationCallback",
    "source_code": "\tprotected interface InvocationCallback {\n\n\t\t@Nullable\n\t\tObject proceedWithInvocation() throws Throwable;\n\t}"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Base class for transactional aspects, such as the {@link TransactionInterceptor}\n * or an AspectJ aspect.\n *\n * <p>This enables the underlying Spring transaction infrastructure to be used easily\n * to implement an aspect for any aspect system.\n *\n * <p>Subclasses are responsible for calling methods in this class in the correct order.\n *\n * <p>If no transaction name has been specified in the {@link TransactionAttribute},\n * the exposed name will be the {@code fully-qualified class name + \".\" + method name}\n * (by default).\n *\n * <p>Uses the <b>Strategy</b> design pattern. A {@link PlatformTransactionManager} or\n * {@link ReactiveTransactionManager} implementation will perform the actual transaction\n * management, and a {@link TransactionAttributeSource} (e.g. annotation-based) is used\n * for determining transaction definitions for a particular class or method.\n *\n * <p>A transaction aspect is serializable if its {@code TransactionManager} and\n * {@code TransactionAttributeSource} are serializable.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author St\u00e9phane Nicoll\n * @author Sam Brannen\n * @author Mark Paluch\n * @author Sebastien Deleuze\n * @since 1.1\n * @see PlatformTransactionManager\n * @see ReactiveTransactionManager\n * @see #setTransactionManager\n * @see #setTransactionAttributes\n * @see #setTransactionAttributeSource\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "signature": "public class TransactionAspectSupport",
    "source_code": "public abstract class TransactionAspectSupport implements BeanFactoryAware, InitializingBean {\n\n\t// NOTE: This class must not implement Serializable because it serves as base\n\t// class for AspectJ aspects (which are not allowed to implement Serializable)!\n\n\n\t/**\n\t * Key to use to store the default transaction manager.\n\t */\n\tprivate static final Object DEFAULT_TRANSACTION_MANAGER_KEY = new Object();\n\n\tprivate static final String COROUTINES_FLOW_CLASS_NAME = \"kotlinx.coroutines.flow.Flow\";\n\n\t/**\n\t * Vavr library present on the classpath?\n\t */\n\tprivate static final boolean vavrPresent = ClassUtils.isPresent(\n\t\t\t\"io.vavr.control.Try\", TransactionAspectSupport.class.getClassLoader());\n\n\t/**\n\t * Reactive Streams API present on the classpath?\n\t */\n\tprivate static final boolean reactiveStreamsPresent =\n\t\t\tClassUtils.isPresent(\"org.reactivestreams.Publisher\", TransactionAspectSupport.class.getClassLoader());\n\n\t/**\n\t * Holder to support the {@code currentTransactionStatus()} method,\n\t * and to support communication between different cooperating advices\n\t * (e.g. before and after advice) if the aspect involves more than a\n\t * single method (as will be the case for around advice).\n\t */\n\tprivate static final ThreadLocal<TransactionInfo> transactionInfoHolder =\n\t\t\tnew NamedThreadLocal<>(\"Current aspect-driven transaction\");\n\n\n\t/**\n\t * Subclasses can use this to return the current TransactionInfo.\n\t * Only subclasses that cannot handle all operations in one method,\n\t * such as an AspectJ aspect involving distinct before and after advice,\n\t * need to use this mechanism to get at the current TransactionInfo.\n\t * An around advice such as an AOP Alliance MethodInterceptor can hold a\n\t * reference to the TransactionInfo throughout the aspect method.\n\t * <p>A TransactionInfo will be returned even if no transaction was created.\n\t * The {@code TransactionInfo.hasTransaction()} method can be used to query this.\n\t * <p>To find out about specific transaction characteristics, consider using\n\t * TransactionSynchronizationManager's {@code isSynchronizationActive()}\n\t * and/or {@code isActualTransactionActive()} methods.\n\t * @return the TransactionInfo bound to this thread, or {@code null} if none\n\t * @see TransactionInfo#hasTransaction()\n\t * @see org.springframework.transaction.support.TransactionSynchronizationManager#isSynchronizationActive()\n\t * @see org.springframework.transaction.support.TransactionSynchronizationManager#isActualTransactionActive()\n\t */\n\t@Nullable\n\tprotected static TransactionInfo currentTransactionInfo() throws NoTransactionException {\n\t\treturn transactionInfoHolder.get();\n\t}\n\n\t/**\n\t * Return the transaction status of the current method invocation.\n\t * Mainly intended for code that wants to set the current transaction\n\t * rollback-only but not throw an application exception.\n\t * @throws NoTransactionException if the transaction info cannot be found,\n\t * because the method was invoked outside an AOP invocation context\n\t */\n\tpublic static TransactionStatus currentTransactionStatus() throws NoTransactionException {\n\t\tTransactionInfo info = currentTransactionInfo();\n\t\tif (info == null || info.transactionStatus == null) {\n\t\t\tthrow new NoTransactionException(\"No transaction aspect-managed TransactionStatus in scope\");\n\t\t}\n\t\treturn info.transactionStatus;\n\t}\n\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\t@Nullable\n\tprivate final ReactiveAdapterRegistry reactiveAdapterRegistry;\n\n\t@Nullable\n\tprivate String transactionManagerBeanName;\n\n\t@Nullable\n\tprivate TransactionManager transactionManager;\n\n\t@Nullable\n\tprivate TransactionAttributeSource transactionAttributeSource;\n\n\t@Nullable\n\tprivate BeanFactory beanFactory;\n\n\tprivate final ConcurrentMap<Object, TransactionManager> transactionManagerCache =\n\t\t\tnew ConcurrentReferenceHashMap<>(4);\n\n\tprivate final ConcurrentMap<Method, ReactiveTransactionSupport> transactionSupportCache =\n\t\t\tnew ConcurrentReferenceHashMap<>(1024);\n\n\n\tprotected TransactionAspectSupport() {\n\t\tif (reactiveStreamsPresent) {\n\t\t\tthis.reactiveAdapterRegistry = ReactiveAdapterRegistry.getSharedInstance();\n\t\t}\n\t\telse {\n\t\t\tthis.reactiveAdapterRegistry = null;\n\t\t}\n\t}\n\n\n\t/**\n\t * Specify the name of the default transaction manager bean.\n\t * <p>This can either point to a traditional {@link PlatformTransactionManager} or a\n\t * {@link ReactiveTransactionManager} for reactive transaction management.\n\t */\n\tpublic void setTransactionManagerBeanName(@Nullable String transactionManagerBeanName) {\n\t\tthis.transactionManagerBeanName = transactionManagerBeanName;\n\t}\n\n\t/**\n\t * Return the name of the default transaction manager bean.\n\t */\n\t@Nullable\n\tprotected final String getTransactionManagerBeanName() {\n\t\treturn this.transactionManagerBeanName;\n\t}\n\n\t/**\n\t * Specify the <em>default</em> transaction manager to use to drive transactions.\n\t * <p>This can either be a traditional {@link PlatformTransactionManager} or a\n\t * {@link ReactiveTransactionManager} for reactive transaction management.\n\t * <p>The default transaction manager will be used if a <em>qualifier</em>\n\t * has not been declared for a given transaction or if an explicit name for the\n\t * default transaction manager bean has not been specified.\n\t * @see #setTransactionManagerBeanName\n\t */\n\tpublic void setTransactionManager(@Nullable TransactionManager transactionManager) {\n\t\tthis.transactionManager = transactionManager;\n\t}\n\n\t/**\n\t * Return the default transaction manager, or {@code null} if unknown.\n\t * <p>This can either be a traditional {@link PlatformTransactionManager} or a\n\t * {@link ReactiveTransactionManager} for reactive transaction management.\n\t */\n\t@Nullable\n\tpublic TransactionManager getTransactionManager() {\n\t\treturn this.transactionManager;\n\t}\n\n\t/**\n\t * Set properties with method names as keys and transaction attribute\n\t * descriptors (parsed via TransactionAttributeEditor) as values:\n\t * e.g. key = \"myMethod\", value = \"PROPAGATION_REQUIRED,readOnly\".\n\t * <p>Note: Method names are always applied to the target class,\n\t * no matter if defined in an interface or the class itself.\n\t * <p>Internally, a NameMatchTransactionAttributeSource will be\n\t * created from the given properties.\n\t * @see #setTransactionAttributeSource\n\t * @see TransactionAttributeEditor\n\t * @see NameMatchTransactionAttributeSource\n\t */\n\tpublic void setTransactionAttributes(Properties transactionAttributes) {\n\t\tNameMatchTransactionAttributeSource tas = new NameMatchTransactionAttributeSource();\n\t\ttas.setProperties(transactionAttributes);\n\t\tthis.transactionAttributeSource = tas;\n\t}\n\n\t/**\n\t * Set multiple transaction attribute sources which are used to find transaction\n\t * attributes. Will build a CompositeTransactionAttributeSource for the given sources.\n\t * @see CompositeTransactionAttributeSource\n\t * @see MethodMapTransactionAttributeSource\n\t * @see NameMatchTransactionAttributeSource\n\t * @see org.springframework.transaction.annotation.AnnotationTransactionAttributeSource\n\t */\n\tpublic void setTransactionAttributeSources(TransactionAttributeSource... transactionAttributeSources) {\n\t\tthis.transactionAttributeSource = new CompositeTransactionAttributeSource(transactionAttributeSources);\n\t}\n\n\t/**\n\t * Set the transaction attribute source which is used to find transaction\n\t * attributes. If specifying a String property value, a PropertyEditor\n\t * will create a MethodMapTransactionAttributeSource from the value.\n\t * @see TransactionAttributeSourceEditor\n\t * @see MethodMapTransactionAttributeSource\n\t * @see NameMatchTransactionAttributeSource\n\t * @see org.springframework.transaction.annotation.AnnotationTransactionAttributeSource\n\t */\n\tpublic void setTransactionAttributeSource(@Nullable TransactionAttributeSource transactionAttributeSource) {\n\t\tthis.transactionAttributeSource = transactionAttributeSource;\n\t}\n\n\t/**\n\t * Return the transaction attribute source.\n\t */\n\t@Nullable\n\tpublic TransactionAttributeSource getTransactionAttributeSource() {\n\t\treturn this.transactionAttributeSource;\n\t}\n\n\t/**\n\t * Set the BeanFactory to use for retrieving {@code TransactionManager} beans.\n\t */\n\t@Override\n\tpublic void setBeanFactory(@Nullable BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t}\n\n\t/**\n\t * Return the BeanFactory to use for retrieving {@code TransactionManager} beans.\n\t */\n\t@Nullable\n\tprotected final BeanFactory getBeanFactory() {\n\t\treturn this.beanFactory;\n\t}\n\n\t/**\n\t * Check that required properties were set.\n\t */\n\t@Override\n\tpublic void afterPropertiesSet() {\n\t\tif (getTransactionManager() == null && this.beanFactory == null) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Set the 'transactionManager' property or make sure to run within a BeanFactory \" +\n\t\t\t\t\t\"containing a TransactionManager bean!\");\n\t\t}\n\t\tif (getTransactionAttributeSource() == null) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Either 'transactionAttributeSource' or 'transactionAttributes' is required: \" +\n\t\t\t\t\t\"If there are no transactional methods, then don't use a transaction aspect.\");\n\t\t}\n\t}\n\n\n\t/**\n\t * General delegate for around-advice-based subclasses, delegating to several other template\n\t * methods on this class. Able to handle {@link CallbackPreferringPlatformTransactionManager}\n\t * as well as regular {@link PlatformTransactionManager} implementations and\n\t * {@link ReactiveTransactionManager} implementations for reactive return types.\n\t * @param method the Method being invoked\n\t * @param targetClass the target class that we're invoking the method on\n\t * @param invocation the callback to use for proceeding with the target invocation\n\t * @return the return value of the method, if any\n\t * @throws Throwable propagated from the target invocation\n\t */\n\t@Nullable\n\tprotected Object invokeWithinTransaction(Method method, @Nullable Class<?> targetClass,\n\t\t\tfinal InvocationCallback invocation) throws Throwable {\n\n\t\t// If the transaction attribute is null, the method is non-transactional.\n\t\tTransactionAttributeSource tas = getTransactionAttributeSource();\n\t\tfinal TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null);\n\t\tfinal TransactionManager tm = determineTransactionManager(txAttr);\n\n\t\tif (this.reactiveAdapterRegistry != null && tm instanceof ReactiveTransactionManager rtm) {\n\t\t\tboolean isSuspendingFunction = KotlinDetector.isSuspendingFunction(method);\n\t\t\tboolean hasSuspendingFlowReturnType = isSuspendingFunction &&\n\t\t\t\t\tCOROUTINES_FLOW_CLASS_NAME.equals(new MethodParameter(method, -1).getParameterType().getName());\n\t\t\tif (isSuspendingFunction && !(invocation instanceof CoroutinesInvocationCallback)) {\n\t\t\t\tthrow new IllegalStateException(\"Coroutines invocation not supported: \" + method);\n\t\t\t}\n\t\t\tCoroutinesInvocationCallback corInv = (isSuspendingFunction ? (CoroutinesInvocationCallback) invocation : null);\n\n\t\t\tReactiveTransactionSupport txSupport = this.transactionSupportCache.computeIfAbsent(method, key -> {\n\t\t\t\tClass<?> reactiveType =\n\t\t\t\t\t\t(isSuspendingFunction ? (hasSuspendingFlowReturnType ? Flux.class : Mono.class) : method.getReturnType());\n\t\t\t\tReactiveAdapter adapter = this.reactiveAdapterRegistry.getAdapter(reactiveType);\n\t\t\t\tif (adapter == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Cannot apply reactive transaction to non-reactive return type: \" +\n\t\t\t\t\t\t\tmethod.getReturnType());\n\t\t\t\t}\n\t\t\t\treturn new ReactiveTransactionSupport(adapter);\n\t\t\t});\n\n\t\t\tInvocationCallback callback = invocation;\n\t\t\tif (corInv != null) {\n\t\t\t\tcallback = () -> KotlinDelegate.invokeSuspendingFunction(method, corInv);\n\t\t\t}\n\t\t\tObject result = txSupport.invokeWithinTransaction(method, targetClass, callback, txAttr, rtm);\n\t\t\tif (corInv != null) {\n\t\t\t\tPublisher<?> pr = (Publisher<?>) result;\n\t\t\t\treturn (hasSuspendingFlowReturnType ? KotlinDelegate.asFlow(pr) :\n\t\t\t\t\t\tKotlinDelegate.awaitSingleOrNull(pr, corInv.getContinuation()));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tPlatformTransactionManager ptm = asPlatformTransactionManager(tm);\n\t\tfinal String joinpointIdentification = methodIdentification(method, targetClass, txAttr);\n\n\t\tif (txAttr == null || !(ptm instanceof CallbackPreferringPlatformTransactionManager cpptm)) {\n\t\t\t// Standard transaction demarcation with getTransaction and commit/rollback calls.\n\t\t\tTransactionInfo txInfo = createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);\n\n\t\t\tObject retVal;\n\t\t\ttry {\n\t\t\t\t// This is an around advice: Invoke the next interceptor in the chain.\n\t\t\t\t// This will normally result in a target object being invoked.\n\t\t\t\tretVal = invocation.proceedWithInvocation();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// target invocation exception\n\t\t\t\tcompleteTransactionAfterThrowing(txInfo, ex);\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tcleanupTransactionInfo(txInfo);\n\t\t\t}\n\n\t\t\tif (retVal != null && vavrPresent && VavrDelegate.isVavrTry(retVal)) {\n\t\t\t\t// Set rollback-only in case of Vavr failure matching our rollback rules...\n\t\t\t\tTransactionStatus status = txInfo.getTransactionStatus();\n\t\t\t\tif (status != null && txAttr != null) {\n\t\t\t\t\tretVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcommitTransactionAfterReturning(txInfo);\n\t\t\treturn retVal;\n\t\t}\n\n\t\telse {\n\t\t\tObject result;\n\t\t\tfinal ThrowableHolder throwableHolder = new ThrowableHolder();\n\n\t\t\t// It's a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.\n\t\t\ttry {\n\t\t\t\tresult = cpptm.execute(txAttr, status -> {\n\t\t\t\t\tTransactionInfo txInfo = prepareTransactionInfo(ptm, txAttr, joinpointIdentification, status);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tObject retVal = invocation.proceedWithInvocation();\n\t\t\t\t\t\tif (retVal != null && vavrPresent && VavrDelegate.isVavrTry(retVal)) {\n\t\t\t\t\t\t\t// Set rollback-only in case of Vavr failure matching our rollback rules...\n\t\t\t\t\t\t\tretVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn retVal;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tif (txAttr.rollbackOn(ex)) {\n\t\t\t\t\t\t\t// A RuntimeException: will lead to a rollback.\n\t\t\t\t\t\t\tif (ex instanceof RuntimeException runtimeException) {\n\t\t\t\t\t\t\t\tthrow runtimeException;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tthrow new ThrowableHolderException(ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// A normal return value: will lead to a commit.\n\t\t\t\t\t\t\tthrowableHolder.throwable = ex;\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tcleanupTransactionInfo(txInfo);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tcatch (ThrowableHolderException ex) {\n\t\t\t\tthrow ex.getCause();\n\t\t\t}\n\t\t\tcatch (TransactionSystemException ex2) {\n\t\t\t\tif (throwableHolder.throwable != null) {\n\t\t\t\t\tlogger.error(\"Application exception overridden by commit exception\", throwableHolder.throwable);\n\t\t\t\t\tex2.initApplicationException(throwableHolder.throwable);\n\t\t\t\t}\n\t\t\t\tthrow ex2;\n\t\t\t}\n\t\t\tcatch (Throwable ex2) {\n\t\t\t\tif (throwableHolder.throwable != null) {\n\t\t\t\t\tlogger.error(\"Application exception overridden by commit exception\", throwableHolder.throwable);\n\t\t\t\t}\n\t\t\t\tthrow ex2;\n\t\t\t}\n\n\t\t\t// Check result state: It might indicate a Throwable to rethrow.\n\t\t\tif (throwableHolder.throwable != null) {\n\t\t\t\tthrow throwableHolder.throwable;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/**\n\t * Clear the transaction manager cache.\n\t */\n\tprotected void clearTransactionManagerCache() {\n\t\tthis.transactionManagerCache.clear();\n\t\tthis.beanFactory = null;\n\t}\n\n\t/**\n\t * Determine the specific transaction manager to use for the given transaction.\n\t */\n\t@Nullable\n\tprotected TransactionManager determineTransactionManager(@Nullable TransactionAttribute txAttr) {\n\t\t// Do not attempt to lookup tx manager if no tx attributes are set\n\t\tif (txAttr == null || this.beanFactory == null) {\n\t\t\treturn getTransactionManager();\n\t\t}\n\n\t\tString qualifier = txAttr.getQualifier();\n\t\tif (StringUtils.hasText(qualifier)) {\n\t\t\treturn determineQualifiedTransactionManager(this.beanFactory, qualifier);\n\t\t}\n\t\telse if (StringUtils.hasText(this.transactionManagerBeanName)) {\n\t\t\treturn determineQualifiedTransactionManager(this.beanFactory, this.transactionManagerBeanName);\n\t\t}\n\t\telse {\n\t\t\tTransactionManager defaultTransactionManager = getTransactionManager();\n\t\t\tif (defaultTransactionManager == null) {\n\t\t\t\tdefaultTransactionManager = this.transactionManagerCache.get(DEFAULT_TRANSACTION_MANAGER_KEY);\n\t\t\t\tif (defaultTransactionManager == null) {\n\t\t\t\t\tdefaultTransactionManager = this.beanFactory.getBean(TransactionManager.class);\n\t\t\t\t\tthis.transactionManagerCache.putIfAbsent(\n\t\t\t\t\t\t\tDEFAULT_TRANSACTION_MANAGER_KEY, defaultTransactionManager);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn defaultTransactionManager;\n\t\t}\n\t}\n\n\tprivate TransactionManager determineQualifiedTransactionManager(BeanFactory beanFactory, String qualifier) {\n\t\tTransactionManager txManager = this.transactionManagerCache.get(qualifier);\n\t\tif (txManager == null) {\n\t\t\ttxManager = BeanFactoryAnnotationUtils.qualifiedBeanOfType(\n\t\t\t\t\tbeanFactory, TransactionManager.class, qualifier);\n\t\t\tthis.transactionManagerCache.putIfAbsent(qualifier, txManager);\n\t\t}\n\t\treturn txManager;\n\t}\n\n\n\t@Nullable\n\tprivate PlatformTransactionManager asPlatformTransactionManager(@Nullable Object transactionManager) {\n\t\tif (transactionManager == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (transactionManager instanceof PlatformTransactionManager ptm) {\n\t\t\treturn ptm;\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Specified transaction manager is not a PlatformTransactionManager: \" + transactionManager);\n\t\t}\n\t}\n\n\tprivate String methodIdentification(Method method, @Nullable Class<?> targetClass,\n\t\t\t@Nullable TransactionAttribute txAttr) {\n\n\t\tString methodIdentification = methodIdentification(method, targetClass);\n\t\tif (methodIdentification == null) {\n\t\t\tif (txAttr instanceof DefaultTransactionAttribute dta) {\n\t\t\t\tmethodIdentification = dta.getDescriptor();\n\t\t\t}\n\t\t\tif (methodIdentification == null) {\n\t\t\t\tmethodIdentification = ClassUtils.getQualifiedMethodName(method, targetClass);\n\t\t\t}\n\t\t}\n\t\treturn methodIdentification;\n\t}\n\n\t/**\n\t * Convenience method to return a String representation of this Method\n\t * for use in logging. Can be overridden in subclasses to provide a\n\t * different identifier for the given method.\n\t * <p>The default implementation returns {@code null}, indicating the\n\t * use of {@link DefaultTransactionAttribute#getDescriptor()} instead,\n\t * ending up as {@link ClassUtils#getQualifiedMethodName(Method, Class)}.\n\t * @param method the method we're interested in\n\t * @param targetClass the class that the method is being invoked on\n\t * @return a String representation identifying this method\n\t * @see org.springframework.util.ClassUtils#getQualifiedMethodName\n\t */\n\t@Nullable\n\tprotected String methodIdentification(Method method, @Nullable Class<?> targetClass) {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Create a transaction if necessary based on the given TransactionAttribute.\n\t * <p>Allows callers to perform custom TransactionAttribute lookups through\n\t * the TransactionAttributeSource.\n\t * @param txAttr the TransactionAttribute (may be {@code null})\n\t * @param joinpointIdentification the fully qualified method name\n\t * (used for monitoring and logging purposes)\n\t * @return a TransactionInfo object, whether a transaction was created.\n\t * The {@code hasTransaction()} method on TransactionInfo can be used to\n\t * tell if there was a transaction created.\n\t * @see #getTransactionAttributeSource()\n\t */\n\t@SuppressWarnings(\"serial\")\n\tprotected TransactionInfo createTransactionIfNecessary(@Nullable PlatformTransactionManager tm,\n\t\t\t@Nullable TransactionAttribute txAttr, final String joinpointIdentification) {\n\n\t\t// If no name specified, apply method identification as transaction name.\n\t\tif (txAttr != null && txAttr.getName() == null) {\n\t\t\ttxAttr = new DelegatingTransactionAttribute(txAttr) {\n\t\t\t\t@Override\n\t\t\t\tpublic String getName() {\n\t\t\t\t\treturn joinpointIdentification;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tTransactionStatus status = null;\n\t\tif (txAttr != null) {\n\t\t\tif (tm != null) {\n\t\t\t\tstatus = tm.getTransaction(txAttr);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Skipping transactional joinpoint [\" + joinpointIdentification +\n\t\t\t\t\t\t\t\"] because no transaction manager has been configured\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);\n\t}\n\n\t/**\n\t * Prepare a TransactionInfo for the given attribute and status object.\n\t * @param txAttr the TransactionAttribute (may be {@code null})\n\t * @param joinpointIdentification the fully qualified method name\n\t * (used for monitoring and logging purposes)\n\t * @param status the TransactionStatus for the current transaction\n\t * @return the prepared TransactionInfo object\n\t */\n\tprotected TransactionInfo prepareTransactionInfo(@Nullable PlatformTransactionManager tm,\n\t\t\t@Nullable TransactionAttribute txAttr, String joinpointIdentification,\n\t\t\t@Nullable TransactionStatus status) {\n\n\t\tTransactionInfo txInfo = new TransactionInfo(tm, txAttr, joinpointIdentification);\n\t\tif (txAttr != null) {\n\t\t\t// We need a transaction for this method...\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Getting transaction for [\" + txInfo.getJoinpointIdentification() + \"]\");\n\t\t\t}\n\t\t\t// The transaction manager will flag an error if an incompatible tx already exists.\n\t\t\ttxInfo.newTransactionStatus(status);\n\t\t}\n\t\telse {\n\t\t\t// The TransactionInfo.hasTransaction() method will return false. We created it only\n\t\t\t// to preserve the integrity of the ThreadLocal stack maintained in this class.\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"No need to create transaction for [\" + joinpointIdentification +\n\t\t\t\t\t\t\"]: This method is not transactional.\");\n\t\t\t}\n\t\t}\n\n\t\t// We always bind the TransactionInfo to the thread, even if we didn't create\n\t\t// a new transaction here. This guarantees that the TransactionInfo stack\n\t\t// will be managed correctly even if no transaction was created by this aspect.\n\t\ttxInfo.bindToThread();\n\t\treturn txInfo;\n\t}\n\n\t/**\n\t * Execute after successful completion of call, but not after an exception was handled.\n\t * Do nothing if we didn't create a transaction.\n\t * @param txInfo information about the current transaction\n\t */\n\tprotected void commitTransactionAfterReturning(@Nullable TransactionInfo txInfo) {\n\t\tif (txInfo != null && txInfo.getTransactionStatus() != null) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Completing transaction for [\" + txInfo.getJoinpointIdentification() + \"]\");\n\t\t\t}\n\t\t\ttxInfo.getTransactionManager().commit(txInfo.getTransactionStatus());\n\t\t}\n\t}\n\n\t/**\n\t * Handle a throwable, completing the transaction.\n\t * We may commit or roll back, depending on the configuration.\n\t * @param txInfo information about the current transaction\n\t * @param ex throwable encountered\n\t */\n\tprotected void completeTransactionAfterThrowing(@Nullable TransactionInfo txInfo, Throwable ex) {\n\t\tif (txInfo != null && txInfo.getTransactionStatus() != null) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Completing transaction for [\" + txInfo.getJoinpointIdentification() +\n\t\t\t\t\t\t\"] after exception: \" + ex);\n\t\t\t}\n\t\t\tif (txInfo.transactionAttribute != null && txInfo.transactionAttribute.rollbackOn(ex)) {\n\t\t\t\ttry {\n\t\t\t\t\ttxInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());\n\t\t\t\t}\n\t\t\t\tcatch (TransactionSystemException ex2) {\n\t\t\t\t\tlogger.error(\"Application exception overridden by rollback exception\", ex);\n\t\t\t\t\tex2.initApplicationException(ex);\n\t\t\t\t\tthrow ex2;\n\t\t\t\t}\n\t\t\t\tcatch (RuntimeException | Error ex2) {\n\t\t\t\t\tlogger.error(\"Application exception overridden by rollback exception\", ex);\n\t\t\t\t\tthrow ex2;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don't roll back on this exception.\n\t\t\t\t// Will still roll back if TransactionStatus.isRollbackOnly() is true.\n\t\t\t\ttry {\n\t\t\t\t\ttxInfo.getTransactionManager().commit(txInfo.getTransactionStatus());\n\t\t\t\t}\n\t\t\t\tcatch (TransactionSystemException ex2) {\n\t\t\t\t\tlogger.error(\"Application exception overridden by commit exception\", ex);\n\t\t\t\t\tex2.initApplicationException(ex);\n\t\t\t\t\tthrow ex2;\n\t\t\t\t}\n\t\t\t\tcatch (RuntimeException | Error ex2) {\n\t\t\t\t\tlogger.error(\"Application exception overridden by commit exception\", ex);\n\t\t\t\t\tthrow ex2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Reset the TransactionInfo ThreadLocal.\n\t * <p>Call this in all cases: exception or normal return!\n\t * @param txInfo information about the current transaction (may be {@code null})\n\t */\n\tprotected void cleanupTransactionInfo(@Nullable TransactionInfo txInfo) {\n\t\tif (txInfo != null) {\n\t\t\ttxInfo.restoreThreadLocalStatus();\n\t\t}\n\t}\n\n\n\t/**\n\t * Opaque object used to hold transaction information. Subclasses\n\t * must pass it back to methods on this class, but not see its internals.\n\t */\n\tprotected static final class TransactionInfo {\n\n\t\t@Nullable\n\t\tprivate final PlatformTransactionManager transactionManager;\n\n\t\t@Nullable\n\t\tprivate final TransactionAttribute transactionAttribute;\n\n\t\tprivate final String joinpointIdentification;\n\n\t\t@Nullable\n\t\tprivate TransactionStatus transactionStatus;\n\n\t\t@Nullable\n\t\tprivate TransactionInfo oldTransactionInfo;\n\n\t\tpublic TransactionInfo(@Nullable PlatformTransactionManager transactionManager,\n\t\t\t\t@Nullable TransactionAttribute transactionAttribute, String joinpointIdentification) {\n\n\t\t\tthis.transactionManager = transactionManager;\n\t\t\tthis.transactionAttribute = transactionAttribute;\n\t\t\tthis.joinpointIdentification = joinpointIdentification;\n\t\t}\n\n\t\tpublic PlatformTransactionManager getTransactionManager() {\n\t\t\tAssert.state(this.transactionManager != null, \"No PlatformTransactionManager set\");\n\t\t\treturn this.transactionManager;\n\t\t}\n\n\t\t@Nullable\n\t\tpublic TransactionAttribute getTransactionAttribute() {\n\t\t\treturn this.transactionAttribute;\n\t\t}\n\n\t\t/**\n\t\t * Return a String representation of this joinpoint (usually a Method call)\n\t\t * for use in logging.\n\t\t */\n\t\tpublic String getJoinpointIdentification() {\n\t\t\treturn this.joinpointIdentification;\n\t\t}\n\n\t\tpublic void newTransactionStatus(@Nullable TransactionStatus status) {\n\t\t\tthis.transactionStatus = status;\n\t\t}\n\n\t\t@Nullable\n\t\tpublic TransactionStatus getTransactionStatus() {\n\t\t\treturn this.transactionStatus;\n\t\t}\n\n\t\t/**\n\t\t * Return whether a transaction was created by this aspect,\n\t\t * or whether we just have a placeholder to keep ThreadLocal stack integrity.\n\t\t */\n\t\tpublic boolean hasTransaction() {\n\t\t\treturn (this.transactionStatus != null);\n\t\t}\n\n\t\tprivate void bindToThread() {\n\t\t\t// Expose current TransactionStatus, preserving any existing TransactionStatus\n\t\t\t// for restoration after this transaction is complete.\n\t\t\tthis.oldTransactionInfo = transactionInfoHolder.get();\n\t\t\ttransactionInfoHolder.set(this);\n\t\t}\n\n\t\tprivate void restoreThreadLocalStatus() {\n\t\t\t// Use stack to restore old transaction TransactionInfo.\n\t\t\t// Will be null if none was set.\n\t\t\ttransactionInfoHolder.set(this.oldTransactionInfo);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn (this.transactionAttribute != null ? this.transactionAttribute.toString() : \"No transaction\");\n\t\t}\n\t}\n\n\n\t/**\n\t * Simple callback interface for proceeding with the target invocation.\n\t * Concrete interceptors/aspects adapt this to their invocation mechanism.\n\t */\n\t@FunctionalInterface\n\tprotected interface InvocationCallback {\n\n\t\t@Nullable\n\t\tObject proceedWithInvocation() throws Throwable;\n\t}\n\n\n\t/**\n\t * Coroutines-supporting extension of the callback interface.\n\t */\n\tprotected interface CoroutinesInvocationCallback extends InvocationCallback {\n\n\t\tObject getTarget();\n\n\t\tObject[] getArguments();\n\n\t\tdefault Object getContinuation() {\n\t\t\tObject[] args = getArguments();\n\t\t\treturn args[args.length - 1];\n\t\t}\n\t}\n\n\n\t/**\n\t * Internal holder class for a Throwable in a callback transaction model.\n\t */\n\tprivate static class ThrowableHolder {\n\n\t\t@Nullable\n\t\tpublic Throwable throwable;\n\t}\n\n\n\t/**\n\t * Internal holder class for a Throwable, used as a RuntimeException to be\n\t * thrown from a TransactionCallback (and subsequently unwrapped again).\n\t */\n\t@SuppressWarnings(\"serial\")\n\tprivate static class ThrowableHolderException extends RuntimeException {\n\n\t\tpublic ThrowableHolderException(Throwable throwable) {\n\t\t\tsuper(throwable);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn getCause().toString();\n\t\t}\n\t}\n\n\n\t/**\n\t * Inner class to avoid a hard dependency on the Vavr library at runtime.\n\t */\n\tprivate static class VavrDelegate {\n\n\t\tpublic static boolean isVavrTry(Object retVal) {\n\t\t\treturn (retVal instanceof Try);\n\t\t}\n\n\t\tpublic static Object evaluateTryFailure(Object retVal, TransactionAttribute txAttr, TransactionStatus status) {\n\t\t\treturn ((Try<?>) retVal).onFailure(ex -> {\n\t\t\t\tif (txAttr.rollbackOn(ex)) {\n\t\t\t\t\tstatus.setRollbackOnly();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Inner class to avoid a hard dependency on Kotlin at runtime.\n\t */\n\tprivate static class KotlinDelegate {\n\n\t\tprivate static Object asFlow(Publisher<?> publisher) {\n\t\t\treturn ReactiveFlowKt.asFlow(publisher);\n\t\t}\n\n\t\t@SuppressWarnings({\"unchecked\", \"deprecation\"})\n\t\t@Nullable\n\t\tprivate static Object awaitSingleOrNull(Publisher<?> publisher, Object continuation) {\n\t\t\treturn AwaitKt.awaitSingleOrNull(publisher, (Continuation<Object>) continuation);\n\t\t}\n\n\t\tpublic static Publisher<?> invokeSuspendingFunction(Method method, CoroutinesInvocationCallback callback) {\n\t\t\tCoroutineContext coroutineContext = ((Continuation<?>) callback.getContinuation()).getContext().minusKey(Job.Key);\n\t\t\treturn CoroutinesUtils.invokeSuspendingFunction(coroutineContext, method, callback.getTarget(), callback.getArguments());\n\t\t}\n\n\t}\n\n\n\t/**\n\t * Delegate for Reactor-based management of transactional methods with a\n\t * reactive return type.\n\t */\n\tprivate class ReactiveTransactionSupport {\n\n\t\tprivate final ReactiveAdapter adapter;\n\n\t\tpublic ReactiveTransactionSupport(ReactiveAdapter adapter) {\n\t\t\tthis.adapter = adapter;\n\t\t}\n\n\t\tpublic Object invokeWithinTransaction(Method method, @Nullable Class<?> targetClass,\n\t\t\t\tInvocationCallback invocation, @Nullable TransactionAttribute txAttr, ReactiveTransactionManager rtm) {\n\n\t\t\tString joinpointIdentification = methodIdentification(method, targetClass, txAttr);\n\n\t\t\t// For Mono and suspending functions not returning kotlinx.coroutines.flow.Flow\n\t\t\tif (Mono.class.isAssignableFrom(method.getReturnType()) || (KotlinDetector.isSuspendingFunction(method) &&\n\t\t\t\t\t!COROUTINES_FLOW_CLASS_NAME.equals(new MethodParameter(method, -1).getParameterType().getName()))) {\n\n\t\t\t\treturn TransactionContextManager.currentContext().flatMap(context ->\n\t\t\t\t\t\tcreateTransactionIfNecessary(rtm, txAttr, joinpointIdentification).flatMap(it -> {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t// Need re-wrapping until we get hold of the exception through usingWhen.\n\t\t\t\t\t\t\t\treturn Mono.<Object, ReactiveTransactionInfo>usingWhen(\n\t\t\t\t\t\t\t\t\t\tMono.just(it),\n\t\t\t\t\t\t\t\t\t\ttxInfo -> {\n\t\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\t\treturn (Mono<?>) invocation.proceedWithInvocation();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn Mono.error(ex);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tthis::commitTransactionAfterReturning,\n\t\t\t\t\t\t\t\t\t\t(txInfo, err) -> Mono.empty(),\n\t\t\t\t\t\t\t\t\t\tthis::rollbackTransactionOnCancel)\n\t\t\t\t\t\t\t\t\t\t.onErrorResume(ex ->\n\t\t\t\t\t\t\t\t\t\t\t\tcompleteTransactionAfterThrowing(it, ex).then(Mono.error(ex)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\t\t\t// target invocation exception\n\t\t\t\t\t\t\t\treturn completeTransactionAfterThrowing(it, ex).then(Mono.error(ex));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})).contextWrite(TransactionContextManager.getOrCreateContext())\n\t\t\t\t\t\t.contextWrite(TransactionContextManager.getOrCreateContextHolder());\n\t\t\t}\n\n\t\t\t// Any other reactive type, typically a Flux\n\t\t\treturn this.adapter.fromPublisher(TransactionContextManager.currentContext().flatMapMany(context ->\n\t\t\t\t\tcreateTransactionIfNecessary(rtm, txAttr, joinpointIdentification).flatMapMany(it -> {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// Need re-wrapping until we get hold of the exception through usingWhen.\n\t\t\t\t\t\t\treturn Flux\n\t\t\t\t\t\t\t\t\t.usingWhen(\n\t\t\t\t\t\t\t\t\t\t\tMono.just(it),\n\t\t\t\t\t\t\t\t\t\t\ttxInfo -> {\n\t\t\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.adapter.toPublisher(invocation.proceedWithInvocation());\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn Mono.error(ex);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tthis::commitTransactionAfterReturning,\n\t\t\t\t\t\t\t\t\t\t\t(txInfo, ex) -> Mono.empty(),\n\t\t\t\t\t\t\t\t\t\t\tthis::rollbackTransactionOnCancel)\n\t\t\t\t\t\t\t\t\t.onErrorResume(ex ->\n\t\t\t\t\t\t\t\t\t\t\tcompleteTransactionAfterThrowing(it, ex).then(Mono.error(ex)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\t\t// target invocation exception\n\t\t\t\t\t\t\treturn completeTransactionAfterThrowing(it, ex).then(Mono.error(ex));\n\t\t\t\t\t\t}\n\t\t\t\t\t})).contextWrite(TransactionContextManager.getOrCreateContext())\n\t\t\t\t\t.contextWrite(TransactionContextManager.getOrCreateContextHolder()));\n\t\t}\n\n\t\t@SuppressWarnings(\"serial\")\n\t\tprivate Mono<ReactiveTransactionInfo> createTransactionIfNecessary(ReactiveTransactionManager tm,\n\t\t\t\t@Nullable TransactionAttribute txAttr, final String joinpointIdentification) {\n\n\t\t\t// If no name specified, apply method identification as transaction name.\n\t\t\tif (txAttr != null && txAttr.getName() == null) {\n\t\t\t\ttxAttr = new DelegatingTransactionAttribute(txAttr) {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String getName() {\n\t\t\t\t\t\treturn joinpointIdentification;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tfinal TransactionAttribute attrToUse = txAttr;\n\t\t\tMono<ReactiveTransaction> tx = (attrToUse != null ? tm.getReactiveTransaction(attrToUse) : Mono.empty());\n\t\t\treturn tx.map(it -> prepareTransactionInfo(tm, attrToUse, joinpointIdentification, it)).switchIfEmpty(\n\t\t\t\t\tMono.defer(() -> Mono.just(prepareTransactionInfo(tm, attrToUse, joinpointIdentification, null))));\n\t\t}\n\n\t\tprivate ReactiveTransactionInfo prepareTransactionInfo(@Nullable ReactiveTransactionManager tm,\n\t\t\t\t@Nullable TransactionAttribute txAttr, String joinpointIdentification,\n\t\t\t\t@Nullable ReactiveTransaction transaction) {\n\n\t\t\tReactiveTransactionInfo txInfo = new ReactiveTransactionInfo(tm, txAttr, joinpointIdentification);\n\t\t\tif (txAttr != null) {\n\t\t\t\t// We need a transaction for this method...\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Getting transaction for [\" + txInfo.getJoinpointIdentification() + \"]\");\n\t\t\t\t}\n\t\t\t\t// The transaction manager will flag an error if an incompatible tx already exists.\n\t\t\t\ttxInfo.newReactiveTransaction(transaction);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// The TransactionInfo.hasTransaction() method will return false. We created it only\n\t\t\t\t// to preserve the integrity of the ThreadLocal stack maintained in this class.\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Don't need to create transaction for [\" + joinpointIdentification +\n\t\t\t\t\t\t\t\"]: This method isn't transactional.\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn txInfo;\n\t\t}\n\n\t\tprivate Mono<Void> commitTransactionAfterReturning(@Nullable ReactiveTransactionInfo txInfo) {\n\t\t\tif (txInfo != null && txInfo.getReactiveTransaction() != null) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Completing transaction for [\" + txInfo.getJoinpointIdentification() + \"]\");\n\t\t\t\t}\n\t\t\t\treturn txInfo.getTransactionManager().commit(txInfo.getReactiveTransaction());\n\t\t\t}\n\t\t\treturn Mono.empty();\n\t\t}\n\n\t\tprivate Mono<Void> rollbackTransactionOnCancel(@Nullable ReactiveTransactionInfo txInfo) {\n\t\t\tif (txInfo != null && txInfo.getReactiveTransaction() != null) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Rolling back transaction for [\" + txInfo.getJoinpointIdentification() + \"] after cancellation\");\n\t\t\t\t}\n\t\t\t\treturn txInfo.getTransactionManager().rollback(txInfo.getReactiveTransaction());\n\t\t\t}\n\t\t\treturn Mono.empty();\n\t\t}\n\n\t\tprivate Mono<Void> completeTransactionAfterThrowing(@Nullable ReactiveTransactionInfo txInfo, Throwable ex) {\n\t\t\tif (txInfo != null && txInfo.getReactiveTransaction() != null) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Completing transaction for [\" + txInfo.getJoinpointIdentification() +\n\t\t\t\t\t\t\t\"] after exception: \" + ex);\n\t\t\t\t}\n\t\t\t\tif (txInfo.transactionAttribute != null && txInfo.transactionAttribute.rollbackOn(ex)) {\n\t\t\t\t\treturn txInfo.getTransactionManager().rollback(txInfo.getReactiveTransaction()).onErrorMap(ex2 -> {\n\t\t\t\t\t\t\t\tlogger.error(\"Application exception overridden by rollback exception\", ex);\n\t\t\t\t\t\t\t\tif (ex2 instanceof TransactionSystemException systemException) {\n\t\t\t\t\t\t\t\t\tsystemException.initApplicationException(ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn ex2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// We don't roll back on this exception.\n\t\t\t\t\t// Will still roll back if TransactionStatus.isRollbackOnly() is true.\n\t\t\t\t\treturn txInfo.getTransactionManager().commit(txInfo.getReactiveTransaction()).onErrorMap(ex2 -> {\n\t\t\t\t\t\t\t\tlogger.error(\"Application exception overridden by commit exception\", ex);\n\t\t\t\t\t\t\t\tif (ex2 instanceof TransactionSystemException systemException) {\n\t\t\t\t\t\t\t\t\tsystemException.initApplicationException(ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn ex2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Mono.empty();\n\t\t}\n\t}\n\n\n\t/**\n\t * Opaque object used to hold transaction information for reactive methods.\n\t */\n\tprivate static final class ReactiveTransactionInfo {\n\n\t\t@Nullable\n\t\tprivate final ReactiveTransactionManager transactionManager;\n\n\t\t@Nullable\n\t\tprivate final TransactionAttribute transactionAttribute;\n\n\t\tprivate final String joinpointIdentification;\n\n\t\t@Nullable\n\t\tprivate ReactiveTransaction reactiveTransaction;\n\n\t\tpublic ReactiveTransactionInfo(@Nullable ReactiveTransactionManager transactionManager,\n\t\t\t\t@Nullable TransactionAttribute transactionAttribute, String joinpointIdentification) {\n\n\t\t\tthis.transactionManager = transactionManager;\n\t\t\tthis.transactionAttribute = transactionAttribute;\n\t\t\tthis.joinpointIdentification = joinpointIdentification;\n\t\t}\n\n\t\tpublic ReactiveTransactionManager getTransactionManager() {\n\t\t\tAssert.state(this.transactionManager != null, \"No ReactiveTransactionManager set\");\n\t\t\treturn this.transactionManager;\n\t\t}\n\n\t\t@Nullable\n\t\tpublic TransactionAttribute getTransactionAttribute() {\n\t\t\treturn this.transactionAttribute;\n\t\t}\n\n\t\t/**\n\t\t * Return a String representation of this joinpoint (usually a Method call)\n\t\t * for use in logging.\n\t\t */\n\t\tpublic String getJoinpointIdentification() {\n\t\t\treturn this.joinpointIdentification;\n\t\t}\n\n\t\tpublic void newReactiveTransaction(@Nullable ReactiveTransaction transaction) {\n\t\t\tthis.reactiveTransaction = transaction;\n\t\t}\n\n\t\t@Nullable\n\t\tpublic ReactiveTransaction getReactiveTransaction() {\n\t\t\treturn this.reactiveTransaction;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn (this.transactionAttribute != null ? this.transactionAttribute.toString() : \"No transaction\");\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check that required properties were set.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 312
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tif (getTransactionManager() == null && this.beanFactory == null) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Set the 'transactionManager' property or make sure to run within a BeanFactory \" +\n\t\t\t\t\t\"containing a TransactionManager bean!\");\n\t\t}\n\t\tif (getTransactionAttributeSource() == null) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Either 'transactionAttributeSource' or 'transactionAttributes' is required: \" +\n\t\t\t\t\t\"If there are no transactional methods, then don't use a transaction aspect.\");\n\t\t}\n\t}"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#cleanupTransactionInfo(txInfo)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Reset the TransactionInfo ThreadLocal.\n\t * <p>Call this in all cases: exception or normal return!\n\t * @param txInfo information about the current transaction (may be {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "txInfo"
    ],
    "position": {
      "column": 1,
      "line": 713
    },
    "return": "void",
    "signature": "protected void cleanupTransactionInfo(@Nullable TransactionInfo txInfo)",
    "source_code": "\tprotected void cleanupTransactionInfo(@Nullable TransactionInfo txInfo) {\n\t\tif (txInfo != null) {\n\t\t\ttxInfo.restoreThreadLocalStatus();\n\t\t}\n\t}"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#clearTransactionManagerCache()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Clear the transaction manager cache.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 478
    },
    "return": "void",
    "signature": "protected void clearTransactionManagerCache()",
    "source_code": "\tprotected void clearTransactionManagerCache() {\n\t\tthis.transactionManagerCache.clear();\n\t\tthis.beanFactory = null;\n\t}"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#commitTransactionAfterReturning(txInfo)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute after successful completion of call, but not after an exception was handled.\n\t * Do nothing if we didn't create a transaction.\n\t * @param txInfo information about the current transaction\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "txInfo"
    ],
    "position": {
      "column": 1,
      "line": 654
    },
    "return": "void",
    "signature": "protected void commitTransactionAfterReturning(@Nullable TransactionInfo txInfo)",
    "source_code": "\tprotected void commitTransactionAfterReturning(@Nullable TransactionInfo txInfo) {\n\t\tif (txInfo != null && txInfo.getTransactionStatus() != null) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Completing transaction for [\" + txInfo.getJoinpointIdentification() + \"]\");\n\t\t\t}\n\t\t\ttxInfo.getTransactionManager().commit(txInfo.getTransactionStatus());\n\t\t}\n\t}"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#completeTransactionAfterThrowing(txInfo,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle a throwable, completing the transaction.\n\t * We may commit or roll back, depending on the configuration.\n\t * @param txInfo information about the current transaction\n\t * @param ex throwable encountered\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "txInfo",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 669
    },
    "return": "void",
    "signature": "protected void completeTransactionAfterThrowing(@Nullable TransactionInfo txInfo, Throwable ex)",
    "source_code": "\tprotected void completeTransactionAfterThrowing(@Nullable TransactionInfo txInfo, Throwable ex) {\n\t\tif (txInfo != null && txInfo.getTransactionStatus() != null) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Completing transaction for [\" + txInfo.getJoinpointIdentification() +\n\t\t\t\t\t\t\"] after exception: \" + ex);\n\t\t\t}\n\t\t\tif (txInfo.transactionAttribute != null && txInfo.transactionAttribute.rollbackOn(ex)) {\n\t\t\t\ttry {\n\t\t\t\t\ttxInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());\n\t\t\t\t}\n\t\t\t\tcatch (TransactionSystemException ex2) {\n\t\t\t\t\tlogger.error(\"Application exception overridden by rollback exception\", ex);\n\t\t\t\t\tex2.initApplicationException(ex);\n\t\t\t\t\tthrow ex2;\n\t\t\t\t}\n\t\t\t\tcatch (RuntimeException | Error ex2) {\n\t\t\t\t\tlogger.error(\"Application exception overridden by rollback exception\", ex);\n\t\t\t\t\tthrow ex2;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don't roll back on this exception.\n\t\t\t\t// Will still roll back if TransactionStatus.isRollbackOnly() is true.\n\t\t\t\ttry {\n\t\t\t\t\ttxInfo.getTransactionManager().commit(txInfo.getTransactionStatus());\n\t\t\t\t}\n\t\t\t\tcatch (TransactionSystemException ex2) {\n\t\t\t\t\tlogger.error(\"Application exception overridden by commit exception\", ex);\n\t\t\t\t\tex2.initApplicationException(ex);\n\t\t\t\t\tthrow ex2;\n\t\t\t\t}\n\t\t\t\tcatch (RuntimeException | Error ex2) {\n\t\t\t\t\tlogger.error(\"Application exception overridden by commit exception\", ex);\n\t\t\t\t\tthrow ex2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#createTransactionIfNecessary(tm,txAttr,joinpointIdentification)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a transaction if necessary based on the given TransactionAttribute.\n\t * <p>Allows callers to perform custom TransactionAttribute lookups through\n\t * the TransactionAttributeSource.\n\t * @param txAttr the TransactionAttribute (may be {@code null})\n\t * @param joinpointIdentification the fully qualified method name\n\t * (used for monitoring and logging purposes)\n\t * @return a TransactionInfo object, whether a transaction was created.\n\t * The {@code hasTransaction()} method on TransactionInfo can be used to\n\t * tell if there was a transaction created.\n\t * @see #getTransactionAttributeSource()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "tm",
      "txAttr",
      "joinpointIdentification"
    ],
    "position": {
      "column": 1,
      "line": 584
    },
    "return": "TransactionInfo",
    "signature": "protected TransactionInfo createTransactionIfNecessary(@Nullable PlatformTransactionManager tm,\n\t\t\t@Nullable TransactionAttribute txAttr, final String joinpointIdentification)",
    "source_code": "\tprotected TransactionInfo createTransactionIfNecessary(@Nullable PlatformTransactionManager tm,"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#currentTransactionInfo()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses can use this to return the current TransactionInfo.\n\t * Only subclasses that cannot handle all operations in one method,\n\t * such as an AspectJ aspect involving distinct before and after advice,\n\t * need to use this mechanism to get at the current TransactionInfo.\n\t * An around advice such as an AOP Alliance MethodInterceptor can hold a\n\t * reference to the TransactionInfo throughout the aspect method.\n\t * <p>A TransactionInfo will be returned even if no transaction was created.\n\t * The {@code TransactionInfo.hasTransaction()} method can be used to query this.\n\t * <p>To find out about specific transaction characteristics, consider using\n\t * TransactionSynchronizationManager's {@code isSynchronizationActive()}\n\t * and/or {@code isActualTransactionActive()} methods.\n\t * @return the TransactionInfo bound to this thread, or {@code null} if none\n\t * @see TransactionInfo#hasTransaction()\n\t * @see org.springframework.transaction.support.TransactionSynchronizationManager#isSynchronizationActive()\n\t * @see org.springframework.transaction.support.TransactionSynchronizationManager#isActualTransactionActive()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "TransactionInfo",
    "signature": "protected TransactionInfo currentTransactionInfo()",
    "source_code": "\tprotected static TransactionInfo currentTransactionInfo() throws NoTransactionException {\n\t\treturn transactionInfoHolder.get();\n\t}"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#currentTransactionStatus()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the transaction status of the current method invocation.\n\t * Mainly intended for code that wants to set the current transaction\n\t * rollback-only but not throw an application exception.\n\t * @throws NoTransactionException if the transaction info cannot be found,\n\t * because the method was invoked outside an AOP invocation context\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "TransactionStatus",
    "signature": "public TransactionStatus currentTransactionStatus()",
    "source_code": "\tpublic static TransactionStatus currentTransactionStatus() throws NoTransactionException {\n\t\tTransactionInfo info = currentTransactionInfo();\n\t\tif (info == null || info.transactionStatus == null) {\n\t\t\tthrow new NoTransactionException(\"No transaction aspect-managed TransactionStatus in scope\");\n\t\t}\n\t\treturn info.transactionStatus;\n\t}"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#determineTransactionManager(txAttr)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the specific transaction manager to use for the given transaction.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "txAttr"
    ],
    "position": {
      "column": 1,
      "line": 487
    },
    "return": "TransactionManager",
    "signature": "protected TransactionManager determineTransactionManager(@Nullable TransactionAttribute txAttr)",
    "source_code": "\tprotected TransactionManager determineTransactionManager(@Nullable TransactionAttribute txAttr) {\n\t\t// Do not attempt to lookup tx manager if no tx attributes are set\n\t\tif (txAttr == null || this.beanFactory == null) {\n\t\t\treturn getTransactionManager();\n\t\t}\n\n\t\tString qualifier = txAttr.getQualifier();\n\t\tif (StringUtils.hasText(qualifier)) {\n\t\t\treturn determineQualifiedTransactionManager(this.beanFactory, qualifier);\n\t\t}\n\t\telse if (StringUtils.hasText(this.transactionManagerBeanName)) {\n\t\t\treturn determineQualifiedTransactionManager(this.beanFactory, this.transactionManagerBeanName);\n\t\t}\n\t\telse {\n\t\t\tTransactionManager defaultTransactionManager = getTransactionManager();\n\t\t\tif (defaultTransactionManager == null) {\n\t\t\t\tdefaultTransactionManager = this.transactionManagerCache.get(DEFAULT_TRANSACTION_MANAGER_KEY);\n\t\t\t\tif (defaultTransactionManager == null) {\n\t\t\t\t\tdefaultTransactionManager = this.beanFactory.getBean(TransactionManager.class);\n\t\t\t\t\tthis.transactionManagerCache.putIfAbsent(\n\t\t\t\t\t\t\tDEFAULT_TRANSACTION_MANAGER_KEY, defaultTransactionManager);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn defaultTransactionManager;\n\t\t}\n\t}"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#evaluateTryFailure(retVal,txAttr,status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "retVal",
      "txAttr",
      "status"
    ],
    "position": {
      "column": 1,
      "line": 868
    },
    "return": "Object",
    "signature": "public Object evaluateTryFailure(Object retVal, TransactionAttribute txAttr, TransactionStatus status)",
    "source_code": "\t\tpublic static Object evaluateTryFailure(Object retVal, TransactionAttribute txAttr, TransactionStatus status) {\n\t\t\treturn ((Try<?>) retVal).onFailure(ex -> {\n\t\t\t\tif (txAttr.rollbackOn(ex)) {\n\t\t\t\t\tstatus.setRollbackOnly();\n\t\t\t\t}\n\t\t\t});\n\t\t}"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#getBeanFactory()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the BeanFactory to use for retrieving {@code TransactionManager} beans.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "BeanFactory",
    "signature": "protected BeanFactory getBeanFactory()",
    "source_code": "\tprotected final BeanFactory getBeanFactory() {\n\t\treturn this.beanFactory;\n\t}"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#getJoinpointIdentification()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return a String representation of this joinpoint (usually a Method call)\n\t\t * for use in logging.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1116
    },
    "return": "String",
    "signature": "public String getJoinpointIdentification()",
    "source_code": "\t\tpublic String getJoinpointIdentification() {\n\t\t\treturn this.joinpointIdentification;\n\t\t}"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#getName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 987
    },
    "return": "String",
    "signature": "public String getName()",
    "source_code": "\t\t\t\t\tpublic String getName() {\n\t\t\t\t\t\treturn joinpointIdentification;\n\t\t\t\t\t}"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#getReactiveTransaction()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1125
    },
    "return": "ReactiveTransaction",
    "signature": "public ReactiveTransaction getReactiveTransaction()",
    "source_code": "\t\tpublic ReactiveTransaction getReactiveTransaction() {\n\t\t\treturn this.reactiveTransaction;\n\t\t}"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#getTransactionAttribute()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1108
    },
    "return": "TransactionAttribute",
    "signature": "public TransactionAttribute getTransactionAttribute()",
    "source_code": "\t\tpublic TransactionAttribute getTransactionAttribute() {\n\t\t\treturn this.transactionAttribute;\n\t\t}"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#getTransactionAttributeSource()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the transaction attribute source.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "TransactionAttributeSource",
    "signature": "public TransactionAttributeSource getTransactionAttributeSource()",
    "source_code": "\tpublic TransactionAttributeSource getTransactionAttributeSource() {\n\t\treturn this.transactionAttributeSource;\n\t}"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#getTransactionManager()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1102
    },
    "return": "ReactiveTransactionManager",
    "signature": "public ReactiveTransactionManager getTransactionManager()",
    "source_code": "\t\tpublic ReactiveTransactionManager getTransactionManager() {\n\t\t\tAssert.state(this.transactionManager != null, \"No ReactiveTransactionManager set\");\n\t\t\treturn this.transactionManager;\n\t\t}"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#getTransactionManagerBeanName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the name of the default transaction manager bean.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "String",
    "signature": "protected String getTransactionManagerBeanName()",
    "source_code": "\tprotected final String getTransactionManagerBeanName() {\n\t\treturn this.transactionManagerBeanName;\n\t}"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#getTransactionStatus()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 771
    },
    "return": "TransactionStatus",
    "signature": "public TransactionStatus getTransactionStatus()",
    "source_code": "\t\tpublic TransactionStatus getTransactionStatus() {\n\t\t\treturn this.transactionStatus;\n\t\t}"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#hasTransaction()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return whether a transaction was created by this aspect,\n\t\t * or whether we just have a placeholder to keep ThreadLocal stack integrity.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 779
    },
    "return": "boolean",
    "signature": "public boolean hasTransaction()",
    "source_code": "\t\tpublic boolean hasTransaction() {\n\t\t\treturn (this.transactionStatus != null);\n\t\t}"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#invokeWithinTransaction(method,targetClass,invocation)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * General delegate for around-advice-based subclasses, delegating to several other template\n\t * methods on this class. Able to handle {@link CallbackPreferringPlatformTransactionManager}\n\t * as well as regular {@link PlatformTransactionManager} implementations and\n\t * {@link ReactiveTransactionManager} implementations for reactive return types.\n\t * @param method the Method being invoked\n\t * @param targetClass the target class that we're invoking the method on\n\t * @param invocation the callback to use for proceeding with the target invocation\n\t * @return the return value of the method, if any\n\t * @throws Throwable propagated from the target invocation\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "targetClass",
      "invocation"
    ],
    "position": {
      "column": 1,
      "line": 338
    },
    "return": "Object",
    "signature": "protected Object invokeWithinTransaction(Method method, @Nullable Class<?> targetClass,\n\t\t\tfinal InvocationCallback invocation)",
    "source_code": "\tprotected Object invokeWithinTransaction(Method method, @Nullable Class<?> targetClass,"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#invokeWithinTransaction(method,targetClass,invocation,txAttr,rtm)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass",
      "invocation",
      "txAttr",
      "rtm"
    ],
    "position": {
      "column": 1,
      "line": 912
    },
    "return": "Object",
    "signature": "public Object invokeWithinTransaction(Method method, @Nullable Class<?> targetClass,\n\t\t\t\tInvocationCallback invocation, @Nullable TransactionAttribute txAttr, ReactiveTransactionManager rtm)",
    "source_code": "\t\tpublic Object invokeWithinTransaction(Method method, @Nullable Class<?> targetClass,"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#isVavrTry(retVal)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "retVal"
    ],
    "position": {
      "column": 1,
      "line": 864
    },
    "return": "boolean",
    "signature": "public boolean isVavrTry(Object retVal)",
    "source_code": "\t\tpublic static boolean isVavrTry(Object retVal) {\n\t\t\treturn (retVal instanceof Try);\n\t\t}"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#methodIdentification(method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenience method to return a String representation of this Method\n\t * for use in logging. Can be overridden in subclasses to provide a\n\t * different identifier for the given method.\n\t * <p>The default implementation returns {@code null}, indicating the\n\t * use of {@link DefaultTransactionAttribute#getDescriptor()} instead,\n\t * ending up as {@link ClassUtils#getQualifiedMethodName(Method, Class)}.\n\t * @param method the method we're interested in\n\t * @param targetClass the class that the method is being invoked on\n\t * @return a String representation identifying this method\n\t * @see org.springframework.util.ClassUtils#getQualifiedMethodName\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 567
    },
    "return": "String",
    "signature": "protected String methodIdentification(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tprotected String methodIdentification(Method method, @Nullable Class<?> targetClass) {\n\t\treturn null;\n\t}"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#newReactiveTransaction(transaction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "transaction"
    ],
    "position": {
      "column": 1,
      "line": 1120
    },
    "return": "void",
    "signature": "public void newReactiveTransaction(@Nullable ReactiveTransaction transaction)",
    "source_code": "\t\tpublic void newReactiveTransaction(@Nullable ReactiveTransaction transaction) {\n\t\t\tthis.reactiveTransaction = transaction;\n\t\t}"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#newTransactionStatus(status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 766
    },
    "return": "void",
    "signature": "public void newTransactionStatus(@Nullable TransactionStatus status)",
    "source_code": "\t\tpublic void newTransactionStatus(@Nullable TransactionStatus status) {\n\t\t\tthis.transactionStatus = status;\n\t\t}"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#prepareTransactionInfo(tm,txAttr,joinpointIdentification,status)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare a TransactionInfo for the given attribute and status object.\n\t * @param txAttr the TransactionAttribute (may be {@code null})\n\t * @param joinpointIdentification the fully qualified method name\n\t * (used for monitoring and logging purposes)\n\t * @param status the TransactionStatus for the current transaction\n\t * @return the prepared TransactionInfo object\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "tm",
      "txAttr",
      "joinpointIdentification",
      "status"
    ],
    "position": {
      "column": 1,
      "line": 620
    },
    "return": "TransactionInfo",
    "signature": "protected TransactionInfo prepareTransactionInfo(@Nullable PlatformTransactionManager tm,\n\t\t\t@Nullable TransactionAttribute txAttr, String joinpointIdentification,\n\t\t\t@Nullable TransactionStatus status)",
    "source_code": "\tprotected TransactionInfo prepareTransactionInfo(@Nullable PlatformTransactionManager tm,"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the BeanFactory to use for retrieving {@code TransactionManager} beans.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "void",
    "signature": "public void setBeanFactory(@Nullable BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(@Nullable BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t}"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#setTransactionAttributeSource(transactionAttributeSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the transaction attribute source which is used to find transaction\n\t * attributes. If specifying a String property value, a PropertyEditor\n\t * will create a MethodMapTransactionAttributeSource from the value.\n\t * @see TransactionAttributeSourceEditor\n\t * @see MethodMapTransactionAttributeSource\n\t * @see NameMatchTransactionAttributeSource\n\t * @see org.springframework.transaction.annotation.AnnotationTransactionAttributeSource\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "transactionAttributeSource"
    ],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "void",
    "signature": "public void setTransactionAttributeSource(@Nullable TransactionAttributeSource transactionAttributeSource)",
    "source_code": "\tpublic void setTransactionAttributeSource(@Nullable TransactionAttributeSource transactionAttributeSource) {\n\t\tthis.transactionAttributeSource = transactionAttributeSource;\n\t}"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#setTransactionAttributeSources(transactionAttributeSources)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set multiple transaction attribute sources which are used to find transaction\n\t * attributes. Will build a CompositeTransactionAttributeSource for the given sources.\n\t * @see CompositeTransactionAttributeSource\n\t * @see MethodMapTransactionAttributeSource\n\t * @see NameMatchTransactionAttributeSource\n\t * @see org.springframework.transaction.annotation.AnnotationTransactionAttributeSource\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "transactionAttributeSources"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "void",
    "signature": "public void setTransactionAttributeSources(TransactionAttributeSource... transactionAttributeSources)",
    "source_code": "\tpublic void setTransactionAttributeSources(TransactionAttributeSource... transactionAttributeSources) {\n\t\tthis.transactionAttributeSource = new CompositeTransactionAttributeSource(transactionAttributeSources);\n\t}"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#setTransactionAttributes(transactionAttributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set properties with method names as keys and transaction attribute\n\t * descriptors (parsed via TransactionAttributeEditor) as values:\n\t * e.g. key = \"myMethod\", value = \"PROPAGATION_REQUIRED,readOnly\".\n\t * <p>Note: Method names are always applied to the target class,\n\t * no matter if defined in an interface or the class itself.\n\t * <p>Internally, a NameMatchTransactionAttributeSource will be\n\t * created from the given properties.\n\t * @see #setTransactionAttributeSource\n\t * @see TransactionAttributeEditor\n\t * @see NameMatchTransactionAttributeSource\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "transactionAttributes"
    ],
    "position": {
      "column": 1,
      "line": 253
    },
    "return": "void",
    "signature": "public void setTransactionAttributes(Properties transactionAttributes)",
    "source_code": "\tpublic void setTransactionAttributes(Properties transactionAttributes) {\n\t\tNameMatchTransactionAttributeSource tas = new NameMatchTransactionAttributeSource();\n\t\ttas.setProperties(transactionAttributes);\n\t\tthis.transactionAttributeSource = tas;\n\t}"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#setTransactionManager(transactionManager)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the <em>default</em> transaction manager to use to drive transactions.\n\t * <p>This can either be a traditional {@link PlatformTransactionManager} or a\n\t * {@link ReactiveTransactionManager} for reactive transaction management.\n\t * <p>The default transaction manager will be used if a <em>qualifier</em>\n\t * has not been declared for a given transaction or if an explicit name for the\n\t * default transaction manager bean has not been specified.\n\t * @see #setTransactionManagerBeanName\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "transactionManager"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "void",
    "signature": "public void setTransactionManager(@Nullable TransactionManager transactionManager)",
    "source_code": "\tpublic void setTransactionManager(@Nullable TransactionManager transactionManager) {\n\t\tthis.transactionManager = transactionManager;\n\t}"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#setTransactionManagerBeanName(transactionManagerBeanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the name of the default transaction manager bean.\n\t * <p>This can either point to a traditional {@link PlatformTransactionManager} or a\n\t * {@link ReactiveTransactionManager} for reactive transaction management.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "transactionManagerBeanName"
    ],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "void",
    "signature": "public void setTransactionManagerBeanName(@Nullable String transactionManagerBeanName)",
    "source_code": "\tpublic void setTransactionManagerBeanName(@Nullable String transactionManagerBeanName) {\n\t\tthis.transactionManagerBeanName = transactionManagerBeanName;\n\t}"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1130
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn (this.transactionAttribute != null ? this.transactionAttribute.toString() : \"No transaction\");\n\t\t}"
  },
  "org.springframework.transaction.interceptor.TransactionInfo": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Opaque object used to hold transaction information. Subclasses\n\t * must pass it back to methods on this class, but not see its internals.\n\t */",
    "kind": "class",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 724
    },
    "signature": "protected class TransactionInfo",
    "source_code": "\tprotected static final class TransactionInfo {\n\n\t\t@Nullable\n\t\tprivate final PlatformTransactionManager transactionManager;\n\n\t\t@Nullable\n\t\tprivate final TransactionAttribute transactionAttribute;\n\n\t\tprivate final String joinpointIdentification;\n\n\t\t@Nullable\n\t\tprivate TransactionStatus transactionStatus;\n\n\t\t@Nullable\n\t\tprivate TransactionInfo oldTransactionInfo;\n\n\t\tpublic TransactionInfo(@Nullable PlatformTransactionManager transactionManager,\n\t\t\t\t@Nullable TransactionAttribute transactionAttribute, String joinpointIdentification) {\n\n\t\t\tthis.transactionManager = transactionManager;\n\t\t\tthis.transactionAttribute = transactionAttribute;\n\t\t\tthis.joinpointIdentification = joinpointIdentification;\n\t\t}\n\n\t\tpublic PlatformTransactionManager getTransactionManager() {\n\t\t\tAssert.state(this.transactionManager != null, \"No PlatformTransactionManager set\");\n\t\t\treturn this.transactionManager;\n\t\t}\n\n\t\t@Nullable\n\t\tpublic TransactionAttribute getTransactionAttribute() {\n\t\t\treturn this.transactionAttribute;\n\t\t}\n\n\t\t/**\n\t\t * Return a String representation of this joinpoint (usually a Method call)\n\t\t * for use in logging.\n\t\t */\n\t\tpublic String getJoinpointIdentification() {\n\t\t\treturn this.joinpointIdentification;\n\t\t}\n\n\t\tpublic void newTransactionStatus(@Nullable TransactionStatus status) {\n\t\t\tthis.transactionStatus = status;\n\t\t}\n\n\t\t@Nullable\n\t\tpublic TransactionStatus getTransactionStatus() {\n\t\t\treturn this.transactionStatus;\n\t\t}\n\n\t\t/**\n\t\t * Return whether a transaction was created by this aspect,\n\t\t * or whether we just have a placeholder to keep ThreadLocal stack integrity.\n\t\t */\n\t\tpublic boolean hasTransaction() {\n\t\t\treturn (this.transactionStatus != null);\n\t\t}\n\n\t\tprivate void bindToThread() {\n\t\t\t// Expose current TransactionStatus, preserving any existing TransactionStatus\n\t\t\t// for restoration after this transaction is complete.\n\t\t\tthis.oldTransactionInfo = transactionInfoHolder.get();\n\t\t\ttransactionInfoHolder.set(this);\n\t\t}\n\n\t\tprivate void restoreThreadLocalStatus() {\n\t\t\t// Use stack to restore old transaction TransactionInfo.\n\t\t\t// Will be null if none was set.\n\t\t\ttransactionInfoHolder.set(this.oldTransactionInfo);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn (this.transactionAttribute != null ? this.transactionAttribute.toString() : \"No transaction\");\n\t\t}\n\t}"
  },
  "org.springframework.transaction.interceptor.throwable": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 837
    },
    "signature": "public Throwable throwable",
    "source_code": "\t\tpublic Throwable throwable;",
    "type": "Throwable"
  },
  "org.springframework.transaction.jta.DEFAULT_TRANSACTION_SYNCHRONIZATION_REGISTRY_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Standard Jakarta EE JNDI location for the JTA TransactionSynchronizationRegistry.\n\t * Autodetected when available.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "signature": "public String DEFAULT_TRANSACTION_SYNCHRONIZATION_REGISTRY_NAME",
    "source_code": "\tpublic static final String DEFAULT_TRANSACTION_SYNCHRONIZATION_REGISTRY_NAME =",
    "type": "String"
  },
  "org.springframework.transaction.jta.DEFAULT_USER_TRANSACTION_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Default JNDI location for the JTA UserTransaction. Many Jakarta EE servers\n\t * also provide support for the JTA TransactionManager interface there.\n\t * @see #setUserTransactionName\n\t * @see #setAutodetectTransactionManager\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "signature": "public String DEFAULT_USER_TRANSACTION_NAME",
    "source_code": "\tpublic static final String DEFAULT_USER_TRANSACTION_NAME = \"java:comp/UserTransaction\";",
    "type": "String"
  },
  "org.springframework.transaction.jta.FALLBACK_TRANSACTION_MANAGER_NAMES": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Fallback JNDI locations for the JTA TransactionManager. Applied if\n\t * the JTA UserTransaction does not implement the JTA TransactionManager\n\t * interface, provided that the \"autodetectTransactionManager\" flag is \"true\".\n\t * @see #setTransactionManagerName\n\t * @see #setAutodetectTransactionManager\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "signature": "public String[] FALLBACK_TRANSACTION_MANAGER_NAMES",
    "source_code": "\tpublic static final String[] FALLBACK_TRANSACTION_MANAGER_NAMES =",
    "type": "String[]"
  },
  "org.springframework.transaction.jta.JtaTransactionManager": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link org.springframework.transaction.PlatformTransactionManager} implementation\n * for JTA, delegating to a backend JTA provider. This is typically used to delegate\n * to a Jakarta EE server's transaction coordinator, but may also be configured with a\n * local JTA provider which is embedded within the application.\n *\n * <p>This transaction manager is appropriate for handling distributed transactions,\n * i.e. transactions that span multiple resources, and for controlling transactions on\n * application server resources (e.g. JDBC DataSources available in JNDI) in general.\n * For a single JDBC DataSource, DataSourceTransactionManager is perfectly sufficient,\n * and for accessing a single resource with Hibernate (including transactional cache),\n * HibernateTransactionManager is appropriate, for example.\n *\n * <p><b>For typical JTA transactions (REQUIRED, SUPPORTS, MANDATORY, NEVER), a plain\n * JtaTransactionManager definition is all you need, portable across all Jakarta EE servers.</b>\n * This corresponds to the functionality of the JTA UserTransaction, for which Jakarta EE\n * specifies a standard JNDI name (\"java:comp/UserTransaction\"). There is no need to\n * configure a server-specific TransactionManager lookup for this kind of JTA usage.\n *\n * <p><b>Transaction suspension (REQUIRES_NEW, NOT_SUPPORTED) is just available with a\n * JTA TransactionManager being registered.</b> Common TransactionManager locations are\n * autodetected by JtaTransactionManager, provided that the \"autodetectTransactionManager\"\n * flag is set to \"true\" (which it is by default).\n *\n * <p>Note: Support for the JTA TransactionManager interface is not required by Jakarta EE.\n * Almost all Jakarta EE servers expose it, but do so as extension to EE. There might be some\n * issues with compatibility, despite the TransactionManager interface being part of JTA.\n *\n * <p>This pure JtaTransactionManager class supports timeouts but not per-transaction\n * isolation levels. Custom subclasses may override the {@link #doJtaBegin} method for\n * specific JTA extensions in order to provide this functionality. Such adapters for\n * specific Jakarta EE transaction coordinators may also expose transaction names for\n * monitoring; with standard JTA, transaction names will simply be ignored.\n *\n * <p>JTA 1.1 adds the TransactionSynchronizationRegistry facility, as public Jakarta EE\n * API in addition to the standard JTA UserTransaction handle. As of Spring 2.5, this\n * JtaTransactionManager autodetects the TransactionSynchronizationRegistry and uses\n * it for registering Spring-managed synchronizations when participating in an existing\n * JTA transaction (e.g. controlled by EJB CMT). If no TransactionSynchronizationRegistry\n * is available, then such synchronizations will be registered via the (non-EE) JTA\n * TransactionManager handle.\n *\n * <p>This class is serializable. However, active synchronizations do not survive serialization.\n *\n * @author Juergen Hoeller\n * @since 24.03.2003\n * @see jakarta.transaction.UserTransaction\n * @see jakarta.transaction.TransactionManager\n * @see jakarta.transaction.TransactionSynchronizationRegistry\n * @see #setUserTransactionName\n * @see #setUserTransaction\n * @see #setTransactionManagerName\n * @see #setTransactionManager\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "signature": "public class JtaTransactionManager",
    "source_code": "public class JtaTransactionManager extends AbstractPlatformTransactionManager"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the UserTransaction as well as the TransactionManager handle.\n\t * @see #initUserTransactionAndTransactionManager()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 437
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() throws TransactionSystemException {\n\t\tinitUserTransactionAndTransactionManager();\n\t\tcheckUserTransactionAndTransactionManager();\n\t\tinitTransactionSynchronizationRegistry();\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#applyIsolationLevel(txObject,isolationLevel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the given transaction isolation level. The default implementation\n\t * will throw an exception for any level other than ISOLATION_DEFAULT.\n\t * <p>To be overridden in subclasses for specific JTA implementations,\n\t * as alternative to overriding the full {@link #doJtaBegin} method.\n\t * @param txObject the JtaTransactionObject containing the UserTransaction\n\t * @param isolationLevel isolation level taken from transaction definition\n\t * @throws InvalidIsolationLevelException if the given isolation level\n\t * cannot be applied\n\t * @throws SystemException if thrown by the JTA implementation\n\t * @see #doJtaBegin\n\t * @see JtaTransactionObject#getUserTransaction()\n\t * @see #getTransactionManager()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "txObject",
      "isolationLevel"
    ],
    "position": {
      "column": 1,
      "line": 894
    },
    "return": "void",
    "signature": "protected void applyIsolationLevel(JtaTransactionObject txObject, int isolationLevel)",
    "source_code": "\tprotected void applyIsolationLevel(JtaTransactionObject txObject, int isolationLevel)"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#applyTimeout(txObject,timeout)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the given transaction timeout. The default implementation will call\n\t * {@code UserTransaction.setTransactionTimeout} for a non-default timeout value.\n\t * @param txObject the JtaTransactionObject containing the UserTransaction\n\t * @param timeout the timeout value taken from transaction definition\n\t * @throws SystemException if thrown by the JTA implementation\n\t * @see #doJtaBegin\n\t * @see JtaTransactionObject#getUserTransaction()\n\t * @see jakarta.transaction.UserTransaction#setTransactionTimeout(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "txObject",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 914
    },
    "return": "void",
    "signature": "protected void applyTimeout(JtaTransactionObject txObject, int timeout)",
    "source_code": "\tprotected void applyTimeout(JtaTransactionObject txObject, int timeout) throws SystemException {\n\t\tif (timeout > TransactionDefinition.TIMEOUT_DEFAULT) {\n\t\t\ttxObject.getUserTransaction().setTransactionTimeout(timeout);\n\t\t\tif (timeout > 0) {\n\t\t\t\ttxObject.resetTransactionTimeout = true;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#buildUserTransaction(transactionManager)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a UserTransaction handle based on the given TransactionManager.\n\t * @param transactionManager the TransactionManager\n\t * @return a corresponding UserTransaction handle\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transactionManager"
    ],
    "position": {
      "column": 1,
      "line": 549
    },
    "return": "UserTransaction",
    "signature": "protected UserTransaction buildUserTransaction(TransactionManager transactionManager)",
    "source_code": "\tprotected UserTransaction buildUserTransaction(TransactionManager transactionManager) {\n\t\tif (transactionManager instanceof UserTransaction ut) {\n\t\t\treturn ut;\n\t\t}\n\t\telse {\n\t\t\treturn new UserTransactionAdapter(transactionManager);\n\t\t}\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#checkUserTransactionAndTransactionManager()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check the UserTransaction as well as the TransactionManager handle,\n\t * assuming standard JTA requirements.\n\t * @throws IllegalStateException if no sufficient handles are available\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 489
    },
    "return": "void",
    "signature": "protected void checkUserTransactionAndTransactionManager()",
    "source_code": "\tprotected void checkUserTransactionAndTransactionManager() throws IllegalStateException {\n\t\t// We at least need the JTA UserTransaction.\n\t\tif (this.userTransaction != null) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Using JTA UserTransaction: \" + this.userTransaction);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\"No JTA UserTransaction available - specify either \" +\n\t\t\t\t\t\"'userTransaction' or 'userTransactionName' or 'transactionManager' or 'transactionManagerName'\");\n\t\t}\n\n\t\t// For transaction suspension, the JTA TransactionManager is necessary too.\n\t\tif (this.transactionManager != null) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Using JTA TransactionManager: \" + this.transactionManager);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlogger.warn(\"No JTA TransactionManager found: transaction suspension not available\");\n\t\t}\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#createTransaction(name,timeout)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 1196
    },
    "return": "Transaction",
    "signature": "public Transaction createTransaction(@Nullable String name, int timeout)",
    "source_code": "\tpublic Transaction createTransaction(@Nullable String name, int timeout) throws NotSupportedException, SystemException {\n\t\tTransactionManager tm = getTransactionManager();\n\t\tAssert.state(tm != null, \"No JTA TransactionManager available\");\n\t\tif (timeout >= 0) {\n\t\t\ttm.setTransactionTimeout(timeout);\n\t\t}\n\t\ttm.begin();\n\t\treturn new ManagedTransactionAdapter(tm);\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#doBegin(transaction,definition)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 837
    },
    "return": "void",
    "signature": "protected void doBegin(Object transaction, TransactionDefinition definition)",
    "source_code": "\tprotected void doBegin(Object transaction, TransactionDefinition definition) {\n\t\tJtaTransactionObject txObject = (JtaTransactionObject) transaction;\n\t\ttry {\n\t\t\tdoJtaBegin(txObject, definition);\n\t\t}\n\t\tcatch (NotSupportedException | UnsupportedOperationException ex) {\n\t\t\tthrow new NestedTransactionNotSupportedException(\n\t\t\t\t\t\"JTA implementation does not support nested transactions\", ex);\n\t\t}\n\t\tcatch (SystemException ex) {\n\t\t\tthrow new CannotCreateTransactionException(\"JTA failure on begin\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#doCleanupAfterCompletion(transaction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction"
    ],
    "position": {
      "column": 1,
      "line": 1178
    },
    "return": "void",
    "signature": "protected void doCleanupAfterCompletion(Object transaction)",
    "source_code": "\tprotected void doCleanupAfterCompletion(Object transaction) {\n\t\tJtaTransactionObject txObject = (JtaTransactionObject) transaction;\n\t\tif (txObject.resetTransactionTimeout) {\n\t\t\ttry {\n\t\t\t\ttxObject.getUserTransaction().setTransactionTimeout(0);\n\t\t\t}\n\t\t\tcatch (SystemException ex) {\n\t\t\t\tlogger.debug(\"Failed to reset transaction timeout after JTA completion\", ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#doCommit(status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 1002
    },
    "return": "void",
    "signature": "protected void doCommit(DefaultTransactionStatus status)",
    "source_code": "\tprotected void doCommit(DefaultTransactionStatus status) {\n\t\tJtaTransactionObject txObject = (JtaTransactionObject) status.getTransaction();\n\t\ttry {\n\t\t\tint jtaStatus = txObject.getUserTransaction().getStatus();\n\t\t\tif (jtaStatus == Status.STATUS_NO_TRANSACTION) {\n\t\t\t\t// Should never happen... would have thrown an exception before\n\t\t\t\t// and as a consequence led to a rollback, not to a commit call.\n\t\t\t\t// In any case, the transaction is already fully cleaned up.\n\t\t\t\tthrow new UnexpectedRollbackException(\"JTA transaction already completed - probably rolled back\");\n\t\t\t}\n\t\t\tif (jtaStatus == Status.STATUS_ROLLEDBACK) {\n\t\t\t\t// Only really happens on JBoss 4.2 in case of an early timeout...\n\t\t\t\t// Explicit rollback call necessary to clean up the transaction.\n\t\t\t\t// IllegalStateException expected on JBoss; call still necessary.\n\t\t\t\ttry {\n\t\t\t\t\ttxObject.getUserTransaction().rollback();\n\t\t\t\t}\n\t\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Rollback failure with transaction already marked as rolled back: \" + ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow new UnexpectedRollbackException(\"JTA transaction already rolled back (probably due to a timeout)\");\n\t\t\t}\n\t\t\ttxObject.getUserTransaction().commit();\n\t\t}\n\t\tcatch (RollbackException ex) {\n\t\t\tthrow new UnexpectedRollbackException(\n\t\t\t\t\t\"JTA transaction unexpectedly rolled back (maybe due to a timeout)\", ex);\n\t\t}\n\t\tcatch (HeuristicMixedException ex) {\n\t\t\tthrow new HeuristicCompletionException(HeuristicCompletionException.STATE_MIXED, ex);\n\t\t}\n\t\tcatch (HeuristicRollbackException ex) {\n\t\t\tthrow new HeuristicCompletionException(HeuristicCompletionException.STATE_ROLLED_BACK, ex);\n\t\t}\n\t\tcatch (IllegalStateException ex) {\n\t\t\tthrow new TransactionSystemException(\"Unexpected internal transaction state\", ex);\n\t\t}\n\t\tcatch (SystemException ex) {\n\t\t\tthrow new TransactionSystemException(\"JTA failure on commit\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#doGetJtaTransaction(ut)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get a JTA transaction object for the given current UserTransaction.\n\t * <p>Subclasses can override this to provide a JtaTransactionObject\n\t * subclass, for example holding some additional JTA handle needed.\n\t * @param ut the UserTransaction handle to use for the current transaction\n\t * @return the JtaTransactionObject holding the UserTransaction\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ut"
    ],
    "position": {
      "column": 1,
      "line": 807
    },
    "return": "JtaTransactionObject",
    "signature": "protected JtaTransactionObject doGetJtaTransaction(UserTransaction ut)",
    "source_code": "\tprotected JtaTransactionObject doGetJtaTransaction(UserTransaction ut) {\n\t\treturn new JtaTransactionObject(ut);\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#doGetTransaction()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns a JtaTransactionObject instance for the\n\t * JTA UserTransaction.\n\t * <p>The UserTransaction object will either be looked up freshly for the\n\t * current transaction, or the cached one looked up at startup will be used.\n\t * The latter is the default: Most application servers use a shared singleton\n\t * UserTransaction that can be cached. Turn off the \"cacheUserTransaction\"\n\t * flag to enforce a fresh lookup for every transaction.\n\t * @see #setCacheUserTransaction\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 787
    },
    "return": "Object",
    "signature": "protected Object doGetTransaction()",
    "source_code": "\tprotected Object doGetTransaction() {\n\t\tUserTransaction ut = getUserTransaction();\n\t\tif (ut == null) {\n\t\t\tthrow new CannotCreateTransactionException(\"No JTA UserTransaction available - \" +\n\t\t\t\t\t\"programmatic PlatformTransactionManager.getTransaction usage not supported\");\n\t\t}\n\t\tif (!this.cacheUserTransaction) {\n\t\t\tut = lookupUserTransaction(\n\t\t\t\t\tthis.userTransactionName != null ? this.userTransactionName : DEFAULT_USER_TRANSACTION_NAME);\n\t\t}\n\t\treturn doGetJtaTransaction(ut);\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#doJtaBegin(txObject,definition)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform a JTA begin on the JTA UserTransaction or TransactionManager.\n\t * <p>This implementation only supports standard JTA functionality:\n\t * that is, no per-transaction isolation levels and no transaction names.\n\t * Can be overridden in subclasses, for specific JTA implementations.\n\t * <p>Calls {@code applyIsolationLevel} and {@code applyTimeout}\n\t * before invoking the UserTransaction's {@code begin} method.\n\t * @param txObject the JtaTransactionObject containing the UserTransaction\n\t * @param definition the TransactionDefinition instance, describing propagation\n\t * behavior, isolation level, read-only flag, timeout, and transaction name\n\t * @throws NotSupportedException if thrown by JTA methods\n\t * @throws SystemException if thrown by JTA methods\n\t * @see #getUserTransaction\n\t * @see #getTransactionManager\n\t * @see #applyIsolationLevel\n\t * @see #applyTimeout\n\t * @see JtaTransactionObject#getUserTransaction()\n\t * @see jakarta.transaction.UserTransaction#setTransactionTimeout\n\t * @see jakarta.transaction.UserTransaction#begin\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "txObject",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 871
    },
    "return": "void",
    "signature": "protected void doJtaBegin(JtaTransactionObject txObject, TransactionDefinition definition)",
    "source_code": "\tprotected void doJtaBegin(JtaTransactionObject txObject, TransactionDefinition definition)"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#doJtaResume(txObject,suspendedTransaction)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform a JTA resume on the JTA TransactionManager.\n\t * <p>Can be overridden in subclasses, for specific JTA implementations.\n\t * @param txObject the JtaTransactionObject containing the UserTransaction\n\t * @param suspendedTransaction the suspended JTA Transaction object\n\t * @throws InvalidTransactionException if thrown by JTA methods\n\t * @throws SystemException if thrown by JTA methods\n\t * @see #getTransactionManager()\n\t * @see jakarta.transaction.TransactionManager#resume(jakarta.transaction.Transaction)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "txObject",
      "suspendedTransaction"
    ],
    "position": {
      "column": 1,
      "line": 980
    },
    "return": "void",
    "signature": "protected void doJtaResume(@Nullable JtaTransactionObject txObject, Object suspendedTransaction)",
    "source_code": "\tprotected void doJtaResume(@Nullable JtaTransactionObject txObject, Object suspendedTransaction)"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#doJtaSuspend(txObject)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform a JTA suspend on the JTA TransactionManager.\n\t * <p>Can be overridden in subclasses, for specific JTA implementations.\n\t * @param txObject the JtaTransactionObject containing the UserTransaction\n\t * @return the suspended JTA Transaction object\n\t * @throws SystemException if thrown by JTA methods\n\t * @see #getTransactionManager()\n\t * @see jakarta.transaction.TransactionManager#suspend()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "txObject"
    ],
    "position": {
      "column": 1,
      "line": 944
    },
    "return": "Object",
    "signature": "protected Object doJtaSuspend(JtaTransactionObject txObject)",
    "source_code": "\tprotected Object doJtaSuspend(JtaTransactionObject txObject) throws SystemException {\n\t\tif (getTransactionManager() == null) {\n\t\t\tthrow new TransactionSuspensionNotSupportedException(\n\t\t\t\t\t\"JtaTransactionManager needs a JTA TransactionManager for suspending a transaction: \" +\n\t\t\t\t\t\"specify the 'transactionManager' or 'transactionManagerName' property\");\n\t\t}\n\t\treturn getTransactionManager().suspend();\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#doRegisterAfterCompletionWithJtaTransaction(txObject,synchronizations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a JTA synchronization on the JTA TransactionManager, for calling\n\t * {@code afterCompletion} on the given Spring TransactionSynchronizations.\n\t * <p>The default implementation registers the synchronizations on the\n\t * JTA 1.1 TransactionSynchronizationRegistry, if available, or on the\n\t * JTA TransactionManager's current Transaction - again, if available.\n\t * If none of the two is available, a warning will be logged.\n\t * <p>Can be overridden in subclasses, for specific JTA implementations.\n\t * @param txObject the current transaction object\n\t * @param synchronizations a List of TransactionSynchronization objects\n\t * @throws RollbackException if thrown by JTA methods\n\t * @throws SystemException if thrown by JTA methods\n\t * @see #getTransactionManager()\n\t * @see jakarta.transaction.Transaction#registerSynchronization\n\t * @see jakarta.transaction.TransactionSynchronizationRegistry#registerInterposedSynchronization\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "txObject",
      "synchronizations"
    ],
    "position": {
      "column": 1,
      "line": 1141
    },
    "return": "void",
    "signature": "protected void doRegisterAfterCompletionWithJtaTransaction(JtaTransactionObject txObject, List<TransactionSynchronization> synchronizations)",
    "source_code": "\tprotected void doRegisterAfterCompletionWithJtaTransaction("
  },
  "org.springframework.transaction.jta.JtaTransactionManager#doResume(transaction,suspendedResources)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "suspendedResources"
    ],
    "position": {
      "column": 1,
      "line": 954
    },
    "return": "void",
    "signature": "protected void doResume(@Nullable Object transaction, Object suspendedResources)",
    "source_code": "\tprotected void doResume(@Nullable Object transaction, Object suspendedResources) {\n\t\tJtaTransactionObject txObject = (JtaTransactionObject) transaction;\n\t\ttry {\n\t\t\tdoJtaResume(txObject, suspendedResources);\n\t\t}\n\t\tcatch (InvalidTransactionException ex) {\n\t\t\tthrow new IllegalTransactionStateException(\"Tried to resume invalid JTA transaction\", ex);\n\t\t}\n\t\tcatch (IllegalStateException ex) {\n\t\t\tthrow new TransactionSystemException(\"Unexpected internal transaction state\", ex);\n\t\t}\n\t\tcatch (SystemException ex) {\n\t\t\tthrow new TransactionSystemException(\"JTA failure on resume\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#doRollback(status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 1047
    },
    "return": "void",
    "signature": "protected void doRollback(DefaultTransactionStatus status)",
    "source_code": "\tprotected void doRollback(DefaultTransactionStatus status) {\n\t\tJtaTransactionObject txObject = (JtaTransactionObject) status.getTransaction();\n\t\ttry {\n\t\t\tint jtaStatus = txObject.getUserTransaction().getStatus();\n\t\t\tif (jtaStatus != Status.STATUS_NO_TRANSACTION) {\n\t\t\t\ttry {\n\t\t\t\t\ttxObject.getUserTransaction().rollback();\n\t\t\t\t}\n\t\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\t\tif (jtaStatus == Status.STATUS_ROLLEDBACK) {\n\t\t\t\t\t\t// Only really happens on JBoss 4.2 in case of an early timeout...\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Rollback failure with transaction already marked as rolled back: \" + ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new TransactionSystemException(\"Unexpected internal transaction state\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (SystemException ex) {\n\t\t\tthrow new TransactionSystemException(\"JTA failure on rollback\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#doSetRollbackOnly(status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 1074
    },
    "return": "void",
    "signature": "protected void doSetRollbackOnly(DefaultTransactionStatus status)",
    "source_code": "\tprotected void doSetRollbackOnly(DefaultTransactionStatus status) {\n\t\tJtaTransactionObject txObject = (JtaTransactionObject) status.getTransaction();\n\t\tif (status.isDebug()) {\n\t\t\tlogger.debug(\"Setting JTA transaction rollback-only\");\n\t\t}\n\t\ttry {\n\t\t\tint jtaStatus = txObject.getUserTransaction().getStatus();\n\t\t\tif (jtaStatus != Status.STATUS_NO_TRANSACTION && jtaStatus != Status.STATUS_ROLLEDBACK) {\n\t\t\t\ttxObject.getUserTransaction().setRollbackOnly();\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalStateException ex) {\n\t\t\tthrow new TransactionSystemException(\"Unexpected internal transaction state\", ex);\n\t\t}\n\t\tcatch (SystemException ex) {\n\t\t\tthrow new TransactionSystemException(\"JTA failure on setRollbackOnly\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#doSuspend(transaction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction"
    ],
    "position": {
      "column": 1,
      "line": 925
    },
    "return": "Object",
    "signature": "protected Object doSuspend(Object transaction)",
    "source_code": "\tprotected Object doSuspend(Object transaction) {\n\t\tJtaTransactionObject txObject = (JtaTransactionObject) transaction;\n\t\ttry {\n\t\t\treturn doJtaSuspend(txObject);\n\t\t}\n\t\tcatch (SystemException ex) {\n\t\t\tthrow new TransactionSystemException(\"JTA failure on suspend\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#findTransactionManager(ut)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the JTA TransactionManager through autodetection: checking whether the\n\t * UserTransaction object implements the TransactionManager, and checking the\n\t * fallback JNDI locations.\n\t * @param ut the JTA UserTransaction object\n\t * @return the JTA TransactionManager reference, or {@code null} if not found\n\t * @see #FALLBACK_TRANSACTION_MANAGER_NAMES\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ut"
    ],
    "position": {
      "column": 1,
      "line": 704
    },
    "return": "TransactionManager",
    "signature": "protected TransactionManager findTransactionManager(@Nullable UserTransaction ut)",
    "source_code": "\tprotected TransactionManager findTransactionManager(@Nullable UserTransaction ut) {\n\t\tif (ut instanceof TransactionManager tm) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"JTA UserTransaction object [\" + ut + \"] implements TransactionManager\");\n\t\t\t}\n\t\t\treturn tm;\n\t\t}\n\n\t\t// Check fallback JNDI locations.\n\t\tfor (String jndiName : FALLBACK_TRANSACTION_MANAGER_NAMES) {\n\t\t\ttry {\n\t\t\t\tTransactionManager tm = getJndiTemplate().lookup(jndiName, TransactionManager.class);\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"JTA TransactionManager found at fallback JNDI location [\" + jndiName + \"]\");\n\t\t\t\t}\n\t\t\t\treturn tm;\n\t\t\t}\n\t\t\tcatch (NamingException ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"No JTA TransactionManager found at fallback JNDI location [\" + jndiName + \"]\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// OK, so no JTA TransactionManager is available...\n\t\treturn null;\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#findTransactionSynchronizationRegistry(ut,tm)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the JTA 1.1 TransactionSynchronizationRegistry through autodetection:\n\t * checking whether the UserTransaction object or TransactionManager object\n\t * implements it, and checking Jakarta EE's standard JNDI location.\n\t * <p>The default implementation simply returns {@code null}.\n\t * @param ut the JTA UserTransaction object\n\t * @param tm the JTA TransactionManager object\n\t * @return the JTA TransactionSynchronizationRegistry handle to use,\n\t * or {@code null} if none found\n\t * @throws TransactionSystemException in case of errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ut",
      "tm"
    ],
    "position": {
      "column": 1,
      "line": 744
    },
    "return": "TransactionSynchronizationRegistry",
    "signature": "protected TransactionSynchronizationRegistry findTransactionSynchronizationRegistry(@Nullable UserTransaction ut, @Nullable TransactionManager tm)",
    "source_code": "\tprotected TransactionSynchronizationRegistry findTransactionSynchronizationRegistry("
  },
  "org.springframework.transaction.jta.JtaTransactionManager#findUserTransaction()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the JTA UserTransaction through a default JNDI lookup:\n\t * \"java:comp/UserTransaction\".\n\t * @return the JTA UserTransaction reference, or {@code null} if not found\n\t * @see #DEFAULT_USER_TRANSACTION_NAME\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 677
    },
    "return": "UserTransaction",
    "signature": "protected UserTransaction findUserTransaction()",
    "source_code": "\tprotected UserTransaction findUserTransaction() {\n\t\tString jndiName = DEFAULT_USER_TRANSACTION_NAME;\n\t\ttry {\n\t\t\tUserTransaction ut = getJndiTemplate().lookup(jndiName, UserTransaction.class);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"JTA UserTransaction found at default JNDI location [\" + jndiName + \"]\");\n\t\t\t}\n\t\t\tthis.userTransactionObtainedFromJndi = true;\n\t\t\treturn ut;\n\t\t}\n\t\tcatch (NamingException ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"No JTA UserTransaction found at default JNDI location [\" + jndiName + \"]\", ex);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#getJndiEnvironment()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the JNDI environment to use for JNDI lookups.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "Properties",
    "signature": "public Properties getJndiEnvironment()",
    "source_code": "\tpublic Properties getJndiEnvironment() {\n\t\treturn this.jndiTemplate.getEnvironment();\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#getJndiTemplate()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the JndiTemplate used for JNDI lookups.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "JndiTemplate",
    "signature": "public JndiTemplate getJndiTemplate()",
    "source_code": "\tpublic JndiTemplate getJndiTemplate() {\n\t\treturn this.jndiTemplate;\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#getTransactionManager()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the JTA TransactionManager that this transaction manager uses, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 336
    },
    "return": "TransactionManager",
    "signature": "public TransactionManager getTransactionManager()",
    "source_code": "\tpublic TransactionManager getTransactionManager() {\n\t\treturn this.transactionManager;\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#getTransactionSynchronizationRegistry()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the JTA 1.1 TransactionSynchronizationRegistry that this transaction manager uses, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 389
    },
    "return": "TransactionSynchronizationRegistry",
    "signature": "public TransactionSynchronizationRegistry getTransactionSynchronizationRegistry()",
    "source_code": "\tpublic TransactionSynchronizationRegistry getTransactionSynchronizationRegistry() {\n\t\treturn this.transactionSynchronizationRegistry;\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#getUserTransaction()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the JTA UserTransaction that this transaction manager uses.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "UserTransaction",
    "signature": "public UserTransaction getUserTransaction()",
    "source_code": "\tpublic UserTransaction getUserTransaction() {\n\t\treturn this.userTransaction;\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#initTransactionSynchronizationRegistry()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the JTA 1.1 TransactionSynchronizationRegistry, if available.\n\t * <p>To be called after {@link #initUserTransactionAndTransactionManager()},\n\t * since it may check the UserTransaction and TransactionManager handles.\n\t * @throws TransactionSystemException if initialization failed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 518
    },
    "return": "void",
    "signature": "protected void initTransactionSynchronizationRegistry()",
    "source_code": "\tprotected void initTransactionSynchronizationRegistry() {\n\t\tif (this.transactionSynchronizationRegistry == null) {\n\t\t\t// Fetch JTA TransactionSynchronizationRegistry from JNDI, if necessary.\n\t\t\tif (StringUtils.hasLength(this.transactionSynchronizationRegistryName)) {\n\t\t\t\tthis.transactionSynchronizationRegistry =\n\t\t\t\t\t\tlookupTransactionSynchronizationRegistry(this.transactionSynchronizationRegistryName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.transactionSynchronizationRegistry = retrieveTransactionSynchronizationRegistry();\n\t\t\t\tif (this.transactionSynchronizationRegistry == null && this.autodetectTransactionSynchronizationRegistry) {\n\t\t\t\t\t// Autodetect in JNDI if applicable, and check UserTransaction/TransactionManager\n\t\t\t\t\t// object that implements TransactionSynchronizationRegistry otherwise.\n\t\t\t\t\tthis.transactionSynchronizationRegistry =\n\t\t\t\t\t\t\tfindTransactionSynchronizationRegistry(this.userTransaction, this.transactionManager);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.transactionSynchronizationRegistry != null) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Using JTA TransactionSynchronizationRegistry: \" + this.transactionSynchronizationRegistry);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#initUserTransactionAndTransactionManager()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the UserTransaction as well as the TransactionManager handle.\n\t * @throws TransactionSystemException if initialization failed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 447
    },
    "return": "void",
    "signature": "protected void initUserTransactionAndTransactionManager()",
    "source_code": "\tprotected void initUserTransactionAndTransactionManager() throws TransactionSystemException {\n\t\tif (this.userTransaction == null) {\n\t\t\t// Fetch JTA UserTransaction from JNDI, if necessary.\n\t\t\tif (StringUtils.hasLength(this.userTransactionName)) {\n\t\t\t\tthis.userTransaction = lookupUserTransaction(this.userTransactionName);\n\t\t\t\tthis.userTransactionObtainedFromJndi = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.userTransaction = retrieveUserTransaction();\n\t\t\t\tif (this.userTransaction == null && this.autodetectUserTransaction) {\n\t\t\t\t\t// Autodetect UserTransaction at its default JNDI location.\n\t\t\t\t\tthis.userTransaction = findUserTransaction();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.transactionManager == null) {\n\t\t\t// Fetch JTA TransactionManager from JNDI, if necessary.\n\t\t\tif (StringUtils.hasLength(this.transactionManagerName)) {\n\t\t\t\tthis.transactionManager = lookupTransactionManager(this.transactionManagerName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.transactionManager = retrieveTransactionManager();\n\t\t\t\tif (this.transactionManager == null && this.autodetectTransactionManager) {\n\t\t\t\t\t// Autodetect UserTransaction object that implements TransactionManager,\n\t\t\t\t\t// and check fallback JNDI locations otherwise.\n\t\t\t\t\tthis.transactionManager = findTransactionManager(this.userTransaction);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If only JTA TransactionManager specified, create UserTransaction handle for it.\n\t\tif (this.userTransaction == null && this.transactionManager != null) {\n\t\t\tthis.userTransaction = buildUserTransaction(this.transactionManager);\n\t\t}\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#isExistingTransaction(transaction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction"
    ],
    "position": {
      "column": 1,
      "line": 812
    },
    "return": "boolean",
    "signature": "protected boolean isExistingTransaction(Object transaction)",
    "source_code": "\tprotected boolean isExistingTransaction(Object transaction) {\n\t\tJtaTransactionObject txObject = (JtaTransactionObject) transaction;\n\t\ttry {\n\t\t\treturn (txObject.getUserTransaction().getStatus() != Status.STATUS_NO_TRANSACTION);\n\t\t}\n\t\tcatch (SystemException ex) {\n\t\t\tthrow new TransactionSystemException(\"JTA failure on getStatus\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#lookupTransactionManager(transactionManagerName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Look up the JTA TransactionManager in JNDI via the configured name.\n\t * <p>Called by {@code afterPropertiesSet} if no direct TransactionManager reference was set.\n\t * Can be overridden in subclasses to provide a different TransactionManager object.\n\t * @param transactionManagerName the JNDI name of the TransactionManager\n\t * @return the UserTransaction object\n\t * @throws TransactionSystemException if the JNDI lookup failed\n\t * @see #setJndiTemplate\n\t * @see #setTransactionManagerName\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transactionManagerName"
    ],
    "position": {
      "column": 1,
      "line": 592
    },
    "return": "TransactionManager",
    "signature": "protected TransactionManager lookupTransactionManager(String transactionManagerName)",
    "source_code": "\tprotected TransactionManager lookupTransactionManager(String transactionManagerName)"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#lookupTransactionSynchronizationRegistry(registryName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Look up the JTA 1.1 TransactionSynchronizationRegistry in JNDI via the configured name.\n\t * <p>Can be overridden in subclasses to provide a different TransactionManager object.\n\t * @param registryName the JNDI name of the\n\t * TransactionSynchronizationRegistry\n\t * @return the TransactionSynchronizationRegistry object\n\t * @throws TransactionSystemException if the JNDI lookup failed\n\t * @see #setJndiTemplate\n\t * @see #setTransactionSynchronizationRegistryName\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "registryName"
    ],
    "position": {
      "column": 1,
      "line": 616
    },
    "return": "TransactionSynchronizationRegistry",
    "signature": "protected TransactionSynchronizationRegistry lookupTransactionSynchronizationRegistry(String registryName)",
    "source_code": "\tprotected TransactionSynchronizationRegistry lookupTransactionSynchronizationRegistry(String registryName) throws TransactionSystemException {\n\t\ttry {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Retrieving JTA TransactionSynchronizationRegistry from JNDI location [\" + registryName + \"]\");\n\t\t\t}\n\t\t\treturn getJndiTemplate().lookup(registryName, TransactionSynchronizationRegistry.class);\n\t\t}\n\t\tcatch (NamingException ex) {\n\t\t\tthrow new TransactionSystemException(\n\t\t\t\t\t\"JTA TransactionSynchronizationRegistry is not available at JNDI location [\" + registryName + \"]\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#lookupUserTransaction(userTransactionName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Look up the JTA UserTransaction in JNDI via the configured name.\n\t * <p>Called by {@code afterPropertiesSet} if no direct UserTransaction reference was set.\n\t * Can be overridden in subclasses to provide a different UserTransaction object.\n\t * @param userTransactionName the JNDI name of the UserTransaction\n\t * @return the UserTransaction object\n\t * @throws TransactionSystemException if the JNDI lookup failed\n\t * @see #setJndiTemplate\n\t * @see #setUserTransactionName\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "userTransactionName"
    ],
    "position": {
      "column": 1,
      "line": 568
    },
    "return": "UserTransaction",
    "signature": "protected UserTransaction lookupUserTransaction(String userTransactionName)",
    "source_code": "\tprotected UserTransaction lookupUserTransaction(String userTransactionName)"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#registerAfterCompletionWithExistingTransaction(transaction,synchronizations)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "synchronizations"
    ],
    "position": {
      "column": 1,
      "line": 1095
    },
    "return": "void",
    "signature": "protected void registerAfterCompletionWithExistingTransaction(Object transaction, List<TransactionSynchronization> synchronizations)",
    "source_code": "\tprotected void registerAfterCompletionWithExistingTransaction("
  },
  "org.springframework.transaction.jta.JtaTransactionManager#retrieveTransactionManager()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Allows subclasses to retrieve the JTA TransactionManager in a vendor-specific manner.\n\t * Only called if no \"transactionManager\" or \"transactionManagerName\" specified.\n\t * <p>The default implementation simply returns {@code null}.\n\t * @return the JTA TransactionManager handle to use, or {@code null} if none found\n\t * @throws TransactionSystemException in case of errors\n\t * @see #setTransactionManager\n\t * @see #setTransactionManagerName\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 653
    },
    "return": "TransactionManager",
    "signature": "protected TransactionManager retrieveTransactionManager()",
    "source_code": "\tprotected TransactionManager retrieveTransactionManager() throws TransactionSystemException {\n\t\treturn null;\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#retrieveTransactionSynchronizationRegistry()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Allows subclasses to retrieve the JTA 1.1 TransactionSynchronizationRegistry\n\t * in a vendor-specific manner.\n\t * <p>The default implementation simply returns {@code null}.\n\t * @return the JTA TransactionSynchronizationRegistry handle to use,\n\t * or {@code null} if none found\n\t * @throws TransactionSystemException in case of errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 666
    },
    "return": "TransactionSynchronizationRegistry",
    "signature": "protected TransactionSynchronizationRegistry retrieveTransactionSynchronizationRegistry()",
    "source_code": "\tprotected TransactionSynchronizationRegistry retrieveTransactionSynchronizationRegistry() throws TransactionSystemException {\n\t\treturn null;\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#retrieveUserTransaction()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Allows subclasses to retrieve the JTA UserTransaction in a vendor-specific manner.\n\t * Only called if no \"userTransaction\" or \"userTransactionName\" specified.\n\t * <p>The default implementation simply returns {@code null}.\n\t * @return the JTA UserTransaction handle to use, or {@code null} if none found\n\t * @throws TransactionSystemException in case of errors\n\t * @see #setUserTransaction\n\t * @see #setUserTransactionName\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 639
    },
    "return": "UserTransaction",
    "signature": "protected UserTransaction retrieveUserTransaction()",
    "source_code": "\tprotected UserTransaction retrieveUserTransaction() throws TransactionSystemException {\n\t\treturn null;\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#setAllowCustomIsolationLevels(allowCustomIsolationLevels)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to allow custom isolation levels to be specified.\n\t * <p>Default is \"false\", throwing an exception if a non-default isolation level\n\t * is specified for a transaction. Turn this flag on if affected resource adapters\n\t * check the thread-bound transaction context and apply the specified isolation\n\t * levels individually (e.g. through an IsolationLevelDataSourceAdapter).\n\t * @see org.springframework.jdbc.datasource.IsolationLevelDataSourceAdapter\n\t * @see org.springframework.jdbc.datasource.lookup.IsolationLevelDataSourceRouter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "allowCustomIsolationLevels"
    ],
    "position": {
      "column": 1,
      "line": 427
    },
    "return": "void",
    "signature": "public void setAllowCustomIsolationLevels(boolean allowCustomIsolationLevels)",
    "source_code": "\tpublic void setAllowCustomIsolationLevels(boolean allowCustomIsolationLevels) {\n\t\tthis.allowCustomIsolationLevels = allowCustomIsolationLevels;\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#setAutodetectTransactionManager(autodetectTransactionManager)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to autodetect a JTA UserTransaction object that implements\n\t * the JTA TransactionManager interface too (i.e. the JNDI location for the\n\t * TransactionManager is \"java:comp/UserTransaction\", same as for the UserTransaction).\n\t * Also checks the fallback JNDI locations \"java:comp/TransactionManager\" and\n\t * \"java:/TransactionManager\". Will proceed without TransactionManager if none found.\n\t * <p>Default is \"true\", autodetecting the TransactionManager unless it has been\n\t * specified explicitly. Can be turned off to deliberately ignore an available\n\t * TransactionManager, for example when there are known issues with suspend/resume\n\t * and any attempt to use REQUIRES_NEW or NOT_SUPPORTED should fail fast.\n\t * @see #FALLBACK_TRANSACTION_MANAGER_NAMES\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "autodetectTransactionManager"
    ],
    "position": {
      "column": 1,
      "line": 366
    },
    "return": "void",
    "signature": "public void setAutodetectTransactionManager(boolean autodetectTransactionManager)",
    "source_code": "\tpublic void setAutodetectTransactionManager(boolean autodetectTransactionManager) {\n\t\tthis.autodetectTransactionManager = autodetectTransactionManager;\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#setAutodetectTransactionSynchronizationRegistry(autodetectTransactionSynchronizationRegistry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to autodetect a JTA 1.1 TransactionSynchronizationRegistry object\n\t * at its default JDNI location (\"java:comp/TransactionSynchronizationRegistry\")\n\t * if the UserTransaction has also been obtained from JNDI, and also whether\n\t * to fall back to checking whether the JTA UserTransaction/TransactionManager\n\t * object implements the JTA TransactionSynchronizationRegistry interface too.\n\t * <p>Default is \"true\", autodetecting the TransactionSynchronizationRegistry\n\t * unless it has been specified explicitly. Can be turned off to delegate\n\t * synchronization registration to the regular JTA TransactionManager API.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "autodetectTransactionSynchronizationRegistry"
    ],
    "position": {
      "column": 1,
      "line": 414
    },
    "return": "void",
    "signature": "public void setAutodetectTransactionSynchronizationRegistry(boolean autodetectTransactionSynchronizationRegistry)",
    "source_code": "\tpublic void setAutodetectTransactionSynchronizationRegistry(boolean autodetectTransactionSynchronizationRegistry) {\n\t\tthis.autodetectTransactionSynchronizationRegistry = autodetectTransactionSynchronizationRegistry;\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#setAutodetectUserTransaction(autodetectUserTransaction)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to autodetect the JTA UserTransaction at its default\n\t * JNDI location \"java:comp/UserTransaction\", as specified by Jakarta EE.\n\t * Will proceed without UserTransaction if none found.\n\t * <p>Default is \"true\", autodetecting the UserTransaction unless\n\t * it has been specified explicitly. Turn this flag off to allow for\n\t * JtaTransactionManager operating against the TransactionManager only,\n\t * despite a default UserTransaction being available.\n\t * @see #DEFAULT_USER_TRANSACTION_NAME\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "autodetectUserTransaction"
    ],
    "position": {
      "column": 1,
      "line": 298
    },
    "return": "void",
    "signature": "public void setAutodetectUserTransaction(boolean autodetectUserTransaction)",
    "source_code": "\tpublic void setAutodetectUserTransaction(boolean autodetectUserTransaction) {\n\t\tthis.autodetectUserTransaction = autodetectUserTransaction;\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#setCacheUserTransaction(cacheUserTransaction)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to cache the JTA UserTransaction object fetched from JNDI.\n\t * <p>Default is \"true\": UserTransaction lookup will only happen at startup,\n\t * reusing the same UserTransaction handle for all transactions of all threads.\n\t * This is the most efficient choice for all application servers that provide\n\t * a shared UserTransaction object (the typical case).\n\t * <p>Turn this flag off to enforce a fresh lookup of the UserTransaction\n\t * for every transaction. This is only necessary for application servers\n\t * that return a new UserTransaction for every transaction, keeping state\n\t * tied to the UserTransaction object itself rather than the current thread.\n\t * @see #setUserTransactionName\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cacheUserTransaction"
    ],
    "position": {
      "column": 1,
      "line": 314
    },
    "return": "void",
    "signature": "public void setCacheUserTransaction(boolean cacheUserTransaction)",
    "source_code": "\tpublic void setCacheUserTransaction(boolean cacheUserTransaction) {\n\t\tthis.cacheUserTransaction = cacheUserTransaction;\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#setJndiEnvironment(jndiEnvironment)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the JNDI environment to use for JNDI lookups.\n\t * Creates a JndiTemplate with the given environment settings.\n\t * @see #setJndiTemplate\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "jndiEnvironment"
    ],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "void",
    "signature": "public void setJndiEnvironment(@Nullable Properties jndiEnvironment)",
    "source_code": "\tpublic void setJndiEnvironment(@Nullable Properties jndiEnvironment) {\n\t\tthis.jndiTemplate = new JndiTemplate(jndiEnvironment);\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#setJndiTemplate(jndiTemplate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the JndiTemplate to use for JNDI lookups.\n\t * A default one is used if not set.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "jndiTemplate"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "void",
    "signature": "public void setJndiTemplate(JndiTemplate jndiTemplate)",
    "source_code": "\tpublic void setJndiTemplate(JndiTemplate jndiTemplate) {\n\t\tAssert.notNull(jndiTemplate, \"JndiTemplate must not be null\");\n\t\tthis.jndiTemplate = jndiTemplate;\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager(transactionManager)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the JTA TransactionManager to use as direct reference.\n\t * <p>A TransactionManager is necessary for suspending and resuming transactions,\n\t * as this not supported by the UserTransaction interface.\n\t * <p>Note that the TransactionManager will be autodetected if the JTA\n\t * UserTransaction object implements the JTA TransactionManager interface too,\n\t * as well as autodetected at various well-known fallback JNDI locations.\n\t * @see #setTransactionManagerName\n\t * @see #setAutodetectTransactionManager\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "transactionManager"
    ],
    "position": {
      "column": 1,
      "line": 328
    },
    "return": "void",
    "signature": "public void setTransactionManager(@Nullable TransactionManager transactionManager)",
    "source_code": "\tpublic void setTransactionManager(@Nullable TransactionManager transactionManager) {\n\t\tthis.transactionManager = transactionManager;\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#setTransactionManagerName(transactionManagerName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the JNDI name of the JTA TransactionManager.\n\t * <p>A TransactionManager is necessary for suspending and resuming transactions,\n\t * as this not supported by the UserTransaction interface.\n\t * <p>Note that the TransactionManager will be autodetected if the JTA\n\t * UserTransaction object implements the JTA TransactionManager interface too,\n\t * as well as autodetected at various well-known fallback JNDI locations.\n\t * @see #setTransactionManager\n\t * @see #setAutodetectTransactionManager\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "transactionManagerName"
    ],
    "position": {
      "column": 1,
      "line": 350
    },
    "return": "void",
    "signature": "public void setTransactionManagerName(String transactionManagerName)",
    "source_code": "\tpublic void setTransactionManagerName(String transactionManagerName) {\n\t\tthis.transactionManagerName = transactionManagerName;\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#setTransactionSynchronizationRegistry(transactionSynchronizationRegistry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the JTA 1.1 TransactionSynchronizationRegistry to use as direct reference.\n\t * <p>A TransactionSynchronizationRegistry allows for interposed registration\n\t * of transaction synchronizations, as an alternative to the regular registration\n\t * methods on the JTA TransactionManager API. Also, it is an official part of the\n\t * Jakarta EE platform, in contrast to the JTA TransactionManager itself.\n\t * <p>Note that the TransactionSynchronizationRegistry will be autodetected in JNDI and\n\t * also from the UserTransaction/TransactionManager object if implemented there as well.\n\t * @see #setTransactionSynchronizationRegistryName\n\t * @see #setAutodetectTransactionSynchronizationRegistry\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "transactionSynchronizationRegistry"
    ],
    "position": {
      "column": 1,
      "line": 381
    },
    "return": "void",
    "signature": "public void setTransactionSynchronizationRegistry(@Nullable TransactionSynchronizationRegistry transactionSynchronizationRegistry)",
    "source_code": "\tpublic void setTransactionSynchronizationRegistry(@Nullable TransactionSynchronizationRegistry transactionSynchronizationRegistry) {\n\t\tthis.transactionSynchronizationRegistry = transactionSynchronizationRegistry;\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#setTransactionSynchronizationRegistryName(transactionSynchronizationRegistryName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the JNDI name of the JTA 1.1 TransactionSynchronizationRegistry.\n\t * <p>Note that the TransactionSynchronizationRegistry will be autodetected\n\t * at the Jakarta EE default location \"java:comp/TransactionSynchronizationRegistry\"\n\t * if not specified explicitly.\n\t * @see #DEFAULT_TRANSACTION_SYNCHRONIZATION_REGISTRY_NAME\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "transactionSynchronizationRegistryName"
    ],
    "position": {
      "column": 1,
      "line": 400
    },
    "return": "void",
    "signature": "public void setTransactionSynchronizationRegistryName(String transactionSynchronizationRegistryName)",
    "source_code": "\tpublic void setTransactionSynchronizationRegistryName(String transactionSynchronizationRegistryName) {\n\t\tthis.transactionSynchronizationRegistryName = transactionSynchronizationRegistryName;\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#setUserTransaction(userTransaction)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the JTA UserTransaction to use as direct reference.\n\t * <p>Typically just used for local JTA setups; in a Jakarta EE environment,\n\t * the UserTransaction will always be fetched from JNDI.\n\t * @see #setUserTransactionName\n\t * @see #setAutodetectUserTransaction\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "userTransaction"
    ],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "void",
    "signature": "public void setUserTransaction(@Nullable UserTransaction userTransaction)",
    "source_code": "\tpublic void setUserTransaction(@Nullable UserTransaction userTransaction) {\n\t\tthis.userTransaction = userTransaction;\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#setUserTransactionName(userTransactionName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the JNDI name of the JTA UserTransaction.\n\t * <p>Note that the UserTransaction will be autodetected at the Jakarta EE\n\t * default location \"java:comp/UserTransaction\" if not specified explicitly.\n\t * @see #DEFAULT_USER_TRANSACTION_NAME\n\t * @see #setUserTransaction\n\t * @see #setAutodetectUserTransaction\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "userTransactionName"
    ],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "void",
    "signature": "public void setUserTransactionName(String userTransactionName)",
    "source_code": "\tpublic void setUserTransactionName(String userTransactionName) {\n\t\tthis.userTransactionName = userTransactionName;\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#shouldCommitOnGlobalRollbackOnly()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns \"true\": a JTA commit will properly handle\n\t * transactions that have been marked rollback-only at a global level.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 997
    },
    "return": "boolean",
    "signature": "protected boolean shouldCommitOnGlobalRollbackOnly()",
    "source_code": "\tprotected boolean shouldCommitOnGlobalRollbackOnly() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#supportsResourceAdapterManagedTransactions()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1207
    },
    "return": "boolean",
    "signature": "public boolean supportsResourceAdapterManagedTransactions()",
    "source_code": "\tpublic boolean supportsResourceAdapterManagedTransactions() {\n\t\treturn false;\n\t}"
  },
  "org.springframework.transaction.jta.JtaTransactionManager#useSavepointForNestedTransaction()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns false to cause a further invocation\n\t * of doBegin despite an already existing transaction.\n\t * <p>JTA implementations might support nested transactions via further\n\t * {@code UserTransaction.begin()} invocations, but never support savepoints.\n\t * @see #doBegin\n\t * @see jakarta.transaction.UserTransaction#begin()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 831
    },
    "return": "boolean",
    "signature": "protected boolean useSavepointForNestedTransaction()",
    "source_code": "\tprotected boolean useSavepointForNestedTransaction() {\n\t\treturn false;\n\t}"
  },
  "org.springframework.transaction.reactive.<unknown>#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (super.equals(other) && (!(other instanceof TransactionalOperatorImpl toi) ||\n\t\t\t\tgetTransactionManager() == toi.getTransactionManager())));\n\t}"
  },
  "org.springframework.transaction.reactive.<unknown>#execute(action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "action"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "Flux<T>",
    "signature": "public Flux<T> execute(TransactionCallback<T> action)",
    "source_code": "\tpublic <T> Flux<T> execute(TransactionCallback<T> action) throws TransactionException {\n\t\treturn TransactionContextManager.currentContext().flatMapMany(context -> {\n\t\t\tMono<ReactiveTransaction> status = this.transactionManager.getReactiveTransaction(this.transactionDefinition);\n\t\t\t// This is an around advice: Invoke the next interceptor in the chain.\n\t\t\t// This will normally result in a target object being invoked.\n\t\t\t// Need re-wrapping of ReactiveTransaction until we get hold of the exception\n\t\t\t// through usingWhen.\n\t\t\treturn status.flatMapMany(it -> Flux\n\t\t\t\t\t.usingWhen(\n\t\t\t\t\t\t\tMono.just(it),\n\t\t\t\t\t\t\taction::doInTransaction,\n\t\t\t\t\t\t\tthis.transactionManager::commit,\n\t\t\t\t\t\t\t(tx, ex) -> Mono.empty(),\n\t\t\t\t\t\t\tthis.transactionManager::rollback)\n\t\t\t\t\t.onErrorResume(ex ->\n\t\t\t\t\t\t\trollbackOnException(it, ex).then(Mono.error(ex))));\n\t\t})\n\t\t.contextWrite(TransactionContextManager.getOrCreateContext())\n\t\t.contextWrite(TransactionContextManager.getOrCreateContextHolder());\n\t}"
  },
  "org.springframework.transaction.reactive.<unknown>#getTransactionManager()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the transaction management strategy to be used.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "ReactiveTransactionManager",
    "signature": "public ReactiveTransactionManager getTransactionManager()",
    "source_code": "\tpublic ReactiveTransactionManager getTransactionManager() {\n\t\treturn this.transactionManager;\n\t}"
  },
  "org.springframework.transaction.reactive.<unknown>#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn getTransactionManager().hashCode();\n\t}"
  },
  "org.springframework.transaction.reactive.<unknown>#invokeAfterCommit(synchronizations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Actually invoke the {@code afterCommit} methods of the\n\t * given Spring TransactionSynchronization objects.\n\t * @param synchronizations a List of TransactionSynchronization objects\n\t * @see TransactionSynchronization#afterCommit()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "synchronizations"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> invokeAfterCommit(Collection<TransactionSynchronization> synchronizations)",
    "source_code": "\tpublic static Mono<Void> invokeAfterCommit(Collection<TransactionSynchronization> synchronizations) {\n\t\treturn Flux.fromIterable(synchronizations)\n\t\t\t\t.concatMap(TransactionSynchronization::afterCommit)\n\t\t\t\t.then();\n\t}"
  },
  "org.springframework.transaction.reactive.<unknown>#invokeAfterCompletion(synchronizations,completionStatus)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Actually invoke the {@code afterCompletion} methods of the\n\t * given Spring TransactionSynchronization objects.\n\t * @param synchronizations a List of TransactionSynchronization objects\n\t * @param completionStatus the completion status according to the\n\t * constants in the TransactionSynchronization interface\n\t * @see TransactionSynchronization#afterCompletion(int)\n\t * @see TransactionSynchronization#STATUS_COMMITTED\n\t * @see TransactionSynchronization#STATUS_ROLLED_BACK\n\t * @see TransactionSynchronization#STATUS_UNKNOWN\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "synchronizations",
      "completionStatus"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> invokeAfterCompletion(Collection<TransactionSynchronization> synchronizations, int completionStatus)",
    "source_code": "\tpublic static Mono<Void> invokeAfterCompletion("
  },
  "org.springframework.transaction.reactive.<unknown>#transactional(mono)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mono"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> transactional(Mono<T> mono)",
    "source_code": "\tpublic <T> Mono<T> transactional(Mono<T> mono) {\n\t\treturn TransactionContextManager.currentContext().flatMap(context -> {\n\t\t\tMono<ReactiveTransaction> status = this.transactionManager.getReactiveTransaction(this.transactionDefinition);\n\t\t\t// This is an around advice: Invoke the next interceptor in the chain.\n\t\t\t// This will normally result in a target object being invoked.\n\t\t\t// Need re-wrapping of ReactiveTransaction until we get hold of the exception\n\t\t\t// through usingWhen.\n\t\t\treturn status.flatMap(it -> Mono.usingWhen(Mono.just(it), ignore -> mono,\n\t\t\t\t\tthis.transactionManager::commit, (res, err) -> Mono.empty(), this.transactionManager::rollback)\n\t\t\t\t\t.onErrorResume(ex -> rollbackOnException(it, ex).then(Mono.error(ex))));\n\t\t})\n\t\t.contextWrite(TransactionContextManager.getOrCreateContext())\n\t\t.contextWrite(TransactionContextManager.getOrCreateContextHolder());\n\t}"
  },
  "org.springframework.transaction.reactive.<unknown>#triggerBeforeCommit(synchronizations,readOnly)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Actually invoke the {@code triggerBeforeCommit} methods of the\n\t * given Spring TransactionSynchronization objects.\n\t * @param synchronizations a List of TransactionSynchronization objects\n\t * @see TransactionSynchronization#beforeCommit(boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "synchronizations",
      "readOnly"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> triggerBeforeCommit(Collection<TransactionSynchronization> synchronizations, boolean readOnly)",
    "source_code": "\tpublic static Mono<Void> triggerBeforeCommit(Collection<TransactionSynchronization> synchronizations, boolean readOnly) {\n\t\treturn Flux.fromIterable(synchronizations).concatMap(it -> it.beforeCommit(readOnly)).then();\n\t}"
  },
  "org.springframework.transaction.reactive.<unknown>#triggerBeforeCompletion(synchronizations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Actually invoke the {@code beforeCompletion} methods of the\n\t * given Spring TransactionSynchronization objects.\n\t * @param synchronizations a List of TransactionSynchronization objects\n\t * @see TransactionSynchronization#beforeCompletion()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "synchronizations"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> triggerBeforeCompletion(Collection<TransactionSynchronization> synchronizations)",
    "source_code": "\tpublic static Mono<Void> triggerBeforeCompletion(Collection<TransactionSynchronization> synchronizations) {\n\t\treturn Flux.fromIterable(synchronizations)\n\t\t\t\t.concatMap(TransactionSynchronization::beforeCompletion).onErrorContinue((t, o) ->\n\t\t\t\t\t\tlogger.debug(\"TransactionSynchronization.beforeCompletion threw exception\", t)).then();\n\t}"
  },
  "org.springframework.transaction.reactive.<unknown>#unwrapIfNecessary(resource)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resource"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "Object",
    "signature": "public Object unwrapIfNecessary(Object resource)",
    "source_code": "\t\tpublic static Object unwrapIfNecessary(Object resource) {\n\t\t\tif (resource instanceof ScopedObject scopedObject) {\n\t\t\t\treturn scopedObject.getTargetObject();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn resource;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionStatus": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Default implementation of the {@link org.springframework.transaction.TransactionStatus}\n * interface, used by {@link AbstractPlatformTransactionManager}. Based on the concept\n * of an underlying \"transaction object\".\n *\n * <p>Holds all status information that {@link AbstractPlatformTransactionManager}\n * needs internally, including a generic transaction object determined by the\n * concrete transaction manager implementation.\n *\n * <p>Supports delegating savepoint-related methods to a transaction object\n * that implements the {@link SavepointManager} interface.\n *\n * <p><b>NOTE:</b> This is <i>not</i> intended for use with other PlatformTransactionManager\n * implementations, in particular not for mock transaction managers in testing environments.\n * Use the alternative {@link SimpleTransactionStatus} class or a mock for the plain\n * {@link org.springframework.transaction.TransactionStatus} interface instead.\n *\n * @author Juergen Hoeller\n * @since 19.01.2004\n * @see AbstractPlatformTransactionManager\n * @see org.springframework.transaction.SavepointManager\n * @see #getTransaction\n * @see #createSavepoint\n * @see #rollbackToSavepoint\n * @see #releaseSavepoint\n * @see SimpleTransactionStatus\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "public class DefaultTransactionStatus",
    "source_code": "public class DefaultTransactionStatus extends AbstractTransactionStatus {\n\n\t@Nullable\n\tprivate final Object transaction;\n\n\tprivate final boolean newTransaction;\n\n\tprivate final boolean newSynchronization;\n\n\tprivate final boolean readOnly;\n\n\tprivate final boolean debug;\n\n\t@Nullable\n\tprivate final Object suspendedResources;\n\n\n\t/**\n\t * Create a new {@code DefaultTransactionStatus} instance.\n\t * @param transaction underlying transaction object that can hold state\n\t * for the internal transaction implementation\n\t * @param newTransaction if the transaction is new, otherwise participating\n\t * in an existing transaction\n\t * @param newSynchronization if a new transaction synchronization has been\n\t * opened for the given transaction\n\t * @param readOnly whether the transaction is marked as read-only\n\t * @param debug should debug logging be enabled for the handling of this transaction?\n\t * Caching it in here can prevent repeated calls to ask the logging system whether\n\t * debug logging should be enabled.\n\t * @param suspendedResources a holder for resources that have been suspended\n\t * for this transaction, if any\n\t */\n\tpublic DefaultTransactionStatus(\n\t\t\t@Nullable Object transaction, boolean newTransaction, boolean newSynchronization,\n\t\t\tboolean readOnly, boolean debug, @Nullable Object suspendedResources) {\n\n\t\tthis.transaction = transaction;\n\t\tthis.newTransaction = newTransaction;\n\t\tthis.newSynchronization = newSynchronization;\n\t\tthis.readOnly = readOnly;\n\t\tthis.debug = debug;\n\t\tthis.suspendedResources = suspendedResources;\n\t}\n\n\n\t/**\n\t * Return the underlying transaction object.\n\t * @throws IllegalStateException if no transaction is active\n\t */\n\tpublic Object getTransaction() {\n\t\tAssert.state(this.transaction != null, \"No transaction active\");\n\t\treturn this.transaction;\n\t}\n\n\t/**\n\t * Return whether there is an actual transaction active.\n\t */\n\tpublic boolean hasTransaction() {\n\t\treturn (this.transaction != null);\n\t}\n\n\t@Override\n\tpublic boolean isNewTransaction() {\n\t\treturn (hasTransaction() && this.newTransaction);\n\t}\n\n\t/**\n\t * Return if a new transaction synchronization has been opened\n\t * for this transaction.\n\t */\n\tpublic boolean isNewSynchronization() {\n\t\treturn this.newSynchronization;\n\t}\n\n\t/**\n\t * Return if this transaction is defined as read-only transaction.\n\t */\n\tpublic boolean isReadOnly() {\n\t\treturn this.readOnly;\n\t}\n\n\t/**\n\t * Return whether the progress of this transaction is debugged. This is used by\n\t * {@link AbstractPlatformTransactionManager} as an optimization, to prevent repeated\n\t * calls to {@code logger.isDebugEnabled()}. Not really intended for client code.\n\t */\n\tpublic boolean isDebug() {\n\t\treturn this.debug;\n\t}\n\n\t/**\n\t * Return the holder for resources that have been suspended for this transaction,\n\t * if any.\n\t */\n\t@Nullable\n\tpublic Object getSuspendedResources() {\n\t\treturn this.suspendedResources;\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Enable functionality through underlying transaction object\n\t//---------------------------------------------------------------------\n\n\t/**\n\t * Determine the rollback-only flag via checking the transaction object, provided\n\t * that the latter implements the {@link SmartTransactionObject} interface.\n\t * <p>Will return {@code true} if the global transaction itself has been marked\n\t * rollback-only by the transaction coordinator, for example in case of a timeout.\n\t * @see SmartTransactionObject#isRollbackOnly()\n\t */\n\t@Override\n\tpublic boolean isGlobalRollbackOnly() {\n\t\treturn (this.transaction instanceof SmartTransactionObject smartTransactionObject &&\n\t\t\t\tsmartTransactionObject.isRollbackOnly());\n\t}\n\n\t/**\n\t * This implementation exposes the {@link SavepointManager} interface\n\t * of the underlying transaction object, if any.\n\t * @throws NestedTransactionNotSupportedException if savepoints are not supported\n\t * @see #isTransactionSavepointManager()\n\t */\n\t@Override\n\tprotected SavepointManager getSavepointManager() {\n\t\tObject transaction = this.transaction;\n\t\tif (!(transaction instanceof SavepointManager savepointManager)) {\n\t\t\tthrow new NestedTransactionNotSupportedException(\n\t\t\t\t\t\"Transaction object [\" + this.transaction + \"] does not support savepoints\");\n\t\t}\n\t\treturn savepointManager;\n\t}\n\n\t/**\n\t * Return whether the underlying transaction implements the {@link SavepointManager}\n\t * interface and therefore supports savepoints.\n\t * @see #getTransaction()\n\t * @see #getSavepointManager()\n\t */\n\tpublic boolean isTransactionSavepointManager() {\n\t\treturn (this.transaction instanceof SavepointManager);\n\t}\n\n\t/**\n\t * Delegate the flushing to the transaction object, provided that the latter\n\t * implements the {@link SmartTransactionObject} interface.\n\t * @see SmartTransactionObject#flush()\n\t */\n\t@Override\n\tpublic void flush() {\n\t\tif (this.transaction instanceof SmartTransactionObject smartTransactionObject) {\n\t\t\tsmartTransactionObject.flush();\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.transaction.support.DefaultTransactionStatus#flush()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate the flushing to the transaction object, provided that the latter\n\t * implements the {@link SmartTransactionObject} interface.\n\t * @see SmartTransactionObject#flush()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "void",
    "signature": "public void flush()",
    "source_code": "\tpublic void flush() {\n\t\tif (this.transaction instanceof SmartTransactionObject smartTransactionObject) {\n\t\t\tsmartTransactionObject.flush();\n\t\t}\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionStatus#getSavepointManager()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation exposes the {@link SavepointManager} interface\n\t * of the underlying transaction object, if any.\n\t * @throws NestedTransactionNotSupportedException if savepoints are not supported\n\t * @see #isTransactionSavepointManager()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "SavepointManager",
    "signature": "protected SavepointManager getSavepointManager()",
    "source_code": "\tprotected SavepointManager getSavepointManager() {\n\t\tObject transaction = this.transaction;\n\t\tif (!(transaction instanceof SavepointManager savepointManager)) {\n\t\t\tthrow new NestedTransactionNotSupportedException(\n\t\t\t\t\t\"Transaction object [\" + this.transaction + \"] does not support savepoints\");\n\t\t}\n\t\treturn savepointManager;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionStatus#getSuspendedResources()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the holder for resources that have been suspended for this transaction,\n\t * if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "Object",
    "signature": "public Object getSuspendedResources()",
    "source_code": "\tpublic Object getSuspendedResources() {\n\t\treturn this.suspendedResources;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionStatus#getTransaction()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the underlying transaction object.\n\t * @throws IllegalStateException if no transaction is active\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "Object",
    "signature": "public Object getTransaction()",
    "source_code": "\tpublic Object getTransaction() {\n\t\tAssert.state(this.transaction != null, \"No transaction active\");\n\t\treturn this.transaction;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionStatus#hasTransaction()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether there is an actual transaction active.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "boolean",
    "signature": "public boolean hasTransaction()",
    "source_code": "\tpublic boolean hasTransaction() {\n\t\treturn (this.transaction != null);\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionStatus#isDebug()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether the progress of this transaction is debugged. This is used by\n\t * {@link AbstractPlatformTransactionManager} as an optimization, to prevent repeated\n\t * calls to {@code logger.isDebugEnabled()}. Not really intended for client code.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "boolean",
    "signature": "public boolean isDebug()",
    "source_code": "\tpublic boolean isDebug() {\n\t\treturn this.debug;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionStatus#isGlobalRollbackOnly()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the rollback-only flag via checking the transaction object, provided\n\t * that the latter implements the {@link SmartTransactionObject} interface.\n\t * <p>Will return {@code true} if the global transaction itself has been marked\n\t * rollback-only by the transaction coordinator, for example in case of a timeout.\n\t * @see SmartTransactionObject#isRollbackOnly()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "boolean",
    "signature": "public boolean isGlobalRollbackOnly()",
    "source_code": "\tpublic boolean isGlobalRollbackOnly() {\n\t\treturn (this.transaction instanceof SmartTransactionObject smartTransactionObject &&\n\t\t\t\tsmartTransactionObject.isRollbackOnly());\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionStatus#isNewSynchronization()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return if a new transaction synchronization has been opened\n\t * for this transaction.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "boolean",
    "signature": "public boolean isNewSynchronization()",
    "source_code": "\tpublic boolean isNewSynchronization() {\n\t\treturn this.newSynchronization;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionStatus#isNewTransaction()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "boolean",
    "signature": "public boolean isNewTransaction()",
    "source_code": "\tpublic boolean isNewTransaction() {\n\t\treturn (hasTransaction() && this.newTransaction);\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionStatus#isReadOnly()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return if this transaction is defined as read-only transaction.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "boolean",
    "signature": "public boolean isReadOnly()",
    "source_code": "\tpublic boolean isReadOnly() {\n\t\treturn this.readOnly;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionStatus#isTransactionSavepointManager()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether the underlying transaction implements the {@link SavepointManager}\n\t * interface and therefore supports savepoints.\n\t * @see #getTransaction()\n\t * @see #getSavepointManager()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "boolean",
    "signature": "public boolean isTransactionSavepointManager()",
    "source_code": "\tpublic boolean isTransactionSavepointManager() {\n\t\treturn (this.transaction instanceof SavepointManager);\n\t}"
  },
  "org.springframework.transaction.support.TransactionSynchronizationManager": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Central delegate that manages resources and transaction synchronizations per thread.\n * To be used by resource management code but not by typical application code.\n *\n * <p>Supports one resource per key without overwriting, that is, a resource needs\n * to be removed before a new one can be set for the same key.\n * Supports a list of transaction synchronizations if synchronization is active.\n *\n * <p>Resource management code should check for thread-bound resources, e.g. JDBC\n * Connections or Hibernate Sessions, via {@code getResource}. Such code is\n * normally not supposed to bind resources to threads, as this is the responsibility\n * of transaction managers. A further option is to lazily bind on first use if\n * transaction synchronization is active, for performing transactions that span\n * an arbitrary number of resources.\n *\n * <p>Transaction synchronization must be activated and deactivated by a transaction\n * manager via {@link #initSynchronization()} and {@link #clearSynchronization()}.\n * This is automatically supported by {@link AbstractPlatformTransactionManager},\n * and thus by all standard Spring transaction managers, such as\n * {@link org.springframework.transaction.jta.JtaTransactionManager} and\n * {@link org.springframework.jdbc.datasource.DataSourceTransactionManager}.\n *\n * <p>Resource management code should only register synchronizations when this\n * manager is active, which can be checked via {@link #isSynchronizationActive};\n * it should perform immediate resource cleanup else. If transaction synchronization\n * isn't active, there is either no current transaction, or the transaction manager\n * doesn't support transaction synchronization.\n *\n * <p>Synchronization is for example used to always return the same resources\n * within a JTA transaction, e.g. a JDBC Connection or a Hibernate Session for\n * any given DataSource or SessionFactory, respectively.\n *\n * @author Juergen Hoeller\n * @since 02.06.2003\n * @see #isSynchronizationActive\n * @see #registerSynchronization\n * @see TransactionSynchronization\n * @see AbstractPlatformTransactionManager#setTransactionSynchronization\n * @see org.springframework.transaction.jta.JtaTransactionManager\n * @see org.springframework.jdbc.datasource.DataSourceTransactionManager\n * @see org.springframework.jdbc.datasource.DataSourceUtils#getConnection\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "signature": "public class TransactionSynchronizationManager",
    "source_code": "public abstract class TransactionSynchronizationManager {\n\n\tprivate static final ThreadLocal<Map<Object, Object>> resources =\n\t\t\tnew NamedThreadLocal<>(\"Transactional resources\");\n\n\tprivate static final ThreadLocal<Set<TransactionSynchronization>> synchronizations =\n\t\t\tnew NamedThreadLocal<>(\"Transaction synchronizations\");\n\n\tprivate static final ThreadLocal<String> currentTransactionName =\n\t\t\tnew NamedThreadLocal<>(\"Current transaction name\");\n\n\tprivate static final ThreadLocal<Boolean> currentTransactionReadOnly =\n\t\t\tnew NamedThreadLocal<>(\"Current transaction read-only status\");\n\n\tprivate static final ThreadLocal<Integer> currentTransactionIsolationLevel =\n\t\t\tnew NamedThreadLocal<>(\"Current transaction isolation level\");\n\n\tprivate static final ThreadLocal<Boolean> actualTransactionActive =\n\t\t\tnew NamedThreadLocal<>(\"Actual transaction active\");\n\n\n\t//-------------------------------------------------------------------------\n\t// Management of transaction-associated resource handles\n\t//-------------------------------------------------------------------------\n\n\t/**\n\t * Return all resources that are bound to the current thread.\n\t * <p>Mainly for debugging purposes. Resource managers should always invoke\n\t * {@code hasResource} for a specific resource key that they are interested in.\n\t * @return a Map with resource keys (usually the resource factory) and resource\n\t * values (usually the active resource object), or an empty Map if there are\n\t * currently no resources bound\n\t * @see #hasResource\n\t */\n\tpublic static Map<Object, Object> getResourceMap() {\n\t\tMap<Object, Object> map = resources.get();\n\t\treturn (map != null ? Collections.unmodifiableMap(map) : Collections.emptyMap());\n\t}\n\n\t/**\n\t * Check if there is a resource for the given key bound to the current thread.\n\t * @param key the key to check (usually the resource factory)\n\t * @return if there is a value bound to the current thread\n\t * @see ResourceTransactionManager#getResourceFactory()\n\t */\n\tpublic static boolean hasResource(Object key) {\n\t\tObject actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);\n\t\tObject value = doGetResource(actualKey);\n\t\treturn (value != null);\n\t}\n\n\t/**\n\t * Retrieve a resource for the given key that is bound to the current thread.\n\t * @param key the key to check (usually the resource factory)\n\t * @return a value bound to the current thread (usually the active\n\t * resource object), or {@code null} if none\n\t * @see ResourceTransactionManager#getResourceFactory()\n\t */\n\t@Nullable\n\tpublic static Object getResource(Object key) {\n\t\tObject actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);\n\t\treturn doGetResource(actualKey);\n\t}\n\n\t/**\n\t * Actually check the value of the resource that is bound for the given key.\n\t */\n\t@Nullable\n\tprivate static Object doGetResource(Object actualKey) {\n\t\tMap<Object, Object> map = resources.get();\n\t\tif (map == null) {\n\t\t\treturn null;\n\t\t}\n\t\tObject value = map.get(actualKey);\n\t\t// Transparently remove ResourceHolder that was marked as void...\n\t\tif (value instanceof ResourceHolder resourceHolder && resourceHolder.isVoid()) {\n\t\t\tmap.remove(actualKey);\n\t\t\t// Remove entire ThreadLocal if empty...\n\t\t\tif (map.isEmpty()) {\n\t\t\t\tresources.remove();\n\t\t\t}\n\t\t\tvalue = null;\n\t\t}\n\t\treturn value;\n\t}\n\n\t/**\n\t * Bind the given resource for the given key to the current thread.\n\t * @param key the key to bind the value to (usually the resource factory)\n\t * @param value the value to bind (usually the active resource object)\n\t * @throws IllegalStateException if there is already a value bound to the thread\n\t * @see ResourceTransactionManager#getResourceFactory()\n\t */\n\tpublic static void bindResource(Object key, Object value) throws IllegalStateException {\n\t\tObject actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);\n\t\tAssert.notNull(value, \"Value must not be null\");\n\t\tMap<Object, Object> map = resources.get();\n\t\t// set ThreadLocal Map if none found\n\t\tif (map == null) {\n\t\t\tmap = new HashMap<>();\n\t\t\tresources.set(map);\n\t\t}\n\t\tObject oldValue = map.put(actualKey, value);\n\t\t// Transparently suppress a ResourceHolder that was marked as void...\n\t\tif (oldValue instanceof ResourceHolder resourceHolder && resourceHolder.isVoid()) {\n\t\t\toldValue = null;\n\t\t}\n\t\tif (oldValue != null) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Already value [\" + oldValue + \"] for key [\" + actualKey + \"] bound to thread\");\n\t\t}\n\t}\n\n\t/**\n\t * Unbind a resource for the given key from the current thread.\n\t * @param key the key to unbind (usually the resource factory)\n\t * @return the previously bound value (usually the active resource object)\n\t * @throws IllegalStateException if there is no value bound to the thread\n\t * @see ResourceTransactionManager#getResourceFactory()\n\t */\n\tpublic static Object unbindResource(Object key) throws IllegalStateException {\n\t\tObject actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);\n\t\tObject value = doUnbindResource(actualKey);\n\t\tif (value == null) {\n\t\t\tthrow new IllegalStateException(\"No value for key [\" + actualKey + \"] bound to thread\");\n\t\t}\n\t\treturn value;\n\t}\n\n\t/**\n\t * Unbind a resource for the given key from the current thread.\n\t * @param key the key to unbind (usually the resource factory)\n\t * @return the previously bound value, or {@code null} if none bound\n\t */\n\t@Nullable\n\tpublic static Object unbindResourceIfPossible(Object key) {\n\t\tObject actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);\n\t\treturn doUnbindResource(actualKey);\n\t}\n\n\t/**\n\t * Actually remove the value of the resource that is bound for the given key.\n\t */\n\t@Nullable\n\tprivate static Object doUnbindResource(Object actualKey) {\n\t\tMap<Object, Object> map = resources.get();\n\t\tif (map == null) {\n\t\t\treturn null;\n\t\t}\n\t\tObject value = map.remove(actualKey);\n\t\t// Remove entire ThreadLocal if empty...\n\t\tif (map.isEmpty()) {\n\t\t\tresources.remove();\n\t\t}\n\t\t// Transparently suppress a ResourceHolder that was marked as void...\n\t\tif (value instanceof ResourceHolder resourceHolder && resourceHolder.isVoid()) {\n\t\t\tvalue = null;\n\t\t}\n\t\treturn value;\n\t}\n\n\n\t//-------------------------------------------------------------------------\n\t// Management of transaction synchronizations\n\t//-------------------------------------------------------------------------\n\n\t/**\n\t * Return if transaction synchronization is active for the current thread.\n\t * Can be called before register to avoid unnecessary instance creation.\n\t * @see #registerSynchronization\n\t */\n\tpublic static boolean isSynchronizationActive() {\n\t\treturn (synchronizations.get() != null);\n\t}\n\n\t/**\n\t * Activate transaction synchronization for the current thread.\n\t * Called by a transaction manager on transaction begin.\n\t * @throws IllegalStateException if synchronization is already active\n\t */\n\tpublic static void initSynchronization() throws IllegalStateException {\n\t\tif (isSynchronizationActive()) {\n\t\t\tthrow new IllegalStateException(\"Cannot activate transaction synchronization - already active\");\n\t\t}\n\t\tsynchronizations.set(new LinkedHashSet<>());\n\t}\n\n\t/**\n\t * Register a new transaction synchronization for the current thread.\n\t * Typically called by resource management code.\n\t * <p>Note that synchronizations can implement the\n\t * {@link org.springframework.core.Ordered} interface.\n\t * They will be executed in an order according to their order value (if any).\n\t * @param synchronization the synchronization object to register\n\t * @throws IllegalStateException if transaction synchronization is not active\n\t * @see org.springframework.core.Ordered\n\t */\n\tpublic static void registerSynchronization(TransactionSynchronization synchronization)\n\t\t\tthrows IllegalStateException {\n\n\t\tAssert.notNull(synchronization, \"TransactionSynchronization must not be null\");\n\t\tSet<TransactionSynchronization> synchs = synchronizations.get();\n\t\tif (synchs == null) {\n\t\t\tthrow new IllegalStateException(\"Transaction synchronization is not active\");\n\t\t}\n\t\tsynchs.add(synchronization);\n\t}\n\n\t/**\n\t * Return an unmodifiable snapshot list of all registered synchronizations\n\t * for the current thread.\n\t * @return unmodifiable List of TransactionSynchronization instances\n\t * @throws IllegalStateException if synchronization is not active\n\t * @see TransactionSynchronization\n\t */\n\tpublic static List<TransactionSynchronization> getSynchronizations() throws IllegalStateException {\n\t\tSet<TransactionSynchronization> synchs = synchronizations.get();\n\t\tif (synchs == null) {\n\t\t\tthrow new IllegalStateException(\"Transaction synchronization is not active\");\n\t\t}\n\t\t// Return unmodifiable snapshot, to avoid ConcurrentModificationExceptions\n\t\t// while iterating and invoking synchronization callbacks that in turn\n\t\t// might register further synchronizations.\n\t\tif (synchs.isEmpty()) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\telse {\n\t\t\t// Sort lazily here, not in registerSynchronization.\n\t\t\tList<TransactionSynchronization> sortedSynchs = new ArrayList<>(synchs);\n\t\t\tOrderComparator.sort(sortedSynchs);\n\t\t\treturn Collections.unmodifiableList(sortedSynchs);\n\t\t}\n\t}\n\n\t/**\n\t * Deactivate transaction synchronization for the current thread.\n\t * Called by the transaction manager on transaction cleanup.\n\t * @throws IllegalStateException if synchronization is not active\n\t */\n\tpublic static void clearSynchronization() throws IllegalStateException {\n\t\tif (!isSynchronizationActive()) {\n\t\t\tthrow new IllegalStateException(\"Cannot deactivate transaction synchronization - not active\");\n\t\t}\n\t\tsynchronizations.remove();\n\t}\n\n\n\t//-------------------------------------------------------------------------\n\t// Exposure of transaction characteristics\n\t//-------------------------------------------------------------------------\n\n\t/**\n\t * Expose the name of the current transaction, if any.\n\t * Called by the transaction manager on transaction begin and on cleanup.\n\t * @param name the name of the transaction, or {@code null} to reset it\n\t * @see org.springframework.transaction.TransactionDefinition#getName()\n\t */\n\tpublic static void setCurrentTransactionName(@Nullable String name) {\n\t\tcurrentTransactionName.set(name);\n\t}\n\n\t/**\n\t * Return the name of the current transaction, or {@code null} if none set.\n\t * To be called by resource management code for optimizations per use case,\n\t * for example to optimize fetch strategies for specific named transactions.\n\t * @see org.springframework.transaction.TransactionDefinition#getName()\n\t */\n\t@Nullable\n\tpublic static String getCurrentTransactionName() {\n\t\treturn currentTransactionName.get();\n\t}\n\n\t/**\n\t * Expose a read-only flag for the current transaction.\n\t * Called by the transaction manager on transaction begin and on cleanup.\n\t * @param readOnly {@code true} to mark the current transaction\n\t * as read-only; {@code false} to reset such a read-only marker\n\t * @see org.springframework.transaction.TransactionDefinition#isReadOnly()\n\t */\n\tpublic static void setCurrentTransactionReadOnly(boolean readOnly) {\n\t\tcurrentTransactionReadOnly.set(readOnly ? Boolean.TRUE : null);\n\t}\n\n\t/**\n\t * Return whether the current transaction is marked as read-only.\n\t * To be called by resource management code when preparing a newly\n\t * created resource (for example, a Hibernate Session).\n\t * <p>Note that transaction synchronizations receive the read-only flag\n\t * as argument for the {@code beforeCommit} callback, to be able\n\t * to suppress change detection on commit. The present method is meant\n\t * to be used for earlier read-only checks, for example to set the\n\t * flush mode of a Hibernate Session to \"FlushMode.MANUAL\" upfront.\n\t * @see org.springframework.transaction.TransactionDefinition#isReadOnly()\n\t * @see TransactionSynchronization#beforeCommit(boolean)\n\t */\n\tpublic static boolean isCurrentTransactionReadOnly() {\n\t\treturn (currentTransactionReadOnly.get() != null);\n\t}\n\n\t/**\n\t * Expose an isolation level for the current transaction.\n\t * Called by the transaction manager on transaction begin and on cleanup.\n\t * @param isolationLevel the isolation level to expose, according to the\n\t * JDBC Connection constants (equivalent to the corresponding Spring\n\t * TransactionDefinition constants), or {@code null} to reset it\n\t * @see java.sql.Connection#TRANSACTION_READ_UNCOMMITTED\n\t * @see java.sql.Connection#TRANSACTION_READ_COMMITTED\n\t * @see java.sql.Connection#TRANSACTION_REPEATABLE_READ\n\t * @see java.sql.Connection#TRANSACTION_SERIALIZABLE\n\t * @see org.springframework.transaction.TransactionDefinition#ISOLATION_READ_UNCOMMITTED\n\t * @see org.springframework.transaction.TransactionDefinition#ISOLATION_READ_COMMITTED\n\t * @see org.springframework.transaction.TransactionDefinition#ISOLATION_REPEATABLE_READ\n\t * @see org.springframework.transaction.TransactionDefinition#ISOLATION_SERIALIZABLE\n\t * @see org.springframework.transaction.TransactionDefinition#getIsolationLevel()\n\t */\n\tpublic static void setCurrentTransactionIsolationLevel(@Nullable Integer isolationLevel) {\n\t\tcurrentTransactionIsolationLevel.set(isolationLevel);\n\t}\n\n\t/**\n\t * Return the isolation level for the current transaction, if any.\n\t * To be called by resource management code when preparing a newly\n\t * created resource (for example, a JDBC Connection).\n\t * @return the currently exposed isolation level, according to the\n\t * JDBC Connection constants (equivalent to the corresponding Spring\n\t * TransactionDefinition constants), or {@code null} if none\n\t * @see java.sql.Connection#TRANSACTION_READ_UNCOMMITTED\n\t * @see java.sql.Connection#TRANSACTION_READ_COMMITTED\n\t * @see java.sql.Connection#TRANSACTION_REPEATABLE_READ\n\t * @see java.sql.Connection#TRANSACTION_SERIALIZABLE\n\t * @see org.springframework.transaction.TransactionDefinition#ISOLATION_READ_UNCOMMITTED\n\t * @see org.springframework.transaction.TransactionDefinition#ISOLATION_READ_COMMITTED\n\t * @see org.springframework.transaction.TransactionDefinition#ISOLATION_REPEATABLE_READ\n\t * @see org.springframework.transaction.TransactionDefinition#ISOLATION_SERIALIZABLE\n\t * @see org.springframework.transaction.TransactionDefinition#getIsolationLevel()\n\t */\n\t@Nullable\n\tpublic static Integer getCurrentTransactionIsolationLevel() {\n\t\treturn currentTransactionIsolationLevel.get();\n\t}\n\n\t/**\n\t * Expose whether there currently is an actual transaction active.\n\t * Called by the transaction manager on transaction begin and on cleanup.\n\t * @param active {@code true} to mark the current thread as being associated\n\t * with an actual transaction; {@code false} to reset that marker\n\t */\n\tpublic static void setActualTransactionActive(boolean active) {\n\t\tactualTransactionActive.set(active ? Boolean.TRUE : null);\n\t}\n\n\t/**\n\t * Return whether there currently is an actual transaction active.\n\t * This indicates whether the current thread is associated with an actual\n\t * transaction rather than just with active transaction synchronization.\n\t * <p>To be called by resource management code that wants to discriminate\n\t * between active transaction synchronization (with or without backing\n\t * resource transaction; also on PROPAGATION_SUPPORTS) and an actual\n\t * transaction being active (with backing resource transaction;\n\t * on PROPAGATION_REQUIRED, PROPAGATION_REQUIRES_NEW, etc).\n\t * @see #isSynchronizationActive()\n\t */\n\tpublic static boolean isActualTransactionActive() {\n\t\treturn (actualTransactionActive.get() != null);\n\t}\n\n\n\t/**\n\t * Clear the entire transaction synchronization state for the current thread:\n\t * registered synchronizations as well as the various transaction characteristics.\n\t * @see #clearSynchronization()\n\t * @see #setCurrentTransactionName\n\t * @see #setCurrentTransactionReadOnly\n\t * @see #setCurrentTransactionIsolationLevel\n\t * @see #setActualTransactionActive\n\t */\n\tpublic static void clear() {\n\t\tsynchronizations.remove();\n\t\tcurrentTransactionName.remove();\n\t\tcurrentTransactionReadOnly.remove();\n\t\tcurrentTransactionIsolationLevel.remove();\n\t\tactualTransactionActive.remove();\n\t}\n\n}"
  },
  "org.springframework.transaction.support.TransactionSynchronizationManager#bindResource(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Bind the given resource for the given key to the current thread.\n\t * @param key the key to bind the value to (usually the resource factory)\n\t * @param value the value to bind (usually the active resource object)\n\t * @throws IllegalStateException if there is already a value bound to the thread\n\t * @see ResourceTransactionManager#getResourceFactory()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "void",
    "signature": "public void bindResource(Object key, Object value)",
    "source_code": "\tpublic static void bindResource(Object key, Object value) throws IllegalStateException {\n\t\tObject actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);\n\t\tAssert.notNull(value, \"Value must not be null\");\n\t\tMap<Object, Object> map = resources.get();\n\t\t// set ThreadLocal Map if none found\n\t\tif (map == null) {\n\t\t\tmap = new HashMap<>();\n\t\t\tresources.set(map);\n\t\t}\n\t\tObject oldValue = map.put(actualKey, value);\n\t\t// Transparently suppress a ResourceHolder that was marked as void...\n\t\tif (oldValue instanceof ResourceHolder resourceHolder && resourceHolder.isVoid()) {\n\t\t\toldValue = null;\n\t\t}\n\t\tif (oldValue != null) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Already value [\" + oldValue + \"] for key [\" + actualKey + \"] bound to thread\");\n\t\t}\n\t}"
  },
  "org.springframework.transaction.support.TransactionSynchronizationManager#clear()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Clear the entire transaction synchronization state for the current thread:\n\t * registered synchronizations as well as the various transaction characteristics.\n\t * @see #clearSynchronization()\n\t * @see #setCurrentTransactionName\n\t * @see #setCurrentTransactionReadOnly\n\t * @see #setCurrentTransactionIsolationLevel\n\t * @see #setActualTransactionActive\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 450
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\tpublic static void clear() {\n\t\tsynchronizations.remove();\n\t\tcurrentTransactionName.remove();\n\t\tcurrentTransactionReadOnly.remove();\n\t\tcurrentTransactionIsolationLevel.remove();\n\t\tactualTransactionActive.remove();\n\t}"
  },
  "org.springframework.transaction.support.TransactionSynchronizationManager#clearSynchronization()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Deactivate transaction synchronization for the current thread.\n\t * Called by the transaction manager on transaction cleanup.\n\t * @throws IllegalStateException if synchronization is not active\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 313
    },
    "return": "void",
    "signature": "public void clearSynchronization()",
    "source_code": "\tpublic static void clearSynchronization() throws IllegalStateException {\n\t\tif (!isSynchronizationActive()) {\n\t\t\tthrow new IllegalStateException(\"Cannot deactivate transaction synchronization - not active\");\n\t\t}\n\t\tsynchronizations.remove();\n\t}"
  },
  "org.springframework.transaction.support.TransactionSynchronizationManager#getCurrentTransactionIsolationLevel()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the isolation level for the current transaction, if any.\n\t * To be called by resource management code when preparing a newly\n\t * created resource (for example, a JDBC Connection).\n\t * @return the currently exposed isolation level, according to the\n\t * JDBC Connection constants (equivalent to the corresponding Spring\n\t * TransactionDefinition constants), or {@code null} if none\n\t * @see java.sql.Connection#TRANSACTION_READ_UNCOMMITTED\n\t * @see java.sql.Connection#TRANSACTION_READ_COMMITTED\n\t * @see java.sql.Connection#TRANSACTION_REPEATABLE_READ\n\t * @see java.sql.Connection#TRANSACTION_SERIALIZABLE\n\t * @see org.springframework.transaction.TransactionDefinition#ISOLATION_READ_UNCOMMITTED\n\t * @see org.springframework.transaction.TransactionDefinition#ISOLATION_READ_COMMITTED\n\t * @see org.springframework.transaction.TransactionDefinition#ISOLATION_REPEATABLE_READ\n\t * @see org.springframework.transaction.TransactionDefinition#ISOLATION_SERIALIZABLE\n\t * @see org.springframework.transaction.TransactionDefinition#getIsolationLevel()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 411
    },
    "return": "Integer",
    "signature": "public Integer getCurrentTransactionIsolationLevel()",
    "source_code": "\tpublic static Integer getCurrentTransactionIsolationLevel() {\n\t\treturn currentTransactionIsolationLevel.get();\n\t}"
  },
  "org.springframework.transaction.support.TransactionSynchronizationManager#getCurrentTransactionName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the name of the current transaction, or {@code null} if none set.\n\t * To be called by resource management code for optimizations per use case,\n\t * for example to optimize fetch strategies for specific named transactions.\n\t * @see org.springframework.transaction.TransactionDefinition#getName()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 342
    },
    "return": "String",
    "signature": "public String getCurrentTransactionName()",
    "source_code": "\tpublic static String getCurrentTransactionName() {\n\t\treturn currentTransactionName.get();\n\t}"
  },
  "org.springframework.transaction.support.TransactionSynchronizationManager#getResource(key)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve a resource for the given key that is bound to the current thread.\n\t * @param key the key to check (usually the resource factory)\n\t * @return a value bound to the current thread (usually the active\n\t * resource object), or {@code null} if none\n\t * @see ResourceTransactionManager#getResourceFactory()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "Object",
    "signature": "public Object getResource(Object key)",
    "source_code": "\tpublic static Object getResource(Object key) {\n\t\tObject actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);\n\t\treturn doGetResource(actualKey);\n\t}"
  },
  "org.springframework.transaction.support.TransactionSynchronizationManager#getResourceMap()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return all resources that are bound to the current thread.\n\t * <p>Mainly for debugging purposes. Resource managers should always invoke\n\t * {@code hasResource} for a specific resource key that they are interested in.\n\t * @return a Map with resource keys (usually the resource factory) and resource\n\t * values (usually the active resource object), or an empty Map if there are\n\t * currently no resources bound\n\t * @see #hasResource\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "Object>",
    "signature": "public Object> getResourceMap()",
    "source_code": "\tpublic static Map<Object, Object> getResourceMap() {\n\t\tMap<Object, Object> map = resources.get();\n\t\treturn (map != null ? Collections.unmodifiableMap(map) : Collections.emptyMap());\n\t}"
  },
  "org.springframework.transaction.support.TransactionSynchronizationManager#getSynchronizations()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return an unmodifiable snapshot list of all registered synchronizations\n\t * for the current thread.\n\t * @return unmodifiable List of TransactionSynchronization instances\n\t * @throws IllegalStateException if synchronization is not active\n\t * @see TransactionSynchronization\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 289
    },
    "return": "List<TransactionSynchronization>",
    "signature": "public List<TransactionSynchronization> getSynchronizations()",
    "source_code": "\tpublic static List<TransactionSynchronization> getSynchronizations() throws IllegalStateException {\n\t\tSet<TransactionSynchronization> synchs = synchronizations.get();\n\t\tif (synchs == null) {\n\t\t\tthrow new IllegalStateException(\"Transaction synchronization is not active\");\n\t\t}\n\t\t// Return unmodifiable snapshot, to avoid ConcurrentModificationExceptions\n\t\t// while iterating and invoking synchronization callbacks that in turn\n\t\t// might register further synchronizations.\n\t\tif (synchs.isEmpty()) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\telse {\n\t\t\t// Sort lazily here, not in registerSynchronization.\n\t\t\tList<TransactionSynchronization> sortedSynchs = new ArrayList<>(synchs);\n\t\t\tOrderComparator.sort(sortedSynchs);\n\t\t\treturn Collections.unmodifiableList(sortedSynchs);\n\t\t}\n\t}"
  },
  "org.springframework.transaction.support.TransactionSynchronizationManager#hasResource(key)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check if there is a resource for the given key bound to the current thread.\n\t * @param key the key to check (usually the resource factory)\n\t * @return if there is a value bound to the current thread\n\t * @see ResourceTransactionManager#getResourceFactory()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "boolean",
    "signature": "public boolean hasResource(Object key)",
    "source_code": "\tpublic static boolean hasResource(Object key) {\n\t\tObject actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);\n\t\tObject value = doGetResource(actualKey);\n\t\treturn (value != null);\n\t}"
  },
  "org.springframework.transaction.support.TransactionSynchronizationManager#initSynchronization()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Activate transaction synchronization for the current thread.\n\t * Called by a transaction manager on transaction begin.\n\t * @throws IllegalStateException if synchronization is already active\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "void",
    "signature": "public void initSynchronization()",
    "source_code": "\tpublic static void initSynchronization() throws IllegalStateException {\n\t\tif (isSynchronizationActive()) {\n\t\t\tthrow new IllegalStateException(\"Cannot activate transaction synchronization - already active\");\n\t\t}\n\t\tsynchronizations.set(new LinkedHashSet<>());\n\t}"
  },
  "org.springframework.transaction.support.TransactionSynchronizationManager#isActualTransactionActive()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether there currently is an actual transaction active.\n\t * This indicates whether the current thread is associated with an actual\n\t * transaction rather than just with active transaction synchronization.\n\t * <p>To be called by resource management code that wants to discriminate\n\t * between active transaction synchronization (with or without backing\n\t * resource transaction; also on PROPAGATION_SUPPORTS) and an actual\n\t * transaction being active (with backing resource transaction;\n\t * on PROPAGATION_REQUIRED, PROPAGATION_REQUIRES_NEW, etc).\n\t * @see #isSynchronizationActive()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 436
    },
    "return": "boolean",
    "signature": "public boolean isActualTransactionActive()",
    "source_code": "\tpublic static boolean isActualTransactionActive() {\n\t\treturn (actualTransactionActive.get() != null);\n\t}"
  },
  "org.springframework.transaction.support.TransactionSynchronizationManager#isCurrentTransactionReadOnly()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether the current transaction is marked as read-only.\n\t * To be called by resource management code when preparing a newly\n\t * created resource (for example, a Hibernate Session).\n\t * <p>Note that transaction synchronizations receive the read-only flag\n\t * as argument for the {@code beforeCommit} callback, to be able\n\t * to suppress change detection on commit. The present method is meant\n\t * to be used for earlier read-only checks, for example to set the\n\t * flush mode of a Hibernate Session to \"FlushMode.MANUAL\" upfront.\n\t * @see org.springframework.transaction.TransactionDefinition#isReadOnly()\n\t * @see TransactionSynchronization#beforeCommit(boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 369
    },
    "return": "boolean",
    "signature": "public boolean isCurrentTransactionReadOnly()",
    "source_code": "\tpublic static boolean isCurrentTransactionReadOnly() {\n\t\treturn (currentTransactionReadOnly.get() != null);\n\t}"
  },
  "org.springframework.transaction.support.TransactionSynchronizationManager#isSynchronizationActive()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return if transaction synchronization is active for the current thread.\n\t * Can be called before register to avoid unnecessary instance creation.\n\t * @see #registerSynchronization\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 245
    },
    "return": "boolean",
    "signature": "public boolean isSynchronizationActive()",
    "source_code": "\tpublic static boolean isSynchronizationActive() {\n\t\treturn (synchronizations.get() != null);\n\t}"
  },
  "org.springframework.transaction.support.TransactionSynchronizationManager#registerSynchronization(synchronization)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a new transaction synchronization for the current thread.\n\t * Typically called by resource management code.\n\t * <p>Note that synchronizations can implement the\n\t * {@link org.springframework.core.Ordered} interface.\n\t * They will be executed in an order according to their order value (if any).\n\t * @param synchronization the synchronization object to register\n\t * @throws IllegalStateException if transaction synchronization is not active\n\t * @see org.springframework.core.Ordered\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "synchronization"
    ],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "void",
    "signature": "public void registerSynchronization(TransactionSynchronization synchronization)",
    "source_code": "\tpublic static void registerSynchronization(TransactionSynchronization synchronization)"
  },
  "org.springframework.transaction.support.TransactionSynchronizationManager#setActualTransactionActive(active)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Expose whether there currently is an actual transaction active.\n\t * Called by the transaction manager on transaction begin and on cleanup.\n\t * @param active {@code true} to mark the current thread as being associated\n\t * with an actual transaction; {@code false} to reset that marker\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "active"
    ],
    "position": {
      "column": 1,
      "line": 421
    },
    "return": "void",
    "signature": "public void setActualTransactionActive(boolean active)",
    "source_code": "\tpublic static void setActualTransactionActive(boolean active) {\n\t\tactualTransactionActive.set(active ? Boolean.TRUE : null);\n\t}"
  },
  "org.springframework.transaction.support.TransactionSynchronizationManager#setCurrentTransactionIsolationLevel(isolationLevel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Expose an isolation level for the current transaction.\n\t * Called by the transaction manager on transaction begin and on cleanup.\n\t * @param isolationLevel the isolation level to expose, according to the\n\t * JDBC Connection constants (equivalent to the corresponding Spring\n\t * TransactionDefinition constants), or {@code null} to reset it\n\t * @see java.sql.Connection#TRANSACTION_READ_UNCOMMITTED\n\t * @see java.sql.Connection#TRANSACTION_READ_COMMITTED\n\t * @see java.sql.Connection#TRANSACTION_REPEATABLE_READ\n\t * @see java.sql.Connection#TRANSACTION_SERIALIZABLE\n\t * @see org.springframework.transaction.TransactionDefinition#ISOLATION_READ_UNCOMMITTED\n\t * @see org.springframework.transaction.TransactionDefinition#ISOLATION_READ_COMMITTED\n\t * @see org.springframework.transaction.TransactionDefinition#ISOLATION_REPEATABLE_READ\n\t * @see org.springframework.transaction.TransactionDefinition#ISOLATION_SERIALIZABLE\n\t * @see org.springframework.transaction.TransactionDefinition#getIsolationLevel()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "isolationLevel"
    ],
    "position": {
      "column": 1,
      "line": 389
    },
    "return": "void",
    "signature": "public void setCurrentTransactionIsolationLevel(@Nullable Integer isolationLevel)",
    "source_code": "\tpublic static void setCurrentTransactionIsolationLevel(@Nullable Integer isolationLevel) {\n\t\tcurrentTransactionIsolationLevel.set(isolationLevel);\n\t}"
  },
  "org.springframework.transaction.support.TransactionSynchronizationManager#setCurrentTransactionName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Expose the name of the current transaction, if any.\n\t * Called by the transaction manager on transaction begin and on cleanup.\n\t * @param name the name of the transaction, or {@code null} to reset it\n\t * @see org.springframework.transaction.TransactionDefinition#getName()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 331
    },
    "return": "void",
    "signature": "public void setCurrentTransactionName(@Nullable String name)",
    "source_code": "\tpublic static void setCurrentTransactionName(@Nullable String name) {\n\t\tcurrentTransactionName.set(name);\n\t}"
  },
  "org.springframework.transaction.support.TransactionSynchronizationManager#setCurrentTransactionReadOnly(readOnly)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Expose a read-only flag for the current transaction.\n\t * Called by the transaction manager on transaction begin and on cleanup.\n\t * @param readOnly {@code true} to mark the current transaction\n\t * as read-only; {@code false} to reset such a read-only marker\n\t * @see org.springframework.transaction.TransactionDefinition#isReadOnly()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "readOnly"
    ],
    "position": {
      "column": 1,
      "line": 353
    },
    "return": "void",
    "signature": "public void setCurrentTransactionReadOnly(boolean readOnly)",
    "source_code": "\tpublic static void setCurrentTransactionReadOnly(boolean readOnly) {\n\t\tcurrentTransactionReadOnly.set(readOnly ? Boolean.TRUE : null);\n\t}"
  },
  "org.springframework.transaction.support.TransactionSynchronizationManager#unbindResource(key)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Unbind a resource for the given key from the current thread.\n\t * @param key the key to unbind (usually the resource factory)\n\t * @return the previously bound value (usually the active resource object)\n\t * @throws IllegalStateException if there is no value bound to the thread\n\t * @see ResourceTransactionManager#getResourceFactory()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "Object",
    "signature": "public Object unbindResource(Object key)",
    "source_code": "\tpublic static Object unbindResource(Object key) throws IllegalStateException {\n\t\tObject actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);\n\t\tObject value = doUnbindResource(actualKey);\n\t\tif (value == null) {\n\t\t\tthrow new IllegalStateException(\"No value for key [\" + actualKey + \"] bound to thread\");\n\t\t}\n\t\treturn value;\n\t}"
  },
  "org.springframework.transaction.support.TransactionSynchronizationManager#unbindResourceIfPossible(key)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Unbind a resource for the given key from the current thread.\n\t * @param key the key to unbind (usually the resource factory)\n\t * @return the previously bound value, or {@code null} if none bound\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "Object",
    "signature": "public Object unbindResourceIfPossible(Object key)",
    "source_code": "\tpublic static Object unbindResourceIfPossible(Object key) {\n\t\tObject actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);\n\t\treturn doUnbindResource(actualKey);\n\t}"
  },
  "org.springframework.transaction.support.TransactionSynchronizationUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Utility methods for triggering specific {@link TransactionSynchronization}\n * callback methods on all currently registered synchronizations.\n *\n * @author Juergen Hoeller\n * @since 2.0\n * @see TransactionSynchronization\n * @see TransactionSynchronizationManager#getSynchronizations()\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class TransactionSynchronizationUtils",
    "source_code": "public abstract class TransactionSynchronizationUtils {\n\n\tprivate static final Log logger = LogFactory.getLog(TransactionSynchronizationUtils.class);\n\n\tprivate static final boolean aopAvailable = ClassUtils.isPresent(\n\t\t\t\"org.springframework.aop.scope.ScopedObject\", TransactionSynchronizationUtils.class.getClassLoader());\n\n\n\t/**\n\t * Check whether the given resource transaction manager refers to the given\n\t * (underlying) resource factory.\n\t * @see ResourceTransactionManager#getResourceFactory()\n\t * @see InfrastructureProxy#getWrappedObject()\n\t */\n\tpublic static boolean sameResourceFactory(ResourceTransactionManager tm, Object resourceFactory) {\n\t\treturn unwrapResourceIfNecessary(tm.getResourceFactory()).equals(unwrapResourceIfNecessary(resourceFactory));\n\t}\n\n\t/**\n\t * Unwrap the given resource handle if necessary; otherwise return\n\t * the given handle as-is.\n\t * @since 5.3.4\n\t * @see InfrastructureProxy#getWrappedObject()\n\t */\n\tpublic static Object unwrapResourceIfNecessary(Object resource) {\n\t\tAssert.notNull(resource, \"Resource must not be null\");\n\t\tObject resourceRef = resource;\n\t\t// unwrap infrastructure proxy\n\t\tif (resourceRef instanceof InfrastructureProxy infrastructureProxy) {\n\t\t\tresourceRef = infrastructureProxy.getWrappedObject();\n\t\t}\n\t\tif (aopAvailable) {\n\t\t\t// now unwrap scoped proxy\n\t\t\tresourceRef = ScopedProxyUnwrapper.unwrapIfNecessary(resourceRef);\n\t\t}\n\t\treturn resourceRef;\n\t}\n\n\n\t/**\n\t * Trigger {@code flush} callbacks on all currently registered synchronizations.\n\t * @throws RuntimeException if thrown by a {@code flush} callback\n\t * @see TransactionSynchronization#flush()\n\t */\n\tpublic static void triggerFlush() {\n\t\tfor (TransactionSynchronization synchronization : TransactionSynchronizationManager.getSynchronizations()) {\n\t\t\tsynchronization.flush();\n\t\t}\n\t}\n\n\t/**\n\t * Trigger {@code beforeCommit} callbacks on all currently registered synchronizations.\n\t * @param readOnly whether the transaction is defined as read-only transaction\n\t * @throws RuntimeException if thrown by a {@code beforeCommit} callback\n\t * @see TransactionSynchronization#beforeCommit(boolean)\n\t */\n\tpublic static void triggerBeforeCommit(boolean readOnly) {\n\t\tfor (TransactionSynchronization synchronization : TransactionSynchronizationManager.getSynchronizations()) {\n\t\t\tsynchronization.beforeCommit(readOnly);\n\t\t}\n\t}\n\n\t/**\n\t * Trigger {@code beforeCompletion} callbacks on all currently registered synchronizations.\n\t * @see TransactionSynchronization#beforeCompletion()\n\t */\n\tpublic static void triggerBeforeCompletion() {\n\t\tfor (TransactionSynchronization synchronization : TransactionSynchronizationManager.getSynchronizations()) {\n\t\t\ttry {\n\t\t\t\tsynchronization.beforeCompletion();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tlogger.debug(\"TransactionSynchronization.beforeCompletion threw exception\", ex);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Trigger {@code afterCommit} callbacks on all currently registered synchronizations.\n\t * @throws RuntimeException if thrown by a {@code afterCommit} callback\n\t * @see TransactionSynchronizationManager#getSynchronizations()\n\t * @see TransactionSynchronization#afterCommit()\n\t */\n\tpublic static void triggerAfterCommit() {\n\t\tinvokeAfterCommit(TransactionSynchronizationManager.getSynchronizations());\n\t}\n\n\t/**\n\t * Actually invoke the {@code afterCommit} methods of the\n\t * given Spring TransactionSynchronization objects.\n\t * @param synchronizations a List of TransactionSynchronization objects\n\t * @see TransactionSynchronization#afterCommit()\n\t */\n\tpublic static void invokeAfterCommit(@Nullable List<TransactionSynchronization> synchronizations) {\n\t\tif (synchronizations != null) {\n\t\t\tfor (TransactionSynchronization synchronization : synchronizations) {\n\t\t\t\tsynchronization.afterCommit();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Trigger {@code afterCompletion} callbacks on all currently registered synchronizations.\n\t * @param completionStatus the completion status according to the\n\t * constants in the TransactionSynchronization interface\n\t * @see TransactionSynchronizationManager#getSynchronizations()\n\t * @see TransactionSynchronization#afterCompletion(int)\n\t * @see TransactionSynchronization#STATUS_COMMITTED\n\t * @see TransactionSynchronization#STATUS_ROLLED_BACK\n\t * @see TransactionSynchronization#STATUS_UNKNOWN\n\t */\n\tpublic static void triggerAfterCompletion(int completionStatus) {\n\t\tList<TransactionSynchronization> synchronizations = TransactionSynchronizationManager.getSynchronizations();\n\t\tinvokeAfterCompletion(synchronizations, completionStatus);\n\t}\n\n\t/**\n\t * Actually invoke the {@code afterCompletion} methods of the\n\t * given Spring TransactionSynchronization objects.\n\t * @param synchronizations a List of TransactionSynchronization objects\n\t * @param completionStatus the completion status according to the\n\t * constants in the TransactionSynchronization interface\n\t * @see TransactionSynchronization#afterCompletion(int)\n\t * @see TransactionSynchronization#STATUS_COMMITTED\n\t * @see TransactionSynchronization#STATUS_ROLLED_BACK\n\t * @see TransactionSynchronization#STATUS_UNKNOWN\n\t */\n\tpublic static void invokeAfterCompletion(@Nullable List<TransactionSynchronization> synchronizations,\n\t\t\tint completionStatus) {\n\n\t\tif (synchronizations != null) {\n\t\t\tfor (TransactionSynchronization synchronization : synchronizations) {\n\t\t\t\ttry {\n\t\t\t\t\tsynchronization.afterCompletion(completionStatus);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tlogger.debug(\"TransactionSynchronization.afterCompletion threw exception\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Inner class to avoid hard-coded dependency on AOP module.\n\t */\n\tprivate static class ScopedProxyUnwrapper {\n\n\t\tpublic static Object unwrapIfNecessary(Object resource) {\n\t\t\tif (resource instanceof ScopedObject scopedObject) {\n\t\t\t\treturn scopedObject.getTargetObject();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn resource;\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.transaction.support.TransactionSynchronizationUtils#invokeAfterCommit(synchronizations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Actually invoke the {@code afterCommit} methods of the\n\t * given Spring TransactionSynchronization objects.\n\t * @param synchronizations a List of TransactionSynchronization objects\n\t * @see TransactionSynchronization#afterCommit()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "synchronizations"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "void",
    "signature": "public void invokeAfterCommit(@Nullable List<TransactionSynchronization> synchronizations)",
    "source_code": "\tpublic static void invokeAfterCommit(@Nullable List<TransactionSynchronization> synchronizations) {\n\t\tif (synchronizations != null) {\n\t\t\tfor (TransactionSynchronization synchronization : synchronizations) {\n\t\t\t\tsynchronization.afterCommit();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.transaction.support.TransactionSynchronizationUtils#invokeAfterCompletion(synchronizations,completionStatus)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Actually invoke the {@code afterCompletion} methods of the\n\t * given Spring TransactionSynchronization objects.\n\t * @param synchronizations a List of TransactionSynchronization objects\n\t * @param completionStatus the completion status according to the\n\t * constants in the TransactionSynchronization interface\n\t * @see TransactionSynchronization#afterCompletion(int)\n\t * @see TransactionSynchronization#STATUS_COMMITTED\n\t * @see TransactionSynchronization#STATUS_ROLLED_BACK\n\t * @see TransactionSynchronization#STATUS_UNKNOWN\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "synchronizations",
      "completionStatus"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "void",
    "signature": "public void invokeAfterCompletion(@Nullable List<TransactionSynchronization> synchronizations,\n\t\t\tint completionStatus)",
    "source_code": "\tpublic static void invokeAfterCompletion(@Nullable List<TransactionSynchronization> synchronizations,"
  },
  "org.springframework.transaction.support.TransactionSynchronizationUtils#sameResourceFactory(tm,resourceFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given resource transaction manager refers to the given\n\t * (underlying) resource factory.\n\t * @see ResourceTransactionManager#getResourceFactory()\n\t * @see InfrastructureProxy#getWrappedObject()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "tm",
      "resourceFactory"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "return": "boolean",
    "signature": "public boolean sameResourceFactory(ResourceTransactionManager tm, Object resourceFactory)",
    "source_code": "\tpublic static boolean sameResourceFactory(ResourceTransactionManager tm, Object resourceFactory) {\n\t\treturn unwrapResourceIfNecessary(tm.getResourceFactory()).equals(unwrapResourceIfNecessary(resourceFactory));\n\t}"
  },
  "org.springframework.transaction.support.TransactionSynchronizationUtils#triggerAfterCommit()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Trigger {@code afterCommit} callbacks on all currently registered synchronizations.\n\t * @throws RuntimeException if thrown by a {@code afterCommit} callback\n\t * @see TransactionSynchronizationManager#getSynchronizations()\n\t * @see TransactionSynchronization#afterCommit()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "void",
    "signature": "public void triggerAfterCommit()",
    "source_code": "\tpublic static void triggerAfterCommit() {\n\t\tinvokeAfterCommit(TransactionSynchronizationManager.getSynchronizations());\n\t}"
  },
  "org.springframework.transaction.support.TransactionSynchronizationUtils#triggerAfterCompletion(completionStatus)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Trigger {@code afterCompletion} callbacks on all currently registered synchronizations.\n\t * @param completionStatus the completion status according to the\n\t * constants in the TransactionSynchronization interface\n\t * @see TransactionSynchronizationManager#getSynchronizations()\n\t * @see TransactionSynchronization#afterCompletion(int)\n\t * @see TransactionSynchronization#STATUS_COMMITTED\n\t * @see TransactionSynchronization#STATUS_ROLLED_BACK\n\t * @see TransactionSynchronization#STATUS_UNKNOWN\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "completionStatus"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "void",
    "signature": "public void triggerAfterCompletion(int completionStatus)",
    "source_code": "\tpublic static void triggerAfterCompletion(int completionStatus) {\n\t\tList<TransactionSynchronization> synchronizations = TransactionSynchronizationManager.getSynchronizations();\n\t\tinvokeAfterCompletion(synchronizations, completionStatus);\n\t}"
  },
  "org.springframework.transaction.support.TransactionSynchronizationUtils#triggerBeforeCommit(readOnly)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Trigger {@code beforeCommit} callbacks on all currently registered synchronizations.\n\t * @param readOnly whether the transaction is defined as read-only transaction\n\t * @throws RuntimeException if thrown by a {@code beforeCommit} callback\n\t * @see TransactionSynchronization#beforeCommit(boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "readOnly"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "void",
    "signature": "public void triggerBeforeCommit(boolean readOnly)",
    "source_code": "\tpublic static void triggerBeforeCommit(boolean readOnly) {\n\t\tfor (TransactionSynchronization synchronization : TransactionSynchronizationManager.getSynchronizations()) {\n\t\t\tsynchronization.beforeCommit(readOnly);\n\t\t}\n\t}"
  },
  "org.springframework.transaction.support.TransactionSynchronizationUtils#triggerBeforeCompletion()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Trigger {@code beforeCompletion} callbacks on all currently registered synchronizations.\n\t * @see TransactionSynchronization#beforeCompletion()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "void",
    "signature": "public void triggerBeforeCompletion()",
    "source_code": "\tpublic static void triggerBeforeCompletion() {\n\t\tfor (TransactionSynchronization synchronization : TransactionSynchronizationManager.getSynchronizations()) {\n\t\t\ttry {\n\t\t\t\tsynchronization.beforeCompletion();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tlogger.debug(\"TransactionSynchronization.beforeCompletion threw exception\", ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.transaction.support.TransactionSynchronizationUtils#triggerFlush()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Trigger {@code flush} callbacks on all currently registered synchronizations.\n\t * @throws RuntimeException if thrown by a {@code flush} callback\n\t * @see TransactionSynchronization#flush()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void triggerFlush()",
    "source_code": "\tpublic static void triggerFlush() {\n\t\tfor (TransactionSynchronization synchronization : TransactionSynchronizationManager.getSynchronizations()) {\n\t\t\tsynchronization.flush();\n\t\t}\n\t}"
  },
  "org.springframework.transaction.support.TransactionSynchronizationUtils#unwrapIfNecessary(resource)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resource"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "Object",
    "signature": "public Object unwrapIfNecessary(Object resource)",
    "source_code": "\t\tpublic static Object unwrapIfNecessary(Object resource) {\n\t\t\tif (resource instanceof ScopedObject scopedObject) {\n\t\t\t\treturn scopedObject.getTargetObject();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn resource;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.transaction.support.TransactionSynchronizationUtils#unwrapResourceIfNecessary(resource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Unwrap the given resource handle if necessary; otherwise return\n\t * the given handle as-is.\n\t * @since 5.3.4\n\t * @see InfrastructureProxy#getWrappedObject()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resource"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "Object",
    "signature": "public Object unwrapResourceIfNecessary(Object resource)",
    "source_code": "\tpublic static Object unwrapResourceIfNecessary(Object resource) {\n\t\tAssert.notNull(resource, \"Resource must not be null\");\n\t\tObject resourceRef = resource;\n\t\t// unwrap infrastructure proxy\n\t\tif (resourceRef instanceof InfrastructureProxy infrastructureProxy) {\n\t\t\tresourceRef = infrastructureProxy.getWrappedObject();\n\t\t}\n\t\tif (aopAvailable) {\n\t\t\t// now unwrap scoped proxy\n\t\t\tresourceRef = ScopedProxyUnwrapper.unwrapIfNecessary(resourceRef);\n\t\t}\n\t\treturn resourceRef;\n\t}"
  },
  "org.springframework.transaction.support.TransactionTemplate": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Template class that simplifies programmatic transaction demarcation and\n * transaction exception handling.\n *\n * <p>The central method is {@link #execute}, supporting transactional code that\n * implements the {@link TransactionCallback} interface. This template handles\n * the transaction lifecycle and possible exceptions such that neither the\n * TransactionCallback implementation nor the calling code needs to explicitly\n * handle transactions.\n *\n * <p>Typical usage: Allows for writing low-level data access objects that use\n * resources such as JDBC DataSources but are not transaction-aware themselves.\n * Instead, they can implicitly participate in transactions handled by higher-level\n * application services utilizing this class, making calls to the low-level\n * services via an inner-class callback object.\n *\n * <p>Can be used within a service implementation via direct instantiation with\n * a transaction manager reference, or get prepared in an application context\n * and passed to services as bean reference. Note: The transaction manager should\n * always be configured as bean in the application context: in the first case given\n * to the service directly, in the second case given to the prepared template.\n *\n * <p>Supports setting the propagation behavior and the isolation level by name,\n * for convenient configuration in context definitions.\n *\n * @author Juergen Hoeller\n * @since 17.03.2003\n * @see #execute\n * @see #setTransactionManager\n * @see org.springframework.transaction.PlatformTransactionManager\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "signature": "public class TransactionTemplate",
    "source_code": "public class TransactionTemplate extends DefaultTransactionDefinition"
  },
  "org.springframework.transaction.support.TransactionTemplate#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tif (this.transactionManager == null) {\n\t\t\tthrow new IllegalArgumentException(\"Property 'transactionManager' is required\");\n\t\t}\n\t}"
  },
  "org.springframework.transaction.support.TransactionTemplate#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (super.equals(other) && (!(other instanceof TransactionTemplate template) ||\n\t\t\t\tgetTransactionManager() == template.getTransactionManager())));\n\t}"
  },
  "org.springframework.transaction.support.TransactionTemplate#execute(action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "action"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "T",
    "signature": "public T execute(TransactionCallback<T> action)",
    "source_code": "\tpublic <T> T execute(TransactionCallback<T> action) throws TransactionException {\n\t\tAssert.state(this.transactionManager != null, \"No PlatformTransactionManager set\");\n\n\t\tif (this.transactionManager instanceof CallbackPreferringPlatformTransactionManager cpptm) {\n\t\t\treturn cpptm.execute(this, action);\n\t\t}\n\t\telse {\n\t\t\tTransactionStatus status = this.transactionManager.getTransaction(this);\n\t\t\tT result;\n\t\t\ttry {\n\t\t\t\tresult = action.doInTransaction(status);\n\t\t\t}\n\t\t\tcatch (RuntimeException | Error ex) {\n\t\t\t\t// Transactional code threw application exception -> rollback\n\t\t\t\trollbackOnException(status, ex);\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// Transactional code threw unexpected exception -> rollback\n\t\t\t\trollbackOnException(status, ex);\n\t\t\t\tthrow new UndeclaredThrowableException(ex, \"TransactionCallback threw undeclared checked exception\");\n\t\t\t}\n\t\t\tthis.transactionManager.commit(status);\n\t\t\treturn result;\n\t\t}\n\t}"
  },
  "org.springframework.transaction.support.TransactionTemplate#getTransactionManager()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the transaction management strategy to be used.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "PlatformTransactionManager",
    "signature": "public PlatformTransactionManager getTransactionManager()",
    "source_code": "\tpublic PlatformTransactionManager getTransactionManager() {\n\t\treturn this.transactionManager;\n\t}"
  },
  "org.springframework.transaction.support.TransactionTemplate#setTransactionManager(transactionManager)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the transaction management strategy to be used.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "transactionManager"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "void",
    "signature": "public void setTransactionManager(@Nullable PlatformTransactionManager transactionManager)",
    "source_code": "\tpublic void setTransactionManager(@Nullable PlatformTransactionManager transactionManager) {\n\t\tthis.transactionManager = transactionManager;\n\t}"
  },
  "org.springframework.transaction.support.logger": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Logger available to subclasses. */",
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.validation.BindingResultUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Convenience methods for looking up BindingResults in a model Map.\n *\n * @author Juergen Hoeller\n * @since 2.0\n * @see BindingResult#MODEL_KEY_PREFIX\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 31
    },
    "signature": "public class BindingResultUtils",
    "source_code": "public abstract class BindingResultUtils {\n\n\t/**\n\t * Find the BindingResult for the given name in the given model.\n\t * @param model the model to search\n\t * @param name the name of the target object to find a BindingResult for\n\t * @return the BindingResult, or {@code null} if none found\n\t * @throws IllegalStateException if the attribute found is not of type BindingResult\n\t */\n\t@Nullable\n\tpublic static BindingResult getBindingResult(Map<?, ?> model, String name) {\n\t\tAssert.notNull(model, \"Model map must not be null\");\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tObject attr = model.get(BindingResult.MODEL_KEY_PREFIX + name);\n\t\tif (attr == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (attr instanceof BindingResult bindingResult) {\n\t\t\treturn bindingResult;\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\"BindingResult attribute is not of type BindingResult: \" + attr);\n\t\t}\n\t}\n\n\t/**\n\t * Find a required BindingResult for the given name in the given model.\n\t * @param model the model to search\n\t * @param name the name of the target object to find a BindingResult for\n\t * @return the BindingResult (never {@code null})\n\t * @throws IllegalStateException if no BindingResult found\n\t */\n\tpublic static BindingResult getRequiredBindingResult(Map<?, ?> model, String name) {\n\t\tBindingResult bindingResult = getBindingResult(model, name);\n\t\tif (bindingResult == null) {\n\t\t\tthrow new IllegalStateException(\"No BindingResult attribute found for name '\" + name +\n\t\t\t\t\t\"'- have you exposed the correct model?\");\n\t\t}\n\t\treturn bindingResult;\n\t}\n\n}"
  },
  "org.springframework.validation.BindingResultUtils#getBindingResult(Map<?,model,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the BindingResult for the given name in the given model.\n\t * @param model the model to search\n\t * @param name the name of the target object to find a BindingResult for\n\t * @return the BindingResult, or {@code null} if none found\n\t * @throws IllegalStateException if the attribute found is not of type BindingResult\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "model",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "return": "BindingResult",
    "signature": "public BindingResult getBindingResult(Map<?, ?> model, String name)",
    "source_code": "\tpublic static BindingResult getBindingResult(Map<?, ?> model, String name) {\n\t\tAssert.notNull(model, \"Model map must not be null\");\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tObject attr = model.get(BindingResult.MODEL_KEY_PREFIX + name);\n\t\tif (attr == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (attr instanceof BindingResult bindingResult) {\n\t\t\treturn bindingResult;\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\"BindingResult attribute is not of type BindingResult: \" + attr);\n\t\t}\n\t}"
  },
  "org.springframework.validation.BindingResultUtils#getRequiredBindingResult(Map<?,model,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a required BindingResult for the given name in the given model.\n\t * @param model the model to search\n\t * @param name the name of the target object to find a BindingResult for\n\t * @return the BindingResult (never {@code null})\n\t * @throws IllegalStateException if no BindingResult found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "model",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "BindingResult",
    "signature": "public BindingResult getRequiredBindingResult(Map<?, ?> model, String name)",
    "source_code": "\tpublic static BindingResult getRequiredBindingResult(Map<?, ?> model, String name) {\n\t\tBindingResult bindingResult = getBindingResult(model, name);\n\t\tif (bindingResult == null) {\n\t\t\tthrow new IllegalStateException(\"No BindingResult attribute found for name '\" + name +\n\t\t\t\t\t\"'- have you exposed the correct model?\");\n\t\t}\n\t\treturn bindingResult;\n\t}"
  },
  "org.springframework.validation.ObjectError": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Encapsulates an object error, that is, a global reason for rejecting\n * an object.\n *\n * <p>See the {@link DefaultMessageCodesResolver} javadoc for details on\n * how a message code list is built for an {@code ObjectError}.\n *\n * @author Juergen Hoeller\n * @since 10.03.2003\n * @see FieldError\n * @see DefaultMessageCodesResolver\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 36
    },
    "signature": "public class ObjectError",
    "source_code": "public class ObjectError extends DefaultMessageSourceResolvable {\n\n\tprivate final String objectName;\n\n\t@Nullable\n\tprivate transient Object source;\n\n\n\t/**\n\t * Create a new instance of the ObjectError class.\n\t * @param objectName the name of the affected object\n\t * @param defaultMessage the default message to be used to resolve this message\n\t */\n\tpublic ObjectError(String objectName, String defaultMessage) {\n\t\tthis(objectName, null, null, defaultMessage);\n\t}\n\n\t/**\n\t * Create a new instance of the ObjectError class.\n\t * @param objectName the name of the affected object\n\t * @param codes the codes to be used to resolve this message\n\t * @param arguments\tthe array of arguments to be used to resolve this message\n\t * @param defaultMessage the default message to be used to resolve this message\n\t */\n\tpublic ObjectError(\n\t\t\tString objectName, @Nullable String[] codes, @Nullable Object[] arguments, @Nullable String defaultMessage) {\n\n\t\tsuper(codes, arguments, defaultMessage);\n\t\tAssert.notNull(objectName, \"Object name must not be null\");\n\t\tthis.objectName = objectName;\n\t}\n\n\n\t/**\n\t * Return the name of the affected object.\n\t */\n\tpublic String getObjectName() {\n\t\treturn this.objectName;\n\t}\n\n\t/**\n\t * Preserve the source behind this error: possibly an {@link Exception}\n\t * (typically {@link org.springframework.beans.PropertyAccessException})\n\t * or a Bean Validation {@link jakarta.validation.ConstraintViolation}.\n\t * <p>Note that any such source object is being stored as transient:\n\t * that is, it won't be part of a serialized error representation.\n\t * @param source the source object\n\t * @since 5.0.4\n\t */\n\tpublic void wrap(Object source) {\n\t\tif (this.source != null) {\n\t\t\tthrow new IllegalStateException(\"Already wrapping \" + this.source);\n\t\t}\n\t\tthis.source = source;\n\t}\n\n\t/**\n\t * Unwrap the source behind this error: possibly an {@link Exception}\n\t * (typically {@link org.springframework.beans.PropertyAccessException})\n\t * or a Bean Validation {@link jakarta.validation.ConstraintViolation}.\n\t * <p>The cause of the outermost exception will be introspected as well,\n\t * e.g. the underlying conversion exception or exception thrown from a setter\n\t * (instead of having to unwrap the {@code PropertyAccessException} in turn).\n\t * @return the source object of the given type\n\t * @throws IllegalArgumentException if no such source object is available\n\t * (i.e. none specified or not available anymore after deserialization)\n\t * @since 5.0.4\n\t */\n\tpublic <T> T unwrap(Class<T> sourceType) {\n\t\tif (sourceType.isInstance(this.source)) {\n\t\t\treturn sourceType.cast(this.source);\n\t\t}\n\t\telse if (this.source instanceof Throwable throwable) {\n\t\t\tThrowable cause = throwable.getCause();\n\t\t\tif (sourceType.isInstance(cause)) {\n\t\t\t\treturn sourceType.cast(cause);\n\t\t\t}\n\t\t}\n\t\tthrow new IllegalArgumentException(\"No source object of the given type available: \" + sourceType);\n\t}\n\n\t/**\n\t * Check the source behind this error: possibly an {@link Exception}\n\t * (typically {@link org.springframework.beans.PropertyAccessException})\n\t * or a Bean Validation {@link jakarta.validation.ConstraintViolation}.\n\t * <p>The cause of the outermost exception will be introspected as well,\n\t * e.g. the underlying conversion exception or exception thrown from a setter\n\t * (instead of having to unwrap the {@code PropertyAccessException} in turn).\n\t * @return whether this error has been caused by a source object of the given type\n\t * @since 5.0.4\n\t */\n\tpublic boolean contains(Class<?> sourceType) {\n\t\treturn (sourceType.isInstance(this.source) ||\n\t\t\t\t(this.source instanceof Throwable throwable && sourceType.isInstance(throwable.getCause())));\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (other == null || other.getClass() != getClass() || !super.equals(other)) {\n\t\t\treturn false;\n\t\t}\n\t\tObjectError otherError = (ObjectError) other;\n\t\treturn getObjectName().equals(otherError.getObjectName());\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn (29 * super.hashCode() + getObjectName().hashCode());\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Error in object '\" + this.objectName + \"': \" + resolvableToString();\n\t}\n\n}"
  },
  "org.springframework.validation.ObjectError#contains(sourceType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check the source behind this error: possibly an {@link Exception}\n\t * (typically {@link org.springframework.beans.PropertyAccessException})\n\t * or a Bean Validation {@link jakarta.validation.ConstraintViolation}.\n\t * <p>The cause of the outermost exception will be introspected as well,\n\t * e.g. the underlying conversion exception or exception thrown from a setter\n\t * (instead of having to unwrap the {@code PropertyAccessException} in turn).\n\t * @return whether this error has been caused by a source object of the given type\n\t * @since 5.0.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "boolean",
    "signature": "public boolean contains(Class<?> sourceType)",
    "source_code": "\tpublic boolean contains(Class<?> sourceType) {\n\t\treturn (sourceType.isInstance(this.source) ||\n\t\t\t\t(this.source instanceof Throwable throwable && sourceType.isInstance(throwable.getCause())));\n\t}"
  },
  "org.springframework.validation.ObjectError#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (other == null || other.getClass() != getClass() || !super.equals(other)) {\n\t\t\treturn false;\n\t\t}\n\t\tObjectError otherError = (ObjectError) other;\n\t\treturn getObjectName().equals(otherError.getObjectName());\n\t}"
  },
  "org.springframework.validation.ObjectError#getObjectName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the name of the affected object.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "String",
    "signature": "public String getObjectName()",
    "source_code": "\tpublic String getObjectName() {\n\t\treturn this.objectName;\n\t}"
  },
  "org.springframework.validation.ObjectError#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn (29 * super.hashCode() + getObjectName().hashCode());\n\t}"
  },
  "org.springframework.validation.ObjectError#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn \"Error in object '\" + this.objectName + \"': \" + resolvableToString();\n\t}"
  },
  "org.springframework.validation.ObjectError#unwrap(sourceType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Unwrap the source behind this error: possibly an {@link Exception}\n\t * (typically {@link org.springframework.beans.PropertyAccessException})\n\t * or a Bean Validation {@link jakarta.validation.ConstraintViolation}.\n\t * <p>The cause of the outermost exception will be introspected as well,\n\t * e.g. the underlying conversion exception or exception thrown from a setter\n\t * (instead of having to unwrap the {@code PropertyAccessException} in turn).\n\t * @return the source object of the given type\n\t * @throws IllegalArgumentException if no such source object is available\n\t * (i.e. none specified or not available anymore after deserialization)\n\t * @since 5.0.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "T",
    "signature": "public T unwrap(Class<T> sourceType)",
    "source_code": "\tpublic <T> T unwrap(Class<T> sourceType) {\n\t\tif (sourceType.isInstance(this.source)) {\n\t\t\treturn sourceType.cast(this.source);\n\t\t}\n\t\telse if (this.source instanceof Throwable throwable) {\n\t\t\tThrowable cause = throwable.getCause();\n\t\t\tif (sourceType.isInstance(cause)) {\n\t\t\t\treturn sourceType.cast(cause);\n\t\t\t}\n\t\t}\n\t\tthrow new IllegalArgumentException(\"No source object of the given type available: \" + sourceType);\n\t}"
  },
  "org.springframework.validation.ObjectError#wrap(source)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Preserve the source behind this error: possibly an {@link Exception}\n\t * (typically {@link org.springframework.beans.PropertyAccessException})\n\t * or a Bean Validation {@link jakarta.validation.ConstraintViolation}.\n\t * <p>Note that any such source object is being stored as transient:\n\t * that is, it won't be part of a serialized error representation.\n\t * @param source the source object\n\t * @since 5.0.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "void",
    "signature": "public void wrap(Object source)",
    "source_code": "\tpublic void wrap(Object source) {\n\t\tif (this.source != null) {\n\t\t\tthrow new IllegalStateException(\"Already wrapping \" + this.source);\n\t\t}\n\t\tthis.source = source;\n\t}"
  },
  "org.springframework.validation.ValidationUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Utility class offering convenient methods for invoking a {@link Validator}\n * and for rejecting empty fields.\n *\n * <p>Checks for an empty field in {@code Validator} implementations can become\n * one-liners when using {@link #rejectIfEmpty} or {@link #rejectIfEmptyOrWhitespace}.\n *\n * @author Juergen Hoeller\n * @author Dmitriy Kopylenko\n * @since 06.05.2003\n * @see Validator\n * @see Errors\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 40
    },
    "signature": "public class ValidationUtils",
    "source_code": "public abstract class ValidationUtils {\n\n\tprivate static final Log logger = LogFactory.getLog(ValidationUtils.class);\n\n\n\t/**\n\t * Invoke the given {@link Validator} for the supplied object and\n\t * {@link Errors} instance.\n\t * @param validator the {@code Validator} to be invoked\n\t * @param target the object to bind the parameters to\n\t * @param errors the {@link Errors} instance that should store the errors\n\t * @throws IllegalArgumentException if either of the {@code Validator} or {@code Errors}\n\t * arguments is {@code null}, or if the supplied {@code Validator} does not\n\t * {@link Validator#supports(Class) support} the validation of the supplied object's type\n\t */\n\tpublic static void invokeValidator(Validator validator, Object target, Errors errors) {\n\t\tinvokeValidator(validator, target, errors, (Object[]) null);\n\t}\n\n\t/**\n\t * Invoke the given {@link Validator}/{@link SmartValidator} for the supplied object and\n\t * {@link Errors} instance.\n\t * @param validator the {@code Validator} to be invoked\n\t * @param target the object to bind the parameters to\n\t * @param errors the {@link Errors} instance that should store the errors\n\t * @param validationHints one or more hint objects to be passed to the validation engine\n\t * @throws IllegalArgumentException if either of the {@code Validator} or {@code Errors}\n\t * arguments is {@code null}, or if the supplied {@code Validator} does not\n\t * {@link Validator#supports(Class) support} the validation of the supplied object's type\n\t */\n\tpublic static void invokeValidator(\n\t\t\tValidator validator, Object target, Errors errors, @Nullable Object... validationHints) {\n\n\t\tAssert.notNull(validator, \"Validator must not be null\");\n\t\tAssert.notNull(target, \"Target object must not be null\");\n\t\tAssert.notNull(errors, \"Errors object must not be null\");\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Invoking validator [\" + validator + \"]\");\n\t\t}\n\t\tif (!validator.supports(target.getClass())) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Validator [\" + validator.getClass() + \"] does not support [\" + target.getClass() + \"]\");\n\t\t}\n\n\t\tif (!ObjectUtils.isEmpty(validationHints) && validator instanceof SmartValidator smartValidator) {\n\t\t\tsmartValidator.validate(target, errors, validationHints);\n\t\t}\n\t\telse {\n\t\t\tvalidator.validate(target, errors);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tif (errors.hasErrors()) {\n\t\t\t\tlogger.debug(\"Validator found \" + errors.getErrorCount() + \" errors\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.debug(\"Validator found no errors\");\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Reject the given field with the given error code if the value is empty.\n\t * <p>An 'empty' value in this context means either {@code null} or\n\t * the empty string \"\".\n\t * <p>The object whose field is being validated does not need to be passed\n\t * in because the {@link Errors} instance can resolve field values by itself\n\t * (it will usually hold an internal reference to the target object).\n\t * @param errors the {@code Errors} instance to register errors on\n\t * @param field the field name to check\n\t * @param errorCode the error code, interpretable as message key\n\t */\n\tpublic static void rejectIfEmpty(Errors errors, String field, String errorCode) {\n\t\trejectIfEmpty(errors, field, errorCode, null, null);\n\t}\n\n\t/**\n\t * Reject the given field with the given error code and default message\n\t * if the value is empty.\n\t * <p>An 'empty' value in this context means either {@code null} or\n\t * the empty string \"\".\n\t * <p>The object whose field is being validated does not need to be passed\n\t * in because the {@link Errors} instance can resolve field values by itself\n\t * (it will usually hold an internal reference to the target object).\n\t * @param errors the {@code Errors} instance to register errors on\n\t * @param field the field name to check\n\t * @param errorCode error code, interpretable as message key\n\t * @param defaultMessage fallback default message\n\t */\n\tpublic static void rejectIfEmpty(Errors errors, String field, String errorCode, String defaultMessage) {\n\t\trejectIfEmpty(errors, field, errorCode, null, defaultMessage);\n\t}\n\n\t/**\n\t * Reject the given field with the given error code and error arguments\n\t * if the value is empty.\n\t * <p>An 'empty' value in this context means either {@code null} or\n\t * the empty string \"\".\n\t * <p>The object whose field is being validated does not need to be passed\n\t * in because the {@link Errors} instance can resolve field values by itself\n\t * (it will usually hold an internal reference to the target object).\n\t * @param errors the {@code Errors} instance to register errors on\n\t * @param field the field name to check\n\t * @param errorCode the error code, interpretable as message key\n\t * @param errorArgs the error arguments, for argument binding via MessageFormat\n\t * (can be {@code null})\n\t */\n\tpublic static void rejectIfEmpty(Errors errors, String field, String errorCode, Object[] errorArgs) {\n\t\trejectIfEmpty(errors, field, errorCode, errorArgs, null);\n\t}\n\n\t/**\n\t * Reject the given field with the given error code, error arguments\n\t * and default message if the value is empty.\n\t * <p>An 'empty' value in this context means either {@code null} or\n\t * the empty string \"\".\n\t * <p>The object whose field is being validated does not need to be passed\n\t * in because the {@link Errors} instance can resolve field values by itself\n\t * (it will usually hold an internal reference to the target object).\n\t * @param errors the {@code Errors} instance to register errors on\n\t * @param field the field name to check\n\t * @param errorCode the error code, interpretable as message key\n\t * @param errorArgs the error arguments, for argument binding via MessageFormat\n\t * (can be {@code null})\n\t * @param defaultMessage fallback default message\n\t */\n\tpublic static void rejectIfEmpty(Errors errors, String field, String errorCode,\n\t\t\t@Nullable Object[] errorArgs, @Nullable String defaultMessage) {\n\n\t\tAssert.notNull(errors, \"Errors object must not be null\");\n\t\tObject value = errors.getFieldValue(field);\n\t\tif (value == null || !StringUtils.hasLength(value.toString())) {\n\t\t\terrors.rejectValue(field, errorCode, errorArgs, defaultMessage);\n\t\t}\n\t}\n\n\t/**\n\t * Reject the given field with the given error code if the value is empty\n\t * or just contains whitespace.\n\t * <p>An 'empty' value in this context means either {@code null},\n\t * the empty string \"\", or consisting wholly of whitespace.\n\t * <p>The object whose field is being validated does not need to be passed\n\t * in because the {@link Errors} instance can resolve field values by itself\n\t * (it will usually hold an internal reference to the target object).\n\t * @param errors the {@code Errors} instance to register errors on\n\t * @param field the field name to check\n\t * @param errorCode the error code, interpretable as message key\n\t */\n\tpublic static void rejectIfEmptyOrWhitespace(Errors errors, String field, String errorCode) {\n\t\trejectIfEmptyOrWhitespace(errors, field, errorCode, null, null);\n\t}\n\n\t/**\n\t * Reject the given field with the given error code and default message\n\t * if the value is empty or just contains whitespace.\n\t * <p>An 'empty' value in this context means either {@code null},\n\t * the empty string \"\", or consisting wholly of whitespace.\n\t * <p>The object whose field is being validated does not need to be passed\n\t * in because the {@link Errors} instance can resolve field values by itself\n\t * (it will usually hold an internal reference to the target object).\n\t * @param errors the {@code Errors} instance to register errors on\n\t * @param field the field name to check\n\t * @param errorCode the error code, interpretable as message key\n\t * @param defaultMessage fallback default message\n\t */\n\tpublic static void rejectIfEmptyOrWhitespace(\n\t\t\tErrors errors, String field, String errorCode, String defaultMessage) {\n\n\t\trejectIfEmptyOrWhitespace(errors, field, errorCode, null, defaultMessage);\n\t}\n\n\t/**\n\t * Reject the given field with the given error code and error arguments\n\t * if the value is empty or just contains whitespace.\n\t * <p>An 'empty' value in this context means either {@code null},\n\t * the empty string \"\", or consisting wholly of whitespace.\n\t * <p>The object whose field is being validated does not need to be passed\n\t * in because the {@link Errors} instance can resolve field values by itself\n\t * (it will usually hold an internal reference to the target object).\n\t * @param errors the {@code Errors} instance to register errors on\n\t * @param field the field name to check\n\t * @param errorCode the error code, interpretable as message key\n\t * @param errorArgs the error arguments, for argument binding via MessageFormat\n\t * (can be {@code null})\n\t */\n\tpublic static void rejectIfEmptyOrWhitespace(\n\t\t\tErrors errors, String field, String errorCode, @Nullable Object[] errorArgs) {\n\n\t\trejectIfEmptyOrWhitespace(errors, field, errorCode, errorArgs, null);\n\t}\n\n\t/**\n\t * Reject the given field with the given error code, error arguments\n\t * and default message if the value is empty or just contains whitespace.\n\t * <p>An 'empty' value in this context means either {@code null},\n\t * the empty string \"\", or consisting wholly of whitespace.\n\t * <p>The object whose field is being validated does not need to be passed\n\t * in because the {@link Errors} instance can resolve field values by itself\n\t * (it will usually hold an internal reference to the target object).\n\t * @param errors the {@code Errors} instance to register errors on\n\t * @param field the field name to check\n\t * @param errorCode the error code, interpretable as message key\n\t * @param errorArgs the error arguments, for argument binding via MessageFormat\n\t * (can be {@code null})\n\t * @param defaultMessage fallback default message\n\t */\n\tpublic static void rejectIfEmptyOrWhitespace(\n\t\t\tErrors errors, String field, String errorCode, @Nullable Object[] errorArgs, @Nullable String defaultMessage) {\n\n\t\tAssert.notNull(errors, \"Errors object must not be null\");\n\t\tObject value = errors.getFieldValue(field);\n\t\tif (value == null ||!StringUtils.hasText(value.toString())) {\n\t\t\terrors.rejectValue(field, errorCode, errorArgs, defaultMessage);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.validation.ValidationUtils#invokeValidator(validator,target,errors)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the given {@link Validator} for the supplied object and\n\t * {@link Errors} instance.\n\t * @param validator the {@code Validator} to be invoked\n\t * @param target the object to bind the parameters to\n\t * @param errors the {@link Errors} instance that should store the errors\n\t * @throws IllegalArgumentException if either of the {@code Validator} or {@code Errors}\n\t * arguments is {@code null}, or if the supplied {@code Validator} does not\n\t * {@link Validator#supports(Class) support} the validation of the supplied object's type\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "validator",
      "target",
      "errors"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "return": "void",
    "signature": "public void invokeValidator(Validator validator, Object target, Errors errors)",
    "source_code": "\tpublic static void invokeValidator(Validator validator, Object target, Errors errors) {\n\t\tinvokeValidator(validator, target, errors, (Object[]) null);\n\t}"
  },
  "org.springframework.validation.ValidationUtils#invokeValidator(validator,target,errors,validationHints)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the given {@link Validator}/{@link SmartValidator} for the supplied object and\n\t * {@link Errors} instance.\n\t * @param validator the {@code Validator} to be invoked\n\t * @param target the object to bind the parameters to\n\t * @param errors the {@link Errors} instance that should store the errors\n\t * @param validationHints one or more hint objects to be passed to the validation engine\n\t * @throws IllegalArgumentException if either of the {@code Validator} or {@code Errors}\n\t * arguments is {@code null}, or if the supplied {@code Validator} does not\n\t * {@link Validator#supports(Class) support} the validation of the supplied object's type\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "validator",
      "target",
      "errors",
      "validationHints"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "void",
    "signature": "public void invokeValidator(Validator validator, Object target, Errors errors, @Nullable Object... validationHints)",
    "source_code": "\tpublic static void invokeValidator("
  },
  "org.springframework.validation.ValidationUtils#rejectIfEmpty(errors,field,errorCode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Reject the given field with the given error code if the value is empty.\n\t * <p>An 'empty' value in this context means either {@code null} or\n\t * the empty string \"\".\n\t * <p>The object whose field is being validated does not need to be passed\n\t * in because the {@link Errors} instance can resolve field values by itself\n\t * (it will usually hold an internal reference to the target object).\n\t * @param errors the {@code Errors} instance to register errors on\n\t * @param field the field name to check\n\t * @param errorCode the error code, interpretable as message key\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors",
      "field",
      "errorCode"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "void",
    "signature": "public void rejectIfEmpty(Errors errors, String field, String errorCode)",
    "source_code": "\tpublic static void rejectIfEmpty(Errors errors, String field, String errorCode) {\n\t\trejectIfEmpty(errors, field, errorCode, null, null);\n\t}"
  },
  "org.springframework.validation.ValidationUtils#rejectIfEmpty(errors,field,errorCode,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Reject the given field with the given error code and default message\n\t * if the value is empty.\n\t * <p>An 'empty' value in this context means either {@code null} or\n\t * the empty string \"\".\n\t * <p>The object whose field is being validated does not need to be passed\n\t * in because the {@link Errors} instance can resolve field values by itself\n\t * (it will usually hold an internal reference to the target object).\n\t * @param errors the {@code Errors} instance to register errors on\n\t * @param field the field name to check\n\t * @param errorCode error code, interpretable as message key\n\t * @param defaultMessage fallback default message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors",
      "field",
      "errorCode",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "void",
    "signature": "public void rejectIfEmpty(Errors errors, String field, String errorCode, String defaultMessage)",
    "source_code": "\tpublic static void rejectIfEmpty(Errors errors, String field, String errorCode, String defaultMessage) {\n\t\trejectIfEmpty(errors, field, errorCode, null, defaultMessage);\n\t}"
  },
  "org.springframework.validation.ValidationUtils#rejectIfEmpty(errors,field,errorCode,errorArgs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Reject the given field with the given error code and error arguments\n\t * if the value is empty.\n\t * <p>An 'empty' value in this context means either {@code null} or\n\t * the empty string \"\".\n\t * <p>The object whose field is being validated does not need to be passed\n\t * in because the {@link Errors} instance can resolve field values by itself\n\t * (it will usually hold an internal reference to the target object).\n\t * @param errors the {@code Errors} instance to register errors on\n\t * @param field the field name to check\n\t * @param errorCode the error code, interpretable as message key\n\t * @param errorArgs the error arguments, for argument binding via MessageFormat\n\t * (can be {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors",
      "field",
      "errorCode",
      "errorArgs"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "void",
    "signature": "public void rejectIfEmpty(Errors errors, String field, String errorCode, Object[] errorArgs)",
    "source_code": "\tpublic static void rejectIfEmpty(Errors errors, String field, String errorCode, Object[] errorArgs) {\n\t\trejectIfEmpty(errors, field, errorCode, errorArgs, null);\n\t}"
  },
  "org.springframework.validation.ValidationUtils#rejectIfEmpty(errors,field,errorCode,errorArgs,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Reject the given field with the given error code, error arguments\n\t * and default message if the value is empty.\n\t * <p>An 'empty' value in this context means either {@code null} or\n\t * the empty string \"\".\n\t * <p>The object whose field is being validated does not need to be passed\n\t * in because the {@link Errors} instance can resolve field values by itself\n\t * (it will usually hold an internal reference to the target object).\n\t * @param errors the {@code Errors} instance to register errors on\n\t * @param field the field name to check\n\t * @param errorCode the error code, interpretable as message key\n\t * @param errorArgs the error arguments, for argument binding via MessageFormat\n\t * (can be {@code null})\n\t * @param defaultMessage fallback default message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors",
      "field",
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "void",
    "signature": "public void rejectIfEmpty(Errors errors, String field, String errorCode,\n\t\t\t@Nullable Object[] errorArgs, @Nullable String defaultMessage)",
    "source_code": "\tpublic static void rejectIfEmpty(Errors errors, String field, String errorCode,"
  },
  "org.springframework.validation.ValidationUtils#rejectIfEmptyOrWhitespace(errors,field,errorCode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Reject the given field with the given error code if the value is empty\n\t * or just contains whitespace.\n\t * <p>An 'empty' value in this context means either {@code null},\n\t * the empty string \"\", or consisting wholly of whitespace.\n\t * <p>The object whose field is being validated does not need to be passed\n\t * in because the {@link Errors} instance can resolve field values by itself\n\t * (it will usually hold an internal reference to the target object).\n\t * @param errors the {@code Errors} instance to register errors on\n\t * @param field the field name to check\n\t * @param errorCode the error code, interpretable as message key\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors",
      "field",
      "errorCode"
    ],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "void",
    "signature": "public void rejectIfEmptyOrWhitespace(Errors errors, String field, String errorCode)",
    "source_code": "\tpublic static void rejectIfEmptyOrWhitespace(Errors errors, String field, String errorCode) {\n\t\trejectIfEmptyOrWhitespace(errors, field, errorCode, null, null);\n\t}"
  },
  "org.springframework.validation.ValidationUtils#rejectIfEmptyOrWhitespace(errors,field,errorCode,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Reject the given field with the given error code and default message\n\t * if the value is empty or just contains whitespace.\n\t * <p>An 'empty' value in this context means either {@code null},\n\t * the empty string \"\", or consisting wholly of whitespace.\n\t * <p>The object whose field is being validated does not need to be passed\n\t * in because the {@link Errors} instance can resolve field values by itself\n\t * (it will usually hold an internal reference to the target object).\n\t * @param errors the {@code Errors} instance to register errors on\n\t * @param field the field name to check\n\t * @param errorCode the error code, interpretable as message key\n\t * @param defaultMessage fallback default message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors",
      "field",
      "errorCode",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "void",
    "signature": "public void rejectIfEmptyOrWhitespace(Errors errors, String field, String errorCode, String defaultMessage)",
    "source_code": "\tpublic static void rejectIfEmptyOrWhitespace("
  },
  "org.springframework.validation.ValidationUtils#rejectIfEmptyOrWhitespace(errors,field,errorCode,errorArgs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Reject the given field with the given error code and error arguments\n\t * if the value is empty or just contains whitespace.\n\t * <p>An 'empty' value in this context means either {@code null},\n\t * the empty string \"\", or consisting wholly of whitespace.\n\t * <p>The object whose field is being validated does not need to be passed\n\t * in because the {@link Errors} instance can resolve field values by itself\n\t * (it will usually hold an internal reference to the target object).\n\t * @param errors the {@code Errors} instance to register errors on\n\t * @param field the field name to check\n\t * @param errorCode the error code, interpretable as message key\n\t * @param errorArgs the error arguments, for argument binding via MessageFormat\n\t * (can be {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors",
      "field",
      "errorCode",
      "errorArgs"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "void",
    "signature": "public void rejectIfEmptyOrWhitespace(Errors errors, String field, String errorCode, @Nullable Object[] errorArgs)",
    "source_code": "\tpublic static void rejectIfEmptyOrWhitespace("
  },
  "org.springframework.validation.ValidationUtils#rejectIfEmptyOrWhitespace(errors,field,errorCode,errorArgs,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Reject the given field with the given error code, error arguments\n\t * and default message if the value is empty or just contains whitespace.\n\t * <p>An 'empty' value in this context means either {@code null},\n\t * the empty string \"\", or consisting wholly of whitespace.\n\t * <p>The object whose field is being validated does not need to be passed\n\t * in because the {@link Errors} instance can resolve field values by itself\n\t * (it will usually hold an internal reference to the target object).\n\t * @param errors the {@code Errors} instance to register errors on\n\t * @param field the field name to check\n\t * @param errorCode the error code, interpretable as message key\n\t * @param errorArgs the error arguments, for argument binding via MessageFormat\n\t * (can be {@code null})\n\t * @param defaultMessage fallback default message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors",
      "field",
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "void",
    "signature": "public void rejectIfEmptyOrWhitespace(Errors errors, String field, String errorCode, @Nullable Object[] errorArgs, @Nullable String defaultMessage)",
    "source_code": "\tpublic static void rejectIfEmptyOrWhitespace("
  },
  "org.springframework.validation.annotation.ValidationAnnotationUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Utility class for handling validation annotations.\n * Mainly for internal use within the framework.\n *\n * @author Christoph Dreis\n * @since 5.3.7\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 31
    },
    "signature": "public class ValidationAnnotationUtils",
    "source_code": "public abstract class ValidationAnnotationUtils {\n\n\tprivate static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n\n\t/**\n\t * Determine any validation hints by the given annotation.\n\t * <p>This implementation checks for {@code @jakarta.validation.Valid},\n\t * Spring's {@link org.springframework.validation.annotation.Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param ann the annotation (potentially a validation annotation)\n\t * @return the validation hints to apply (possibly an empty array),\n\t * or {@code null} if this annotation does not trigger any validation\n\t */\n\t@Nullable\n\tpublic static Object[] determineValidationHints(Annotation ann) {\n\t\tClass<? extends Annotation> annotationType = ann.annotationType();\n\t\tString annotationName = annotationType.getName();\n\t\tif (\"jakarta.validation.Valid\".equals(annotationName)) {\n\t\t\treturn EMPTY_OBJECT_ARRAY;\n\t\t}\n\t\tValidated validatedAnn = AnnotationUtils.getAnnotation(ann, Validated.class);\n\t\tif (validatedAnn != null) {\n\t\t\tObject hints = validatedAnn.value();\n\t\t\treturn convertValidationHints(hints);\n\t\t}\n\t\tif (annotationType.getSimpleName().startsWith(\"Valid\")) {\n\t\t\tObject hints = AnnotationUtils.getValue(ann);\n\t\t\treturn convertValidationHints(hints);\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate static Object[] convertValidationHints(@Nullable Object hints) {\n\t\tif (hints == null) {\n\t\t\treturn EMPTY_OBJECT_ARRAY;\n\t\t}\n\t\treturn (hints instanceof Object[] objectHints ? objectHints : new Object[] {hints});\n\t}\n\n}"
  },
  "org.springframework.validation.annotation.ValidationAnnotationUtils#determineValidationHints(ann)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine any validation hints by the given annotation.\n\t * <p>This implementation checks for {@code @jakarta.validation.Valid},\n\t * Spring's {@link org.springframework.validation.annotation.Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param ann the annotation (potentially a validation annotation)\n\t * @return the validation hints to apply (possibly an empty array),\n\t * or {@code null} if this annotation does not trigger any validation\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ann"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "return": "Object[]",
    "signature": "public Object[] determineValidationHints(Annotation ann)",
    "source_code": "\tpublic static Object[] determineValidationHints(Annotation ann) {\n\t\tClass<? extends Annotation> annotationType = ann.annotationType();\n\t\tString annotationName = annotationType.getName();\n\t\tif (\"jakarta.validation.Valid\".equals(annotationName)) {\n\t\t\treturn EMPTY_OBJECT_ARRAY;\n\t\t}\n\t\tValidated validatedAnn = AnnotationUtils.getAnnotation(ann, Validated.class);\n\t\tif (validatedAnn != null) {\n\t\t\tObject hints = validatedAnn.value();\n\t\t\treturn convertValidationHints(hints);\n\t\t}\n\t\tif (annotationType.getSimpleName().startsWith(\"Valid\")) {\n\t\t\tObject hints = AnnotationUtils.getValue(ann);\n\t\t\treturn convertValidationHints(hints);\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.bind.annotation.RequestMethod": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Enumeration of HTTP request methods. Intended for use with the\n * {@link RequestMapping#method()} attribute of the {@link RequestMapping} annotation.\n *\n * <p>Note that, by default, {@link org.springframework.web.servlet.DispatcherServlet}\n * supports GET, HEAD, POST, PUT, PATCH, and DELETE only. DispatcherServlet will\n * process TRACE and OPTIONS with the default HttpServlet behavior unless explicitly\n * told to dispatch those request types as well: Check out the \"dispatchOptionsRequest\"\n * and \"dispatchTraceRequest\" properties, switching them to \"true\" if necessary.\n *\n * @author Juergen Hoeller\n * @since 2.5\n * @see RequestMapping\n * @see org.springframework.web.servlet.DispatcherServlet#setDispatchOptionsRequest\n * @see org.springframework.web.servlet.DispatcherServlet#setDispatchTraceRequest\n */",
    "kind": "enum",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public enum RequestMethod",
    "source_code": "public enum RequestMethod {\n\n\tGET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE;\n\n\n\t/**\n\t * Resolve the given method value to an {@code RequestMethod} enum value.\n\t * Returns {@code null} if {@code method} has no corresponding value.\n\t * @param method the method value as a String\n\t * @return the corresponding {@code RequestMethod}, or {@code null} if not found\n\t * @since 6.0.6\n\t */\n\t@Nullable\n\tpublic static RequestMethod resolve(String method) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\treturn switch (method) {\n\t\t\tcase \"GET\" -> GET;\n\t\t\tcase \"HEAD\" -> HEAD;\n\t\t\tcase \"POST\" -> POST;\n\t\t\tcase \"PUT\" -> PUT;\n\t\t\tcase \"PATCH\" -> PATCH;\n\t\t\tcase \"DELETE\" -> DELETE;\n\t\t\tcase \"OPTIONS\" -> OPTIONS;\n\t\t\tcase \"TRACE\" -> TRACE;\n\t\t\tdefault -> null;\n\t\t};\n\t}\n\n\t/**\n\t * Resolve the given {@link HttpMethod} to a {@code RequestMethod} enum value.\n\t * Returns {@code null} if {@code httpMethod} has no corresponding value.\n\t * @param httpMethod the http method object\n\t * @return the corresponding {@code RequestMethod}, or {@code null} if not found\n\t * @since 6.0.6\n\t */\n\t@Nullable\n\tpublic static RequestMethod resolve(HttpMethod httpMethod) {\n\t\tAssert.notNull(httpMethod, \"HttpMethod must not be null\");\n\t\treturn resolve(httpMethod.name());\n\t}\n\n\n\t/**\n\t * Return the {@link HttpMethod} corresponding to this {@code RequestMethod}.\n\t * @return the http method for this request method\n\t * @since 6.0.6\n\t */\n\tpublic HttpMethod asHttpMethod() {\n\t\treturn switch (this) {\n\t\t\tcase GET -> HttpMethod.GET;\n\t\t\tcase HEAD -> HttpMethod.HEAD;\n\t\t\tcase POST -> HttpMethod.POST;\n\t\t\tcase PUT -> HttpMethod.PUT;\n\t\t\tcase PATCH -> HttpMethod.PATCH;\n\t\t\tcase DELETE -> HttpMethod.DELETE;\n\t\t\tcase OPTIONS -> HttpMethod.OPTIONS;\n\t\t\tcase TRACE -> HttpMethod.TRACE;\n\t\t};\n\t}\n\n}"
  },
  "org.springframework.web.bind.annotation.RequestMethod#asHttpMethod()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link HttpMethod} corresponding to this {@code RequestMethod}.\n\t * @return the http method for this request method\n\t * @since 6.0.6\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "HttpMethod",
    "signature": "public HttpMethod asHttpMethod()",
    "source_code": "\tpublic HttpMethod asHttpMethod() {\n\t\treturn switch (this) {\n\t\t\tcase GET -> HttpMethod.GET;\n\t\t\tcase HEAD -> HttpMethod.HEAD;\n\t\t\tcase POST -> HttpMethod.POST;\n\t\t\tcase PUT -> HttpMethod.PUT;\n\t\t\tcase PATCH -> HttpMethod.PATCH;\n\t\t\tcase DELETE -> HttpMethod.DELETE;\n\t\t\tcase OPTIONS -> HttpMethod.OPTIONS;\n\t\t\tcase TRACE -> HttpMethod.TRACE;\n\t\t};\n\t}"
  },
  "org.springframework.web.bind.annotation.RequestMethod#resolve(httpMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the given {@link HttpMethod} to a {@code RequestMethod} enum value.\n\t * Returns {@code null} if {@code httpMethod} has no corresponding value.\n\t * @param httpMethod the http method object\n\t * @return the corresponding {@code RequestMethod}, or {@code null} if not found\n\t * @since 6.0.6\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "httpMethod"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "RequestMethod",
    "signature": "public RequestMethod resolve(HttpMethod httpMethod)",
    "source_code": "\tpublic static RequestMethod resolve(HttpMethod httpMethod) {\n\t\tAssert.notNull(httpMethod, \"HttpMethod must not be null\");\n\t\treturn resolve(httpMethod.name());\n\t}"
  },
  "org.springframework.web.bind.annotation.RequestMethod#resolve(method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the given method value to an {@code RequestMethod} enum value.\n\t * Returns {@code null} if {@code method} has no corresponding value.\n\t * @param method the method value as a String\n\t * @return the corresponding {@code RequestMethod}, or {@code null} if not found\n\t * @since 6.0.6\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "RequestMethod",
    "signature": "public RequestMethod resolve(String method)",
    "source_code": "\tpublic static RequestMethod resolve(String method) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\treturn switch (method) {\n\t\t\tcase \"GET\" -> GET;\n\t\t\tcase \"HEAD\" -> HEAD;\n\t\t\tcase \"POST\" -> POST;\n\t\t\tcase \"PUT\" -> PUT;\n\t\t\tcase \"PATCH\" -> PATCH;\n\t\t\tcase \"DELETE\" -> DELETE;\n\t\t\tcase \"OPTIONS\" -> OPTIONS;\n\t\t\tcase \"TRACE\" -> TRACE;\n\t\t\tdefault -> null;\n\t\t};\n\t}"
  }
}