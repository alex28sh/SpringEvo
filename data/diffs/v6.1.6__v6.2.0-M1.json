{
  "org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Abstract BeanFactory-based PointcutAdvisor that allows for any Advice\n * to be configured as reference to an Advice bean in a BeanFactory.\n *\n * <p>Specifying the name of an advice bean instead of the advice object itself\n * (if running within a BeanFactory) increases loose coupling at initialization time,\n * in order to not initialize the advice object until the pointcut actually matches.\n *\n * @author Juergen Hoeller\n * @since 2.0.2\n * @see #setAdviceBeanName\n * @see DefaultBeanFactoryPointcutAdvisor\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "signature": "public class AbstractBeanFactoryPointcutAdvisor",
    "source_code": "public abstract class AbstractBeanFactoryPointcutAdvisor extends AbstractPointcutAdvisor implements BeanFactoryAware {\n\n\t@Nullable\n\tprivate String adviceBeanName;\n\n\t@Nullable\n\tprivate BeanFactory beanFactory;\n\n\t@Nullable\n\tprivate transient volatile Advice advice;\n\n\tprivate transient volatile Object adviceMonitor = new Object();\n\n\n\t/**\n\t * Specify the name of the advice bean that this advisor should refer to.\n\t * <p>An instance of the specified bean will be obtained on first access\n\t * of this advisor's advice. This advisor will only ever obtain at most one\n\t * single instance of the advice bean, caching the instance for the lifetime\n\t * of the advisor.\n\t * @see #getAdvice()\n\t */\n\tpublic void setAdviceBeanName(@Nullable String adviceBeanName) {\n\t\tthis.adviceBeanName = adviceBeanName;\n\t}\n\n\t/**\n\t * Return the name of the advice bean that this advisor refers to, if any.\n\t */\n\t@Nullable\n\tpublic String getAdviceBeanName() {\n\t\treturn this.adviceBeanName;\n\t}\n\n\t@Override\n\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t\tresetAdviceMonitor();\n\t}\n\n\tprivate void resetAdviceMonitor() {\n\t\tif (this.beanFactory instanceof ConfigurableBeanFactory cbf) {\n\t\t\tthis.adviceMonitor = cbf.getSingletonMutex();\n\t\t}\n\t\telse {\n\t\t\tthis.adviceMonitor = new Object();\n\t\t}\n\t}\n\n\t/**\n\t * Specify a particular instance of the target advice directly,\n\t * avoiding lazy resolution in {@link #getAdvice()}.\n\t * @since 3.1\n\t */\n\tpublic void setAdvice(Advice advice) {\n\t\tsynchronized (this.adviceMonitor) {\n\t\t\tthis.advice = advice;\n\t\t}\n\t}\n\n\t@Override\n\tpublic Advice getAdvice() {\n\t\tAdvice advice = this.advice;\n\t\tif (advice != null) {\n\t\t\treturn advice;\n\t\t}\n\n\t\tAssert.state(this.adviceBeanName != null, \"'adviceBeanName' must be specified\");\n\t\tAssert.state(this.beanFactory != null, \"BeanFactory must be set to resolve 'adviceBeanName'\");\n\n\t\tif (this.beanFactory.isSingleton(this.adviceBeanName)) {\n\t\t\t// Rely on singleton semantics provided by the factory.\n\t\t\tadvice = this.beanFactory.getBean(this.adviceBeanName, Advice.class);\n\t\t\tthis.advice = advice;\n\t\t\treturn advice;\n\t\t}\n\t\telse {\n\t\t\t// No singleton guarantees from the factory -> let's lock locally but\n\t\t\t// reuse the factory's singleton lock, just in case a lazy dependency\n\t\t\t// of our advice bean happens to trigger the singleton lock implicitly...\n\t\t\tsynchronized (this.adviceMonitor) {\n\t\t\t\tadvice = this.advice;\n\t\t\t\tif (advice == null) {\n\t\t\t\t\tadvice = this.beanFactory.getBean(this.adviceBeanName, Advice.class);\n\t\t\t\t\tthis.advice = advice;\n\t\t\t\t}\n\t\t\t\treturn advice;\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder(getClass().getName());\n\t\tsb.append(\": advice \");\n\t\tif (this.adviceBeanName != null) {\n\t\t\tsb.append(\"bean '\").append(this.adviceBeanName).append('\\'');\n\t\t}\n\t\telse {\n\t\t\tsb.append(this.advice);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Serialization support\n\t//---------------------------------------------------------------------\n\n\tprivate void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\n\t\t// Rely on default serialization, just initialize state after deserialization.\n\t\tois.defaultReadObject();\n\n\t\t// Initialize transient fields.\n\t\tresetAdviceMonitor();\n\t}\n\n}"
  },
  "org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor#getAdvice()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "Advice",
    "signature": "public Advice getAdvice()",
    "source_code": "\tpublic Advice getAdvice() {\n\t\tAdvice advice = this.advice;\n\t\tif (advice != null) {\n\t\t\treturn advice;\n\t\t}\n\n\t\tAssert.state(this.adviceBeanName != null, \"'adviceBeanName' must be specified\");\n\t\tAssert.state(this.beanFactory != null, \"BeanFactory must be set to resolve 'adviceBeanName'\");\n\n\t\tif (this.beanFactory.isSingleton(this.adviceBeanName)) {\n\t\t\t// Rely on singleton semantics provided by the factory.\n\t\t\tadvice = this.beanFactory.getBean(this.adviceBeanName, Advice.class);\n\t\t\tthis.advice = advice;\n\t\t\treturn advice;\n\t\t}\n\t\telse {\n\t\t\t// No singleton guarantees from the factory -> let's lock locally but\n\t\t\t// reuse the factory's singleton lock, just in case a lazy dependency\n\t\t\t// of our advice bean happens to trigger the singleton lock implicitly...\n\t\t\tsynchronized (this.adviceMonitor) {\n\t\t\t\tadvice = this.advice;\n\t\t\t\tif (advice == null) {\n\t\t\t\t\tadvice = this.beanFactory.getBean(this.adviceBeanName, Advice.class);\n\t\t\t\t\tthis.advice = advice;\n\t\t\t\t}\n\t\t\t\treturn advice;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor#getAdviceBeanName()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the name of the advice bean that this advisor refers to, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "String",
    "signature": "public String getAdviceBeanName()",
    "source_code": "\tpublic String getAdviceBeanName() {\n\t\treturn this.adviceBeanName;\n\t}"
  },
  "org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor#setAdvice(advice)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify a particular instance of the target advice directly,\n\t * avoiding lazy resolution in {@link #getAdvice()}.\n\t * @since 3.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "advice"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void setAdvice(Advice advice)",
    "source_code": "\tpublic void setAdvice(Advice advice) {\n\t\tsynchronized (this.adviceMonitor) {\n\t\t\tthis.advice = advice;\n\t\t}\n\t}"
  },
  "org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor#setAdviceBeanName(adviceBeanName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the name of the advice bean that this advisor should refer to.\n\t * <p>An instance of the specified bean will be obtained on first access\n\t * of this advisor's advice. This advisor will only ever obtain at most one\n\t * single instance of the advice bean, caching the instance for the lifetime\n\t * of the advisor.\n\t * @see #getAdvice()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "adviceBeanName"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "void",
    "signature": "public void setAdviceBeanName(@Nullable String adviceBeanName)",
    "source_code": "\tpublic void setAdviceBeanName(@Nullable String adviceBeanName) {\n\t\tthis.adviceBeanName = adviceBeanName;\n\t}"
  },
  "org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor#setBeanFactory(beanFactory)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t\tresetAdviceMonitor();\n\t}"
  },
  "org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor#toString()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder(getClass().getName());\n\t\tsb.append(\": advice \");\n\t\tif (this.adviceBeanName != null) {\n\t\t\tsb.append(\"bean '\").append(this.adviceBeanName).append('\\'');\n\t\t}\n\t\telse {\n\t\t\tsb.append(this.advice);\n\t\t}\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.beans.factory.annotation.BeanFactoryAnnotationUtils#getQualifierValue(annotatedElement)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the {@link Qualifier#value() qualifier value} for the given\n\t * annotated element.\n\t * @param annotatedElement the class, method or parameter to introspect\n\t * @return the associated qualifier value, or {@code null} if none\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "String",
    "signature": "public String getQualifierValue(AnnotatedElement annotatedElement)",
    "source_code": "\tpublic static String getQualifierValue(AnnotatedElement annotatedElement) {\n\t\tQualifier qualifier = AnnotationUtils.getAnnotation(annotatedElement, Qualifier.class);\n\t\treturn (qualifier != null ? qualifier.value() : null);\n\t}"
  },
  "org.springframework.beans.factory.annotation.QualifierAnnotationAutowireCandidateResolver#getSuggestedName(descriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 348
    },
    "return": "String",
    "signature": "public String getSuggestedName(DependencyDescriptor descriptor)",
    "source_code": "\tpublic String getSuggestedName(DependencyDescriptor descriptor) {\n\t\tfor (Annotation annotation : descriptor.getAnnotations()) {\n\t\t\tif (isQualifier(annotation.annotationType())) {\n\t\t\t\tObject value = AnnotationUtils.getValue(annotation);\n\t\t\t\tif (value instanceof String str) {\n\t\t\t\t\treturn str;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Descriptor for a specific dependency that is about to be injected.\n * Wraps a constructor parameter, a method parameter or a field,\n * allowing unified access to their metadata.\n *\n * @author Juergen Hoeller\n * @since 2.5\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "public class DependencyDescriptor",
    "source_code": "public class DependencyDescriptor extends InjectionPoint implements Serializable {\n\n\tprivate final Class<?> declaringClass;\n\n\t@Nullable\n\tprivate String methodName;\n\n\t@Nullable\n\tprivate Class<?>[] parameterTypes;\n\n\tprivate int parameterIndex;\n\n\t@Nullable\n\tprivate String fieldName;\n\n\tprivate final boolean required;\n\n\tprivate final boolean eager;\n\n\tprivate int nestingLevel = 1;\n\n\t@Nullable\n\tprivate Class<?> containingClass;\n\n\t@Nullable\n\tprivate transient volatile ResolvableType resolvableType;\n\n\t@Nullable\n\tprivate transient volatile TypeDescriptor typeDescriptor;\n\n\n\t/**\n\t * Create a new descriptor for a method or constructor parameter.\n\t * Considers the dependency as 'eager'.\n\t * @param methodParameter the MethodParameter to wrap\n\t * @param required whether the dependency is required\n\t */\n\tpublic DependencyDescriptor(MethodParameter methodParameter, boolean required) {\n\t\tthis(methodParameter, required, true);\n\t}\n\n\t/**\n\t * Create a new descriptor for a method or constructor parameter.\n\t * @param methodParameter the MethodParameter to wrap\n\t * @param required whether the dependency is required\n\t * @param eager whether this dependency is 'eager' in the sense of\n\t * eagerly resolving potential target beans for type matching\n\t */\n\tpublic DependencyDescriptor(MethodParameter methodParameter, boolean required, boolean eager) {\n\t\tsuper(methodParameter);\n\n\t\tthis.declaringClass = methodParameter.getDeclaringClass();\n\t\tif (methodParameter.getMethod() != null) {\n\t\t\tthis.methodName = methodParameter.getMethod().getName();\n\t\t}\n\t\tthis.parameterTypes = methodParameter.getExecutable().getParameterTypes();\n\t\tthis.parameterIndex = methodParameter.getParameterIndex();\n\t\tthis.containingClass = methodParameter.getContainingClass();\n\t\tthis.required = required;\n\t\tthis.eager = eager;\n\t}\n\n\t/**\n\t * Create a new descriptor for a field.\n\t * Considers the dependency as 'eager'.\n\t * @param field the field to wrap\n\t * @param required whether the dependency is required\n\t */\n\tpublic DependencyDescriptor(Field field, boolean required) {\n\t\tthis(field, required, true);\n\t}\n\n\t/**\n\t * Create a new descriptor for a field.\n\t * @param field the field to wrap\n\t * @param required whether the dependency is required\n\t * @param eager whether this dependency is 'eager' in the sense of\n\t * eagerly resolving potential target beans for type matching\n\t */\n\tpublic DependencyDescriptor(Field field, boolean required, boolean eager) {\n\t\tsuper(field);\n\n\t\tthis.declaringClass = field.getDeclaringClass();\n\t\tthis.fieldName = field.getName();\n\t\tthis.required = required;\n\t\tthis.eager = eager;\n\t}\n\n\t/**\n\t * Copy constructor.\n\t * @param original the original descriptor to create a copy from\n\t */\n\tpublic DependencyDescriptor(DependencyDescriptor original) {\n\t\tsuper(original);\n\n\t\tthis.declaringClass = original.declaringClass;\n\t\tthis.methodName = original.methodName;\n\t\tthis.parameterTypes = original.parameterTypes;\n\t\tthis.parameterIndex = original.parameterIndex;\n\t\tthis.fieldName = original.fieldName;\n\t\tthis.containingClass = original.containingClass;\n\t\tthis.required = original.required;\n\t\tthis.eager = original.eager;\n\t\tthis.nestingLevel = original.nestingLevel;\n\t}\n\n\n\t/**\n\t * Return whether this dependency is required.\n\t * <p>Optional semantics are derived from Java 8's {@link java.util.Optional},\n\t * any variant of a parameter-level {@code Nullable} annotation (such as from\n\t * JSR-305 or the FindBugs set of annotations), or a language-level nullable\n\t * type declaration in Kotlin.\n\t */\n\tpublic boolean isRequired() {\n\t\tif (!this.required) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.field != null) {\n\t\t\treturn !(this.field.getType() == Optional.class || hasNullableAnnotation() ||\n\t\t\t\t\t(KotlinDetector.isKotlinReflectPresent() &&\n\t\t\t\t\t\t\tKotlinDetector.isKotlinType(this.field.getDeclaringClass()) &&\n\t\t\t\t\t\t\tKotlinDelegate.isNullable(this.field)));\n\t\t}\n\t\telse {\n\t\t\treturn !obtainMethodParameter().isOptional();\n\t\t}\n\t}\n\n\t/**\n\t * Check whether the underlying field is annotated with any variant of a\n\t * {@code Nullable} annotation, e.g. {@code jakarta.annotation.Nullable} or\n\t * {@code edu.umd.cs.findbugs.annotations.Nullable}.\n\t */\n\tprivate boolean hasNullableAnnotation() {\n\t\tfor (Annotation ann : getAnnotations()) {\n\t\t\tif (\"Nullable\".equals(ann.annotationType().getSimpleName())) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Return whether this dependency is 'eager' in the sense of\n\t * eagerly resolving potential target beans for type matching.\n\t */\n\tpublic boolean isEager() {\n\t\treturn this.eager;\n\t}\n\n\t/**\n\t * Resolve the specified not-unique scenario: by default,\n\t * throwing a {@link NoUniqueBeanDefinitionException}.\n\t * <p>Subclasses may override this to select one of the instances or\n\t * to opt out with no result at all through returning {@code null}.\n\t * @param type the requested bean type\n\t * @param matchingBeans a map of bean names and corresponding bean\n\t * instances which have been pre-selected for the given type\n\t * (qualifiers etc already applied)\n\t * @return a bean instance to proceed with, or {@code null} for none\n\t * @throws BeansException in case of the not-unique scenario being fatal\n\t * @since 5.1\n\t */\n\t@Nullable\n\tpublic Object resolveNotUnique(ResolvableType type, Map<String, Object> matchingBeans) throws BeansException {\n\t\tthrow new NoUniqueBeanDefinitionException(type, matchingBeans.keySet());\n\t}\n\n\t/**\n\t * Resolve a shortcut for this dependency against the given factory, for example\n\t * taking some pre-resolved information into account.\n\t * <p>The resolution algorithm will first attempt to resolve a shortcut through this\n\t * method before going into the regular type matching algorithm across all beans.\n\t * Subclasses may override this method to improve resolution performance based on\n\t * pre-cached information while still receiving {@link InjectionPoint} exposure etc.\n\t * @param beanFactory the associated factory\n\t * @return the shortcut result if any, or {@code null} if none\n\t * @throws BeansException if the shortcut could not be obtained\n\t * @since 4.3.1\n\t */\n\t@Nullable\n\tpublic Object resolveShortcut(BeanFactory beanFactory) throws BeansException {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Resolve the specified bean name, as a candidate result of the matching\n\t * algorithm for this dependency, to a bean instance from the given factory.\n\t * <p>The default implementation calls {@link BeanFactory#getBean(String)}.\n\t * Subclasses may provide additional arguments or other customizations.\n\t * @param beanName the bean name, as a candidate result for this dependency\n\t * @param requiredType the expected type of the bean (as an assertion)\n\t * @param beanFactory the associated factory\n\t * @return the bean instance (never {@code null})\n\t * @throws BeansException if the bean could not be obtained\n\t * @since 4.3.2\n\t * @see BeanFactory#getBean(String)\n\t */\n\tpublic Object resolveCandidate(String beanName, Class<?> requiredType, BeanFactory beanFactory)\n\t\t\tthrows BeansException {\n\n\t\treturn beanFactory.getBean(beanName);\n\t}\n\n\n\t/**\n\t * Increase this descriptor's nesting level.\n\t */\n\tpublic void increaseNestingLevel() {\n\t\tthis.nestingLevel++;\n\t\tthis.resolvableType = null;\n\t\tif (this.methodParameter != null) {\n\t\t\tthis.methodParameter = this.methodParameter.nested();\n\t\t}\n\t}\n\n\t/**\n\t * Optionally set the concrete class that contains this dependency.\n\t * This may differ from the class that declares the parameter/field in that\n\t * it may be a subclass thereof, potentially substituting type variables.\n\t * @since 4.0\n\t */\n\tpublic void setContainingClass(Class<?> containingClass) {\n\t\tthis.containingClass = containingClass;\n\t\tthis.resolvableType = null;\n\t\tif (this.methodParameter != null) {\n\t\t\tthis.methodParameter = this.methodParameter.withContainingClass(containingClass);\n\t\t}\n\t}\n\n\t/**\n\t * Build a {@link ResolvableType} object for the wrapped parameter/field.\n\t * @since 4.0\n\t */\n\tpublic ResolvableType getResolvableType() {\n\t\tResolvableType resolvableType = this.resolvableType;\n\t\tif (resolvableType == null) {\n\t\t\tresolvableType = (this.field != null ?\n\t\t\t\t\tResolvableType.forField(this.field, this.nestingLevel, this.containingClass) :\n\t\t\t\t\tResolvableType.forMethodParameter(obtainMethodParameter()));\n\t\t\tthis.resolvableType = resolvableType;\n\t\t}\n\t\treturn resolvableType;\n\t}\n\n\t/**\n\t * Build a {@link TypeDescriptor} object for the wrapped parameter/field.\n\t * @since 5.1.4\n\t */\n\tpublic TypeDescriptor getTypeDescriptor() {\n\t\tTypeDescriptor typeDescriptor = this.typeDescriptor;\n\t\tif (typeDescriptor == null) {\n\t\t\ttypeDescriptor = (this.field != null ?\n\t\t\t\t\tnew TypeDescriptor(getResolvableType(), getDependencyType(), getAnnotations()) :\n\t\t\t\t\tnew TypeDescriptor(obtainMethodParameter()));\n\t\t\tthis.typeDescriptor = typeDescriptor;\n\t\t}\n\t\treturn typeDescriptor;\n\t}\n\n\t/**\n\t * Return whether a fallback match is allowed.\n\t * <p>This is {@code false} by default but may be overridden to return {@code true} in order\n\t * to suggest to an {@link org.springframework.beans.factory.support.AutowireCandidateResolver}\n\t * that a fallback match is acceptable as well.\n\t * @since 4.0\n\t */\n\tpublic boolean fallbackMatchAllowed() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Return a variant of this descriptor that is intended for a fallback match.\n\t * @since 4.0\n\t * @see #fallbackMatchAllowed()\n\t */\n\tpublic DependencyDescriptor forFallbackMatch() {\n\t\treturn new DependencyDescriptor(this) {\n\t\t\t@Override\n\t\t\tpublic boolean fallbackMatchAllowed() {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic boolean usesStandardBeanLookup() {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Initialize parameter name discovery for the underlying method parameter, if any.\n\t * <p>This method does not actually try to retrieve the parameter name at\n\t * this point; it just allows discovery to happen when the application calls\n\t * {@link #getDependencyName()} (if ever).\n\t */\n\tpublic void initParameterNameDiscovery(@Nullable ParameterNameDiscoverer parameterNameDiscoverer) {\n\t\tif (this.methodParameter != null) {\n\t\t\tthis.methodParameter.initParameterNameDiscovery(parameterNameDiscoverer);\n\t\t}\n\t}\n\n\t/**\n\t * Determine the name of the wrapped parameter/field.\n\t * @return the declared name (may be {@code null} if unresolvable)\n\t */\n\t@Nullable\n\tpublic String getDependencyName() {\n\t\treturn (this.field != null ? this.field.getName() : obtainMethodParameter().getParameterName());\n\t}\n\n\t/**\n\t * Determine the declared (non-generic) type of the wrapped parameter/field.\n\t * @return the declared type (never {@code null})\n\t */\n\tpublic Class<?> getDependencyType() {\n\t\tif (this.field != null) {\n\t\t\tif (this.nestingLevel > 1) {\n\t\t\t\tClass<?> clazz = getResolvableType().getRawClass();\n\t\t\t\treturn (clazz != null ? clazz : Object.class);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn this.field.getType();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn obtainMethodParameter().getNestedParameterType();\n\t\t}\n\t}\n\n\t/**\n\t * Determine whether this dependency supports lazy resolution,\n\t * e.g. through extra proxying. The default is {@code true}.\n\t * @since 6.1.2\n\t * @see org.springframework.beans.factory.support.AutowireCandidateResolver#getLazyResolutionProxyIfNecessary\n\t */\n\tpublic boolean supportsLazyResolution() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Determine whether this descriptor uses a standard bean lookup\n\t * in {@link #resolveCandidate(String, Class, BeanFactory)} and\n\t * therefore qualifies for factory-level shortcut resolution.\n\t * <p>By default, the {@code DependencyDescriptor} class itself\n\t * uses a standard bean lookup but subclasses may override this.\n\t * If a subclass overrides other methods but preserves a standard\n\t * bean lookup, it may override this method to return {@code true}.\n\t * @since 6.2\n\t * @see #resolveCandidate(String, Class, BeanFactory)\n\t */\n\tpublic boolean usesStandardBeanLookup() {\n\t\treturn (getClass() == DependencyDescriptor.class);\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!super.equals(other)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (other instanceof DependencyDescriptor otherDesc && this.required == otherDesc.required &&\n\t\t\t\tthis.eager == otherDesc.eager && this.nestingLevel == otherDesc.nestingLevel &&\n\t\t\t\tthis.containingClass == otherDesc.containingClass);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn (31 * super.hashCode() + ObjectUtils.nullSafeHashCode(this.containingClass));\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Serialization support\n\t//---------------------------------------------------------------------\n\n\tprivate void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\n\t\t// Rely on default serialization; just initialize state after deserialization.\n\t\tois.defaultReadObject();\n\n\t\t// Restore reflective handles (which are unfortunately not serializable)\n\t\ttry {\n\t\t\tif (this.fieldName != null) {\n\t\t\t\tthis.field = this.declaringClass.getDeclaredField(this.fieldName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (this.methodName != null) {\n\t\t\t\t\tthis.methodParameter = new MethodParameter(\n\t\t\t\t\t\t\tthis.declaringClass.getDeclaredMethod(this.methodName, this.parameterTypes), this.parameterIndex);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.methodParameter = new MethodParameter(\n\t\t\t\t\t\t\tthis.declaringClass.getDeclaredConstructor(this.parameterTypes), this.parameterIndex);\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i < this.nestingLevel; i++) {\n\t\t\t\t\tthis.methodParameter = this.methodParameter.nested();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new IllegalStateException(\"Could not find original class structure\", ex);\n\t\t}\n\t}\n\n\n\t/**\n\t * Inner class to avoid a hard dependency on Kotlin at runtime.\n\t */\n\tprivate static class KotlinDelegate {\n\n\t\t/**\n\t\t * Check whether the specified {@link Field} represents a nullable Kotlin type or not.\n\t\t */\n\t\tpublic static boolean isNullable(Field field) {\n\t\t\tKProperty<?> property = ReflectJvmMapping.getKotlinProperty(field);\n\t\t\treturn (property != null && property.getReturnType().isMarkedNullable());\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 409
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!super.equals(other)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (other instanceof DependencyDescriptor otherDesc && this.required == otherDesc.required &&\n\t\t\t\tthis.eager == otherDesc.eager && this.nestingLevel == otherDesc.nestingLevel &&\n\t\t\t\tthis.containingClass == otherDesc.containingClass);\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#fallbackMatchAllowed()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 332
    },
    "return": "boolean",
    "signature": "public boolean fallbackMatchAllowed()",
    "source_code": "\t\t\tpublic boolean fallbackMatchAllowed() {\n\t\t\t\treturn true;\n\t\t\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#forFallbackMatch()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a variant of this descriptor that is intended for a fallback match.\n\t * @since 4.0\n\t * @see #fallbackMatchAllowed()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 329
    },
    "return": "DependencyDescriptor",
    "signature": "public DependencyDescriptor forFallbackMatch()",
    "source_code": "\tpublic DependencyDescriptor forFallbackMatch() {\n\t\treturn new DependencyDescriptor(this) {\n\t\t\t@Override\n\t\t\tpublic boolean fallbackMatchAllowed() {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic boolean usesStandardBeanLookup() {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#getDependencyName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the name of the wrapped parameter/field.\n\t * @return the declared name (may be {@code null} if unresolvable)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 359
    },
    "return": "String",
    "signature": "public String getDependencyName()",
    "source_code": "\tpublic String getDependencyName() {\n\t\treturn (this.field != null ? this.field.getName() : obtainMethodParameter().getParameterName());\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#getResolvableType()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@link ResolvableType} object for the wrapped parameter/field.\n\t * @since 4.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType getResolvableType()",
    "source_code": "\tpublic ResolvableType getResolvableType() {\n\t\tResolvableType resolvableType = this.resolvableType;\n\t\tif (resolvableType == null) {\n\t\t\tresolvableType = (this.field != null ?\n\t\t\t\t\tResolvableType.forField(this.field, this.nestingLevel, this.containingClass) :\n\t\t\t\t\tResolvableType.forMethodParameter(obtainMethodParameter()));\n\t\t\tthis.resolvableType = resolvableType;\n\t\t}\n\t\treturn resolvableType;\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#getTypeDescriptor()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@link TypeDescriptor} object for the wrapped parameter/field.\n\t * @since 5.1.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getTypeDescriptor()",
    "source_code": "\tpublic TypeDescriptor getTypeDescriptor() {\n\t\tTypeDescriptor typeDescriptor = this.typeDescriptor;\n\t\tif (typeDescriptor == null) {\n\t\t\ttypeDescriptor = (this.field != null ?\n\t\t\t\t\tnew TypeDescriptor(getResolvableType(), getDependencyType(), getAnnotations()) :\n\t\t\t\t\tnew TypeDescriptor(obtainMethodParameter()));\n\t\t\tthis.typeDescriptor = typeDescriptor;\n\t\t}\n\t\treturn typeDescriptor;\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 422
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn (31 * super.hashCode() + ObjectUtils.nullSafeHashCode(this.containingClass));\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#increaseNestingLevel()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Increase this descriptor's nesting level.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "void",
    "signature": "public void increaseNestingLevel()",
    "source_code": "\tpublic void increaseNestingLevel() {\n\t\tthis.nestingLevel++;\n\t\tthis.resolvableType = null;\n\t\tif (this.methodParameter != null) {\n\t\t\tthis.methodParameter = this.methodParameter.nested();\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#initParameterNameDiscovery(parameterNameDiscoverer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize parameter name discovery for the underlying method parameter, if any.\n\t * <p>This method does not actually try to retrieve the parameter name at\n\t * this point; it just allows discovery to happen when the application calls\n\t * {@link #getDependencyName()} (if ever).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterNameDiscoverer"
    ],
    "position": {
      "column": 1,
      "line": 348
    },
    "return": "void",
    "signature": "public void initParameterNameDiscovery(@Nullable ParameterNameDiscoverer parameterNameDiscoverer)",
    "source_code": "\tpublic void initParameterNameDiscovery(@Nullable ParameterNameDiscoverer parameterNameDiscoverer) {\n\t\tif (this.methodParameter != null) {\n\t\t\tthis.methodParameter.initParameterNameDiscovery(parameterNameDiscoverer);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#isEager()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether this dependency is 'eager' in the sense of\n\t * eagerly resolving potential target beans for type matching.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "boolean",
    "signature": "public boolean isEager()",
    "source_code": "\tpublic boolean isEager() {\n\t\treturn this.eager;\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#isNullable(field)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Check whether the specified {@link Field} represents a nullable Kotlin type or not.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field"
    ],
    "position": {
      "column": 1,
      "line": 468
    },
    "return": "boolean",
    "signature": "public boolean isNullable(Field field)",
    "source_code": "\t\tpublic static boolean isNullable(Field field) {\n\t\t\tKProperty<?> property = ReflectJvmMapping.getKotlinProperty(field);\n\t\t\treturn (property != null && property.getReturnType().isMarkedNullable());\n\t\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#isRequired()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether this dependency is required.\n\t * <p>Optional semantics are derived from Java 8's {@link java.util.Optional},\n\t * any variant of a parameter-level {@code Nullable} annotation (such as from\n\t * JSR-305 or the FindBugs set of annotations), or a language-level nullable\n\t * type declaration in Kotlin.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "boolean",
    "signature": "public boolean isRequired()",
    "source_code": "\tpublic boolean isRequired() {\n\t\tif (!this.required) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.field != null) {\n\t\t\treturn !(this.field.getType() == Optional.class || hasNullableAnnotation() ||\n\t\t\t\t\t(KotlinDetector.isKotlinReflectPresent() &&\n\t\t\t\t\t\t\tKotlinDetector.isKotlinType(this.field.getDeclaringClass()) &&\n\t\t\t\t\t\t\tKotlinDelegate.isNullable(this.field)));\n\t\t}\n\t\telse {\n\t\t\treturn !obtainMethodParameter().isOptional();\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#resolveCandidate(beanName,requiredType,beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the specified bean name, as a candidate result of the matching\n\t * algorithm for this dependency, to a bean instance from the given factory.\n\t * <p>The default implementation calls {@link BeanFactory#getBean(String)}.\n\t * Subclasses may provide additional arguments or other customizations.\n\t * @param beanName the bean name, as a candidate result for this dependency\n\t * @param requiredType the expected type of the bean (as an assertion)\n\t * @param beanFactory the associated factory\n\t * @return the bean instance (never {@code null})\n\t * @throws BeansException if the bean could not be obtained\n\t * @since 4.3.2\n\t * @see BeanFactory#getBean(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "requiredType",
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "Object",
    "signature": "public Object resolveCandidate(String beanName, Class<?> requiredType, BeanFactory beanFactory)",
    "source_code": "\tpublic Object resolveCandidate(String beanName, Class<?> requiredType, BeanFactory beanFactory)"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#resolveNotUnique(type,Map<String,matchingBeans)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the specified not-unique scenario: by default,\n\t * throwing a {@link NoUniqueBeanDefinitionException}.\n\t * <p>Subclasses may override this to select one of the instances or\n\t * to opt out with no result at all through returning {@code null}.\n\t * @param type the requested bean type\n\t * @param matchingBeans a map of bean names and corresponding bean\n\t * instances which have been pre-selected for the given type\n\t * (qualifiers etc already applied)\n\t * @return a bean instance to proceed with, or {@code null} for none\n\t * @throws BeansException in case of the not-unique scenario being fatal\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "Map<String",
      "matchingBeans"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "Object",
    "signature": "public Object resolveNotUnique(ResolvableType type, Map<String, Object> matchingBeans)",
    "source_code": "\tpublic Object resolveNotUnique(ResolvableType type, Map<String, Object> matchingBeans) throws BeansException {\n\t\tthrow new NoUniqueBeanDefinitionException(type, matchingBeans.keySet());\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#resolveShortcut(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve a shortcut for this dependency against the given factory, for example\n\t * taking some pre-resolved information into account.\n\t * <p>The resolution algorithm will first attempt to resolve a shortcut through this\n\t * method before going into the regular type matching algorithm across all beans.\n\t * Subclasses may override this method to improve resolution performance based on\n\t * pre-cached information while still receiving {@link InjectionPoint} exposure etc.\n\t * @param beanFactory the associated factory\n\t * @return the shortcut result if any, or {@code null} if none\n\t * @throws BeansException if the shortcut could not be obtained\n\t * @since 4.3.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 234
    },
    "return": "Object",
    "signature": "public Object resolveShortcut(BeanFactory beanFactory)",
    "source_code": "\tpublic Object resolveShortcut(BeanFactory beanFactory) throws BeansException {\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#setContainingClass(containingClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Optionally set the concrete class that contains this dependency.\n\t * This may differ from the class that declares the parameter/field in that\n\t * it may be a subclass thereof, potentially substituting type variables.\n\t * @since 4.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "containingClass"
    ],
    "position": {
      "column": 1,
      "line": 275
    },
    "return": "void",
    "signature": "public void setContainingClass(Class<?> containingClass)",
    "source_code": "\tpublic void setContainingClass(Class<?> containingClass) {\n\t\tthis.containingClass = containingClass;\n\t\tthis.resolvableType = null;\n\t\tif (this.methodParameter != null) {\n\t\t\tthis.methodParameter = this.methodParameter.withContainingClass(containingClass);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#supportsLazyResolution()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether this dependency supports lazy resolution,\n\t * e.g. through extra proxying. The default is {@code true}.\n\t * @since 6.1.2\n\t * @see org.springframework.beans.factory.support.AutowireCandidateResolver#getLazyResolutionProxyIfNecessary\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 388
    },
    "return": "boolean",
    "signature": "public boolean supportsLazyResolution()",
    "source_code": "\tpublic boolean supportsLazyResolution() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.beans.factory.config.DependencyDescriptor#usesStandardBeanLookup()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether this descriptor uses a standard bean lookup\n\t * in {@link #resolveCandidate(String, Class, BeanFactory)} and\n\t * therefore qualifies for factory-level shortcut resolution.\n\t * <p>By default, the {@code DependencyDescriptor} class itself\n\t * uses a standard bean lookup but subclasses may override this.\n\t * If a subclass overrides other methods but preserves a standard\n\t * bean lookup, it may override this method to return {@code true}.\n\t * @since 6.2\n\t * @see #resolveCandidate(String, Class, BeanFactory)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 403
    },
    "return": "boolean",
    "signature": "public boolean usesStandardBeanLookup()",
    "source_code": "\tpublic boolean usesStandardBeanLookup() {\n\t\treturn (getClass() == DependencyDescriptor.class);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#usesStandardBeanLookup()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1447
    },
    "return": "boolean",
    "signature": "public boolean usesStandardBeanLookup()",
    "source_code": "\t\tpublic boolean usesStandardBeanLookup() {\n\t\t\treturn true;\n\t\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinition#isBackgroundInit()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the bootstrap mode for this bean: default is {@code false} for using\n\t * the main pre-instantiation thread for non-lazy singleton beans and the caller\n\t * thread for prototype beans.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 606
    },
    "return": "boolean",
    "signature": "public boolean isBackgroundInit()",
    "source_code": "\tpublic boolean isBackgroundInit() {\n\t\treturn this.backgroundInit;\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinition#isDefaultCandidate()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether this bean is a candidate for getting autowired into some other\n\t * bean based on the plain type, without any further indications such as a\n\t * qualifier match?\n\t * <p>The default is {@code true}.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 768
    },
    "return": "boolean",
    "signature": "public boolean isDefaultCandidate()",
    "source_code": "\tpublic boolean isDefaultCandidate() {\n\t\treturn this.defaultCandidate;\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinition#isFallback()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p>The default is {@code false}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 804
    },
    "return": "boolean",
    "signature": "public boolean isFallback()",
    "source_code": "\tpublic boolean isFallback() {\n\t\treturn this.fallback;\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinition#setBackgroundInit(backgroundInit)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the bootstrap mode for this bean: default is {@code false} for using\n\t * the main pre-instantiation thread for non-lazy singleton beans and the caller\n\t * thread for prototype beans.\n\t * <p>Set this flag to {@code true} to allow for instantiating this bean on a\n\t * background thread. For a non-lazy singleton, a background pre-instantiation\n\t * thread can be used then, while still enforcing the completion at the end of\n\t * {@link DefaultListableBeanFactory#preInstantiateSingletons()}.\n\t * For a lazy singleton, a background pre-instantiation thread can be used as well\n\t * - with completion allowed at a later point, enforcing it when actually accessed.\n\t * <p>Note that this flag may be ignored by bean factories not set up for\n\t * background bootstrapping, always applying single-threaded bootstrapping\n\t * for non-lazy singleton beans.\n\t * @since 6.2\n\t * @see #setLazyInit\n\t * @see DefaultListableBeanFactory#setBootstrapExecutor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "backgroundInit"
    ],
    "position": {
      "column": 1,
      "line": 596
    },
    "return": "void",
    "signature": "public void setBackgroundInit(boolean backgroundInit)",
    "source_code": "\tpublic void setBackgroundInit(boolean backgroundInit) {\n\t\tthis.backgroundInit = backgroundInit;\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinition#setDefaultCandidate(defaultCandidate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether this bean is a candidate for getting autowired into some other\n\t * bean based on the plain type, without any further indications such as a\n\t * qualifier match.\n\t * <p>The default is {@code true}, allowing injection by type at any injection point.\n\t * Switch this to {@code false} in order to restrict injection by default,\n\t * effectively enforcing an additional indication such as a qualifier match.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultCandidate"
    ],
    "position": {
      "column": 1,
      "line": 757
    },
    "return": "void",
    "signature": "public void setDefaultCandidate(boolean defaultCandidate)",
    "source_code": "\tpublic void setDefaultCandidate(boolean defaultCandidate) {\n\t\tthis.defaultCandidate = defaultCandidate;\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinition#setFallback(fallback)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p>The default is {@code false}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fallback"
    ],
    "position": {
      "column": 1,
      "line": 795
    },
    "return": "void",
    "signature": "public void setFallback(boolean fallback)",
    "source_code": "\tpublic void setFallback(boolean fallback) {\n\t\tthis.fallback = fallback;\n\t}"
  },
  "org.springframework.beans.factory.support.DefaultListableBeanFactory#checkMergedBeanDefinition(mbd,beanName,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mbd",
      "beanName",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 983
    },
    "return": "void",
    "signature": "protected void checkMergedBeanDefinition(RootBeanDefinition mbd, String beanName, @Nullable Object[] args)",
    "source_code": "\tprotected void checkMergedBeanDefinition(RootBeanDefinition mbd, String beanName, @Nullable Object[] args) {\n\t\tsuper.checkMergedBeanDefinition(mbd, beanName, args);\n\n\t\tif (mbd.isBackgroundInit()) {\n\t\t\tif (this.preInstantiationThread.get() == PreInstantiation.MAIN && getBootstrapExecutor() != null) {\n\t\t\t\tthrow new BeanCurrentlyInCreationException(beanName, \"Bean marked for background \" +\n\t\t\t\t\t\t\"initialization but requested in mainline thread - declare ObjectProvider \" +\n\t\t\t\t\t\t\"or lazy injection point in dependent mainline beans\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Bean intended to be initialized in main bootstrap thread\n\t\t\tif (this.preInstantiationThread.get() == PreInstantiation.BACKGROUND) {\n\t\t\t\tthrow new BeanCurrentlyInCreationException(beanName, \"Bean marked for mainline initialization \" +\n\t\t\t\t\t\t\"but requested in background thread - enforce early instantiation in mainline thread \" +\n\t\t\t\t\t\t\"through depends-on '\" + beanName + \"' declaration for dependent background beans\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.DefaultListableBeanFactory#getBootstrapExecutor()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "Executor",
    "signature": "public Executor getBootstrapExecutor()",
    "source_code": "\tpublic Executor getBootstrapExecutor() {\n\t\treturn this.bootstrapExecutor;\n\t}"
  },
  "org.springframework.beans.factory.support.DefaultListableBeanFactory#isCurrentThreadAllowedToHoldSingletonLock()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1004
    },
    "return": "boolean",
    "signature": "protected boolean isCurrentThreadAllowedToHoldSingletonLock()",
    "source_code": "\tprotected boolean isCurrentThreadAllowedToHoldSingletonLock() {\n\t\treturn (this.preInstantiationThread.get() != PreInstantiation.BACKGROUND);\n\t}"
  },
  "org.springframework.beans.factory.support.DefaultListableBeanFactory#setBootstrapExecutor(bootstrapExecutor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bootstrapExecutor"
    ],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "void",
    "signature": "public void setBootstrapExecutor(@Nullable Executor bootstrapExecutor)",
    "source_code": "\tpublic void setBootstrapExecutor(@Nullable Executor bootstrapExecutor) {\n\t\tthis.bootstrapExecutor = bootstrapExecutor;\n\t}"
  },
  "org.springframework.beans.factory.support.DefaultListableBeanFactory#usesStandardBeanLookup()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 2399
    },
    "return": "boolean",
    "signature": "public boolean usesStandardBeanLookup()",
    "source_code": "\t\t\t\tpublic boolean usesStandardBeanLookup() {\n\t\t\t\t\treturn true;\n\t\t\t\t}"
  },
  "org.springframework.cache.annotation.AnnotationCacheOperationSource#setPublicMethodsOnly(publicMethodsOnly)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether cacheable methods are expected to be public.\n\t * <p>The default is {@code true}.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "publicMethodsOnly"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "void",
    "signature": "public void setPublicMethodsOnly(boolean publicMethodsOnly)",
    "source_code": "\tpublic void setPublicMethodsOnly(boolean publicMethodsOnly) {\n\t\tthis.publicMethodsOnly = publicMethodsOnly;\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.<unknown>#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other || (other instanceof JCacheOperationSourceClassFilter that &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(getCacheOperationSource(), that.getCacheOperationSource())));\n\t\t}"
  },
  "org.springframework.cache.jcache.interceptor.<unknown>#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\t\tpublic int hashCode() {\n\t\t\treturn JCacheOperationSourceClassFilter.class.hashCode();\n\t\t}"
  },
  "org.springframework.cache.jcache.interceptor.<unknown>#matches(clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "boolean",
    "signature": "public boolean matches(Class<?> clazz)",
    "source_code": "\t\tpublic boolean matches(Class<?> clazz) {\n\t\t\tif (CacheManager.class.isAssignableFrom(clazz)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn (cacheOperationSource == null || cacheOperationSource.isCandidateClass(clazz));\n\t\t}"
  },
  "org.springframework.cache.jcache.interceptor.<unknown>#matches(method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\treturn (this.cacheOperationSource == null ||\n\t\t\t\tthis.cacheOperationSource.hasCacheOperation(method, targetClass));\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.<unknown>#setCacheOperationSource(cacheOperationSource)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cacheOperationSource"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "return": "void",
    "signature": "public void setCacheOperationSource(@Nullable JCacheOperationSource cacheOperationSource)",
    "source_code": "\tpublic void setCacheOperationSource(@Nullable JCacheOperationSource cacheOperationSource) {\n\t\tthis.cacheOperationSource = cacheOperationSource;\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.<unknown>#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn JCacheOperationSourceClassFilter.class.getName() + \": \" + getCacheOperationSource();\n\t\t}"
  },
  "org.springframework.cache.jcache.interceptor.BeanFactoryJCacheOperationSourceAdvisor": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Advisor driven by a {@link JCacheOperationSource}, used to include a\n * cache advice bean for methods that are cacheable.\n *\n * @author Stephane Nicoll\n * @author Juergen Hoeller\n * @since 4.1\n * @see #setAdviceBeanName\n * @see JCacheInterceptor\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 40
    },
    "signature": "public class BeanFactoryJCacheOperationSourceAdvisor",
    "source_code": "public class BeanFactoryJCacheOperationSourceAdvisor extends AbstractBeanFactoryPointcutAdvisor {\n\n\tprivate final JCacheOperationSourcePointcut pointcut = new JCacheOperationSourcePointcut();\n\n\n\t/**\n\t * Set the cache operation attribute source which is used to find cache\n\t * attributes. This should usually be identical to the source reference\n\t * set on the cache interceptor itself.\n\t * @see JCacheInterceptor#setCacheOperationSource\n\t */\n\tpublic void setCacheOperationSource(JCacheOperationSource cacheOperationSource) {\n\t\tthis.pointcut.setCacheOperationSource(cacheOperationSource);\n\t}\n\n\t/**\n\t * Set the {@link org.springframework.aop.ClassFilter} to use for this pointcut.\n\t * Default is {@link org.springframework.aop.ClassFilter#TRUE}.\n\t */\n\tpublic void setClassFilter(ClassFilter classFilter) {\n\t\tthis.pointcut.setClassFilter(classFilter);\n\t}\n\n\t@Override\n\tpublic Pointcut getPointcut() {\n\t\treturn this.pointcut;\n\t}\n\n\n\tprivate static class JCacheOperationSourcePointcut extends StaticMethodMatcherPointcut implements Serializable {\n\n\t\t@Nullable\n\t\tprivate JCacheOperationSource cacheOperationSource;\n\n\t\tpublic void setCacheOperationSource(@Nullable JCacheOperationSource cacheOperationSource) {\n\t\t\tthis.cacheOperationSource = cacheOperationSource;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\t\treturn (this.cacheOperationSource == null ||\n\t\t\t\t\tthis.cacheOperationSource.getCacheOperation(method, targetClass) != null);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other || (other instanceof JCacheOperationSourcePointcut that &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.cacheOperationSource, that.cacheOperationSource)));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn JCacheOperationSourcePointcut.class.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn getClass().getName() + \": \" + this.cacheOperationSource;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.cache.jcache.interceptor.BeanFactoryJCacheOperationSourceAdvisor#equals(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other || (other instanceof JCacheOperationSourcePointcut that &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.cacheOperationSource, that.cacheOperationSource)));\n\t\t}"
  },
  "org.springframework.cache.jcache.interceptor.BeanFactoryJCacheOperationSourceAdvisor#getPointcut()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "Pointcut",
    "signature": "public Pointcut getPointcut()",
    "source_code": "\tpublic Pointcut getPointcut() {\n\t\treturn this.pointcut;\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.BeanFactoryJCacheOperationSourceAdvisor#hashCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\t\tpublic int hashCode() {\n\t\t\treturn JCacheOperationSourcePointcut.class.hashCode();\n\t\t}"
  },
  "org.springframework.cache.jcache.interceptor.BeanFactoryJCacheOperationSourceAdvisor#matches(method,targetClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\t\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\t\treturn (this.cacheOperationSource == null ||\n\t\t\t\t\tthis.cacheOperationSource.getCacheOperation(method, targetClass) != null);\n\t\t}"
  },
  "org.springframework.cache.jcache.interceptor.BeanFactoryJCacheOperationSourceAdvisor#setCacheOperationSource(cacheOperationSource)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cacheOperationSource"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "public void setCacheOperationSource(@Nullable JCacheOperationSource cacheOperationSource)",
    "source_code": "\t\tpublic void setCacheOperationSource(@Nullable JCacheOperationSource cacheOperationSource) {\n\t\t\tthis.cacheOperationSource = cacheOperationSource;\n\t\t}"
  },
  "org.springframework.cache.jcache.interceptor.BeanFactoryJCacheOperationSourceAdvisor#setClassFilter(classFilter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link org.springframework.aop.ClassFilter} to use for this pointcut.\n\t * Default is {@link org.springframework.aop.ClassFilter#TRUE}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classFilter"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "void",
    "signature": "public void setClassFilter(ClassFilter classFilter)",
    "source_code": "\tpublic void setClassFilter(ClassFilter classFilter) {\n\t\tthis.pointcut.setClassFilter(classFilter);\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.BeanFactoryJCacheOperationSourceAdvisor#toString()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn getClass().getName() + \": \" + this.cacheOperationSource;\n\t\t}"
  },
  "org.springframework.cache.jcache.interceptor.JCacheOperationSourcePointcut": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * A {@code Pointcut} that matches if the underlying {@link JCacheOperationSource}\n * has an operation for a given method.\n *\n * @author Stephane Nicoll\n * @since 4.1\n * @deprecated since 6.0.10, as it is not used by the framework anymore\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 36
    },
    "signature": "public class JCacheOperationSourcePointcut",
    "source_code": "public abstract class JCacheOperationSourcePointcut extends StaticMethodMatcherPointcut implements Serializable {\n\n\t@Override\n\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\tJCacheOperationSource cas = getCacheOperationSource();\n\t\treturn (cas != null && cas.getCacheOperation(method, targetClass) != null);\n\t}\n\n\t/**\n\t * Obtain the underlying {@link JCacheOperationSource} (may be {@code null}).\n\t * To be implemented by subclasses.\n\t */\n\t@Nullable\n\tprotected abstract JCacheOperationSource getCacheOperationSource();\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof JCacheOperationSourcePointcut that &&\n\t\t\t\tObjectUtils.nullSafeEquals(getCacheOperationSource(), that.getCacheOperationSource())));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn JCacheOperationSourcePointcut.class.hashCode();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getClass().getName() + \": \" + getCacheOperationSource();\n\t}\n\n}"
  },
  "org.springframework.cache.jcache.interceptor.JCacheOperationSourcePointcut#equals(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof JCacheOperationSourcePointcut that &&\n\t\t\t\tObjectUtils.nullSafeEquals(getCacheOperationSource(), that.getCacheOperationSource())));\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.JCacheOperationSourcePointcut#getCacheOperationSource()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain the underlying {@link JCacheOperationSource} (may be {@code null}).\n\t * To be implemented by subclasses.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 49
    },
    "return": "JCacheOperationSource",
    "signature": "protected JCacheOperationSource getCacheOperationSource()",
    "source_code": "\tprotected abstract JCacheOperationSource getCacheOperationSource();"
  },
  "org.springframework.cache.jcache.interceptor.JCacheOperationSourcePointcut#hashCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn JCacheOperationSourcePointcut.class.hashCode();\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.JCacheOperationSourcePointcut#matches(method,targetClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\tJCacheOperationSource cas = getCacheOperationSource();\n\t\treturn (cas != null && cas.getCacheOperation(method, targetClass) != null);\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.JCacheOperationSourcePointcut#toString()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn getClass().getName() + \": \" + getCacheOperationSource();\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#add(deferredImport)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "deferredImport"
    ],
    "position": {
      "column": 1,
      "line": 803
    },
    "return": "void",
    "signature": "public void add(DeferredImportSelectorHolder deferredImport)",
    "source_code": "\t\tpublic void add(DeferredImportSelectorHolder deferredImport) {\n\t\t\tthis.deferredImports.add(deferredImport);\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#getCandidateFilter()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 819
    },
    "return": "Predicate<String>",
    "signature": "public Predicate<String> getCandidateFilter()",
    "source_code": "\t\tpublic Predicate<String> getCandidateFilter() {\n\t\t\tPredicate<String> mergedFilter = DEFAULT_EXCLUSION_FILTER;\n\t\t\tfor (DeferredImportSelectorHolder deferredImport : this.deferredImports) {\n\t\t\t\tPredicate<String> selectorFilter = deferredImport.getImportSelector().getExclusionFilter();\n\t\t\t\tif (selectorFilter != null) {\n\t\t\t\t\tmergedFilter = mergedFilter.or(selectorFilter);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn mergedFilter;\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#getConfigurationClass()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 783
    },
    "return": "ConfigurationClass",
    "signature": "public ConfigurationClass getConfigurationClass()",
    "source_code": "\t\tpublic ConfigurationClass getConfigurationClass() {\n\t\t\treturn this.configurationClass;\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#getConfigurationClasses()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "Set<ConfigurationClass>",
    "signature": "public Set<ConfigurationClass> getConfigurationClasses()",
    "source_code": "\tpublic Set<ConfigurationClass> getConfigurationClasses() {\n\t\treturn this.configurationClasses.keySet();\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#getImportSelector()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 787
    },
    "return": "DeferredImportSelector",
    "signature": "public DeferredImportSelector getImportSelector()",
    "source_code": "\t\tpublic DeferredImportSelector getImportSelector() {\n\t\t\treturn this.importSelector;\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#handle(configClass,importSelector)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Handle the specified {@link DeferredImportSelector}. If deferred import\n\t\t * selectors are being collected, this registers this instance to the list. If\n\t\t * they are being processed, the {@link DeferredImportSelector} is also processed\n\t\t * immediately according to its {@link DeferredImportSelector.Group}.\n\t\t * @param configClass the source configuration class\n\t\t * @param importSelector the selector to handle\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "configClass",
      "importSelector"
    ],
    "position": {
      "column": 1,
      "line": 694
    },
    "return": "void",
    "signature": "public void handle(ConfigurationClass configClass, DeferredImportSelector importSelector)",
    "source_code": "\t\tpublic void handle(ConfigurationClass configClass, DeferredImportSelector importSelector) {\n\t\t\tDeferredImportSelectorHolder holder = new DeferredImportSelectorHolder(configClass, importSelector);\n\t\t\tif (this.deferredImportSelectors == null) {\n\t\t\t\tDeferredImportSelectorGroupingHandler handler = new DeferredImportSelectorGroupingHandler();\n\t\t\t\thandler.register(holder);\n\t\t\t\thandler.processGroupImports();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.deferredImportSelectors.add(holder);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#parse(className,beanName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "className",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "void",
    "signature": "protected void parse(@Nullable String className, String beanName)",
    "source_code": "\tprotected final void parse(@Nullable String className, String beanName) throws IOException {\n\t\tAssert.notNull(className, \"No bean class name for configuration class bean definition\");\n\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(className);\n\t\tprocessConfigurationClass(new ConfigurationClass(reader, beanName), DEFAULT_EXCLUSION_FILTER);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#parse(clazz,beanName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "void",
    "signature": "protected void parse(Class<?> clazz, String beanName)",
    "source_code": "\tprotected final void parse(Class<?> clazz, String beanName) throws IOException {\n\t\tprocessConfigurationClass(new ConfigurationClass(clazz, beanName), DEFAULT_EXCLUSION_FILTER);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#parse(metadata,beanName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "metadata",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "void",
    "signature": "protected void parse(AnnotationMetadata metadata, String beanName)",
    "source_code": "\tprotected final void parse(AnnotationMetadata metadata, String beanName) throws IOException {\n\t\tprocessConfigurationClass(new ConfigurationClass(metadata, beanName), DEFAULT_EXCLUSION_FILTER);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#process()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 706
    },
    "return": "void",
    "signature": "public void process()",
    "source_code": "\t\tpublic void process() {\n\t\t\tList<DeferredImportSelectorHolder> deferredImports = this.deferredImportSelectors;\n\t\t\tthis.deferredImportSelectors = null;\n\t\t\ttry {\n\t\t\t\tif (deferredImports != null) {\n\t\t\t\t\tDeferredImportSelectorGroupingHandler handler = new DeferredImportSelectorGroupingHandler();\n\t\t\t\t\tdeferredImports.sort(DEFERRED_IMPORT_COMPARATOR);\n\t\t\t\t\tdeferredImports.forEach(handler::register);\n\t\t\t\t\thandler.processGroupImports();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.deferredImportSelectors = new ArrayList<>();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#processGroupImports()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 740
    },
    "return": "void",
    "signature": "public void processGroupImports()",
    "source_code": "\t\tpublic void processGroupImports() {\n\t\t\tfor (DeferredImportSelectorGrouping grouping : this.groupings.values()) {\n\t\t\t\tPredicate<String> exclusionFilter = grouping.getCandidateFilter();\n\t\t\t\tgrouping.getImports().forEach(entry -> {\n\t\t\t\t\tConfigurationClass configurationClass = this.configurationClasses.get(entry.getMetadata());\n\t\t\t\t\ttry {\n\t\t\t\t\t\tprocessImports(configurationClass, asSourceClass(configurationClass, exclusionFilter),\n\t\t\t\t\t\t\t\tCollections.singleton(asSourceClass(entry.getImportClassName(), exclusionFilter)),\n\t\t\t\t\t\t\t\texclusionFilter, false);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (BeanDefinitionStoreException ex) {\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tthrow new BeanDefinitionStoreException(\n\t\t\t\t\t\t\t\t\"Failed to process import candidates for configuration class [\" +\n\t\t\t\t\t\t\t\t\t\tconfigurationClass.getMetadata().getClassName() + \"]\", ex);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#register(deferredImport)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "deferredImport"
    ],
    "position": {
      "column": 1,
      "line": 730
    },
    "return": "void",
    "signature": "public void register(DeferredImportSelectorHolder deferredImport)",
    "source_code": "\t\tpublic void register(DeferredImportSelectorHolder deferredImport) {\n\t\t\tClass<? extends Group> group = deferredImport.getImportSelector().getImportGroup();\n\t\t\tDeferredImportSelectorGrouping grouping = this.groupings.computeIfAbsent(\n\t\t\t\t\t(group != null ? group : deferredImport),\n\t\t\t\t\tkey -> new DeferredImportSelectorGrouping(createGroup(group)));\n\t\t\tgrouping.add(deferredImport);\n\t\t\tthis.configurationClasses.put(deferredImport.getConfigurationClass().getMetadata(),\n\t\t\t\t\tdeferredImport.getConfigurationClass());\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerImport(importingClass,importedClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "importingClass",
      "importedClass"
    ],
    "position": {
      "column": 1,
      "line": 639
    },
    "return": "void",
    "signature": "public void registerImport(AnnotationMetadata importingClass, String importedClass)",
    "source_code": "\t\tpublic void registerImport(AnnotationMetadata importingClass, String importedClass) {\n\t\t\tthis.imports.add(importedClass, importingClass);\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#validate()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Validate each {@link ConfigurationClass} object.\n\t * @see ConfigurationClass#validate\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "void",
    "signature": "public void validate()",
    "source_code": "\tpublic void validate() {\n\t\tfor (ConfigurationClass configClass : this.configurationClasses.keySet()) {\n\t\t\tconfigClass.validate(this.problemReporter);\n\t\t}\n\t}"
  },
  "org.springframework.context.event.ApplicationListenerMethodAdapter#isDefaultExecution()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether default execution is applicable for the target listener.\n\t * @since 6.2\n\t * @see #onApplicationEvent\n\t * @see EventListener#defaultExecution()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "boolean",
    "signature": "protected boolean isDefaultExecution()",
    "source_code": "\tprotected boolean isDefaultExecution() {\n\t\treturn this.defaultExecution;\n\t}"
  },
  "org.springframework.context.support.AbstractApplicationContext#clearResourceCaches()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1025
    },
    "return": "void",
    "signature": "public void clearResourceCaches()",
    "source_code": "\tpublic void clearResourceCaches() {\n\t\tsuper.clearResourceCaches();\n\t\tif (this.resourcePatternResolver instanceof PathMatchingResourcePatternResolver pmrpr) {\n\t\t\tpmrpr.clearCache();\n\t\t}\n\t}"
  },
  "org.springframework.core.ResolvableType#isAssignableFrom(type,Map<Type,matchedBefore)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return {@code true} if these bounds are assignable from the specified type.\n\t\t * @param type the type to test against\n\t\t * @return {@code true} if these bounds are assignable from the type\n\t\t * @since 6.2\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "Map<Type",
      "matchedBefore"
    ],
    "position": {
      "column": 1,
      "line": 1726
    },
    "return": "boolean",
    "signature": "public boolean isAssignableFrom(ResolvableType type, @Nullable Map<Type, Type> matchedBefore)",
    "source_code": "\t\tpublic boolean isAssignableFrom(ResolvableType type, @Nullable Map<Type, Type> matchedBefore) {\n\t\t\tfor (ResolvableType bound : this.bounds) {\n\t\t\t\tif (this.kind == Kind.UPPER ? !bound.isAssignableFrom(type, false, matchedBefore, false) :\n\t\t\t\t\t\t!type.isAssignableFrom(bound, false, matchedBefore, false)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}"
  },
  "org.springframework.core.ResolvableType#isAssignableFrom(types)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return {@code true} if this bounds is assignable to all the specified types.\n\t\t * @param types the types to test against\n\t\t * @return {@code true} if this bounds is assignable to all types\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "types"
    ],
    "position": {
      "column": 1,
      "line": 1659
    },
    "return": "boolean",
    "signature": "public boolean isAssignableFrom(ResolvableType... types)",
    "source_code": "\t\tpublic boolean isAssignableFrom(ResolvableType... types) {\n\t\t\tfor (ResolvableType bound : this.bounds) {\n\t\t\t\tfor (ResolvableType type : types) {\n\t\t\t\t\tif (!isAssignable(bound, type)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}"
  },
  "org.springframework.core.ResolvableType#isAssignableFrom(types,Map<Type,matchedBefore)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return {@code true} if these bounds are assignable from all the specified types.\n\t\t * @param types the types to test against\n\t\t * @return {@code true} if these bounds are assignable from all types\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "types",
      "Map<Type",
      "matchedBefore"
    ],
    "position": {
      "column": 1,
      "line": 1711
    },
    "return": "boolean",
    "signature": "public boolean isAssignableFrom(ResolvableType[] types, @Nullable Map<Type, Type> matchedBefore)",
    "source_code": "\t\tpublic boolean isAssignableFrom(ResolvableType[] types, @Nullable Map<Type, Type> matchedBefore) {\n\t\t\tfor (ResolvableType type : types) {\n\t\t\t\tif (!isAssignableFrom(type, matchedBefore)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}"
  },
  "org.springframework.core.ResolvableType#isAssignableFromResolvedPart(other)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether this {@code ResolvableType} is assignable from the\n\t * specified other type, as far as the other type is actually resolvable.\n\t * @param other the type to be checked against (as a {@code ResolvableType})\n\t * @return {@code true} if the specified other type can be assigned to this\n\t * {@code ResolvableType} as far as it is resolvable; {@code false} otherwise\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "boolean",
    "signature": "public boolean isAssignableFromResolvedPart(ResolvableType other)",
    "source_code": "\tpublic boolean isAssignableFromResolvedPart(ResolvableType other) {\n\t\treturn isAssignableFrom(other, false, null, true);\n\t}"
  },
  "org.springframework.core.ResolvableType#isAssignableTo(type,Map<Type,matchedBefore)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return {@code true} if these bounds are assignable to the specified type.\n\t\t * @param type the type to test against\n\t\t * @return {@code true} if these bounds are assignable to the type\n\t\t * @since 6.2\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "Map<Type",
      "matchedBefore"
    ],
    "position": {
      "column": 1,
      "line": 1742
    },
    "return": "boolean",
    "signature": "public boolean isAssignableTo(ResolvableType type, @Nullable Map<Type, Type> matchedBefore)",
    "source_code": "\t\tpublic boolean isAssignableTo(ResolvableType type, @Nullable Map<Type, Type> matchedBefore) {\n\t\t\tif (this.kind == Kind.UPPER) {\n\t\t\t\tfor (ResolvableType bound : this.bounds) {\n\t\t\t\t\tif (type.isAssignableFrom(bound, false, matchedBefore, false)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn (type.resolve() == Object.class);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.core.io.support.PathMatchingResourcePatternResolver#clearCache()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Clear the local resource cache, removing all cached classpath/jar structures.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 369
    },
    "return": "void",
    "signature": "public void clearCache()",
    "source_code": "\tpublic void clearCache() {\n\t\tthis.rootDirCache.clear();\n\t\tthis.jarEntryCache.clear();\n\t}"
  },
  "org.springframework.expression.spel.ast.Indexer#isNullSafe()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Does this node represent a null-safe index operation?\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 212
    },
    "return": "boolean",
    "signature": "public boolean isNullSafe()",
    "source_code": "\tpublic final boolean isNullSafe() {\n\t\treturn this.nullSafe;\n\t}"
  },
  "org.springframework.expression.spel.support.OptimalPropertyAccessor": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * An optimized form of a PropertyAccessor that will use reflection but only knows\n\t * how to access a particular property on a particular class. This is unlike the\n\t * general ReflectivePropertyResolver which manages a cache of methods/fields that\n\t * may be invoked to access different properties on different classes. This optimal\n\t * accessor exists because looking up the appropriate reflective object by class/name\n\t * on each read is not cheap.\n\t */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 635
    },
    "signature": "public class OptimalPropertyAccessor",
    "source_code": "\tpublic static class OptimalPropertyAccessor implements CompilablePropertyAccessor {\n\n\t\t/**\n\t\t * The member being accessed.\n\t\t */\n\t\tpublic final Member member;\n\n\t\tprivate final TypeDescriptor typeDescriptor;\n\n\t\tOptimalPropertyAccessor(InvokerPair target) {\n\t\t\tthis.member = target.member;\n\t\t\tthis.typeDescriptor = target.typeDescriptor;\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Class<?>[] getSpecificTargetClasses() {\n\t\t\tthrow new UnsupportedOperationException(\"Should not be called on an OptimalPropertyAccessor\");\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean canRead(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\t\tif (target == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tClass<?> type = (target instanceof Class<?> clazz ? clazz : target.getClass());\n\t\t\tif (type.isArray()) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (this.member instanceof Method method) {\n\t\t\t\tString getterName = \"get\" + StringUtils.capitalize(name);\n\t\t\t\tif (getterName.equals(method.getName())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tgetterName = \"is\" + StringUtils.capitalize(name);\n\t\t\t\tif (getterName.equals(method.getName())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.member.getName().equals(name);\n\t\t}\n\n\t\t@Override\n\t\tpublic TypedValue read(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\t\tif (this.member instanceof Method method) {\n\t\t\t\ttry {\n\t\t\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\t\t\tObject value = method.invoke(target);\n\t\t\t\t\treturn new TypedValue(value, this.typeDescriptor.narrow(value));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new AccessException(\"Unable to access property '\" + name + \"' through getter method\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tField field = (Field) this.member;\n\t\t\t\ttry {\n\t\t\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\t\t\tObject value = field.get(target);\n\t\t\t\t\treturn new TypedValue(value, this.typeDescriptor.narrow(value));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new AccessException(\"Unable to access field '\" + name + \"'\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean canWrite(EvaluationContext context, @Nullable Object target, String name) {\n\t\t\tthrow new UnsupportedOperationException(\"Should not be called on an OptimalPropertyAccessor\");\n\t\t}\n\n\t\t@Override\n\t\tpublic void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object newValue) {\n\t\t\tthrow new UnsupportedOperationException(\"Should not be called on an OptimalPropertyAccessor\");\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isCompilable() {\n\t\t\treturn (Modifier.isPublic(this.member.getModifiers()) &&\n\t\t\t\t\tModifier.isPublic(this.member.getDeclaringClass().getModifiers()));\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<?> getPropertyType() {\n\t\t\tif (this.member instanceof Method method) {\n\t\t\t\treturn method.getReturnType();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn ((Field) this.member).getType();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void generateCode(String propertyName, MethodVisitor mv, CodeFlow cf) {\n\t\t\tboolean isStatic = Modifier.isStatic(this.member.getModifiers());\n\t\t\tString descriptor = cf.lastDescriptor();\n\t\t\tString classDesc = this.member.getDeclaringClass().getName().replace('.', '/');\n\n\t\t\tif (!isStatic) {\n\t\t\t\tif (descriptor == null) {\n\t\t\t\t\tcf.loadTarget(mv);\n\t\t\t\t}\n\t\t\t\tif (descriptor == null || !classDesc.equals(descriptor.substring(1))) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, classDesc);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (descriptor != null) {\n\t\t\t\t\t// A static field/method call will not consume what is on the stack,\n\t\t\t\t\t// it needs to be popped off.\n\t\t\t\t\tmv.visitInsn(POP);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.member instanceof Method method) {\n\t\t\t\tboolean isInterface = method.getDeclaringClass().isInterface();\n\t\t\t\tint opcode = (isStatic ? INVOKESTATIC : isInterface ? INVOKEINTERFACE : INVOKEVIRTUAL);\n\t\t\t\tmv.visitMethodInsn(opcode, classDesc, method.getName(),\n\t\t\t\t\t\tCodeFlow.createSignatureDescriptor(method), isInterface);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmv.visitFieldInsn((isStatic ? GETSTATIC : GETFIELD), classDesc, this.member.getName(),\n\t\t\t\t\t\tCodeFlow.toJvmDescriptor(((Field) this.member).getType()));\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.support.ReflectivePropertyAccessor#equals(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 599
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other || (other instanceof PropertyCacheKey that &&\n\t\t\t\t\tthis.clazz == that.clazz && this.property.equals(that.property) &&\n\t\t\t\t\tthis.targetIsClass == that.targetIsClass));\n\t\t}"
  },
  "org.springframework.expression.spel.support.ReflectivePropertyAccessor#hashCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 606
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\t\tpublic int hashCode() {\n\t\t\treturn (this.clazz.hashCode() * 29 + this.property.hashCode());\n\t\t}"
  },
  "org.springframework.expression.spel.support.ReflectivePropertyAccessor#toString()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 611
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn \"PropertyCacheKey [clazz=\" + this.clazz.getName() + \", property=\" + this.property +\n\t\t\t\t\t\", targetIsClass=\" + this.targetIsClass + \"]\";\n\t\t}"
  },
  "org.springframework.expression.spel.support.member": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * The member being accessed.\n\t\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 640
    },
    "signature": "public Member member",
    "source_code": "\t\tpublic final Member member;",
    "type": "Member"
  },
  "org.springframework.http.APPLICATION_YAML": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Public constant media type for {@code application/yaml}.\n\t * @since 6.2\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 319
    },
    "signature": "public MediaType APPLICATION_YAML",
    "source_code": "\tpublic static final MediaType APPLICATION_YAML;",
    "type": "MediaType"
  },
  "org.springframework.http.APPLICATION_YAML_VALUE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A String equivalent of {@link MediaType#APPLICATION_YAML}.\n\t * @since 6.2\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 325
    },
    "signature": "public String APPLICATION_YAML_VALUE",
    "source_code": "\tpublic static final String APPLICATION_YAML_VALUE = \"application/yaml\";",
    "type": "String"
  },
  "org.springframework.http.RequestEntity": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Extension of {@link HttpEntity} that also exposes the HTTP method and the\n * target URL. For use in the {@code RestTemplate} to prepare requests with\n * and in {@code @Controller} methods to represent request input.\n *\n * <p>Example use with the {@code RestTemplate}:\n * <pre class=\"code\">\n * MyRequest body = ...\n * RequestEntity&lt;MyRequest&gt; request = RequestEntity\n *     .post(&quot;https://example.com/{foo}&quot;, &quot;bar&quot;)\n *     .accept(MediaType.APPLICATION_JSON)\n *     .body(body);\n * ResponseEntity&lt;MyResponse&gt; response = template.exchange(request, MyResponse.class);\n * </pre>\n *\n * <p>Example use in an {@code @Controller}:\n * <pre class=\"code\">\n * &#64;RequestMapping(\"/handle\")\n * public void handle(RequestEntity&lt;String&gt; request) {\n *   HttpMethod method = request.getMethod();\n *   URI url = request.getUrl();\n *   String body = request.getBody();\n * }\n * </pre>\n *\n * @author Arjen Poutsma\n * @author Sebastien Deleuze\n * @author Parviz Rozikov\n * @since 4.1\n * @param <T> the body type\n * @see #getMethod()\n * @see #getUrl()\n * @see org.springframework.web.client.RestOperations#exchange(RequestEntity, Class)\n * @see ResponseEntity\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "signature": "public class RequestEntity",
    "source_code": "public class RequestEntity<T> extends HttpEntity<T> {\n\n\t@Nullable\n\tprivate final HttpMethod method;\n\n\t@Nullable\n\tprivate final URI url;\n\n\t@Nullable\n\tprivate final Type type;\n\n\t/**\n\t * Constructor with method and URL but without body nor headers.\n\t * @param method the method\n\t * @param url the URL\n\t */\n\tpublic RequestEntity(HttpMethod method, URI url) {\n\t\tthis(null, null, method, url, null);\n\t}\n\n\t/**\n\t * Constructor with method, URL and body but without headers.\n\t * @param body the body\n\t * @param method the method\n\t * @param url the URL\n\t */\n\tpublic RequestEntity(@Nullable T body, HttpMethod method, URI url) {\n\t\tthis(body, null, method, url, null);\n\t}\n\n\t/**\n\t * Constructor with method, URL, body and type but without headers.\n\t * @param body the body\n\t * @param method the method\n\t * @param url the URL\n\t * @param type the type used for generic type resolution\n\t * @since 4.3\n\t */\n\tpublic RequestEntity(@Nullable T body, HttpMethod method, URI url, Type type) {\n\t\tthis(body, null, method, url, type);\n\t}\n\n\t/**\n\t * Constructor with method, URL and headers but without body.\n\t * @param headers the headers\n\t * @param method the method\n\t * @param url the URL\n\t */\n\tpublic RequestEntity(MultiValueMap<String, String> headers, HttpMethod method, URI url) {\n\t\tthis(null, headers, method, url, null);\n\t}\n\n\t/**\n\t * Constructor with method, URL, headers and body.\n\t * @param body the body\n\t * @param headers the headers\n\t * @param method the method\n\t * @param url the URL\n\t */\n\tpublic RequestEntity(@Nullable T body, @Nullable MultiValueMap<String, String> headers,\n\t\t\t@Nullable HttpMethod method, URI url) {\n\n\t\tthis(body, headers, method, url, null);\n\t}\n\n\t/**\n\t * Constructor with method, URL, headers, body and type.\n\t * @param body the body\n\t * @param headers the headers\n\t * @param method the method\n\t * @param url the URL\n\t * @param type the type used for generic type resolution\n\t * @since 4.3\n\t */\n\tpublic RequestEntity(@Nullable T body, @Nullable MultiValueMap<String, String> headers,\n\t\t\t@Nullable HttpMethod method, @Nullable URI url, @Nullable Type type) {\n\n\t\tsuper(body, headers);\n\t\tthis.method = method;\n\t\tthis.url = url;\n\t\tthis.type = type;\n\t}\n\n\n\t/**\n\t * Return the HTTP method of the request.\n\t * @return the HTTP method as an {@code HttpMethod} enum value\n\t */\n\t@Nullable\n\tpublic HttpMethod getMethod() {\n\t\treturn this.method;\n\t}\n\n\t/**\n\t * Return the {@link URI} for the target HTTP endpoint.\n\t * <p><strong>Note:</strong> This method raises\n\t * {@link UnsupportedOperationException} if the {@code RequestEntity} was\n\t * created with a URI template and variables rather than with a {@link URI}\n\t * instance. This is because a URI cannot be created without further input\n\t * on how to expand template and encode the URI. In such cases, the\n\t * {@code URI} is prepared by the\n\t * {@link org.springframework.web.client.RestTemplate} with the help of the\n\t * {@link org.springframework.web.util.UriTemplateHandler} it is configured with.\n\t */\n\tpublic URI getUrl() {\n\t\tif (this.url == null) {\n\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\"The RequestEntity was created with a URI template and variables, \" +\n\t\t\t\t\t\t\t\"and there is not enough information on how to correctly expand and \" +\n\t\t\t\t\t\t\t\"encode the URI template. This will be done by the RestTemplate instead \" +\n\t\t\t\t\t\t\t\"with help from the UriTemplateHandler it is configured with.\");\n\t\t}\n\t\treturn this.url;\n\t}\n\n\n\t/**\n\t * Return the type of the request's body.\n\t * @return the request's body type, or {@code null} if not known\n\t * @since 4.3\n\t */\n\t@Nullable\n\tpublic Type getType() {\n\t\tif (this.type == null) {\n\t\t\tT body = getBody();\n\t\t\tif (body != null) {\n\t\t\t\treturn body.getClass();\n\t\t\t}\n\t\t}\n\t\treturn this.type;\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!super.equals(other)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (other instanceof RequestEntity<?> otherEntity &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.method, otherEntity.method) &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.url, otherEntity.url));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tint hashCode = super.hashCode();\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(this.method);\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(this.url);\n\t\treturn hashCode;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn format(getMethod(), getUrl().toString(), getBody(), getHeaders());\n\t}\n\n\tstatic <T> String format(@Nullable HttpMethod httpMethod, String url, @Nullable T body, HttpHeaders headers) {\n\t\tStringBuilder builder = new StringBuilder(\"<\");\n\t\tbuilder.append(httpMethod);\n\t\tbuilder.append(' ');\n\t\tbuilder.append(url);\n\t\tbuilder.append(',');\n\t\tif (body != null) {\n\t\t\tbuilder.append(body);\n\t\t\tbuilder.append(',');\n\t\t}\n\t\tbuilder.append(headers);\n\t\tbuilder.append('>');\n\t\treturn builder.toString();\n\t}\n\n\n\t// Static builder methods\n\n\t/**\n\t * Create a builder with the given method and url.\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param url the URL\n\t * @return the created builder\n\t */\n\tpublic static BodyBuilder method(HttpMethod method, URI url) {\n\t\treturn new DefaultBodyBuilder(method, url);\n\t}\n\n\t/**\n\t * Create a builder with the given HTTP method, URI template, and variables.\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */\n\tpublic static BodyBuilder method(HttpMethod method, String uriTemplate, Object... uriVariables) {\n\t\treturn new DefaultBodyBuilder(method, uriTemplate, uriVariables);\n\t}\n\n\t/**\n\t * Create a builder with the given HTTP method, URI template, and variables.\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param uriTemplate the uri template to use\n\t * @return the created builder\n\t * @since 5.3\n\t */\n\tpublic static BodyBuilder method(HttpMethod method, String uriTemplate, Map<String, ?> uriVariables) {\n\t\treturn new DefaultBodyBuilder(method, uriTemplate, uriVariables);\n\t}\n\n\n\t/**\n\t * Create an HTTP GET builder with the given url.\n\t * @param url the URL\n\t * @return the created builder\n\t */\n\tpublic static HeadersBuilder<?> get(URI url) {\n\t\treturn method(HttpMethod.GET, url);\n\t}\n\n\t/**\n\t * Create an HTTP GET builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */\n\tpublic static HeadersBuilder<?> get(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.GET, uriTemplate, uriVariables);\n\t}\n\n\t/**\n\t * Create an HTTP HEAD builder with the given url.\n\t * @param url the URL\n\t * @return the created builder\n\t */\n\tpublic static HeadersBuilder<?> head(URI url) {\n\t\treturn method(HttpMethod.HEAD, url);\n\t}\n\n\t/**\n\t * Create an HTTP HEAD builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */\n\tpublic static HeadersBuilder<?> head(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.HEAD, uriTemplate, uriVariables);\n\t}\n\n\t/**\n\t * Create an HTTP POST builder with the given url.\n\t * @param url the URL\n\t * @return the created builder\n\t */\n\tpublic static BodyBuilder post(URI url) {\n\t\treturn method(HttpMethod.POST, url);\n\t}\n\n\t/**\n\t * Create an HTTP POST builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */\n\tpublic static BodyBuilder post(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.POST, uriTemplate, uriVariables);\n\t}\n\n\t/**\n\t * Create an HTTP PUT builder with the given url.\n\t * @param url the URL\n\t * @return the created builder\n\t */\n\tpublic static BodyBuilder put(URI url) {\n\t\treturn method(HttpMethod.PUT, url);\n\t}\n\n\t/**\n\t * Create an HTTP PUT builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */\n\tpublic static BodyBuilder put(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.PUT, uriTemplate, uriVariables);\n\t}\n\n\t/**\n\t * Create an HTTP PATCH builder with the given url.\n\t * @param url the URL\n\t * @return the created builder\n\t */\n\tpublic static BodyBuilder patch(URI url) {\n\t\treturn method(HttpMethod.PATCH, url);\n\t}\n\n\t/**\n\t * Create an HTTP PATCH builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */\n\tpublic static BodyBuilder patch(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.PATCH, uriTemplate, uriVariables);\n\t}\n\n\t/**\n\t * Create an HTTP DELETE builder with the given url.\n\t * @param url the URL\n\t * @return the created builder\n\t */\n\tpublic static HeadersBuilder<?> delete(URI url) {\n\t\treturn method(HttpMethod.DELETE, url);\n\t}\n\n\t/**\n\t * Create an HTTP DELETE builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */\n\tpublic static HeadersBuilder<?> delete(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.DELETE, uriTemplate, uriVariables);\n\t}\n\n\t/**\n\t * Creates an HTTP OPTIONS builder with the given url.\n\t * @param url the URL\n\t * @return the created builder\n\t */\n\tpublic static HeadersBuilder<?> options(URI url) {\n\t\treturn method(HttpMethod.OPTIONS, url);\n\t}\n\n\t/**\n\t * Creates an HTTP OPTIONS builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */\n\tpublic static HeadersBuilder<?> options(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.OPTIONS, uriTemplate, uriVariables);\n\t}\n\n\n\t/**\n\t * Defines a builder that adds headers to the request entity.\n\t * @param <B> the builder subclass\n\t */\n\tpublic interface HeadersBuilder<B extends HeadersBuilder<B>> {\n\n\t\t/**\n\t\t * Add the given, single header value under the given name.\n\t\t * @param headerName  the header name\n\t\t * @param headerValues the header value(s)\n\t\t * @return this builder\n\t\t * @see HttpHeaders#add(String, String)\n\t\t */\n\t\tB header(String headerName, String... headerValues);\n\n\t\t/**\n\t\t * Copy the given headers into the entity's headers map.\n\t\t * @param headers the existing HttpHeaders to copy from\n\t\t * @return this builder\n\t\t * @since 5.2\n\t\t * @see HttpHeaders#add(String, String)\n\t\t */\n\t\tB headers(@Nullable HttpHeaders headers);\n\n\t\t/**\n\t\t * Manipulate this entity's headers with the given consumer. The\n\t\t * headers provided to the consumer are \"live\", so that the consumer can be used to\n\t\t * {@linkplain HttpHeaders#set(String, String) overwrite} existing header values,\n\t\t * {@linkplain HttpHeaders#remove(Object) remove} values, or use any of the other\n\t\t * {@link HttpHeaders} methods.\n\t\t * @param headersConsumer a function that consumes the {@code HttpHeaders}\n\t\t * @return this builder\n\t\t * @since 5.2\n\t\t */\n\t\tB headers(Consumer<HttpHeaders> headersConsumer);\n\n\t\t/**\n\t\t * Set the list of acceptable {@linkplain MediaType media types}, as\n\t\t * specified by the {@code Accept} header.\n\t\t * @param acceptableMediaTypes the acceptable media types\n\t\t */\n\t\tB accept(MediaType... acceptableMediaTypes);\n\n\t\t/**\n\t\t * Set the list of acceptable {@linkplain Charset charsets}, as specified\n\t\t * by the {@code Accept-Charset} header.\n\t\t * @param acceptableCharsets the acceptable charsets\n\t\t */\n\t\tB acceptCharset(Charset... acceptableCharsets);\n\n\t\t/**\n\t\t * Set the value of the {@code If-Modified-Since} header.\n\t\t * @param ifModifiedSince the new value of the header\n\t\t * @since 5.1.4\n\t\t */\n\t\tB ifModifiedSince(ZonedDateTime ifModifiedSince);\n\n\t\t/**\n\t\t * Set the value of the {@code If-Modified-Since} header.\n\t\t * @param ifModifiedSince the new value of the header\n\t\t * @since 5.1.4\n\t\t */\n\t\tB ifModifiedSince(Instant ifModifiedSince);\n\n\t\t/**\n\t\t * Set the value of the {@code If-Modified-Since} header.\n\t\t * <p>The date should be specified as the number of milliseconds since\n\t\t * January 1, 1970 GMT.\n\t\t * @param ifModifiedSince the new value of the header\n\t\t */\n\t\tB ifModifiedSince(long ifModifiedSince);\n\n\t\t/**\n\t\t * Set the values of the {@code If-None-Match} header.\n\t\t * @param ifNoneMatches the new value of the header\n\t\t */\n\t\tB ifNoneMatch(String... ifNoneMatches);\n\n\t\t/**\n\t\t * Builds the request entity with no body.\n\t\t * @return the request entity\n\t\t * @see BodyBuilder#body(Object)\n\t\t */\n\t\tRequestEntity<Void> build();\n\t}\n\n\n\t/**\n\t * Defines a builder that adds a body to the response entity.\n\t */\n\tpublic interface BodyBuilder extends HeadersBuilder<BodyBuilder> {\n\n\t\t/**\n\t\t * Set the length of the body in bytes, as specified by the\n\t\t * {@code Content-Length} header.\n\t\t * @param contentLength the content length\n\t\t * @return this builder\n\t\t * @see HttpHeaders#setContentLength(long)\n\t\t */\n\t\tBodyBuilder contentLength(long contentLength);\n\n\t\t/**\n\t\t * Set the {@linkplain MediaType media type} of the body, as specified\n\t\t * by the {@code Content-Type} header.\n\t\t * @param contentType the content type\n\t\t * @return this builder\n\t\t * @see HttpHeaders#setContentType(MediaType)\n\t\t */\n\t\tBodyBuilder contentType(MediaType contentType);\n\n\t\t/**\n\t\t * Set the body of the request entity and build the RequestEntity.\n\t\t * @param <T> the type of the body\n\t\t * @param body the body of the request entity\n\t\t * @return the built request entity\n\t\t */\n\t\t<T> RequestEntity<T> body(T body);\n\n\t\t/**\n\t\t * Set the body and type of the request entity and build the RequestEntity.\n\t\t * @param <T> the type of the body\n\t\t * @param body the body of the request entity\n\t\t * @param type the type of the body, useful for generic type resolution\n\t\t * @return the built request entity\n\t\t * @since 4.3\n\t\t */\n\t\t<T> RequestEntity<T> body(T body, Type type);\n\t}\n\n\n\tprivate static class DefaultBodyBuilder implements BodyBuilder {\n\n\t\tprivate final HttpMethod method;\n\n\t\tprivate final HttpHeaders headers = new HttpHeaders();\n\n\t\t@Nullable\n\t\tprivate final URI uri;\n\n\t\t@Nullable\n\t\tprivate final String uriTemplate;\n\n\t\t@Nullable\n\t\tprivate final Object[] uriVarsArray;\n\n\t\t@Nullable\n\t\tprivate final Map<String, ?> uriVarsMap;\n\n\t\tDefaultBodyBuilder(HttpMethod method, URI url) {\n\t\t\tthis.method = method;\n\t\t\tthis.uri = url;\n\t\t\tthis.uriTemplate = null;\n\t\t\tthis.uriVarsArray = null;\n\t\t\tthis.uriVarsMap = null;\n\t\t}\n\n\t\tDefaultBodyBuilder(HttpMethod method, String uriTemplate, Object... uriVars) {\n\t\t\tthis.method = method;\n\t\t\tthis.uri = null;\n\t\t\tthis.uriTemplate = uriTemplate;\n\t\t\tthis.uriVarsArray = uriVars;\n\t\t\tthis.uriVarsMap = null;\n\t\t}\n\n\t\tDefaultBodyBuilder(HttpMethod method, String uriTemplate, Map<String, ?> uriVars) {\n\t\t\tthis.method = method;\n\t\t\tthis.uri = null;\n\t\t\tthis.uriTemplate = uriTemplate;\n\t\t\tthis.uriVarsArray = null;\n\t\t\tthis.uriVarsMap = uriVars;\n\t\t}\n\n\t\t@Override\n\t\tpublic BodyBuilder header(String headerName, String... headerValues) {\n\t\t\tfor (String headerValue : headerValues) {\n\t\t\t\tthis.headers.add(headerName, headerValue);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic BodyBuilder headers(@Nullable HttpHeaders headers) {\n\t\t\tif (headers != null) {\n\t\t\t\tthis.headers.putAll(headers);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic BodyBuilder headers(Consumer<HttpHeaders> headersConsumer) {\n\t\t\theadersConsumer.accept(this.headers);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic BodyBuilder accept(MediaType... acceptableMediaTypes) {\n\t\t\tthis.headers.setAccept(Arrays.asList(acceptableMediaTypes));\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic BodyBuilder acceptCharset(Charset... acceptableCharsets) {\n\t\t\tthis.headers.setAcceptCharset(Arrays.asList(acceptableCharsets));\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic BodyBuilder contentLength(long contentLength) {\n\t\t\tthis.headers.setContentLength(contentLength);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic BodyBuilder contentType(MediaType contentType) {\n\t\t\tthis.headers.setContentType(contentType);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic BodyBuilder ifModifiedSince(ZonedDateTime ifModifiedSince) {\n\t\t\tthis.headers.setIfModifiedSince(ifModifiedSince);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic BodyBuilder ifModifiedSince(Instant ifModifiedSince) {\n\t\t\tthis.headers.setIfModifiedSince(ifModifiedSince);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic BodyBuilder ifModifiedSince(long ifModifiedSince) {\n\t\t\tthis.headers.setIfModifiedSince(ifModifiedSince);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic BodyBuilder ifNoneMatch(String... ifNoneMatches) {\n\t\t\tthis.headers.setIfNoneMatch(Arrays.asList(ifNoneMatches));\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic RequestEntity<Void> build() {\n\t\t\treturn buildInternal(null, null);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> RequestEntity<T> body(T body) {\n\t\t\treturn buildInternal(body, null);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> RequestEntity<T> body(T body, Type type) {\n\t\t\treturn buildInternal(body, type);\n\t\t}\n\n\t\tprivate <T> RequestEntity<T> buildInternal(@Nullable T body, @Nullable Type type) {\n\t\t\tif (this.uri != null) {\n\t\t\t\treturn new RequestEntity<>(body, this.headers, this.method, this.uri, type);\n\t\t\t}\n\t\t\telse if (this.uriTemplate != null){\n\t\t\t\treturn new UriTemplateRequestEntity<>(body, this.headers, this.method, type,\n\t\t\t\t\t\tthis.uriTemplate, this.uriVarsArray, this.uriVarsMap);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalStateException(\"Neither URI nor URI template\");\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * RequestEntity initialized with a URI template and variables instead of a {@link URI}.\n\t * @since 5.3\n\t * @param <T> the body type\n\t */\n\tpublic static class UriTemplateRequestEntity<T> extends RequestEntity<T> {\n\n\t\tprivate final String uriTemplate;\n\n\t\t@Nullable\n\t\tprivate final Object[] uriVarsArray;\n\n\t\t@Nullable\n\t\tprivate final Map<String, ?> uriVarsMap;\n\n\t\tUriTemplateRequestEntity(\n\t\t\t\t@Nullable T body, @Nullable MultiValueMap<String, String> headers,\n\t\t\t\t@Nullable HttpMethod method, @Nullable Type type, String uriTemplate,\n\t\t\t\t@Nullable Object[] uriVarsArray, @Nullable Map<String, ?> uriVarsMap) {\n\n\t\t\tsuper(body, headers, method, null, type);\n\t\t\tthis.uriTemplate = uriTemplate;\n\t\t\tthis.uriVarsArray = uriVarsArray;\n\t\t\tthis.uriVarsMap = uriVarsMap;\n\t\t}\n\n\t\tpublic String getUriTemplate() {\n\t\t\treturn this.uriTemplate;\n\t\t}\n\n\t\t@Nullable\n\t\tpublic Object[] getVars() {\n\t\t\treturn this.uriVarsArray;\n\t\t}\n\n\t\t@Nullable\n\t\tpublic Map<String, ?> getVarsMap() {\n\t\t\treturn this.uriVarsMap;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\tif (this == other) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!super.equals(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn (other instanceof UriTemplateRequestEntity<?> otherEntity &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.uriTemplate, otherEntity.uriTemplate) &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.uriVarsArray, otherEntity.uriVarsArray) &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.uriVarsMap, otherEntity.uriVarsMap));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn (29 * super.hashCode() + ObjectUtils.nullSafeHashCode(this.uriTemplate));\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn format(getMethod(), getUriTemplate(), getBody(), getHeaders());\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.http.RequestEntity#accept(acceptableMediaTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "acceptableMediaTypes"
    ],
    "position": {
      "column": 1,
      "line": 614
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder accept(MediaType... acceptableMediaTypes)",
    "source_code": "\t\tpublic BodyBuilder accept(MediaType... acceptableMediaTypes) {\n\t\t\tthis.headers.setAccept(Arrays.asList(acceptableMediaTypes));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.RequestEntity#acceptCharset(acceptableCharsets)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "acceptableCharsets"
    ],
    "position": {
      "column": 1,
      "line": 620
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder acceptCharset(Charset... acceptableCharsets)",
    "source_code": "\t\tpublic BodyBuilder acceptCharset(Charset... acceptableCharsets) {\n\t\t\tthis.headers.setAcceptCharset(Arrays.asList(acceptableCharsets));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.RequestEntity#body(body)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body"
    ],
    "position": {
      "column": 1,
      "line": 667
    },
    "return": "RequestEntity<T>",
    "signature": "public RequestEntity<T> body(T body)",
    "source_code": "\t\tpublic <T> RequestEntity<T> body(T body) {\n\t\t\treturn buildInternal(body, null);\n\t\t}"
  },
  "org.springframework.http.RequestEntity#body(body,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 672
    },
    "return": "RequestEntity<T>",
    "signature": "public RequestEntity<T> body(T body, Type type)",
    "source_code": "\t\tpublic <T> RequestEntity<T> body(T body, Type type) {\n\t\t\treturn buildInternal(body, type);\n\t\t}"
  },
  "org.springframework.http.RequestEntity#build()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 662
    },
    "return": "RequestEntity<Void>",
    "signature": "public RequestEntity<Void> build()",
    "source_code": "\t\tpublic RequestEntity<Void> build() {\n\t\t\treturn buildInternal(null, null);\n\t\t}"
  },
  "org.springframework.http.RequestEntity#contentLength(contentLength)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentLength"
    ],
    "position": {
      "column": 1,
      "line": 626
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder contentLength(long contentLength)",
    "source_code": "\t\tpublic BodyBuilder contentLength(long contentLength) {\n\t\t\tthis.headers.setContentLength(contentLength);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.RequestEntity#contentType(contentType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 632
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder contentType(MediaType contentType)",
    "source_code": "\t\tpublic BodyBuilder contentType(MediaType contentType) {\n\t\t\tthis.headers.setContentType(contentType);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.RequestEntity#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 732
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\tif (this == other) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!super.equals(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn (other instanceof UriTemplateRequestEntity<?> otherEntity &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.uriTemplate, otherEntity.uriTemplate) &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.uriVarsArray, otherEntity.uriVarsArray) &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.uriVarsMap, otherEntity.uriVarsMap));\n\t\t}"
  },
  "org.springframework.http.RequestEntity#getMethod()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the HTTP method of the request.\n\t * @return the HTTP method as an {@code HttpMethod} enum value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "HttpMethod",
    "signature": "public HttpMethod getMethod()",
    "source_code": "\tpublic HttpMethod getMethod() {\n\t\treturn this.method;\n\t}"
  },
  "org.springframework.http.RequestEntity#getType()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the type of the request's body.\n\t * @return the request's body type, or {@code null} if not known\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "Type",
    "signature": "public Type getType()",
    "source_code": "\tpublic Type getType() {\n\t\tif (this.type == null) {\n\t\t\tT body = getBody();\n\t\t\tif (body != null) {\n\t\t\t\treturn body.getClass();\n\t\t\t}\n\t\t}\n\t\treturn this.type;\n\t}"
  },
  "org.springframework.http.RequestEntity#getUriTemplate()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 717
    },
    "return": "String",
    "signature": "public String getUriTemplate()",
    "source_code": "\t\tpublic String getUriTemplate() {\n\t\t\treturn this.uriTemplate;\n\t\t}"
  },
  "org.springframework.http.RequestEntity#getUrl()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link URI} for the target HTTP endpoint.\n\t * <p><strong>Note:</strong> This method raises\n\t * {@link UnsupportedOperationException} if the {@code RequestEntity} was\n\t * created with a URI template and variables rather than with a {@link URI}\n\t * instance. This is because a URI cannot be created without further input\n\t * on how to expand template and encode the URI. In such cases, the\n\t * {@code URI} is prepared by the\n\t * {@link org.springframework.web.client.RestTemplate} with the help of the\n\t * {@link org.springframework.web.util.UriTemplateHandler} it is configured with.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "URI",
    "signature": "public URI getUrl()",
    "source_code": "\tpublic URI getUrl() {\n\t\tif (this.url == null) {\n\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\"The RequestEntity was created with a URI template and variables, \" +\n\t\t\t\t\t\t\t\"and there is not enough information on how to correctly expand and \" +\n\t\t\t\t\t\t\t\"encode the URI template. This will be done by the RestTemplate instead \" +\n\t\t\t\t\t\t\t\"with help from the UriTemplateHandler it is configured with.\");\n\t\t}\n\t\treturn this.url;\n\t}"
  },
  "org.springframework.http.RequestEntity#getVars()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 722
    },
    "return": "Object[]",
    "signature": "public Object[] getVars()",
    "source_code": "\t\tpublic Object[] getVars() {\n\t\t\treturn this.uriVarsArray;\n\t\t}"
  },
  "org.springframework.http.RequestEntity#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 746
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\t\tpublic int hashCode() {\n\t\t\treturn (29 * super.hashCode() + ObjectUtils.nullSafeHashCode(this.uriTemplate));\n\t\t}"
  },
  "org.springframework.http.RequestEntity#header(headerName,headerValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 592
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder header(String headerName, String... headerValues)",
    "source_code": "\t\tpublic BodyBuilder header(String headerName, String... headerValues) {\n\t\t\tfor (String headerValue : headerValues) {\n\t\t\t\tthis.headers.add(headerName, headerValue);\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.RequestEntity#headers(headers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 600
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder headers(@Nullable HttpHeaders headers)",
    "source_code": "\t\tpublic BodyBuilder headers(@Nullable HttpHeaders headers) {\n\t\t\tif (headers != null) {\n\t\t\t\tthis.headers.putAll(headers);\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.RequestEntity#headers(headersConsumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headersConsumer"
    ],
    "position": {
      "column": 1,
      "line": 608
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder headers(Consumer<HttpHeaders> headersConsumer)",
    "source_code": "\t\tpublic BodyBuilder headers(Consumer<HttpHeaders> headersConsumer) {\n\t\t\theadersConsumer.accept(this.headers);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.RequestEntity#ifModifiedSince(ifModifiedSince)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ifModifiedSince"
    ],
    "position": {
      "column": 1,
      "line": 650
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder ifModifiedSince(long ifModifiedSince)",
    "source_code": "\t\tpublic BodyBuilder ifModifiedSince(long ifModifiedSince) {\n\t\t\tthis.headers.setIfModifiedSince(ifModifiedSince);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.RequestEntity#ifNoneMatch(ifNoneMatches)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ifNoneMatches"
    ],
    "position": {
      "column": 1,
      "line": 656
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder ifNoneMatch(String... ifNoneMatches)",
    "source_code": "\t\tpublic BodyBuilder ifNoneMatch(String... ifNoneMatches) {\n\t\t\tthis.headers.setIfNoneMatch(Arrays.asList(ifNoneMatches));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.RequestEntity#method(method,uriTemplate,Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a builder with the given HTTP method, URI template, and variables.\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param uriTemplate the uri template to use\n\t * @return the created builder\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "uriTemplate",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder method(HttpMethod method, String uriTemplate, Map<String, ?> uriVariables)",
    "source_code": "\tpublic static BodyBuilder method(HttpMethod method, String uriTemplate, Map<String, ?> uriVariables) {\n\t\treturn new DefaultBodyBuilder(method, uriTemplate, uriVariables);\n\t}"
  },
  "org.springframework.http.RequestEntity#method(method,uriTemplate,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a builder with the given HTTP method, URI template, and variables.\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder method(HttpMethod method, String uriTemplate, Object... uriVariables)",
    "source_code": "\tpublic static BodyBuilder method(HttpMethod method, String uriTemplate, Object... uriVariables) {\n\t\treturn new DefaultBodyBuilder(method, uriTemplate, uriVariables);\n\t}"
  },
  "org.springframework.http.RequestEntity#method(method,url)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a builder with the given method and url.\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param url the URL\n\t * @return the created builder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "url"
    ],
    "position": {
      "column": 1,
      "line": 250
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder method(HttpMethod method, URI url)",
    "source_code": "\tpublic static BodyBuilder method(HttpMethod method, URI url) {\n\t\treturn new DefaultBodyBuilder(method, url);\n\t}"
  },
  "org.springframework.http.RequestEntity#patch(uriTemplate,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an HTTP PATCH builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 374
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder patch(String uriTemplate, Object... uriVariables)",
    "source_code": "\tpublic static BodyBuilder patch(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.PATCH, uriTemplate, uriVariables);\n\t}"
  },
  "org.springframework.http.RequestEntity#patch(url)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an HTTP PATCH builder with the given url.\n\t * @param url the URL\n\t * @return the created builder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder patch(URI url)",
    "source_code": "\tpublic static BodyBuilder patch(URI url) {\n\t\treturn method(HttpMethod.PATCH, url);\n\t}"
  },
  "org.springframework.http.RequestEntity#post(uriTemplate,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an HTTP POST builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder post(String uriTemplate, Object... uriVariables)",
    "source_code": "\tpublic static BodyBuilder post(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.POST, uriTemplate, uriVariables);\n\t}"
  },
  "org.springframework.http.RequestEntity#post(url)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an HTTP POST builder with the given url.\n\t * @param url the URL\n\t * @return the created builder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder post(URI url)",
    "source_code": "\tpublic static BodyBuilder post(URI url) {\n\t\treturn method(HttpMethod.POST, url);\n\t}"
  },
  "org.springframework.http.RequestEntity#put(uriTemplate,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an HTTP PUT builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 354
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder put(String uriTemplate, Object... uriVariables)",
    "source_code": "\tpublic static BodyBuilder put(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.PUT, uriTemplate, uriVariables);\n\t}"
  },
  "org.springframework.http.RequestEntity#put(url)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an HTTP PUT builder with the given url.\n\t * @param url the URL\n\t * @return the created builder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url"
    ],
    "position": {
      "column": 1,
      "line": 343
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder put(URI url)",
    "source_code": "\tpublic static BodyBuilder put(URI url) {\n\t\treturn method(HttpMethod.PUT, url);\n\t}"
  },
  "org.springframework.http.RequestEntity#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 751
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn format(getMethod(), getUriTemplate(), getBody(), getHeaders());\n\t\t}"
  },
  "org.springframework.http.UriTemplateRequestEntity": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * RequestEntity initialized with a URI template and variables instead of a {@link URI}.\n\t * @since 5.3\n\t * @param <T> the body type\n\t */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 696
    },
    "signature": "public class UriTemplateRequestEntity",
    "source_code": "\tpublic static class UriTemplateRequestEntity<T> extends RequestEntity<T> {\n\n\t\tprivate final String uriTemplate;\n\n\t\t@Nullable\n\t\tprivate final Object[] uriVarsArray;\n\n\t\t@Nullable\n\t\tprivate final Map<String, ?> uriVarsMap;\n\n\t\tUriTemplateRequestEntity(\n\t\t\t\t@Nullable T body, @Nullable MultiValueMap<String, String> headers,\n\t\t\t\t@Nullable HttpMethod method, @Nullable Type type, String uriTemplate,\n\t\t\t\t@Nullable Object[] uriVarsArray, @Nullable Map<String, ?> uriVarsMap) {\n\n\t\t\tsuper(body, headers, method, null, type);\n\t\t\tthis.uriTemplate = uriTemplate;\n\t\t\tthis.uriVarsArray = uriVarsArray;\n\t\t\tthis.uriVarsMap = uriVarsMap;\n\t\t}\n\n\t\tpublic String getUriTemplate() {\n\t\t\treturn this.uriTemplate;\n\t\t}\n\n\t\t@Nullable\n\t\tpublic Object[] getVars() {\n\t\t\treturn this.uriVarsArray;\n\t\t}\n\n\t\t@Nullable\n\t\tpublic Map<String, ?> getVarsMap() {\n\t\t\treturn this.uriVarsMap;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\tif (this == other) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!super.equals(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn (other instanceof UriTemplateRequestEntity<?> otherEntity &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.uriTemplate, otherEntity.uriTemplate) &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.uriVarsArray, otherEntity.uriVarsArray) &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.uriVarsMap, otherEntity.uriVarsMap));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn (29 * super.hashCode() + ObjectUtils.nullSafeHashCode(this.uriTemplate));\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn format(getMethod(), getUriTemplate(), getBody(), getHeaders());\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#yaml()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a {@link Jackson2ObjectMapperBuilder} instance in order to\n\t * build a YAML data format {@link ObjectMapper} instance.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 946
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder yaml()",
    "source_code": "\tpublic static Jackson2ObjectMapperBuilder yaml() {\n\t\treturn new Jackson2ObjectMapperBuilder().factory(new YamlFactoryInitializer().create());\n\t}"
  },
  "org.springframework.jdbc.datasource.embedded.<unknown>#getConfigurer(type)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a configurer instance for the given embedded database type.\n\t * @param type the embedded database type (HSQL, H2 or Derby)\n\t * @return the configurer instance\n\t * @throws IllegalStateException if the driver for the specified database type is not available\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "return": "EmbeddedDatabaseConfigurer",
    "signature": "public EmbeddedDatabaseConfigurer getConfigurer(EmbeddedDatabaseType type)",
    "source_code": "\tpublic static EmbeddedDatabaseConfigurer getConfigurer(EmbeddedDatabaseType type) throws IllegalStateException {\n\t\tAssert.notNull(type, \"EmbeddedDatabaseType is required\");\n\t\ttry {\n\t\t\treturn switch (type) {\n\t\t\t\tcase HSQL -> HsqlEmbeddedDatabaseConfigurer.getInstance();\n\t\t\t\tcase H2 -> H2EmbeddedDatabaseConfigurer.getInstance();\n\t\t\t\tcase DERBY -> DerbyEmbeddedDatabaseConfigurer.getInstance();\n\t\t\t\tdefault -> throw new UnsupportedOperationException(\"Embedded database type [\" + type + \"] is not supported\");\n\t\t\t};\n\t\t}\n\t\tcatch (ClassNotFoundException | NoClassDefFoundError ex) {\n\t\t\tthrow new IllegalStateException(\"Driver for test database type [\" + type + \"] is not available\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseConfigurers": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Maps well-known {@linkplain EmbeddedDatabaseType embedded database types}\n * to {@link EmbeddedDatabaseConfigurer} strategies.\n *\n * @author Keith Donald\n * @author Oliver Gierke\n * @author Sam Brannen\n * @author Stephane Nicoll\n * @since 6.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 33
    },
    "signature": "public class EmbeddedDatabaseConfigurers",
    "source_code": "public abstract class EmbeddedDatabaseConfigurers {\n\n\t/**\n\t * Return a configurer instance for the given embedded database type.\n\t * @param type the {@linkplain EmbeddedDatabaseType embedded database type}\n\t * @return the configurer instance\n\t * @throws IllegalStateException if the driver for the specified database type is not available\n\t */\n\tpublic static EmbeddedDatabaseConfigurer getConfigurer(EmbeddedDatabaseType type) {\n\t\tAssert.notNull(type, \"EmbeddedDatabaseType is required\");\n\t\ttry {\n\t\t\treturn switch (type) {\n\t\t\t\tcase HSQL -> HsqlEmbeddedDatabaseConfigurer.getInstance();\n\t\t\t\tcase H2 -> H2EmbeddedDatabaseConfigurer.getInstance();\n\t\t\t\tcase DERBY -> DerbyEmbeddedDatabaseConfigurer.getInstance();\n\t\t\t};\n\t\t}\n\t\tcatch (ClassNotFoundException | NoClassDefFoundError ex) {\n\t\t\tthrow new IllegalStateException(\"Driver for test database type [\" + type + \"] is not available\", ex);\n\t\t}\n\t}\n\n\t/**\n\t * Customize the default configurer for the given embedded database type.\n\t * <p>The {@code customizer} typically uses\n\t * {@link EmbeddedDatabaseConfigurerDelegate} to customize things as necessary.\n\t * @param type the {@linkplain EmbeddedDatabaseType embedded database type}\n\t * @param customizer the customizer to return based on the default\n\t * @return the customized configurer instance\n\t * @throws IllegalStateException if the driver for the specified database type is not available\n\t */\n\tpublic static EmbeddedDatabaseConfigurer customizeConfigurer(\n\t\t\tEmbeddedDatabaseType type, UnaryOperator<EmbeddedDatabaseConfigurer> customizer) {\n\n\t\tEmbeddedDatabaseConfigurer defaultConfigurer = getConfigurer(type);\n\t\treturn customizer.apply(defaultConfigurer);\n\t}\n\n}"
  },
  "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseConfigurers#customizeConfigurer(type,customizer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the default configurer for the given embedded database type.\n\t * <p>The {@code customizer} typically uses\n\t * {@link EmbeddedDatabaseConfigurerDelegate} to customize things as necessary.\n\t * @param type the {@linkplain EmbeddedDatabaseType embedded database type}\n\t * @param customizer the customizer to return based on the default\n\t * @return the customized configurer instance\n\t * @throws IllegalStateException if the driver for the specified database type is not available\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "customizer"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "EmbeddedDatabaseConfigurer",
    "signature": "public EmbeddedDatabaseConfigurer customizeConfigurer(EmbeddedDatabaseType type, UnaryOperator<EmbeddedDatabaseConfigurer> customizer)",
    "source_code": "\tpublic static EmbeddedDatabaseConfigurer customizeConfigurer("
  },
  "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseConfigurers#getConfigurer(type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a configurer instance for the given embedded database type.\n\t * @param type the {@linkplain EmbeddedDatabaseType embedded database type}\n\t * @return the configurer instance\n\t * @throws IllegalStateException if the driver for the specified database type is not available\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "return": "EmbeddedDatabaseConfigurer",
    "signature": "public EmbeddedDatabaseConfigurer getConfigurer(EmbeddedDatabaseType type)",
    "source_code": "\tpublic static EmbeddedDatabaseConfigurer getConfigurer(EmbeddedDatabaseType type) {\n\t\tAssert.notNull(type, \"EmbeddedDatabaseType is required\");\n\t\ttry {\n\t\t\treturn switch (type) {\n\t\t\t\tcase HSQL -> HsqlEmbeddedDatabaseConfigurer.getInstance();\n\t\t\t\tcase H2 -> H2EmbeddedDatabaseConfigurer.getInstance();\n\t\t\t\tcase DERBY -> DerbyEmbeddedDatabaseConfigurer.getInstance();\n\t\t\t};\n\t\t}\n\t\tcatch (ClassNotFoundException | NoClassDefFoundError ex) {\n\t\t\tthrow new IllegalStateException(\"Driver for test database type [\" + type + \"] is not available\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Helper bean for registering {@link JmsListenerEndpoint} with a {@link JmsListenerEndpointRegistry}.\n *\n * @author Stephane Nicoll\n * @author Juergen Hoeller\n * @since 4.1\n * @see org.springframework.jms.annotation.JmsListenerConfigurer\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class JmsListenerEndpointRegistrar",
    "source_code": "public class JmsListenerEndpointRegistrar implements BeanFactoryAware, InitializingBean {\n\n\t@Nullable\n\tprivate JmsListenerEndpointRegistry endpointRegistry;\n\n\t@Nullable\n\tprivate MessageHandlerMethodFactory messageHandlerMethodFactory;\n\n\t@Nullable\n\tprivate JmsListenerContainerFactory<?> containerFactory;\n\n\t@Nullable\n\tprivate String containerFactoryBeanName;\n\n\t@Nullable\n\tprivate BeanFactory beanFactory;\n\n\tprivate final List<JmsListenerEndpointDescriptor> endpointDescriptors = new ArrayList<>();\n\n\tprivate boolean startImmediately;\n\n\tprivate Object mutex = this.endpointDescriptors;\n\n\n\t/**\n\t * Set the {@link JmsListenerEndpointRegistry} instance to use.\n\t */\n\tpublic void setEndpointRegistry(@Nullable JmsListenerEndpointRegistry endpointRegistry) {\n\t\tthis.endpointRegistry = endpointRegistry;\n\t}\n\n\t/**\n\t * Return the {@link JmsListenerEndpointRegistry} instance for this\n\t * registrar, may be {@code null}.\n\t */\n\t@Nullable\n\tpublic JmsListenerEndpointRegistry getEndpointRegistry() {\n\t\treturn this.endpointRegistry;\n\t}\n\n\t/**\n\t * Set the {@link MessageHandlerMethodFactory} to use to configure the message\n\t * listener responsible to serve an endpoint detected by this processor.\n\t * <p>By default, {@link DefaultMessageHandlerMethodFactory} is used and it\n\t * can be configured further to support additional method arguments\n\t * or to customize conversion and validation support. See\n\t * {@link DefaultMessageHandlerMethodFactory} javadoc for more details.\n\t */\n\tpublic void setMessageHandlerMethodFactory(@Nullable MessageHandlerMethodFactory messageHandlerMethodFactory) {\n\t\tthis.messageHandlerMethodFactory = messageHandlerMethodFactory;\n\t}\n\n\t/**\n\t * Return the custom {@link MessageHandlerMethodFactory} to use, if any.\n\t */\n\t@Nullable\n\tpublic MessageHandlerMethodFactory getMessageHandlerMethodFactory() {\n\t\treturn this.messageHandlerMethodFactory;\n\t}\n\n\t/**\n\t * Set the {@link JmsListenerContainerFactory} to use in case a {@link JmsListenerEndpoint}\n\t * is registered with a {@code null} container factory.\n\t * <p>Alternatively, the bean name of the {@link JmsListenerContainerFactory} to use\n\t * can be specified for a lazy lookup, see {@link #setContainerFactoryBeanName}.\n\t */\n\tpublic void setContainerFactory(JmsListenerContainerFactory<?> containerFactory) {\n\t\tthis.containerFactory = containerFactory;\n\t}\n\n\t/**\n\t * Set the bean name of the {@link JmsListenerContainerFactory} to use in case\n\t * a {@link JmsListenerEndpoint} is registered with a {@code null} container factory.\n\t * Alternatively, the container factory instance can be registered directly:\n\t * see {@link #setContainerFactory(JmsListenerContainerFactory)}.\n\t * @see #setBeanFactory\n\t */\n\tpublic void setContainerFactoryBeanName(String containerFactoryBeanName) {\n\t\tthis.containerFactoryBeanName = containerFactoryBeanName;\n\t}\n\n\t/**\n\t * A {@link BeanFactory} only needs to be available in conjunction with\n\t * {@link #setContainerFactoryBeanName}.\n\t */\n\t@Override\n\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t\tif (beanFactory instanceof ConfigurableBeanFactory cbf) {\n\t\t\tthis.mutex = cbf.getSingletonMutex();\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic void afterPropertiesSet() {\n\t\tregisterAllEndpoints();\n\t}\n\n\tprotected void registerAllEndpoints() {\n\t\tAssert.state(this.endpointRegistry != null, \"No JmsListenerEndpointRegistry set\");\n\t\tsynchronized (this.mutex) {\n\t\t\tfor (JmsListenerEndpointDescriptor descriptor : this.endpointDescriptors) {\n\t\t\t\tthis.endpointRegistry.registerListenerContainer(\n\t\t\t\t\t\tdescriptor.endpoint, resolveContainerFactory(descriptor));\n\t\t\t}\n\t\t\tthis.startImmediately = true;  // trigger immediate startup\n\t\t}\n\t}\n\n\tprivate JmsListenerContainerFactory<?> resolveContainerFactory(JmsListenerEndpointDescriptor descriptor) {\n\t\tif (descriptor.containerFactory != null) {\n\t\t\treturn descriptor.containerFactory;\n\t\t}\n\t\telse if (this.containerFactory != null) {\n\t\t\treturn this.containerFactory;\n\t\t}\n\t\telse if (this.containerFactoryBeanName != null) {\n\t\t\tAssert.state(this.beanFactory != null, \"BeanFactory must be set to obtain container factory by bean name\");\n\t\t\t// Consider changing this if live change of the factory is required...\n\t\t\tthis.containerFactory = this.beanFactory.getBean(\n\t\t\t\t\tthis.containerFactoryBeanName, JmsListenerContainerFactory.class);\n\t\t\treturn this.containerFactory;\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\"Could not resolve the \" +\n\t\t\t\t\tJmsListenerContainerFactory.class.getSimpleName() + \" to use for [\" +\n\t\t\t\t\tdescriptor.endpoint + \"] no factory was given and no default is set.\");\n\t\t}\n\t}\n\n\t/**\n\t * Register a new {@link JmsListenerEndpoint} alongside the\n\t * {@link JmsListenerContainerFactory} to use to create the underlying container.\n\t * <p>The {@code factory} may be {@code null} if the default factory should be\n\t * used for the supplied endpoint.\n\t */\n\tpublic void registerEndpoint(JmsListenerEndpoint endpoint, @Nullable JmsListenerContainerFactory<?> factory) {\n\t\tAssert.notNull(endpoint, \"Endpoint must not be null\");\n\t\tAssert.hasText(endpoint.getId(), \"Endpoint id must be set\");\n\n\t\t// Factory may be null, we defer the resolution right before actually creating the container\n\t\tJmsListenerEndpointDescriptor descriptor = new JmsListenerEndpointDescriptor(endpoint, factory);\n\n\t\tsynchronized (this.mutex) {\n\t\t\tif (this.startImmediately) {  // register and start immediately\n\t\t\t\tAssert.state(this.endpointRegistry != null, \"No JmsListenerEndpointRegistry set\");\n\t\t\t\tthis.endpointRegistry.registerListenerContainer(descriptor.endpoint,\n\t\t\t\t\t\tresolveContainerFactory(descriptor), true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.endpointDescriptors.add(descriptor);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Register a new {@link JmsListenerEndpoint} using the default\n\t * {@link JmsListenerContainerFactory} to create the underlying container.\n\t * @see #setContainerFactory(JmsListenerContainerFactory)\n\t * @see #registerEndpoint(JmsListenerEndpoint, JmsListenerContainerFactory)\n\t */\n\tpublic void registerEndpoint(JmsListenerEndpoint endpoint) {\n\t\tregisterEndpoint(endpoint, null);\n\t}\n\n\n\tprivate static class JmsListenerEndpointDescriptor {\n\n\t\tpublic final JmsListenerEndpoint endpoint;\n\n\t\t@Nullable\n\t\tpublic final JmsListenerContainerFactory<?> containerFactory;\n\n\t\tpublic JmsListenerEndpointDescriptor(JmsListenerEndpoint endpoint,\n\t\t\t\t@Nullable JmsListenerContainerFactory<?> containerFactory) {\n\n\t\t\tthis.endpoint = endpoint;\n\t\t\tthis.containerFactory = containerFactory;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#afterPropertiesSet()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tregisterAllEndpoints();\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#getEndpointRegistry()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link JmsListenerEndpointRegistry} instance for this\n\t * registrar, may be {@code null}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "JmsListenerEndpointRegistry",
    "signature": "public JmsListenerEndpointRegistry getEndpointRegistry()",
    "source_code": "\tpublic JmsListenerEndpointRegistry getEndpointRegistry() {\n\t\treturn this.endpointRegistry;\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#getMessageHandlerMethodFactory()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the custom {@link MessageHandlerMethodFactory} to use, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "MessageHandlerMethodFactory",
    "signature": "public MessageHandlerMethodFactory getMessageHandlerMethodFactory()",
    "source_code": "\tpublic MessageHandlerMethodFactory getMessageHandlerMethodFactory() {\n\t\treturn this.messageHandlerMethodFactory;\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#registerAllEndpoints()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "void",
    "signature": "protected void registerAllEndpoints()",
    "source_code": "\tprotected void registerAllEndpoints() {\n\t\tAssert.state(this.endpointRegistry != null, \"No JmsListenerEndpointRegistry set\");\n\t\tsynchronized (this.mutex) {\n\t\t\tfor (JmsListenerEndpointDescriptor descriptor : this.endpointDescriptors) {\n\t\t\t\tthis.endpointRegistry.registerListenerContainer(\n\t\t\t\t\t\tdescriptor.endpoint, resolveContainerFactory(descriptor));\n\t\t\t}\n\t\t\tthis.startImmediately = true;  // trigger immediate startup\n\t\t}\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#registerEndpoint(endpoint)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a new {@link JmsListenerEndpoint} using the default\n\t * {@link JmsListenerContainerFactory} to create the underlying container.\n\t * @see #setContainerFactory(JmsListenerContainerFactory)\n\t * @see #registerEndpoint(JmsListenerEndpoint, JmsListenerContainerFactory)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "endpoint"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "void",
    "signature": "public void registerEndpoint(JmsListenerEndpoint endpoint)",
    "source_code": "\tpublic void registerEndpoint(JmsListenerEndpoint endpoint) {\n\t\tregisterEndpoint(endpoint, null);\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#registerEndpoint(endpoint,factory)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a new {@link JmsListenerEndpoint} alongside the\n\t * {@link JmsListenerContainerFactory} to use to create the underlying container.\n\t * <p>The {@code factory} may be {@code null} if the default factory should be\n\t * used for the supplied endpoint.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "endpoint",
      "factory"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "void",
    "signature": "public void registerEndpoint(JmsListenerEndpoint endpoint, @Nullable JmsListenerContainerFactory<?> factory)",
    "source_code": "\tpublic void registerEndpoint(JmsListenerEndpoint endpoint, @Nullable JmsListenerContainerFactory<?> factory) {\n\t\tAssert.notNull(endpoint, \"Endpoint must not be null\");\n\t\tAssert.hasText(endpoint.getId(), \"Endpoint id must be set\");\n\n\t\t// Factory may be null, we defer the resolution right before actually creating the container\n\t\tJmsListenerEndpointDescriptor descriptor = new JmsListenerEndpointDescriptor(endpoint, factory);\n\n\t\tsynchronized (this.mutex) {\n\t\t\tif (this.startImmediately) {  // register and start immediately\n\t\t\t\tAssert.state(this.endpointRegistry != null, \"No JmsListenerEndpointRegistry set\");\n\t\t\t\tthis.endpointRegistry.registerListenerContainer(descriptor.endpoint,\n\t\t\t\t\t\tresolveContainerFactory(descriptor), true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.endpointDescriptors.add(descriptor);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#setBeanFactory(beanFactory)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * A {@link BeanFactory} only needs to be available in conjunction with\n\t * {@link #setContainerFactoryBeanName}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "void",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t\tif (beanFactory instanceof ConfigurableBeanFactory cbf) {\n\t\t\tthis.mutex = cbf.getSingletonMutex();\n\t\t}\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#setContainerFactory(containerFactory)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link JmsListenerContainerFactory} to use in case a {@link JmsListenerEndpoint}\n\t * is registered with a {@code null} container factory.\n\t * <p>Alternatively, the bean name of the {@link JmsListenerContainerFactory} to use\n\t * can be specified for a lazy lookup, see {@link #setContainerFactoryBeanName}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "containerFactory"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "void",
    "signature": "public void setContainerFactory(JmsListenerContainerFactory<?> containerFactory)",
    "source_code": "\tpublic void setContainerFactory(JmsListenerContainerFactory<?> containerFactory) {\n\t\tthis.containerFactory = containerFactory;\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#setContainerFactoryBeanName(containerFactoryBeanName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the bean name of the {@link JmsListenerContainerFactory} to use in case\n\t * a {@link JmsListenerEndpoint} is registered with a {@code null} container factory.\n\t * Alternatively, the container factory instance can be registered directly:\n\t * see {@link #setContainerFactory(JmsListenerContainerFactory)}.\n\t * @see #setBeanFactory\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "containerFactoryBeanName"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "void",
    "signature": "public void setContainerFactoryBeanName(String containerFactoryBeanName)",
    "source_code": "\tpublic void setContainerFactoryBeanName(String containerFactoryBeanName) {\n\t\tthis.containerFactoryBeanName = containerFactoryBeanName;\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#setEndpointRegistry(endpointRegistry)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link JmsListenerEndpointRegistry} instance to use.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "endpointRegistry"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "void",
    "signature": "public void setEndpointRegistry(@Nullable JmsListenerEndpointRegistry endpointRegistry)",
    "source_code": "\tpublic void setEndpointRegistry(@Nullable JmsListenerEndpointRegistry endpointRegistry) {\n\t\tthis.endpointRegistry = endpointRegistry;\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#setMessageHandlerMethodFactory(messageHandlerMethodFactory)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link MessageHandlerMethodFactory} to use to configure the message\n\t * listener responsible to serve an endpoint detected by this processor.\n\t * <p>By default, {@link DefaultMessageHandlerMethodFactory} is used and it\n\t * can be configured further to support additional method arguments\n\t * or to customize conversion and validation support. See\n\t * {@link DefaultMessageHandlerMethodFactory} javadoc for more details.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageHandlerMethodFactory"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "void",
    "signature": "public void setMessageHandlerMethodFactory(@Nullable MessageHandlerMethodFactory messageHandlerMethodFactory)",
    "source_code": "\tpublic void setMessageHandlerMethodFactory(@Nullable MessageHandlerMethodFactory messageHandlerMethodFactory) {\n\t\tthis.messageHandlerMethodFactory = messageHandlerMethodFactory;\n\t}"
  },
  "org.springframework.jms.config.endpoint": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "signature": "public JmsListenerEndpoint endpoint",
    "source_code": "\t\tpublic final JmsListenerEndpoint endpoint;",
    "type": "JmsListenerEndpoint"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#setVirtualThreads(virtualThreads)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether the default {@link SimpleAsyncTaskExecutor} should be\n\t * configured to use virtual threads instead of platform threads, for\n\t * efficient blocking behavior in listener threads on Java 21 or higher.\n\t * This is off by default, setting up one platform thread per consumer.\n\t * <p>Only applicable if the internal default executor is in use rather than\n\t * an externally provided {@link #setTaskExecutor TaskExecutor} instance.\n\t * The thread name prefix for virtual threads will be derived from the\n\t * listener container's bean name, just like with default platform threads.\n\t * <p>Alternatively, pass in a virtual threads based executor through\n\t * {@link #setTaskExecutor} (with externally defined thread naming).\n\t * <p>Consider specifying concurrency limits through {@link #setConcurrency}\n\t * or {@link #setConcurrentConsumers}/{@link #setMaxConcurrentConsumers},\n\t * for potential dynamic scaling. This works fine with the default executor;\n\t * see {@link #setIdleReceivesPerTaskLimit} with its effective default of 10.\n\t * @since 6.2\n\t * @see #setTaskExecutor\n\t * @see SimpleAsyncTaskExecutor#setVirtualThreads\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "virtualThreads"
    ],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "void",
    "signature": "public void setVirtualThreads(boolean virtualThreads)",
    "source_code": "\tpublic void setVirtualThreads(boolean virtualThreads) {\n\t\tthis.virtualThreads = virtualThreads;\n\t}"
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#brokerChannelExecutor(clientInboundChannel,clientOutboundChannel)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel"
    ],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "Executor",
    "signature": "public Executor brokerChannelExecutor(AbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel)",
    "source_code": "\tpublic Executor brokerChannelExecutor("
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#clientInboundChannelExecutor()": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "Executor",
    "signature": "public Executor clientInboundChannelExecutor()",
    "source_code": "\tpublic Executor clientInboundChannelExecutor() {\n\t\tChannelRegistration registration = getClientInboundChannelRegistration();\n\t\tExecutor executor = getExecutor(registration, \"clientInboundChannel-\", this::defaultExecutor);\n\t\tif (executor instanceof ExecutorConfigurationSupport executorSupport) {\n\t\t\texecutorSupport.setPhase(getPhase());\n\t\t}\n\t\treturn executor;\n\t}"
  },
  "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#clientOutboundChannelExecutor()": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "Executor",
    "signature": "public Executor clientOutboundChannelExecutor()",
    "source_code": "\tpublic Executor clientOutboundChannelExecutor() {\n\t\tChannelRegistration registration = getClientOutboundChannelRegistration();\n\t\tExecutor executor = getExecutor(registration, \"clientOutboundChannel-\", this::defaultExecutor);\n\t\tif (executor instanceof ExecutorConfigurationSupport executorSupport) {\n\t\t\texecutorSupport.setPhase(getPhase());\n\t\t}\n\t\treturn executor;\n\t}"
  },
  "org.springframework.mock.web.MockHttpServletResponse#sendRedirect(url,sc,clearBuffer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "sc",
      "clearBuffer"
    ],
    "position": {
      "column": 1,
      "line": 630
    },
    "return": "void",
    "signature": "public void sendRedirect(String url, int sc, boolean clearBuffer)",
    "source_code": "\tpublic void sendRedirect(String url, int sc, boolean clearBuffer) throws IOException {\n\t\tAssert.state(!isCommitted(), \"Cannot send redirect - response is already committed\");\n\t\tAssert.notNull(url, \"Redirect URL must not be null\");\n\t\tsetHeader(HttpHeaders.LOCATION, url);\n\t\tsetStatus(sc);\n\t\tsetCommitted(true);\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#afterSingletonsInstantiated()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 609
    },
    "return": "void",
    "signature": "public void afterSingletonsInstantiated()",
    "source_code": "\tpublic void afterSingletonsInstantiated() {\n\t\t// Enforce completion of asynchronous Hibernate initialization before context refresh completion.\n\t\tif (this.sessionFactory instanceof InfrastructureProxy proxy) {\n\t\t\tproxy.getWrappedObject();\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.AbstractEntityManagerFactoryBean#afterSingletonsInstantiated()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 411
    },
    "return": "void",
    "signature": "public void afterSingletonsInstantiated()",
    "source_code": "\tpublic void afterSingletonsInstantiated() {\n\t\t// Enforce completion of asynchronous JPA initialization before context refresh completion.\n\t\tgetNativeEntityManagerFactory();\n\t}"
  },
  "org.springframework.scheduling.concurrent.DEFAULT_PHASE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The default phase for an executor {@link SmartLifecycle}: {@code Integer.MAX_VALUE / 2}.\n\t * <p>This is different from the default phase {@code Integer.MAX_VALUE} associated with\n\t * other {@link SmartLifecycle} implementations, putting the typically auto-started\n\t * executor/scheduler beans into an earlier startup phase and a later shutdown phase while\n\t * still leaving room for regular {@link Lifecycle} components with the common phase 0.\n\t * @since 6.2\n\t * @see #getPhase()\n\t * @see SmartLifecycle#DEFAULT_PHASE\n\t * @see org.springframework.context.support.DefaultLifecycleProcessor#setTimeoutPerShutdownPhase\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "signature": "public int DEFAULT_PHASE",
    "source_code": "\tpublic static final int DEFAULT_PHASE = Integer.MAX_VALUE / 2;",
    "type": "int"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#execute(task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "void",
    "signature": "public void execute(Runnable task)",
    "source_code": "\tpublic void execute(Runnable task) {\n\t\tsuper.execute(TaskUtils.decorateTaskWithErrorHandler(task, this.errorHandler, false));\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#setErrorHandler(errorHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide an {@link ErrorHandler} strategy.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorHandler"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "void",
    "signature": "public void setErrorHandler(ErrorHandler errorHandler)",
    "source_code": "\tpublic void setErrorHandler(ErrorHandler errorHandler) {\n\t\tAssert.notNull(errorHandler, \"ErrorHandler must not be null\");\n\t\tthis.errorHandler = errorHandler;\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#submit(task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 250
    },
    "return": "Future<T>",
    "signature": "public Future<T> submit(Callable<T> task)",
    "source_code": "\tpublic <T> Future<T> submit(Callable<T> task) {\n\t\treturn super.submit(new DelegatingErrorHandlingCallable<>(task, this.errorHandler));\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#submitListenable(task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "ListenableFuture<T>",
    "signature": "public ListenableFuture<T> submitListenable(Callable<T> task)",
    "source_code": "\tpublic <T> ListenableFuture<T> submitListenable(Callable<T> task) {\n\t\treturn super.submitListenable(new DelegatingErrorHandlingCallable<>(task, this.errorHandler));\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#call()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 478
    },
    "return": "V",
    "signature": "public V call()",
    "source_code": "\t\tpublic V call() throws Exception {\n\t\t\ttry {\n\t\t\t\treturn this.delegate.call();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthis.errorHandler.handleError(ex);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#cancel(mayInterruptIfRunning)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mayInterruptIfRunning"
    ],
    "position": {
      "column": 1,
      "line": 512
    },
    "return": "boolean",
    "signature": "public boolean cancel(boolean mayInterruptIfRunning)",
    "source_code": "\t\tpublic boolean cancel(boolean mayInterruptIfRunning) {\n\t\t\treturn this.future.cancel(mayInterruptIfRunning);\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#compareTo(o)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o"
    ],
    "position": {
      "column": 1,
      "line": 547
    },
    "return": "int",
    "signature": "public int compareTo(Delayed o)",
    "source_code": "\t\tpublic int compareTo(Delayed o) {\n\t\t\treturn this.future.compareTo(o);\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#decorateTask(callable,task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "callable",
      "task"
    ],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "RunnableScheduledFuture<V>",
    "signature": "protected RunnableScheduledFuture<V> decorateTask(Callable<V> callable, RunnableScheduledFuture<V> task)",
    "source_code": "\t\t\tprotected <V> RunnableScheduledFuture<V> decorateTask(Callable<V> callable, RunnableScheduledFuture<V> task) {\n\t\t\t\treturn decorateTaskIfNecessary(task);\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#decorateTask(runnable,task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "runnable",
      "task"
    ],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "RunnableScheduledFuture<V>",
    "signature": "protected RunnableScheduledFuture<V> decorateTask(Runnable runnable, RunnableScheduledFuture<V> task)",
    "source_code": "\t\t\tprotected <V> RunnableScheduledFuture<V> decorateTask(Runnable runnable, RunnableScheduledFuture<V> task) {\n\t\t\t\treturn decorateTaskIfNecessary(task);\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#get()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 527
    },
    "return": "V",
    "signature": "public V get()",
    "source_code": "\t\tpublic V get() throws InterruptedException, ExecutionException {\n\t\t\treturn this.future.get();\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#get(timeout,unit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeout",
      "unit"
    ],
    "position": {
      "column": 1,
      "line": 532
    },
    "return": "V",
    "signature": "public V get(long timeout, TimeUnit unit)",
    "source_code": "\t\tpublic V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n\t\t\treturn this.future.get(timeout, unit);\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#getDelay(unit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "unit"
    ],
    "position": {
      "column": 1,
      "line": 542
    },
    "return": "long",
    "signature": "public long getDelay(TimeUnit unit)",
    "source_code": "\t\tpublic long getDelay(TimeUnit unit) {\n\t\t\treturn this.future.getDelay(unit);\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#isCancelled()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 517
    },
    "return": "boolean",
    "signature": "public boolean isCancelled()",
    "source_code": "\t\tpublic boolean isCancelled() {\n\t\t\treturn this.future.isCancelled();\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#isDone()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 522
    },
    "return": "boolean",
    "signature": "public boolean isDone()",
    "source_code": "\t\tpublic boolean isDone() {\n\t\t\treturn this.future.isDone();\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#isPeriodic()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 537
    },
    "return": "boolean",
    "signature": "public boolean isPeriodic()",
    "source_code": "\t\tpublic boolean isPeriodic() {\n\t\t\treturn this.future.isPeriodic();\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#run()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 507
    },
    "return": "void",
    "signature": "public void run()",
    "source_code": "\t\tpublic void run() {\n\t\t\tthis.decoratedRunnable.run();\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#setTaskDecorator(taskDecorator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify a custom {@link TaskDecorator} to be applied to any {@link Runnable}\n\t * about to be executed.\n\t * <p>Note that such a decorator is not being applied to the user-supplied\n\t * {@code Runnable}/{@code Callable} but rather to the scheduled execution\n\t * callback (a wrapper around the user-supplied task).\n\t * <p>The primary use case is to set some execution context around the task's\n\t * invocation, or to provide some monitoring/statistics for task execution.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "taskDecorator"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "void",
    "signature": "public void setTaskDecorator(TaskDecorator taskDecorator)",
    "source_code": "\tpublic void setTaskDecorator(TaskDecorator taskDecorator) {\n\t\tthis.taskDecorator = taskDecorator;\n\t}"
  },
  "org.springframework.test.context.bean.override.<unknown>#copyBeanDefinitionDetails(from,to)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy certain details of a {@link BeanDefinition} to the definition created by\n\t * this processor for a given {@link OverrideMetadata}.\n\t * <p>The default implementation copies the {@linkplain BeanDefinition#isPrimary()\n\t * primary flag} and the {@linkplain BeanDefinition#getScope() scope}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "from",
      "to"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "void",
    "signature": "protected void copyBeanDefinitionDetails(BeanDefinition from, RootBeanDefinition to)",
    "source_code": "\tprotected void copyBeanDefinitionDetails(BeanDefinition from, RootBeanDefinition to) {\n\t\tto.setPrimary(from.isPrimary());\n\t\tto.setScope(from.getScope());\n\t}"
  },
  "org.springframework.test.context.bean.override.<unknown>#customizeContext(context,mergedConfig)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "mergedConfig"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "void",
    "signature": "public void customizeContext(ConfigurableApplicationContext context, MergedContextConfiguration mergedConfig)",
    "source_code": "\tpublic void customizeContext(ConfigurableApplicationContext context, MergedContextConfiguration mergedConfig) {\n\t\tif (context instanceof BeanDefinitionRegistry registry) {\n\t\t\tregisterInfrastructure(registry, this.detectedClasses);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.bean.override.<unknown>#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "boolean",
    "signature": "public boolean equals(Object obj)",
    "source_code": "\tpublic boolean equals(Object obj) {\n\t\tif (obj == this) {\n\t\t\treturn true;\n\t\t}\n\t\tif (obj == null || obj.getClass() != getClass()) {\n\t\t\treturn false;\n\t\t}\n\t\tBeanOverrideContextCustomizer other = (BeanOverrideContextCustomizer) obj;\n\t\treturn this.detectedClasses.equals(other.detectedClasses);\n\t}"
  },
  "org.springframework.test.context.bean.override.<unknown>#getEarlyBeanReference(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "Object",
    "signature": "public Object getEarlyBeanReference(Object bean, String beanName)",
    "source_code": "\t\tpublic Object getEarlyBeanReference(Object bean, String beanName) throws BeansException {\n\t\t\tif (bean instanceof FactoryBean) {\n\t\t\t\treturn bean;\n\t\t\t}\n\t\t\tthis.earlyReferences.put(getCacheKey(bean, beanName), bean);\n\t\t\treturn this.overrideRegistrar.wrapIfNecessary(bean, beanName);\n\t\t}"
  },
  "org.springframework.test.context.bean.override.<unknown>#getOrder()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "int",
    "signature": "public int getOrder()",
    "source_code": "\t\tpublic int getOrder() {\n\t\t\treturn Ordered.HIGHEST_PRECEDENCE;\n\t\t}"
  },
  "org.springframework.test.context.bean.override.<unknown>#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.detectedClasses.hashCode();\n\t}"
  },
  "org.springframework.test.context.bean.override.<unknown>#postProcessAfterInitialization(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(Object bean, String beanName)",
    "source_code": "\t\tpublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n\t\t\tif (bean instanceof FactoryBean) {\n\t\t\t\treturn bean;\n\t\t\t}\n\t\t\tif (this.earlyReferences.remove(getCacheKey(bean, beanName)) != bean) {\n\t\t\t\treturn this.overrideRegistrar.wrapIfNecessary(bean, beanName);\n\t\t\t}\n\t\t\treturn bean;\n\t\t}"
  },
  "org.springframework.test.context.bean.override.<unknown>#postProcessBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "void",
    "signature": "public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)",
    "source_code": "\tpublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n\t\tif (!(beanFactory instanceof BeanDefinitionRegistry registry)) {\n\t\t\tthrow new IllegalStateException(\"Cannot process bean override with a BeanFactory \" +\n\t\t\t\t\t\"that doesn't implement BeanDefinitionRegistry: \" + beanFactory.getClass());\n\t\t}\n\t\tpostProcessWithRegistry(beanFactory, registry);\n\t}"
  },
  "org.springframework.test.context.bean.override.<unknown>#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "void",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n\t\tif (!(beanFactory instanceof ConfigurableBeanFactory cbf)) {\n\t\t\tthrow new IllegalStateException(\"Cannot process bean override with a BeanFactory \" +\n\t\t\t\t\t\"that doesn't implement ConfigurableBeanFactory: \" + beanFactory.getClass());\n\t\t}\n\t\tthis.beanFactory = cbf;\n\t}"
  },
  "org.springframework.test.context.bean.override.convention.<unknown>#createMetadata(overrideAnnotation,testClass,field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "overrideAnnotation",
      "testClass",
      "field"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "TestBeanOverrideMetadata",
    "signature": "public TestBeanOverrideMetadata createMetadata(Annotation overrideAnnotation, Class<?> testClass, Field field)",
    "source_code": "\tpublic TestBeanOverrideMetadata createMetadata(Annotation overrideAnnotation, Class<?> testClass, Field field) {\n\t\tif (!(overrideAnnotation instanceof TestBean testBeanAnnotation)) {\n\t\t\tthrow new IllegalStateException(String.format(\"Invalid annotation passed to %s: expected @TestBean on field %s.%s\",\n\t\t\t\t\tTestBeanOverrideProcessor.class.getSimpleName(), field.getDeclaringClass().getName(),\n\t\t\t\t\tfield.getName()));\n\t\t}\n\t\t// If the user specified a method explicitly, search for that.\n\t\t// Otherwise, search candidate factory methods using the convention suffix\n\t\t// and the explicit bean name (if any) or field name.\n\t\tMethod explicitOverrideMethod;\n\t\tif (!testBeanAnnotation.methodName().isBlank()) {\n\t\t\texplicitOverrideMethod = findTestBeanFactoryMethod(testClass, field.getType(), testBeanAnnotation.methodName());\n\t\t}\n\t\telse {\n\t\t\tString beanName = testBeanAnnotation.name();\n\t\t\tif (!StringUtils.hasText(beanName)) {\n\t\t\t\texplicitOverrideMethod = findTestBeanFactoryMethod(testClass, field.getType(),\n\t\t\t\t\tfield.getName() + TestBean.CONVENTION_SUFFIX);\n\t\t\t}\n\t\t\telse {\n\t\t\t\texplicitOverrideMethod = findTestBeanFactoryMethod(testClass, field.getType(),\n\t\t\t\t\tbeanName + TestBean.CONVENTION_SUFFIX,\n\t\t\t\t\t\tfield.getName() + TestBean.CONVENTION_SUFFIX);\n\t\t\t}\n\t\t}\n\n\t\treturn new TestBeanOverrideMetadata(field, explicitOverrideMethod, testBeanAnnotation, ResolvableType.forField(field, testClass));\n\t}"
  },
  "org.springframework.test.context.bean.override.convention.<unknown>#createOverride(beanName,existingBeanDefinition,existingBeanInstance)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "existingBeanDefinition",
      "existingBeanInstance"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "Object",
    "signature": "protected Object createOverride(String beanName, @Nullable BeanDefinition existingBeanDefinition,\n\t\t\t\t@Nullable Object existingBeanInstance)",
    "source_code": "\t\tprotected Object createOverride(String beanName, @Nullable BeanDefinition existingBeanDefinition,"
  },
  "org.springframework.test.context.bean.override.convention.<unknown>#equals(o)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object o)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object o) {\n\t\t\tif (this == o) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (o == null || getClass() != o.getClass()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!super.equals(o)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tTestBeanOverrideMetadata that = (TestBeanOverrideMetadata) o;\n\t\t\treturn Objects.equals(this.overrideMethod, that.overrideMethod)\n\t\t\t\t\t&& Objects.equals(this.beanName, that.beanName);\n\t\t}"
  },
  "org.springframework.test.context.bean.override.convention.<unknown>#getBeanName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "String",
    "signature": "protected String getBeanName()",
    "source_code": "\t\tprotected String getBeanName() {\n\t\t\treturn this.beanName;\n\t\t}"
  },
  "org.springframework.test.context.bean.override.convention.<unknown>#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\t\tpublic int hashCode() {\n\t\t\treturn Objects.hash(super.hashCode(), this.overrideMethod, this.beanName);\n\t\t}"
  },
  "org.springframework.test.context.bean.override.mockito.<unknown>#createMetadata(overrideAnnotation,testClass,field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "overrideAnnotation",
      "testClass",
      "field"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "return": "MockitoMetadata",
    "signature": "public MockitoMetadata createMetadata(Annotation overrideAnnotation, Class<?> testClass, Field field)",
    "source_code": "\tpublic MockitoMetadata createMetadata(Annotation overrideAnnotation, Class<?> testClass, Field field) {\n\t\tif (overrideAnnotation instanceof MockitoBean mockBean) {\n\t\t\treturn new MockitoBeanMetadata(mockBean, field, ResolvableType.forField(field, testClass));\n\t\t}\n\t\telse if (overrideAnnotation instanceof MockitoSpyBean spyBean) {\n\t\t\treturn new MockitoSpyBeanMetadata(spyBean, field, ResolvableType.forField(field, testClass));\n\t\t}\n\t\tthrow new IllegalStateException(String.format(\"Invalid annotation passed to MockitoBeanOverrideProcessor: \"\n\t\t\t\t+ \"expected @MockitoBean/@MockitoSpyBean on field %s.%s\",\n\t\t\t\tfield.getDeclaringClass().getName(), field.getName()));\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockReset": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Reset strategy used on a mock bean. Usually applied to a mock through the\n * {@link MockitoBean @MockitoBean} annotation but can also be directly applied\n * to any mock in the {@code ApplicationContext} using the static methods.\n *\n * @author Phillip Webb\n * @since 6.2\n * @see MockitoResetTestExecutionListener\n */",
    "kind": "enum",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public enum MockReset",
    "source_code": "public enum MockReset {\n\n\t/**\n\t * Reset the mock before the test method runs.\n\t */\n\tBEFORE,\n\n\t/**\n\t * Reset the mock after the test method runs.\n\t */\n\tAFTER,\n\n\t/**\n\t * Don't reset the mock.\n\t */\n\tNONE;\n\n\n\t/**\n\t * Create {@link MockSettings settings} to be used with mocks where reset\n\t * should occur before each test method runs.\n\t * @return mock settings\n\t */\n\tpublic static MockSettings before() {\n\t\treturn withSettings(BEFORE);\n\t}\n\n\t/**\n\t * Create {@link MockSettings settings} to be used with mocks where reset\n\t * should occur after each test method runs.\n\t * @return mock settings\n\t */\n\tpublic static MockSettings after() {\n\t\treturn withSettings(AFTER);\n\t}\n\n\t/**\n\t * Create {@link MockSettings settings} to be used with mocks where a\n\t * specific reset should occur.\n\t * @param reset the reset type\n\t * @return mock settings\n\t */\n\tpublic static MockSettings withSettings(MockReset reset) {\n\t\treturn apply(reset, Mockito.withSettings());\n\t}\n\n\t/**\n\t * Apply {@link MockReset} to existing {@link MockSettings settings}.\n\t * @param reset the reset type\n\t * @param settings the settings\n\t * @return the configured settings\n\t */\n\tpublic static MockSettings apply(MockReset reset, MockSettings settings) {\n\t\tAssert.notNull(settings, \"Settings must not be null\");\n\t\tif (reset != null && reset != NONE) {\n\t\t\tsettings.invocationListeners(new ResetInvocationListener(reset));\n\t\t}\n\t\treturn settings;\n\t}\n\n\t/**\n\t * Get the {@link MockReset} associated with the given mock.\n\t * @param mock the source mock\n\t * @return the reset type (never {@code null})\n\t */\n\tstatic MockReset get(Object mock) {\n\t\tMockReset reset = MockReset.NONE;\n\t\tMockingDetails mockingDetails = Mockito.mockingDetails(mock);\n\t\tif (mockingDetails.isMock()) {\n\t\t\tMockCreationSettings<?> settings = mockingDetails.getMockCreationSettings();\n\t\t\tList<InvocationListener> listeners = settings.getInvocationListeners();\n\t\t\tfor (Object listener : listeners) {\n\t\t\t\tif (listener instanceof ResetInvocationListener resetInvocationListener) {\n\t\t\t\t\treset = resetInvocationListener.getReset();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn reset;\n\t}\n\n\t/**\n\t * Dummy {@link InvocationListener} used to hold the {@link MockReset} value.\n\t */\n\tprivate static class ResetInvocationListener implements InvocationListener {\n\n\t\tprivate final MockReset reset;\n\n\t\tResetInvocationListener(MockReset reset) {\n\t\t\tthis.reset = reset;\n\t\t}\n\n\t\tMockReset getReset() {\n\t\t\treturn this.reset;\n\t\t}\n\n\t\t@Override\n\t\tpublic void reportInvocation(MethodInvocationReport methodInvocationReport) {\n\t\t}\n\n\t}\n\n}"
  },
  "org.springframework.test.context.bean.override.mockito.MockReset#after()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create {@link MockSettings settings} to be used with mocks where reset\n\t * should occur after each test method runs.\n\t * @return mock settings\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "MockSettings",
    "signature": "public MockSettings after()",
    "source_code": "\tpublic static MockSettings after() {\n\t\treturn withSettings(AFTER);\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockReset#apply(reset,settings)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply {@link MockReset} to existing {@link MockSettings settings}.\n\t * @param reset the reset type\n\t * @param settings the settings\n\t * @return the configured settings\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "reset",
      "settings"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "MockSettings",
    "signature": "public MockSettings apply(MockReset reset, MockSettings settings)",
    "source_code": "\tpublic static MockSettings apply(MockReset reset, MockSettings settings) {\n\t\tAssert.notNull(settings, \"Settings must not be null\");\n\t\tif (reset != null && reset != NONE) {\n\t\t\tsettings.invocationListeners(new ResetInvocationListener(reset));\n\t\t}\n\t\treturn settings;\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockReset#before()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create {@link MockSettings settings} to be used with mocks where reset\n\t * should occur before each test method runs.\n\t * @return mock settings\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "MockSettings",
    "signature": "public MockSettings before()",
    "source_code": "\tpublic static MockSettings before() {\n\t\treturn withSettings(BEFORE);\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockReset#reportInvocation(methodInvocationReport)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodInvocationReport"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "void",
    "signature": "public void reportInvocation(MethodInvocationReport methodInvocationReport)",
    "source_code": "\t\tpublic void reportInvocation(MethodInvocationReport methodInvocationReport) {\n\t\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockReset#withSettings(reset)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create {@link MockSettings settings} to be used with mocks where a\n\t * specific reset should occur.\n\t * @param reset the reset type\n\t * @return mock settings\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "reset"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "MockSettings",
    "signature": "public MockSettings withSettings(MockReset reset)",
    "source_code": "\tpublic static MockSettings withSettings(MockReset reset) {\n\t\treturn apply(reset, Mockito.withSettings());\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockitoResetTestExecutionListener": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code TestExecutionListener} that resets any mock beans that have been marked\n * with a {@link MockReset}.\n *\n * @author Phillip Webb\n * @since 6.2\n * @see MockitoTestExecutionListener\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "signature": "public class MockitoResetTestExecutionListener",
    "source_code": "public class MockitoResetTestExecutionListener extends AbstractTestExecutionListener {\n\n\t/**\n\t * Executes before {@link org.springframework.test.context.bean.override.BeanOverrideTestExecutionListener}.\n\t */\n\t@Override\n\tpublic int getOrder() {\n\t\treturn Ordered.LOWEST_PRECEDENCE - 100;\n\t}\n\n\t@Override\n\tpublic void beforeTestMethod(TestContext testContext) throws Exception {\n\t\tif (MockitoTestExecutionListener.mockitoPresent && !NativeDetector.inNativeImage()) {\n\t\t\tresetMocks(testContext.getApplicationContext(), MockReset.BEFORE);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void afterTestMethod(TestContext testContext) throws Exception {\n\t\tif (MockitoTestExecutionListener.mockitoPresent && !NativeDetector.inNativeImage()) {\n\t\t\tresetMocks(testContext.getApplicationContext(), MockReset.AFTER);\n\t\t}\n\t}\n\n\tprivate void resetMocks(ApplicationContext applicationContext, MockReset reset) {\n\t\tif (applicationContext instanceof ConfigurableApplicationContext configurableContext) {\n\t\t\tresetMocks(configurableContext, reset);\n\t\t}\n\t}\n\n\tprivate void resetMocks(ConfigurableApplicationContext applicationContext, MockReset reset) {\n\t\tConfigurableListableBeanFactory beanFactory = applicationContext.getBeanFactory();\n\t\tString[] names = beanFactory.getBeanDefinitionNames();\n\t\tSet<String> instantiatedSingletons = new HashSet<>(Arrays.asList(beanFactory.getSingletonNames()));\n\t\tfor (String name : names) {\n\t\t\tBeanDefinition definition = beanFactory.getBeanDefinition(name);\n\t\t\tif (definition.isSingleton() && instantiatedSingletons.contains(name)) {\n\t\t\t\tObject bean = getBean(beanFactory, name);\n\t\t\t\tif (bean != null && reset.equals(MockReset.get(bean))) {\n\t\t\t\t\tMockito.reset(bean);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tMockitoBeans mockedBeans = beanFactory.getBean(MockitoBeans.class);\n\t\t\tfor (Object mockedBean : mockedBeans) {\n\t\t\t\tif (reset.equals(MockReset.get(mockedBean))) {\n\t\t\t\t\tMockito.reset(mockedBean);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Continue\n\t\t}\n\t\tif (applicationContext.getParent() != null) {\n\t\t\tresetMocks(applicationContext.getParent(), reset);\n\t\t}\n\t}\n\n\t@Nullable\n\tprivate Object getBean(ConfigurableListableBeanFactory beanFactory, String name) {\n\t\ttry {\n\t\t\tif (isStandardBeanOrSingletonFactoryBean(beanFactory, name)) {\n\t\t\t\treturn beanFactory.getBean(name);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\t// Continue\n\t\t}\n\t\treturn beanFactory.getSingleton(name);\n\t}\n\n\tprivate boolean isStandardBeanOrSingletonFactoryBean(ConfigurableListableBeanFactory beanFactory, String name) {\n\t\tString factoryBeanName = BeanFactory.FACTORY_BEAN_PREFIX + name;\n\t\tif (beanFactory.containsBean(factoryBeanName)) {\n\t\t\tFactoryBean<?> factoryBean = (FactoryBean<?>) beanFactory.getBean(factoryBeanName);\n\t\t\treturn factoryBean.isSingleton();\n\t\t}\n\t\treturn true;\n\t}\n\n}"
  },
  "org.springframework.test.context.bean.override.mockito.MockitoResetTestExecutionListener#afterTestMethod(testContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "void",
    "signature": "public void afterTestMethod(TestContext testContext)",
    "source_code": "\tpublic void afterTestMethod(TestContext testContext) throws Exception {\n\t\tif (MockitoTestExecutionListener.mockitoPresent && !NativeDetector.inNativeImage()) {\n\t\t\tresetMocks(testContext.getApplicationContext(), MockReset.AFTER);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockitoResetTestExecutionListener#beforeTestMethod(testContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "void",
    "signature": "public void beforeTestMethod(TestContext testContext)",
    "source_code": "\tpublic void beforeTestMethod(TestContext testContext) throws Exception {\n\t\tif (MockitoTestExecutionListener.mockitoPresent && !NativeDetector.inNativeImage()) {\n\t\t\tresetMocks(testContext.getApplicationContext(), MockReset.BEFORE);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockitoResetTestExecutionListener#getOrder()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Executes before {@link org.springframework.test.context.bean.override.BeanOverrideTestExecutionListener}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "int",
    "signature": "public int getOrder()",
    "source_code": "\tpublic int getOrder() {\n\t\treturn Ordered.LOWEST_PRECEDENCE - 100;\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockitoTestExecutionListener": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code TestExecutionListener} that enables {@link MockitoBean @MockitoBean} and\n * {@link MockitoSpyBean @MockitoSpyBean} support. Also triggers\n * {@link MockitoAnnotations#openMocks(Object)} when any Mockito annotations are\n * used, primarily to support {@link Captor @Captor} annotations.\n *\n * <p>The automatic reset support for {@code @MockBean} and {@code @SpyBean} is\n * handled by the {@link MockitoResetTestExecutionListener}.\n *\n * @author Simon Basl\u00e9\n * @author Phillip Webb\n * @author Andy Wilkinson\n * @author Moritz Halbritter\n * @since 6.2\n * @see MockitoResetTestExecutionListener\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "public class MockitoTestExecutionListener",
    "source_code": "public class MockitoTestExecutionListener extends AbstractTestExecutionListener {\n\n\tprivate static final String MOCKS_ATTRIBUTE_NAME = MockitoTestExecutionListener.class.getName() + \".mocks\";\n\n\tstatic final boolean mockitoPresent = ClassUtils.isPresent(\"org.mockito.MockSettings\",\n\t\t\tMockitoTestExecutionListener.class.getClassLoader());\n\n\n\t/**\n\t * Executes before {@link DependencyInjectionTestExecutionListener}.\n\t */\n\t@Override\n\tpublic final int getOrder() {\n\t\treturn 1950;\n\t}\n\n\t@Override\n\tpublic void prepareTestInstance(TestContext testContext) throws Exception {\n\t\tif (mockitoPresent) {\n\t\t\tcloseMocks(testContext);\n\t\t\tinitMocks(testContext);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void beforeTestMethod(TestContext testContext) throws Exception {\n\t\tif (mockitoPresent && Boolean.TRUE.equals(\n\t\t\t\ttestContext.getAttribute(DependencyInjectionTestExecutionListener.REINJECT_DEPENDENCIES_ATTRIBUTE))) {\n\t\t\tcloseMocks(testContext);\n\t\t\tinitMocks(testContext);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void afterTestMethod(TestContext testContext) throws Exception {\n\t\tif (mockitoPresent) {\n\t\t\tcloseMocks(testContext);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void afterTestClass(TestContext testContext) throws Exception {\n\t\tif (mockitoPresent) {\n\t\t\tcloseMocks(testContext);\n\t\t}\n\t}\n\n\tprivate void initMocks(TestContext testContext) {\n\t\tif (hasMockitoAnnotations(testContext)) {\n\t\t\tObject testInstance = testContext.getTestInstance();\n\t\t\ttestContext.setAttribute(MOCKS_ATTRIBUTE_NAME, MockitoAnnotations.openMocks(testInstance));\n\t\t}\n\t}\n\n\tprivate void closeMocks(TestContext testContext) throws Exception {\n\t\tObject mocks = testContext.getAttribute(MOCKS_ATTRIBUTE_NAME);\n\t\tif (mocks instanceof AutoCloseable closeable) {\n\t\t\tcloseable.close();\n\t\t}\n\t}\n\n\tprivate boolean hasMockitoAnnotations(TestContext testContext) {\n\t\tMockitoAnnotationCollector collector = new MockitoAnnotationCollector();\n\t\tReflectionUtils.doWithFields(testContext.getTestClass(), collector);\n\t\treturn collector.hasAnnotations();\n\t}\n\n\n\t/**\n\t * {@link FieldCallback} that collects Mockito annotations.\n\t */\n\tprivate static final class MockitoAnnotationCollector implements FieldCallback {\n\n\t\tprivate final Set<Annotation> annotations = new LinkedHashSet<>();\n\n\t\t@Override\n\t\tpublic void doWith(Field field) throws IllegalArgumentException {\n\t\t\tfor (Annotation annotation : field.getAnnotations()) {\n\t\t\t\tif (annotation.annotationType().getPackageName().startsWith(\"org.mockito\")) {\n\t\t\t\t\tthis.annotations.add(annotation);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboolean hasAnnotations() {\n\t\t\treturn !this.annotations.isEmpty();\n\t\t}\n\n\t}\n\n}"
  },
  "org.springframework.test.context.bean.override.mockito.MockitoTestExecutionListener#afterTestClass(testContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "void",
    "signature": "public void afterTestClass(TestContext testContext)",
    "source_code": "\tpublic void afterTestClass(TestContext testContext) throws Exception {\n\t\tif (mockitoPresent) {\n\t\t\tcloseMocks(testContext);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockitoTestExecutionListener#afterTestMethod(testContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "void",
    "signature": "public void afterTestMethod(TestContext testContext)",
    "source_code": "\tpublic void afterTestMethod(TestContext testContext) throws Exception {\n\t\tif (mockitoPresent) {\n\t\t\tcloseMocks(testContext);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockitoTestExecutionListener#beforeTestMethod(testContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "void",
    "signature": "public void beforeTestMethod(TestContext testContext)",
    "source_code": "\tpublic void beforeTestMethod(TestContext testContext) throws Exception {\n\t\tif (mockitoPresent && Boolean.TRUE.equals(\n\t\t\t\ttestContext.getAttribute(DependencyInjectionTestExecutionListener.REINJECT_DEPENDENCIES_ATTRIBUTE))) {\n\t\t\tcloseMocks(testContext);\n\t\t\tinitMocks(testContext);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockitoTestExecutionListener#doWith(field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void doWith(Field field)",
    "source_code": "\t\tpublic void doWith(Field field) throws IllegalArgumentException {\n\t\t\tfor (Annotation annotation : field.getAnnotations()) {\n\t\t\t\tif (annotation.annotationType().getPackageName().startsWith(\"org.mockito\")) {\n\t\t\t\t\tthis.annotations.add(annotation);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockitoTestExecutionListener#getOrder()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Executes before {@link DependencyInjectionTestExecutionListener}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "int",
    "signature": "public int getOrder()",
    "source_code": "\tpublic final int getOrder() {\n\t\treturn 1950;\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.MockitoTestExecutionListener#prepareTestInstance(testContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "void",
    "signature": "public void prepareTestInstance(TestContext testContext)",
    "source_code": "\tpublic void prepareTestInstance(TestContext testContext) throws Exception {\n\t\tif (mockitoPresent) {\n\t\t\tcloseMocks(testContext);\n\t\t\tinitMocks(testContext);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.support.CommonCachesTestExecutionListener": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code TestExecutionListener} which makes sure that common caches are cleared\n * once they are no longer required.\n *\n * <p>Clears the resource caches of the {@link ApplicationContext} since they are\n * only required during the bean initialization phase. Runs after\n * {@link DirtiesContextTestExecutionListener} since dirtying the context will\n * close it and remove it from the context cache, making it unnecessary to clear\n * the associated resource caches.\n *\n * @author Stephane Nicoll\n * @since 6.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 36
    },
    "signature": "public class CommonCachesTestExecutionListener",
    "source_code": "public class CommonCachesTestExecutionListener extends AbstractTestExecutionListener {\n\n\t/**\n\t * Returns {@code 3005}.\n\t */\n\t@Override\n\tpublic final int getOrder() {\n\t\treturn 3005;\n\t}\n\n\n\t@Override\n\tpublic void afterTestClass(TestContext testContext) throws Exception {\n\t\tif (testContext.hasApplicationContext()) {\n\t\t\tApplicationContext applicationContext = testContext.getApplicationContext();\n\t\t\tif (applicationContext instanceof AbstractApplicationContext ctx) {\n\t\t\t\tctx.clearResourceCaches();\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.test.context.support.CommonCachesTestExecutionListener#afterTestClass(testContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "return": "void",
    "signature": "public void afterTestClass(TestContext testContext)",
    "source_code": "\tpublic void afterTestClass(TestContext testContext) throws Exception {\n\t\tif (testContext.hasApplicationContext()) {\n\t\t\tApplicationContext applicationContext = testContext.getApplicationContext();\n\t\t\tif (applicationContext instanceof AbstractApplicationContext ctx) {\n\t\t\t\tctx.clearResourceCaches();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.test.context.support.CommonCachesTestExecutionListener#getOrder()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns {@code 3005}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 42
    },
    "return": "int",
    "signature": "public int getOrder()",
    "source_code": "\tpublic final int getOrder() {\n\t\treturn 3005;\n\t}"
  },
  "org.springframework.test.context.web.WebMergedContextConfiguration": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code WebMergedContextConfiguration} encapsulates the <em>merged</em> context\n * configuration declared on a test class and all of its superclasses and\n * enclosing classes via\n * {@link org.springframework.test.context.ContextConfiguration @ContextConfiguration},\n * {@link WebAppConfiguration @WebAppConfiguration},\n * {@link org.springframework.test.context.ActiveProfiles @ActiveProfiles}, and\n * {@link org.springframework.test.context.TestPropertySource @TestPropertySource}.\n *\n * <p>{@code WebMergedContextConfiguration} extends the contract of\n * {@link MergedContextConfiguration} by adding support for the {@linkplain\n * #getResourceBasePath() resource base path} configured via {@code @WebAppConfiguration}.\n * This allows the {@link org.springframework.test.context.cache.ContextCache ContextCache}\n * to properly cache the corresponding {@link\n * org.springframework.web.context.WebApplicationContext WebApplicationContext}\n * that was loaded using properties of this {@code WebMergedContextConfiguration}.\n *\n * @author Sam Brannen\n * @since 3.2\n * @see WebAppConfiguration\n * @see MergedContextConfiguration\n * @see org.springframework.test.context.ContextConfiguration\n * @see org.springframework.test.context.ActiveProfiles\n * @see org.springframework.test.context.ContextConfigurationAttributes\n * @see org.springframework.test.context.SmartContextLoader#loadContext(MergedContextConfiguration)\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "signature": "public class WebMergedContextConfiguration",
    "source_code": "public class WebMergedContextConfiguration extends MergedContextConfiguration {\n\n\tprivate static final long serialVersionUID = 7323361588604247458L;\n\n\tprivate final String resourceBasePath;\n\n\n\t/**\n\t * Create a new {@code WebMergedContextConfiguration} instance by copying\n\t * all properties from the supplied {@code MergedContextConfiguration}.\n\t * <p>If an <em>empty</em> value is supplied for the {@code resourceBasePath}\n\t * an empty string will be used.\n\t * @param resourceBasePath the resource path to the root directory of the web application\n\t * @since 4.1\n\t */\n\tpublic WebMergedContextConfiguration(MergedContextConfiguration mergedConfig, String resourceBasePath) {\n\t\tsuper(mergedConfig);\n\t\tthis.resourceBasePath = (StringUtils.hasText(resourceBasePath) ? resourceBasePath : \"\");\n\t}\n\n\t/**\n\t * Create a new {@code WebMergedContextConfiguration} instance for the\n\t * supplied parameters.\n\t * <p>If a {@code null} value is supplied for {@code locations},\n\t * {@code classes}, {@code activeProfiles}, {@code propertySourceLocations},\n\t * or {@code propertySourceProperties} an empty array will be stored instead.\n\t * If a {@code null} value is supplied for the\n\t * {@code contextInitializerClasses} an empty set will be stored instead.\n\t * If an <em>empty</em> value is supplied for the {@code resourceBasePath}\n\t * an empty string will be used. Furthermore, active profiles will be sorted,\n\t * and duplicate profiles will be removed.\n\t * @param testClass the test class for which the configuration was merged\n\t * @param locations the merged resource locations\n\t * @param classes the merged annotated classes\n\t * @param contextInitializerClasses the merged context initializer classes\n\t * @param activeProfiles the merged active bean definition profiles\n\t * @param propertySourceLocations the merged {@code PropertySource} locations\n\t * @param propertySourceProperties the merged {@code PropertySource} properties\n\t * @param resourceBasePath the resource path to the root directory of the web application\n\t * @param contextLoader the resolved {@code ContextLoader}\n\t * @param cacheAwareContextLoaderDelegate a cache-aware context loader\n\t * delegate with which to retrieve the parent context\n\t * @param parent the parent configuration or {@code null} if there is no parent\n\t * @since 4.1\n\t * @deprecated since 6.1 in favor of\n\t * {@link #WebMergedContextConfiguration(Class, String[], Class[], Set, String[], List, String[], Set, String, ContextLoader, CacheAwareContextLoaderDelegate, MergedContextConfiguration)}\n\t */\n\t@Deprecated(since = \"6.1\")\n\tpublic WebMergedContextConfiguration(Class<?> testClass, @Nullable String[] locations, @Nullable Class<?>[] classes,\n\t\t\t@Nullable Set<Class<? extends ApplicationContextInitializer<?>>> contextInitializerClasses,\n\t\t\t@Nullable String[] activeProfiles, @Nullable String[] propertySourceLocations, @Nullable String[] propertySourceProperties,\n\t\t\tString resourceBasePath, ContextLoader contextLoader,\n\t\t\tCacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate, @Nullable MergedContextConfiguration parent) {\n\n\t\tthis(testClass, locations, classes, contextInitializerClasses, activeProfiles, propertySourceLocations,\n\t\t\tpropertySourceProperties, null, resourceBasePath, contextLoader, cacheAwareContextLoaderDelegate, parent);\n\t}\n\n\t/**\n\t * Create a new {@code WebMergedContextConfiguration} instance for the\n\t * supplied parameters.\n\t * <p>If a {@code null} value is supplied for {@code locations},\n\t * {@code classes}, {@code activeProfiles}, {@code propertySourceLocations},\n\t * or {@code propertySourceProperties} an empty array will be stored instead.\n\t * If a {@code null} value is supplied for {@code contextInitializerClasses}\n\t * or {@code contextCustomizers}, an empty set will be stored instead.\n\t * If an <em>empty</em> value is supplied for the {@code resourceBasePath}\n\t * an empty string will be used. Furthermore, active profiles will be sorted,\n\t * and duplicate profiles will be removed.\n\t * @param testClass the test class for which the configuration was merged\n\t * @param locations the merged context resource locations\n\t * @param classes the merged annotated classes\n\t * @param contextInitializerClasses the merged context initializer classes\n\t * @param activeProfiles the merged active bean definition profiles\n\t * @param propertySourceLocations the merged {@code PropertySource} locations\n\t * @param propertySourceProperties the merged {@code PropertySource} properties\n\t * @param contextCustomizers the context customizers\n\t * @param resourceBasePath the resource path to the root directory of the web application\n\t * @param contextLoader the resolved {@code ContextLoader}\n\t * @param cacheAwareContextLoaderDelegate a cache-aware context loader\n\t * delegate with which to retrieve the parent context\n\t * @param parent the parent configuration or {@code null} if there is no parent\n\t * @since 4.3\n\t * @deprecated since 6.1 in favor of\n\t * {@link #WebMergedContextConfiguration(Class, String[], Class[], Set, String[], List, String[], Set, String, ContextLoader, CacheAwareContextLoaderDelegate, MergedContextConfiguration)}\n\t */\n\t@Deprecated(since = \"6.1\")\n\tpublic WebMergedContextConfiguration(Class<?> testClass, @Nullable String[] locations, @Nullable Class<?>[] classes,\n\t\t\t@Nullable Set<Class<? extends ApplicationContextInitializer<?>>> contextInitializerClasses,\n\t\t\t@Nullable String[] activeProfiles, @Nullable String[] propertySourceLocations, @Nullable String[] propertySourceProperties,\n\t\t\t@Nullable Set<ContextCustomizer> contextCustomizers, String resourceBasePath, ContextLoader contextLoader,\n\t\t\tCacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate, @Nullable MergedContextConfiguration parent) {\n\n\t\tthis(testClass, locations, classes, contextInitializerClasses, activeProfiles,\n\t\t\tList.of(new PropertySourceDescriptor(processStrings(propertySourceLocations))),\n\t\t\tpropertySourceProperties, contextCustomizers, resourceBasePath, contextLoader,\n\t\t\tcacheAwareContextLoaderDelegate, parent);\n\t}\n\n\t/**\n\t * Create a new {@code WebMergedContextConfiguration} instance for the supplied\n\t * parameters.\n\t * <p>If a {@code null} value is supplied for {@code locations}, {@code classes},\n\t * {@code activeProfiles}, or {@code propertySourceProperties} an empty array\n\t * will be stored instead. If a {@code null} value is supplied for\n\t * {@code contextInitializerClasses} or {@code contextCustomizers}, an empty\n\t * set will be stored instead. Furthermore, active profiles will be sorted,\n\t * and duplicate profiles will be removed.\n\t * @param testClass the test class for which the configuration was merged\n\t * @param locations the merged context resource locations\n\t * @param classes the merged annotated classes\n\t * @param contextInitializerClasses the merged context initializer classes\n\t * @param activeProfiles the merged active bean definition profiles\n\t * @param propertySourceDescriptors the merged property source descriptors\n\t * @param propertySourceProperties the merged inlined properties\n\t * @param contextCustomizers the context customizers\n\t * @param resourceBasePath the resource path to the root directory of the web application\n\t * @param contextLoader the resolved {@code ContextLoader}\n\t * @param cacheAwareContextLoaderDelegate a cache-aware context loader\n\t * delegate with which to retrieve the parent {@code ApplicationContext}\n\t * @param parent the parent configuration or {@code null} if there is no parent\n\t * @since 6.1\n\t */\n\tpublic WebMergedContextConfiguration(Class<?> testClass, @Nullable String[] locations, @Nullable Class<?>[] classes,\n\t\t\t@Nullable Set<Class<? extends ApplicationContextInitializer<?>>> contextInitializerClasses,\n\t\t\t@Nullable String[] activeProfiles,\n\t\t\tList<PropertySourceDescriptor> propertySourceDescriptors, @Nullable String[] propertySourceProperties,\n\t\t\t@Nullable Set<ContextCustomizer> contextCustomizers, String resourceBasePath, ContextLoader contextLoader,\n\t\t\tCacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate, @Nullable MergedContextConfiguration parent) {\n\n\t\tsuper(testClass, locations, classes, contextInitializerClasses, activeProfiles, propertySourceDescriptors,\n\t\t\tpropertySourceProperties, contextCustomizers, contextLoader, cacheAwareContextLoaderDelegate, parent);\n\n\t\tthis.resourceBasePath = (StringUtils.hasText(resourceBasePath) ? resourceBasePath : \"\");\n\t}\n\n\t/**\n\t * Get the resource path to the root directory of the web application for the\n\t * {@linkplain #getTestClass() test class}, configured via {@code @WebAppConfiguration}.\n\t * @see WebAppConfiguration\n\t */\n\tpublic String getResourceBasePath() {\n\t\treturn this.resourceBasePath;\n\t}\n\n\n\t/**\n\t * Determine if the supplied object is equal to this {@code WebMergedContextConfiguration}\n\t * instance by comparing both objects' {@linkplain #getLocations() locations},\n\t * {@linkplain #getClasses() annotated classes},\n\t * {@linkplain #getContextInitializerClasses() context initializer classes},\n\t * {@linkplain #getActiveProfiles() active profiles},\n\t * {@linkplain #getResourceBasePath() resource base paths},\n\t * {@linkplain #getPropertySourceDescriptors() property source descriptors},\n\t * {@linkplain #getPropertySourceProperties() property source properties},\n\t * {@linkplain #getContextCustomizers() context customizers},\n\t * {@linkplain #getParent() parents}, and the fully qualified names of their\n\t * {@link #getContextLoader() ContextLoaders}.\n\t */\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (super.equals(other) && other instanceof WebMergedContextConfiguration otherConfiguration &&\n\t\t\t\tthis.resourceBasePath.equals(otherConfiguration.resourceBasePath)));\n\t}\n\n\t/**\n\t * Generate a unique hash code for all properties of this\n\t * {@code WebMergedContextConfiguration} excluding the\n\t * {@linkplain #getTestClass() test class}.\n\t */\n\t@Override\n\tpublic int hashCode() {\n\t\treturn (31 * super.hashCode() + this.resourceBasePath.hashCode());\n\t}\n\n\t/**\n\t * Provide a String representation of the {@linkplain #getTestClass() test class},\n\t * {@linkplain #getLocations() locations}, {@linkplain #getClasses() annotated classes},\n\t * {@linkplain #getContextInitializerClasses() context initializer classes},\n\t * {@linkplain #getActiveProfiles() active profiles},\n\t * {@linkplain #getPropertySourceDescriptors() property source descriptors},\n\t * {@linkplain #getPropertySourceProperties() property source properties},\n\t * {@linkplain #getContextCustomizers() context customizers},\n\t * {@linkplain #getResourceBasePath() resource base path}, the name of the\n\t * {@link #getContextLoader() ContextLoader}, and the\n\t * {@linkplain #getParent() parent configuration}.\n\t */\n\t@Override\n\tpublic String toString() {\n\t\treturn new ToStringCreator(this, new DefaultToStringStyler(new SimpleValueStyler()))\n\t\t\t\t.append(\"testClass\", getTestClass())\n\t\t\t\t.append(\"locations\", getLocations())\n\t\t\t\t.append(\"classes\", getClasses())\n\t\t\t\t.append(\"contextInitializerClasses\", getContextInitializerClasses())\n\t\t\t\t.append(\"activeProfiles\", getActiveProfiles())\n\t\t\t\t.append(\"propertySourceDescriptors\", getPropertySourceDescriptors())\n\t\t\t\t.append(\"propertySourceProperties\", getPropertySourceProperties())\n\t\t\t\t.append(\"contextCustomizers\", getContextCustomizers())\n\t\t\t\t.append(\"resourceBasePath\", getResourceBasePath())\n\t\t\t\t.append(\"contextLoader\", (getContextLoader() != null ? getContextLoader().getClass() : null))\n\t\t\t\t.append(\"parent\", getParent())\n\t\t\t\t.toString();\n\t}\n\n}"
  },
  "org.springframework.test.context.web.WebMergedContextConfiguration#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied object is equal to this {@code WebMergedContextConfiguration}\n\t * instance by comparing both objects' {@linkplain #getLocations() locations},\n\t * {@linkplain #getClasses() annotated classes},\n\t * {@linkplain #getContextInitializerClasses() context initializer classes},\n\t * {@linkplain #getActiveProfiles() active profiles},\n\t * {@linkplain #getResourceBasePath() resource base paths},\n\t * {@linkplain #getPropertySourceDescriptors() property source descriptors},\n\t * {@linkplain #getPropertySourceProperties() property source properties},\n\t * {@linkplain #getContextCustomizers() context customizers},\n\t * {@linkplain #getParent() parents}, and the fully qualified names of their\n\t * {@link #getContextLoader() ContextLoaders}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (super.equals(other) && other instanceof WebMergedContextConfiguration otherConfiguration &&\n\t\t\t\tthis.resourceBasePath.equals(otherConfiguration.resourceBasePath)));\n\t}"
  },
  "org.springframework.test.context.web.WebMergedContextConfiguration#getResourceBasePath()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the resource path to the root directory of the web application for the\n\t * {@linkplain #getTestClass() test class}, configured via {@code @WebAppConfiguration}.\n\t * @see WebAppConfiguration\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "String",
    "signature": "public String getResourceBasePath()",
    "source_code": "\tpublic String getResourceBasePath() {\n\t\treturn this.resourceBasePath;\n\t}"
  },
  "org.springframework.test.context.web.WebMergedContextConfiguration#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate a unique hash code for all properties of this\n\t * {@code WebMergedContextConfiguration} excluding the\n\t * {@linkplain #getTestClass() test class}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 231
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn (31 * super.hashCode() + this.resourceBasePath.hashCode());\n\t}"
  },
  "org.springframework.test.context.web.WebMergedContextConfiguration#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide a String representation of the {@linkplain #getTestClass() test class},\n\t * {@linkplain #getLocations() locations}, {@linkplain #getClasses() annotated classes},\n\t * {@linkplain #getContextInitializerClasses() context initializer classes},\n\t * {@linkplain #getActiveProfiles() active profiles},\n\t * {@linkplain #getPropertySourceDescriptors() property source descriptors},\n\t * {@linkplain #getPropertySourceProperties() property source properties},\n\t * {@linkplain #getContextCustomizers() context customizers},\n\t * {@linkplain #getResourceBasePath() resource base path}, the name of the\n\t * {@link #getContextLoader() ContextLoader}, and the\n\t * {@linkplain #getParent() parent configuration}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn new ToStringCreator(this, new DefaultToStringStyler(new SimpleValueStyler()))\n\t\t\t\t.append(\"testClass\", getTestClass())\n\t\t\t\t.append(\"locations\", getLocations())\n\t\t\t\t.append(\"classes\", getClasses())\n\t\t\t\t.append(\"contextInitializerClasses\", getContextInitializerClasses())\n\t\t\t\t.append(\"activeProfiles\", getActiveProfiles())\n\t\t\t\t.append(\"propertySourceDescriptors\", getPropertySourceDescriptors())\n\t\t\t\t.append(\"propertySourceProperties\", getPropertySourceProperties())\n\t\t\t\t.append(\"contextCustomizers\", getContextCustomizers())\n\t\t\t\t.append(\"resourceBasePath\", getResourceBasePath())\n\t\t\t\t.append(\"contextLoader\", (getContextLoader() != null ? getContextLoader().getClass() : null))\n\t\t\t\t.append(\"parent\", getParent())\n\t\t\t\t.toString();\n\t}"
  },
  "org.springframework.test.json.JsonContentAssert": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * AssertJ {@link org.assertj.core.api.Assert assertions} that can be applied\n * to a {@link CharSequence} representation of a JSON document, mostly to\n * compare the JSON document against a target, using {@linkplain JSONCompare\n * JSON Assert}.\n *\n * @author Phillip Webb\n * @author Andy Wilkinson\n * @author Diego Berrueta\n * @author Camille Vienot\n * @author Stephane Nicoll\n * @since 6.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "public class JsonContentAssert",
    "source_code": "public class JsonContentAssert extends AbstractAssert<JsonContentAssert, CharSequence> {\n\n\tprivate final JsonLoader loader;\n\n\t/**\n\t * Create a new {@link JsonContentAssert} instance that will load resources\n\t * relative to the given {@code resourceLoadClass}, using the given\n\t * {@code charset}.\n\t * @param json the actual JSON content\n\t * @param resourceLoadClass the class used to load resources\n\t * @param charset the charset of the JSON resources\n\t */\n\tpublic JsonContentAssert(@Nullable CharSequence json, @Nullable Class<?> resourceLoadClass,\n\t\t\t@Nullable Charset charset) {\n\n\t\tsuper(json, JsonContentAssert.class);\n\t\tthis.loader = new JsonLoader(resourceLoadClass, charset);\n\t}\n\n\t/**\n\t * Create a new {@link JsonContentAssert} instance that will load resources\n\t * relative to the given {@code resourceLoadClass}, using {@code UTF-8}.\n\t * @param json the actual JSON content\n\t * @param resourceLoadClass the class used to load resources\n\t */\n\tpublic JsonContentAssert(@Nullable CharSequence json, @Nullable Class<?> resourceLoadClass) {\n\t\tthis(json, resourceLoadClass, null);\n\t}\n\n\n\t/**\n\t * Verify that the actual value is equal to the given JSON. The\n\t * {@code expected} value can contain the JSON itself or, if it ends with\n\t * {@code .json}, the name of a resource to be loaded from the classpath.\n\t * @param expected the expected JSON or the name of a resource containing\n\t * the expected JSON\n\t * @param compareMode the compare mode used when checking\n\t */\n\tpublic JsonContentAssert isEqualTo(@Nullable CharSequence expected, JSONCompareMode compareMode) {\n\t\tString expectedJson = this.loader.getJson(expected);\n\t\treturn assertNotFailed(compare(expectedJson, compareMode));\n\t}\n\n\t/**\n\t * Verify that the actual value is equal to the given JSON {@link Resource}.\n\t * <p>The resource abstraction allows to provide several input types:\n\t * <ul>\n\t * <li>a {@code byte} array, using {@link ByteArrayResource}</li>\n\t * <li>a {@code classpath} resource, using {@link ClassPathResource}</li>\n\t * <li>a {@link File} or {@link Path}, using {@link FileSystemResource}</li>\n\t * <li>an {@link InputStream}, using {@link InputStreamResource}</li>\n\t * </ul>\n\t * @param expected a resource containing the expected JSON\n\t * @param compareMode the compare mode used when checking\n\t */\n\tpublic JsonContentAssert isEqualTo(Resource expected, JSONCompareMode compareMode) {\n\t\tString expectedJson = this.loader.getJson(expected);\n\t\treturn assertNotFailed(compare(expectedJson, compareMode));\n\t}\n\n\t/**\n\t * Verify that the actual value is equal to the given JSON. The\n\t * {@code expected} value can contain the JSON itself or, if it ends with\n\t * {@code .json}, the name of a resource to be loaded from the classpath.\n\t * @param expected the expected JSON or the name of a resource containing\n\t * the expected JSON\n\t * @param comparator the comparator used when checking\n\t */\n\tpublic JsonContentAssert isEqualTo(@Nullable CharSequence expected, JSONComparator comparator) {\n\t\tString expectedJson = this.loader.getJson(expected);\n\t\treturn assertNotFailed(compare(expectedJson, comparator));\n\t}\n\n\t/**\n\t * Verify that the actual value is equal to the given JSON {@link Resource}.\n\t * <p>The resource abstraction allows to provide several input types:\n\t * <ul>\n\t * <li>a {@code byte} array, using {@link ByteArrayResource}</li>\n\t * <li>a {@code classpath} resource, using {@link ClassPathResource}</li>\n\t * <li>a {@link File} or {@link Path}, using {@link FileSystemResource}</li>\n\t * <li>an {@link InputStream}, using {@link InputStreamResource}</li>\n\t * </ul>\n\t * @param expected a resource containing the expected JSON\n\t * @param comparator the comparator used when checking\n\t */\n\tpublic JsonContentAssert isEqualTo(Resource expected, JSONComparator comparator) {\n\t\tString expectedJson = this.loader.getJson(expected);\n\t\treturn assertNotFailed(compare(expectedJson, comparator));\n\t}\n\n\t/**\n\t * Verify that the actual value is {@link JSONCompareMode#LENIENT leniently}\n\t * equal to the given JSON. The {@code expected} value can contain the JSON\n\t * itself or, if it ends with {@code .json}, the name of a resource to be\n\t * loaded from the classpath.\n\t * @param expected the expected JSON or the name of a resource containing\n\t * the expected JSON\n\t */\n\tpublic JsonContentAssert isLenientlyEqualTo(@Nullable CharSequence expected) {\n\t\treturn isEqualTo(expected, JSONCompareMode.LENIENT);\n\t}\n\n\t/**\n\t * Verify that the actual value is {@link JSONCompareMode#LENIENT leniently}\n\t * equal to the given JSON {@link Resource}.\n\t * <p>The resource abstraction allows to provide several input types:\n\t * <ul>\n\t * <li>a {@code byte} array, using {@link ByteArrayResource}</li>\n\t * <li>a {@code classpath} resource, using {@link ClassPathResource}</li>\n\t * <li>a {@link File} or {@link Path}, using {@link FileSystemResource}</li>\n\t * <li>an {@link InputStream}, using {@link InputStreamResource}</li>\n\t * </ul>\n\t * @param expected a resource containing the expected JSON\n\t */\n\tpublic JsonContentAssert isLenientlyEqualTo(Resource expected) {\n\t\treturn isEqualTo(expected, JSONCompareMode.LENIENT);\n\t}\n\n\t/**\n\t * Verify that the actual value is {@link JSONCompareMode#STRICT strictly}\n\t * equal to the given JSON. The {@code expected} value can contain the JSON\n\t * itself or, if it ends with {@code .json}, the name of a resource to be\n\t * loaded from the classpath.\n\t * @param expected the expected JSON or the name of a resource containing\n\t * the expected JSON\n\t */\n\tpublic JsonContentAssert isStrictlyEqualTo(@Nullable CharSequence expected) {\n\t\treturn isEqualTo(expected, JSONCompareMode.STRICT);\n\t}\n\n\t/**\n\t * Verify that the actual value is {@link JSONCompareMode#STRICT strictly}\n\t * equal to the given JSON {@link Resource}.\n\t * <p>The resource abstraction allows to provide several input types:\n\t * <ul>\n\t * <li>a {@code byte} array, using {@link ByteArrayResource}</li>\n\t * <li>a {@code classpath} resource, using {@link ClassPathResource}</li>\n\t * <li>a {@link File} or {@link Path}, using {@link FileSystemResource}</li>\n\t * <li>an {@link InputStream}, using {@link InputStreamResource}</li>\n\t * </ul>\n\t * @param expected a resource containing the expected JSON\n\t */\n\tpublic JsonContentAssert isStrictlyEqualTo(Resource expected) {\n\t\treturn isEqualTo(expected, JSONCompareMode.STRICT);\n\t}\n\n\t/**\n\t * Verify that the actual value is not equal to the given JSON. The\n\t * {@code expected} value can contain the JSON itself or, if it ends with\n\t * {@code .json}, the name of a resource to be loaded from the classpath.\n\t * @param expected the expected JSON or the name of a resource containing\n\t * the expected JSON\n\t * @param compareMode the compare mode used when checking\n\t */\n\tpublic JsonContentAssert isNotEqualTo(@Nullable CharSequence expected, JSONCompareMode compareMode) {\n\t\tString expectedJson = this.loader.getJson(expected);\n\t\treturn assertNotPassed(compare(expectedJson, compareMode));\n\t}\n\n\t/**\n\t * Verify that the actual value is not equal to the given JSON {@link Resource}.\n\t * <p>The resource abstraction allows to provide several input types:\n\t * <ul>\n\t * <li>a {@code byte} array, using {@link ByteArrayResource}</li>\n\t * <li>a {@code classpath} resource, using {@link ClassPathResource}</li>\n\t * <li>a {@link File} or {@link Path}, using {@link FileSystemResource}</li>\n\t * <li>an {@link InputStream}, using {@link InputStreamResource}</li>\n\t * </ul>\n\t * @param expected a resource containing the expected JSON\n\t * @param compareMode the compare mode used when checking\n\t */\n\tpublic JsonContentAssert isNotEqualTo(Resource expected, JSONCompareMode compareMode) {\n\t\tString expectedJson = this.loader.getJson(expected);\n\t\treturn assertNotPassed(compare(expectedJson, compareMode));\n\t}\n\n\t/**\n\t * Verify that the actual value is not equal to the given JSON. The\n\t * {@code expected} value can contain the JSON itself or, if it ends with\n\t * {@code .json}, the name of a resource to be loaded from the classpath.\n\t * @param expected the expected JSON or the name of a resource containing\n\t * the expected JSON\n\t * @param comparator the comparator used when checking\n\t */\n\tpublic JsonContentAssert isNotEqualTo(@Nullable CharSequence expected, JSONComparator comparator) {\n\t\tString expectedJson = this.loader.getJson(expected);\n\t\treturn assertNotPassed(compare(expectedJson, comparator));\n\t}\n\n\t/**\n\t * Verify that the actual value is not equal to the given JSON {@link Resource}.\n\t * <p>The resource abstraction allows to provide several input types:\n\t * <ul>\n\t * <li>a {@code byte} array, using {@link ByteArrayResource}</li>\n\t * <li>a {@code classpath} resource, using {@link ClassPathResource}</li>\n\t * <li>a {@link File} or {@link Path}, using {@link FileSystemResource}</li>\n\t * <li>an {@link InputStream}, using {@link InputStreamResource}</li>\n\t * </ul>\n\t * @param expected a resource containing the expected JSON\n\t * @param comparator the comparator used when checking\n\t */\n\tpublic JsonContentAssert isNotEqualTo(Resource expected, JSONComparator comparator) {\n\t\tString expectedJson = this.loader.getJson(expected);\n\t\treturn assertNotPassed(compare(expectedJson, comparator));\n\t}\n\n\t/**\n\t * Verify that the actual value is not {@link JSONCompareMode#LENIENT\n\t * leniently} equal to the given JSON. The {@code expected} value can\n\t * contain the JSON itself or, if it ends with {@code .json}, the name of a\n\t * resource to be loaded from the classpath.\n\t * @param expected the expected JSON or the name of a resource containing\n\t * the expected JSON\n\t */\n\tpublic JsonContentAssert isNotLenientlyEqualTo(@Nullable CharSequence expected) {\n\t\treturn isNotEqualTo(expected, JSONCompareMode.LENIENT);\n\t}\n\n\t/**\n\t * Verify that the actual value is not {@link JSONCompareMode#LENIENT\n\t * leniently} equal to the given JSON {@link Resource}.\n\t * <p>The resource abstraction allows to provide several input types:\n\t * <ul>\n\t * <li>a {@code byte} array, using {@link ByteArrayResource}</li>\n\t * <li>a {@code classpath} resource, using {@link ClassPathResource}</li>\n\t * <li>a {@link File} or {@link Path}, using {@link FileSystemResource}</li>\n\t * <li>an {@link InputStream}, using {@link InputStreamResource}</li>\n\t * </ul>\n\t * @param expected a resource containing the expected JSON\n\t */\n\tpublic JsonContentAssert isNotLenientlyEqualTo(Resource expected) {\n\t\treturn isNotEqualTo(expected, JSONCompareMode.LENIENT);\n\t}\n\n\t/**\n\t * Verify that the actual value is not {@link JSONCompareMode#STRICT\n\t * strictly} equal to the given JSON. The {@code expected} value can\n\t * contain the JSON itself or, if it ends with {@code .json}, the name of a\n\t * resource to be loaded from the classpath.\n\t * @param expected the expected JSON or the name of a resource containing\n\t * the expected JSON\n\t */\n\tpublic JsonContentAssert isNotStrictlyEqualTo(@Nullable CharSequence expected) {\n\t\treturn isNotEqualTo(expected, JSONCompareMode.STRICT);\n\t}\n\n\t/**\n\t * Verify that the actual value is not {@link JSONCompareMode#STRICT\n\t * strictly} equal to the given JSON {@link Resource}.\n\t * <p>The resource abstraction allows to provide several input types:\n\t * <ul>\n\t * <li>a {@code byte} array, using {@link ByteArrayResource}</li>\n\t * <li>a {@code classpath} resource, using {@link ClassPathResource}</li>\n\t * <li>a {@link File} or {@link Path}, using {@link FileSystemResource}</li>\n\t * <li>an {@link InputStream}, using {@link InputStreamResource}</li>\n\t * </ul>\n\t * @param expected a resource containing the expected JSON\n\t */\n\tpublic JsonContentAssert isNotStrictlyEqualTo(Resource expected) {\n\t\treturn isNotEqualTo(expected, JSONCompareMode.STRICT);\n\t}\n\n\n\tprivate JSONCompareResult compare(@Nullable CharSequence expectedJson, JSONCompareMode compareMode) {\n\t\treturn compare(this.actual, expectedJson, (actualJsonString, expectedJsonString) ->\n\t\t\t\tJSONCompare.compareJSON(expectedJsonString, actualJsonString, compareMode));\n\t}\n\n\tprivate JSONCompareResult compare(@Nullable CharSequence expectedJson, JSONComparator comparator) {\n\t\treturn compare(this.actual, expectedJson, (actualJsonString, expectedJsonString) ->\n\t\t\t\tJSONCompare.compareJSON(expectedJsonString, actualJsonString, comparator));\n\t}\n\n\tprivate JSONCompareResult compare(@Nullable CharSequence actualJson, @Nullable CharSequence expectedJson,\n\t\t\tThrowingBiFunction<String, String, JSONCompareResult> comparator) {\n\n\t\tif (actualJson == null) {\n\t\t\treturn compareForNull(expectedJson);\n\t\t}\n\t\tif (expectedJson == null) {\n\t\t\treturn compareForNull(actualJson.toString());\n\t\t}\n\t\ttry {\n\t\t\treturn comparator.applyWithException(actualJson.toString(), expectedJson.toString());\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (ex instanceof RuntimeException runtimeException) {\n\t\t\t\tthrow runtimeException;\n\t\t\t}\n\t\t\tthrow new IllegalStateException(ex);\n\t\t}\n\t}\n\n\tprivate JSONCompareResult compareForNull(@Nullable CharSequence expectedJson) {\n\t\tJSONCompareResult result = new JSONCompareResult();\n\t\tif (expectedJson != null) {\n\t\t\tresult.fail(\"Expected null JSON\");\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate JsonContentAssert assertNotFailed(JSONCompareResult result) {\n\t\tif (result.failed()) {\n\t\t\tfailWithMessage(\"JSON comparison failure: %s\", result.getMessage());\n\t\t}\n\t\treturn this;\n\t}\n\n\tprivate JsonContentAssert assertNotPassed(JSONCompareResult result) {\n\t\tif (result.passed()) {\n\t\t\tfailWithMessage(\"JSON comparison failure: %s\", result.getMessage());\n\t\t}\n\t\treturn this;\n\t}\n\n}"
  },
  "org.springframework.test.json.JsonContentAssert#isEqualTo(expected,comparator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Verify that the actual value is equal to the given JSON {@link Resource}.\n\t * <p>The resource abstraction allows to provide several input types:\n\t * <ul>\n\t * <li>a {@code byte} array, using {@link ByteArrayResource}</li>\n\t * <li>a {@code classpath} resource, using {@link ClassPathResource}</li>\n\t * <li>a {@link File} or {@link Path}, using {@link FileSystemResource}</li>\n\t * <li>an {@link InputStream}, using {@link InputStreamResource}</li>\n\t * </ul>\n\t * @param expected a resource containing the expected JSON\n\t * @param comparator the comparator used when checking\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expected",
      "comparator"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "JsonContentAssert",
    "signature": "public JsonContentAssert isEqualTo(Resource expected, JSONComparator comparator)",
    "source_code": "\tpublic JsonContentAssert isEqualTo(Resource expected, JSONComparator comparator) {\n\t\tString expectedJson = this.loader.getJson(expected);\n\t\treturn assertNotFailed(compare(expectedJson, comparator));\n\t}"
  },
  "org.springframework.test.json.JsonContentAssert#isEqualTo(expected,compareMode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Verify that the actual value is equal to the given JSON {@link Resource}.\n\t * <p>The resource abstraction allows to provide several input types:\n\t * <ul>\n\t * <li>a {@code byte} array, using {@link ByteArrayResource}</li>\n\t * <li>a {@code classpath} resource, using {@link ClassPathResource}</li>\n\t * <li>a {@link File} or {@link Path}, using {@link FileSystemResource}</li>\n\t * <li>an {@link InputStream}, using {@link InputStreamResource}</li>\n\t * </ul>\n\t * @param expected a resource containing the expected JSON\n\t * @param compareMode the compare mode used when checking\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expected",
      "compareMode"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "JsonContentAssert",
    "signature": "public JsonContentAssert isEqualTo(Resource expected, JSONCompareMode compareMode)",
    "source_code": "\tpublic JsonContentAssert isEqualTo(Resource expected, JSONCompareMode compareMode) {\n\t\tString expectedJson = this.loader.getJson(expected);\n\t\treturn assertNotFailed(compare(expectedJson, compareMode));\n\t}"
  },
  "org.springframework.test.json.JsonContentAssert#isLenientlyEqualTo(expected)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Verify that the actual value is {@link JSONCompareMode#LENIENT leniently}\n\t * equal to the given JSON {@link Resource}.\n\t * <p>The resource abstraction allows to provide several input types:\n\t * <ul>\n\t * <li>a {@code byte} array, using {@link ByteArrayResource}</li>\n\t * <li>a {@code classpath} resource, using {@link ClassPathResource}</li>\n\t * <li>a {@link File} or {@link Path}, using {@link FileSystemResource}</li>\n\t * <li>an {@link InputStream}, using {@link InputStreamResource}</li>\n\t * </ul>\n\t * @param expected a resource containing the expected JSON\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expected"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "JsonContentAssert",
    "signature": "public JsonContentAssert isLenientlyEqualTo(Resource expected)",
    "source_code": "\tpublic JsonContentAssert isLenientlyEqualTo(Resource expected) {\n\t\treturn isEqualTo(expected, JSONCompareMode.LENIENT);\n\t}"
  },
  "org.springframework.test.json.JsonContentAssert#isNotEqualTo(expected,comparator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Verify that the actual value is not equal to the given JSON {@link Resource}.\n\t * <p>The resource abstraction allows to provide several input types:\n\t * <ul>\n\t * <li>a {@code byte} array, using {@link ByteArrayResource}</li>\n\t * <li>a {@code classpath} resource, using {@link ClassPathResource}</li>\n\t * <li>a {@link File} or {@link Path}, using {@link FileSystemResource}</li>\n\t * <li>an {@link InputStream}, using {@link InputStreamResource}</li>\n\t * </ul>\n\t * @param expected a resource containing the expected JSON\n\t * @param comparator the comparator used when checking\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expected",
      "comparator"
    ],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "JsonContentAssert",
    "signature": "public JsonContentAssert isNotEqualTo(Resource expected, JSONComparator comparator)",
    "source_code": "\tpublic JsonContentAssert isNotEqualTo(Resource expected, JSONComparator comparator) {\n\t\tString expectedJson = this.loader.getJson(expected);\n\t\treturn assertNotPassed(compare(expectedJson, comparator));\n\t}"
  },
  "org.springframework.test.json.JsonContentAssert#isNotEqualTo(expected,compareMode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Verify that the actual value is not equal to the given JSON {@link Resource}.\n\t * <p>The resource abstraction allows to provide several input types:\n\t * <ul>\n\t * <li>a {@code byte} array, using {@link ByteArrayResource}</li>\n\t * <li>a {@code classpath} resource, using {@link ClassPathResource}</li>\n\t * <li>a {@link File} or {@link Path}, using {@link FileSystemResource}</li>\n\t * <li>an {@link InputStream}, using {@link InputStreamResource}</li>\n\t * </ul>\n\t * @param expected a resource containing the expected JSON\n\t * @param compareMode the compare mode used when checking\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expected",
      "compareMode"
    ],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "JsonContentAssert",
    "signature": "public JsonContentAssert isNotEqualTo(Resource expected, JSONCompareMode compareMode)",
    "source_code": "\tpublic JsonContentAssert isNotEqualTo(Resource expected, JSONCompareMode compareMode) {\n\t\tString expectedJson = this.loader.getJson(expected);\n\t\treturn assertNotPassed(compare(expectedJson, compareMode));\n\t}"
  },
  "org.springframework.test.json.JsonContentAssert#isNotLenientlyEqualTo(expected)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Verify that the actual value is not {@link JSONCompareMode#LENIENT\n\t * leniently} equal to the given JSON {@link Resource}.\n\t * <p>The resource abstraction allows to provide several input types:\n\t * <ul>\n\t * <li>a {@code byte} array, using {@link ByteArrayResource}</li>\n\t * <li>a {@code classpath} resource, using {@link ClassPathResource}</li>\n\t * <li>a {@link File} or {@link Path}, using {@link FileSystemResource}</li>\n\t * <li>an {@link InputStream}, using {@link InputStreamResource}</li>\n\t * </ul>\n\t * @param expected a resource containing the expected JSON\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expected"
    ],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "JsonContentAssert",
    "signature": "public JsonContentAssert isNotLenientlyEqualTo(Resource expected)",
    "source_code": "\tpublic JsonContentAssert isNotLenientlyEqualTo(Resource expected) {\n\t\treturn isNotEqualTo(expected, JSONCompareMode.LENIENT);\n\t}"
  },
  "org.springframework.test.json.JsonContentAssert#isNotStrictlyEqualTo(expected)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Verify that the actual value is not {@link JSONCompareMode#STRICT\n\t * strictly} equal to the given JSON {@link Resource}.\n\t * <p>The resource abstraction allows to provide several input types:\n\t * <ul>\n\t * <li>a {@code byte} array, using {@link ByteArrayResource}</li>\n\t * <li>a {@code classpath} resource, using {@link ClassPathResource}</li>\n\t * <li>a {@link File} or {@link Path}, using {@link FileSystemResource}</li>\n\t * <li>an {@link InputStream}, using {@link InputStreamResource}</li>\n\t * </ul>\n\t * @param expected a resource containing the expected JSON\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expected"
    ],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "JsonContentAssert",
    "signature": "public JsonContentAssert isNotStrictlyEqualTo(Resource expected)",
    "source_code": "\tpublic JsonContentAssert isNotStrictlyEqualTo(Resource expected) {\n\t\treturn isNotEqualTo(expected, JSONCompareMode.STRICT);\n\t}"
  },
  "org.springframework.test.json.JsonContentAssert#isStrictlyEqualTo(expected)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Verify that the actual value is {@link JSONCompareMode#STRICT strictly}\n\t * equal to the given JSON {@link Resource}.\n\t * <p>The resource abstraction allows to provide several input types:\n\t * <ul>\n\t * <li>a {@code byte} array, using {@link ByteArrayResource}</li>\n\t * <li>a {@code classpath} resource, using {@link ClassPathResource}</li>\n\t * <li>a {@link File} or {@link Path}, using {@link FileSystemResource}</li>\n\t * <li>an {@link InputStream}, using {@link InputStreamResource}</li>\n\t * </ul>\n\t * @param expected a resource containing the expected JSON\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expected"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "JsonContentAssert",
    "signature": "public JsonContentAssert isStrictlyEqualTo(Resource expected)",
    "source_code": "\tpublic JsonContentAssert isStrictlyEqualTo(Resource expected) {\n\t\treturn isEqualTo(expected, JSONCompareMode.STRICT);\n\t}"
  },
  "org.springframework.test.util.JsonPathExpectationsHelper#evaluateJsonPath(content,targetType)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #evaluateJsonPath(String)} with a target type that has\n\t * generics.\n\t * <p>This must be used with a {@link Configuration} that defines a more\n\t * elaborate {@link MappingProvider} as the default one cannot handle\n\t * generic types.\n\t * @param content the content to evaluate against\n\t * @param targetType the requested target type\n\t * @return the result of the evaluation\n\t * @throws AssertionError if the evaluation fails\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 381
    },
    "return": "T",
    "signature": "public T evaluateJsonPath(String content, ParameterizedTypeReference<T> targetType)",
    "source_code": "\tpublic <T> T evaluateJsonPath(String content, ParameterizedTypeReference<T> targetType) {\n\t\treturn evaluateExpression(content, context ->\n\t\t\t\tcontext.read(this.expression, new TypeRefAdapter<>(targetType)));\n\t}"
  },
  "org.springframework.test.util.JsonPathExpectationsHelper#getType()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 425
    },
    "return": "Type",
    "signature": "public Type getType()",
    "source_code": "\t\tpublic Type getType() {\n\t\t\treturn this.type;\n\t\t}"
  },
  "org.springframework.test.web.client.match.ContentRequestMatchers#multipartData(MultiValueMap<String,expectedMap,defaultCharset)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #multipartData(MultiValueMap)} with a defaultCharset.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "expectedMap",
      "defaultCharset"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher multipartData(MultiValueMap<String, ?> expectedMap, Charset defaultCharset)",
    "source_code": "\tpublic RequestMatcher multipartData(MultiValueMap<String, ?> expectedMap, Charset defaultCharset) {\n\t\treturn multipartData(expectedMap, defaultCharset, true);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.AssertableMockMvc": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link MockMvc} variant that tests Spring MVC exchanges and provides fluent\n * assertions using {@link org.assertj.core.api.Assertions AssertJ}.\n *\n * <p>A main difference with {@link MockMvc} is that an unresolved exception\n * is not thrown directly. Rather an {@link AssertableMvcResult} is available\n * with an {@link AssertableMvcResult#getUnresolvedException() unresolved\n * exception}.\n *\n * <p>{@link AssertableMockMvc} can be configured with a list of\n * {@linkplain HttpMessageConverter message converters} to allow the response\n * body to be deserialized, rather than asserting on the raw values.\n *\n * @author Stephane Nicoll\n * @author Brian Clozel\n * @since 6.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "signature": "public class AssertableMockMvc",
    "source_code": "public final class AssertableMockMvc {\n\n\tprivate static final MediaType JSON = MediaType.APPLICATION_JSON;\n\n\tprivate final MockMvc mockMvc;\n\n\t@Nullable\n\tprivate final GenericHttpMessageConverter<Object> jsonMessageConverter;\n\n\n\tprivate AssertableMockMvc(MockMvc mockMvc, @Nullable GenericHttpMessageConverter<Object> jsonMessageConverter) {\n\t\tAssert.notNull(mockMvc, \"mockMVC should not be null\");\n\t\tthis.mockMvc = mockMvc;\n\t\tthis.jsonMessageConverter = jsonMessageConverter;\n\t}\n\n\t/**\n\t * Create a {@link AssertableMockMvc} instance that delegates to the given\n\t * {@link MockMvc} instance.\n\t * @param mockMvc the MockMvc instance to delegate calls to\n\t */\n\tpublic static AssertableMockMvc create(MockMvc mockMvc) {\n\t\treturn new AssertableMockMvc(mockMvc, null);\n\t}\n\n\t/**\n\t * Create an {@link AssertableMockMvc} instance using the given, fully\n\t * initialized (i.e., <em>refreshed</em>) {@link WebApplicationContext}. The\n\t * given {@code customizations} are applied to the {@link DefaultMockMvcBuilder}\n\t * that ultimately creates the underlying {@link MockMvc} instance.\n\t * <p>If no further customization of the underlying {@link MockMvc} instance\n\t * is required, use {@link #from(WebApplicationContext)}.\n\t * @param applicationContext the application context to detect the Spring\n\t * MVC infrastructure and application controllers from\n\t * @param customizations a function that creates a {@link MockMvc}\n\t * instance based on a {@link DefaultMockMvcBuilder}.\n\t * @see MockMvcBuilders#webAppContextSetup(WebApplicationContext)\n\t */\n\tpublic static AssertableMockMvc from(WebApplicationContext applicationContext,\n\t\t\tFunction<DefaultMockMvcBuilder, MockMvc> customizations) {\n\n\t\tDefaultMockMvcBuilder builder = MockMvcBuilders.webAppContextSetup(applicationContext);\n\t\tMockMvc mockMvc = customizations.apply(builder);\n\t\treturn create(mockMvc);\n\t}\n\n\t/**\n\t * Shortcut to create an {@link AssertableMockMvc} instance using the given,\n\t * fully initialized (i.e., <em>refreshed</em>) {@link WebApplicationContext}.\n\t * <p>Consider using {@link #from(WebApplicationContext, Function)} if\n\t * further customization of the underlying {@link MockMvc} instance is\n\t * required.\n\t * @param applicationContext the application context to detect the Spring\n\t * MVC infrastructure and application controllers from\n\t * @see MockMvcBuilders#webAppContextSetup(WebApplicationContext)\n\t */\n\tpublic static AssertableMockMvc from(WebApplicationContext applicationContext) {\n\t\treturn from(applicationContext, DefaultMockMvcBuilder::build);\n\t}\n\n\t/**\n\t * Create an {@link AssertableMockMvc} instance by registering one or more\n\t * {@code @Controller} instances and configuring Spring MVC infrastructure\n\t * programmatically.\n\t * <p>This allows full control over the instantiation and initialization of\n\t * controllers and their dependencies, similar to plain unit tests while\n\t * also making it possible to test one controller at a time.\n\t * @param controllers one or more {@code @Controller} instances or\n\t * {@code @Controller} types to test; a type ({@code Class}) will be turned\n\t * into an instance\n\t * @param customizations a function that creates a {@link MockMvc} instance\n\t * based on a {@link StandaloneMockMvcBuilder}, typically to configure the\n\t * Spring MVC infrastructure\n\t * @see MockMvcBuilders#standaloneSetup(Object...)\n\t */\n\tpublic static AssertableMockMvc of(Collection<?> controllers,\n\t\t\tFunction<StandaloneMockMvcBuilder, MockMvc> customizations) {\n\n\t\tStandaloneMockMvcBuilder builder = MockMvcBuilders.standaloneSetup(controllers.toArray());\n\t\treturn create(customizations.apply(builder));\n\t}\n\n\t/**\n\t * Shortcut to create an {@link AssertableMockMvc} instance by registering\n\t * one or more {@code @Controller} instances.\n\t * <p>The minimum infrastructure required by the\n\t * {@link org.springframework.web.servlet.DispatcherServlet DispatcherServlet}\n\t * to serve requests with annotated controllers is created. Consider using\n\t * {@link #of(Collection, Function)} if additional configuration of the MVC\n\t * infrastructure is required.\n\t * @param controllers one or more {@code @Controller} instances or\n\t * {@code @Controller} types to test; a type ({@code Class}) will be turned\n\t * into an instance\n\t * @see MockMvcBuilders#standaloneSetup(Object...)\n\t */\n\tpublic static AssertableMockMvc of(Object... controllers) {\n\t\treturn of(Arrays.asList(controllers), StandaloneMockMvcBuilder::build);\n\t}\n\n\t/**\n\t * Return a new {@link AssertableMockMvc} instance using the specified\n\t * {@linkplain HttpMessageConverter message converters}.\n\t * <p>If none are specified, only basic assertions on the response body can\n\t * be performed. Consider registering a suitable JSON converter for asserting\n\t * against JSON data structures.\n\t * @param httpMessageConverters the message converters to use\n\t * @return a new instance using the specified converters\n\t */\n\tpublic AssertableMockMvc withHttpMessageConverters(Iterable<HttpMessageConverter<?>> httpMessageConverters) {\n\t\treturn new AssertableMockMvc(this.mockMvc, findJsonMessageConverter(httpMessageConverters));\n\t}\n\n\t/**\n\t * Perform a request and return a type that can be used with standard\n\t * {@link org.assertj.core.api.Assertions AssertJ} assertions.\n\t * <p>Use static methods of {@link MockMvcRequestBuilders} to prepare the\n\t * request, wrapping the invocation in {@code assertThat}. The following\n\t * asserts that a {@linkplain MockMvcRequestBuilders#get(URI) GET} request\n\t * against \"/greet\" has an HTTP status code 200 (OK) and a simple body:\n\t * <pre><code class='java'>assertThat(mvc.perform(get(\"/greet\")))\n\t *       .hasStatusOk()\n\t *       .body().asString().isEqualTo(\"Hello\");\n\t * </code></pre>\n\t * <p>Contrary to {@link MockMvc#perform(RequestBuilder)}, this does not\n\t * throw an exception if the request fails with an unresolved exception.\n\t * Rather, the result provides the exception, if any. Assuming that a\n\t * {@link MockMvcRequestBuilders#post(URI) POST} request against\n\t * {@code /boom} throws an {@code IllegalStateException}, the following\n\t * asserts that the invocation has indeed failed with the expected error\n\t * message:\n\t * <pre><code class='java'>assertThat(mvc.perform(post(\"/boom\")))\n\t *       .unresolvedException().isInstanceOf(IllegalStateException.class)\n\t *       .hasMessage(\"Expected\");\n\t * </code></pre>\n\t * @param requestBuilder used to prepare the request to execute;\n\t * see static factory methods in\n\t * {@link org.springframework.test.web.servlet.request.MockMvcRequestBuilders}\n\t * @return an {@link AssertableMvcResult} to be wrapped in {@code assertThat}\n\t * @see MockMvc#perform(RequestBuilder)\n\t */\n\tpublic AssertableMvcResult perform(RequestBuilder requestBuilder) {\n\t\tObject result = getMvcResultOrFailure(requestBuilder);\n\t\tif (result instanceof MvcResult mvcResult) {\n\t\t\treturn new DefaultAssertableMvcResult(mvcResult, null, this.jsonMessageConverter);\n\t\t}\n\t\telse {\n\t\t\treturn new DefaultAssertableMvcResult(null, (Exception) result, this.jsonMessageConverter);\n\t\t}\n\t}\n\n\tprivate Object getMvcResultOrFailure(RequestBuilder requestBuilder) {\n\t\ttry {\n\t\t\treturn this.mockMvc.perform(requestBuilder).andReturn();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\treturn ex;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Nullable\n\tprivate GenericHttpMessageConverter<Object> findJsonMessageConverter(\n\t\t\tIterable<HttpMessageConverter<?>> messageConverters) {\n\n\t\treturn StreamSupport.stream(messageConverters.spliterator(), false)\n\t\t\t\t.filter(GenericHttpMessageConverter.class::isInstance)\n\t\t\t\t.map(GenericHttpMessageConverter.class::cast)\n\t\t\t\t.filter(converter -> converter.canWrite(null, Map.class, JSON))\n\t\t\t\t.filter(converter -> converter.canRead(Map.class, JSON))\n\t\t\t\t.findFirst().orElse(null);\n\t}\n\n}"
  },
  "org.springframework.test.web.servlet.assertj.AssertableMockMvc#create(mockMvc)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link AssertableMockMvc} instance that delegates to the given\n\t * {@link MockMvc} instance.\n\t * @param mockMvc the MockMvc instance to delegate calls to\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mockMvc"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "AssertableMockMvc",
    "signature": "public AssertableMockMvc create(MockMvc mockMvc)",
    "source_code": "\tpublic static AssertableMockMvc create(MockMvc mockMvc) {\n\t\treturn new AssertableMockMvc(mockMvc, null);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.AssertableMockMvc#from(applicationContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Shortcut to create an {@link AssertableMockMvc} instance using the given,\n\t * fully initialized (i.e., <em>refreshed</em>) {@link WebApplicationContext}.\n\t * <p>Consider using {@link #from(WebApplicationContext, Function)} if\n\t * further customization of the underlying {@link MockMvc} instance is\n\t * required.\n\t * @param applicationContext the application context to detect the Spring\n\t * MVC infrastructure and application controllers from\n\t * @see MockMvcBuilders#webAppContextSetup(WebApplicationContext)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "applicationContext"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "AssertableMockMvc",
    "signature": "public AssertableMockMvc from(WebApplicationContext applicationContext)",
    "source_code": "\tpublic static AssertableMockMvc from(WebApplicationContext applicationContext) {\n\t\treturn from(applicationContext, DefaultMockMvcBuilder::build);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.AssertableMockMvc#from(applicationContext,Function<DefaultMockMvcBuilder,customizations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an {@link AssertableMockMvc} instance using the given, fully\n\t * initialized (i.e., <em>refreshed</em>) {@link WebApplicationContext}. The\n\t * given {@code customizations} are applied to the {@link DefaultMockMvcBuilder}\n\t * that ultimately creates the underlying {@link MockMvc} instance.\n\t * <p>If no further customization of the underlying {@link MockMvc} instance\n\t * is required, use {@link #from(WebApplicationContext)}.\n\t * @param applicationContext the application context to detect the Spring\n\t * MVC infrastructure and application controllers from\n\t * @param customizations a function that creates a {@link MockMvc}\n\t * instance based on a {@link DefaultMockMvcBuilder}.\n\t * @see MockMvcBuilders#webAppContextSetup(WebApplicationContext)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "applicationContext",
      "Function<DefaultMockMvcBuilder",
      "customizations"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "AssertableMockMvc",
    "signature": "public AssertableMockMvc from(WebApplicationContext applicationContext,\n\t\t\tFunction<DefaultMockMvcBuilder, MockMvc> customizations)",
    "source_code": "\tpublic static AssertableMockMvc from(WebApplicationContext applicationContext,"
  },
  "org.springframework.test.web.servlet.assertj.AssertableMockMvc#of(controllers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Shortcut to create an {@link AssertableMockMvc} instance by registering\n\t * one or more {@code @Controller} instances.\n\t * <p>The minimum infrastructure required by the\n\t * {@link org.springframework.web.servlet.DispatcherServlet DispatcherServlet}\n\t * to serve requests with annotated controllers is created. Consider using\n\t * {@link #of(Collection, Function)} if additional configuration of the MVC\n\t * infrastructure is required.\n\t * @param controllers one or more {@code @Controller} instances or\n\t * {@code @Controller} types to test; a type ({@code Class}) will be turned\n\t * into an instance\n\t * @see MockMvcBuilders#standaloneSetup(Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "controllers"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "AssertableMockMvc",
    "signature": "public AssertableMockMvc of(Object... controllers)",
    "source_code": "\tpublic static AssertableMockMvc of(Object... controllers) {\n\t\treturn of(Arrays.asList(controllers), StandaloneMockMvcBuilder::build);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.AssertableMockMvc#of(controllers,Function<StandaloneMockMvcBuilder,customizations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an {@link AssertableMockMvc} instance by registering one or more\n\t * {@code @Controller} instances and configuring Spring MVC infrastructure\n\t * programmatically.\n\t * <p>This allows full control over the instantiation and initialization of\n\t * controllers and their dependencies, similar to plain unit tests while\n\t * also making it possible to test one controller at a time.\n\t * @param controllers one or more {@code @Controller} instances or\n\t * {@code @Controller} types to test; a type ({@code Class}) will be turned\n\t * into an instance\n\t * @param customizations a function that creates a {@link MockMvc} instance\n\t * based on a {@link StandaloneMockMvcBuilder}, typically to configure the\n\t * Spring MVC infrastructure\n\t * @see MockMvcBuilders#standaloneSetup(Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "controllers",
      "Function<StandaloneMockMvcBuilder",
      "customizations"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "AssertableMockMvc",
    "signature": "public AssertableMockMvc of(Collection<?> controllers,\n\t\t\tFunction<StandaloneMockMvcBuilder, MockMvc> customizations)",
    "source_code": "\tpublic static AssertableMockMvc of(Collection<?> controllers,"
  },
  "org.springframework.test.web.servlet.assertj.AssertableMockMvc#perform(requestBuilder)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform a request and return a type that can be used with standard\n\t * {@link org.assertj.core.api.Assertions AssertJ} assertions.\n\t * <p>Use static methods of {@link MockMvcRequestBuilders} to prepare the\n\t * request, wrapping the invocation in {@code assertThat}. The following\n\t * asserts that a {@linkplain MockMvcRequestBuilders#get(URI) GET} request\n\t * against \"/greet\" has an HTTP status code 200 (OK) and a simple body:\n\t * <pre><code class='java'>assertThat(mvc.perform(get(\"/greet\")))\n\t *       .hasStatusOk()\n\t *       .body().asString().isEqualTo(\"Hello\");\n\t * </code></pre>\n\t * <p>Contrary to {@link MockMvc#perform(RequestBuilder)}, this does not\n\t * throw an exception if the request fails with an unresolved exception.\n\t * Rather, the result provides the exception, if any. Assuming that a\n\t * {@link MockMvcRequestBuilders#post(URI) POST} request against\n\t * {@code /boom} throws an {@code IllegalStateException}, the following\n\t * asserts that the invocation has indeed failed with the expected error\n\t * message:\n\t * <pre><code class='java'>assertThat(mvc.perform(post(\"/boom\")))\n\t *       .unresolvedException().isInstanceOf(IllegalStateException.class)\n\t *       .hasMessage(\"Expected\");\n\t * </code></pre>\n\t * @param requestBuilder used to prepare the request to execute;\n\t * see static factory methods in\n\t * {@link org.springframework.test.web.servlet.request.MockMvcRequestBuilders}\n\t * @return an {@link AssertableMvcResult} to be wrapped in {@code assertThat}\n\t * @see MockMvc#perform(RequestBuilder)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestBuilder"
    ],
    "position": {
      "column": 1,
      "line": 197
    },
    "return": "AssertableMvcResult",
    "signature": "public AssertableMvcResult perform(RequestBuilder requestBuilder)",
    "source_code": "\tpublic AssertableMvcResult perform(RequestBuilder requestBuilder) {\n\t\tObject result = getMvcResultOrFailure(requestBuilder);\n\t\tif (result instanceof MvcResult mvcResult) {\n\t\t\treturn new DefaultAssertableMvcResult(mvcResult, null, this.jsonMessageConverter);\n\t\t}\n\t\telse {\n\t\t\treturn new DefaultAssertableMvcResult(null, (Exception) result, this.jsonMessageConverter);\n\t\t}\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.AssertableMockMvc#withHttpMessageConverters(httpMessageConverters)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a new {@link AssertableMockMvc} instance using the specified\n\t * {@linkplain HttpMessageConverter message converters}.\n\t * <p>If none are specified, only basic assertions on the response body can\n\t * be performed. Consider registering a suitable JSON converter for asserting\n\t * against JSON data structures.\n\t * @param httpMessageConverters the message converters to use\n\t * @return a new instance using the specified converters\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "httpMessageConverters"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "AssertableMockMvc",
    "signature": "public AssertableMockMvc withHttpMessageConverters(Iterable<HttpMessageConverter<?>> httpMessageConverters)",
    "source_code": "\tpublic AssertableMockMvc withHttpMessageConverters(Iterable<HttpMessageConverter<?>> httpMessageConverters) {\n\t\treturn new AssertableMockMvc(this.mockMvc, findJsonMessageConverter(httpMessageConverters));\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.HandlerResultAssert": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * AssertJ {@link org.assertj.core.api.Assert assertions} that can be applied to\n * a handler or handler method.\n\n * @author Stephane Nicoll\n * @since 6.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class HandlerResultAssert",
    "source_code": "public class HandlerResultAssert extends AbstractObjectAssert<HandlerResultAssert, Object> {\n\n\tpublic HandlerResultAssert(@Nullable Object actual) {\n\t\tsuper(actual, HandlerResultAssert.class);\n\t\tas(\"Handler result\");\n\t}\n\n\t/**\n\t * Return a new {@linkplain MethodAssert assertion} object that uses\n\t * the {@link Method} that handles the request as the object to test.\n\t * <p>Verifies first that the handler is a {@linkplain #isMethodHandler()\n\t * method handler}.\n\t * <p>Example: <pre><code class='java'>\n\t * // Check that a GET to \"/greet\" is invoked on a \"handleGreet\" method name\n\t * assertThat(mvc.perform(get(\"/greet\")).handler().method().hasName(\"sayGreet\");\n\t * </code></pre>\n\t */\n\tpublic MethodAssert method() {\n\t\treturn new MethodAssert(getHandlerMethod());\n\t}\n\n\t/**\n\t * Verify that the handler is managed by a method invocation, typically on\n\t * a controller.\n\t */\n\tpublic HandlerResultAssert isMethodHandler() {\n\t\treturn isNotNull().isInstanceOf(HandlerMethod.class);\n\t}\n\n\t/**\n\t * Verify that the handler is managed by the given {@code handlerMethod}.\n\t * <p>This creates a \"mock\" for the given {@code controllerType} and records\n\t * the method invocation in the {@code handlerMethod}. The arguments used by\n\t * the target method invocation can be {@code null} as the purpose of the mock\n\t * is to identify the method that was invoked.\n\t * <p>Example: <pre><code class='java'>\n\t * // If the method has a return type, you can return the result of the invocation\n\t * assertThat(mvc.perform(get(\"/greet\")).handler().isInvokedOn(\n\t *         GreetController.class, controller -> controller.sayGreet());\n\t *\n\t * // If the method has a void return type, the controller should be returned\n\t * assertThat(mvc.perform(post(\"/persons/\")).handler().isInvokedOn(\n\t *         PersonController.class, controller -> controller.createPerson(null, null));\n\t * </code></pre>\n\t * @param controllerType the controller to mock\n\t * @param handlerMethod the method\n\t */\n\tpublic <T> HandlerResultAssert isInvokedOn(Class<T> controllerType, Function<T, Object> handlerMethod) {\n\t\tMethodAssert actual = method();\n\t\tObject methodInvocationInfo = handlerMethod.apply(MvcUriComponentsBuilder.on(controllerType));\n\t\tAssertions.assertThat(methodInvocationInfo)\n\t\t\t\t.as(\"Method invocation on controller '%s'\", controllerType.getSimpleName())\n\t\t\t\t.isInstanceOfSatisfying(MethodInvocationInfo.class, mii ->\n\t\t\t\t\t\tactual.isEqualTo(mii.getControllerMethod()));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Verify that the handler is of the given {@code type}. For a controller\n\t * method, this is the type of the controller.\n\t * <p>Example: <pre><code class='java'>\n\t * // Check that a GET to \"/greet\" is managed by GreetController\n\t * assertThat(mvc.perform(get(\"/greet\")).handler().hasType(GreetController.class);\n\t * </code></pre>\n\t * @param type the expected type of the handler\n\t */\n\tpublic HandlerResultAssert hasType(Class<?> type) {\n\t\tisNotNull();\n\t\tClass<?> actualType = this.actual.getClass();\n\t\tif (this.actual instanceof HandlerMethod handlerMethod) {\n\t\t\tactualType = handlerMethod.getBeanType();\n\t\t}\n\t\tAssertions.assertThat(ClassUtils.getUserClass(actualType)).as(\"Handler result type\").isEqualTo(type);\n\t\treturn this;\n\t}\n\n\tprivate Method getHandlerMethod() {\n\t\tisMethodHandler(); // validate type\n\t\treturn ((HandlerMethod) this.actual).getMethod();\n\t}\n\n\n}"
  },
  "org.springframework.test.web.servlet.assertj.HandlerResultAssert#hasType(type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Verify that the handler is of the given {@code type}. For a controller\n\t * method, this is the type of the controller.\n\t * <p>Example: <pre><code class='java'>\n\t * // Check that a GET to \"/greet\" is managed by GreetController\n\t * assertThat(mvc.perform(get(\"/greet\")).handler().hasType(GreetController.class);\n\t * </code></pre>\n\t * @param type the expected type of the handler\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "HandlerResultAssert",
    "signature": "public HandlerResultAssert hasType(Class<?> type)",
    "source_code": "\tpublic HandlerResultAssert hasType(Class<?> type) {\n\t\tisNotNull();\n\t\tClass<?> actualType = this.actual.getClass();\n\t\tif (this.actual instanceof HandlerMethod handlerMethod) {\n\t\t\tactualType = handlerMethod.getBeanType();\n\t\t}\n\t\tAssertions.assertThat(ClassUtils.getUserClass(actualType)).as(\"Handler result type\").isEqualTo(type);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.HandlerResultAssert#isInvokedOn(controllerType,Function<T,handlerMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Verify that the handler is managed by the given {@code handlerMethod}.\n\t * <p>This creates a \"mock\" for the given {@code controllerType} and records\n\t * the method invocation in the {@code handlerMethod}. The arguments used by\n\t * the target method invocation can be {@code null} as the purpose of the mock\n\t * is to identify the method that was invoked.\n\t * <p>Example: <pre><code class='java'>\n\t * // If the method has a return type, you can return the result of the invocation\n\t * assertThat(mvc.perform(get(\"/greet\")).handler().isInvokedOn(\n\t *         GreetController.class, controller -> controller.sayGreet());\n\t *\n\t * // If the method has a void return type, the controller should be returned\n\t * assertThat(mvc.perform(post(\"/persons/\")).handler().isInvokedOn(\n\t *         PersonController.class, controller -> controller.createPerson(null, null));\n\t * </code></pre>\n\t * @param controllerType the controller to mock\n\t * @param handlerMethod the method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "controllerType",
      "Function<T",
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "HandlerResultAssert",
    "signature": "public HandlerResultAssert isInvokedOn(Class<T> controllerType, Function<T, Object> handlerMethod)",
    "source_code": "\tpublic <T> HandlerResultAssert isInvokedOn(Class<T> controllerType, Function<T, Object> handlerMethod) {\n\t\tMethodAssert actual = method();\n\t\tObject methodInvocationInfo = handlerMethod.apply(MvcUriComponentsBuilder.on(controllerType));\n\t\tAssertions.assertThat(methodInvocationInfo)\n\t\t\t\t.as(\"Method invocation on controller '%s'\", controllerType.getSimpleName())\n\t\t\t\t.isInstanceOfSatisfying(MethodInvocationInfo.class, mii ->\n\t\t\t\t\t\tactual.isEqualTo(mii.getControllerMethod()));\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.HandlerResultAssert#isMethodHandler()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Verify that the handler is managed by a method invocation, typically on\n\t * a controller.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "HandlerResultAssert",
    "signature": "public HandlerResultAssert isMethodHandler()",
    "source_code": "\tpublic HandlerResultAssert isMethodHandler() {\n\t\treturn isNotNull().isInstanceOf(HandlerMethod.class);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.HandlerResultAssert#method()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a new {@linkplain MethodAssert assertion} object that uses\n\t * the {@link Method} that handles the request as the object to test.\n\t * <p>Verifies first that the handler is a {@linkplain #isMethodHandler()\n\t * method handler}.\n\t * <p>Example: <pre><code class='java'>\n\t * // Check that a GET to \"/greet\" is invoked on a \"handleGreet\" method name\n\t * assertThat(mvc.perform(get(\"/greet\")).handler().method().hasName(\"sayGreet\");\n\t * </code></pre>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "MethodAssert",
    "signature": "public MethodAssert method()",
    "source_code": "\tpublic MethodAssert method() {\n\t\treturn new MethodAssert(getHandlerMethod());\n\t}"
  },
  "org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#addDefaultRollbackRule(rollbackRule)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a default rollback rule, to be applied to all rule-based\n\t * transaction attributes returned by this source.\n\t * <p>By default, a rollback will be triggered on unchecked exceptions\n\t * but not on checked exceptions. A default rule may override this\n\t * while still respecting any custom rules in the transaction attribute.\n\t * @param rollbackRule a rollback rule overriding the default behavior,\n\t * e.g. {@link RollbackRuleAttribute#ROLLBACK_ON_ALL_EXCEPTIONS}\n\t * @since 6.2\n\t * @see RuleBasedTransactionAttribute#getRollbackRules()\n\t * @see EnableTransactionManagement#rollbackOn()\n\t * @see Transactional#rollbackFor()\n\t * @see Transactional#noRollbackFor()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rollbackRule"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "void",
    "signature": "public void addDefaultRollbackRule(RollbackRuleAttribute rollbackRule)",
    "source_code": "\tpublic void addDefaultRollbackRule(RollbackRuleAttribute rollbackRule) {\n\t\tif (this.defaultRollbackRules == null) {\n\t\t\tthis.defaultRollbackRules = new LinkedHashSet<>();\n\t\t}\n\t\tthis.defaultRollbackRules.add(rollbackRule);\n\t}"
  },
  "org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#setPublicMethodsOnly(publicMethodsOnly)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether transactional methods are expected to be public.\n\t * <p>The default is {@code true}.\n\t * @since 6.2\n\t * @see #AnnotationTransactionAttributeSource(boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "publicMethodsOnly"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "void",
    "signature": "public void setPublicMethodsOnly(boolean publicMethodsOnly)",
    "source_code": "\tpublic void setPublicMethodsOnly(boolean publicMethodsOnly) {\n\t\tthis.publicMethodsOnly = publicMethodsOnly;\n\t}"
  },
  "org.springframework.transaction.interceptor.AbstractFallbackTransactionAttributeSource#hasTransactionAttribute(method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "boolean",
    "signature": "public boolean hasTransactionAttribute(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tpublic boolean hasTransactionAttribute(Method method, @Nullable Class<?> targetClass) {\n\t\treturn (getTransactionAttribute(method, targetClass, false) != null);\n\t}"
  },
  "org.springframework.transaction.interceptor.ROLLBACK_ON_ALL_EXCEPTIONS": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The {@linkplain RollbackRuleAttribute rollback rule} for all\n\t * {@link Exception Exceptions}, including checked exceptions.\n\t * @since 6.2\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "signature": "public RollbackRuleAttribute ROLLBACK_ON_ALL_EXCEPTIONS",
    "source_code": "\tpublic static final RollbackRuleAttribute ROLLBACK_ON_ALL_EXCEPTIONS =",
    "type": "RollbackRuleAttribute"
  },
  "org.springframework.transaction.interceptor.TransactionAspectSupport#determineTransactionManager(txAttr,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the specific transaction manager to use for the given transaction.\n\t * @param txAttr the current transaction attribute\n\t * @param targetClass the target class that the attribute has been declared on\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "txAttr",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 510
    },
    "return": "TransactionManager",
    "signature": "protected TransactionManager determineTransactionManager(@Nullable TransactionAttribute txAttr, @Nullable Class<?> targetClass)",
    "source_code": "\tprotected TransactionManager determineTransactionManager("
  },
  "org.springframework.util.<unknown>#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "return": "boolean",
    "signature": "public boolean equals(Object obj)",
    "source_code": "\tpublic boolean equals(Object obj) {\n\t\tif (obj == this) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (obj instanceof Set<?> set) {\n\t\t\tif (set.size() != size()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn containsAll(set);\n\t\t\t}\n\t\t\tcatch (ClassCastException | NullPointerException ignored) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#flagPlaceholderAsVisited(placeholder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "placeholder"
    ],
    "position": {
      "column": 1,
      "line": 351
    },
    "return": "void",
    "signature": "public void flagPlaceholderAsVisited(String placeholder)",
    "source_code": "\t\tpublic void flagPlaceholderAsVisited(String placeholder) {\n\t\t\tif (this.visitedPlaceholders == null) {\n\t\t\t\tthis.visitedPlaceholders = new HashSet<>(4);\n\t\t\t}\n\t\t\tif (!this.visitedPlaceholders.add(placeholder)) {\n\t\t\t\tthrow new PlaceholderResolutionException(\n\t\t\t\t\t\t\"Circular placeholder reference '%s'\".formatted(placeholder), placeholder, null);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.util.<unknown>#handleUnresolvablePlaceholder(key,text)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "text"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "String",
    "signature": "public String handleUnresolvablePlaceholder(String key, String text)",
    "source_code": "\t\tpublic String handleUnresolvablePlaceholder(String key, String text) {\n\t\t\tif (this.ignoreUnresolvablePlaceholders) {\n\t\t\t\treturn toPlaceholderText(key);\n\t\t\t}\n\t\t\tString originalValue = (!key.equals(text) ? toPlaceholderText(text) : null);\n\t\t\tthrow new PlaceholderResolutionException(\n\t\t\t\t\t\"Could not resolve placeholder '%s'\".formatted(key), key, originalValue);\n\t\t}"
  },
  "org.springframework.util.<unknown>#parse(text)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text"
    ],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "List<Part>",
    "signature": "public List<Part> parse(String text)",
    "source_code": "\t\tpublic List<Part> parse(String text) {\n\t\t\treturn this.parser.apply(text);\n\t\t}"
  },
  "org.springframework.util.<unknown>#removePlaceholder(placeholder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "placeholder"
    ],
    "position": {
      "column": 1,
      "line": 361
    },
    "return": "void",
    "signature": "public void removePlaceholder(String placeholder)",
    "source_code": "\t\tpublic void removePlaceholder(String placeholder) {\n\t\t\tAssert.state(this.visitedPlaceholders != null, \"Visited placeholders must not be null\");\n\t\t\tthis.visitedPlaceholders.remove(placeholder);\n\t\t}"
  },
  "org.springframework.util.<unknown>#replacePlaceholders(value,placeholderResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Replace all placeholders of format {@code ${name}} with the value returned\n\t * from the supplied {@link PlaceholderResolver}.\n\t * @param value the value containing the placeholders to be replaced\n\t * @param placeholderResolver the {@code PlaceholderResolver} to use for replacement\n\t * @return the supplied value with placeholders replaced inline\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "placeholderResolver"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "String",
    "signature": "public String replacePlaceholders(String value, PlaceholderResolver placeholderResolver)",
    "source_code": "\tpublic String replacePlaceholders(String value, PlaceholderResolver placeholderResolver) {\n\t\tAssert.notNull(value, \"'value' must not be null\");\n\t\tParsedValue parsedValue = parse(value);\n\t\tPartResolutionContext resolutionContext = new PartResolutionContext(placeholderResolver,\n\t\t\t\tthis.prefix, this.suffix, this.ignoreUnresolvablePlaceholders,\n\t\t\t\tcandidate -> parse(candidate, false));\n\t\treturn parsedValue.resolve(resolutionContext);\n\t}"
  },
  "org.springframework.util.<unknown>#resolve(resolutionContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolutionContext"
    ],
    "position": {
      "column": 1,
      "line": 495
    },
    "return": "String",
    "signature": "public String resolve(PartResolutionContext resolutionContext)",
    "source_code": "\t\tpublic String resolve(PartResolutionContext resolutionContext) {\n\t\t\tString resolvedKey = Part.resolveAll(this.keyParts, resolutionContext);\n\t\t\tString value = resolutionContext.resolvePlaceholder(resolvedKey);\n\t\t\tif (value != null) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\telse if (this.defaultParts != null) {\n\t\t\t\treturn Part.resolveAll(this.defaultParts, resolutionContext);\n\t\t\t}\n\t\t\treturn resolutionContext.handleUnresolvablePlaceholder(resolvedKey, this.text);\n\t\t}"
  },
  "org.springframework.util.<unknown>#resolvePlaceholder(placeholderName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "placeholderName"
    ],
    "position": {
      "column": 1,
      "line": 326
    },
    "return": "String",
    "signature": "public String resolvePlaceholder(String placeholderName)",
    "source_code": "\t\tpublic String resolvePlaceholder(String placeholderName) {\n\t\t\tString value = this.resolver.resolvePlaceholder(placeholderName);\n\t\t\tif (value != null && logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Resolved placeholder '\" + placeholderName + \"'\");\n\t\t\t}\n\t\t\treturn value;\n\t\t}"
  },
  "org.springframework.util.CollectionUtils#compositeMap(Map<K,first,Map<K,second)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a (partially unmodifiable) map that combines the provided two\n\t * maps. Invoking {@link Map#put(Object, Object)} or {@link Map#putAll(Map)}\n\t * on the returned map results in an {@link UnsupportedOperationException}.\n\t * @param first the first map to compose\n\t * @param second the second map to compose\n\t * @return a new map that composes the given two maps\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<K",
      "first",
      "Map<K",
      "second"
    ],
    "position": {
      "column": 1,
      "line": 523
    },
    "return": "V>",
    "signature": "public V> compositeMap(Map<K,V> first, Map<K,V> second)",
    "source_code": "\tpublic static <K, V> Map<K, V> compositeMap(Map<K,V> first, Map<K,V> second) {\n\t\treturn new CompositeMap<>(first, second);\n\t}"
  },
  "org.springframework.util.CollectionUtils#compositeMap(Map<K,first,Map<K,second,BiFunction<K,V,putFunction,Consumer<Map<K,putAllFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a map that combines the provided maps. Invoking\n\t * {@link Map#put(Object, Object)} on the returned map will apply\n\t * {@code putFunction}, or will throw an\n\t * {@link UnsupportedOperationException} {@code putFunction} is\n\t * {@code null}. The same applies to {@link Map#putAll(Map)} and\n\t * {@code putAllFunction}.\n\t * @param first the first map to compose\n\t * @param second the second map to compose\n\t * @param putFunction applied when {@code Map::put} is invoked. If\n\t * {@code null}, {@code Map::put} throws an\n\t * {@code UnsupportedOperationException}.\n\t * @param putAllFunction applied when {@code Map::putAll} is invoked. If\n\t * {@code null}, {@code Map::putAll} throws an\n\t * {@code UnsupportedOperationException}.\n\t * @return a new map that composes the give maps\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<K",
      "first",
      "Map<K",
      "second",
      "BiFunction<K",
      "V",
      "putFunction",
      "Consumer<Map<K",
      "putAllFunction"
    ],
    "position": {
      "column": 1,
      "line": 545
    },
    "return": "V>",
    "signature": "public V> compositeMap(Map<K,V> first, Map<K,V> second,\n\t\t\t@Nullable BiFunction<K, V, V> putFunction,\n\t\t\t@Nullable Consumer<Map<K, V>> putAllFunction)",
    "source_code": "\tpublic static <K, V> Map<K, V> compositeMap(Map<K,V> first, Map<K,V> second,"
  },
  "org.springframework.util.CollectionUtils#newHashSet(expectedSize)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Instantiate a new {@link HashSet} with an initial capacity that can\n\t * accommodate the specified number of elements without any immediate\n\t * resize/rehash operations to be expected.\n\t * @param expectedSize the expected number of elements (with a corresponding\n\t * capacity to be derived so that no resize/rehash operations are needed)\n\t * @since 6.2\n\t * @see #newLinkedHashSet(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedSize"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "HashSet<E>",
    "signature": "public HashSet<E> newHashSet(int expectedSize)",
    "source_code": "\tpublic static <E> HashSet<E> newHashSet(int expectedSize) {\n\t\treturn new HashSet<>(computeInitialCapacity(expectedSize), DEFAULT_LOAD_FACTOR);\n\t}"
  },
  "org.springframework.util.CollectionUtils#newLinkedHashSet(expectedSize)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Instantiate a new {@link LinkedHashSet} with an initial capacity that can\n\t * accommodate the specified number of elements without any immediate\n\t * resize/rehash operations to be expected.\n\t * @param expectedSize the expected number of elements (with a corresponding\n\t * capacity to be derived so that no resize/rehash operations are needed)\n\t * @since 6.2\n\t * @see #newHashSet(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedSize"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "LinkedHashSet<E>",
    "signature": "public LinkedHashSet<E> newLinkedHashSet(int expectedSize)",
    "source_code": "\tpublic static <E> LinkedHashSet<E> newLinkedHashSet(int expectedSize) {\n\t\treturn new LinkedHashSet<>(computeInitialCapacity(expectedSize), DEFAULT_LOAD_FACTOR);\n\t}"
  },
  "org.springframework.util.xml.<unknown>#endPrefixMapping(prefix)": {
    "change": "modifier_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * End the prefix mapping for the given prefix.\n\t * @see org.xml.sax.ContentHandler#endPrefixMapping(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "prefix"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "void",
    "signature": "protected void endPrefixMapping(String prefix)",
    "source_code": "\tprotected void endPrefixMapping(String prefix) throws SAXException {\n\t\tif (getContentHandler() != null && this.namespaces.containsKey(prefix)) {\n\t\t\tgetContentHandler().endPrefixMapping(prefix);\n\t\t\tthis.namespaces.remove(prefix);\n\t\t}\n\t}"
  },
  "org.springframework.validation.FieldError": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Encapsulates a field error, that is, a reason for rejecting a specific\n * field value.\n *\n * <p>See the {@link DefaultMessageCodesResolver} javadoc for details on\n * how a message code list is built for a {@code FieldError}.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 10.03.2003\n * @see DefaultMessageCodesResolver\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 36
    },
    "signature": "public class FieldError",
    "source_code": "public class FieldError extends ObjectError {\n\n\tprivate final String field;\n\n\t@Nullable\n\tprivate final Object rejectedValue;\n\n\tprivate final boolean bindingFailure;\n\n\n\t/**\n\t * Create a new FieldError instance.\n\t * @param objectName the name of the affected object\n\t * @param field the affected field of the object\n\t * @param defaultMessage the default message to be used to resolve this message\n\t */\n\tpublic FieldError(String objectName, String field, String defaultMessage) {\n\t\tthis(objectName, field, null, false, null, null, defaultMessage);\n\t}\n\n\t/**\n\t * Create a new FieldError instance.\n\t * @param objectName the name of the affected object\n\t * @param field the affected field of the object\n\t * @param rejectedValue the rejected field value\n\t * @param bindingFailure whether this error represents a binding failure\n\t * (like a type mismatch); else, it is a validation failure\n\t * @param codes the codes to be used to resolve this message\n\t * @param arguments the array of arguments to be used to resolve this message\n\t * @param defaultMessage the default message to be used to resolve this message\n\t */\n\tpublic FieldError(String objectName, String field, @Nullable Object rejectedValue, boolean bindingFailure,\n\t\t\t@Nullable String[] codes, @Nullable Object[] arguments, @Nullable String defaultMessage) {\n\n\t\tsuper(objectName, codes, arguments, defaultMessage);\n\t\tAssert.notNull(field, \"Field must not be null\");\n\t\tthis.field = field;\n\t\tthis.rejectedValue = rejectedValue;\n\t\tthis.bindingFailure = bindingFailure;\n\t}\n\n\n\t/**\n\t * Return the affected field of the object.\n\t */\n\tpublic String getField() {\n\t\treturn this.field;\n\t}\n\n\t/**\n\t * Return the rejected field value.\n\t */\n\t@Nullable\n\tpublic Object getRejectedValue() {\n\t\treturn this.rejectedValue;\n\t}\n\n\t/**\n\t * Return whether this error represents a binding failure\n\t * (like a type mismatch); otherwise it is a validation failure.\n\t */\n\tpublic boolean isBindingFailure() {\n\t\treturn this.bindingFailure;\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!super.equals(other)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (other instanceof FieldError otherError && getField().equals(otherError.getField()) &&\n\t\t\t\tObjectUtils.nullSafeEquals(getRejectedValue(), otherError.getRejectedValue()) &&\n\t\t\t\tisBindingFailure() == otherError.isBindingFailure());\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tint hashCode = super.hashCode();\n\t\thashCode = 29 * hashCode + getField().hashCode();\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getRejectedValue());\n\t\thashCode = 29 * hashCode + (isBindingFailure() ? 1 : 0);\n\t\treturn hashCode;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\t// We would preferably use ObjectUtils.nullSafeConciseToString(rejectedValue) here but\n\t\t// keep including the full nullSafeToString representation for backwards compatibility.\n\t\treturn \"Field error in object '\" + getObjectName() + \"' on field '\" + this.field +\n\t\t\t\t\"': rejected value [\" + ObjectUtils.nullSafeToString(this.rejectedValue) + \"]; \" +\n\t\t\t\tresolvableToString();\n\t}\n\n}"
  },
  "org.springframework.validation.FieldError#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!super.equals(other)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (other instanceof FieldError otherError && getField().equals(otherError.getField()) &&\n\t\t\t\tObjectUtils.nullSafeEquals(getRejectedValue(), otherError.getRejectedValue()) &&\n\t\t\t\tisBindingFailure() == otherError.isBindingFailure());\n\t}"
  },
  "org.springframework.validation.FieldError#getField()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the affected field of the object.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "String",
    "signature": "public String getField()",
    "source_code": "\tpublic String getField() {\n\t\treturn this.field;\n\t}"
  },
  "org.springframework.validation.FieldError#getRejectedValue()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the rejected field value.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "Object",
    "signature": "public Object getRejectedValue()",
    "source_code": "\tpublic Object getRejectedValue() {\n\t\treturn this.rejectedValue;\n\t}"
  },
  "org.springframework.validation.FieldError#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\tint hashCode = super.hashCode();\n\t\thashCode = 29 * hashCode + getField().hashCode();\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getRejectedValue());\n\t\thashCode = 29 * hashCode + (isBindingFailure() ? 1 : 0);\n\t\treturn hashCode;\n\t}"
  },
  "org.springframework.validation.FieldError#isBindingFailure()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether this error represents a binding failure\n\t * (like a type mismatch); otherwise it is a validation failure.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "boolean",
    "signature": "public boolean isBindingFailure()",
    "source_code": "\tpublic boolean isBindingFailure() {\n\t\treturn this.bindingFailure;\n\t}"
  },
  "org.springframework.validation.FieldError#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\t// We would preferably use ObjectUtils.nullSafeConciseToString(rejectedValue) here but\n\t\t// keep including the full nullSafeToString representation for backwards compatibility.\n\t\treturn \"Field error in object '\" + getObjectName() + \"' on field '\" + this.field +\n\t\t\t\t\"': rejected value [\" + ObjectUtils.nullSafeToString(this.rejectedValue) + \"]; \" +\n\t\t\t\tresolvableToString();\n\t}"
  },
  "org.springframework.validation.method.ParameterValidationResult": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Store and expose the results of method validation for a method parameter.\n * <ul>\n * <li>Validation errors directly on method parameter values are exposed as a\n * list of {@link MessageSourceResolvable}s.\n * <li>Nested validation errors on an Object method parameter are exposed as\n * {@link org.springframework.validation.Errors} by the subclass\n * {@link ParameterErrors}.\n * </ul>\n *\n * <p>When the method parameter is a container such as a {@link List}, array,\n * or {@link java.util.Map}, then a separate {@link ParameterValidationResult}\n * is created for each element with errors. In that case, the properties\n * {@link #getContainer() container}, {@link #getContainerIndex() containerIndex},\n * and {@link #getContainerKey() containerKey} provide additional context.\n *\n * @author Rossen Stoyanchev\n * @since 6.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "signature": "public class ParameterValidationResult",
    "source_code": "public class ParameterValidationResult {\n\n\tprivate final MethodParameter methodParameter;\n\n\t@Nullable\n\tprivate final Object argument;\n\n\tprivate final List<MessageSourceResolvable> resolvableErrors;\n\n\t@Nullable\n\tprivate final Object container;\n\n\t@Nullable\n\tprivate final Integer containerIndex;\n\n\t@Nullable\n\tprivate final Object containerKey;\n\n\n\t/**\n\t * Create a {@code ParameterValidationResult}.\n\t */\n\tpublic ParameterValidationResult(\n\t\t\tMethodParameter param, @Nullable Object arg, Collection<? extends MessageSourceResolvable> errors,\n\t\t\t@Nullable Object container, @Nullable Integer index, @Nullable Object key) {\n\n\t\tAssert.notNull(param, \"MethodParameter is required\");\n\t\tAssert.notEmpty(errors, \"`resolvableErrors` must not be empty\");\n\t\tthis.methodParameter = param;\n\t\tthis.argument = arg;\n\t\tthis.resolvableErrors = List.copyOf(errors);\n\t\tthis.container = container;\n\t\tthis.containerIndex = index;\n\t\tthis.containerKey = key;\n\t}\n\n\t/**\n\t * Create a {@code ParameterValidationResult}.\n\t * @deprecated in favor of\n\t * {@link ParameterValidationResult#ParameterValidationResult(MethodParameter, Object, Collection, Object, Integer, Object)}\n\t */\n\t@Deprecated(since = \"6.1.3\", forRemoval = true)\n\tpublic ParameterValidationResult(\n\t\t\tMethodParameter param, @Nullable Object arg, Collection<? extends MessageSourceResolvable> errors) {\n\n\t\tthis(param, arg, errors, null, null, null);\n\t}\n\n\n\t/**\n\t * The method parameter the validation results are for.\n\t */\n\tpublic MethodParameter getMethodParameter() {\n\t\treturn this.methodParameter;\n\t}\n\n\t/**\n\t * The method argument value that was validated.\n\t */\n\t@Nullable\n\tpublic Object getArgument() {\n\t\treturn this.argument;\n\t}\n\n\t/**\n\t * List of {@link MessageSourceResolvable} representations adapted from the\n\t * validation errors of the validation library.\n\t * <ul>\n\t * <li>For a constraints directly on a method parameter, error codes are\n\t * based on the names of the constraint annotation, the object, the method,\n\t * the parameter, and parameter type, e.g.\n\t * {@code [\"Max.myObject#myMethod.myParameter\", \"Max.myParameter\", \"Max.int\", \"Max\"]}.\n\t * Arguments include the parameter itself as a {@link MessageSourceResolvable}, e.g.\n\t * {@code [\"myObject#myMethod.myParameter\", \"myParameter\"]}, followed by actual\n\t * constraint annotation attributes (i.e. excluding \"message\", \"groups\" and\n\t * \"payload\") in alphabetical order of attribute names.\n\t * <li>For cascaded constraints via {@link jakarta.validation.Validator @Valid}\n\t * on a bean method parameter, this method returns\n\t * {@link org.springframework.validation.FieldError field errors} that you\n\t * can also access more conveniently through methods of the\n\t * {@link ParameterErrors} sub-class.\n\t * </ul>\n\t */\n\tpublic List<MessageSourceResolvable> getResolvableErrors() {\n\t\treturn this.resolvableErrors;\n\t}\n\n\t/**\n\t * When {@code @Valid} is declared on a container of elements such as\n\t * {@link java.util.Collection}, {@link java.util.Map},\n\t * {@link java.util.Optional}, and others, this method returns the container\n\t * of the validated {@link #getArgument() argument}, while\n\t * {@link #getContainerIndex()} and {@link #getContainerKey()} provide\n\t * information about the index or key if applicable.\n\t */\n\t@Nullable\n\tpublic Object getContainer() {\n\t\treturn this.container;\n\t}\n\n\t/**\n\t * When {@code @Valid} is declared on an indexed container of elements such as\n\t * {@link List} or array, this method returns the index of the validated\n\t * {@link #getArgument() argument}.\n\t */\n\t@Nullable\n\tpublic Integer getContainerIndex() {\n\t\treturn this.containerIndex;\n\t}\n\n\t/**\n\t * When {@code @Valid} is declared on a container of elements referenced by\n\t * key such as {@link java.util.Map}, this method returns the key of the\n\t * validated {@link #getArgument() argument}.\n\t */\n\t@Nullable\n\tpublic Object getContainerKey() {\n\t\treturn this.containerKey;\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!super.equals(other)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (other instanceof ParameterValidationResult otherResult &&\n\t\t\t\tgetMethodParameter().equals(otherResult.getMethodParameter()) &&\n\t\t\t\tObjectUtils.nullSafeEquals(getArgument(), otherResult.getArgument()) &&\n\t\t\t\tObjectUtils.nullSafeEquals(getContainerIndex(), otherResult.getContainerIndex()) &&\n\t\t\t\tObjectUtils.nullSafeEquals(getContainerKey(), otherResult.getContainerKey()));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tint hashCode = super.hashCode();\n\t\thashCode = 29 * hashCode + getMethodParameter().hashCode();\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getArgument());\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getContainerIndex());\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getContainerKey());\n\t\treturn hashCode;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \" for \" + this.methodParameter +\n\t\t\t\t\", argument value '\" + ObjectUtils.nullSafeConciseToString(this.argument) + \"',\" +\n\t\t\t\t(this.containerIndex != null ? \"containerIndex[\" + this.containerIndex + \"],\" : \"\") +\n\t\t\t\t(this.containerKey != null ? \"containerKey['\" + this.containerKey + \"'],\" : \"\") +\n\t\t\t\t\" errors: \" + getResolvableErrors();\n\t}\n\n}"
  },
  "org.springframework.validation.method.ParameterValidationResult#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!super.equals(other)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (other instanceof ParameterValidationResult otherResult &&\n\t\t\t\tgetMethodParameter().equals(otherResult.getMethodParameter()) &&\n\t\t\t\tObjectUtils.nullSafeEquals(getArgument(), otherResult.getArgument()) &&\n\t\t\t\tObjectUtils.nullSafeEquals(getContainerIndex(), otherResult.getContainerIndex()) &&\n\t\t\t\tObjectUtils.nullSafeEquals(getContainerKey(), otherResult.getContainerKey()));\n\t}"
  },
  "org.springframework.validation.method.ParameterValidationResult#getArgument()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The method argument value that was validated.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "Object",
    "signature": "public Object getArgument()",
    "source_code": "\tpublic Object getArgument() {\n\t\treturn this.argument;\n\t}"
  },
  "org.springframework.validation.method.ParameterValidationResult#getContainer()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * When {@code @Valid} is declared on a container of elements such as\n\t * {@link java.util.Collection}, {@link java.util.Map},\n\t * {@link java.util.Optional}, and others, this method returns the container\n\t * of the validated {@link #getArgument() argument}, while\n\t * {@link #getContainerIndex()} and {@link #getContainerKey()} provide\n\t * information about the index or key if applicable.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "Object",
    "signature": "public Object getContainer()",
    "source_code": "\tpublic Object getContainer() {\n\t\treturn this.container;\n\t}"
  },
  "org.springframework.validation.method.ParameterValidationResult#getContainerIndex()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * When {@code @Valid} is declared on an indexed container of elements such as\n\t * {@link List} or array, this method returns the index of the validated\n\t * {@link #getArgument() argument}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "Integer",
    "signature": "public Integer getContainerIndex()",
    "source_code": "\tpublic Integer getContainerIndex() {\n\t\treturn this.containerIndex;\n\t}"
  },
  "org.springframework.validation.method.ParameterValidationResult#getContainerKey()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * When {@code @Valid} is declared on a container of elements referenced by\n\t * key such as {@link java.util.Map}, this method returns the key of the\n\t * validated {@link #getArgument() argument}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "Object",
    "signature": "public Object getContainerKey()",
    "source_code": "\tpublic Object getContainerKey() {\n\t\treturn this.containerKey;\n\t}"
  },
  "org.springframework.validation.method.ParameterValidationResult#getMethodParameter()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The method parameter the validation results are for.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter getMethodParameter()",
    "source_code": "\tpublic MethodParameter getMethodParameter() {\n\t\treturn this.methodParameter;\n\t}"
  },
  "org.springframework.validation.method.ParameterValidationResult#getResolvableErrors()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * List of {@link MessageSourceResolvable} representations adapted from the\n\t * validation errors of the validation library.\n\t * <ul>\n\t * <li>For a constraints directly on a method parameter, error codes are\n\t * based on the names of the constraint annotation, the object, the method,\n\t * the parameter, and parameter type, e.g.\n\t * {@code [\"Max.myObject#myMethod.myParameter\", \"Max.myParameter\", \"Max.int\", \"Max\"]}.\n\t * Arguments include the parameter itself as a {@link MessageSourceResolvable}, e.g.\n\t * {@code [\"myObject#myMethod.myParameter\", \"myParameter\"]}, followed by actual\n\t * constraint annotation attributes (i.e. excluding \"message\", \"groups\" and\n\t * \"payload\") in alphabetical order of attribute names.\n\t * <li>For cascaded constraints via {@link jakarta.validation.Validator @Valid}\n\t * on a bean method parameter, this method returns\n\t * {@link org.springframework.validation.FieldError field errors} that you\n\t * can also access more conveniently through methods of the\n\t * {@link ParameterErrors} sub-class.\n\t * </ul>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "List<MessageSourceResolvable>",
    "signature": "public List<MessageSourceResolvable> getResolvableErrors()",
    "source_code": "\tpublic List<MessageSourceResolvable> getResolvableErrors() {\n\t\treturn this.resolvableErrors;\n\t}"
  },
  "org.springframework.validation.method.ParameterValidationResult#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\tint hashCode = super.hashCode();\n\t\thashCode = 29 * hashCode + getMethodParameter().hashCode();\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getArgument());\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getContainerIndex());\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getContainerKey());\n\t\treturn hashCode;\n\t}"
  },
  "org.springframework.validation.method.ParameterValidationResult#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \" for \" + this.methodParameter +\n\t\t\t\t\", argument value '\" + ObjectUtils.nullSafeConciseToString(this.argument) + \"',\" +\n\t\t\t\t(this.containerIndex != null ? \"containerIndex[\" + this.containerIndex + \"],\" : \"\") +\n\t\t\t\t(this.containerKey != null ? \"containerKey['\" + this.containerKey + \"'],\" : \"\") +\n\t\t\t\t\" errors: \" + getResolvableErrors();\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#block()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "ServerResponse",
    "signature": "public ServerResponse block()",
    "source_code": "\tpublic ServerResponse block() {\n\t\ttry {\n\t\t\tif (this.timeout != null) {\n\t\t\t\treturn this.futureResponse.get(this.timeout.toMillis(), TimeUnit.MILLISECONDS);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn this.futureResponse.get();\n\t\t\t}\n\t\t}\n\t\tcatch (InterruptedException | ExecutionException | TimeoutException ex) {\n\t\t\tthrow new IllegalStateException(\"Failed to get future response\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#create(obj,timeout)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "AsyncServerResponse",
    "signature": "public AsyncServerResponse create(Object obj, @Nullable Duration timeout)",
    "source_code": "\tpublic static AsyncServerResponse create(Object obj, @Nullable Duration timeout) {\n\t\tAssert.notNull(obj, \"Argument to async must not be null\");\n\n\t\tif (obj instanceof CompletableFuture futureResponse) {\n\t\t\treturn new DefaultAsyncServerResponse(futureResponse, timeout);\n\t\t}\n\t\telse if (reactiveStreamsPresent) {\n\t\t\tReactiveAdapterRegistry registry = ReactiveAdapterRegistry.getSharedInstance();\n\t\t\tReactiveAdapter publisherAdapter = registry.getAdapter(obj.getClass());\n\t\t\tif (publisherAdapter != null) {\n\t\t\t\tPublisher<ServerResponse> publisher = publisherAdapter.toPublisher(obj);\n\t\t\t\tReactiveAdapter futureAdapter = registry.getAdapter(CompletableFuture.class);\n\t\t\t\tif (futureAdapter != null) {\n\t\t\t\t\tCompletableFuture<ServerResponse> futureResponse =\n\t\t\t\t\t\t\t(CompletableFuture<ServerResponse>) futureAdapter.fromPublisher(publisher);\n\t\t\t\t\treturn new DefaultAsyncServerResponse(futureResponse, timeout);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Asynchronous type not supported: \" + obj.getClass());\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#headers()": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "Headers",
    "signature": "public Headers headers()",
    "source_code": "\t\tpublic Headers headers() {\n\t\t\treturn new DefaultServerRequest.DefaultRequestHeaders(this.headers);\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#rawStatusCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "int",
    "signature": "public int rawStatusCode()",
    "source_code": "\tpublic int rawStatusCode() {\n\t\treturn delegate(ServerResponse::rawStatusCode);\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#sendRedirect(location,sc,clearBuffer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location",
      "sc",
      "clearBuffer"
    ],
    "position": {
      "column": 1,
      "line": 683
    },
    "return": "void",
    "signature": "public void sendRedirect(String location, int sc, boolean clearBuffer)",
    "source_code": "\t\tpublic void sendRedirect(String location, int sc, boolean clearBuffer) throws IOException {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#statusCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "HttpStatusCode",
    "signature": "public HttpStatusCode statusCode()",
    "source_code": "\tpublic HttpStatusCode statusCode() {\n\t\treturn delegate(ServerResponse::statusCode);\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#writeTo(request,response,context)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "ModelAndView",
    "signature": "public ModelAndView writeTo(HttpServletRequest request, HttpServletResponse response, Context context)",
    "source_code": "\tpublic ModelAndView writeTo(HttpServletRequest request, HttpServletResponse response, Context context)"
  },
  "org.springframework.web.servlet.function.AsyncServerResponse": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Asynchronous subtype of {@link ServerResponse} that exposes the future\n * response.\n *\n * @author Arjen Poutsma\n * @since 5.3.2\n * @see ServerResponse#async(Object)\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "signature": "public interface AsyncServerResponse",
    "source_code": "public interface AsyncServerResponse extends ServerResponse {\n\n\t/**\n\t * Blocks indefinitely until the future response is obtained.\n\t */\n\tServerResponse block();\n\n\n\t// Static creation methods\n\n\t/**\n\t * Create a {@code AsyncServerResponse} with the given asynchronous response.\n\t * Parameter {@code asyncResponse} can be a\n\t * {@link CompletableFuture CompletableFuture&lt;ServerResponse&gt;} or\n\t * {@link Publisher Publisher&lt;ServerResponse&gt;} (or any\n\t * asynchronous producer of a single {@code ServerResponse} that can be\n\t * adapted via the {@link ReactiveAdapterRegistry}).\n\t * @param asyncResponse a {@code CompletableFuture<ServerResponse>} or\n\t * {@code Publisher<ServerResponse>}\n\t * @return the asynchronous response\n\t */\n\tstatic AsyncServerResponse create(Object asyncResponse) {\n\t\treturn createInternal(asyncResponse, null);\n\t}\n\n\t/**\n\t * Create a (built) response with the given asynchronous response.\n\t * Parameter {@code asyncResponse} can be a\n\t * {@link CompletableFuture CompletableFuture&lt;ServerResponse&gt;} or\n\t * {@link Publisher Publisher&lt;ServerResponse&gt;} (or any\n\t * asynchronous producer of a single {@code ServerResponse} that can be\n\t * adapted via the {@link ReactiveAdapterRegistry}).\n\t * @param asyncResponse a {@code CompletableFuture<ServerResponse>} or\n\t * {@code Publisher<ServerResponse>}\n\t * @param timeout maximum time period to wait for before timing out\n\t * @return the asynchronous response\n\t */\n\tstatic AsyncServerResponse create(Object asyncResponse, Duration timeout) {\n\t\treturn createInternal(asyncResponse, timeout);\n\t}\n\n\tprivate static AsyncServerResponse createInternal(Object asyncResponse, @Nullable Duration timeout) {\n\t\tAssert.notNull(asyncResponse, \"AsyncResponse must not be null\");\n\n\t\tCompletableFuture<ServerResponse> futureResponse = toCompletableFuture(asyncResponse);\n\t\tif (futureResponse.isDone() &&\n\t\t\t\t!futureResponse.isCancelled() &&\n\t\t\t\t!futureResponse.isCompletedExceptionally()) {\n\n\t\t\ttry {\n\t\t\t\tServerResponse completedResponse = futureResponse.get();\n\t\t\t\treturn new CompletedAsyncServerResponse(completedResponse);\n\t\t\t}\n\t\t\tcatch (InterruptedException | ExecutionException ignored) {\n\t\t\t\t// fall through to use DefaultAsyncServerResponse\n\t\t\t}\n\t\t}\n\t\treturn new DefaultAsyncServerResponse(futureResponse, timeout);\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate static CompletableFuture<ServerResponse> toCompletableFuture(Object obj) {\n\t\tif (obj instanceof CompletableFuture<?> futureResponse) {\n\t\t\treturn (CompletableFuture<ServerResponse>) futureResponse;\n\t\t}\n\t\telse if (DefaultAsyncServerResponse.reactiveStreamsPresent) {\n\t\t\tReactiveAdapterRegistry registry = ReactiveAdapterRegistry.getSharedInstance();\n\t\t\tReactiveAdapter publisherAdapter = registry.getAdapter(obj.getClass());\n\t\t\tif (publisherAdapter != null) {\n\t\t\t\tPublisher<ServerResponse> publisher = publisherAdapter.toPublisher(obj);\n\t\t\t\tReactiveAdapter futureAdapter = registry.getAdapter(CompletableFuture.class);\n\t\t\t\tif (futureAdapter != null) {\n\t\t\t\t\treturn (CompletableFuture<ServerResponse>) futureAdapter.fromPublisher(publisher);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Asynchronous type not supported: \" + obj.getClass());\n\t}\n\n}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor#invokeErrorResponseInterceptors(detail,errorResponse)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the configured {@link ErrorResponse.Interceptor}'s.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "detail",
      "errorResponse"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "void",
    "signature": "protected void invokeErrorResponseInterceptors(ProblemDetail detail, @Nullable ErrorResponse errorResponse)",
    "source_code": "\tprotected void invokeErrorResponseInterceptors(ProblemDetail detail, @Nullable ErrorResponse errorResponse) {\n\t\ttry {\n\t\t\tfor (ErrorResponse.Interceptor handler : this.errorResponseInterceptors) {\n\t\t\t\thandler.handleError(detail, errorResponse);\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\t// ignore\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#setErrorResponseInterceptors(interceptors)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a list of {@link ErrorResponse.Interceptor}'s to apply when\n\t * rendering an RFC 7807 {@link org.springframework.http.ProblemDetail}\n\t * error response.\n\t * @param interceptors the handlers to use\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "interceptors"
    ],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "void",
    "signature": "public void setErrorResponseInterceptors(List<ErrorResponse.Interceptor> interceptors)",
    "source_code": "\tpublic void setErrorResponseInterceptors(List<ErrorResponse.Interceptor> interceptors) {\n\t\tthis.errorResponseInterceptors.clear();\n\t\tthis.errorResponseInterceptors.addAll(interceptors);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#setErrorResponseInterceptors(interceptors)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a list of {@link ErrorResponse.Interceptor}'s to apply when\n\t * rendering an RFC 7807 {@link org.springframework.http.ProblemDetail}\n\t * error response.\n\t * @param interceptors the interceptors to use\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "interceptors"
    ],
    "position": {
      "column": 1,
      "line": 408
    },
    "return": "void",
    "signature": "public void setErrorResponseInterceptors(List<ErrorResponse.Interceptor> interceptors)",
    "source_code": "\tpublic void setErrorResponseInterceptors(List<ErrorResponse.Interceptor> interceptors) {\n\t\tthis.errorResponseInterceptors.clear();\n\t\tthis.errorResponseInterceptors.addAll(interceptors);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler#handleBindException(ex,headers,status,request)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link BindException}.\n\t * <p>By default this method creates a {@link ProblemDetail} with the status\n\t * and a short detail message, and then delegates to\n\t * {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @deprecated as of 6.0 since {@link org.springframework.web.method.annotation.ModelAttributeMethodProcessor}\n\t * now raises the {@link MethodArgumentNotValidException} subclass instead.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 568
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleBindException(BindException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleBindException("
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#handleBindException(ex,request,response,handler)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where an {@linkplain ModelAttribute @ModelAttribute} method\n\t * argument has binding or validation errors and is not followed by another\n\t * method argument of type {@link BindingResult}.\n\t * <p>By default, an HTTP 400 error is sent back to the client.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @deprecated as of 6.0 since {@link org.springframework.web.method.annotation.ModelAttributeMethodProcessor}\n\t * now raises the {@link MethodArgumentNotValidException} subclass instead.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 683
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleBindException(BindException ex, HttpServletRequest request,\n\t\t\tHttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleBindException(BindException ex, HttpServletRequest request,"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#getOutboundMessageSizeLimit()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the configured outbound message buffer size in bytes.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "Integer",
    "signature": "public Integer getOutboundMessageSizeLimit()",
    "source_code": "\tpublic Integer getOutboundMessageSizeLimit() {\n\t\treturn this.outboundMessageSizeLimit;\n\t}"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#hasSplittingEncoder()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 631
    },
    "return": "boolean",
    "signature": "public boolean hasSplittingEncoder()",
    "source_code": "\t\tpublic boolean hasSplittingEncoder() {\n\t\t\treturn (this.splittingEncoder != null);\n\t\t}"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#setOutboundMessageSizeLimit(outboundMessageSizeLimit)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the maximum size allowed for outbound STOMP message.\n\t * If STOMP message's size exceeds {@link WebSocketStompClient#outboundMessageSizeLimit},\n\t * STOMP message is split into multiple frames.\n\t * <p>By default this is not set in which case each STOMP message are not split.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outboundMessageSizeLimit"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "void",
    "signature": "public void setOutboundMessageSizeLimit(Integer outboundMessageSizeLimit)",
    "source_code": "\tpublic void setOutboundMessageSizeLimit(Integer outboundMessageSizeLimit) {\n\t\tthis.outboundMessageSizeLimit = outboundMessageSizeLimit;\n\t}"
  }
}