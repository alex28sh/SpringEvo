{
  "org.apache.commons.logging.<unknown>#createLocationAwareLog(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "Log",
    "signature": "public Log createLocationAwareLog(String name)",
    "source_code": "\t\tpublic static Log createLocationAwareLog(String name) {\n\t\t\tLogger logger = LoggerFactory.getLogger(name);\n\t\t\treturn (logger instanceof LocationAwareLogger locationAwareLogger ?\n\t\t\t\t\tnew Slf4jLocationAwareLog(locationAwareLogger) : new Slf4jLog<>(logger));\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#createLog(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "Log",
    "signature": "public Log createLog(String name)",
    "source_code": "\t\tpublic static Log createLog(String name) {\n\t\t\treturn new JavaUtilLog(name);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#debug(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 574
    },
    "return": "void",
    "signature": "public void debug(Object message)",
    "source_code": "\t\tpublic void debug(Object message) {\n\t\t\tlog(java.util.logging.Level.FINE, message, null);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#debug(message,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 579
    },
    "return": "void",
    "signature": "public void debug(Object message, Throwable exception)",
    "source_code": "\t\tpublic void debug(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.FINE, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#error(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 544
    },
    "return": "void",
    "signature": "public void error(Object message)",
    "source_code": "\t\tpublic void error(Object message) {\n\t\t\tlog(java.util.logging.Level.SEVERE, message, null);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#error(message,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 549
    },
    "return": "void",
    "signature": "public void error(Object message, Throwable exception)",
    "source_code": "\t\tpublic void error(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.SEVERE, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#fatal(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 534
    },
    "return": "void",
    "signature": "public void fatal(Object message)",
    "source_code": "\t\tpublic void fatal(Object message) {\n\t\t\terror(message);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#fatal(message,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 539
    },
    "return": "void",
    "signature": "public void fatal(Object message, Throwable exception)",
    "source_code": "\t\tpublic void fatal(Object message, Throwable exception) {\n\t\t\terror(message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#getSourceClassName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 628
    },
    "return": "String",
    "signature": "public String getSourceClassName()",
    "source_code": "\t\tpublic String getSourceClassName() {\n\t\t\tif (!this.resolved) {\n\t\t\t\tresolve();\n\t\t\t}\n\t\t\treturn super.getSourceClassName();\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#getSourceMethodName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 642
    },
    "return": "String",
    "signature": "public String getSourceMethodName()",
    "source_code": "\t\tpublic String getSourceMethodName() {\n\t\t\tif (!this.resolved) {\n\t\t\t\tresolve();\n\t\t\t}\n\t\t\treturn super.getSourceMethodName();\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#info(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 564
    },
    "return": "void",
    "signature": "public void info(Object message)",
    "source_code": "\t\tpublic void info(Object message) {\n\t\t\tlog(java.util.logging.Level.INFO, message, null);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#info(message,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 569
    },
    "return": "void",
    "signature": "public void info(Object message, Throwable exception)",
    "source_code": "\t\tpublic void info(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.INFO, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#isDebugEnabled()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 524
    },
    "return": "boolean",
    "signature": "public boolean isDebugEnabled()",
    "source_code": "\t\tpublic boolean isDebugEnabled() {\n\t\t\treturn this.logger.isLoggable(java.util.logging.Level.FINE);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#isErrorEnabled()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 509
    },
    "return": "boolean",
    "signature": "public boolean isErrorEnabled()",
    "source_code": "\t\tpublic boolean isErrorEnabled() {\n\t\t\treturn this.logger.isLoggable(java.util.logging.Level.SEVERE);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#isFatalEnabled()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 504
    },
    "return": "boolean",
    "signature": "public boolean isFatalEnabled()",
    "source_code": "\t\tpublic boolean isFatalEnabled() {\n\t\t\treturn isErrorEnabled();\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#isInfoEnabled()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 519
    },
    "return": "boolean",
    "signature": "public boolean isInfoEnabled()",
    "source_code": "\t\tpublic boolean isInfoEnabled() {\n\t\t\treturn this.logger.isLoggable(java.util.logging.Level.INFO);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#isTraceEnabled()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 529
    },
    "return": "boolean",
    "signature": "public boolean isTraceEnabled()",
    "source_code": "\t\tpublic boolean isTraceEnabled() {\n\t\t\treturn this.logger.isLoggable(java.util.logging.Level.FINEST);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#isWarnEnabled()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 514
    },
    "return": "boolean",
    "signature": "public boolean isWarnEnabled()",
    "source_code": "\t\tpublic boolean isWarnEnabled() {\n\t\t\treturn this.logger.isLoggable(java.util.logging.Level.WARNING);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#readResolve()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 610
    },
    "return": "Object",
    "signature": "protected Object readResolve()",
    "source_code": "\t\tprotected Object readResolve() {\n\t\t\treturn new JavaUtilLog(this.name);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#setSourceClassName(sourceClassName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceClassName"
    ],
    "position": {
      "column": 1,
      "line": 636
    },
    "return": "void",
    "signature": "public void setSourceClassName(String sourceClassName)",
    "source_code": "\t\tpublic void setSourceClassName(String sourceClassName) {\n\t\t\tsuper.setSourceClassName(sourceClassName);\n\t\t\tthis.resolved = true;\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#setSourceMethodName(sourceMethodName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceMethodName"
    ],
    "position": {
      "column": 1,
      "line": 650
    },
    "return": "void",
    "signature": "public void setSourceMethodName(String sourceMethodName)",
    "source_code": "\t\tpublic void setSourceMethodName(String sourceMethodName) {\n\t\t\tsuper.setSourceMethodName(sourceMethodName);\n\t\t\tthis.resolved = true;\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#trace(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 584
    },
    "return": "void",
    "signature": "public void trace(Object message)",
    "source_code": "\t\tpublic void trace(Object message) {\n\t\t\tlog(java.util.logging.Level.FINEST, message, null);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#trace(message,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 589
    },
    "return": "void",
    "signature": "public void trace(Object message, Throwable exception)",
    "source_code": "\t\tpublic void trace(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.FINEST, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#warn(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 554
    },
    "return": "void",
    "signature": "public void warn(Object message)",
    "source_code": "\t\tpublic void warn(Object message) {\n\t\t\tlog(java.util.logging.Level.WARNING, message, null);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#warn(message,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 559
    },
    "return": "void",
    "signature": "public void warn(Object message, Throwable exception)",
    "source_code": "\t\tpublic void warn(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.WARNING, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#writeReplace()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 675
    },
    "return": "Object",
    "signature": "protected Object writeReplace()",
    "source_code": "\t\tprotected Object writeReplace() {\n\t\t\tLogRecord serialized = new LogRecord(getLevel(), getMessage());\n\t\t\tserialized.setLoggerName(getLoggerName());\n\t\t\tserialized.setResourceBundle(getResourceBundle());\n\t\t\tserialized.setResourceBundleName(getResourceBundleName());\n\t\t\tserialized.setSourceClassName(getSourceClassName());\n\t\t\tserialized.setSourceMethodName(getSourceMethodName());\n\t\t\tserialized.setSequenceNumber(getSequenceNumber());\n\t\t\tserialized.setParameters(getParameters());\n\t\t\tserialized.setLongThreadID(getLongThreadID());\n\t\t\tserialized.setInstant(getInstant());\n\t\t\tserialized.setThrown(getThrown());\n\t\t\treturn serialized;\n\t\t}"
  },
  "org.apache.commons.logging.logger": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "signature": "protected T logger",
    "source_code": "\t\tprotected final transient T logger;",
    "type": "T"
  },
  "org.apache.commons.logging.name": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 270
    },
    "signature": "protected String name",
    "source_code": "\t\tprotected final String name;",
    "type": "String"
  },
  "org.springframework.aop.aspectj.AbstractAspectJAdvice#setArgumentNames(argNames)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set by creator of this advice object if the argument names are known.\n\t * <p>This could be for example because they have been explicitly specified in XML,\n\t * or in an advice annotation.\n\t * @param argNames comma delimited list of arg names\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argNames"
    ],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "void",
    "signature": "public void setArgumentNames(String argNames)",
    "source_code": "\tpublic void setArgumentNames(String argNames) {\n\t\tString[] tokens = StringUtils.commaDelimitedListToStringArray(argNames);\n\t\tsetArgumentNamesFromStringArray(tokens);\n\t}"
  },
  "org.springframework.aop.aspectj.AbstractAspectJAdvice#setArgumentNames(argumentNames)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set by the creator of this advice object if the argument names are known.\n\t * <p>This could be for example because they have been explicitly specified in XML\n\t * or in an advice annotation.\n\t * @param argumentNames comma delimited list of argument names\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argumentNames"
    ],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "void",
    "signature": "public void setArgumentNames(String argumentNames)",
    "source_code": "\tpublic void setArgumentNames(String argumentNames) {\n\t\tString[] tokens = StringUtils.commaDelimitedListToStringArray(argumentNames);\n\t\tsetArgumentNamesFromStringArray(tokens);\n\t}"
  },
  "org.springframework.aop.aspectj.AbstractAspectJAdvice#setArgumentNamesFromStringArray(args)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "args"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "void",
    "signature": "public void setArgumentNamesFromStringArray(String... args)",
    "source_code": "\tpublic void setArgumentNamesFromStringArray(String... args) {\n\t\tthis.argumentNames = new String[args.length];\n\t\tfor (int i = 0; i < args.length; i++) {\n\t\t\tthis.argumentNames[i] = args[i].strip();\n\t\t\tif (!isVariableName(this.argumentNames[i])) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"'argumentNames' property of AbstractAspectJAdvice contains an argument name '\" +\n\t\t\t\t\t\tthis.argumentNames[i] + \"' that is not a valid Java identifier\");\n\t\t\t}\n\t\t}\n\t\tif (this.aspectJAdviceMethod.getParameterCount() == this.argumentNames.length + 1) {\n\t\t\t// May need to add implicit join point arg name...\n\t\t\tClass<?> firstArgType = this.aspectJAdviceMethod.getParameterTypes()[0];\n\t\t\tif (firstArgType == JoinPoint.class ||\n\t\t\t\t\tfirstArgType == ProceedingJoinPoint.class ||\n\t\t\t\t\tfirstArgType == JoinPoint.StaticPart.class) {\n\t\t\t\tString[] oldNames = this.argumentNames;\n\t\t\t\tthis.argumentNames = new String[oldNames.length + 1];\n\t\t\t\tthis.argumentNames[0] = \"THIS_JOIN_POINT\";\n\t\t\t\tSystem.arraycopy(oldNames, 0, this.argumentNames, 1, oldNames.length);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.aop.aspectj.AbstractAspectJAdvice#setArgumentNamesFromStringArray(argumentNames)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set by the creator of this advice object if the argument names are known.\n\t * <p>This could be for example because they have been explicitly specified in XML\n\t * or in an advice annotation.\n\t * @param argumentNames list of argument names\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argumentNames"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "void",
    "signature": "public void setArgumentNamesFromStringArray(String... argumentNames)",
    "source_code": "\tpublic void setArgumentNamesFromStringArray(String... argumentNames) {\n\t\tthis.argumentNames = new String[argumentNames.length];\n\t\tfor (int i = 0; i < argumentNames.length; i++) {\n\t\t\tthis.argumentNames[i] = argumentNames[i].strip();\n\t\t\tif (!isVariableName(this.argumentNames[i])) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"'argumentNames' property of AbstractAspectJAdvice contains an argument name '\" +\n\t\t\t\t\t\tthis.argumentNames[i] + \"' that is not a valid Java identifier\");\n\t\t\t}\n\t\t}\n\t\tif (this.aspectJAdviceMethod.getParameterCount() == this.argumentNames.length + 1) {\n\t\t\t// May need to add implicit join point arg name...\n\t\t\tClass<?> firstArgType = this.aspectJAdviceMethod.getParameterTypes()[0];\n\t\t\tif (firstArgType == JoinPoint.class ||\n\t\t\t\t\tfirstArgType == ProceedingJoinPoint.class ||\n\t\t\t\t\tfirstArgType == JoinPoint.StaticPart.class) {\n\t\t\t\tString[] oldNames = this.argumentNames;\n\t\t\t\tthis.argumentNames = new String[oldNames.length + 1];\n\t\t\t\tthis.argumentNames[0] = \"THIS_JOIN_POINT\";\n\t\t\t\tSystem.arraycopy(oldNames, 0, this.argumentNames, 1, oldNames.length);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.aot.agent.Builder": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Builder for {@link RecordedInvocation}.\n\t */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "signature": "public class Builder",
    "source_code": "\tpublic static class Builder {\n\n\t\t@Nullable\n\t\tprivate Object instance;\n\n\t\tprivate final InstrumentedMethod instrumentedMethod;\n\n\t\tprivate Object[] arguments = new Object[0];\n\n\t\t@Nullable\n\t\tprivate Object returnValue;\n\n\n\t\tBuilder(InstrumentedMethod instrumentedMethod) {\n\t\t\tthis.instrumentedMethod = instrumentedMethod;\n\t\t}\n\n\t\t/**\n\t\t * Set the {@code this} object instance used for this invocation.\n\t\t * @param instance the current object instance, {@code null} in case of static invocations\n\t\t * @return {@code this}, to facilitate method chaining\n\t\t */\n\t\tpublic Builder onInstance(Object instance) {\n\t\t\tthis.instance = instance;\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Use the given object as the unique argument.\n\t\t * @param argument the invocation argument\n\t\t * @return {@code this}, to facilitate method chaining\n\t\t */\n\t\tpublic Builder withArgument(@Nullable Object argument) {\n\t\t\tif (argument != null) {\n\t\t\t\tthis.arguments = new Object[] {argument};\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Use the given objects as the invocation arguments.\n\t\t * @param arguments the invocation arguments\n\t\t * @return {@code this}, to facilitate method chaining\n\t\t */\n\t\tpublic Builder withArguments(@Nullable Object... arguments) {\n\t\t\tif (arguments != null) {\n\t\t\t\tthis.arguments = arguments;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Use the given object as the return value for the invocation.\n\t\t * @param returnValue the return value\n\t\t * @return {@code this}, to facilitate method chaining\n\t\t */\n\t\tpublic Builder returnValue(@Nullable Object returnValue) {\n\t\t\tthis.returnValue = returnValue;\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Create a {@link RecordedInvocation} based on the state of this builder.\n\t\t * @return a recorded invocation\n\t\t */\n\t\tpublic RecordedInvocation build() {\n\t\t\tList<StackWalker.StackFrame> stackFrames = StackWalker.getInstance().walk(stream -> stream\n\t\t\t\t\t.dropWhile(stackFrame -> stackFrame.getClassName().startsWith(getClass().getPackageName()))\n\t\t\t\t\t.toList());\n\t\t\treturn new RecordedInvocation(this.instrumentedMethod, this.instance, this.arguments, this.returnValue, stackFrames);\n\t\t}\n\n\t}"
  },
  "org.springframework.aot.agent.RecordedInvocation": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Record of an invocation of a method relevant to {@link org.springframework.aot.hint.RuntimeHints}.\n * <p>The {@link RuntimeHintsAgent} instruments bytecode and intercepts invocations of\n * {@link InstrumentedMethod specific methods}; invocations are recorded during test execution\n * to match them against an existing {@link org.springframework.aot.hint.RuntimeHints} configuration.\n *\n * @author Brian Clozel\n * @since 6.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "signature": "public class RecordedInvocation",
    "source_code": "public final class RecordedInvocation {\n\n\t@Nullable\n\tprivate final Object instance;\n\n\tprivate final InstrumentedMethod instrumentedMethod;\n\n\tprivate final Object[] arguments;\n\n\t@Nullable\n\tprivate final Object returnValue;\n\n\tprivate final List<StackWalker.StackFrame> stackFrames;\n\n\tprivate RecordedInvocation(InstrumentedMethod instrumentedMethod, @Nullable Object instance,\n\t\t\tObject[] arguments, @Nullable Object returnValue, List<StackWalker.StackFrame> stackFrames) {\n\t\tthis.instance = instance;\n\t\tthis.instrumentedMethod = instrumentedMethod;\n\t\tthis.arguments = arguments;\n\t\tthis.returnValue = returnValue;\n\t\tthis.stackFrames = stackFrames;\n\t}\n\n\t/**\n\t * Initialize a builder for the given {@link InstrumentedMethod}.\n\t * @param instrumentedMethod the instrumented method\n\t * @return a builder\n\t */\n\tpublic static Builder of(InstrumentedMethod instrumentedMethod) {\n\t\tAssert.notNull(instrumentedMethod, \"InstrumentedMethod must not be null\");\n\t\treturn new Builder(instrumentedMethod);\n\t}\n\n\t/**\n\t * Return the category of {@link RuntimeHints} this invocation relates to.\n\t * @return the hint type\n\t */\n\tpublic HintType getHintType() {\n\t\treturn this.instrumentedMethod.getHintType();\n\t}\n\n\t/**\n\t * Return a simple representation of the method invoked here.\n\t * @return the method reference\n\t */\n\tpublic MethodReference getMethodReference() {\n\t\treturn this.instrumentedMethod.methodReference();\n\t}\n\n\t/**\n\t * Return the stack trace of the current invocation.\n\t * @return the stack frames\n\t */\n\tpublic Stream<StackWalker.StackFrame> getStackFrames() {\n\t\treturn this.stackFrames.stream();\n\t}\n\n\t/**\n\t * Return the instance of the object being invoked.\n\t * @return the object instance\n\t * @throws IllegalStateException in case of static invocations (there is no {@code this})\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> T getInstance() {\n\t\tAssert.state(this.instance != null, \"Cannot resolve 'this' for static invocations\");\n\t\treturn (T) this.instance;\n\t}\n\n\t/**\n\t * Return the Type reference of the object being invoked.\n\t * @return the instance type reference, or {@code null}\n\t * @throws IllegalStateException in case of static invocations (there is no {@code this})\n\t */\n\tpublic TypeReference getInstanceTypeReference() {\n\t\tAssert.state(this.instance != null, \"Cannot resolve 'this' for static invocations\");\n\t\treturn TypeReference.of(this.instance.getClass());\n\t}\n\n\t/**\n\t * Return whether the current invocation is static.\n\t * @return {@code true} if the invocation is static\n\t */\n\tpublic boolean isStatic() {\n\t\treturn this.instance == null;\n\t}\n\n\t/**\n\t * Return the argument values used for the current reflection invocation.\n\t * @return the invocation arguments\n\t */\n\tpublic List<Object> getArguments() {\n\t\treturn Arrays.asList(this.arguments);\n\t}\n\n\t/**\n\t * Return the argument value at the given index used for the current reflection invocation.\n\t * @param index the parameter index\n\t * @return the argument at the given index\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> T getArgument(int index) {\n\t\treturn (T) this.arguments[index];\n\t}\n\n\t/**\n\t * Return the types of the arguments used for the current reflection invocation.\n\t * @return the argument types\n\t */\n\tpublic List<TypeReference> getArgumentTypes() {\n\t\treturn getArgumentTypes(0);\n\t}\n\n\t/**\n\t * Return the types of the arguments used for the current reflection invocation,\n\t * starting from the given index.\n\t * @return the argument types, starting at the given index\n\t */\n\tpublic List<TypeReference> getArgumentTypes(int index) {\n\t\treturn Arrays.stream(this.arguments).skip(index).map(param -> TypeReference.of(param.getClass())).toList();\n\t}\n\n\t/**\n\t * Return the value actually returned by the invoked method.\n\t * @return the value returned by the invocation\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\t@Nullable\n\tpublic <T> T getReturnValue() {\n\t\treturn (T) this.returnValue;\n\t}\n\n\t/**\n\t * Whether the given hints cover the current invocation.\n\t * <p>If the given hint doesn't match this invocation might fail at execution time depending on the target runtime.\n\t * @return whether the given hints match\n\t */\n\tpublic boolean matches(RuntimeHints hints) {\n\t\treturn this.instrumentedMethod.matcher(this).test(hints);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tif (isStatic()) {\n\t\t\treturn \"<%s> invocation of <%s> with arguments %s\".formatted(\n\t\t\t\t\tgetHintType().hintClassName(), getMethodReference(), getArguments());\n\t\t}\n\t\telse {\n\t\t\tClass<?> instanceType = (getInstance() instanceof Class<?> clazz) ? clazz : getInstance().getClass();\n\t\t\treturn \"<%s> invocation of <%s> on type <%s> with arguments %s\".formatted(\n\t\t\t\t\tgetHintType().hintClassName(), getMethodReference(), instanceType.getCanonicalName(), getArguments());\n\t\t}\n\t}\n\n\t/**\n\t * Builder for {@link RecordedInvocation}.\n\t */\n\tpublic static class Builder {\n\n\t\t@Nullable\n\t\tprivate Object instance;\n\n\t\tprivate final InstrumentedMethod instrumentedMethod;\n\n\t\tprivate Object[] arguments = new Object[0];\n\n\t\t@Nullable\n\t\tprivate Object returnValue;\n\n\n\t\tBuilder(InstrumentedMethod instrumentedMethod) {\n\t\t\tthis.instrumentedMethod = instrumentedMethod;\n\t\t}\n\n\t\t/**\n\t\t * Set the {@code this} object instance used for this invocation.\n\t\t * @param instance the current object instance, {@code null} in case of static invocations\n\t\t * @return {@code this}, to facilitate method chaining\n\t\t */\n\t\tpublic Builder onInstance(Object instance) {\n\t\t\tthis.instance = instance;\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Use the given object as the unique argument.\n\t\t * @param argument the invocation argument\n\t\t * @return {@code this}, to facilitate method chaining\n\t\t */\n\t\tpublic Builder withArgument(@Nullable Object argument) {\n\t\t\tif (argument != null) {\n\t\t\t\tthis.arguments = new Object[] {argument};\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Use the given objects as the invocation arguments.\n\t\t * @param arguments the invocation arguments\n\t\t * @return {@code this}, to facilitate method chaining\n\t\t */\n\t\tpublic Builder withArguments(@Nullable Object... arguments) {\n\t\t\tif (arguments != null) {\n\t\t\t\tthis.arguments = arguments;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Use the given object as the return value for the invocation.\n\t\t * @param returnValue the return value\n\t\t * @return {@code this}, to facilitate method chaining\n\t\t */\n\t\tpublic Builder returnValue(@Nullable Object returnValue) {\n\t\t\tthis.returnValue = returnValue;\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Create a {@link RecordedInvocation} based on the state of this builder.\n\t\t * @return a recorded invocation\n\t\t */\n\t\tpublic RecordedInvocation build() {\n\t\t\tList<StackWalker.StackFrame> stackFrames = StackWalker.getInstance().walk(stream -> stream\n\t\t\t\t\t.dropWhile(stackFrame -> stackFrame.getClassName().startsWith(getClass().getPackageName()))\n\t\t\t\t\t.toList());\n\t\t\treturn new RecordedInvocation(this.instrumentedMethod, this.instance, this.arguments, this.returnValue, stackFrames);\n\t\t}\n\n\t}\n\n}"
  },
  "org.springframework.aot.agent.RecordedInvocation#build()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Create a {@link RecordedInvocation} based on the state of this builder.\n\t\t * @return a recorded invocation\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "RecordedInvocation",
    "signature": "public RecordedInvocation build()",
    "source_code": "\t\tpublic RecordedInvocation build() {\n\t\t\tList<StackWalker.StackFrame> stackFrames = StackWalker.getInstance().walk(stream -> stream\n\t\t\t\t\t.dropWhile(stackFrame -> stackFrame.getClassName().startsWith(getClass().getPackageName()))\n\t\t\t\t\t.toList());\n\t\t\treturn new RecordedInvocation(this.instrumentedMethod, this.instance, this.arguments, this.returnValue, stackFrames);\n\t\t}"
  },
  "org.springframework.aot.agent.RecordedInvocation#getArgument(index)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the argument value at the given index used for the current reflection invocation.\n\t * @param index the parameter index\n\t * @return the argument at the given index\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "T",
    "signature": "public T getArgument(int index)",
    "source_code": "\tpublic <T> T getArgument(int index) {\n\t\treturn (T) this.arguments[index];\n\t}"
  },
  "org.springframework.aot.agent.RecordedInvocation#getArgumentTypes()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the types of the arguments used for the current reflection invocation.\n\t * @return the argument types\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "List<TypeReference>",
    "signature": "public List<TypeReference> getArgumentTypes()",
    "source_code": "\tpublic List<TypeReference> getArgumentTypes() {\n\t\treturn getArgumentTypes(0);\n\t}"
  },
  "org.springframework.aot.agent.RecordedInvocation#getArgumentTypes(index)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the types of the arguments used for the current reflection invocation,\n\t * starting from the given index.\n\t * @return the argument types, starting at the given index\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "List<TypeReference>",
    "signature": "public List<TypeReference> getArgumentTypes(int index)",
    "source_code": "\tpublic List<TypeReference> getArgumentTypes(int index) {\n\t\treturn Arrays.stream(this.arguments).skip(index).map(param -> TypeReference.of(param.getClass())).toList();\n\t}"
  },
  "org.springframework.aot.agent.RecordedInvocation#getArguments()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the argument values used for the current reflection invocation.\n\t * @return the invocation arguments\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "List<Object>",
    "signature": "public List<Object> getArguments()",
    "source_code": "\tpublic List<Object> getArguments() {\n\t\treturn Arrays.asList(this.arguments);\n\t}"
  },
  "org.springframework.aot.agent.RecordedInvocation#getHintType()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the category of {@link RuntimeHints} this invocation relates to.\n\t * @return the hint type\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "HintType",
    "signature": "public HintType getHintType()",
    "source_code": "\tpublic HintType getHintType() {\n\t\treturn this.instrumentedMethod.getHintType();\n\t}"
  },
  "org.springframework.aot.agent.RecordedInvocation#getInstance()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the instance of the object being invoked.\n\t * @return the object instance\n\t * @throws IllegalStateException in case of static invocations (there is no {@code this})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "T",
    "signature": "public T getInstance()",
    "source_code": "\tpublic <T> T getInstance() {\n\t\tAssert.state(this.instance != null, \"Cannot resolve 'this' for static invocations\");\n\t\treturn (T) this.instance;\n\t}"
  },
  "org.springframework.aot.agent.RecordedInvocation#getInstanceTypeReference()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the Type reference of the object being invoked.\n\t * @return the instance type reference, or {@code null}\n\t * @throws IllegalStateException in case of static invocations (there is no {@code this})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "TypeReference",
    "signature": "public TypeReference getInstanceTypeReference()",
    "source_code": "\tpublic TypeReference getInstanceTypeReference() {\n\t\tAssert.state(this.instance != null, \"Cannot resolve 'this' for static invocations\");\n\t\treturn TypeReference.of(this.instance.getClass());\n\t}"
  },
  "org.springframework.aot.agent.RecordedInvocation#getMethodReference()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a simple representation of the method invoked here.\n\t * @return the method reference\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "MethodReference",
    "signature": "public MethodReference getMethodReference()",
    "source_code": "\tpublic MethodReference getMethodReference() {\n\t\treturn this.instrumentedMethod.methodReference();\n\t}"
  },
  "org.springframework.aot.agent.RecordedInvocation#getReturnValue()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the value actually returned by the invoked method.\n\t * @return the value returned by the invocation\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "T",
    "signature": "public T getReturnValue()",
    "source_code": "\tpublic <T> T getReturnValue() {\n\t\treturn (T) this.returnValue;\n\t}"
  },
  "org.springframework.aot.agent.RecordedInvocation#isStatic()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether the current invocation is static.\n\t * @return {@code true} if the invocation is static\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "boolean",
    "signature": "public boolean isStatic()",
    "source_code": "\tpublic boolean isStatic() {\n\t\treturn this.instance == null;\n\t}"
  },
  "org.springframework.aot.agent.RecordedInvocation#matches(hints)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the given hints cover the current invocation.\n\t * <p>If the given hint doesn't match this invocation might fail at execution time depending on the target runtime.\n\t * @return whether the given hints match\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "boolean",
    "signature": "public boolean matches(RuntimeHints hints)",
    "source_code": "\tpublic boolean matches(RuntimeHints hints) {\n\t\treturn this.instrumentedMethod.matcher(this).test(hints);\n\t}"
  },
  "org.springframework.aot.agent.RecordedInvocation#of(instrumentedMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize a builder for the given {@link InstrumentedMethod}.\n\t * @param instrumentedMethod the instrumented method\n\t * @return a builder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "instrumentedMethod"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "Builder",
    "signature": "public Builder of(InstrumentedMethod instrumentedMethod)",
    "source_code": "\tpublic static Builder of(InstrumentedMethod instrumentedMethod) {\n\t\tAssert.notNull(instrumentedMethod, \"InstrumentedMethod must not be null\");\n\t\treturn new Builder(instrumentedMethod);\n\t}"
  },
  "org.springframework.aot.agent.RecordedInvocation#onInstance(instance)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Set the {@code this} object instance used for this invocation.\n\t\t * @param instance the current object instance, {@code null} in case of static invocations\n\t\t * @return {@code this}, to facilitate method chaining\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "instance"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "Builder",
    "signature": "public Builder onInstance(Object instance)",
    "source_code": "\t\tpublic Builder onInstance(Object instance) {\n\t\t\tthis.instance = instance;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.aot.agent.RecordedInvocation#returnValue(returnValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Use the given object as the return value for the invocation.\n\t\t * @param returnValue the return value\n\t\t * @return {@code this}, to facilitate method chaining\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue"
    ],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "Builder",
    "signature": "public Builder returnValue(@Nullable Object returnValue)",
    "source_code": "\t\tpublic Builder returnValue(@Nullable Object returnValue) {\n\t\t\tthis.returnValue = returnValue;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.aot.agent.RecordedInvocation#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\tif (isStatic()) {\n\t\t\treturn \"<%s> invocation of <%s> with arguments %s\".formatted(\n\t\t\t\t\tgetHintType().hintClassName(), getMethodReference(), getArguments());\n\t\t}\n\t\telse {\n\t\t\tClass<?> instanceType = (getInstance() instanceof Class<?> clazz) ? clazz : getInstance().getClass();\n\t\t\treturn \"<%s> invocation of <%s> on type <%s> with arguments %s\".formatted(\n\t\t\t\t\tgetHintType().hintClassName(), getMethodReference(), instanceType.getCanonicalName(), getArguments());\n\t\t}\n\t}"
  },
  "org.springframework.aot.agent.RecordedInvocation#withArgument(argument)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Use the given object as the unique argument.\n\t\t * @param argument the invocation argument\n\t\t * @return {@code this}, to facilitate method chaining\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argument"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "Builder",
    "signature": "public Builder withArgument(@Nullable Object argument)",
    "source_code": "\t\tpublic Builder withArgument(@Nullable Object argument) {\n\t\t\tif (argument != null) {\n\t\t\t\tthis.arguments = new Object[] {argument};\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.aot.agent.RecordedInvocation#withArguments(arguments)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Use the given objects as the invocation arguments.\n\t\t * @param arguments the invocation arguments\n\t\t * @return {@code this}, to facilitate method chaining\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "arguments"
    ],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "Builder",
    "signature": "public Builder withArguments(@Nullable Object... arguments)",
    "source_code": "\t\tpublic Builder withArguments(@Nullable Object... arguments) {\n\t\t\tif (arguments != null) {\n\t\t\t\tthis.arguments = arguments;\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.aot.test.agent.RuntimeHintsInvocationsAssert": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * AssertJ {@link org.assertj.core.api.Assert assertions} that can be applied to\n * {@link RuntimeHintsInvocations}.\n *\n * @author Brian Clozel\n * @since 6.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "signature": "public class RuntimeHintsInvocationsAssert",
    "source_code": "public class RuntimeHintsInvocationsAssert extends AbstractAssert<RuntimeHintsInvocationsAssert, RuntimeHintsInvocations> {\n\n\tprivate final List<Consumer<RuntimeHints>> configurers = new ArrayList<>();\n\n\tRuntimeHintsInvocationsAssert(RuntimeHintsInvocations invocations) {\n\t\tsuper(invocations, RuntimeHintsInvocationsAssert.class);\n\t}\n\n\tpublic RuntimeHintsInvocationsAssert withRegistrar(RuntimeHintsRegistrar registrar) {\n\t\tthis.configurers.add(hints -> registrar.registerHints(hints, getClass().getClassLoader()));\n\t\treturn this;\n\t}\n\n\tpublic RuntimeHintsInvocationsAssert withSpringFactoriesRegistrars(String location) {\n\t\tList<RuntimeHintsRegistrar> registrars = SpringFactoriesLoader.forResourceLocation(location).load(RuntimeHintsRegistrar.class);\n\t\tthis.configurers.add(hints -> registrars.forEach(registrar -> registrar.registerHints(hints, getClass().getClassLoader())));\n\t\treturn this;\n\t}\n\n\tprivate void configureRuntimeHints(RuntimeHints hints) {\n\t\tthis.configurers.forEach(configurer -> configurer.accept(hints));\n\t}\n\n\t/**\n\t * Verifies that each recorded invocation match at least once hint in the provided {@link RuntimeHints}.\n\t * <p>\n\t * Example: <pre class=\"code\">\n\t * RuntimeHints hints = new RuntimeHints();\n\t * hints.reflection().registerType(MyType.class);\n\t * assertThat(invocations).match(hints); </pre>\n\t * @param runtimeHints the runtime hints configuration to test against\n\t * @throws AssertionError if any of the recorded invocations has no match in the provided hints\n\t */\n\tpublic void match(RuntimeHints runtimeHints) {\n\t\tAssert.notNull(runtimeHints, \"RuntimeHints must not be null\");\n\t\tconfigureRuntimeHints(runtimeHints);\n\t\tList<RecordedInvocation> noMatchInvocations =\n\t\t\t\tthis.actual.recordedInvocations().filter(invocation -> !invocation.matches(runtimeHints)).toList();\n\t\tif (!noMatchInvocations.isEmpty()) {\n\t\t\tthrowAssertionError(errorMessageForInvocation(noMatchInvocations.get(0)));\n\t\t}\n\t}\n\n\tpublic ListAssert<RecordedInvocation> notMatching(RuntimeHints runtimeHints) {\n\t\tAssert.notNull(runtimeHints, \"RuntimeHints must not be null\");\n\t\tconfigureRuntimeHints(runtimeHints);\n\t\treturn ListAssert.assertThatStream(this.actual.recordedInvocations()\n\t\t\t\t.filter(invocation -> !invocation.matches(runtimeHints)));\n\t}\n\n\n\tprivate ErrorMessageFactory errorMessageForInvocation(RecordedInvocation invocation) {\n\t\tif (invocation.isStatic()) {\n\t\t\treturn new BasicErrorMessageFactory(\"%nMissing <%s> for invocation <%s>%nwith arguments %s.%nStacktrace:%n<%s>\",\n\t\t\t\t\tinvocation.getHintType().hintClassName(), invocation.getMethodReference(),\n\t\t\t\t\tinvocation.getArguments(), formatStackTrace(invocation.getStackFrames()));\n\t\t}\n\t\telse {\n\t\t\tClass<?> instanceType = (invocation.getInstance() instanceof Class<?> clazz) ? clazz : invocation.getInstance().getClass();\n\t\t\treturn new BasicErrorMessageFactory(\"%nMissing <%s> for invocation <%s> on type <%s> %nwith arguments %s.%nStacktrace:%n<%s>\",\n\t\t\t\t\tinvocation.getHintType().hintClassName(), invocation.getMethodReference(),\n\t\t\t\t\tinstanceType, invocation.getArguments(),\n\t\t\t\t\tformatStackTrace(invocation.getStackFrames()));\n\t\t}\n\t}\n\n\tprivate String formatStackTrace(Stream<StackWalker.StackFrame> stackTraceElements) {\n\t\treturn stackTraceElements\n\t\t\t\t.map(f -> f.getClassName() + \"#\" + f.getMethodName()\n\t\t\t\t\t\t+ \", Line \" + f.getLineNumber()).collect(Collectors.joining(System.lineSeparator()));\n\t}\n\n\t/**\n\t * Verifies that the count of recorded invocations match the expected one.\n\t * <p>\n\t * Example: <pre class=\"code\">\n\t * assertThat(invocations).hasCount(42); </pre>\n\t * @param count the expected invocations count\n\t * @return {@code this} assertion object.\n\t * @throws AssertionError if the number of recorded invocations doesn't match the expected one\n\t */\n\tpublic RuntimeHintsInvocationsAssert hasCount(long count) {\n\t\tisNotNull();\n\t\tlong invocationsCount = this.actual.recordedInvocations().count();\n\t\tif(invocationsCount != count) {\n\t\t\tthrowAssertionError(new BasicErrorMessageFactory(\"%nNumber of recorded invocations does not match, expected <%n> but got <%n>.\",\n\t\t\t\t\tinvocationsCount, count));\n\t\t}\n\t\treturn this;\n\t}\n\n}"
  },
  "org.springframework.aot.test.agent.RuntimeHintsInvocationsAssert#hasCount(count)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Verifies that the count of recorded invocations match the expected one.\n\t * <p>\n\t * Example: <pre class=\"code\">\n\t * assertThat(invocations).hasCount(42); </pre>\n\t * @param count the expected invocations count\n\t * @return {@code this} assertion object.\n\t * @throws AssertionError if the number of recorded invocations doesn't match the expected one\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "count"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "RuntimeHintsInvocationsAssert",
    "signature": "public RuntimeHintsInvocationsAssert hasCount(long count)",
    "source_code": "\tpublic RuntimeHintsInvocationsAssert hasCount(long count) {\n\t\tisNotNull();\n\t\tlong invocationsCount = this.actual.recordedInvocations().count();\n\t\tif(invocationsCount != count) {\n\t\t\tthrowAssertionError(new BasicErrorMessageFactory(\"%nNumber of recorded invocations does not match, expected <%n> but got <%n>.\",\n\t\t\t\t\tinvocationsCount, count));\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.aot.test.agent.RuntimeHintsInvocationsAssert#match(runtimeHints)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Verifies that each recorded invocation match at least once hint in the provided {@link RuntimeHints}.\n\t * <p>\n\t * Example: <pre class=\"code\">\n\t * RuntimeHints hints = new RuntimeHints();\n\t * hints.reflection().registerType(MyType.class);\n\t * assertThat(invocations).match(hints); </pre>\n\t * @param runtimeHints the runtime hints configuration to test against\n\t * @throws AssertionError if any of the recorded invocations has no match in the provided hints\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runtimeHints"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "void",
    "signature": "public void match(RuntimeHints runtimeHints)",
    "source_code": "\tpublic void match(RuntimeHints runtimeHints) {\n\t\tAssert.notNull(runtimeHints, \"RuntimeHints must not be null\");\n\t\tconfigureRuntimeHints(runtimeHints);\n\t\tList<RecordedInvocation> noMatchInvocations =\n\t\t\t\tthis.actual.recordedInvocations().filter(invocation -> !invocation.matches(runtimeHints)).toList();\n\t\tif (!noMatchInvocations.isEmpty()) {\n\t\t\tthrowAssertionError(errorMessageForInvocation(noMatchInvocations.get(0)));\n\t\t}\n\t}"
  },
  "org.springframework.aot.test.agent.RuntimeHintsInvocationsAssert#notMatching(runtimeHints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runtimeHints"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "ListAssert<RecordedInvocation>",
    "signature": "public ListAssert<RecordedInvocation> notMatching(RuntimeHints runtimeHints)",
    "source_code": "\tpublic ListAssert<RecordedInvocation> notMatching(RuntimeHints runtimeHints) {\n\t\tAssert.notNull(runtimeHints, \"RuntimeHints must not be null\");\n\t\tconfigureRuntimeHints(runtimeHints);\n\t\treturn ListAssert.assertThatStream(this.actual.recordedInvocations()\n\t\t\t\t.filter(invocation -> !invocation.matches(runtimeHints)));\n\t}"
  },
  "org.springframework.aot.test.agent.RuntimeHintsInvocationsAssert#withRegistrar(registrar)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registrar"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "return": "RuntimeHintsInvocationsAssert",
    "signature": "public RuntimeHintsInvocationsAssert withRegistrar(RuntimeHintsRegistrar registrar)",
    "source_code": "\tpublic RuntimeHintsInvocationsAssert withRegistrar(RuntimeHintsRegistrar registrar) {\n\t\tthis.configurers.add(hints -> registrar.registerHints(hints, getClass().getClassLoader()));\n\t\treturn this;\n\t}"
  },
  "org.springframework.aot.test.agent.RuntimeHintsInvocationsAssert#withSpringFactoriesRegistrars(location)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "RuntimeHintsInvocationsAssert",
    "signature": "public RuntimeHintsInvocationsAssert withSpringFactoriesRegistrars(String location)",
    "source_code": "\tpublic RuntimeHintsInvocationsAssert withSpringFactoriesRegistrars(String location) {\n\t\tList<RuntimeHintsRegistrar> registrars = SpringFactoriesLoader.forResourceLocation(location).load(RuntimeHintsRegistrar.class);\n\t\tthis.configurers.add(hints -> registrars.forEach(registrar -> registrar.registerHints(hints, getClass().getClassLoader())));\n\t\treturn this;\n\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#addProperty(propertyName,propertyValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName",
      "propertyValue"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "GroovyBeanDefinitionWrapper",
    "signature": "public GroovyBeanDefinitionWrapper addProperty(String propertyName, Object propertyValue)",
    "source_code": "\tpublic GroovyBeanDefinitionWrapper addProperty(String propertyName, Object propertyValue) {\n\t\tif (propertyValue instanceof GroovyBeanDefinitionWrapper wrapper) {\n\t\t\tpropertyValue = wrapper.getBeanDefinition();\n\t\t}\n\t\tgetBeanDefinition().getPropertyValues().add(propertyName, propertyValue);\n\t\treturn this;\n\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#getBeanDefinition()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "AbstractBeanDefinition",
    "signature": "public AbstractBeanDefinition getBeanDefinition()",
    "source_code": "\tpublic AbstractBeanDefinition getBeanDefinition() {\n\t\tif (this.definition == null) {\n\t\t\tthis.definition = createBeanDefinition();\n\t\t}\n\t\treturn this.definition;\n\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#getBeanDefinitionHolder()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "BeanDefinitionHolder",
    "signature": "public BeanDefinitionHolder getBeanDefinitionHolder()",
    "source_code": "\tpublic BeanDefinitionHolder getBeanDefinitionHolder() {\n\t\treturn new BeanDefinitionHolder(getBeanDefinition(), getBeanName());\n\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#setBeanDefinition(definition)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "void",
    "signature": "public void setBeanDefinition(AbstractBeanDefinition definition)",
    "source_code": "\tpublic void setBeanDefinition(AbstractBeanDefinition definition) {\n\t\tthis.definition = definition;\n\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#setBeanDefinitionHolder(holder)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "holder"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "void",
    "signature": "public void setBeanDefinitionHolder(BeanDefinitionHolder holder)",
    "source_code": "\tpublic void setBeanDefinitionHolder(BeanDefinitionHolder holder) {\n\t\tthis.definition = (AbstractBeanDefinition) holder.getBeanDefinition();\n\t\tthis.beanName = holder.getBeanName();\n\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#setParent(obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "void",
    "signature": "public void setParent(Object obj)",
    "source_code": "\tpublic void setParent(Object obj) {\n\t\tif (obj == null) {\n\t\t\tthrow new IllegalArgumentException(\"Parent bean cannot be set to a null runtime bean reference!\");\n\t\t}\n\t\tif (obj instanceof String name) {\n\t\t\tthis.parentName = name;\n\t\t}\n\t\telse if (obj instanceof RuntimeBeanReference runtimeBeanReference) {\n\t\t\tthis.parentName = runtimeBeanReference.getBeanName();\n\t\t}\n\t\telse if (obj instanceof GroovyBeanDefinitionWrapper wrapper) {\n\t\t\tthis.parentName = wrapper.getBeanName();\n\t\t}\n\t\tgetBeanDefinition().setParentName(this.parentName);\n\t\tgetBeanDefinition().setAbstract(false);\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#obtainFromSupplier(supplier,beanName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a bean instance from the given supplier.\n\t * @param supplier the configured supplier\n\t * @param beanName the corresponding bean name\n\t * @return a BeanWrapper for the new instance\n\t * @since 5.0\n\t * @see #getObjectForBeanInstance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "supplier",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 1209
    },
    "return": "BeanWrapper",
    "signature": "protected BeanWrapper obtainFromSupplier(Supplier<?> supplier, String beanName)",
    "source_code": "\tprotected BeanWrapper obtainFromSupplier(Supplier<?> supplier, String beanName) {\n\t\tObject instance = obtainInstanceFromSupplier(supplier, beanName);\n\t\tif (instance == null) {\n\t\t\tinstance = new NullBean();\n\t\t}\n\t\tBeanWrapper bw = new BeanWrapperImpl(instance);\n\t\tinitBeanWrapper(bw);\n\t\treturn bw;\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#obtainInstanceFromSupplier(supplier,beanName,mbd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a bean instance from the given supplier.\n\t * @param supplier the configured supplier\n\t * @param beanName the corresponding bean name\n\t * @param mbd the bean definition for the bean\n\t * @return the bean instance (possibly {@code null})\n\t * @since 6.0.7\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "supplier",
      "beanName",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 1248
    },
    "return": "Object",
    "signature": "protected Object obtainInstanceFromSupplier(Supplier<?> supplier, String beanName, RootBeanDefinition mbd)",
    "source_code": "\tprotected Object obtainInstanceFromSupplier(Supplier<?> supplier, String beanName, RootBeanDefinition mbd)"
  },
  "org.springframework.beans.factory.support.DefaultListableBeanFactory#obtainInstanceFromSupplier(supplier,beanName,mbd)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "supplier",
      "beanName",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 943
    },
    "return": "Object",
    "signature": "protected Object obtainInstanceFromSupplier(Supplier<?> supplier, String beanName, RootBeanDefinition mbd)",
    "source_code": "\tprotected Object obtainInstanceFromSupplier(Supplier<?> supplier, String beanName, RootBeanDefinition mbd)"
  },
  "org.springframework.beans.factory.support.SimpleInstantiationStrategy": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Simple object instantiation strategy for use in a BeanFactory.\n *\n * <p>Does not support Method Injection, although it provides hooks for subclasses\n * to override to add Method Injection support, for example by overriding methods.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 1.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "signature": "public class SimpleInstantiationStrategy",
    "source_code": "public class SimpleInstantiationStrategy implements InstantiationStrategy {\n\n\tprivate static final ThreadLocal<Method> currentlyInvokedFactoryMethod = new ThreadLocal<>();\n\n\n\t/**\n\t * Return the factory method currently being invoked or {@code null} if none.\n\t * <p>Allows factory method implementations to determine whether the current\n\t * caller is the container itself as opposed to user code.\n\t */\n\t@Nullable\n\tpublic static Method getCurrentlyInvokedFactoryMethod() {\n\t\treturn currentlyInvokedFactoryMethod.get();\n\t}\n\n\t/**\n\t * Set the factory method currently being invoked or {@code null} to reset.\n\t * @param method the factory method currently being invoked or {@code null}\n\t * @since 6.0\n\t */\n\tpublic static void setCurrentlyInvokedFactoryMethod(@Nullable Method method) {\n\t\tcurrentlyInvokedFactoryMethod.set(method);\n\t}\n\n\n\t@Override\n\tpublic Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) {\n\t\t// Don't override the class with CGLIB if no overrides.\n\t\tif (!bd.hasMethodOverrides()) {\n\t\t\tConstructor<?> constructorToUse;\n\t\t\tsynchronized (bd.constructorArgumentLock) {\n\t\t\t\tconstructorToUse = (Constructor<?>) bd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (constructorToUse == null) {\n\t\t\t\t\tfinal Class<?> clazz = bd.getBeanClass();\n\t\t\t\t\tif (clazz.isInterface()) {\n\t\t\t\t\t\tthrow new BeanInstantiationException(clazz, \"Specified class is an interface\");\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconstructorToUse = clazz.getDeclaredConstructor();\n\t\t\t\t\t\tbd.resolvedConstructorOrFactoryMethod = constructorToUse;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tthrow new BeanInstantiationException(clazz, \"No default constructor found\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn BeanUtils.instantiateClass(constructorToUse);\n\t\t}\n\t\telse {\n\t\t\t// Must generate CGLIB subclass.\n\t\t\treturn instantiateWithMethodInjection(bd, beanName, owner);\n\t\t}\n\t}\n\n\t/**\n\t * Subclasses can override this method, which is implemented to throw\n\t * UnsupportedOperationException, if they can instantiate an object with\n\t * the Method Injection specified in the given RootBeanDefinition.\n\t * Instantiation should use a no-arg constructor.\n\t */\n\tprotected Object instantiateWithMethodInjection(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) {\n\t\tthrow new UnsupportedOperationException(\"Method Injection not supported in SimpleInstantiationStrategy\");\n\t}\n\n\t@Override\n\tpublic Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,\n\t\t\tfinal Constructor<?> ctor, Object... args) {\n\n\t\tif (!bd.hasMethodOverrides()) {\n\t\t\treturn BeanUtils.instantiateClass(ctor, args);\n\t\t}\n\t\telse {\n\t\t\treturn instantiateWithMethodInjection(bd, beanName, owner, ctor, args);\n\t\t}\n\t}\n\n\t/**\n\t * Subclasses can override this method, which is implemented to throw\n\t * UnsupportedOperationException, if they can instantiate an object with\n\t * the Method Injection specified in the given RootBeanDefinition.\n\t * Instantiation should use the given constructor and parameters.\n\t */\n\tprotected Object instantiateWithMethodInjection(RootBeanDefinition bd, @Nullable String beanName,\n\t\t\tBeanFactory owner, @Nullable Constructor<?> ctor, Object... args) {\n\n\t\tthrow new UnsupportedOperationException(\"Method Injection not supported in SimpleInstantiationStrategy\");\n\t}\n\n\t@Override\n\tpublic Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,\n\t\t\t@Nullable Object factoryBean, final Method factoryMethod, Object... args) {\n\n\t\ttry {\n\t\t\tReflectionUtils.makeAccessible(factoryMethod);\n\n\t\t\tMethod priorInvokedFactoryMethod = currentlyInvokedFactoryMethod.get();\n\t\t\ttry {\n\t\t\t\tcurrentlyInvokedFactoryMethod.set(factoryMethod);\n\t\t\t\tObject result = factoryMethod.invoke(factoryBean, args);\n\t\t\t\tif (result == null) {\n\t\t\t\t\tresult = new NullBean();\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (priorInvokedFactoryMethod != null) {\n\t\t\t\t\tcurrentlyInvokedFactoryMethod.set(priorInvokedFactoryMethod);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcurrentlyInvokedFactoryMethod.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\tthrow new BeanInstantiationException(factoryMethod,\n\t\t\t\t\t\"Illegal arguments to factory method '\" + factoryMethod.getName() + \"'; \" +\n\t\t\t\t\t\"args: \" + StringUtils.arrayToCommaDelimitedString(args), ex);\n\t\t}\n\t\tcatch (IllegalAccessException ex) {\n\t\t\tthrow new BeanInstantiationException(factoryMethod,\n\t\t\t\t\t\"Cannot access factory method '\" + factoryMethod.getName() + \"'; is it public?\", ex);\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\tString msg = \"Factory method '\" + factoryMethod.getName() + \"' threw exception with message: \" +\n\t\t\t\t\tex.getTargetException().getMessage();\n\t\t\tif (bd.getFactoryBeanName() != null && owner instanceof ConfigurableBeanFactory cbf &&\n\t\t\t\t\tcbf.isCurrentlyInCreation(bd.getFactoryBeanName())) {\n\t\t\t\tmsg = \"Circular reference involving containing bean '\" + bd.getFactoryBeanName() + \"' - consider \" +\n\t\t\t\t\t\t\"declaring the factory method as static for independence from its containing instance. \" + msg;\n\t\t\t}\n\t\t\tthrow new BeanInstantiationException(factoryMethod, msg, ex.getTargetException());\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.beans.factory.support.SimpleInstantiationStrategy#getCurrentlyInvokedFactoryMethod()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the factory method currently being invoked or {@code null} if none.\n\t * <p>Allows factory method implementations to determine whether the current\n\t * caller is the container itself as opposed to user code.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "Method",
    "signature": "public Method getCurrentlyInvokedFactoryMethod()",
    "source_code": "\tpublic static Method getCurrentlyInvokedFactoryMethod() {\n\t\treturn currentlyInvokedFactoryMethod.get();\n\t}"
  },
  "org.springframework.beans.factory.support.SimpleInstantiationStrategy#instantiate(bd,beanName,owner)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bd",
      "beanName",
      "owner"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "Object",
    "signature": "public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner)",
    "source_code": "\tpublic Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) {\n\t\t// Don't override the class with CGLIB if no overrides.\n\t\tif (!bd.hasMethodOverrides()) {\n\t\t\tConstructor<?> constructorToUse;\n\t\t\tsynchronized (bd.constructorArgumentLock) {\n\t\t\t\tconstructorToUse = (Constructor<?>) bd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (constructorToUse == null) {\n\t\t\t\t\tfinal Class<?> clazz = bd.getBeanClass();\n\t\t\t\t\tif (clazz.isInterface()) {\n\t\t\t\t\t\tthrow new BeanInstantiationException(clazz, \"Specified class is an interface\");\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconstructorToUse = clazz.getDeclaredConstructor();\n\t\t\t\t\t\tbd.resolvedConstructorOrFactoryMethod = constructorToUse;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tthrow new BeanInstantiationException(clazz, \"No default constructor found\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn BeanUtils.instantiateClass(constructorToUse);\n\t\t}\n\t\telse {\n\t\t\t// Must generate CGLIB subclass.\n\t\t\treturn instantiateWithMethodInjection(bd, beanName, owner);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.SimpleInstantiationStrategy#instantiate(bd,beanName,owner,ctor,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bd",
      "beanName",
      "owner",
      "ctor",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "Object",
    "signature": "public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,\n\t\t\tfinal Constructor<?> ctor, Object... args)",
    "source_code": "\tpublic Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,"
  },
  "org.springframework.beans.factory.support.SimpleInstantiationStrategy#instantiate(bd,beanName,owner,factoryBean,factoryMethod,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bd",
      "beanName",
      "owner",
      "factoryBean",
      "factoryMethod",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "Object",
    "signature": "public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,\n\t\t\t@Nullable Object factoryBean, final Method factoryMethod, Object... args)",
    "source_code": "\tpublic Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,"
  },
  "org.springframework.beans.factory.support.SimpleInstantiationStrategy#instantiateWithMethodInjection(bd,beanName,owner)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses can override this method, which is implemented to throw\n\t * UnsupportedOperationException, if they can instantiate an object with\n\t * the Method Injection specified in the given RootBeanDefinition.\n\t * Instantiation should use a no-arg constructor.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bd",
      "beanName",
      "owner"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "Object",
    "signature": "protected Object instantiateWithMethodInjection(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner)",
    "source_code": "\tprotected Object instantiateWithMethodInjection(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) {\n\t\tthrow new UnsupportedOperationException(\"Method Injection not supported in SimpleInstantiationStrategy\");\n\t}"
  },
  "org.springframework.beans.factory.support.SimpleInstantiationStrategy#instantiateWithMethodInjection(bd,beanName,owner,ctor,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses can override this method, which is implemented to throw\n\t * UnsupportedOperationException, if they can instantiate an object with\n\t * the Method Injection specified in the given RootBeanDefinition.\n\t * Instantiation should use the given constructor and parameters.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bd",
      "beanName",
      "owner",
      "ctor",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "Object",
    "signature": "protected Object instantiateWithMethodInjection(RootBeanDefinition bd, @Nullable String beanName,\n\t\t\tBeanFactory owner, @Nullable Constructor<?> ctor, Object... args)",
    "source_code": "\tprotected Object instantiateWithMethodInjection(RootBeanDefinition bd, @Nullable String beanName,"
  },
  "org.springframework.beans.factory.support.SimpleInstantiationStrategy#setCurrentlyInvokedFactoryMethod(method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the factory method currently being invoked or {@code null} to reset.\n\t * @param method the factory method currently being invoked or {@code null}\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "void",
    "signature": "public void setCurrentlyInvokedFactoryMethod(@Nullable Method method)",
    "source_code": "\tpublic static void setCurrentlyInvokedFactoryMethod(@Nullable Method method) {\n\t\tcurrentlyInvokedFactoryMethod.set(method);\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCache": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Spring {@link org.springframework.cache.Cache} adapter implementation\n * on top of a Caffeine {@link com.github.benmanes.caffeine.cache.Cache} instance.\n *\n * <p>Requires Caffeine 2.1 or higher.\n *\n * @author Ben Manes\n * @author Juergen Hoeller\n * @author Stephane Nicoll\n * @since 4.3\n * @see CaffeineCacheManager\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 40
    },
    "signature": "public class CaffeineCache",
    "source_code": "public class CaffeineCache extends AbstractValueAdaptingCache {\n\n\tprivate final String name;\n\n\tprivate final com.github.benmanes.caffeine.cache.Cache<Object, Object> cache;\n\n\n\t/**\n\t * Create a {@link CaffeineCache} instance with the specified name and the\n\t * given internal {@link com.github.benmanes.caffeine.cache.Cache} to use.\n\t * @param name the name of the cache\n\t * @param cache the backing Caffeine Cache instance\n\t */\n\tpublic CaffeineCache(String name, com.github.benmanes.caffeine.cache.Cache<Object, Object> cache) {\n\t\tthis(name, cache, true);\n\t}\n\n\t/**\n\t * Create a {@link CaffeineCache} instance with the specified name and the\n\t * given internal {@link com.github.benmanes.caffeine.cache.Cache} to use.\n\t * @param name the name of the cache\n\t * @param cache the backing Caffeine Cache instance\n\t * @param allowNullValues whether to accept and convert {@code null}\n\t * values for this cache\n\t */\n\tpublic CaffeineCache(String name, com.github.benmanes.caffeine.cache.Cache<Object, Object> cache,\n\t\t\tboolean allowNullValues) {\n\n\t\tsuper(allowNullValues);\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tAssert.notNull(cache, \"Cache must not be null\");\n\t\tthis.name = name;\n\t\tthis.cache = cache;\n\t}\n\n\n\t@Override\n\tpublic final String getName() {\n\t\treturn this.name;\n\t}\n\n\t@Override\n\tpublic final com.github.benmanes.caffeine.cache.Cache<Object, Object> getNativeCache() {\n\t\treturn this.cache;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\t@Nullable\n\tpublic <T> T get(Object key, final Callable<T> valueLoader) {\n\t\treturn (T) fromStoreValue(this.cache.get(key, new LoadFunction(valueLoader)));\n\t}\n\n\t@Override\n\t@Nullable\n\tprotected Object lookup(Object key) {\n\t\tif (this.cache instanceof LoadingCache<Object, Object> loadingCache) {\n\t\t\treturn loadingCache.get(key);\n\t\t}\n\t\treturn this.cache.getIfPresent(key);\n\t}\n\n\t@Override\n\tpublic void put(Object key, @Nullable Object value) {\n\t\tthis.cache.put(key, toStoreValue(value));\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic ValueWrapper putIfAbsent(Object key, @Nullable final Object value) {\n\t\tPutIfAbsentFunction callable = new PutIfAbsentFunction(value);\n\t\tObject result = this.cache.get(key, callable);\n\t\treturn (callable.called ? null : toValueWrapper(result));\n\t}\n\n\t@Override\n\tpublic void evict(Object key) {\n\t\tthis.cache.invalidate(key);\n\t}\n\n\t@Override\n\tpublic boolean evictIfPresent(Object key) {\n\t\treturn (this.cache.asMap().remove(key) != null);\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\tthis.cache.invalidateAll();\n\t}\n\n\t@Override\n\tpublic boolean invalidate() {\n\t\tboolean notEmpty = !this.cache.asMap().isEmpty();\n\t\tthis.cache.invalidateAll();\n\t\treturn notEmpty;\n\t}\n\n\n\tprivate class PutIfAbsentFunction implements Function<Object, Object> {\n\n\t\t@Nullable\n\t\tprivate final Object value;\n\n\t\tprivate boolean called;\n\n\t\tpublic PutIfAbsentFunction(@Nullable Object value) {\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object apply(Object key) {\n\t\t\tthis.called = true;\n\t\t\treturn toStoreValue(this.value);\n\t\t}\n\t}\n\n\n\tprivate class LoadFunction implements Function<Object, Object> {\n\n\t\tprivate final Callable<?> valueLoader;\n\n\t\tpublic LoadFunction(Callable<?> valueLoader) {\n\t\t\tthis.valueLoader = valueLoader;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object apply(Object o) {\n\t\t\ttry {\n\t\t\t\treturn toStoreValue(this.valueLoader.call());\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new ValueRetrievalException(o, this.valueLoader, ex);\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.cache.caffeine.CaffeineCache#apply(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "Object",
    "signature": "public Object apply(Object key)",
    "source_code": "\t\tpublic Object apply(Object key) {\n\t\t\tthis.called = true;\n\t\t\treturn toStoreValue(this.value);\n\t\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCache#apply(o)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "Object",
    "signature": "public Object apply(Object o)",
    "source_code": "\t\tpublic Object apply(Object o) {\n\t\t\ttry {\n\t\t\t\treturn toStoreValue(this.valueLoader.call());\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new ValueRetrievalException(o, this.valueLoader, ex);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCache#clear()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\tpublic void clear() {\n\t\tthis.cache.invalidateAll();\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCache#evict(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "void",
    "signature": "public void evict(Object key)",
    "source_code": "\tpublic void evict(Object key) {\n\t\tthis.cache.invalidate(key);\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCache#evictIfPresent(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "boolean",
    "signature": "public boolean evictIfPresent(Object key)",
    "source_code": "\tpublic boolean evictIfPresent(Object key) {\n\t\treturn (this.cache.asMap().remove(key) != null);\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCache#get(key,valueLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "valueLoader"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "T",
    "signature": "public T get(Object key, final Callable<T> valueLoader)",
    "source_code": "\tpublic <T> T get(Object key, final Callable<T> valueLoader) {\n\t\treturn (T) fromStoreValue(this.cache.get(key, new LoadFunction(valueLoader)));\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCache#getName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "String",
    "signature": "public String getName()",
    "source_code": "\tpublic final String getName() {\n\t\treturn this.name;\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCache#invalidate()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "boolean",
    "signature": "public boolean invalidate()",
    "source_code": "\tpublic boolean invalidate() {\n\t\tboolean notEmpty = !this.cache.asMap().isEmpty();\n\t\tthis.cache.invalidateAll();\n\t\treturn notEmpty;\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCache#lookup(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "Object",
    "signature": "protected Object lookup(Object key)",
    "source_code": "\tprotected Object lookup(Object key) {\n\t\tif (this.cache instanceof LoadingCache<Object, Object> loadingCache) {\n\t\t\treturn loadingCache.get(key);\n\t\t}\n\t\treturn this.cache.getIfPresent(key);\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCache#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "void",
    "signature": "public void put(Object key, @Nullable Object value)",
    "source_code": "\tpublic void put(Object key, @Nullable Object value) {\n\t\tthis.cache.put(key, toStoreValue(value));\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCache#putIfAbsent(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "ValueWrapper",
    "signature": "public ValueWrapper putIfAbsent(Object key, @Nullable final Object value)",
    "source_code": "\tpublic ValueWrapper putIfAbsent(Object key, @Nullable final Object value) {\n\t\tPutIfAbsentFunction callable = new PutIfAbsentFunction(value);\n\t\tObject result = this.cache.get(key, callable);\n\t\treturn (callable.called ? null : toValueWrapper(result));\n\t}"
  },
  "org.springframework.cache.jcache.config.AbstractJCacheConfiguration": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract JSR-107 specific {@code @Configuration} class providing common\n * structure for enabling JSR-107 annotation-driven cache management capability.\n *\n * @author Stephane Nicoll\n * @author Juergen Hoeller\n * @since 4.1\n * @see JCacheConfigurer\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "signature": "public class AbstractJCacheConfiguration",
    "source_code": "public abstract class AbstractJCacheConfiguration extends AbstractCachingConfiguration {\n\n\t@Nullable\n\tprotected Supplier<CacheResolver> exceptionCacheResolver;\n\n\n\t@Override\n\tprotected void useCachingConfigurer(CachingConfigurerSupplier cachingConfigurerSupplier) {\n\t\tsuper.useCachingConfigurer(cachingConfigurerSupplier);\n\t\tthis.exceptionCacheResolver = cachingConfigurerSupplier.adapt(config -> {\n\t\t\tif (config instanceof JCacheConfigurer jcacheConfigurer) {\n\t\t\t\treturn jcacheConfigurer.exceptionCacheResolver();\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Bean(name = \"jCacheOperationSource\")\n\t@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\n\tpublic JCacheOperationSource cacheOperationSource() {\n\t\treturn new DefaultJCacheOperationSource(\n\t\t\t\tthis.cacheManager, this.cacheResolver, this.exceptionCacheResolver, this.keyGenerator);\n\t}\n\n}"
  },
  "org.springframework.cache.jcache.config.AbstractJCacheConfiguration#cacheOperationSource()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "JCacheOperationSource",
    "signature": "public JCacheOperationSource cacheOperationSource()",
    "source_code": "\tpublic JCacheOperationSource cacheOperationSource() {\n\t\treturn new DefaultJCacheOperationSource(\n\t\t\t\tthis.cacheManager, this.cacheResolver, this.exceptionCacheResolver, this.keyGenerator);\n\t}"
  },
  "org.springframework.cache.jcache.config.AbstractJCacheConfiguration#useCachingConfigurer(cachingConfigurerSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "cachingConfigurerSupplier"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "return": "void",
    "signature": "protected void useCachingConfigurer(CachingConfigurerSupplier cachingConfigurerSupplier)",
    "source_code": "\tprotected void useCachingConfigurer(CachingConfigurerSupplier cachingConfigurerSupplier) {\n\t\tsuper.useCachingConfigurer(cachingConfigurerSupplier);\n\t\tthis.exceptionCacheResolver = cachingConfigurerSupplier.adapt(config -> {\n\t\t\tif (config instanceof JCacheConfigurer jcacheConfigurer) {\n\t\t\t\treturn jcacheConfigurer.exceptionCacheResolver();\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.cache.jcache.config.exceptionCacheResolver": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "signature": "protected Supplier<CacheResolver> exceptionCacheResolver",
    "source_code": "\tprotected Supplier<CacheResolver> exceptionCacheResolver;",
    "type": "Supplier<CacheResolver>"
  },
  "org.springframework.cache.jcache.interceptor.<unknown>#getKeyParameters()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 55
    },
    "return": "CacheInvocationParameter[]",
    "signature": "public CacheInvocationParameter[] getKeyParameters()",
    "source_code": "\tpublic CacheInvocationParameter[] getKeyParameters() {\n\t\treturn this.keyParameters.clone();\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.<unknown>#getValueParameter()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "CacheInvocationParameter",
    "signature": "public CacheInvocationParameter getValueParameter()",
    "source_code": "\tpublic CacheInvocationParameter getValueParameter() {\n\t\treturn this.valueParameter;\n\t}"
  },
  "org.springframework.cglib.beans.BeanGenerator": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * @author Juozas Baliuka, Chris Nokleberg\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "signature": "public class BeanGenerator",
    "source_code": "public class BeanGenerator extends AbstractClassGenerator"
  },
  "org.springframework.cglib.beans.BeanGenerator#addProperties(gen,descriptors)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "gen",
      "descriptors"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "void",
    "signature": "public void addProperties(BeanGenerator gen, PropertyDescriptor[] descriptors)",
    "source_code": "    public static void addProperties(BeanGenerator gen, PropertyDescriptor[] descriptors) {\n        for (PropertyDescriptor descriptor : descriptors) {\n            gen.addProperty(descriptor.getName(), descriptor.getPropertyType());\n        }\n    }"
  },
  "org.springframework.cglib.beans.BeanGenerator#addProperties(gen,props)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "gen",
      "props"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "void",
    "signature": "public void addProperties(BeanGenerator gen, Map props)",
    "source_code": "    public static void addProperties(BeanGenerator gen, Map props) {\n        for (Iterator it = props.keySet().iterator(); it.hasNext();) {\n            String name = (String)it.next();\n            gen.addProperty(name, (Class)props.get(name));\n        }\n    }"
  },
  "org.springframework.cglib.beans.BeanGenerator#addProperties(gen,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "gen",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "void",
    "signature": "public void addProperties(BeanGenerator gen, Class type)",
    "source_code": "    public static void addProperties(BeanGenerator gen, Class type) {\n        addProperties(gen, ReflectUtils.getBeanProperties(type));\n    }"
  },
  "org.springframework.cglib.beans.BeanGenerator#addProperty(name,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "void",
    "signature": "public void addProperty(String name, Class type)",
    "source_code": "    public void addProperty(String name, Class type) {\n        if (props.containsKey(name)) {\n            throw new IllegalArgumentException(\"Duplicate property name \\\"\" + name + \"\\\"\");\n        }\n        props.put(name, Type.getType(type));\n    }"
  },
  "org.springframework.cglib.beans.BeanGenerator#create()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "Object",
    "signature": "public Object create()",
    "source_code": "    public Object create() {\n        classOnly = false;\n        return createHelper();\n    }"
  },
  "org.springframework.cglib.beans.BeanGenerator#createClass()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "Object",
    "signature": "public Object createClass()",
    "source_code": "    public Object createClass() {\n        classOnly = true;\n        return createHelper();\n    }"
  },
  "org.springframework.cglib.beans.BeanGenerator#firstInstance(type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "Object",
    "signature": "protected Object firstInstance(Class type)",
    "source_code": "\tprotected Object firstInstance(Class type) {\n        if (classOnly) {\n            return type;\n        } else {\n            return ReflectUtils.newInstance(type);\n        }\n    }"
  },
  "org.springframework.cglib.beans.BeanGenerator#generateClass(v)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "v"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "public void generateClass(ClassVisitor v)",
    "source_code": "\tpublic void generateClass(ClassVisitor v) throws Exception {\n        int size = props.size();\n        String[] names = (String[])props.keySet().toArray(new String[size]);\n        Type[] types = new Type[size];\n        for (int i = 0; i < size; i++) {\n            types[i] = (Type)props.get(names[i]);\n        }\n        ClassEmitter ce = new ClassEmitter(v);\n        ce.begin_class(Constants.V1_8,\n                       Constants.ACC_PUBLIC,\n                       getClassName(),\n                       superclass != null ? Type.getType(superclass) : Constants.TYPE_OBJECT,\n                       null,\n                       null);\n        EmitUtils.null_constructor(ce);\n        EmitUtils.add_properties(ce, names, types);\n        ce.end_class();\n    }"
  },
  "org.springframework.cglib.beans.BeanGenerator#getDefaultClassLoader()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "ClassLoader",
    "signature": "protected ClassLoader getDefaultClassLoader()",
    "source_code": "\tprotected ClassLoader getDefaultClassLoader() {\n        if (superclass != null) {\n            return superclass.getClassLoader();\n        } else {\n            return null;\n        }\n    }"
  },
  "org.springframework.cglib.beans.BeanGenerator#getProtectionDomain()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "ProtectionDomain",
    "signature": "protected ProtectionDomain getProtectionDomain()",
    "source_code": "\tprotected ProtectionDomain getProtectionDomain() {\n        return ReflectUtils.getProtectionDomain(superclass);\n    }"
  },
  "org.springframework.cglib.beans.BeanGenerator#newInstance(superclass,props)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "superclass",
      "props"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "return": "Object",
    "signature": "public Object newInstance(String superclass, Map props)",
    "source_code": "        public Object newInstance(String superclass, Map props);"
  },
  "org.springframework.cglib.beans.BeanGenerator#nextInstance(instance)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "instance"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "Object",
    "signature": "protected Object nextInstance(Object instance)",
    "source_code": "\tprotected Object nextInstance(Object instance) {\n        Class protoclass = (instance instanceof Class<?> clazz) ? clazz : instance.getClass();\n        if (classOnly) {\n            return protoclass;\n        } else {\n            return ReflectUtils.newInstance(protoclass);\n        }\n    }"
  },
  "org.springframework.cglib.beans.BeanGenerator#setSuperclass(superclass)": {
    "change": "added",
    "deprecated": false,
    "doc": "    /**\n     * Set the class which the generated class will extend. The class\n     * must not be declared as final, and must have a non-private\n     * no-argument constructor.\n     * @param superclass class to extend, or null to extend Object\n     */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "superclass"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "void",
    "signature": "public void setSuperclass(Class superclass)",
    "source_code": "    public void setSuperclass(Class superclass) {\n        if (superclass != null && superclass.equals(Object.class)) {\n            superclass = null;\n        }\n        this.superclass = superclass;\n\t\t// SPRING PATCH BEGIN\n\t\tsetContextClass(superclass);\n\t\t// SPRING PATCH END\n    }"
  },
  "org.springframework.cglib.core.ArrayDelimiters": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 693
    },
    "signature": "public class ArrayDelimiters",
    "source_code": "    public static class ArrayDelimiters {\n        private String before;\n        private String inside;\n        private String after;\n\n        public ArrayDelimiters(String before, String inside, String after) {\n            this.before = before;\n            this.inside = inside;\n            this.after = after;\n        }\n    }"
  },
  "org.springframework.cglib.core.DEFAULT_DELIMITERS": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "signature": "public ArrayDelimiters DEFAULT_DELIMITERS",
    "source_code": "    public static final ArrayDelimiters DEFAULT_DELIMITERS = new ArrayDelimiters(\"{\", \", \", \"}\");",
    "type": "ArrayDelimiters"
  },
  "org.springframework.cglib.core.EmitUtils": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 36
    },
    "signature": "public class EmitUtils",
    "source_code": "public class EmitUtils {\n    private static final Signature CSTRUCT_NULL =\n      TypeUtils.parseConstructor(\"\");\n    private static final Signature CSTRUCT_THROWABLE =\n      TypeUtils.parseConstructor(\"Throwable\");\n\n    private static final Signature GET_NAME =\n      TypeUtils.parseSignature(\"String getName()\");\n    private static final Signature HASH_CODE =\n      TypeUtils.parseSignature(\"int hashCode()\");\n    private static final Signature EQUALS =\n      TypeUtils.parseSignature(\"boolean equals(Object)\");\n    private static final Signature STRING_LENGTH =\n      TypeUtils.parseSignature(\"int length()\");\n    private static final Signature STRING_CHAR_AT =\n      TypeUtils.parseSignature(\"char charAt(int)\");\n    private static final Signature FOR_NAME =\n      TypeUtils.parseSignature(\"Class forName(String)\");\n    private static final Signature DOUBLE_TO_LONG_BITS =\n      TypeUtils.parseSignature(\"long doubleToLongBits(double)\");\n    private static final Signature FLOAT_TO_INT_BITS =\n      TypeUtils.parseSignature(\"int floatToIntBits(float)\");\n    private static final Signature TO_STRING =\n      TypeUtils.parseSignature(\"String toString()\");\n    private static final Signature APPEND_STRING =\n      TypeUtils.parseSignature(\"StringBuffer append(String)\");\n    private static final Signature APPEND_INT =\n      TypeUtils.parseSignature(\"StringBuffer append(int)\");\n    private static final Signature APPEND_DOUBLE =\n      TypeUtils.parseSignature(\"StringBuffer append(double)\");\n    private static final Signature APPEND_FLOAT =\n      TypeUtils.parseSignature(\"StringBuffer append(float)\");\n    private static final Signature APPEND_CHAR =\n      TypeUtils.parseSignature(\"StringBuffer append(char)\");\n    private static final Signature APPEND_LONG =\n      TypeUtils.parseSignature(\"StringBuffer append(long)\");\n    private static final Signature APPEND_BOOLEAN =\n      TypeUtils.parseSignature(\"StringBuffer append(boolean)\");\n    private static final Signature LENGTH =\n      TypeUtils.parseSignature(\"int length()\");\n    private static final Signature SET_LENGTH =\n      TypeUtils.parseSignature(\"void setLength(int)\");\n    private static final Signature GET_DECLARED_METHOD =\n      TypeUtils.parseSignature(\"java.lang.reflect.Method getDeclaredMethod(String, Class[])\");\n\n\n\n    public static final ArrayDelimiters DEFAULT_DELIMITERS = new ArrayDelimiters(\"{\", \", \", \"}\");\n\n    private EmitUtils() {\n    }\n\n    public static void factory_method(ClassEmitter ce, Signature sig) {\n        CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, sig, null);\n        e.new_instance_this();\n        e.dup();\n        e.load_args();\n        e.invoke_constructor_this(TypeUtils.parseConstructor(sig.getArgumentTypes()));\n        e.return_value();\n        e.end_method();\n    }\n\n    public static void null_constructor(ClassEmitter ce) {\n        CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, CSTRUCT_NULL, null);\n        e.load_this();\n        e.super_invoke_constructor();\n        e.return_value();\n        e.end_method();\n    }\n\n    /**\n     * Process an array on the stack. Assumes the top item on the stack\n     * is an array of the specified type. For each element in the array,\n     * puts the element on the stack and triggers the callback.\n     * @param type the type of the array (type.isArray() must be true)\n     * @param callback the callback triggered for each element\n     */\n    public static void process_array(CodeEmitter e, Type type, ProcessArrayCallback callback) {\n        Type componentType = TypeUtils.getComponentType(type);\n        Local array = e.make_local();\n        Local loopvar = e.make_local(Type.INT_TYPE);\n        Label loopbody = e.make_label();\n        Label checkloop = e.make_label();\n        e.store_local(array);\n        e.push(0);\n        e.store_local(loopvar);\n        e.goTo(checkloop);\n\n        e.mark(loopbody);\n        e.load_local(array);\n        e.load_local(loopvar);\n        e.array_load(componentType);\n        callback.processElement(componentType);\n        e.iinc(loopvar, 1);\n\n        e.mark(checkloop);\n        e.load_local(loopvar);\n        e.load_local(array);\n        e.arraylength();\n        e.if_icmp(CodeEmitter.LT, loopbody);\n    }\n\n    /**\n     * Process two arrays on the stack in parallel. Assumes the top two items on the stack\n     * are arrays of the specified class. The arrays must be the same length. For each pair\n     * of elements in the arrays, puts the pair on the stack and triggers the callback.\n     * @param type the type of the arrays (type.isArray() must be true)\n     * @param callback the callback triggered for each pair of elements\n     */\n    public static void process_arrays(CodeEmitter e, Type type, ProcessArrayCallback callback) {\n        Type componentType = TypeUtils.getComponentType(type);\n        Local array1 = e.make_local();\n        Local array2 = e.make_local();\n        Local loopvar = e.make_local(Type.INT_TYPE);\n        Label loopbody = e.make_label();\n        Label checkloop = e.make_label();\n        e.store_local(array1);\n        e.store_local(array2);\n        e.push(0);\n        e.store_local(loopvar);\n        e.goTo(checkloop);\n\n        e.mark(loopbody);\n        e.load_local(array1);\n        e.load_local(loopvar);\n        e.array_load(componentType);\n        e.load_local(array2);\n        e.load_local(loopvar);\n        e.array_load(componentType);\n        callback.processElement(componentType);\n        e.iinc(loopvar, 1);\n\n        e.mark(checkloop);\n        e.load_local(loopvar);\n        e.load_local(array1);\n        e.arraylength();\n        e.if_icmp(CodeEmitter.LT, loopbody);\n    }\n\n    public static void string_switch(CodeEmitter e, String[] strings, int switchStyle, ObjectSwitchCallback callback) {\n        try {\n            switch (switchStyle) {\n            case Constants.SWITCH_STYLE_TRIE:\n                string_switch_trie(e, strings, callback);\n                break;\n            case Constants.SWITCH_STYLE_HASH:\n                string_switch_hash(e, strings, callback, false);\n                break;\n            case Constants.SWITCH_STYLE_HASHONLY:\n                string_switch_hash(e, strings, callback, true);\n                break;\n            default:\n                throw new IllegalArgumentException(\"unknown switch style \" + switchStyle);\n            }\n        } catch (RuntimeException | Error ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new CodeGenerationException(ex);\n        }\n    }\n\n    private static void string_switch_trie(final CodeEmitter e,\n                                           String[] strings,\n                                           final ObjectSwitchCallback callback) throws Exception {\n        final Label def = e.make_label();\n        final Label end = e.make_label();\n        final Map buckets = CollectionUtils.bucket(Arrays.asList(strings), value -> ((String)value).length());\n        e.dup();\n        e.invoke_virtual(Constants.TYPE_STRING, STRING_LENGTH);\n        e.process_switch(getSwitchKeys(buckets), new ProcessSwitchCallback() {\n                @Override\n                public void processCase(int key, Label ignore_end) throws Exception {\n                    List bucket = (List)buckets.get(key);\n                    stringSwitchHelper(e, bucket, callback, def, end, 0);\n                }\n                @Override\n                public void processDefault() {\n                    e.goTo(def);\n                }\n            });\n        e.mark(def);\n        e.pop();\n        callback.processDefault();\n        e.mark(end);\n    }\n\n    private static void stringSwitchHelper(final CodeEmitter e,\n                                           List strings,\n                                           final ObjectSwitchCallback callback,\n                                           final Label def,\n                                           final Label end,\n                                           final int index) throws Exception {\n        final int len = ((String)strings.get(0)).length();\n        final Map buckets = CollectionUtils.bucket(strings, value -> ((String)value).charAt(index));\n        e.dup();\n        e.push(index);\n        e.invoke_virtual(Constants.TYPE_STRING, STRING_CHAR_AT);\n        e.process_switch(getSwitchKeys(buckets), new ProcessSwitchCallback() {\n                @Override\n                public void processCase(int key, Label ignore_end) throws Exception {\n                    List bucket = (List)buckets.get(key);\n                    if (index + 1 == len) {\n                        e.pop();\n                        callback.processCase(bucket.get(0), end);\n                    } else {\n                        stringSwitchHelper(e, bucket, callback, def, end, index + 1);\n                    }\n                }\n                @Override\n                public void processDefault() {\n                    e.goTo(def);\n                }\n            });\n    }\n\n    static int[] getSwitchKeys(Map buckets) {\n        int[] keys = new int[buckets.size()];\n        int index = 0;\n        for (Iterator it = buckets.keySet().iterator(); it.hasNext();) {\n            keys[index++] = ((Integer)it.next());\n        }\n        Arrays.sort(keys);\n        return keys;\n    }\n\n    private static void string_switch_hash(final CodeEmitter e,\n                                           final String[] strings,\n                                           final ObjectSwitchCallback callback,\n                                           final boolean skipEquals) throws Exception {\n        final Map buckets = CollectionUtils.bucket(Arrays.asList(strings), value -> value.hashCode());\n        final Label def = e.make_label();\n        final Label end = e.make_label();\n        e.dup();\n        e.invoke_virtual(Constants.TYPE_OBJECT, HASH_CODE);\n        e.process_switch(getSwitchKeys(buckets), new ProcessSwitchCallback() {\n            @Override\n            public void processCase(int key, Label ignore_end) throws Exception {\n                List bucket = (List)buckets.get(key);\n                Label next = null;\n                if (skipEquals && bucket.size() == 1) {\n                    if (skipEquals) {\n\t\t\t\t\t\te.pop();\n\t\t\t\t\t}\n                    callback.processCase(bucket.get(0), end);\n                } else {\n                    for (Iterator it = bucket.iterator(); it.hasNext();) {\n                        String string = (String)it.next();\n                        if (next != null) {\n                            e.mark(next);\n                        }\n                        if (it.hasNext()) {\n                            e.dup();\n                        }\n                        e.push(string);\n                        e.invoke_virtual(Constants.TYPE_OBJECT, EQUALS);\n                        if (it.hasNext()) {\n                            e.if_jump(CodeEmitter.EQ, next = e.make_label());\n                            e.pop();\n                        } else {\n                            e.if_jump(CodeEmitter.EQ, def);\n                        }\n                        callback.processCase(string, end);\n                    }\n                }\n            }\n            @Override\n            public void processDefault() {\n                e.pop();\n            }\n        });\n        e.mark(def);\n        callback.processDefault();\n        e.mark(end);\n    }\n\n    public static void load_class_this(CodeEmitter e) {\n        load_class_helper(e, e.getClassEmitter().getClassType());\n    }\n\n    public static void load_class(CodeEmitter e, Type type) {\n        if (TypeUtils.isPrimitive(type)) {\n            if (type == Type.VOID_TYPE) {\n                throw new IllegalArgumentException(\"cannot load void type\");\n            }\n            e.getstatic(TypeUtils.getBoxedType(type), \"TYPE\", Constants.TYPE_CLASS);\n        } else {\n            load_class_helper(e, type);\n        }\n    }\n\n    private static void load_class_helper(CodeEmitter e, final Type type) {\n        if (e.isStaticHook()) {\n            // have to fall back on non-optimized load\n            e.push(TypeUtils.emulateClassGetName(type));\n            e.invoke_static(Constants.TYPE_CLASS, FOR_NAME);\n        } else {\n            ClassEmitter ce = e.getClassEmitter();\n            String typeName = TypeUtils.emulateClassGetName(type);\n\n            // TODO: can end up with duplicated field names when using chained transformers; incorporate static hook # somehow\n            String fieldName = \"CGLIB$load_class$\" + TypeUtils.escapeType(typeName);\n            if (!ce.isFieldDeclared(fieldName)) {\n                ce.declare_field(Constants.PRIVATE_FINAL_STATIC, fieldName, Constants.TYPE_CLASS, null);\n                CodeEmitter hook = ce.getStaticHook();\n                hook.push(typeName);\n                hook.invoke_static(Constants.TYPE_CLASS, FOR_NAME);\n                hook.putstatic(ce.getClassType(), fieldName, Constants.TYPE_CLASS);\n            }\n            e.getfield(fieldName);\n        }\n    }\n\n    public static void push_array(CodeEmitter e, Object[] array) {\n        e.push(array.length);\n        e.newarray(Type.getType(remapComponentType(array.getClass().getComponentType())));\n        for (int i = 0; i < array.length; i++) {\n            e.dup();\n            e.push(i);\n            push_object(e, array[i]);\n            e.aastore();\n        }\n    }\n\n    private static Class remapComponentType(Class componentType) {\n        if (componentType.equals(Type.class)) {\n\t\t\treturn Class.class;\n\t\t}\n        return componentType;\n    }\n\n    public static void push_object(CodeEmitter e, Object obj) {\n        if (obj == null) {\n            e.aconst_null();\n        } else {\n            if (obj.getClass().isArray()) {\n                push_array(e, (Object[]) obj);\n            } else if (obj instanceof String text) {\n                e.push(text);\n            } else if (obj instanceof Type type) {\n                load_class(e, type);\n            } else if (obj instanceof Class<?> clazz) {\n                load_class(e, Type.getType(clazz));\n            } else if (obj instanceof BigInteger) {\n                e.new_instance(Constants.TYPE_BIG_INTEGER);\n                e.dup();\n                e.push(obj.toString());\n                e.invoke_constructor(Constants.TYPE_BIG_INTEGER);\n            } else if (obj instanceof BigDecimal) {\n                e.new_instance(Constants.TYPE_BIG_DECIMAL);\n                e.dup();\n                e.push(obj.toString());\n                e.invoke_constructor(Constants.TYPE_BIG_DECIMAL);\n            } else {\n                throw new IllegalArgumentException(\"unknown type: \" + obj.getClass());\n            }\n        }\n    }\n\n    /**\n     * @deprecated use {@link #hash_code(CodeEmitter, Type, int, CustomizerRegistry)} instead\n     */\n    @Deprecated\n    public static void hash_code(CodeEmitter e, Type type, int multiplier, final Customizer customizer) {\n        hash_code(e, type, multiplier, CustomizerRegistry.singleton(customizer));\n    }\n\n    public static void hash_code(CodeEmitter e, Type type, int multiplier, final CustomizerRegistry registry) {\n        if (TypeUtils.isArray(type)) {\n            hash_array(e, type, multiplier, registry);\n        } else {\n            e.swap(Type.INT_TYPE, type);\n            e.push(multiplier);\n            e.math(CodeEmitter.MUL, Type.INT_TYPE);\n            e.swap(type, Type.INT_TYPE);\n            if (TypeUtils.isPrimitive(type)) {\n                hash_primitive(e, type);\n            } else {\n                hash_object(e, type, registry);\n            }\n            e.math(CodeEmitter.ADD, Type.INT_TYPE);\n        }\n    }\n\n    private static void hash_array(final CodeEmitter e, Type type, final int multiplier, final CustomizerRegistry registry) {\n        Label skip = e.make_label();\n        Label end = e.make_label();\n        e.dup();\n        e.ifnull(skip);\n        EmitUtils.process_array(e, type, type1 -> hash_code(e, type1, multiplier, registry));\n        e.goTo(end);\n        e.mark(skip);\n        e.pop();\n        e.mark(end);\n    }\n\n    private static void hash_object(CodeEmitter e, Type type, CustomizerRegistry registry) {\n        // (f == null) ? 0 : f.hashCode();\n        Label skip = e.make_label();\n        Label end = e.make_label();\n        e.dup();\n        e.ifnull(skip);\n        boolean customHashCode = false;\n        for (HashCodeCustomizer customizer : registry.get(HashCodeCustomizer.class)) {\n            if (customizer.customize(e, type)) {\n                customHashCode = true;\n                break;\n            }\n        }\n        if (!customHashCode) {\n            for (Customizer customizer : registry.get(Customizer.class)) {\n                customizer.customize(e, type);\n            }\n            e.invoke_virtual(Constants.TYPE_OBJECT, HASH_CODE);\n        }\n        e.goTo(end);\n        e.mark(skip);\n        e.pop();\n        e.push(0);\n        e.mark(end);\n    }\n\n    private static void hash_primitive(CodeEmitter e, Type type) {\n        switch (type.getSort()) {\n        case Type.BOOLEAN:\n            // f ? 0 : 1\n            e.push(1);\n            e.math(CodeEmitter.XOR, Type.INT_TYPE);\n            break;\n        case Type.FLOAT:\n            // Float.floatToIntBits(f)\n            e.invoke_static(Constants.TYPE_FLOAT, FLOAT_TO_INT_BITS);\n            break;\n        case Type.DOUBLE:\n            // Double.doubleToLongBits(f), hash_code(Long.TYPE)\n            e.invoke_static(Constants.TYPE_DOUBLE, DOUBLE_TO_LONG_BITS);\n            // fall through\n        case Type.LONG:\n            hash_long(e);\n        }\n    }\n\n    private static void hash_long(CodeEmitter e) {\n        // (int)(f ^ (f >>> 32))\n        e.dup2();\n        e.push(32);\n        e.math(CodeEmitter.USHR, Type.LONG_TYPE);\n        e.math(CodeEmitter.XOR, Type.LONG_TYPE);\n        e.cast_numeric(Type.LONG_TYPE, Type.INT_TYPE);\n    }\n\n//     public static void not_equals(CodeEmitter e, Type type, Label notEquals) {\n//         not_equals(e, type, notEquals, null);\n//     }\n\n    /**\n     * @deprecated use {@link #not_equals(CodeEmitter, Type, Label, CustomizerRegistry)} instead\n     */\n    @Deprecated\n    public static void not_equals(CodeEmitter e, Type type, final Label notEquals, final Customizer customizer) {\n        not_equals(e, type, notEquals, CustomizerRegistry.singleton(customizer));\n    }\n\n    /**\n     * Branches to the specified label if the top two items on the stack\n     * are not equal. The items must both be of the specified\n     * class. Equality is determined by comparing primitive values\n     * directly and by invoking the <code>equals</code> method for\n     * Objects. Arrays are recursively processed in the same manner.\n     */\n    public static void not_equals(final CodeEmitter e, Type type, final Label notEquals, final CustomizerRegistry registry) {\n        (new ProcessArrayCallback() {\n            @Override\n            public void processElement(Type type) {\n                not_equals_helper(e, type, notEquals, registry, this);\n            }\n        }).processElement(type);\n    }\n\n    private static void not_equals_helper(CodeEmitter e,\n                                          Type type,\n                                          Label notEquals,\n                                          CustomizerRegistry registry,\n                                          ProcessArrayCallback callback) {\n        if (TypeUtils.isPrimitive(type)) {\n            e.if_cmp(type, CodeEmitter.NE, notEquals);\n        } else {\n            Label end = e.make_label();\n            nullcmp(e, notEquals, end);\n            if (TypeUtils.isArray(type)) {\n                Label checkContents = e.make_label();\n                e.dup2();\n                e.arraylength();\n                e.swap();\n                e.arraylength();\n                e.if_icmp(CodeEmitter.EQ, checkContents);\n                e.pop2();\n                e.goTo(notEquals);\n                e.mark(checkContents);\n                EmitUtils.process_arrays(e, type, callback);\n            } else {\n                List<Customizer> customizers = registry.get(Customizer.class);\n                if (!customizers.isEmpty()) {\n                    for (Customizer customizer : customizers) {\n                        customizer.customize(e, type);\n                    }\n                    e.swap();\n                    for (Customizer customizer : customizers) {\n                        customizer.customize(e, type);\n                    }\n                }\n                e.invoke_virtual(Constants.TYPE_OBJECT, EQUALS);\n                e.if_jump(CodeEmitter.EQ, notEquals);\n            }\n            e.mark(end);\n        }\n    }\n\n    /**\n     * If both objects on the top of the stack are non-null, does nothing.\n     * If one is null, or both are null, both are popped off and execution\n     * branches to the respective label.\n     * @param oneNull label to branch to if only one of the objects is null\n     * @param bothNull label to branch to if both of the objects are null\n     */\n    private static void nullcmp(CodeEmitter e, Label oneNull, Label bothNull) {\n        e.dup2();\n        Label nonNull = e.make_label();\n        Label oneNullHelper = e.make_label();\n        Label end = e.make_label();\n        e.ifnonnull(nonNull);\n        e.ifnonnull(oneNullHelper);\n        e.pop2();\n        e.goTo(bothNull);\n\n        e.mark(nonNull);\n        e.ifnull(oneNullHelper);\n        e.goTo(end);\n\n        e.mark(oneNullHelper);\n        e.pop2();\n        e.goTo(oneNull);\n\n        e.mark(end);\n    }\n\n    /*\n    public static void to_string(CodeEmitter e,\n                                 Type type,\n                                 ArrayDelimiters delims,\n                                 CustomizerRegistry registry) {\n        e.new_instance(Constants.TYPE_STRING_BUFFER);\n        e.dup();\n        e.invoke_constructor(Constants.TYPE_STRING_BUFFER);\n        e.swap();\n        append_string(e, type, delims, registry);\n        e.invoke_virtual(Constants.TYPE_STRING_BUFFER, TO_STRING);\n    }\n    */\n\n    /**\n      * @deprecated use {@link #append_string(CodeEmitter, Type, ArrayDelimiters, CustomizerRegistry)} instead\n      */\n    @Deprecated\n    public static void append_string(final CodeEmitter e,\n                                     Type type,\n                                     final ArrayDelimiters delims,\n                                     final Customizer customizer) {\n        append_string(e, type, delims, CustomizerRegistry.singleton(customizer));\n    }\n\n    public static void append_string(final CodeEmitter e,\n                                     Type type,\n                                     final ArrayDelimiters delims,\n                                     final CustomizerRegistry registry) {\n        final ArrayDelimiters d = (delims != null) ? delims : DEFAULT_DELIMITERS;\n        ProcessArrayCallback callback = new ProcessArrayCallback() {\n            @Override\n            public void processElement(Type type) {\n                append_string_helper(e, type, d, registry, this);\n                e.push(d.inside);\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n            }\n        };\n        append_string_helper(e, type, d, registry, callback);\n    }\n\n    private static void append_string_helper(CodeEmitter e,\n                                             Type type,\n                                             ArrayDelimiters delims,\n                                             CustomizerRegistry registry,\n                                             ProcessArrayCallback callback) {\n        Label skip = e.make_label();\n        Label end = e.make_label();\n        if (TypeUtils.isPrimitive(type)) {\n            switch (type.getSort()) {\n            case Type.INT:\n            case Type.SHORT:\n            case Type.BYTE:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_INT);\n                break;\n            case Type.DOUBLE:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_DOUBLE);\n                break;\n            case Type.FLOAT:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_FLOAT);\n                break;\n            case Type.LONG:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_LONG);\n                break;\n            case Type.BOOLEAN:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_BOOLEAN);\n                break;\n            case Type.CHAR:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_CHAR);\n                break;\n            }\n        } else if (TypeUtils.isArray(type)) {\n            e.dup();\n            e.ifnull(skip);\n            e.swap();\n            if (delims != null && delims.before != null && !\"\".equals(delims.before)) {\n                e.push(delims.before);\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n                e.swap();\n            }\n            EmitUtils.process_array(e, type, callback);\n            shrinkStringBuffer(e, 2);\n            if (delims != null && delims.after != null && !\"\".equals(delims.after)) {\n                e.push(delims.after);\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n            }\n        } else {\n            e.dup();\n            e.ifnull(skip);\n            for (Customizer customizer : registry.get(Customizer.class)) {\n                customizer.customize(e, type);\n            }\n            e.invoke_virtual(Constants.TYPE_OBJECT, TO_STRING);\n            e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n        }\n        e.goTo(end);\n        e.mark(skip);\n        e.pop();\n        e.push(\"null\");\n        e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n        e.mark(end);\n    }\n\n    private static void shrinkStringBuffer(CodeEmitter e, int amt) {\n        e.dup();\n        e.dup();\n        e.invoke_virtual(Constants.TYPE_STRING_BUFFER, LENGTH);\n        e.push(amt);\n        e.math(CodeEmitter.SUB, Type.INT_TYPE);\n        e.invoke_virtual(Constants.TYPE_STRING_BUFFER, SET_LENGTH);\n    }\n\n    public static class ArrayDelimiters {\n        private String before;\n        private String inside;\n        private String after;\n\n        public ArrayDelimiters(String before, String inside, String after) {\n            this.before = before;\n            this.inside = inside;\n            this.after = after;\n        }\n    }\n\n    public static void load_method(CodeEmitter e, MethodInfo method) {\n        load_class(e, method.getClassInfo().getType());\n        e.push(method.getSignature().getName());\n        push_object(e, method.getSignature().getArgumentTypes());\n        e.invoke_virtual(Constants.TYPE_CLASS, GET_DECLARED_METHOD);\n    }\n\n    private interface ParameterTyper {\n        Type[] getParameterTypes(MethodInfo member);\n    }\n\n    public static void method_switch(CodeEmitter e,\n                                     List methods,\n                                     ObjectSwitchCallback callback) {\n        member_switch_helper(e, methods, callback, true);\n    }\n\n    public static void constructor_switch(CodeEmitter e,\n                                          List constructors,\n                                          ObjectSwitchCallback callback) {\n        member_switch_helper(e, constructors, callback, false);\n    }\n\n    private static void member_switch_helper(final CodeEmitter e,\n                                             List members,\n                                             final ObjectSwitchCallback callback,\n                                             boolean useName) {\n        try {\n            final Map cache = new HashMap();\n            final ParameterTyper cached = member -> {\n                Type[] types = (Type[]) cache.get(member);\n                if (types == null) {\n                    cache.put(member, types = member.getSignature().getArgumentTypes());\n                }\n                return types;\n            };\n            final Label def = e.make_label();\n            final Label end = e.make_label();\n            if (useName) {\n                e.swap();\n                final Map buckets = CollectionUtils.bucket(members, value -> ((MethodInfo)value).getSignature().getName());\n                String[] names = (String[])buckets.keySet().toArray(new String[buckets.size()]);\n                EmitUtils.string_switch(e, names, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\n                        @Override\n                        public void processCase(Object key, Label dontUseEnd) throws Exception {\n                            member_helper_size(e, (List)buckets.get(key), callback, cached, def, end);\n                        }\n                        @Override\n                        public void processDefault() throws Exception {\n                            e.goTo(def);\n                        }\n                    });\n            } else {\n                member_helper_size(e, members, callback, cached, def, end);\n            }\n            e.mark(def);\n            e.pop();\n            callback.processDefault();\n            e.mark(end);\n        } catch (RuntimeException | Error ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new CodeGenerationException(ex);\n        }\n    }\n\n    private static void member_helper_size(final CodeEmitter e,\n                                           List members,\n                                           final ObjectSwitchCallback callback,\n                                           final ParameterTyper typer,\n                                           final Label def,\n                                           final Label end) throws Exception {\n        final Map buckets = CollectionUtils.bucket(members, value -> typer.getParameterTypes((MethodInfo)value).length);\n        e.dup();\n        e.arraylength();\n        e.process_switch(EmitUtils.getSwitchKeys(buckets), new ProcessSwitchCallback() {\n            @Override\n            public void processCase(int key, Label dontUseEnd) throws Exception {\n                List bucket = (List)buckets.get(key);\n                member_helper_type(e, bucket, callback, typer, def, end, new BitSet());\n            }\n            @Override\n            public void processDefault() throws Exception {\n                e.goTo(def);\n            }\n        });\n    }\n\n    private static void member_helper_type(final CodeEmitter e,\n                                           List members,\n                                           final ObjectSwitchCallback callback,\n                                           final ParameterTyper typer,\n                                           final Label def,\n                                           final Label end,\n                                           final BitSet checked) throws Exception {\n        if (members.size() == 1) {\n            MethodInfo member = (MethodInfo)members.get(0);\n            Type[] types = typer.getParameterTypes(member);\n            // need to check classes that have not already been checked via switches\n            for (int i = 0; i < types.length; i++) {\n                if (checked == null || !checked.get(i)) {\n                    e.dup();\n                    e.aaload(i);\n                    e.invoke_virtual(Constants.TYPE_CLASS, GET_NAME);\n                    e.push(TypeUtils.emulateClassGetName(types[i]));\n                    e.invoke_virtual(Constants.TYPE_OBJECT, EQUALS);\n                    e.if_jump(CodeEmitter.EQ, def);\n                }\n            }\n            e.pop();\n            callback.processCase(member, end);\n        } else {\n            // choose the index that has the best chance of uniquely identifying member\n            Type[] example = typer.getParameterTypes((MethodInfo)members.get(0));\n            Map buckets = null;\n            int index = -1;\n            for (int i = 0; i < example.length; i++) {\n                final int j = i;\n                Map test = CollectionUtils.bucket(members,\n                        value -> TypeUtils.emulateClassGetName(typer.getParameterTypes((MethodInfo)value)[j]));\n                if (buckets == null || test.size() > buckets.size()) {\n                    buckets = test;\n                    index = i;\n                }\n            }\n            if (buckets == null || buckets.size() == 1) {\n                // TODO: switch by returnType\n                // must have two methods with same name, types, and different return types\n                e.goTo(def);\n            } else {\n                checked.set(index);\n\n                e.dup();\n                e.aaload(index);\n                e.invoke_virtual(Constants.TYPE_CLASS, GET_NAME);\n\n                final Map fbuckets = buckets;\n                String[] names = (String[])buckets.keySet().toArray(new String[buckets.size()]);\n                EmitUtils.string_switch(e, names, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\n                    @Override\n                    public void processCase(Object key, Label dontUseEnd) throws Exception {\n                        member_helper_type(e, (List)fbuckets.get(key), callback, typer, def, end, checked);\n                    }\n                    @Override\n                    public void processDefault() throws Exception {\n                        e.goTo(def);\n                    }\n                });\n            }\n        }\n    }\n\n    public static void wrap_throwable(Block block, Type wrapper) {\n        CodeEmitter e = block.getCodeEmitter();\n        e.catch_exception(block, Constants.TYPE_THROWABLE);\n        e.new_instance(wrapper);\n        e.dup_x1();\n        e.swap();\n        e.invoke_constructor(wrapper, CSTRUCT_THROWABLE);\n        e.athrow();\n    }\n\n    public static void add_properties(ClassEmitter ce, String[] names, Type[] types) {\n        for (int i = 0; i < names.length; i++) {\n            String fieldName = \"$cglib_prop_\" + names[i];\n            ce.declare_field(Constants.ACC_PRIVATE, fieldName, types[i], null);\n            EmitUtils.add_property(ce, names[i], types[i], fieldName);\n        }\n    }\n\n    public static void add_property(ClassEmitter ce, String name, Type type, String fieldName) {\n        String property = TypeUtils.upperFirst(name);\n        CodeEmitter e;\n        e = ce.begin_method(Constants.ACC_PUBLIC,\n                            new Signature(\"get\" + property,\n                                          type,\n                                          Constants.TYPES_EMPTY),\n                            null);\n        e.load_this();\n        e.getfield(fieldName);\n        e.return_value();\n        e.end_method();\n\n        e = ce.begin_method(Constants.ACC_PUBLIC,\n                            new Signature(\"set\" + property,\n                                          Type.VOID_TYPE,\n                                          new Type[]{ type }),\n                            null);\n        e.load_this();\n        e.load_arg(0);\n        e.putfield(fieldName);\n        e.return_value();\n        e.end_method();\n    }\n\n    /* generates:\n       } catch (RuntimeException e) {\n         throw e;\n       } catch (Error e) {\n         throw e;\n       } catch (<DeclaredException> e) {\n         throw e;\n       } catch (Throwable e) {\n         throw new <Wrapper>(e);\n       }"
  },
  "org.springframework.cglib.core.EmitUtils#add_properties(ce,names,types)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ce",
      "names",
      "types"
    ],
    "position": {
      "column": 1,
      "line": 867
    },
    "return": "void",
    "signature": "public void add_properties(ClassEmitter ce, String[] names, Type[] types)",
    "source_code": "    public static void add_properties(ClassEmitter ce, String[] names, Type[] types) {\n        for (int i = 0; i < names.length; i++) {\n            String fieldName = \"$cglib_prop_\" + names[i];\n            ce.declare_field(Constants.ACC_PRIVATE, fieldName, types[i], null);\n            EmitUtils.add_property(ce, names[i], types[i], fieldName);\n        }\n    }"
  },
  "org.springframework.cglib.core.EmitUtils#add_property(ce,name,type,fieldName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ce",
      "name",
      "type",
      "fieldName"
    ],
    "position": {
      "column": 1,
      "line": 875
    },
    "return": "void",
    "signature": "public void add_property(ClassEmitter ce, String name, Type type, String fieldName)",
    "source_code": "    public static void add_property(ClassEmitter ce, String name, Type type, String fieldName) {\n        String property = TypeUtils.upperFirst(name);\n        CodeEmitter e;\n        e = ce.begin_method(Constants.ACC_PUBLIC,\n                            new Signature(\"get\" + property,\n                                          type,\n                                          Constants.TYPES_EMPTY),\n                            null);\n        e.load_this();\n        e.getfield(fieldName);\n        e.return_value();\n        e.end_method();\n\n        e = ce.begin_method(Constants.ACC_PUBLIC,\n                            new Signature(\"set\" + property,\n                                          Type.VOID_TYPE,\n                                          new Type[]{ type }),\n                            null);\n        e.load_this();\n        e.load_arg(0);\n        e.putfield(fieldName);\n        e.return_value();\n        e.end_method();\n    }"
  },
  "org.springframework.cglib.core.EmitUtils#append_string(e,type,delims,customizer)": {
    "change": "added",
    "deprecated": false,
    "doc": "    /**\n      * @deprecated use {@link #append_string(CodeEmitter, Type, ArrayDelimiters, CustomizerRegistry)} instead\n      */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "type",
      "delims",
      "customizer"
    ],
    "position": {
      "column": 1,
      "line": 599
    },
    "return": "void",
    "signature": "public void append_string(final CodeEmitter e,\n                                     Type type,\n                                     final ArrayDelimiters delims,\n                                     final Customizer customizer)",
    "source_code": "    public static void append_string(final CodeEmitter e,"
  },
  "org.springframework.cglib.core.EmitUtils#append_string(e,type,delims,registry)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "type",
      "delims",
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 606
    },
    "return": "void",
    "signature": "public void append_string(final CodeEmitter e,\n                                     Type type,\n                                     final ArrayDelimiters delims,\n                                     final CustomizerRegistry registry)",
    "source_code": "    public static void append_string(final CodeEmitter e,"
  },
  "org.springframework.cglib.core.EmitUtils#begin_method(e,method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 944
    },
    "return": "CodeEmitter",
    "signature": "public CodeEmitter begin_method(ClassEmitter e, MethodInfo method)",
    "source_code": "    public static CodeEmitter begin_method(ClassEmitter e, MethodInfo method) {\n        return begin_method(e, method, method.getModifiers());\n    }"
  },
  "org.springframework.cglib.core.EmitUtils#begin_method(e,method,access)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "method",
      "access"
    ],
    "position": {
      "column": 1,
      "line": 948
    },
    "return": "CodeEmitter",
    "signature": "public CodeEmitter begin_method(ClassEmitter e, MethodInfo method, int access)",
    "source_code": "    public static CodeEmitter begin_method(ClassEmitter e, MethodInfo method, int access) {\n        return e.begin_method(access,\n                              method.getSignature(),\n                              method.getExceptionTypes());\n    }"
  },
  "org.springframework.cglib.core.EmitUtils#constructor_switch(e,constructors,callback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "constructors",
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 722
    },
    "return": "void",
    "signature": "public void constructor_switch(CodeEmitter e,\n                                          List constructors,\n                                          ObjectSwitchCallback callback)",
    "source_code": "    public static void constructor_switch(CodeEmitter e,"
  },
  "org.springframework.cglib.core.EmitUtils#factory_method(ce,sig)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ce",
      "sig"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "void",
    "signature": "public void factory_method(ClassEmitter ce, Signature sig)",
    "source_code": "    public static void factory_method(ClassEmitter ce, Signature sig) {\n        CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, sig, null);\n        e.new_instance_this();\n        e.dup();\n        e.load_args();\n        e.invoke_constructor_this(TypeUtils.parseConstructor(sig.getArgumentTypes()));\n        e.return_value();\n        e.end_method();\n    }"
  },
  "org.springframework.cglib.core.EmitUtils#hash_code(e,type,multiplier,customizer)": {
    "change": "added",
    "deprecated": false,
    "doc": "    /**\n     * @deprecated use {@link #hash_code(CodeEmitter, Type, int, CustomizerRegistry)} instead\n     */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "type",
      "multiplier",
      "customizer"
    ],
    "position": {
      "column": 1,
      "line": 398
    },
    "return": "void",
    "signature": "public void hash_code(CodeEmitter e, Type type, int multiplier, final Customizer customizer)",
    "source_code": "    public static void hash_code(CodeEmitter e, Type type, int multiplier, final Customizer customizer) {\n        hash_code(e, type, multiplier, CustomizerRegistry.singleton(customizer));\n    }"
  },
  "org.springframework.cglib.core.EmitUtils#hash_code(e,type,multiplier,registry)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "type",
      "multiplier",
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 402
    },
    "return": "void",
    "signature": "public void hash_code(CodeEmitter e, Type type, int multiplier, final CustomizerRegistry registry)",
    "source_code": "    public static void hash_code(CodeEmitter e, Type type, int multiplier, final CustomizerRegistry registry) {\n        if (TypeUtils.isArray(type)) {\n            hash_array(e, type, multiplier, registry);\n        } else {\n            e.swap(Type.INT_TYPE, type);\n            e.push(multiplier);\n            e.math(CodeEmitter.MUL, Type.INT_TYPE);\n            e.swap(type, Type.INT_TYPE);\n            if (TypeUtils.isPrimitive(type)) {\n                hash_primitive(e, type);\n            } else {\n                hash_object(e, type, registry);\n            }\n            e.math(CodeEmitter.ADD, Type.INT_TYPE);\n        }\n    }"
  },
  "org.springframework.cglib.core.EmitUtils#load_class(e,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 315
    },
    "return": "void",
    "signature": "public void load_class(CodeEmitter e, Type type)",
    "source_code": "    public static void load_class(CodeEmitter e, Type type) {\n        if (TypeUtils.isPrimitive(type)) {\n            if (type == Type.VOID_TYPE) {\n                throw new IllegalArgumentException(\"cannot load void type\");\n            }\n            e.getstatic(TypeUtils.getBoxedType(type), \"TYPE\", Constants.TYPE_CLASS);\n        } else {\n            load_class_helper(e, type);\n        }\n    }"
  },
  "org.springframework.cglib.core.EmitUtils#load_class_this(e)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e"
    ],
    "position": {
      "column": 1,
      "line": 311
    },
    "return": "void",
    "signature": "public void load_class_this(CodeEmitter e)",
    "source_code": "    public static void load_class_this(CodeEmitter e) {\n        load_class_helper(e, e.getClassEmitter().getClassType());\n    }"
  },
  "org.springframework.cglib.core.EmitUtils#load_method(e,method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 705
    },
    "return": "void",
    "signature": "public void load_method(CodeEmitter e, MethodInfo method)",
    "source_code": "    public static void load_method(CodeEmitter e, MethodInfo method) {\n        load_class(e, method.getClassInfo().getType());\n        e.push(method.getSignature().getName());\n        push_object(e, method.getSignature().getArgumentTypes());\n        e.invoke_virtual(Constants.TYPE_CLASS, GET_DECLARED_METHOD);\n    }"
  },
  "org.springframework.cglib.core.EmitUtils#method_switch(e,methods,callback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "methods",
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 716
    },
    "return": "void",
    "signature": "public void method_switch(CodeEmitter e,\n                                     List methods,\n                                     ObjectSwitchCallback callback)",
    "source_code": "    public static void method_switch(CodeEmitter e,"
  },
  "org.springframework.cglib.core.EmitUtils#not_equals(e,type,notEquals,customizer)": {
    "change": "added",
    "deprecated": false,
    "doc": "    /**\n     * @deprecated use {@link #not_equals(CodeEmitter, Type, Label, CustomizerRegistry)} instead\n     */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "type",
      "notEquals",
      "customizer"
    ],
    "position": {
      "column": 1,
      "line": 494
    },
    "return": "void",
    "signature": "public void not_equals(CodeEmitter e, Type type, final Label notEquals, final Customizer customizer)",
    "source_code": "    public static void not_equals(CodeEmitter e, Type type, final Label notEquals, final Customizer customizer) {\n        not_equals(e, type, notEquals, CustomizerRegistry.singleton(customizer));\n    }"
  },
  "org.springframework.cglib.core.EmitUtils#not_equals(e,type,notEquals,registry)": {
    "change": "added",
    "deprecated": false,
    "doc": "    /**\n     * Branches to the specified label if the top two items on the stack\n     * are not equal. The items must both be of the specified\n     * class. Equality is determined by comparing primitive values\n     * directly and by invoking the <code>equals</code> method for\n     * Objects. Arrays are recursively processed in the same manner.\n     */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "type",
      "notEquals",
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 505
    },
    "return": "void",
    "signature": "public void not_equals(final CodeEmitter e, Type type, final Label notEquals, final CustomizerRegistry registry)",
    "source_code": "    public static void not_equals(final CodeEmitter e, Type type, final Label notEquals, final CustomizerRegistry registry) {\n        (new ProcessArrayCallback() {\n            @Override\n            public void processElement(Type type) {\n                not_equals_helper(e, type, notEquals, registry, this);\n            }\n        }).processElement(type);\n    }"
  },
  "org.springframework.cglib.core.EmitUtils#null_constructor(ce)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ce"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void null_constructor(ClassEmitter ce)",
    "source_code": "    public static void null_constructor(ClassEmitter ce) {\n        CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, CSTRUCT_NULL, null);\n        e.load_this();\n        e.super_invoke_constructor();\n        e.return_value();\n        e.end_method();\n    }"
  },
  "org.springframework.cglib.core.EmitUtils#processCase(key,dontUseEnd)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "dontUseEnd"
    ],
    "position": {
      "column": 1,
      "line": 845
    },
    "return": "void",
    "signature": "public void processCase(Object key, Label dontUseEnd)",
    "source_code": "                    public void processCase(Object key, Label dontUseEnd) throws Exception {\n                        member_helper_type(e, (List)fbuckets.get(key), callback, typer, def, end, checked);\n                    }"
  },
  "org.springframework.cglib.core.EmitUtils#processCase(key,ignore_end)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "ignore_end"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "void",
    "signature": "public void processCase(int key, Label ignore_end)",
    "source_code": "            public void processCase(int key, Label ignore_end) throws Exception {\n                List bucket = (List)buckets.get(key);\n                Label next = null;\n                if (skipEquals && bucket.size() == 1) {\n                    if (skipEquals) {\n\t\t\t\t\t\te.pop();\n\t\t\t\t\t}\n                    callback.processCase(bucket.get(0), end);\n                } else {\n                    for (Iterator it = bucket.iterator(); it.hasNext();) {\n                        String string = (String)it.next();\n                        if (next != null) {\n                            e.mark(next);\n                        }\n                        if (it.hasNext()) {\n                            e.dup();\n                        }\n                        e.push(string);\n                        e.invoke_virtual(Constants.TYPE_OBJECT, EQUALS);\n                        if (it.hasNext()) {\n                            e.if_jump(CodeEmitter.EQ, next = e.make_label());\n                            e.pop();\n                        } else {\n                            e.if_jump(CodeEmitter.EQ, def);\n                        }\n                        callback.processCase(string, end);\n                    }\n                }\n            }"
  },
  "org.springframework.cglib.core.EmitUtils#processDefault()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 849
    },
    "return": "void",
    "signature": "public void processDefault()",
    "source_code": "                    public void processDefault() throws Exception {\n                        e.goTo(def);\n                    }"
  },
  "org.springframework.cglib.core.EmitUtils#processElement(type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 613
    },
    "return": "void",
    "signature": "public void processElement(Type type)",
    "source_code": "            public void processElement(Type type) {\n                append_string_helper(e, type, d, registry, this);\n                e.push(d.inside);\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n            }"
  },
  "org.springframework.cglib.core.EmitUtils#process_array(e,type,callback)": {
    "change": "added",
    "deprecated": false,
    "doc": "    /**\n     * Process an array on the stack. Assumes the top item on the stack\n     * is an array of the specified type. For each element in the array,\n     * puts the element on the stack and triggers the callback.\n     * @param type the type of the array (type.isArray() must be true)\n     * @param callback the callback triggered for each element\n     */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "type",
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "void",
    "signature": "public void process_array(CodeEmitter e, Type type, ProcessArrayCallback callback)",
    "source_code": "    public static void process_array(CodeEmitter e, Type type, ProcessArrayCallback callback) {\n        Type componentType = TypeUtils.getComponentType(type);\n        Local array = e.make_local();\n        Local loopvar = e.make_local(Type.INT_TYPE);\n        Label loopbody = e.make_label();\n        Label checkloop = e.make_label();\n        e.store_local(array);\n        e.push(0);\n        e.store_local(loopvar);\n        e.goTo(checkloop);\n\n        e.mark(loopbody);\n        e.load_local(array);\n        e.load_local(loopvar);\n        e.array_load(componentType);\n        callback.processElement(componentType);\n        e.iinc(loopvar, 1);\n\n        e.mark(checkloop);\n        e.load_local(loopvar);\n        e.load_local(array);\n        e.arraylength();\n        e.if_icmp(CodeEmitter.LT, loopbody);\n    }"
  },
  "org.springframework.cglib.core.EmitUtils#process_arrays(e,type,callback)": {
    "change": "added",
    "deprecated": false,
    "doc": "    /**\n     * Process two arrays on the stack in parallel. Assumes the top two items on the stack\n     * are arrays of the specified class. The arrays must be the same length. For each pair\n     * of elements in the arrays, puts the pair on the stack and triggers the callback.\n     * @param type the type of the arrays (type.isArray() must be true)\n     * @param callback the callback triggered for each pair of elements\n     */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "type",
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "void",
    "signature": "public void process_arrays(CodeEmitter e, Type type, ProcessArrayCallback callback)",
    "source_code": "    public static void process_arrays(CodeEmitter e, Type type, ProcessArrayCallback callback) {\n        Type componentType = TypeUtils.getComponentType(type);\n        Local array1 = e.make_local();\n        Local array2 = e.make_local();\n        Local loopvar = e.make_local(Type.INT_TYPE);\n        Label loopbody = e.make_label();\n        Label checkloop = e.make_label();\n        e.store_local(array1);\n        e.store_local(array2);\n        e.push(0);\n        e.store_local(loopvar);\n        e.goTo(checkloop);\n\n        e.mark(loopbody);\n        e.load_local(array1);\n        e.load_local(loopvar);\n        e.array_load(componentType);\n        e.load_local(array2);\n        e.load_local(loopvar);\n        e.array_load(componentType);\n        callback.processElement(componentType);\n        e.iinc(loopvar, 1);\n\n        e.mark(checkloop);\n        e.load_local(loopvar);\n        e.load_local(array1);\n        e.arraylength();\n        e.if_icmp(CodeEmitter.LT, loopbody);\n    }"
  },
  "org.springframework.cglib.core.EmitUtils#push_array(e,array)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "array"
    ],
    "position": {
      "column": 1,
      "line": 348
    },
    "return": "void",
    "signature": "public void push_array(CodeEmitter e, Object[] array)",
    "source_code": "    public static void push_array(CodeEmitter e, Object[] array) {\n        e.push(array.length);\n        e.newarray(Type.getType(remapComponentType(array.getClass().getComponentType())));\n        for (int i = 0; i < array.length; i++) {\n            e.dup();\n            e.push(i);\n            push_object(e, array[i]);\n            e.aastore();\n        }\n    }"
  },
  "org.springframework.cglib.core.EmitUtils#push_object(e,obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 366
    },
    "return": "void",
    "signature": "public void push_object(CodeEmitter e, Object obj)",
    "source_code": "    public static void push_object(CodeEmitter e, Object obj) {\n        if (obj == null) {\n            e.aconst_null();\n        } else {\n            if (obj.getClass().isArray()) {\n                push_array(e, (Object[]) obj);\n            } else if (obj instanceof String text) {\n                e.push(text);\n            } else if (obj instanceof Type type) {\n                load_class(e, type);\n            } else if (obj instanceof Class<?> clazz) {\n                load_class(e, Type.getType(clazz));\n            } else if (obj instanceof BigInteger) {\n                e.new_instance(Constants.TYPE_BIG_INTEGER);\n                e.dup();\n                e.push(obj.toString());\n                e.invoke_constructor(Constants.TYPE_BIG_INTEGER);\n            } else if (obj instanceof BigDecimal) {\n                e.new_instance(Constants.TYPE_BIG_DECIMAL);\n                e.dup();\n                e.push(obj.toString());\n                e.invoke_constructor(Constants.TYPE_BIG_DECIMAL);\n            } else {\n                throw new IllegalArgumentException(\"unknown type: \" + obj.getClass());\n            }\n        }\n    }"
  },
  "org.springframework.cglib.core.EmitUtils#string_switch(e,strings,switchStyle,callback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "strings",
      "switchStyle",
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "void",
    "signature": "public void string_switch(CodeEmitter e, String[] strings, int switchStyle, ObjectSwitchCallback callback)",
    "source_code": "    public static void string_switch(CodeEmitter e, String[] strings, int switchStyle, ObjectSwitchCallback callback) {\n        try {\n            switch (switchStyle) {\n            case Constants.SWITCH_STYLE_TRIE:\n                string_switch_trie(e, strings, callback);\n                break;\n            case Constants.SWITCH_STYLE_HASH:\n                string_switch_hash(e, strings, callback, false);\n                break;\n            case Constants.SWITCH_STYLE_HASHONLY:\n                string_switch_hash(e, strings, callback, true);\n                break;\n            default:\n                throw new IllegalArgumentException(\"unknown switch style \" + switchStyle);\n            }\n        } catch (RuntimeException | Error ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new CodeGenerationException(ex);\n        }\n    }"
  },
  "org.springframework.cglib.core.EmitUtils#to_string(e,type,delims,registry)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "type",
      "delims",
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 582
    },
    "return": "void",
    "signature": "public void to_string(CodeEmitter e,\n                                 Type type,\n                                 ArrayDelimiters delims,\n                                 CustomizerRegistry registry)",
    "source_code": "    public static void to_string(CodeEmitter e,"
  },
  "org.springframework.cglib.core.EmitUtils#wrap_throwable(block,wrapper)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "block",
      "wrapper"
    ],
    "position": {
      "column": 1,
      "line": 857
    },
    "return": "void",
    "signature": "public void wrap_throwable(Block block, Type wrapper)",
    "source_code": "    public static void wrap_throwable(Block block, Type wrapper) {\n        CodeEmitter e = block.getCodeEmitter();\n        e.catch_exception(block, Constants.TYPE_THROWABLE);\n        e.new_instance(wrapper);\n        e.dup_x1();\n        e.swap();\n        e.invoke_constructor(wrapper, CSTRUCT_THROWABLE);\n        e.athrow();\n    }"
  },
  "org.springframework.cglib.core.EmitUtils#wrap_undeclared_throwable(e,handler,exceptions,wrapper)": {
    "change": "added",
    "deprecated": false,
    "doc": "    /**\n      * @deprecated use {@link #append_string(CodeEmitter, Type, ArrayDelimiters, CustomizerRegistry)} instead\n      */\n    @Deprecated\n    public static void append_string(final CodeEmitter e,\n                                     Type type,\n                                     final ArrayDelimiters delims,\n                                     final Customizer customizer) {\n        append_string(e, type, delims, CustomizerRegistry.singleton(customizer));\n    }\n\n    public static void append_string(final CodeEmitter e,\n                                     Type type,\n                                     final ArrayDelimiters delims,\n                                     final CustomizerRegistry registry) {\n        final ArrayDelimiters d = (delims != null) ? delims : DEFAULT_DELIMITERS;\n        ProcessArrayCallback callback = new ProcessArrayCallback() {\n            @Override\n            public void processElement(Type type) {\n                append_string_helper(e, type, d, registry, this);\n                e.push(d.inside);\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n            }\n        };\n        append_string_helper(e, type, d, registry, callback);\n    }\n\n    private static void append_string_helper(CodeEmitter e,\n                                             Type type,\n                                             ArrayDelimiters delims,\n                                             CustomizerRegistry registry,\n                                             ProcessArrayCallback callback) {\n        Label skip = e.make_label();\n        Label end = e.make_label();\n        if (TypeUtils.isPrimitive(type)) {\n            switch (type.getSort()) {\n            case Type.INT:\n            case Type.SHORT:\n            case Type.BYTE:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_INT);\n                break;\n            case Type.DOUBLE:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_DOUBLE);\n                break;\n            case Type.FLOAT:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_FLOAT);\n                break;\n            case Type.LONG:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_LONG);\n                break;\n            case Type.BOOLEAN:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_BOOLEAN);\n                break;\n            case Type.CHAR:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_CHAR);\n                break;\n            }\n        } else if (TypeUtils.isArray(type)) {\n            e.dup();\n            e.ifnull(skip);\n            e.swap();\n            if (delims != null && delims.before != null && !\"\".equals(delims.before)) {\n                e.push(delims.before);\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n                e.swap();\n            }\n            EmitUtils.process_array(e, type, callback);\n            shrinkStringBuffer(e, 2);\n            if (delims != null && delims.after != null && !\"\".equals(delims.after)) {\n                e.push(delims.after);\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n            }\n        } else {\n            e.dup();\n            e.ifnull(skip);\n            for (Customizer customizer : registry.get(Customizer.class)) {\n                customizer.customize(e, type);\n            }\n            e.invoke_virtual(Constants.TYPE_OBJECT, TO_STRING);\n            e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n        }\n        e.goTo(end);\n        e.mark(skip);\n        e.pop();\n        e.push(\"null\");\n        e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n        e.mark(end);\n    }\n\n    private static void shrinkStringBuffer(CodeEmitter e, int amt) {\n        e.dup();\n        e.dup();\n        e.invoke_virtual(Constants.TYPE_STRING_BUFFER, LENGTH);\n        e.push(amt);\n        e.math(CodeEmitter.SUB, Type.INT_TYPE);\n        e.invoke_virtual(Constants.TYPE_STRING_BUFFER, SET_LENGTH);\n    }\n\n    public static class ArrayDelimiters {\n        private String before;\n        private String inside;\n        private String after;\n\n        public ArrayDelimiters(String before, String inside, String after) {\n            this.before = before;\n            this.inside = inside;\n            this.after = after;\n        }\n    }\n\n    public static void load_method(CodeEmitter e, MethodInfo method) {\n        load_class(e, method.getClassInfo().getType());\n        e.push(method.getSignature().getName());\n        push_object(e, method.getSignature().getArgumentTypes());\n        e.invoke_virtual(Constants.TYPE_CLASS, GET_DECLARED_METHOD);\n    }\n\n    private interface ParameterTyper {\n        Type[] getParameterTypes(MethodInfo member);\n    }\n\n    public static void method_switch(CodeEmitter e,\n                                     List methods,\n                                     ObjectSwitchCallback callback) {\n        member_switch_helper(e, methods, callback, true);\n    }\n\n    public static void constructor_switch(CodeEmitter e,\n                                          List constructors,\n                                          ObjectSwitchCallback callback) {\n        member_switch_helper(e, constructors, callback, false);\n    }\n\n    private static void member_switch_helper(final CodeEmitter e,\n                                             List members,\n                                             final ObjectSwitchCallback callback,\n                                             boolean useName) {\n        try {\n            final Map cache = new HashMap();\n            final ParameterTyper cached = member -> {\n                Type[] types = (Type[]) cache.get(member);\n                if (types == null) {\n                    cache.put(member, types = member.getSignature().getArgumentTypes());\n                }\n                return types;\n            };\n            final Label def = e.make_label();\n            final Label end = e.make_label();\n            if (useName) {\n                e.swap();\n                final Map buckets = CollectionUtils.bucket(members, value -> ((MethodInfo)value).getSignature().getName());\n                String[] names = (String[])buckets.keySet().toArray(new String[buckets.size()]);\n                EmitUtils.string_switch(e, names, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\n                        @Override\n                        public void processCase(Object key, Label dontUseEnd) throws Exception {\n                            member_helper_size(e, (List)buckets.get(key), callback, cached, def, end);\n                        }\n                        @Override\n                        public void processDefault() throws Exception {\n                            e.goTo(def);\n                        }\n                    });\n            } else {\n                member_helper_size(e, members, callback, cached, def, end);\n            }\n            e.mark(def);\n            e.pop();\n            callback.processDefault();\n            e.mark(end);\n        } catch (RuntimeException | Error ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new CodeGenerationException(ex);\n        }\n    }\n\n    private static void member_helper_size(final CodeEmitter e,\n                                           List members,\n                                           final ObjectSwitchCallback callback,\n                                           final ParameterTyper typer,\n                                           final Label def,\n                                           final Label end) throws Exception {\n        final Map buckets = CollectionUtils.bucket(members, value -> typer.getParameterTypes((MethodInfo)value).length);\n        e.dup();\n        e.arraylength();\n        e.process_switch(EmitUtils.getSwitchKeys(buckets), new ProcessSwitchCallback() {\n            @Override\n            public void processCase(int key, Label dontUseEnd) throws Exception {\n                List bucket = (List)buckets.get(key);\n                member_helper_type(e, bucket, callback, typer, def, end, new BitSet());\n            }\n            @Override\n            public void processDefault() throws Exception {\n                e.goTo(def);\n            }\n        });\n    }\n\n    private static void member_helper_type(final CodeEmitter e,\n                                           List members,\n                                           final ObjectSwitchCallback callback,\n                                           final ParameterTyper typer,\n                                           final Label def,\n                                           final Label end,\n                                           final BitSet checked) throws Exception {\n        if (members.size() == 1) {\n            MethodInfo member = (MethodInfo)members.get(0);\n            Type[] types = typer.getParameterTypes(member);\n            // need to check classes that have not already been checked via switches\n            for (int i = 0; i < types.length; i++) {\n                if (checked == null || !checked.get(i)) {\n                    e.dup();\n                    e.aaload(i);\n                    e.invoke_virtual(Constants.TYPE_CLASS, GET_NAME);\n                    e.push(TypeUtils.emulateClassGetName(types[i]));\n                    e.invoke_virtual(Constants.TYPE_OBJECT, EQUALS);\n                    e.if_jump(CodeEmitter.EQ, def);\n                }\n            }\n            e.pop();\n            callback.processCase(member, end);\n        } else {\n            // choose the index that has the best chance of uniquely identifying member\n            Type[] example = typer.getParameterTypes((MethodInfo)members.get(0));\n            Map buckets = null;\n            int index = -1;\n            for (int i = 0; i < example.length; i++) {\n                final int j = i;\n                Map test = CollectionUtils.bucket(members,\n                        value -> TypeUtils.emulateClassGetName(typer.getParameterTypes((MethodInfo)value)[j]));\n                if (buckets == null || test.size() > buckets.size()) {\n                    buckets = test;\n                    index = i;\n                }\n            }\n            if (buckets == null || buckets.size() == 1) {\n                // TODO: switch by returnType\n                // must have two methods with same name, types, and different return types\n                e.goTo(def);\n            } else {\n                checked.set(index);\n\n                e.dup();\n                e.aaload(index);\n                e.invoke_virtual(Constants.TYPE_CLASS, GET_NAME);\n\n                final Map fbuckets = buckets;\n                String[] names = (String[])buckets.keySet().toArray(new String[buckets.size()]);\n                EmitUtils.string_switch(e, names, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\n                    @Override\n                    public void processCase(Object key, Label dontUseEnd) throws Exception {\n                        member_helper_type(e, (List)fbuckets.get(key), callback, typer, def, end, checked);\n                    }\n                    @Override\n                    public void processDefault() throws Exception {\n                        e.goTo(def);\n                    }\n                });\n            }\n        }\n    }\n\n    public static void wrap_throwable(Block block, Type wrapper) {\n        CodeEmitter e = block.getCodeEmitter();\n        e.catch_exception(block, Constants.TYPE_THROWABLE);\n        e.new_instance(wrapper);\n        e.dup_x1();\n        e.swap();\n        e.invoke_constructor(wrapper, CSTRUCT_THROWABLE);\n        e.athrow();\n    }\n\n    public static void add_properties(ClassEmitter ce, String[] names, Type[] types) {\n        for (int i = 0; i < names.length; i++) {\n            String fieldName = \"$cglib_prop_\" + names[i];\n            ce.declare_field(Constants.ACC_PRIVATE, fieldName, types[i], null);\n            EmitUtils.add_property(ce, names[i], types[i], fieldName);\n        }\n    }\n\n    public static void add_property(ClassEmitter ce, String name, Type type, String fieldName) {\n        String property = TypeUtils.upperFirst(name);\n        CodeEmitter e;\n        e = ce.begin_method(Constants.ACC_PUBLIC,\n                            new Signature(\"get\" + property,\n                                          type,\n                                          Constants.TYPES_EMPTY),\n                            null);\n        e.load_this();\n        e.getfield(fieldName);\n        e.return_value();\n        e.end_method();\n\n        e = ce.begin_method(Constants.ACC_PUBLIC,\n                            new Signature(\"set\" + property,\n                                          Type.VOID_TYPE,\n                                          new Type[]{ type }),\n                            null);\n        e.load_this();\n        e.load_arg(0);\n        e.putfield(fieldName);\n        e.return_value();\n        e.end_method();\n    }\n\n    /* generates:\n       } catch (RuntimeException e) {\n         throw e;\n       } catch (Error e) {\n         throw e;\n       } catch (<DeclaredException> e) {\n         throw e;\n       } catch (Throwable e) {\n         throw new <Wrapper>(e);\n       }\n    */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "handler",
      "exceptions",
      "wrapper"
    ],
    "position": {
      "column": 1,
      "line": 911
    },
    "return": "void",
    "signature": "public void wrap_undeclared_throwable(CodeEmitter e, Block handler, Type[] exceptions, Type wrapper)",
    "source_code": "    public static void wrap_undeclared_throwable(CodeEmitter e, Block handler, Type[] exceptions, Type wrapper) {\n        Set set = (exceptions == null) ? Collections.EMPTY_SET : new HashSet(Arrays.asList(exceptions));\n\n        if (set.contains(Constants.TYPE_THROWABLE)) {\n\t\t\treturn;\n\t\t}\n\n        boolean needThrow = exceptions != null;\n        if (!set.contains(Constants.TYPE_RUNTIME_EXCEPTION)) {\n            e.catch_exception(handler, Constants.TYPE_RUNTIME_EXCEPTION);\n            needThrow = true;\n        }\n        if (!set.contains(Constants.TYPE_ERROR)) {\n            e.catch_exception(handler, Constants.TYPE_ERROR);\n            needThrow = true;\n        }\n        if (exceptions != null) {\n            for (Type exception : exceptions) {\n                e.catch_exception(handler, exception);\n            }\n        }\n        if (needThrow) {\n            e.athrow();\n        }\n        // e -> eo -> oeo -> ooe -> o\n        e.catch_exception(handler, Constants.TYPE_THROWABLE);\n        e.new_instance(wrapper);\n        e.dup_x1();\n        e.swap();\n        e.invoke_constructor(wrapper, CSTRUCT_THROWABLE);\n        e.athrow();\n    }"
  },
  "org.springframework.cglib.core.internal.IDENTITY": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 14
    },
    "signature": "public Function IDENTITY",
    "source_code": "    public static final Function IDENTITY = key -> key;",
    "type": "Function"
  },
  "org.springframework.cglib.core.internal.LoadingCache": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 9
    },
    "signature": "public class LoadingCache",
    "source_code": "public class LoadingCache<K, KK, V> {\n    protected final ConcurrentMap<KK, Object> map;\n    protected final Function<K, V> loader;\n    protected final Function<K, KK> keyMapper;\n\n    public static final Function IDENTITY = key -> key;\n\n    public LoadingCache(Function<K, KK> keyMapper, Function<K, V> loader) {\n        this.keyMapper = keyMapper;\n        this.loader = loader;\n        this.map = new ConcurrentHashMap<>();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static <K> Function<K, K> identity() {\n        return IDENTITY;\n    }\n\n    public V get(K key) {\n        final KK cacheKey = keyMapper.apply(key);\n        Object v = map.get(cacheKey);\n        if (v != null && !(v instanceof FutureTask)) {\n            return (V) v;\n        }\n\n        return createEntry(key, cacheKey, v);\n    }\n\n    /**\n     * Loads entry to the cache.\n     * If entry is missing, put {@link FutureTask} first so other competing thread might wait for the result.\n     * @param key original key that would be used to load the instance\n     * @param cacheKey key that would be used to store the entry in internal map\n     * @param v null or {@link FutureTask<V>}\n     * @return newly created instance\n     */\n    protected V createEntry(final K key, KK cacheKey, Object v) {\n        FutureTask<V> task;\n        boolean creator = false;\n        if (v != null) {\n            // Another thread is already loading an instance\n            task = (FutureTask<V>) v;\n        } else {\n            task = new FutureTask<>(() -> loader.apply(key));\n            Object prevTask = map.putIfAbsent(cacheKey, task);\n            if (prevTask == null) {\n                // creator does the load\n                creator = true;\n                task.run();\n            } else if (prevTask instanceof FutureTask) {\n                task = (FutureTask<V>) prevTask;\n            } else {\n                return (V) prevTask;\n            }\n        }\n\n        V result;\n        try {\n            result = task.get();\n        } catch (InterruptedException e) {\n            throw new IllegalStateException(\"Interrupted while loading cache item\", e);\n        } catch (ExecutionException e) {\n            Throwable cause = e.getCause();\n            if (cause instanceof RuntimeException runtimeException) {\n                throw runtimeException;\n            }\n            throw new IllegalStateException(\"Unable to load cache item\", cause);\n        }\n        if (creator) {\n            map.put(cacheKey, result);\n        }\n        return result;\n    }\n}"
  },
  "org.springframework.cglib.core.internal.LoadingCache#createEntry(key,cacheKey,v)": {
    "change": "added",
    "deprecated": false,
    "doc": "    /**\n     * Loads entry to the cache.\n     * If entry is missing, put {@link FutureTask} first so other competing thread might wait for the result.\n     * @param key original key that would be used to load the instance\n     * @param cacheKey key that would be used to store the entry in internal map\n     * @param v null or {@link FutureTask<V>}\n     * @return newly created instance\n     */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "key",
      "cacheKey",
      "v"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "return": "V",
    "signature": "protected V createEntry(final K key, KK cacheKey, Object v)",
    "source_code": "    protected V createEntry(final K key, KK cacheKey, Object v) {\n        FutureTask<V> task;\n        boolean creator = false;\n        if (v != null) {\n            // Another thread is already loading an instance\n            task = (FutureTask<V>) v;\n        } else {\n            task = new FutureTask<>(() -> loader.apply(key));\n            Object prevTask = map.putIfAbsent(cacheKey, task);\n            if (prevTask == null) {\n                // creator does the load\n                creator = true;\n                task.run();\n            } else if (prevTask instanceof FutureTask) {\n                task = (FutureTask<V>) prevTask;\n            } else {\n                return (V) prevTask;\n            }\n        }\n\n        V result;\n        try {\n            result = task.get();\n        } catch (InterruptedException e) {\n            throw new IllegalStateException(\"Interrupted while loading cache item\", e);\n        } catch (ExecutionException e) {\n            Throwable cause = e.getCause();\n            if (cause instanceof RuntimeException runtimeException) {\n                throw runtimeException;\n            }\n            throw new IllegalStateException(\"Unable to load cache item\", cause);\n        }\n        if (creator) {\n            map.put(cacheKey, result);\n        }\n        return result;\n    }"
  },
  "org.springframework.cglib.core.internal.LoadingCache#get(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 27
    },
    "return": "V",
    "signature": "public V get(K key)",
    "source_code": "    public V get(K key) {\n        final KK cacheKey = keyMapper.apply(key);\n        Object v = map.get(cacheKey);\n        if (v != null && !(v instanceof FutureTask)) {\n            return (V) v;\n        }\n\n        return createEntry(key, cacheKey, v);\n    }"
  },
  "org.springframework.cglib.core.internal.LoadingCache#identity()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 23
    },
    "return": "K>",
    "signature": "public K> identity()",
    "source_code": "    public static <K> Function<K, K> identity() {\n        return IDENTITY;\n    }"
  },
  "org.springframework.cglib.core.internal.keyMapper": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 12
    },
    "signature": "protected KK> keyMapper",
    "source_code": "    protected final Function<K, KK> keyMapper;",
    "type": "KK>"
  },
  "org.springframework.cglib.core.internal.loader": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 11
    },
    "signature": "protected V> loader",
    "source_code": "    protected final Function<K, V> loader;",
    "type": "V>"
  },
  "org.springframework.cglib.core.internal.map": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 10
    },
    "signature": "protected Object> map",
    "source_code": "    protected final ConcurrentMap<KK, Object> map;",
    "type": "Object>"
  },
  "org.springframework.cglib.reflect.Generator": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "signature": "public class Generator",
    "source_code": "    public static class Generator extends AbstractClassGenerator"
  },
  "org.springframework.cglib.reflect.Generator#create()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "FastClass",
    "signature": "public FastClass create()",
    "source_code": "        public FastClass create() {\n            setNamePrefix(type.getName());\n            return (FastClass)super.create(type.getName());\n        }"
  },
  "org.springframework.cglib.reflect.Generator#create(loader,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "loader",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "return": "FastClass",
    "signature": "public FastClass create(ClassLoader loader, Class type)",
    "source_code": "    public static FastClass create(ClassLoader loader, Class type) {\n        Generator gen = new Generator();\n        gen.setType(type);\n        gen.setClassLoader(loader);\n        return gen.create();\n    }"
  },
  "org.springframework.cglib.reflect.Generator#create(type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "return": "FastClass",
    "signature": "public FastClass create(Class type)",
    "source_code": "    public static FastClass create(Class type) {\n\n        return create(type.getClassLoader(),type);\n\n    }"
  },
  "org.springframework.cglib.reflect.Generator#equals(o)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "boolean",
    "signature": "public boolean equals(Object o)",
    "source_code": "\tpublic boolean equals(Object o) {\n        if (o == null || !(o instanceof FastClass that)) {\n            return false;\n        }\n        return type.equals(that.type);\n    }"
  },
  "org.springframework.cglib.reflect.Generator#firstInstance(type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "Object",
    "signature": "protected Object firstInstance(Class type)",
    "source_code": "\t\tprotected Object firstInstance(Class type) {\n            return ReflectUtils.newInstance(type,\n                                            new Class[]{ Class.class },\n                                            new Object[]{ this.type });\n        }"
  },
  "org.springframework.cglib.reflect.Generator#generateClass(v)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "v"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "void",
    "signature": "public void generateClass(ClassVisitor v)",
    "source_code": "\t\tpublic void generateClass(ClassVisitor v) throws Exception {\n            new FastClassEmitter(v, getClassName(), type);\n        }"
  },
  "org.springframework.cglib.reflect.Generator#getConstructor(constructor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "constructor"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "FastConstructor",
    "signature": "public FastConstructor getConstructor(Constructor constructor)",
    "source_code": "    public FastConstructor getConstructor(Constructor constructor) {\n        return new FastConstructor(this, constructor);\n    }"
  },
  "org.springframework.cglib.reflect.Generator#getConstructor(parameterTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterTypes"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "FastConstructor",
    "signature": "public FastConstructor getConstructor(Class[] parameterTypes)",
    "source_code": "    public FastConstructor getConstructor(Class[] parameterTypes) {\n        try {\n            return getConstructor(type.getConstructor(parameterTypes));\n        } catch (NoSuchMethodException e) {\n            throw new NoSuchMethodError(e.getMessage());\n        }\n    }"
  },
  "org.springframework.cglib.reflect.Generator#getDefaultClassLoader()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "ClassLoader",
    "signature": "protected ClassLoader getDefaultClassLoader()",
    "source_code": "\t\tprotected ClassLoader getDefaultClassLoader() {\n            return type.getClassLoader();\n        }"
  },
  "org.springframework.cglib.reflect.Generator#getJavaClass()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "Class",
    "signature": "public Class getJavaClass()",
    "source_code": "    public Class getJavaClass() {\n        return type;\n    }"
  },
  "org.springframework.cglib.reflect.Generator#getMethod(method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "FastMethod",
    "signature": "public FastMethod getMethod(Method method)",
    "source_code": "    public FastMethod getMethod(Method method) {\n        return new FastMethod(this, method);\n    }"
  },
  "org.springframework.cglib.reflect.Generator#getMethod(name,parameterTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "parameterTypes"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "FastMethod",
    "signature": "public FastMethod getMethod(String name, Class[] parameterTypes)",
    "source_code": "    public FastMethod getMethod(String name, Class[] parameterTypes) {\n        try {\n            return getMethod(type.getMethod(name, parameterTypes));\n        } catch (NoSuchMethodException e) {\n            throw new NoSuchMethodError(e.getMessage());\n        }\n    }"
  },
  "org.springframework.cglib.reflect.Generator#getName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "String",
    "signature": "public String getName()",
    "source_code": "    public String getName() {\n        return type.getName();\n    }"
  },
  "org.springframework.cglib.reflect.Generator#getProtectionDomain()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "ProtectionDomain",
    "signature": "protected ProtectionDomain getProtectionDomain()",
    "source_code": "\t\tprotected ProtectionDomain getProtectionDomain() {\n        \treturn ReflectUtils.getProtectionDomain(type);\n        }"
  },
  "org.springframework.cglib.reflect.Generator#getSignatureWithoutReturnType(name,parameterTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameterTypes"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "String",
    "signature": "protected String getSignatureWithoutReturnType(String name, Class[] parameterTypes)",
    "source_code": "    protected static String getSignatureWithoutReturnType(String name, Class[] parameterTypes) {\n\t\tStringBuilder sb = new StringBuilder();\n        sb.append(name);\n        sb.append('(');\n        for (Class parameterType : parameterTypes) {\n            sb.append(Type.getDescriptor(parameterType));\n        }\n        sb.append(')');\n        return sb.toString();\n    }"
  },
  "org.springframework.cglib.reflect.Generator#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n        return type.hashCode();\n    }"
  },
  "org.springframework.cglib.reflect.Generator#invoke(name,parameterTypes,obj,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "parameterTypes",
      "obj",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "Object",
    "signature": "public Object invoke(String name, Class[] parameterTypes, Object obj, Object[] args)",
    "source_code": "    public Object invoke(String name, Class[] parameterTypes, Object obj, Object[] args) throws InvocationTargetException {\n        return invoke(getIndex(name, parameterTypes), obj, args);\n    }"
  },
  "org.springframework.cglib.reflect.Generator#newInstance()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "Object",
    "signature": "public Object newInstance()",
    "source_code": "    public Object newInstance() throws InvocationTargetException {\n        return newInstance(getIndex(Constants.EMPTY_CLASS_ARRAY), null);\n    }"
  },
  "org.springframework.cglib.reflect.Generator#newInstance(parameterTypes,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterTypes",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "Object",
    "signature": "public Object newInstance(Class[] parameterTypes, Object[] args)",
    "source_code": "    public Object newInstance(Class[] parameterTypes, Object[] args) throws InvocationTargetException {\n        return newInstance(getIndex(parameterTypes), args);\n    }"
  },
  "org.springframework.cglib.reflect.Generator#nextInstance(instance)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "instance"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "Object",
    "signature": "protected Object nextInstance(Object instance)",
    "source_code": "\t\tprotected Object nextInstance(Object instance) {\n            return instance;\n        }"
  },
  "org.springframework.cglib.reflect.Generator#setType(type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "void",
    "signature": "public void setType(Class type)",
    "source_code": "        public void setType(Class type) {\n            this.type = type;\n        }"
  },
  "org.springframework.cglib.reflect.Generator#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n        return type.toString();\n    }"
  },
  "org.springframework.context.annotation.AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The bean name of the internally managed Autowired annotation processor.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "signature": "public String AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME",
    "source_code": "\tpublic static final String AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME =",
    "type": "String"
  },
  "org.springframework.context.annotation.AnnotationConfigUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Utility class that allows for convenient registration of common\n * {@link org.springframework.beans.factory.config.BeanPostProcessor} and\n * {@link org.springframework.beans.factory.config.BeanFactoryPostProcessor}\n * definitions for annotation-based configuration. Also registers a common\n * {@link org.springframework.beans.factory.support.AutowireCandidateResolver}.\n *\n * @author Mark Fisher\n * @author Juergen Hoeller\n * @author Chris Beams\n * @author Phillip Webb\n * @author Stephane Nicoll\n * @since 2.5\n * @see ContextAnnotationAutowireCandidateResolver\n * @see ConfigurationClassPostProcessor\n * @see CommonAnnotationBeanPostProcessor\n * @see org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor\n * @see org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "signature": "public class AnnotationConfigUtils",
    "source_code": "public abstract class AnnotationConfigUtils {\n\n\t/**\n\t * The bean name of the internally managed Configuration annotation processor.\n\t */\n\tpublic static final String CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME =\n\t\t\t\"org.springframework.context.annotation.internalConfigurationAnnotationProcessor\";\n\n\t/**\n\t * The bean name of the internally managed BeanNameGenerator for use when processing\n\t * {@link Configuration} classes. Set by {@link AnnotationConfigApplicationContext}\n\t * and {@code AnnotationConfigWebApplicationContext} during bootstrap in order to make\n\t * any custom name generation strategy available to the underlying\n\t * {@link ConfigurationClassPostProcessor}.\n\t * @since 3.1.1\n\t */\n\tpublic static final String CONFIGURATION_BEAN_NAME_GENERATOR =\n\t\t\t\"org.springframework.context.annotation.internalConfigurationBeanNameGenerator\";\n\n\t/**\n\t * The bean name of the internally managed Autowired annotation processor.\n\t */\n\tpublic static final String AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME =\n\t\t\t\"org.springframework.context.annotation.internalAutowiredAnnotationProcessor\";\n\n\t/**\n\t * The bean name of the internally managed common annotation processor.\n\t */\n\tpublic static final String COMMON_ANNOTATION_PROCESSOR_BEAN_NAME =\n\t\t\t\"org.springframework.context.annotation.internalCommonAnnotationProcessor\";\n\n\t/**\n\t * The bean name of the internally managed JSR-250 annotation processor.\n\t */\n\tprivate static final String JSR250_ANNOTATION_PROCESSOR_BEAN_NAME =\n\t\t\t\"org.springframework.context.annotation.internalJsr250AnnotationProcessor\";\n\n\t/**\n\t * The bean name of the internally managed JPA annotation processor.\n\t */\n\tpublic static final String PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME =\n\t\t\t\"org.springframework.context.annotation.internalPersistenceAnnotationProcessor\";\n\n\tprivate static final String PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME =\n\t\t\t\"org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor\";\n\n\t/**\n\t * The bean name of the internally managed @EventListener annotation processor.\n\t */\n\tpublic static final String EVENT_LISTENER_PROCESSOR_BEAN_NAME =\n\t\t\t\"org.springframework.context.event.internalEventListenerProcessor\";\n\n\t/**\n\t * The bean name of the internally managed EventListenerFactory.\n\t */\n\tpublic static final String EVENT_LISTENER_FACTORY_BEAN_NAME =\n\t\t\t\"org.springframework.context.event.internalEventListenerFactory\";\n\n\n\tprivate static final ClassLoader classLoader = AnnotationConfigUtils.class.getClassLoader();\n\n\tprivate static final boolean jakartaAnnotationsPresent =\n\t\t\tClassUtils.isPresent(\"jakarta.annotation.PostConstruct\", classLoader);\n\n\tprivate static final boolean jsr250Present =\n\t\t\tClassUtils.isPresent(\"javax.annotation.PostConstruct\", classLoader);\n\n\tprivate static final boolean jpaPresent =\n\t\t\tClassUtils.isPresent(\"jakarta.persistence.EntityManagerFactory\", classLoader) &&\n\t\t\t\t\tClassUtils.isPresent(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, classLoader);\n\n\n\t/**\n\t * Register all relevant annotation post processors in the given registry.\n\t * @param registry the registry to operate on\n\t */\n\tpublic static void registerAnnotationConfigProcessors(BeanDefinitionRegistry registry) {\n\t\tregisterAnnotationConfigProcessors(registry, null);\n\t}\n\n\t/**\n\t * Register all relevant annotation post processors in the given registry.\n\t * @param registry the registry to operate on\n\t * @param source the configuration source element (already extracted)\n\t * that this registration was triggered from. May be {@code null}.\n\t * @return a Set of BeanDefinitionHolders, containing all bean definitions\n\t * that have actually been registered by this call\n\t */\n\tpublic static Set<BeanDefinitionHolder> registerAnnotationConfigProcessors(\n\t\t\tBeanDefinitionRegistry registry, @Nullable Object source) {\n\n\t\tDefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);\n\t\tif (beanFactory != null) {\n\t\t\tif (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) {\n\t\t\t\tbeanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);\n\t\t\t}\n\t\t\tif (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) {\n\t\t\t\tbeanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());\n\t\t\t}\n\t\t}\n\n\t\tSet<BeanDefinitionHolder> beanDefs = new LinkedHashSet<>(8);\n\n\t\tif (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\tif (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\t// Check for Jakarta Annotations support, and if present add the CommonAnnotationBeanPostProcessor.\n\t\tif (jakartaAnnotationsPresent && !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\t// Check for JSR-250 support, and if present add an InitDestroyAnnotationBeanPostProcessor\n\t\t// for the javax variant of PostConstruct/PreDestroy.\n\t\tif (jsr250Present && !registry.containsBeanDefinition(JSR250_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\ttry {\n\t\t\t\tRootBeanDefinition def = new RootBeanDefinition(InitDestroyAnnotationBeanPostProcessor.class);\n\t\t\t\tdef.getPropertyValues().add(\"initAnnotationType\", classLoader.loadClass(\"javax.annotation.PostConstruct\"));\n\t\t\t\tdef.getPropertyValues().add(\"destroyAnnotationType\", classLoader.loadClass(\"javax.annotation.PreDestroy\"));\n\t\t\t\tdef.setSource(source);\n\t\t\t\tbeanDefs.add(registerPostProcessor(registry, def, JSR250_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t\t}\n\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\t// Failed to load javax variants of the annotation types -> ignore.\n\t\t\t}\n\t\t}\n\n\t\t// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.\n\t\tif (jpaPresent && !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition();\n\t\t\ttry {\n\t\t\t\tdef.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,\n\t\t\t\t\t\tAnnotationConfigUtils.class.getClassLoader()));\n\t\t\t}\n\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Cannot load optional framework class: \" + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);\n\t\t\t}\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\tif (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\tif (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));\n\t\t}\n\n\t\treturn beanDefs;\n\t}\n\n\tprivate static BeanDefinitionHolder registerPostProcessor(\n\t\t\tBeanDefinitionRegistry registry, RootBeanDefinition definition, String beanName) {\n\n\t\tdefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\tregistry.registerBeanDefinition(beanName, definition);\n\t\treturn new BeanDefinitionHolder(definition, beanName);\n\t}\n\n\t@Nullable\n\tprivate static DefaultListableBeanFactory unwrapDefaultListableBeanFactory(BeanDefinitionRegistry registry) {\n\t\tif (registry instanceof DefaultListableBeanFactory dlbf) {\n\t\t\treturn dlbf;\n\t\t}\n\t\telse if (registry instanceof GenericApplicationContext gac) {\n\t\t\treturn gac.getDefaultListableBeanFactory();\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic static void processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd) {\n\t\tprocessCommonDefinitionAnnotations(abd, abd.getMetadata());\n\t}\n\n\tstatic void processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata) {\n\t\tAnnotationAttributes lazy = attributesFor(metadata, Lazy.class);\n\t\tif (lazy != null) {\n\t\t\tabd.setLazyInit(lazy.getBoolean(\"value\"));\n\t\t}\n\t\telse if (abd.getMetadata() != metadata) {\n\t\t\tlazy = attributesFor(abd.getMetadata(), Lazy.class);\n\t\t\tif (lazy != null) {\n\t\t\t\tabd.setLazyInit(lazy.getBoolean(\"value\"));\n\t\t\t}\n\t\t}\n\n\t\tif (metadata.isAnnotated(Primary.class.getName())) {\n\t\t\tabd.setPrimary(true);\n\t\t}\n\t\tAnnotationAttributes dependsOn = attributesFor(metadata, DependsOn.class);\n\t\tif (dependsOn != null) {\n\t\t\tabd.setDependsOn(dependsOn.getStringArray(\"value\"));\n\t\t}\n\n\t\tAnnotationAttributes role = attributesFor(metadata, Role.class);\n\t\tif (role != null) {\n\t\t\tabd.setRole(role.getNumber(\"value\").intValue());\n\t\t}\n\t\tAnnotationAttributes description = attributesFor(metadata, Description.class);\n\t\tif (description != null) {\n\t\t\tabd.setDescription(description.getString(\"value\"));\n\t\t}\n\t}\n\n\tstatic BeanDefinitionHolder applyScopedProxyMode(\n\t\t\tScopeMetadata metadata, BeanDefinitionHolder definition, BeanDefinitionRegistry registry) {\n\n\t\tScopedProxyMode scopedProxyMode = metadata.getScopedProxyMode();\n\t\tif (scopedProxyMode.equals(ScopedProxyMode.NO)) {\n\t\t\treturn definition;\n\t\t}\n\t\tboolean proxyTargetClass = scopedProxyMode.equals(ScopedProxyMode.TARGET_CLASS);\n\t\treturn ScopedProxyCreator.createScopedProxy(definition, registry, proxyTargetClass);\n\t}\n\n\t@Nullable\n\tstatic AnnotationAttributes attributesFor(AnnotatedTypeMetadata metadata, Class<?> annotationClass) {\n\t\treturn attributesFor(metadata, annotationClass.getName());\n\t}\n\n\t@Nullable\n\tstatic AnnotationAttributes attributesFor(AnnotatedTypeMetadata metadata, String annotationClassName) {\n\t\treturn AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(annotationClassName));\n\t}\n\n\tstatic Set<AnnotationAttributes> attributesForRepeatable(AnnotationMetadata metadata,\n\t\t\tClass<?> containerClass, Class<?> annotationClass) {\n\n\t\treturn attributesForRepeatable(metadata, containerClass.getName(), annotationClass.getName());\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tstatic Set<AnnotationAttributes> attributesForRepeatable(\n\t\t\tAnnotationMetadata metadata, String containerClassName, String annotationClassName) {\n\n\t\tSet<AnnotationAttributes> result = new LinkedHashSet<>();\n\n\t\t// Direct annotation present?\n\t\taddAttributesIfNotNull(result, metadata.getAnnotationAttributes(annotationClassName));\n\n\t\t// Container annotation present?\n\t\tMap<String, Object> container = metadata.getAnnotationAttributes(containerClassName);\n\t\tif (container != null && container.containsKey(\"value\")) {\n\t\t\tfor (Map<String, Object> containedAttributes : (Map<String, Object>[]) container.get(\"value\")) {\n\t\t\t\taddAttributesIfNotNull(result, containedAttributes);\n\t\t\t}\n\t\t}\n\n\t\t// Return merged result\n\t\treturn Collections.unmodifiableSet(result);\n\t}\n\n\tprivate static void addAttributesIfNotNull(\n\t\t\tSet<AnnotationAttributes> result, @Nullable Map<String, Object> attributes) {\n\n\t\tif (attributes != null) {\n\t\t\tresult.add(AnnotationAttributes.fromMap(attributes));\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.context.annotation.AnnotationConfigUtils#processCommonDefinitionAnnotations(abd)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "abd"
    ],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "void",
    "signature": "public void processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd)",
    "source_code": "\tpublic static void processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd) {\n\t\tprocessCommonDefinitionAnnotations(abd, abd.getMetadata());\n\t}"
  },
  "org.springframework.context.annotation.AnnotationConfigUtils#registerAnnotationConfigProcessors(registry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register all relevant annotation post processors in the given registry.\n\t * @param registry the registry to operate on\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "void",
    "signature": "public void registerAnnotationConfigProcessors(BeanDefinitionRegistry registry)",
    "source_code": "\tpublic static void registerAnnotationConfigProcessors(BeanDefinitionRegistry registry) {\n\t\tregisterAnnotationConfigProcessors(registry, null);\n\t}"
  },
  "org.springframework.context.annotation.AnnotationConfigUtils#registerAnnotationConfigProcessors(registry,source)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register all relevant annotation post processors in the given registry.\n\t * @param registry the registry to operate on\n\t * @param source the configuration source element (already extracted)\n\t * that this registration was triggered from. May be {@code null}.\n\t * @return a Set of BeanDefinitionHolders, containing all bean definitions\n\t * that have actually been registered by this call\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registry",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "Set<BeanDefinitionHolder>",
    "signature": "public Set<BeanDefinitionHolder> registerAnnotationConfigProcessors(BeanDefinitionRegistry registry, @Nullable Object source)",
    "source_code": "\tpublic static Set<BeanDefinitionHolder> registerAnnotationConfigProcessors("
  },
  "org.springframework.context.annotation.COMMON_ANNOTATION_PROCESSOR_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The bean name of the internally managed common annotation processor.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "signature": "public String COMMON_ANNOTATION_PROCESSOR_BEAN_NAME",
    "source_code": "\tpublic static final String COMMON_ANNOTATION_PROCESSOR_BEAN_NAME =",
    "type": "String"
  },
  "org.springframework.context.annotation.CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The bean name of the internally managed Configuration annotation processor.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "signature": "public String CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME",
    "source_code": "\tpublic static final String CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME =",
    "type": "String"
  },
  "org.springframework.context.annotation.CONFIGURATION_BEAN_NAME_GENERATOR": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The bean name of the internally managed BeanNameGenerator for use when processing\n\t * {@link Configuration} classes. Set by {@link AnnotationConfigApplicationContext}\n\t * and {@code AnnotationConfigWebApplicationContext} during bootstrap in order to make\n\t * any custom name generation strategy available to the underlying\n\t * {@link ConfigurationClassPostProcessor}.\n\t * @since 3.1.1\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "signature": "public String CONFIGURATION_BEAN_NAME_GENERATOR",
    "source_code": "\tpublic static final String CONFIGURATION_BEAN_NAME_GENERATOR =",
    "type": "String"
  },
  "org.springframework.context.annotation.ConfigurationClassUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Utilities for identifying and configuring {@link Configuration} classes.\n *\n * @author Chris Beams\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Stephane Nicoll\n * @since 6.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "signature": "public class ConfigurationClassUtils",
    "source_code": "public abstract class ConfigurationClassUtils {\n\n\tstatic final String CONFIGURATION_CLASS_FULL = \"full\";\n\n\tstatic final String CONFIGURATION_CLASS_LITE = \"lite\";\n\n\tstatic final String CONFIGURATION_CLASS_ATTRIBUTE =\n\t\t\tConventions.getQualifiedAttributeName(ConfigurationClassPostProcessor.class, \"configurationClass\");\n\n\tstatic final String ORDER_ATTRIBUTE =\n\t\t\tConventions.getQualifiedAttributeName(ConfigurationClassPostProcessor.class, \"order\");\n\n\n\tprivate static final Log logger = LogFactory.getLog(ConfigurationClassUtils.class);\n\n\tprivate static final Set<String> candidateIndicators = Set.of(\n\t\t\tComponent.class.getName(),\n\t\t\tComponentScan.class.getName(),\n\t\t\tImport.class.getName(),\n\t\t\tImportResource.class.getName());\n\n\n\t/**\n\t * Initialize a configuration class proxy for the specified class.\n\t * @param userClass the configuration class to initialize\n\t */\n\t@SuppressWarnings(\"unused\") // Used by AOT-optimized generated code\n\tpublic static Class<?> initializeConfigurationClass(Class<?> userClass) {\n\t\tClass<?> configurationClass = new ConfigurationClassEnhancer().enhance(userClass, null);\n\t\tEnhancer.registerStaticCallbacks(configurationClass, ConfigurationClassEnhancer.CALLBACKS);\n\t\treturn configurationClass;\n\t}\n\n\n\t/**\n\t * Check whether the given bean definition is a candidate for a configuration class\n\t * (or a nested component class declared within a configuration/component class,\n\t * to be auto-registered as well), and mark it accordingly.\n\t * @param beanDef the bean definition to check\n\t * @param metadataReaderFactory the current factory in use by the caller\n\t * @return whether the candidate qualifies as (any kind of) configuration class\n\t */\n\tstatic boolean checkConfigurationClassCandidate(\n\t\t\tBeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory) {\n\n\t\tString className = beanDef.getBeanClassName();\n\t\tif (className == null || beanDef.getFactoryMethodName() != null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tAnnotationMetadata metadata;\n\t\tif (beanDef instanceof AnnotatedBeanDefinition annotatedBd &&\n\t\t\t\tclassName.equals(annotatedBd.getMetadata().getClassName())) {\n\t\t\t// Can reuse the pre-parsed metadata from the given BeanDefinition...\n\t\t\tmetadata = annotatedBd.getMetadata();\n\t\t}\n\t\telse if (beanDef instanceof AbstractBeanDefinition abstractBd && abstractBd.hasBeanClass()) {\n\t\t\t// Check already loaded Class if present...\n\t\t\t// since we possibly can't even load the class file for this Class.\n\t\t\tClass<?> beanClass = abstractBd.getBeanClass();\n\t\t\tif (BeanFactoryPostProcessor.class.isAssignableFrom(beanClass) ||\n\t\t\t\t\tBeanPostProcessor.class.isAssignableFrom(beanClass) ||\n\t\t\t\t\tAopInfrastructureBean.class.isAssignableFrom(beanClass) ||\n\t\t\t\t\tEventListenerFactory.class.isAssignableFrom(beanClass)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tmetadata = AnnotationMetadata.introspect(beanClass);\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);\n\t\t\t\tmetadata = metadataReader.getAnnotationMetadata();\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Could not find class file for introspecting configuration annotations: \" +\n\t\t\t\t\t\t\tclassName, ex);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tMap<String, Object> config = metadata.getAnnotationAttributes(Configuration.class.getName());\n\t\tif (config != null && !Boolean.FALSE.equals(config.get(\"proxyBeanMethods\"))) {\n\t\t\tbeanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);\n\t\t}\n\t\telse if (config != null || isConfigurationCandidate(metadata)) {\n\t\t\tbeanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\n\t\t// It's a full or lite configuration candidate... Let's determine the order value, if any.\n\t\tInteger order = getOrder(metadata);\n\t\tif (order != null) {\n\t\t\tbeanDef.setAttribute(ORDER_ATTRIBUTE, order);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Check the given metadata for a configuration class candidate\n\t * (or nested component class declared within a configuration/component class).\n\t * @param metadata the metadata of the annotated class\n\t * @return {@code true} if the given class is to be registered for\n\t * configuration class processing; {@code false} otherwise\n\t */\n\tstatic boolean isConfigurationCandidate(AnnotationMetadata metadata) {\n\t\t// Do not consider an interface or an annotation...\n\t\tif (metadata.isInterface()) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Any of the typical annotations found?\n\t\tfor (String indicator : candidateIndicators) {\n\t\t\tif (metadata.isAnnotated(indicator)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// Finally, let's look for @Bean methods...\n\t\treturn hasBeanMethods(metadata);\n\t}\n\n\tstatic boolean hasBeanMethods(AnnotationMetadata metadata) {\n\t\ttry {\n\t\t\treturn metadata.hasAnnotatedMethods(Bean.class.getName());\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Failed to introspect @Bean methods on class [\" + metadata.getClassName() + \"]: \" + ex);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Determine the order for the given configuration class metadata.\n\t * @param metadata the metadata of the annotated class\n\t * @return the {@code @Order} annotation value on the configuration class,\n\t * or {@code Ordered.LOWEST_PRECEDENCE} if none declared\n\t * @since 5.0\n\t */\n\t@Nullable\n\tpublic static Integer getOrder(AnnotationMetadata metadata) {\n\t\tMap<String, Object> orderAttributes = metadata.getAnnotationAttributes(Order.class.getName());\n\t\treturn (orderAttributes != null ? ((Integer) orderAttributes.get(AnnotationUtils.VALUE)) : null);\n\t}\n\n\t/**\n\t * Determine the order for the given configuration class bean definition,\n\t * as set by {@link #checkConfigurationClassCandidate}.\n\t * @param beanDef the bean definition to check\n\t * @return the {@link Order @Order} annotation value on the configuration class,\n\t * or {@link Ordered#LOWEST_PRECEDENCE} if none declared\n\t * @since 4.2\n\t */\n\tpublic static int getOrder(BeanDefinition beanDef) {\n\t\tInteger order = (Integer) beanDef.getAttribute(ORDER_ATTRIBUTE);\n\t\treturn (order != null ? order : Ordered.LOWEST_PRECEDENCE);\n\t}\n\n}"
  },
  "org.springframework.context.annotation.ConfigurationClassUtils#getOrder(beanDef)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the order for the given configuration class bean definition,\n\t * as set by {@link #checkConfigurationClassCandidate}.\n\t * @param beanDef the bean definition to check\n\t * @return the {@link Order @Order} annotation value on the configuration class,\n\t * or {@link Ordered#LOWEST_PRECEDENCE} if none declared\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanDef"
    ],
    "position": {
      "column": 1,
      "line": 212
    },
    "return": "int",
    "signature": "public int getOrder(BeanDefinition beanDef)",
    "source_code": "\tpublic static int getOrder(BeanDefinition beanDef) {\n\t\tInteger order = (Integer) beanDef.getAttribute(ORDER_ATTRIBUTE);\n\t\treturn (order != null ? order : Ordered.LOWEST_PRECEDENCE);\n\t}"
  },
  "org.springframework.context.annotation.ConfigurationClassUtils#getOrder(metadata)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the order for the given configuration class metadata.\n\t * @param metadata the metadata of the annotated class\n\t * @return the {@code @Order} annotation value on the configuration class,\n\t * or {@code Ordered.LOWEST_PRECEDENCE} if none declared\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "metadata"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "Integer",
    "signature": "public Integer getOrder(AnnotationMetadata metadata)",
    "source_code": "\tpublic static Integer getOrder(AnnotationMetadata metadata) {\n\t\tMap<String, Object> orderAttributes = metadata.getAnnotationAttributes(Order.class.getName());\n\t\treturn (orderAttributes != null ? ((Integer) orderAttributes.get(AnnotationUtils.VALUE)) : null);\n\t}"
  },
  "org.springframework.context.annotation.EVENT_LISTENER_FACTORY_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The bean name of the internally managed EventListenerFactory.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "signature": "public String EVENT_LISTENER_FACTORY_BEAN_NAME",
    "source_code": "\tpublic static final String EVENT_LISTENER_FACTORY_BEAN_NAME =",
    "type": "String"
  },
  "org.springframework.context.annotation.EVENT_LISTENER_PROCESSOR_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The bean name of the internally managed @EventListener annotation processor.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "signature": "public String EVENT_LISTENER_PROCESSOR_BEAN_NAME",
    "source_code": "\tpublic static final String EVENT_LISTENER_PROCESSOR_BEAN_NAME =",
    "type": "String"
  },
  "org.springframework.context.annotation.PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The bean name of the internally managed JPA annotation processor.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "signature": "public String PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME",
    "source_code": "\tpublic static final String PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME =",
    "type": "String"
  },
  "org.springframework.context.event.EventListenerMethodProcessor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Registers {@link EventListener} methods as individual {@link ApplicationListener} instances.\n * Implements {@link BeanFactoryPostProcessor} (as of 5.1) primarily for early retrieval,\n * avoiding AOP checks for this processor bean and its {@link EventListenerFactory} delegates.\n *\n * @author Stephane Nicoll\n * @author Juergen Hoeller\n * @author Sebastien Deleuze\n * @since 4.2\n * @see EventListenerFactory\n * @see DefaultEventListenerFactory\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "signature": "public class EventListenerMethodProcessor",
    "source_code": "public class EventListenerMethodProcessor"
  },
  "org.springframework.context.event.EventListenerMethodProcessor#afterSingletonsInstantiated()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "void",
    "signature": "public void afterSingletonsInstantiated()",
    "source_code": "\tpublic void afterSingletonsInstantiated() {\n\t\tConfigurableListableBeanFactory beanFactory = this.beanFactory;\n\t\tAssert.state(this.beanFactory != null, \"No ConfigurableListableBeanFactory set\");\n\t\tString[] beanNames = beanFactory.getBeanNamesForType(Object.class);\n\t\tfor (String beanName : beanNames) {\n\t\t\tif (!ScopedProxyUtils.isScopedTarget(beanName)) {\n\t\t\t\tClass<?> type = null;\n\t\t\t\ttry {\n\t\t\t\t\ttype = AutoProxyUtils.determineTargetClass(beanFactory, beanName);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t// An unresolvable bean type, probably from a lazy bean - let's ignore it.\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Could not resolve target class for bean with name '\" + beanName + \"'\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (type != null) {\n\t\t\t\t\tif (ScopedObject.class.isAssignableFrom(type)) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tClass<?> targetClass = AutoProxyUtils.determineTargetClass(\n\t\t\t\t\t\t\t\t\tbeanFactory, ScopedProxyUtils.getTargetBeanName(beanName));\n\t\t\t\t\t\t\tif (targetClass != null) {\n\t\t\t\t\t\t\t\ttype = targetClass;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\t\t// An invalid scoped proxy arrangement - let's ignore it.\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Could not resolve target bean for scoped proxy '\" + beanName + \"'\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tprocessBean(beanName, type);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tthrow new BeanInitializationException(\"Failed to process @EventListener \" +\n\t\t\t\t\t\t\t\t\"annotation on bean with name '\" + beanName + \"': \" + ex.getMessage(), ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.context.event.EventListenerMethodProcessor#postProcessBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)",
    "source_code": "\tpublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\n\t\tMap<String, EventListenerFactory> beans = beanFactory.getBeansOfType(EventListenerFactory.class, false, false);\n\t\tList<EventListenerFactory> factories = new ArrayList<>(beans.values());\n\t\tAnnotationAwareOrderComparator.sort(factories);\n\t\tthis.eventListenerFactories = factories;\n\t}"
  },
  "org.springframework.context.event.EventListenerMethodProcessor#setApplicationContext(applicationContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "applicationContext"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "void",
    "signature": "public void setApplicationContext(ApplicationContext applicationContext)",
    "source_code": "\tpublic void setApplicationContext(ApplicationContext applicationContext) {\n\t\tAssert.isTrue(applicationContext instanceof ConfigurableApplicationContext,\n\t\t\t\t\"ApplicationContext does not implement ConfigurableApplicationContext\");\n\t\tthis.applicationContext = (ConfigurableApplicationContext) applicationContext;\n\t}"
  },
  "org.springframework.context.event.GenericApplicationListenerAdapter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link GenericApplicationListener} adapter that determines supported event types\n * through introspecting the generically declared type of the target listener.\n *\n * @author Juergen Hoeller\n * @author Stephane Nicoll\n * @since 3.0\n * @see org.springframework.context.ApplicationListener#onApplicationEvent\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class GenericApplicationListenerAdapter",
    "source_code": "public class GenericApplicationListenerAdapter implements GenericApplicationListener {\n\n\tprivate static final Map<Class<?>, ResolvableType> eventTypeCache = new ConcurrentReferenceHashMap<>();\n\n\n\tprivate final ApplicationListener<ApplicationEvent> delegate;\n\n\t@Nullable\n\tprivate final ResolvableType declaredEventType;\n\n\n\t/**\n\t * Create a new GenericApplicationListener for the given delegate.\n\t * @param delegate the delegate listener to be invoked\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic GenericApplicationListenerAdapter(ApplicationListener<?> delegate) {\n\t\tAssert.notNull(delegate, \"Delegate listener must not be null\");\n\t\tthis.delegate = (ApplicationListener<ApplicationEvent>) delegate;\n\t\tthis.declaredEventType = resolveDeclaredEventType(this.delegate);\n\t}\n\n\n\t@Override\n\tpublic void onApplicationEvent(ApplicationEvent event) {\n\t\tthis.delegate.onApplicationEvent(event);\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic boolean supportsEventType(ResolvableType eventType) {\n\t\tif (this.delegate instanceof GenericApplicationListener gal) {\n\t\t\treturn gal.supportsEventType(eventType);\n\t\t}\n\t\telse if (this.delegate instanceof SmartApplicationListener sal) {\n\t\t\tClass<? extends ApplicationEvent> eventClass = (Class<? extends ApplicationEvent>) eventType.resolve();\n\t\t\treturn (eventClass != null && sal.supportsEventType(eventClass));\n\t\t}\n\t\telse {\n\t\t\treturn (this.declaredEventType == null || this.declaredEventType.isAssignableFrom(eventType));\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean supportsSourceType(@Nullable Class<?> sourceType) {\n\t\treturn (!(this.delegate instanceof SmartApplicationListener sal) || sal.supportsSourceType(sourceType));\n\t}\n\n\t@Override\n\tpublic int getOrder() {\n\t\treturn (this.delegate instanceof Ordered ordered ? ordered.getOrder() : Ordered.LOWEST_PRECEDENCE);\n\t}\n\n\t@Override\n\tpublic String getListenerId() {\n\t\treturn (this.delegate instanceof SmartApplicationListener sal ? sal.getListenerId() : \"\");\n\t}\n\n\n\t@Nullable\n\tprivate static ResolvableType resolveDeclaredEventType(ApplicationListener<ApplicationEvent> listener) {\n\t\tResolvableType declaredEventType = resolveDeclaredEventType(listener.getClass());\n\t\tif (declaredEventType == null || declaredEventType.isAssignableFrom(ApplicationEvent.class)) {\n\t\t\tClass<?> targetClass = AopUtils.getTargetClass(listener);\n\t\t\tif (targetClass != listener.getClass()) {\n\t\t\t\tdeclaredEventType = resolveDeclaredEventType(targetClass);\n\t\t\t}\n\t\t}\n\t\treturn declaredEventType;\n\t}\n\n\t@Nullable\n\tstatic ResolvableType resolveDeclaredEventType(Class<?> listenerType) {\n\t\tResolvableType eventType = eventTypeCache.get(listenerType);\n\t\tif (eventType == null) {\n\t\t\teventType = ResolvableType.forClass(listenerType).as(ApplicationListener.class).getGeneric();\n\t\t\teventTypeCache.put(listenerType, eventType);\n\t\t}\n\t\treturn (eventType != ResolvableType.NONE ? eventType : null);\n\t}\n\n}"
  },
  "org.springframework.context.event.GenericApplicationListenerAdapter#getListenerId()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "String",
    "signature": "public String getListenerId()",
    "source_code": "\tpublic String getListenerId() {\n\t\treturn (this.delegate instanceof SmartApplicationListener sal ? sal.getListenerId() : \"\");\n\t}"
  },
  "org.springframework.context.event.GenericApplicationListenerAdapter#getOrder()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "int",
    "signature": "public int getOrder()",
    "source_code": "\tpublic int getOrder() {\n\t\treturn (this.delegate instanceof Ordered ordered ? ordered.getOrder() : Ordered.LOWEST_PRECEDENCE);\n\t}"
  },
  "org.springframework.context.event.GenericApplicationListenerAdapter#onApplicationEvent(event)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "event"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "void",
    "signature": "public void onApplicationEvent(ApplicationEvent event)",
    "source_code": "\tpublic void onApplicationEvent(ApplicationEvent event) {\n\t\tthis.delegate.onApplicationEvent(event);\n\t}"
  },
  "org.springframework.context.event.GenericApplicationListenerAdapter#supportsEventType(eventType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "eventType"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "boolean",
    "signature": "public boolean supportsEventType(ResolvableType eventType)",
    "source_code": "\tpublic boolean supportsEventType(ResolvableType eventType) {\n\t\tif (this.delegate instanceof GenericApplicationListener gal) {\n\t\t\treturn gal.supportsEventType(eventType);\n\t\t}\n\t\telse if (this.delegate instanceof SmartApplicationListener sal) {\n\t\t\tClass<? extends ApplicationEvent> eventClass = (Class<? extends ApplicationEvent>) eventType.resolve();\n\t\t\treturn (eventClass != null && sal.supportsEventType(eventClass));\n\t\t}\n\t\telse {\n\t\t\treturn (this.declaredEventType == null || this.declaredEventType.isAssignableFrom(eventType));\n\t\t}\n\t}"
  },
  "org.springframework.context.event.GenericApplicationListenerAdapter#supportsSourceType(sourceType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "boolean",
    "signature": "public boolean supportsSourceType(@Nullable Class<?> sourceType)",
    "source_code": "\tpublic boolean supportsSourceType(@Nullable Class<?> sourceType) {\n\t\treturn (!(this.delegate instanceof SmartApplicationListener sal) || sal.supportsSourceType(sourceType));\n\t}"
  },
  "org.springframework.context.event.SimpleApplicationEventMulticaster": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Simple implementation of the {@link ApplicationEventMulticaster} interface.\n *\n * <p>Multicasts all events to all registered listeners, leaving it up to\n * the listeners to ignore events that they are not interested in.\n * Listeners will usually perform corresponding {@code instanceof}\n * checks on the passed-in event object.\n *\n * <p>By default, all listeners are invoked in the calling thread.\n * This allows the danger of a rogue listener blocking the entire application,\n * but adds minimal overhead. Specify an alternative task executor to have\n * listeners executed in different threads, for example from a thread pool.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Stephane Nicoll\n * @author Brian Clozel\n * @see #setTaskExecutor\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "public class SimpleApplicationEventMulticaster",
    "source_code": "public class SimpleApplicationEventMulticaster extends AbstractApplicationEventMulticaster {\n\n\t@Nullable\n\tprivate Executor taskExecutor;\n\n\t@Nullable\n\tprivate ErrorHandler errorHandler;\n\n\t@Nullable\n\tprivate volatile Log lazyLogger;\n\n\n\t/**\n\t * Create a new SimpleApplicationEventMulticaster.\n\t */\n\tpublic SimpleApplicationEventMulticaster() {\n\t}\n\n\t/**\n\t * Create a new SimpleApplicationEventMulticaster for the given BeanFactory.\n\t */\n\tpublic SimpleApplicationEventMulticaster(BeanFactory beanFactory) {\n\t\tsetBeanFactory(beanFactory);\n\t}\n\n\n\t/**\n\t * Set a custom executor (typically a {@link org.springframework.core.task.TaskExecutor})\n\t * to invoke each listener with.\n\t * <p>Default is equivalent to {@link org.springframework.core.task.SyncTaskExecutor},\n\t * executing all listeners synchronously in the calling thread.\n\t * <p>Consider specifying an asynchronous task executor here to not block the\n\t * caller until all listeners have been executed. However, note that asynchronous\n\t * execution will not participate in the caller's thread context (class loader,\n\t * transaction association) unless the TaskExecutor explicitly supports this.\n\t * @see org.springframework.core.task.SyncTaskExecutor\n\t * @see org.springframework.core.task.SimpleAsyncTaskExecutor\n\t */\n\tpublic void setTaskExecutor(@Nullable Executor taskExecutor) {\n\t\tthis.taskExecutor = taskExecutor;\n\t}\n\n\t/**\n\t * Return the current task executor for this multicaster.\n\t */\n\t@Nullable\n\tprotected Executor getTaskExecutor() {\n\t\treturn this.taskExecutor;\n\t}\n\n\t/**\n\t * Set the {@link ErrorHandler} to invoke in case an exception is thrown\n\t * from a listener.\n\t * <p>Default is none, with a listener exception stopping the current\n\t * multicast and getting propagated to the publisher of the current event.\n\t * If a {@linkplain #setTaskExecutor task executor} is specified, each\n\t * individual listener exception will get propagated to the executor but\n\t * won't necessarily stop execution of other listeners.\n\t * <p>Consider setting an {@link ErrorHandler} implementation that catches\n\t * and logs exceptions (a la\n\t * {@link org.springframework.scheduling.support.TaskUtils#LOG_AND_SUPPRESS_ERROR_HANDLER})\n\t * or an implementation that logs exceptions while nevertheless propagating them\n\t * (e.g. {@link org.springframework.scheduling.support.TaskUtils#LOG_AND_PROPAGATE_ERROR_HANDLER}).\n\t * @since 4.1\n\t */\n\tpublic void setErrorHandler(@Nullable ErrorHandler errorHandler) {\n\t\tthis.errorHandler = errorHandler;\n\t}\n\n\t/**\n\t * Return the current error handler for this multicaster.\n\t * @since 4.1\n\t */\n\t@Nullable\n\tprotected ErrorHandler getErrorHandler() {\n\t\treturn this.errorHandler;\n\t}\n\n\t@Override\n\tpublic void multicastEvent(ApplicationEvent event) {\n\t\tmulticastEvent(event, resolveDefaultEventType(event));\n\t}\n\n\t@Override\n\tpublic void multicastEvent(ApplicationEvent event, @Nullable ResolvableType eventType) {\n\t\tResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));\n\t\tExecutor executor = getTaskExecutor();\n\t\tfor (ApplicationListener<?> listener : getApplicationListeners(event, type)) {\n\t\t\tif (executor != null) {\n\t\t\t\texecutor.execute(() -> invokeListener(listener, event));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinvokeListener(listener, event);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate ResolvableType resolveDefaultEventType(ApplicationEvent event) {\n\t\treturn ResolvableType.forInstance(event);\n\t}\n\n\t/**\n\t * Invoke the given listener with the given event.\n\t * @param listener the ApplicationListener to invoke\n\t * @param event the current event to propagate\n\t * @since 4.1\n\t */\n\tprotected void invokeListener(ApplicationListener<?> listener, ApplicationEvent event) {\n\t\tErrorHandler errorHandler = getErrorHandler();\n\t\tif (errorHandler != null) {\n\t\t\ttry {\n\t\t\t\tdoInvokeListener(listener, event);\n\t\t\t}\n\t\t\tcatch (Throwable err) {\n\t\t\t\terrorHandler.handleError(err);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdoInvokeListener(listener, event);\n\t\t}\n\t}\n\n\t@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n\tprivate void doInvokeListener(ApplicationListener listener, ApplicationEvent event) {\n\t\ttry {\n\t\t\tlistener.onApplicationEvent(event);\n\t\t}\n\t\tcatch (ClassCastException ex) {\n\t\t\tString msg = ex.getMessage();\n\t\t\tif (msg == null || matchesClassCastMessage(msg, event.getClass()) ||\n\t\t\t\t\t(event instanceof PayloadApplicationEvent payloadEvent &&\n\t\t\t\t\t\t\tmatchesClassCastMessage(msg, payloadEvent.getPayload().getClass()))) {\n\t\t\t\t// Possibly a lambda-defined listener which we could not resolve the generic event type for\n\t\t\t\t// -> let's suppress the exception.\n\t\t\t\tLog loggerToUse = this.lazyLogger;\n\t\t\t\tif (loggerToUse == null) {\n\t\t\t\t\tloggerToUse = LogFactory.getLog(getClass());\n\t\t\t\t\tthis.lazyLogger = loggerToUse;\n\t\t\t\t}\n\t\t\t\tif (loggerToUse.isTraceEnabled()) {\n\t\t\t\t\tloggerToUse.trace(\"Non-matching event type for listener: \" + listener, ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean matchesClassCastMessage(String classCastMessage, Class<?> eventClass) {\n\t\t// On Java 8, the message starts with the class name: \"java.lang.String cannot be cast...\"\n\t\tif (classCastMessage.startsWith(eventClass.getName())) {\n\t\t\treturn true;\n\t\t}\n\t\t// On Java 11, the message starts with \"class ...\" a.k.a. Class.toString()\n\t\tif (classCastMessage.startsWith(eventClass.toString())) {\n\t\t\treturn true;\n\t\t}\n\t\t// On Java 9, the message used to contain the module name: \"java.base/java.lang.String cannot be cast...\"\n\t\tint moduleSeparatorIndex = classCastMessage.indexOf('/');\n\t\tif (moduleSeparatorIndex != -1 && classCastMessage.startsWith(eventClass.getName(), moduleSeparatorIndex + 1)) {\n\t\t\treturn true;\n\t\t}\n\t\t// Assuming an unrelated class cast failure...\n\t\treturn false;\n\t}\n\n}"
  },
  "org.springframework.context.event.SimpleApplicationEventMulticaster#getErrorHandler()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the current error handler for this multicaster.\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "ErrorHandler",
    "signature": "protected ErrorHandler getErrorHandler()",
    "source_code": "\tprotected ErrorHandler getErrorHandler() {\n\t\treturn this.errorHandler;\n\t}"
  },
  "org.springframework.context.event.SimpleApplicationEventMulticaster#getTaskExecutor()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the current task executor for this multicaster.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "Executor",
    "signature": "protected Executor getTaskExecutor()",
    "source_code": "\tprotected Executor getTaskExecutor() {\n\t\treturn this.taskExecutor;\n\t}"
  },
  "org.springframework.context.event.SimpleApplicationEventMulticaster#invokeListener(listener,event)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the given listener with the given event.\n\t * @param listener the ApplicationListener to invoke\n\t * @param event the current event to propagate\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "listener",
      "event"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "void",
    "signature": "protected void invokeListener(ApplicationListener<?> listener, ApplicationEvent event)",
    "source_code": "\tprotected void invokeListener(ApplicationListener<?> listener, ApplicationEvent event) {\n\t\tErrorHandler errorHandler = getErrorHandler();\n\t\tif (errorHandler != null) {\n\t\t\ttry {\n\t\t\t\tdoInvokeListener(listener, event);\n\t\t\t}\n\t\t\tcatch (Throwable err) {\n\t\t\t\terrorHandler.handleError(err);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdoInvokeListener(listener, event);\n\t\t}\n\t}"
  },
  "org.springframework.context.event.SimpleApplicationEventMulticaster#multicastEvent(event)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "event"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "void",
    "signature": "public void multicastEvent(ApplicationEvent event)",
    "source_code": "\tpublic void multicastEvent(ApplicationEvent event) {\n\t\tmulticastEvent(event, resolveDefaultEventType(event));\n\t}"
  },
  "org.springframework.context.event.SimpleApplicationEventMulticaster#multicastEvent(event,eventType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "event",
      "eventType"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "void",
    "signature": "public void multicastEvent(ApplicationEvent event, @Nullable ResolvableType eventType)",
    "source_code": "\tpublic void multicastEvent(ApplicationEvent event, @Nullable ResolvableType eventType) {\n\t\tResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));\n\t\tExecutor executor = getTaskExecutor();\n\t\tfor (ApplicationListener<?> listener : getApplicationListeners(event, type)) {\n\t\t\tif (executor != null) {\n\t\t\t\texecutor.execute(() -> invokeListener(listener, event));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinvokeListener(listener, event);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.context.event.SimpleApplicationEventMulticaster#setErrorHandler(errorHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link ErrorHandler} to invoke in case an exception is thrown\n\t * from a listener.\n\t * <p>Default is none, with a listener exception stopping the current\n\t * multicast and getting propagated to the publisher of the current event.\n\t * If a {@linkplain #setTaskExecutor task executor} is specified, each\n\t * individual listener exception will get propagated to the executor but\n\t * won't necessarily stop execution of other listeners.\n\t * <p>Consider setting an {@link ErrorHandler} implementation that catches\n\t * and logs exceptions (a la\n\t * {@link org.springframework.scheduling.support.TaskUtils#LOG_AND_SUPPRESS_ERROR_HANDLER})\n\t * or an implementation that logs exceptions while nevertheless propagating them\n\t * (e.g. {@link org.springframework.scheduling.support.TaskUtils#LOG_AND_PROPAGATE_ERROR_HANDLER}).\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorHandler"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "void",
    "signature": "public void setErrorHandler(@Nullable ErrorHandler errorHandler)",
    "source_code": "\tpublic void setErrorHandler(@Nullable ErrorHandler errorHandler) {\n\t\tthis.errorHandler = errorHandler;\n\t}"
  },
  "org.springframework.context.event.SimpleApplicationEventMulticaster#setTaskExecutor(taskExecutor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a custom executor (typically a {@link org.springframework.core.task.TaskExecutor})\n\t * to invoke each listener with.\n\t * <p>Default is equivalent to {@link org.springframework.core.task.SyncTaskExecutor},\n\t * executing all listeners synchronously in the calling thread.\n\t * <p>Consider specifying an asynchronous task executor here to not block the\n\t * caller until all listeners have been executed. However, note that asynchronous\n\t * execution will not participate in the caller's thread context (class loader,\n\t * transaction association) unless the TaskExecutor explicitly supports this.\n\t * @see org.springframework.core.task.SyncTaskExecutor\n\t * @see org.springframework.core.task.SimpleAsyncTaskExecutor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "taskExecutor"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "void",
    "signature": "public void setTaskExecutor(@Nullable Executor taskExecutor)",
    "source_code": "\tpublic void setTaskExecutor(@Nullable Executor taskExecutor) {\n\t\tthis.taskExecutor = taskExecutor;\n\t}"
  },
  "org.springframework.context.event.SourceFilteringListener": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link org.springframework.context.ApplicationListener} decorator that filters\n * events from a specified event source, invoking its delegate listener for\n * matching {@link org.springframework.context.ApplicationEvent} objects only.\n *\n * <p>Can also be used as base class, overriding the {@link #onApplicationEventInternal}\n * method instead of specifying a delegate listener.\n *\n * @author Juergen Hoeller\n * @author Stephane Nicoll\n * @since 2.0.5\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "signature": "public class SourceFilteringListener",
    "source_code": "public class SourceFilteringListener implements GenericApplicationListener {\n\n\tprivate final Object source;\n\n\t@Nullable\n\tprivate GenericApplicationListener delegate;\n\n\n\t/**\n\t * Create a SourceFilteringListener for the given event source.\n\t * @param source the event source that this listener filters for,\n\t * only processing events from this source\n\t * @param delegate the delegate listener to invoke with event\n\t * from the specified source\n\t */\n\tpublic SourceFilteringListener(Object source, ApplicationListener<?> delegate) {\n\t\tthis.source = source;\n\t\tthis.delegate = (delegate instanceof GenericApplicationListener gal ? gal :\n\t\t\t\tnew GenericApplicationListenerAdapter(delegate));\n\t}\n\n\t/**\n\t * Create a SourceFilteringListener for the given event source,\n\t * expecting subclasses to override the {@link #onApplicationEventInternal}\n\t * method (instead of specifying a delegate listener).\n\t * @param source the event source that this listener filters for,\n\t * only processing events from this source\n\t */\n\tprotected SourceFilteringListener(Object source) {\n\t\tthis.source = source;\n\t}\n\n\n\t@Override\n\tpublic void onApplicationEvent(ApplicationEvent event) {\n\t\tif (event.getSource() == this.source) {\n\t\t\tonApplicationEventInternal(event);\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean supportsEventType(ResolvableType eventType) {\n\t\treturn (this.delegate == null || this.delegate.supportsEventType(eventType));\n\t}\n\n\t@Override\n\tpublic boolean supportsSourceType(@Nullable Class<?> sourceType) {\n\t\treturn (sourceType != null && sourceType.isInstance(this.source));\n\t}\n\n\t@Override\n\tpublic int getOrder() {\n\t\treturn (this.delegate != null ? this.delegate.getOrder() : Ordered.LOWEST_PRECEDENCE);\n\t}\n\n\t@Override\n\tpublic String getListenerId() {\n\t\treturn (this.delegate != null ? this.delegate.getListenerId() : \"\");\n\t}\n\n\n\t/**\n\t * Actually process the event, after having filtered according to the\n\t * desired event source already.\n\t * <p>The default implementation invokes the specified delegate, if any.\n\t * @param event the event to process (matching the specified source)\n\t */\n\tprotected void onApplicationEventInternal(ApplicationEvent event) {\n\t\tif (this.delegate == null) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Must specify a delegate object or override the onApplicationEventInternal method\");\n\t\t}\n\t\tthis.delegate.onApplicationEvent(event);\n\t}\n\n}"
  },
  "org.springframework.context.event.SourceFilteringListener#getListenerId()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "String",
    "signature": "public String getListenerId()",
    "source_code": "\tpublic String getListenerId() {\n\t\treturn (this.delegate != null ? this.delegate.getListenerId() : \"\");\n\t}"
  },
  "org.springframework.context.event.SourceFilteringListener#getOrder()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "int",
    "signature": "public int getOrder()",
    "source_code": "\tpublic int getOrder() {\n\t\treturn (this.delegate != null ? this.delegate.getOrder() : Ordered.LOWEST_PRECEDENCE);\n\t}"
  },
  "org.springframework.context.event.SourceFilteringListener#onApplicationEvent(event)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "event"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "void",
    "signature": "public void onApplicationEvent(ApplicationEvent event)",
    "source_code": "\tpublic void onApplicationEvent(ApplicationEvent event) {\n\t\tif (event.getSource() == this.source) {\n\t\t\tonApplicationEventInternal(event);\n\t\t}\n\t}"
  },
  "org.springframework.context.event.SourceFilteringListener#onApplicationEventInternal(event)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Actually process the event, after having filtered according to the\n\t * desired event source already.\n\t * <p>The default implementation invokes the specified delegate, if any.\n\t * @param event the event to process (matching the specified source)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "event"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "void",
    "signature": "protected void onApplicationEventInternal(ApplicationEvent event)",
    "source_code": "\tprotected void onApplicationEventInternal(ApplicationEvent event) {\n\t\tif (this.delegate == null) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Must specify a delegate object or override the onApplicationEventInternal method\");\n\t\t}\n\t\tthis.delegate.onApplicationEvent(event);\n\t}"
  },
  "org.springframework.context.event.SourceFilteringListener#supportsEventType(eventType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "eventType"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "boolean",
    "signature": "public boolean supportsEventType(ResolvableType eventType)",
    "source_code": "\tpublic boolean supportsEventType(ResolvableType eventType) {\n\t\treturn (this.delegate == null || this.delegate.supportsEventType(eventType));\n\t}"
  },
  "org.springframework.context.event.SourceFilteringListener#supportsSourceType(sourceType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "boolean",
    "signature": "public boolean supportsSourceType(@Nullable Class<?> sourceType)",
    "source_code": "\tpublic boolean supportsSourceType(@Nullable Class<?> sourceType) {\n\t\treturn (sourceType != null && sourceType.isInstance(this.source));\n\t}"
  },
  "org.springframework.context.i18n.LocaleContextHolder": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Simple holder class that associates a LocaleContext instance\n * with the current thread. The LocaleContext will be inherited\n * by any child threads spawned by the current thread if the\n * {@code inheritable} flag is set to {@code true}.\n *\n * <p>Used as a central holder for the current Locale in Spring,\n * wherever necessary: for example, in MessageSourceAccessor.\n * DispatcherServlet automatically exposes its current Locale here.\n * Other applications can expose theirs too, to make classes like\n * MessageSourceAccessor automatically use that Locale.\n *\n * @author Juergen Hoeller\n * @author Nicholas Williams\n * @since 1.2\n * @see LocaleContext\n * @see org.springframework.context.support.MessageSourceAccessor\n * @see org.springframework.web.servlet.DispatcherServlet\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "signature": "public class LocaleContextHolder",
    "source_code": "public final class LocaleContextHolder {\n\n\tprivate static final ThreadLocal<LocaleContext> localeContextHolder =\n\t\t\tnew NamedThreadLocal<>(\"LocaleContext\");\n\n\tprivate static final ThreadLocal<LocaleContext> inheritableLocaleContextHolder =\n\t\t\tnew NamedInheritableThreadLocal<>(\"LocaleContext\");\n\n\t// Shared default locale at the framework level\n\t@Nullable\n\tprivate static Locale defaultLocale;\n\n\t// Shared default time zone at the framework level\n\t@Nullable\n\tprivate static TimeZone defaultTimeZone;\n\n\n\tprivate LocaleContextHolder() {\n\t}\n\n\n\t/**\n\t * Reset the LocaleContext for the current thread.\n\t */\n\tpublic static void resetLocaleContext() {\n\t\tlocaleContextHolder.remove();\n\t\tinheritableLocaleContextHolder.remove();\n\t}\n\n\t/**\n\t * Associate the given LocaleContext with the current thread,\n\t * <i>not</i> exposing it as inheritable for child threads.\n\t * <p>The given LocaleContext may be a {@link TimeZoneAwareLocaleContext},\n\t * containing a locale with associated time zone information.\n\t * @param localeContext the current LocaleContext,\n\t * or {@code null} to reset the thread-bound context\n\t * @see SimpleLocaleContext\n\t * @see SimpleTimeZoneAwareLocaleContext\n\t */\n\tpublic static void setLocaleContext(@Nullable LocaleContext localeContext) {\n\t\tsetLocaleContext(localeContext, false);\n\t}\n\n\t/**\n\t * Associate the given LocaleContext with the current thread.\n\t * <p>The given LocaleContext may be a {@link TimeZoneAwareLocaleContext},\n\t * containing a locale with associated time zone information.\n\t * @param localeContext the current LocaleContext,\n\t * or {@code null} to reset the thread-bound context\n\t * @param inheritable whether to expose the LocaleContext as inheritable\n\t * for child threads (using an {@link InheritableThreadLocal})\n\t * @see SimpleLocaleContext\n\t * @see SimpleTimeZoneAwareLocaleContext\n\t */\n\tpublic static void setLocaleContext(@Nullable LocaleContext localeContext, boolean inheritable) {\n\t\tif (localeContext == null) {\n\t\t\tresetLocaleContext();\n\t\t}\n\t\telse {\n\t\t\tif (inheritable) {\n\t\t\t\tinheritableLocaleContextHolder.set(localeContext);\n\t\t\t\tlocaleContextHolder.remove();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlocaleContextHolder.set(localeContext);\n\t\t\t\tinheritableLocaleContextHolder.remove();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Return the LocaleContext associated with the current thread, if any.\n\t * @return the current LocaleContext, or {@code null} if none\n\t */\n\t@Nullable\n\tpublic static LocaleContext getLocaleContext() {\n\t\tLocaleContext localeContext = localeContextHolder.get();\n\t\tif (localeContext == null) {\n\t\t\tlocaleContext = inheritableLocaleContextHolder.get();\n\t\t}\n\t\treturn localeContext;\n\t}\n\n\t/**\n\t * Associate the given Locale with the current thread,\n\t * preserving any TimeZone that may have been set already.\n\t * <p>Will implicitly create a LocaleContext for the given Locale,\n\t * <i>not</i> exposing it as inheritable for child threads.\n\t * @param locale the current Locale, or {@code null} to reset\n\t * the locale part of thread-bound context\n\t * @see #setTimeZone(TimeZone)\n\t * @see SimpleLocaleContext#SimpleLocaleContext(Locale)\n\t */\n\tpublic static void setLocale(@Nullable Locale locale) {\n\t\tsetLocale(locale, false);\n\t}\n\n\t/**\n\t * Associate the given Locale with the current thread,\n\t * preserving any TimeZone that may have been set already.\n\t * <p>Will implicitly create a LocaleContext for the given Locale.\n\t * @param locale the current Locale, or {@code null} to reset\n\t * the locale part of thread-bound context\n\t * @param inheritable whether to expose the LocaleContext as inheritable\n\t * for child threads (using an {@link InheritableThreadLocal})\n\t * @see #setTimeZone(TimeZone, boolean)\n\t * @see SimpleLocaleContext#SimpleLocaleContext(Locale)\n\t */\n\tpublic static void setLocale(@Nullable Locale locale, boolean inheritable) {\n\t\tLocaleContext localeContext = getLocaleContext();\n\t\tTimeZone timeZone = (localeContext instanceof TimeZoneAwareLocaleContext timeZoneAware ?\n\t\t\t\ttimeZoneAware.getTimeZone() : null);\n\t\tif (timeZone != null) {\n\t\t\tlocaleContext = new SimpleTimeZoneAwareLocaleContext(locale, timeZone);\n\t\t}\n\t\telse if (locale != null) {\n\t\t\tlocaleContext = new SimpleLocaleContext(locale);\n\t\t}\n\t\telse {\n\t\t\tlocaleContext = null;\n\t\t}\n\t\tsetLocaleContext(localeContext, inheritable);\n\t}\n\n\t/**\n\t * Set a shared default locale at the framework level,\n\t * as an alternative to the JVM-wide default locale.\n\t * <p><b>NOTE:</b> This can be useful to set an application-level\n\t * default locale which differs from the JVM-wide default locale.\n\t * However, this requires each such application to operate against\n\t * locally deployed Spring Framework jars. Do not deploy Spring\n\t * as a shared library at the server level in such a scenario!\n\t * @param locale the default locale (or {@code null} for none,\n\t * letting lookups fall back to {@link Locale#getDefault()})\n\t * @since 4.3.5\n\t * @see #getLocale()\n\t * @see Locale#getDefault()\n\t */\n\tpublic static void setDefaultLocale(@Nullable Locale locale) {\n\t\tLocaleContextHolder.defaultLocale = locale;\n\t}\n\n\t/**\n\t * Return the Locale associated with the current thread, if any,\n\t * or the system default Locale otherwise. This is effectively a\n\t * replacement for {@link java.util.Locale#getDefault()},\n\t * able to optionally respect a user-level Locale setting.\n\t * <p>Note: This method has a fallback to the shared default Locale,\n\t * either at the framework level or at the JVM-wide system level.\n\t * If you'd like to check for the raw LocaleContext content\n\t * (which may indicate no specific locale through {@code null}, use\n\t * {@link #getLocaleContext()} and call {@link LocaleContext#getLocale()}\n\t * @return the current Locale, or the system default Locale if no\n\t * specific Locale has been associated with the current thread\n\t * @see #getLocaleContext()\n\t * @see LocaleContext#getLocale()\n\t * @see #setDefaultLocale(Locale)\n\t * @see java.util.Locale#getDefault()\n\t */\n\tpublic static Locale getLocale() {\n\t\treturn getLocale(getLocaleContext());\n\t}\n\n\t/**\n\t * Return the Locale associated with the given user context, if any,\n\t * or the system default Locale otherwise. This is effectively a\n\t * replacement for {@link java.util.Locale#getDefault()},\n\t * able to optionally respect a user-level Locale setting.\n\t * @param localeContext the user-level locale context to check\n\t * @return the current Locale, or the system default Locale if no\n\t * specific Locale has been associated with the current thread\n\t * @since 5.0\n\t * @see #getLocale()\n\t * @see LocaleContext#getLocale()\n\t * @see #setDefaultLocale(Locale)\n\t * @see java.util.Locale#getDefault()\n\t */\n\tpublic static Locale getLocale(@Nullable LocaleContext localeContext) {\n\t\tif (localeContext != null) {\n\t\t\tLocale locale = localeContext.getLocale();\n\t\t\tif (locale != null) {\n\t\t\t\treturn locale;\n\t\t\t}\n\t\t}\n\t\treturn (defaultLocale != null ? defaultLocale : Locale.getDefault());\n\t}\n\n\t/**\n\t * Associate the given TimeZone with the current thread,\n\t * preserving any Locale that may have been set already.\n\t * <p>Will implicitly create a LocaleContext for the given Locale,\n\t * <i>not</i> exposing it as inheritable for child threads.\n\t * @param timeZone the current TimeZone, or {@code null} to reset\n\t * the time zone part of the thread-bound context\n\t * @see #setLocale(Locale)\n\t * @see SimpleTimeZoneAwareLocaleContext#SimpleTimeZoneAwareLocaleContext(Locale, TimeZone)\n\t */\n\tpublic static void setTimeZone(@Nullable TimeZone timeZone) {\n\t\tsetTimeZone(timeZone, false);\n\t}\n\n\t/**\n\t * Associate the given TimeZone with the current thread,\n\t * preserving any Locale that may have been set already.\n\t * <p>Will implicitly create a LocaleContext for the given Locale.\n\t * @param timeZone the current TimeZone, or {@code null} to reset\n\t * the time zone part of the thread-bound context\n\t * @param inheritable whether to expose the LocaleContext as inheritable\n\t * for child threads (using an {@link InheritableThreadLocal})\n\t * @see #setLocale(Locale, boolean)\n\t * @see SimpleTimeZoneAwareLocaleContext#SimpleTimeZoneAwareLocaleContext(Locale, TimeZone)\n\t */\n\tpublic static void setTimeZone(@Nullable TimeZone timeZone, boolean inheritable) {\n\t\tLocaleContext localeContext = getLocaleContext();\n\t\tLocale locale = (localeContext != null ? localeContext.getLocale() : null);\n\t\tif (timeZone != null) {\n\t\t\tlocaleContext = new SimpleTimeZoneAwareLocaleContext(locale, timeZone);\n\t\t}\n\t\telse if (locale != null) {\n\t\t\tlocaleContext = new SimpleLocaleContext(locale);\n\t\t}\n\t\telse {\n\t\t\tlocaleContext = null;\n\t\t}\n\t\tsetLocaleContext(localeContext, inheritable);\n\t}\n\n\t/**\n\t * Set a shared default time zone at the framework level,\n\t * as an alternative to the JVM-wide default time zone.\n\t * <p><b>NOTE:</b> This can be useful to set an application-level\n\t * default time zone which differs from the JVM-wide default time zone.\n\t * However, this requires each such application to operate against\n\t * locally deployed Spring Framework jars. Do not deploy Spring\n\t * as a shared library at the server level in such a scenario!\n\t * @param timeZone the default time zone (or {@code null} for none,\n\t * letting lookups fall back to {@link TimeZone#getDefault()})\n\t * @since 4.3.5\n\t * @see #getTimeZone()\n\t * @see TimeZone#getDefault()\n\t */\n\tpublic static void setDefaultTimeZone(@Nullable TimeZone timeZone) {\n\t\tdefaultTimeZone = timeZone;\n\t}\n\n\t/**\n\t * Return the TimeZone associated with the current thread, if any,\n\t * or the system default TimeZone otherwise. This is effectively a\n\t * replacement for {@link java.util.TimeZone#getDefault()},\n\t * able to optionally respect a user-level TimeZone setting.\n\t * <p>Note: This method has a fallback to the shared default TimeZone,\n\t * either at the framework level or at the JVM-wide system level.\n\t * If you'd like to check for the raw LocaleContext content\n\t * (which may indicate no specific time zone through {@code null}), use\n\t * {@link #getLocaleContext()} and call {@link TimeZoneAwareLocaleContext#getTimeZone()}\n\t * after downcasting to {@link TimeZoneAwareLocaleContext}.\n\t * @return the current TimeZone, or the system default TimeZone if no\n\t * specific TimeZone has been associated with the current thread\n\t * @see #getLocaleContext()\n\t * @see TimeZoneAwareLocaleContext#getTimeZone()\n\t * @see #setDefaultTimeZone(TimeZone)\n\t * @see java.util.TimeZone#getDefault()\n\t */\n\tpublic static TimeZone getTimeZone() {\n\t\treturn getTimeZone(getLocaleContext());\n\t}\n\n\t/**\n\t * Return the TimeZone associated with the given user context, if any,\n\t * or the system default TimeZone otherwise. This is effectively a\n\t * replacement for {@link java.util.TimeZone#getDefault()},\n\t * able to optionally respect a user-level TimeZone setting.\n\t * @param localeContext the user-level locale context to check\n\t * @return the current TimeZone, or the system default TimeZone if no\n\t * specific TimeZone has been associated with the current thread\n\t * @since 5.0\n\t * @see #getTimeZone()\n\t * @see TimeZoneAwareLocaleContext#getTimeZone()\n\t * @see #setDefaultTimeZone(TimeZone)\n\t * @see java.util.TimeZone#getDefault()\n\t */\n\tpublic static TimeZone getTimeZone(@Nullable LocaleContext localeContext) {\n\t\tif (localeContext instanceof TimeZoneAwareLocaleContext timeZoneAware) {\n\t\t\tTimeZone timeZone = timeZoneAware.getTimeZone();\n\t\t\tif (timeZone != null) {\n\t\t\t\treturn timeZone;\n\t\t\t}\n\t\t}\n\t\treturn (defaultTimeZone != null ? defaultTimeZone : TimeZone.getDefault());\n\t}\n\n}"
  },
  "org.springframework.context.i18n.LocaleContextHolder#getLocale()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the Locale associated with the current thread, if any,\n\t * or the system default Locale otherwise. This is effectively a\n\t * replacement for {@link java.util.Locale#getDefault()},\n\t * able to optionally respect a user-level Locale setting.\n\t * <p>Note: This method has a fallback to the shared default Locale,\n\t * either at the framework level or at the JVM-wide system level.\n\t * If you'd like to check for the raw LocaleContext content\n\t * (which may indicate no specific locale through {@code null}, use\n\t * {@link #getLocaleContext()} and call {@link LocaleContext#getLocale()}\n\t * @return the current Locale, or the system default Locale if no\n\t * specific Locale has been associated with the current thread\n\t * @see #getLocaleContext()\n\t * @see LocaleContext#getLocale()\n\t * @see #setDefaultLocale(Locale)\n\t * @see java.util.Locale#getDefault()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "Locale",
    "signature": "public Locale getLocale()",
    "source_code": "\tpublic static Locale getLocale() {\n\t\treturn getLocale(getLocaleContext());\n\t}"
  },
  "org.springframework.context.i18n.LocaleContextHolder#getLocale(localeContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the Locale associated with the given user context, if any,\n\t * or the system default Locale otherwise. This is effectively a\n\t * replacement for {@link java.util.Locale#getDefault()},\n\t * able to optionally respect a user-level Locale setting.\n\t * @param localeContext the user-level locale context to check\n\t * @return the current Locale, or the system default Locale if no\n\t * specific Locale has been associated with the current thread\n\t * @since 5.0\n\t * @see #getLocale()\n\t * @see LocaleContext#getLocale()\n\t * @see #setDefaultLocale(Locale)\n\t * @see java.util.Locale#getDefault()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "localeContext"
    ],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "Locale",
    "signature": "public Locale getLocale(@Nullable LocaleContext localeContext)",
    "source_code": "\tpublic static Locale getLocale(@Nullable LocaleContext localeContext) {\n\t\tif (localeContext != null) {\n\t\t\tLocale locale = localeContext.getLocale();\n\t\t\tif (locale != null) {\n\t\t\t\treturn locale;\n\t\t\t}\n\t\t}\n\t\treturn (defaultLocale != null ? defaultLocale : Locale.getDefault());\n\t}"
  },
  "org.springframework.context.i18n.LocaleContextHolder#getLocaleContext()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the LocaleContext associated with the current thread, if any.\n\t * @return the current LocaleContext, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "LocaleContext",
    "signature": "public LocaleContext getLocaleContext()",
    "source_code": "\tpublic static LocaleContext getLocaleContext() {\n\t\tLocaleContext localeContext = localeContextHolder.get();\n\t\tif (localeContext == null) {\n\t\t\tlocaleContext = inheritableLocaleContextHolder.get();\n\t\t}\n\t\treturn localeContext;\n\t}"
  },
  "org.springframework.context.i18n.LocaleContextHolder#getTimeZone()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the TimeZone associated with the current thread, if any,\n\t * or the system default TimeZone otherwise. This is effectively a\n\t * replacement for {@link java.util.TimeZone#getDefault()},\n\t * able to optionally respect a user-level TimeZone setting.\n\t * <p>Note: This method has a fallback to the shared default TimeZone,\n\t * either at the framework level or at the JVM-wide system level.\n\t * If you'd like to check for the raw LocaleContext content\n\t * (which may indicate no specific time zone through {@code null}), use\n\t * {@link #getLocaleContext()} and call {@link TimeZoneAwareLocaleContext#getTimeZone()}\n\t * after downcasting to {@link TimeZoneAwareLocaleContext}.\n\t * @return the current TimeZone, or the system default TimeZone if no\n\t * specific TimeZone has been associated with the current thread\n\t * @see #getLocaleContext()\n\t * @see TimeZoneAwareLocaleContext#getTimeZone()\n\t * @see #setDefaultTimeZone(TimeZone)\n\t * @see java.util.TimeZone#getDefault()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "TimeZone",
    "signature": "public TimeZone getTimeZone()",
    "source_code": "\tpublic static TimeZone getTimeZone() {\n\t\treturn getTimeZone(getLocaleContext());\n\t}"
  },
  "org.springframework.context.i18n.LocaleContextHolder#getTimeZone(localeContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the TimeZone associated with the given user context, if any,\n\t * or the system default TimeZone otherwise. This is effectively a\n\t * replacement for {@link java.util.TimeZone#getDefault()},\n\t * able to optionally respect a user-level TimeZone setting.\n\t * @param localeContext the user-level locale context to check\n\t * @return the current TimeZone, or the system default TimeZone if no\n\t * specific TimeZone has been associated with the current thread\n\t * @since 5.0\n\t * @see #getTimeZone()\n\t * @see TimeZoneAwareLocaleContext#getTimeZone()\n\t * @see #setDefaultTimeZone(TimeZone)\n\t * @see java.util.TimeZone#getDefault()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "localeContext"
    ],
    "position": {
      "column": 1,
      "line": 326
    },
    "return": "TimeZone",
    "signature": "public TimeZone getTimeZone(@Nullable LocaleContext localeContext)",
    "source_code": "\tpublic static TimeZone getTimeZone(@Nullable LocaleContext localeContext) {\n\t\tif (localeContext instanceof TimeZoneAwareLocaleContext timeZoneAware) {\n\t\t\tTimeZone timeZone = timeZoneAware.getTimeZone();\n\t\t\tif (timeZone != null) {\n\t\t\t\treturn timeZone;\n\t\t\t}\n\t\t}\n\t\treturn (defaultTimeZone != null ? defaultTimeZone : TimeZone.getDefault());\n\t}"
  },
  "org.springframework.context.i18n.LocaleContextHolder#resetLocaleContext()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Reset the LocaleContext for the current thread.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "public void resetLocaleContext()",
    "source_code": "\tpublic static void resetLocaleContext() {\n\t\tlocaleContextHolder.remove();\n\t\tinheritableLocaleContextHolder.remove();\n\t}"
  },
  "org.springframework.context.i18n.LocaleContextHolder#setDefaultLocale(locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a shared default locale at the framework level,\n\t * as an alternative to the JVM-wide default locale.\n\t * <p><b>NOTE:</b> This can be useful to set an application-level\n\t * default locale which differs from the JVM-wide default locale.\n\t * However, this requires each such application to operate against\n\t * locally deployed Spring Framework jars. Do not deploy Spring\n\t * as a shared library at the server level in such a scenario!\n\t * @param locale the default locale (or {@code null} for none,\n\t * letting lookups fall back to {@link Locale#getDefault()})\n\t * @since 4.3.5\n\t * @see #getLocale()\n\t * @see Locale#getDefault()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "void",
    "signature": "public void setDefaultLocale(@Nullable Locale locale)",
    "source_code": "\tpublic static void setDefaultLocale(@Nullable Locale locale) {\n\t\tLocaleContextHolder.defaultLocale = locale;\n\t}"
  },
  "org.springframework.context.i18n.LocaleContextHolder#setDefaultTimeZone(timeZone)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a shared default time zone at the framework level,\n\t * as an alternative to the JVM-wide default time zone.\n\t * <p><b>NOTE:</b> This can be useful to set an application-level\n\t * default time zone which differs from the JVM-wide default time zone.\n\t * However, this requires each such application to operate against\n\t * locally deployed Spring Framework jars. Do not deploy Spring\n\t * as a shared library at the server level in such a scenario!\n\t * @param timeZone the default time zone (or {@code null} for none,\n\t * letting lookups fall back to {@link TimeZone#getDefault()})\n\t * @since 4.3.5\n\t * @see #getTimeZone()\n\t * @see TimeZone#getDefault()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeZone"
    ],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "void",
    "signature": "public void setDefaultTimeZone(@Nullable TimeZone timeZone)",
    "source_code": "\tpublic static void setDefaultTimeZone(@Nullable TimeZone timeZone) {\n\t\tdefaultTimeZone = timeZone;\n\t}"
  },
  "org.springframework.context.i18n.LocaleContextHolder#setLocale(locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Associate the given Locale with the current thread,\n\t * preserving any TimeZone that may have been set already.\n\t * <p>Will implicitly create a LocaleContext for the given Locale,\n\t * <i>not</i> exposing it as inheritable for child threads.\n\t * @param locale the current Locale, or {@code null} to reset\n\t * the locale part of thread-bound context\n\t * @see #setTimeZone(TimeZone)\n\t * @see SimpleLocaleContext#SimpleLocaleContext(Locale)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "void",
    "signature": "public void setLocale(@Nullable Locale locale)",
    "source_code": "\tpublic static void setLocale(@Nullable Locale locale) {\n\t\tsetLocale(locale, false);\n\t}"
  },
  "org.springframework.context.i18n.LocaleContextHolder#setLocale(locale,inheritable)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Associate the given Locale with the current thread,\n\t * preserving any TimeZone that may have been set already.\n\t * <p>Will implicitly create a LocaleContext for the given Locale.\n\t * @param locale the current Locale, or {@code null} to reset\n\t * the locale part of thread-bound context\n\t * @param inheritable whether to expose the LocaleContext as inheritable\n\t * for child threads (using an {@link InheritableThreadLocal})\n\t * @see #setTimeZone(TimeZone, boolean)\n\t * @see SimpleLocaleContext#SimpleLocaleContext(Locale)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locale",
      "inheritable"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "void",
    "signature": "public void setLocale(@Nullable Locale locale, boolean inheritable)",
    "source_code": "\tpublic static void setLocale(@Nullable Locale locale, boolean inheritable) {\n\t\tLocaleContext localeContext = getLocaleContext();\n\t\tTimeZone timeZone = (localeContext instanceof TimeZoneAwareLocaleContext timeZoneAware ?\n\t\t\t\ttimeZoneAware.getTimeZone() : null);\n\t\tif (timeZone != null) {\n\t\t\tlocaleContext = new SimpleTimeZoneAwareLocaleContext(locale, timeZone);\n\t\t}\n\t\telse if (locale != null) {\n\t\t\tlocaleContext = new SimpleLocaleContext(locale);\n\t\t}\n\t\telse {\n\t\t\tlocaleContext = null;\n\t\t}\n\t\tsetLocaleContext(localeContext, inheritable);\n\t}"
  },
  "org.springframework.context.i18n.LocaleContextHolder#setLocaleContext(localeContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Associate the given LocaleContext with the current thread,\n\t * <i>not</i> exposing it as inheritable for child threads.\n\t * <p>The given LocaleContext may be a {@link TimeZoneAwareLocaleContext},\n\t * containing a locale with associated time zone information.\n\t * @param localeContext the current LocaleContext,\n\t * or {@code null} to reset the thread-bound context\n\t * @see SimpleLocaleContext\n\t * @see SimpleTimeZoneAwareLocaleContext\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "localeContext"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "void",
    "signature": "public void setLocaleContext(@Nullable LocaleContext localeContext)",
    "source_code": "\tpublic static void setLocaleContext(@Nullable LocaleContext localeContext) {\n\t\tsetLocaleContext(localeContext, false);\n\t}"
  },
  "org.springframework.context.i18n.LocaleContextHolder#setLocaleContext(localeContext,inheritable)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Associate the given LocaleContext with the current thread.\n\t * <p>The given LocaleContext may be a {@link TimeZoneAwareLocaleContext},\n\t * containing a locale with associated time zone information.\n\t * @param localeContext the current LocaleContext,\n\t * or {@code null} to reset the thread-bound context\n\t * @param inheritable whether to expose the LocaleContext as inheritable\n\t * for child threads (using an {@link InheritableThreadLocal})\n\t * @see SimpleLocaleContext\n\t * @see SimpleTimeZoneAwareLocaleContext\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "localeContext",
      "inheritable"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "void",
    "signature": "public void setLocaleContext(@Nullable LocaleContext localeContext, boolean inheritable)",
    "source_code": "\tpublic static void setLocaleContext(@Nullable LocaleContext localeContext, boolean inheritable) {\n\t\tif (localeContext == null) {\n\t\t\tresetLocaleContext();\n\t\t}\n\t\telse {\n\t\t\tif (inheritable) {\n\t\t\t\tinheritableLocaleContextHolder.set(localeContext);\n\t\t\t\tlocaleContextHolder.remove();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlocaleContextHolder.set(localeContext);\n\t\t\t\tinheritableLocaleContextHolder.remove();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.context.i18n.LocaleContextHolder#setTimeZone(timeZone)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Associate the given TimeZone with the current thread,\n\t * preserving any Locale that may have been set already.\n\t * <p>Will implicitly create a LocaleContext for the given Locale,\n\t * <i>not</i> exposing it as inheritable for child threads.\n\t * @param timeZone the current TimeZone, or {@code null} to reset\n\t * the time zone part of the thread-bound context\n\t * @see #setLocale(Locale)\n\t * @see SimpleTimeZoneAwareLocaleContext#SimpleTimeZoneAwareLocaleContext(Locale, TimeZone)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeZone"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "void",
    "signature": "public void setTimeZone(@Nullable TimeZone timeZone)",
    "source_code": "\tpublic static void setTimeZone(@Nullable TimeZone timeZone) {\n\t\tsetTimeZone(timeZone, false);\n\t}"
  },
  "org.springframework.context.i18n.LocaleContextHolder#setTimeZone(timeZone,inheritable)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Associate the given TimeZone with the current thread,\n\t * preserving any Locale that may have been set already.\n\t * <p>Will implicitly create a LocaleContext for the given Locale.\n\t * @param timeZone the current TimeZone, or {@code null} to reset\n\t * the time zone part of the thread-bound context\n\t * @param inheritable whether to expose the LocaleContext as inheritable\n\t * for child threads (using an {@link InheritableThreadLocal})\n\t * @see #setLocale(Locale, boolean)\n\t * @see SimpleTimeZoneAwareLocaleContext#SimpleTimeZoneAwareLocaleContext(Locale, TimeZone)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeZone",
      "inheritable"
    ],
    "position": {
      "column": 1,
      "line": 257
    },
    "return": "void",
    "signature": "public void setTimeZone(@Nullable TimeZone timeZone, boolean inheritable)",
    "source_code": "\tpublic static void setTimeZone(@Nullable TimeZone timeZone, boolean inheritable) {\n\t\tLocaleContext localeContext = getLocaleContext();\n\t\tLocale locale = (localeContext != null ? localeContext.getLocale() : null);\n\t\tif (timeZone != null) {\n\t\t\tlocaleContext = new SimpleTimeZoneAwareLocaleContext(locale, timeZone);\n\t\t}\n\t\telse if (locale != null) {\n\t\t\tlocaleContext = new SimpleLocaleContext(locale);\n\t\t}\n\t\telse {\n\t\t\tlocaleContext = null;\n\t\t}\n\t\tsetLocaleContext(localeContext, inheritable);\n\t}"
  },
  "org.springframework.context.index.processor.CandidateComponentsIndexer": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Annotation {@link Processor} that writes a {@link CandidateComponentsMetadata}\n * file for spring components.\n *\n * @author Stephane Nicoll\n * @author Juergen Hoeller\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "signature": "public class CandidateComponentsIndexer",
    "source_code": "public class CandidateComponentsIndexer implements Processor {\n\n\tprivate MetadataStore metadataStore;\n\n\tprivate MetadataCollector metadataCollector;\n\n\tprivate TypeHelper typeHelper;\n\n\tprivate List<StereotypesProvider> stereotypesProviders;\n\n\n\t@Override\n\tpublic Set<String> getSupportedOptions() {\n\t\treturn Collections.emptySet();\n\t}\n\n\t@Override\n\tpublic Set<String> getSupportedAnnotationTypes() {\n\t\treturn Collections.singleton(\"*\");\n\t}\n\n\t@Override\n\tpublic SourceVersion getSupportedSourceVersion() {\n\t\treturn SourceVersion.latest();\n\t}\n\n\t@Override\n\tpublic synchronized void init(ProcessingEnvironment env) {\n\t\tthis.stereotypesProviders = getStereotypesProviders(env);\n\t\tthis.typeHelper = new TypeHelper(env);\n\t\tthis.metadataStore = new MetadataStore(env);\n\t\tthis.metadataCollector = new MetadataCollector(env, this.metadataStore.readMetadata());\n\t}\n\n\t@Override\n\tpublic boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n\t\tthis.metadataCollector.processing(roundEnv);\n\t\troundEnv.getRootElements().forEach(this::processElement);\n\t\tif (roundEnv.processingOver()) {\n\t\t\twriteMetaData();\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Iterable<? extends Completion> getCompletions(\n\t\t\tElement element, AnnotationMirror annotation, ExecutableElement member, String userText) {\n\n\t\treturn Collections.emptyList();\n\t}\n\n\n\tprivate List<StereotypesProvider> getStereotypesProviders(ProcessingEnvironment env) {\n\t\tList<StereotypesProvider> result = new ArrayList<>();\n\t\tTypeHelper typeHelper = new TypeHelper(env);\n\t\tresult.add(new IndexedStereotypesProvider(typeHelper));\n\t\tresult.add(new StandardStereotypesProvider(typeHelper));\n\t\tresult.add(new PackageInfoStereotypesProvider());\n\t\treturn result;\n\t}\n\n\tprivate void processElement(Element element) {\n\t\taddMetadataFor(element);\n\t\tstaticTypesIn(element.getEnclosedElements()).forEach(this::processElement);\n\t}\n\n\tprivate void addMetadataFor(Element element) {\n\t\tSet<String> stereotypes = new LinkedHashSet<>();\n\t\tthis.stereotypesProviders.forEach(p -> stereotypes.addAll(p.getStereotypes(element)));\n\t\tif (!stereotypes.isEmpty()) {\n\t\t\tthis.metadataCollector.add(new ItemMetadata(this.typeHelper.getType(element), stereotypes));\n\t\t}\n\t}\n\n\tprivate void writeMetaData() {\n\t\tCandidateComponentsMetadata metadata = this.metadataCollector.getMetadata();\n\t\tif (!metadata.getItems().isEmpty()) {\n\t\t\ttry {\n\t\t\t\tthis.metadataStore.writeMetadata(metadata);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new IllegalStateException(\"Failed to write metadata\", ex);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static List<TypeElement> staticTypesIn(Iterable<? extends Element> elements) {\n\t\tList<TypeElement> list = new ArrayList<>();\n\t\tfor (Element element : elements) {\n\t\t\tif ((element.getKind().isClass() || element.getKind() == ElementKind.INTERFACE) &&\n\t\t\t\t\telement.getModifiers().contains(Modifier.STATIC) && element instanceof TypeElement te) {\n\t\t\t\tlist.add(te);\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\n}"
  },
  "org.springframework.context.index.processor.CandidateComponentsIndexer#getSupportedAnnotationTypes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "Set<String>",
    "signature": "public Set<String> getSupportedAnnotationTypes()",
    "source_code": "\tpublic Set<String> getSupportedAnnotationTypes() {\n\t\treturn Collections.singleton(\"*\");\n\t}"
  },
  "org.springframework.context.index.processor.CandidateComponentsIndexer#getSupportedOptions()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "Set<String>",
    "signature": "public Set<String> getSupportedOptions()",
    "source_code": "\tpublic Set<String> getSupportedOptions() {\n\t\treturn Collections.emptySet();\n\t}"
  },
  "org.springframework.context.index.processor.CandidateComponentsIndexer#getSupportedSourceVersion()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "SourceVersion",
    "signature": "public SourceVersion getSupportedSourceVersion()",
    "source_code": "\tpublic SourceVersion getSupportedSourceVersion() {\n\t\treturn SourceVersion.latest();\n\t}"
  },
  "org.springframework.context.index.processor.CandidateComponentsIndexer#init(env)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "env"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "void",
    "signature": "public void init(ProcessingEnvironment env)",
    "source_code": "\tpublic synchronized void init(ProcessingEnvironment env) {\n\t\tthis.stereotypesProviders = getStereotypesProviders(env);\n\t\tthis.typeHelper = new TypeHelper(env);\n\t\tthis.metadataStore = new MetadataStore(env);\n\t\tthis.metadataCollector = new MetadataCollector(env, this.metadataStore.readMetadata());\n\t}"
  },
  "org.springframework.context.index.processor.CandidateComponentsIndexer#process(annotations,roundEnv)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotations",
      "roundEnv"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "boolean",
    "signature": "public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv)",
    "source_code": "\tpublic boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n\t\tthis.metadataCollector.processing(roundEnv);\n\t\troundEnv.getRootElements().forEach(this::processElement);\n\t\tif (roundEnv.processingOver()) {\n\t\t\twriteMetaData();\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.context.weaving.DefaultContextLoadTimeWeaver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Default {@link LoadTimeWeaver} bean for use in an application context,\n * decorating an automatically detected internal {@code LoadTimeWeaver}.\n *\n * <p>Typically registered for the default bean name \"{@code loadTimeWeaver}\";\n * the most convenient way to achieve this is Spring's\n * {@code <context:load-time-weaver>} XML tag or {@code @EnableLoadTimeWeaving}\n * on a {@code @Configuration} class.\n *\n * <p>This class implements a runtime environment check for obtaining the\n * appropriate weaver implementation, including\n * {@link InstrumentationSavingAgent Spring's VM agent} and any {@link ClassLoader}\n * supported by Spring's {@link ReflectiveLoadTimeWeaver}.\n *\n * @author Juergen Hoeller\n * @author Ramnivas Laddad\n * @author Costin Leau\n * @since 2.5\n * @see org.springframework.context.ConfigurableApplicationContext#LOAD_TIME_WEAVER_BEAN_NAME\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "signature": "public class DefaultContextLoadTimeWeaver",
    "source_code": "public class DefaultContextLoadTimeWeaver implements LoadTimeWeaver, BeanClassLoaderAware, DisposableBean {\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\t@Nullable\n\tprivate LoadTimeWeaver loadTimeWeaver;\n\n\n\tpublic DefaultContextLoadTimeWeaver() {\n\t}\n\n\tpublic DefaultContextLoadTimeWeaver(ClassLoader beanClassLoader) {\n\t\tsetBeanClassLoader(beanClassLoader);\n\t}\n\n\n\t@Override\n\tpublic void setBeanClassLoader(ClassLoader classLoader) {\n\t\tLoadTimeWeaver serverSpecificLoadTimeWeaver = createServerSpecificLoadTimeWeaver(classLoader);\n\t\tif (serverSpecificLoadTimeWeaver != null) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Determined server-specific load-time weaver: \" +\n\t\t\t\t\t\tserverSpecificLoadTimeWeaver.getClass().getName());\n\t\t\t}\n\t\t\tthis.loadTimeWeaver = serverSpecificLoadTimeWeaver;\n\t\t}\n\t\telse if (InstrumentationLoadTimeWeaver.isInstrumentationAvailable()) {\n\t\t\tlogger.debug(\"Found Spring's JVM agent for instrumentation\");\n\t\t\tthis.loadTimeWeaver = new InstrumentationLoadTimeWeaver(classLoader);\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tthis.loadTimeWeaver = new ReflectiveLoadTimeWeaver(classLoader);\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Using reflective load-time weaver for class loader: \" +\n\t\t\t\t\t\t\tthis.loadTimeWeaver.getInstrumentableClassLoader().getClass().getName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\tthrow new IllegalStateException(ex.getMessage() + \" Specify a custom LoadTimeWeaver or start your \" +\n\t\t\t\t\t\t\"Java virtual machine with Spring's agent: -javaagent:spring-instrument-{version}.jar\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * This method never fails, allowing to try other possible ways to use a\n\t * server-agnostic weaver. This non-failure logic is required since\n\t * determining a load-time weaver based on the ClassLoader name alone may\n\t * legitimately fail due to other mismatches.\n\t */\n\t@Nullable\n\tprotected LoadTimeWeaver createServerSpecificLoadTimeWeaver(ClassLoader classLoader) {\n\t\tString name = classLoader.getClass().getName();\n\t\ttry {\n\t\t\tif (name.startsWith(\"org.apache.catalina\")) {\n\t\t\t\treturn new TomcatLoadTimeWeaver(classLoader);\n\t\t\t}\n\t\t\telse if (name.startsWith(\"org.glassfish\")) {\n\t\t\t\treturn new GlassFishLoadTimeWeaver(classLoader);\n\t\t\t}\n\t\t\telse if (name.startsWith(\"org.jboss.modules\")) {\n\t\t\t\treturn new JBossLoadTimeWeaver(classLoader);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(\"Could not obtain server-specific LoadTimeWeaver: \" + ex.getMessage());\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void destroy() {\n\t\tif (this.loadTimeWeaver instanceof InstrumentationLoadTimeWeaver iltw) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Removing all registered transformers for class loader: \" +\n\t\t\t\t\t\tthis.loadTimeWeaver.getInstrumentableClassLoader().getClass().getName());\n\t\t\t}\n\t\t\tiltw.removeTransformers();\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic void addTransformer(ClassFileTransformer transformer) {\n\t\tAssert.state(this.loadTimeWeaver != null, \"Not initialized\");\n\t\tthis.loadTimeWeaver.addTransformer(transformer);\n\t}\n\n\t@Override\n\tpublic ClassLoader getInstrumentableClassLoader() {\n\t\tAssert.state(this.loadTimeWeaver != null, \"Not initialized\");\n\t\treturn this.loadTimeWeaver.getInstrumentableClassLoader();\n\t}\n\n\t@Override\n\tpublic ClassLoader getThrowawayClassLoader() {\n\t\tAssert.state(this.loadTimeWeaver != null, \"Not initialized\");\n\t\treturn this.loadTimeWeaver.getThrowawayClassLoader();\n\t}\n\n}"
  },
  "org.springframework.context.weaving.DefaultContextLoadTimeWeaver#addTransformer(transformer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "transformer"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "void",
    "signature": "public void addTransformer(ClassFileTransformer transformer)",
    "source_code": "\tpublic void addTransformer(ClassFileTransformer transformer) {\n\t\tAssert.state(this.loadTimeWeaver != null, \"Not initialized\");\n\t\tthis.loadTimeWeaver.addTransformer(transformer);\n\t}"
  },
  "org.springframework.context.weaving.DefaultContextLoadTimeWeaver#createServerSpecificLoadTimeWeaver(classLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Default {@link LoadTimeWeaver} bean for use in an application context,\n * decorating an automatically detected internal {@code LoadTimeWeaver}.\n *\n * <p>Typically registered for the default bean name \"{@code loadTimeWeaver}\";\n * the most convenient way to achieve this is Spring's\n * {@code <context:load-time-weaver>} XML tag or {@code @EnableLoadTimeWeaving}\n * on a {@code @Configuration} class.\n *\n * <p>This class implements a runtime environment check for obtaining the\n * appropriate weaver implementation, including\n * {@link InstrumentationSavingAgent Spring's VM agent} and any {@link ClassLoader}\n * supported by Spring's {@link ReflectiveLoadTimeWeaver}.\n *\n * @author Juergen Hoeller\n * @author Ramnivas Laddad\n * @author Costin Leau\n * @since 2.5\n * @see org.springframework.context.ConfigurableApplicationContext#LOAD_TIME_WEAVER_BEAN_NAME\n */\npublic class DefaultContextLoadTimeWeaver implements LoadTimeWeaver, BeanClassLoaderAware, DisposableBean {\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\t@Nullable\n\tprivate LoadTimeWeaver loadTimeWeaver;\n\n\n\tpublic DefaultContextLoadTimeWeaver() {\n\t}\n\n\tpublic DefaultContextLoadTimeWeaver(ClassLoader beanClassLoader) {\n\t\tsetBeanClassLoader(beanClassLoader);\n\t}\n\n\n\t@Override\n\tpublic void setBeanClassLoader(ClassLoader classLoader) {\n\t\tLoadTimeWeaver serverSpecificLoadTimeWeaver = createServerSpecificLoadTimeWeaver(classLoader);\n\t\tif (serverSpecificLoadTimeWeaver != null) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Determined server-specific load-time weaver: \" +\n\t\t\t\t\t\tserverSpecificLoadTimeWeaver.getClass().getName());\n\t\t\t}\n\t\t\tthis.loadTimeWeaver = serverSpecificLoadTimeWeaver;\n\t\t}\n\t\telse if (InstrumentationLoadTimeWeaver.isInstrumentationAvailable()) {\n\t\t\tlogger.debug(\"Found Spring's JVM agent for instrumentation\");\n\t\t\tthis.loadTimeWeaver = new InstrumentationLoadTimeWeaver(classLoader);\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tthis.loadTimeWeaver = new ReflectiveLoadTimeWeaver(classLoader);\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Using reflective load-time weaver for class loader: \" +\n\t\t\t\t\t\t\tthis.loadTimeWeaver.getInstrumentableClassLoader().getClass().getName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\tthrow new IllegalStateException(ex.getMessage() + \" Specify a custom LoadTimeWeaver or start your \" +\n\t\t\t\t\t\t\"Java virtual machine with Spring's agent: -javaagent:spring-instrument-{version}.jar\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * This method never fails, allowing to try other possible ways to use a\n\t * server-agnostic weaver. This non-failure logic is required since\n\t * determining a load-time weaver based on the ClassLoader name alone may\n\t * legitimately fail due to other mismatches.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "LoadTimeWeaver",
    "signature": "protected LoadTimeWeaver createServerSpecificLoadTimeWeaver(ClassLoader classLoader)",
    "source_code": "\tprotected LoadTimeWeaver createServerSpecificLoadTimeWeaver(ClassLoader classLoader) {\n\t\tString name = classLoader.getClass().getName();\n\t\ttry {\n\t\t\tif (name.startsWith(\"org.apache.catalina\")) {\n\t\t\t\treturn new TomcatLoadTimeWeaver(classLoader);\n\t\t\t}\n\t\t\telse if (name.startsWith(\"org.glassfish\")) {\n\t\t\t\treturn new GlassFishLoadTimeWeaver(classLoader);\n\t\t\t}\n\t\t\telse if (name.startsWith(\"org.jboss.modules\")) {\n\t\t\t\treturn new JBossLoadTimeWeaver(classLoader);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(\"Could not obtain server-specific LoadTimeWeaver: \" + ex.getMessage());\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.context.weaving.DefaultContextLoadTimeWeaver#destroy()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "void",
    "signature": "public void destroy()",
    "source_code": "\tpublic void destroy() {\n\t\tif (this.loadTimeWeaver instanceof InstrumentationLoadTimeWeaver iltw) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Removing all registered transformers for class loader: \" +\n\t\t\t\t\t\tthis.loadTimeWeaver.getInstrumentableClassLoader().getClass().getName());\n\t\t\t}\n\t\t\tiltw.removeTransformers();\n\t\t}\n\t}"
  },
  "org.springframework.context.weaving.DefaultContextLoadTimeWeaver#getInstrumentableClassLoader()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "ClassLoader",
    "signature": "public ClassLoader getInstrumentableClassLoader()",
    "source_code": "\tpublic ClassLoader getInstrumentableClassLoader() {\n\t\tAssert.state(this.loadTimeWeaver != null, \"Not initialized\");\n\t\treturn this.loadTimeWeaver.getInstrumentableClassLoader();\n\t}"
  },
  "org.springframework.context.weaving.DefaultContextLoadTimeWeaver#getThrowawayClassLoader()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "ClassLoader",
    "signature": "public ClassLoader getThrowawayClassLoader()",
    "source_code": "\tpublic ClassLoader getThrowawayClassLoader() {\n\t\tAssert.state(this.loadTimeWeaver != null, \"Not initialized\");\n\t\treturn this.loadTimeWeaver.getThrowawayClassLoader();\n\t}"
  },
  "org.springframework.context.weaving.DefaultContextLoadTimeWeaver#setBeanClassLoader(classLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "void",
    "signature": "public void setBeanClassLoader(ClassLoader classLoader)",
    "source_code": "\tpublic void setBeanClassLoader(ClassLoader classLoader) {\n\t\tLoadTimeWeaver serverSpecificLoadTimeWeaver = createServerSpecificLoadTimeWeaver(classLoader);\n\t\tif (serverSpecificLoadTimeWeaver != null) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Determined server-specific load-time weaver: \" +\n\t\t\t\t\t\tserverSpecificLoadTimeWeaver.getClass().getName());\n\t\t\t}\n\t\t\tthis.loadTimeWeaver = serverSpecificLoadTimeWeaver;\n\t\t}\n\t\telse if (InstrumentationLoadTimeWeaver.isInstrumentationAvailable()) {\n\t\t\tlogger.debug(\"Found Spring's JVM agent for instrumentation\");\n\t\t\tthis.loadTimeWeaver = new InstrumentationLoadTimeWeaver(classLoader);\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tthis.loadTimeWeaver = new ReflectiveLoadTimeWeaver(classLoader);\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Using reflective load-time weaver for class loader: \" +\n\t\t\t\t\t\t\tthis.loadTimeWeaver.getInstrumentableClassLoader().getClass().getName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\tthrow new IllegalStateException(ex.getMessage() + \" Specify a custom LoadTimeWeaver or start your \" +\n\t\t\t\t\t\t\"Java virtual machine with Spring's agent: -javaagent:spring-instrument-{version}.jar\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.context.weaving.LoadTimeWeaverAwareProcessor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link org.springframework.beans.factory.config.BeanPostProcessor}\n * implementation that passes the context's default {@link LoadTimeWeaver}\n * to beans that implement the {@link LoadTimeWeaverAware} interface.\n *\n * <p>{@link org.springframework.context.ApplicationContext Application contexts}\n * will automatically register this with their underlying {@link BeanFactory bean factory},\n * provided that a default {@code LoadTimeWeaver} is actually available.\n *\n * <p>Applications should not use this class directly.\n *\n * @author Juergen Hoeller\n * @since 2.5\n * @see LoadTimeWeaverAware\n * @see org.springframework.context.ConfigurableApplicationContext#LOAD_TIME_WEAVER_BEAN_NAME\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "signature": "public class LoadTimeWeaverAwareProcessor",
    "source_code": "public class LoadTimeWeaverAwareProcessor implements BeanPostProcessor, BeanFactoryAware {\n\n\t@Nullable\n\tprivate LoadTimeWeaver loadTimeWeaver;\n\n\t@Nullable\n\tprivate BeanFactory beanFactory;\n\n\n\t/**\n\t * Create a new {@code LoadTimeWeaverAwareProcessor} that will\n\t * auto-retrieve the {@link LoadTimeWeaver} from the containing\n\t * {@link BeanFactory}, expecting a bean named\n\t * {@link ConfigurableApplicationContext#LOAD_TIME_WEAVER_BEAN_NAME \"loadTimeWeaver\"}.\n\t */\n\tpublic LoadTimeWeaverAwareProcessor() {\n\t}\n\n\t/**\n\t * Create a new {@code LoadTimeWeaverAwareProcessor} for the given\n\t * {@link LoadTimeWeaver}.\n\t * <p>If the given {@code loadTimeWeaver} is {@code null}, then a\n\t * {@code LoadTimeWeaver} will be auto-retrieved from the containing\n\t * {@link BeanFactory}, expecting a bean named\n\t * {@link ConfigurableApplicationContext#LOAD_TIME_WEAVER_BEAN_NAME \"loadTimeWeaver\"}.\n\t * @param loadTimeWeaver the specific {@code LoadTimeWeaver} that is to be used\n\t */\n\tpublic LoadTimeWeaverAwareProcessor(@Nullable LoadTimeWeaver loadTimeWeaver) {\n\t\tthis.loadTimeWeaver = loadTimeWeaver;\n\t}\n\n\t/**\n\t * Create a new {@code LoadTimeWeaverAwareProcessor}.\n\t * <p>The {@code LoadTimeWeaver} will be auto-retrieved from\n\t * the given {@link BeanFactory}, expecting a bean named\n\t * {@link ConfigurableApplicationContext#LOAD_TIME_WEAVER_BEAN_NAME \"loadTimeWeaver\"}.\n\t * @param beanFactory the BeanFactory to retrieve the LoadTimeWeaver from\n\t */\n\tpublic LoadTimeWeaverAwareProcessor(BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t}\n\n\n\t@Override\n\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t}\n\n\n\t@Override\n\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n\t\tif (bean instanceof LoadTimeWeaverAware loadTimeWeaverAware) {\n\t\t\tLoadTimeWeaver ltw = this.loadTimeWeaver;\n\t\t\tif (ltw == null) {\n\t\t\t\tAssert.state(this.beanFactory != null,\n\t\t\t\t\t\t\"BeanFactory required if no LoadTimeWeaver explicitly specified\");\n\t\t\t\tltw = this.beanFactory.getBean(\n\t\t\t\t\t\tConfigurableApplicationContext.LOAD_TIME_WEAVER_BEAN_NAME, LoadTimeWeaver.class);\n\t\t\t}\n\t\t\tloadTimeWeaverAware.setLoadTimeWeaver(ltw);\n\t\t}\n\t\treturn bean;\n\t}\n\n\t@Override\n\tpublic Object postProcessAfterInitialization(Object bean, String name) {\n\t\treturn bean;\n\t}\n\n}"
  },
  "org.springframework.context.weaving.LoadTimeWeaverAwareProcessor#postProcessAfterInitialization(bean,name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(Object bean, String name)",
    "source_code": "\tpublic Object postProcessAfterInitialization(Object bean, String name) {\n\t\treturn bean;\n\t}"
  },
  "org.springframework.context.weaving.LoadTimeWeaverAwareProcessor#postProcessBeforeInitialization(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n\t\tif (bean instanceof LoadTimeWeaverAware loadTimeWeaverAware) {\n\t\t\tLoadTimeWeaver ltw = this.loadTimeWeaver;\n\t\t\tif (ltw == null) {\n\t\t\t\tAssert.state(this.beanFactory != null,\n\t\t\t\t\t\t\"BeanFactory required if no LoadTimeWeaver explicitly specified\");\n\t\t\t\tltw = this.beanFactory.getBean(\n\t\t\t\t\t\tConfigurableApplicationContext.LOAD_TIME_WEAVER_BEAN_NAME, LoadTimeWeaver.class);\n\t\t\t}\n\t\t\tloadTimeWeaverAware.setLoadTimeWeaver(ltw);\n\t\t}\n\t\treturn bean;\n\t}"
  },
  "org.springframework.context.weaving.LoadTimeWeaverAwareProcessor#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "void",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t}"
  },
  "org.springframework.context.weaving.logger": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.core.AttributeAccessorSupport": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Support class for {@link AttributeAccessor AttributeAccessors}, providing\n * a base implementation of all methods. To be extended by subclasses.\n *\n * <p>{@link Serializable} if subclasses and all attribute values are {@link Serializable}.\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 2.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 40
    },
    "signature": "public class AttributeAccessorSupport",
    "source_code": "public abstract class AttributeAccessorSupport implements AttributeAccessor, Serializable {\n\n\t/** Map with String keys and Object values. */\n\tprivate final Map<String, Object> attributes = new LinkedHashMap<>();\n\n\n\t@Override\n\tpublic void setAttribute(String name, @Nullable Object value) {\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tif (value != null) {\n\t\t\tthis.attributes.put(name, value);\n\t\t}\n\t\telse {\n\t\t\tremoveAttribute(name);\n\t\t}\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Object getAttribute(String name) {\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\treturn this.attributes.get(name);\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> T computeAttribute(String name, Function<String, T> computeFunction) {\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tAssert.notNull(computeFunction, \"Compute function must not be null\");\n\t\tObject value = this.attributes.computeIfAbsent(name, computeFunction);\n\t\tAssert.state(value != null,\n\t\t\t\t() -> String.format(\"Compute function must not return null for attribute named '%s'\", name));\n\t\treturn (T) value;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Object removeAttribute(String name) {\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\treturn this.attributes.remove(name);\n\t}\n\n\t@Override\n\tpublic boolean hasAttribute(String name) {\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\treturn this.attributes.containsKey(name);\n\t}\n\n\t@Override\n\tpublic String[] attributeNames() {\n\t\treturn StringUtils.toStringArray(this.attributes.keySet());\n\t}\n\n\n\t/**\n\t * Copy the attributes from the supplied AttributeAccessor to this accessor.\n\t * @param source the AttributeAccessor to copy from\n\t */\n\tprotected void copyAttributesFrom(AttributeAccessor source) {\n\t\tAssert.notNull(source, \"Source must not be null\");\n\t\tString[] attributeNames = source.attributeNames();\n\t\tfor (String attributeName : attributeNames) {\n\t\t\tsetAttribute(attributeName, source.getAttribute(attributeName));\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof AttributeAccessorSupport that &&\n\t\t\t\tthis.attributes.equals(that.attributes)));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.attributes.hashCode();\n\t}\n\n}"
  },
  "org.springframework.core.AttributeAccessorSupport#attributeNames()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "String[]",
    "signature": "public String[] attributeNames()",
    "source_code": "\tpublic String[] attributeNames() {\n\t\treturn StringUtils.toStringArray(this.attributes.keySet());\n\t}"
  },
  "org.springframework.core.AttributeAccessorSupport#computeAttribute(name,Function<String,computeFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "Function<String",
      "computeFunction"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "T",
    "signature": "public T computeAttribute(String name, Function<String, T> computeFunction)",
    "source_code": "\tpublic <T> T computeAttribute(String name, Function<String, T> computeFunction) {\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tAssert.notNull(computeFunction, \"Compute function must not be null\");\n\t\tObject value = this.attributes.computeIfAbsent(name, computeFunction);\n\t\tAssert.state(value != null,\n\t\t\t\t() -> String.format(\"Compute function must not return null for attribute named '%s'\", name));\n\t\treturn (T) value;\n\t}"
  },
  "org.springframework.core.AttributeAccessorSupport#copyAttributesFrom(source)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy the attributes from the supplied AttributeAccessor to this accessor.\n\t * @param source the AttributeAccessor to copy from\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "source"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "protected void copyAttributesFrom(AttributeAccessor source)",
    "source_code": "\tprotected void copyAttributesFrom(AttributeAccessor source) {\n\t\tAssert.notNull(source, \"Source must not be null\");\n\t\tString[] attributeNames = source.attributeNames();\n\t\tfor (String attributeName : attributeNames) {\n\t\t\tsetAttribute(attributeName, source.getAttribute(attributeName));\n\t\t}\n\t}"
  },
  "org.springframework.core.AttributeAccessorSupport#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof AttributeAccessorSupport that &&\n\t\t\t\tthis.attributes.equals(that.attributes)));\n\t}"
  },
  "org.springframework.core.AttributeAccessorSupport#getAttribute(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "Object",
    "signature": "public Object getAttribute(String name)",
    "source_code": "\tpublic Object getAttribute(String name) {\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\treturn this.attributes.get(name);\n\t}"
  },
  "org.springframework.core.AttributeAccessorSupport#hasAttribute(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "boolean",
    "signature": "public boolean hasAttribute(String name)",
    "source_code": "\tpublic boolean hasAttribute(String name) {\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\treturn this.attributes.containsKey(name);\n\t}"
  },
  "org.springframework.core.AttributeAccessorSupport#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.attributes.hashCode();\n\t}"
  },
  "org.springframework.core.AttributeAccessorSupport#removeAttribute(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "Object",
    "signature": "public Object removeAttribute(String name)",
    "source_code": "\tpublic Object removeAttribute(String name) {\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\treturn this.attributes.remove(name);\n\t}"
  },
  "org.springframework.core.AttributeAccessorSupport#setAttribute(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "return": "void",
    "signature": "public void setAttribute(String name, @Nullable Object value)",
    "source_code": "\tpublic void setAttribute(String name, @Nullable Object value) {\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tif (value != null) {\n\t\t\tthis.attributes.put(name, value);\n\t\t}\n\t\telse {\n\t\t\tremoveAttribute(name);\n\t\t}\n\t}"
  },
  "org.springframework.core.ConstantException": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Exception thrown when the {@link Constants} class is asked for\n\t * an invalid constant name.\n\t */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 343
    },
    "signature": "public class ConstantException",
    "source_code": "\tpublic static class ConstantException extends IllegalArgumentException {\n\n\t\t/**\n\t\t * Thrown when an invalid constant name is requested.\n\t\t * @param className name of the class containing the constant definitions\n\t\t * @param field invalid constant name\n\t\t * @param message description of the problem\n\t\t */\n\t\tpublic ConstantException(String className, String field, String message) {\n\t\t\tsuper(\"Field '\" + field + \"' \" + message + \" in class [\" + className + \"]\");\n\t\t}\n\n\t\t/**\n\t\t * Thrown when an invalid constant value is looked up.\n\t\t * @param className name of the class containing the constant definitions\n\t\t * @param namePrefix prefix of the searched constant names\n\t\t * @param value the looked up constant value\n\t\t */\n\t\tpublic ConstantException(String className, String namePrefix, Object value) {\n\t\t\tsuper(\"No '\" + namePrefix + \"' field with value '\" + value + \"' found in class [\" + className + \"]\");\n\t\t}\n\t}"
  },
  "org.springframework.core.Constants": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * This class can be used to parse other classes containing constant definitions\n * in public static final members. The {@code asXXXX} methods of this class\n * allow these constant values to be accessed via their string names.\n *\n * <p>Consider class Foo containing {@code public final static int CONSTANT1 = 66;}\n * An instance of this class wrapping {@code Foo.class} will return the constant value\n * of 66 from its {@code asNumber} method given the argument {@code \"CONSTANT1\"}.\n *\n * <p>This class is ideal for use in PropertyEditors, enabling them to\n * recognize the same names as the constants themselves, and freeing them\n * from maintaining their own mapping.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 16.03.2003\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "signature": "public class Constants",
    "source_code": "public class Constants {\n\n\t/** The name of the introspected class. */\n\tprivate final String className;\n\n\t/** Map from String field name to object value. */\n\tprivate final Map<String, Object> fieldCache = new HashMap<>();\n\n\n\t/**\n\t * Create a new Constants converter class wrapping the given class.\n\t * <p>All <b>public</b> static final variables will be exposed, whatever their type.\n\t * @param clazz the class to analyze\n\t * @throws IllegalArgumentException if the supplied {@code clazz} is {@code null}\n\t */\n\tpublic Constants(Class<?> clazz) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tthis.className = clazz.getName();\n\t\tField[] fields = clazz.getFields();\n\t\tfor (Field field : fields) {\n\t\t\tif (ReflectionUtils.isPublicStaticFinal(field)) {\n\t\t\t\tString name = field.getName();\n\t\t\t\ttry {\n\t\t\t\t\tObject value = field.get(null);\n\t\t\t\t\tthis.fieldCache.put(name, value);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\t\t// just leave this field and continue\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Return the name of the analyzed class.\n\t */\n\tpublic final String getClassName() {\n\t\treturn this.className;\n\t}\n\n\t/**\n\t * Return the number of constants exposed.\n\t */\n\tpublic final int getSize() {\n\t\treturn this.fieldCache.size();\n\t}\n\n\t/**\n\t * Exposes the field cache to subclasses:\n\t * a Map from String field name to object value.\n\t */\n\tprotected final Map<String, Object> getFieldCache() {\n\t\treturn this.fieldCache;\n\t}\n\n\n\t/**\n\t * Return a constant value cast to a Number.\n\t * @param code the name of the field (never {@code null})\n\t * @return the Number value\n\t * @throws ConstantException if the field name wasn't found\n\t * or if the type wasn't compatible with Number\n\t * @see #asObject\n\t */\n\tpublic Number asNumber(String code) throws ConstantException {\n\t\tObject obj = asObject(code);\n\t\tif (!(obj instanceof Number number)) {\n\t\t\tthrow new ConstantException(this.className, code, \"not a Number\");\n\t\t}\n\t\treturn number;\n\t}\n\n\t/**\n\t * Return a constant value as a String.\n\t * @param code the name of the field (never {@code null})\n\t * @return the String value\n\t * Works even if it's not a string (invokes {@code toString()}).\n\t * @throws ConstantException if the field name wasn't found\n\t * @see #asObject\n\t */\n\tpublic String asString(String code) throws ConstantException {\n\t\treturn asObject(code).toString();\n\t}\n\n\t/**\n\t * Parse the given String (upper or lower case accepted) and return\n\t * the appropriate value if it's the name of a constant field in the\n\t * class that we're analyzing.\n\t * @param code the name of the field (never {@code null})\n\t * @return the Object value\n\t * @throws ConstantException if there's no such field\n\t */\n\tpublic Object asObject(String code) throws ConstantException {\n\t\tAssert.notNull(code, \"Code must not be null\");\n\t\tString codeToUse = code.toUpperCase(Locale.ENGLISH);\n\t\tObject val = this.fieldCache.get(codeToUse);\n\t\tif (val == null) {\n\t\t\tthrow new ConstantException(this.className, codeToUse, \"not found\");\n\t\t}\n\t\treturn val;\n\t}\n\n\n\t/**\n\t * Return all names of the given group of constants.\n\t * <p>Note that this method assumes that constants are named\n\t * in accordance with the standard Java convention for constant\n\t * values (i.e. all uppercase). The supplied {@code namePrefix}\n\t * will be uppercased (in a locale-insensitive fashion) prior to\n\t * the main logic of this method kicking in.\n\t * @param namePrefix prefix of the constant names to search (may be {@code null})\n\t * @return the set of constant names\n\t */\n\tpublic Set<String> getNames(@Nullable String namePrefix) {\n\t\tString prefixToUse = (namePrefix != null ? namePrefix.trim().toUpperCase(Locale.ENGLISH) : \"\");\n\t\tSet<String> names = new HashSet<>();\n\t\tfor (String code : this.fieldCache.keySet()) {\n\t\t\tif (code.startsWith(prefixToUse)) {\n\t\t\t\tnames.add(code);\n\t\t\t}\n\t\t}\n\t\treturn names;\n\t}\n\n\t/**\n\t * Return all names of the group of constants for the\n\t * given bean property name.\n\t * @param propertyName the name of the bean property\n\t * @return the set of values\n\t * @see #propertyToConstantNamePrefix\n\t */\n\tpublic Set<String> getNamesForProperty(String propertyName) {\n\t\treturn getNames(propertyToConstantNamePrefix(propertyName));\n\t}\n\n\t/**\n\t * Return all names of the given group of constants.\n\t * <p>Note that this method assumes that constants are named\n\t * in accordance with the standard Java convention for constant\n\t * values (i.e. all uppercase). The supplied {@code nameSuffix}\n\t * will be uppercased (in a locale-insensitive fashion) prior to\n\t * the main logic of this method kicking in.\n\t * @param nameSuffix suffix of the constant names to search (may be {@code null})\n\t * @return the set of constant names\n\t */\n\tpublic Set<String> getNamesForSuffix(@Nullable String nameSuffix) {\n\t\tString suffixToUse = (nameSuffix != null ? nameSuffix.trim().toUpperCase(Locale.ENGLISH) : \"\");\n\t\tSet<String> names = new HashSet<>();\n\t\tfor (String code : this.fieldCache.keySet()) {\n\t\t\tif (code.endsWith(suffixToUse)) {\n\t\t\t\tnames.add(code);\n\t\t\t}\n\t\t}\n\t\treturn names;\n\t}\n\n\n\t/**\n\t * Return all values of the given group of constants.\n\t * <p>Note that this method assumes that constants are named\n\t * in accordance with the standard Java convention for constant\n\t * values (i.e. all uppercase). The supplied {@code namePrefix}\n\t * will be uppercased (in a locale-insensitive fashion) prior to\n\t * the main logic of this method kicking in.\n\t * @param namePrefix prefix of the constant names to search (may be {@code null})\n\t * @return the set of values\n\t */\n\tpublic Set<Object> getValues(@Nullable String namePrefix) {\n\t\tString prefixToUse = (namePrefix != null ? namePrefix.trim().toUpperCase(Locale.ENGLISH) : \"\");\n\t\tSet<Object> values = new HashSet<>();\n\t\tthis.fieldCache.forEach((code, value) -> {\n\t\t\tif (code.startsWith(prefixToUse)) {\n\t\t\t\tvalues.add(value);\n\t\t\t}\n\t\t});\n\t\treturn values;\n\t}\n\n\t/**\n\t * Return all values of the group of constants for the\n\t * given bean property name.\n\t * @param propertyName the name of the bean property\n\t * @return the set of values\n\t * @see #propertyToConstantNamePrefix\n\t */\n\tpublic Set<Object> getValuesForProperty(String propertyName) {\n\t\treturn getValues(propertyToConstantNamePrefix(propertyName));\n\t}\n\n\t/**\n\t * Return all values of the given group of constants.\n\t * <p>Note that this method assumes that constants are named\n\t * in accordance with the standard Java convention for constant\n\t * values (i.e. all uppercase). The supplied {@code nameSuffix}\n\t * will be uppercased (in a locale-insensitive fashion) prior to\n\t * the main logic of this method kicking in.\n\t * @param nameSuffix suffix of the constant names to search (may be {@code null})\n\t * @return the set of values\n\t */\n\tpublic Set<Object> getValuesForSuffix(@Nullable String nameSuffix) {\n\t\tString suffixToUse = (nameSuffix != null ? nameSuffix.trim().toUpperCase(Locale.ENGLISH) : \"\");\n\t\tSet<Object> values = new HashSet<>();\n\t\tthis.fieldCache.forEach((code, value) -> {\n\t\t\tif (code.endsWith(suffixToUse)) {\n\t\t\t\tvalues.add(value);\n\t\t\t}\n\t\t});\n\t\treturn values;\n\t}\n\n\n\t/**\n\t * Look up the given value within the given group of constants.\n\t * <p>Will return the first match.\n\t * @param value constant value to look up\n\t * @param namePrefix prefix of the constant names to search (may be {@code null})\n\t * @return the name of the constant field\n\t * @throws ConstantException if the value wasn't found\n\t */\n\tpublic String toCode(Object value, @Nullable String namePrefix) throws ConstantException {\n\t\tString prefixToUse = (namePrefix != null ? namePrefix.trim().toUpperCase(Locale.ENGLISH) : \"\");\n\t\tfor (Map.Entry<String, Object> entry : this.fieldCache.entrySet()) {\n\t\t\tif (entry.getKey().startsWith(prefixToUse) && entry.getValue().equals(value)) {\n\t\t\t\treturn entry.getKey();\n\t\t\t}\n\t\t}\n\t\tthrow new ConstantException(this.className, prefixToUse, value);\n\t}\n\n\t/**\n\t * Look up the given value within the group of constants for\n\t * the given bean property name. Will return the first match.\n\t * @param value constant value to look up\n\t * @param propertyName the name of the bean property\n\t * @return the name of the constant field\n\t * @throws ConstantException if the value wasn't found\n\t * @see #propertyToConstantNamePrefix\n\t */\n\tpublic String toCodeForProperty(Object value, String propertyName) throws ConstantException {\n\t\treturn toCode(value, propertyToConstantNamePrefix(propertyName));\n\t}\n\n\t/**\n\t * Look up the given value within the given group of constants.\n\t * <p>Will return the first match.\n\t * @param value constant value to look up\n\t * @param nameSuffix suffix of the constant names to search (may be {@code null})\n\t * @return the name of the constant field\n\t * @throws ConstantException if the value wasn't found\n\t */\n\tpublic String toCodeForSuffix(Object value, @Nullable String nameSuffix) throws ConstantException {\n\t\tString suffixToUse = (nameSuffix != null ? nameSuffix.trim().toUpperCase(Locale.ENGLISH) : \"\");\n\t\tfor (Map.Entry<String, Object> entry : this.fieldCache.entrySet()) {\n\t\t\tif (entry.getKey().endsWith(suffixToUse) && entry.getValue().equals(value)) {\n\t\t\t\treturn entry.getKey();\n\t\t\t}\n\t\t}\n\t\tthrow new ConstantException(this.className, suffixToUse, value);\n\t}\n\n\n\t/**\n\t * Convert the given bean property name to a constant name prefix.\n\t * <p>Uses a common naming idiom: turning all lower case characters to\n\t * upper case, and prepending upper case characters with an underscore.\n\t * <p>Example: \"imageSize\" &rarr; \"IMAGE_SIZE\"<br>\n\t * Example: \"imagesize\" &rarr; \"IMAGESIZE\".<br>\n\t * Example: \"ImageSize\" &rarr; \"_IMAGE_SIZE\".<br>\n\t * Example: \"IMAGESIZE\" &rarr; \"_I_M_A_G_E_S_I_Z_E\"\n\t * @param propertyName the name of the bean property\n\t * @return the corresponding constant name prefix\n\t * @see #getValuesForProperty\n\t * @see #toCodeForProperty\n\t */\n\tpublic String propertyToConstantNamePrefix(String propertyName) {\n\t\tStringBuilder parsedPrefix = new StringBuilder();\n\t\tfor (int i = 0; i < propertyName.length(); i++) {\n\t\t\tchar c = propertyName.charAt(i);\n\t\t\tif (Character.isUpperCase(c)) {\n\t\t\t\tparsedPrefix.append('_');\n\t\t\t\tparsedPrefix.append(c);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparsedPrefix.append(Character.toUpperCase(c));\n\t\t\t}\n\t\t}\n\t\treturn parsedPrefix.toString();\n\t}\n\n\n\t/**\n\t * Exception thrown when the {@link Constants} class is asked for\n\t * an invalid constant name.\n\t */\n\t@SuppressWarnings(\"serial\")\n\tpublic static class ConstantException extends IllegalArgumentException {\n\n\t\t/**\n\t\t * Thrown when an invalid constant name is requested.\n\t\t * @param className name of the class containing the constant definitions\n\t\t * @param field invalid constant name\n\t\t * @param message description of the problem\n\t\t */\n\t\tpublic ConstantException(String className, String field, String message) {\n\t\t\tsuper(\"Field '\" + field + \"' \" + message + \" in class [\" + className + \"]\");\n\t\t}\n\n\t\t/**\n\t\t * Thrown when an invalid constant value is looked up.\n\t\t * @param className name of the class containing the constant definitions\n\t\t * @param namePrefix prefix of the searched constant names\n\t\t * @param value the looked up constant value\n\t\t */\n\t\tpublic ConstantException(String className, String namePrefix, Object value) {\n\t\t\tsuper(\"No '\" + namePrefix + \"' field with value '\" + value + \"' found in class [\" + className + \"]\");\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.core.Constants#asNumber(code)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a constant value cast to a Number.\n\t * @param code the name of the field (never {@code null})\n\t * @return the Number value\n\t * @throws ConstantException if the field name wasn't found\n\t * or if the type wasn't compatible with Number\n\t * @see #asObject\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "Number",
    "signature": "public Number asNumber(String code)",
    "source_code": "\tpublic Number asNumber(String code) throws ConstantException {\n\t\tObject obj = asObject(code);\n\t\tif (!(obj instanceof Number number)) {\n\t\t\tthrow new ConstantException(this.className, code, \"not a Number\");\n\t\t}\n\t\treturn number;\n\t}"
  },
  "org.springframework.core.Constants#asObject(code)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the given String (upper or lower case accepted) and return\n\t * the appropriate value if it's the name of a constant field in the\n\t * class that we're analyzing.\n\t * @param code the name of the field (never {@code null})\n\t * @return the Object value\n\t * @throws ConstantException if there's no such field\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "Object",
    "signature": "public Object asObject(String code)",
    "source_code": "\tpublic Object asObject(String code) throws ConstantException {\n\t\tAssert.notNull(code, \"Code must not be null\");\n\t\tString codeToUse = code.toUpperCase(Locale.ENGLISH);\n\t\tObject val = this.fieldCache.get(codeToUse);\n\t\tif (val == null) {\n\t\t\tthrow new ConstantException(this.className, codeToUse, \"not found\");\n\t\t}\n\t\treturn val;\n\t}"
  },
  "org.springframework.core.Constants#asString(code)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a constant value as a String.\n\t * @param code the name of the field (never {@code null})\n\t * @return the String value\n\t * Works even if it's not a string (invokes {@code toString()}).\n\t * @throws ConstantException if the field name wasn't found\n\t * @see #asObject\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "String",
    "signature": "public String asString(String code)",
    "source_code": "\tpublic String asString(String code) throws ConstantException {\n\t\treturn asObject(code).toString();\n\t}"
  },
  "org.springframework.core.Constants#getClassName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the name of the analyzed class.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "String",
    "signature": "public String getClassName()",
    "source_code": "\tpublic final String getClassName() {\n\t\treturn this.className;\n\t}"
  },
  "org.springframework.core.Constants#getFieldCache()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Exposes the field cache to subclasses:\n\t * a Map from String field name to object value.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "Object>",
    "signature": "protected Object> getFieldCache()",
    "source_code": "\tprotected final Map<String, Object> getFieldCache() {\n\t\treturn this.fieldCache;\n\t}"
  },
  "org.springframework.core.Constants#getNames(namePrefix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return all names of the given group of constants.\n\t * <p>Note that this method assumes that constants are named\n\t * in accordance with the standard Java convention for constant\n\t * values (i.e. all uppercase). The supplied {@code namePrefix}\n\t * will be uppercased (in a locale-insensitive fashion) prior to\n\t * the main logic of this method kicking in.\n\t * @param namePrefix prefix of the constant names to search (may be {@code null})\n\t * @return the set of constant names\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "namePrefix"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "Set<String>",
    "signature": "public Set<String> getNames(@Nullable String namePrefix)",
    "source_code": "\tpublic Set<String> getNames(@Nullable String namePrefix) {\n\t\tString prefixToUse = (namePrefix != null ? namePrefix.trim().toUpperCase(Locale.ENGLISH) : \"\");\n\t\tSet<String> names = new HashSet<>();\n\t\tfor (String code : this.fieldCache.keySet()) {\n\t\t\tif (code.startsWith(prefixToUse)) {\n\t\t\t\tnames.add(code);\n\t\t\t}\n\t\t}\n\t\treturn names;\n\t}"
  },
  "org.springframework.core.Constants#getNamesForProperty(propertyName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return all names of the group of constants for the\n\t * given bean property name.\n\t * @param propertyName the name of the bean property\n\t * @return the set of values\n\t * @see #propertyToConstantNamePrefix\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "Set<String>",
    "signature": "public Set<String> getNamesForProperty(String propertyName)",
    "source_code": "\tpublic Set<String> getNamesForProperty(String propertyName) {\n\t\treturn getNames(propertyToConstantNamePrefix(propertyName));\n\t}"
  },
  "org.springframework.core.Constants#getNamesForSuffix(nameSuffix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return all names of the given group of constants.\n\t * <p>Note that this method assumes that constants are named\n\t * in accordance with the standard Java convention for constant\n\t * values (i.e. all uppercase). The supplied {@code nameSuffix}\n\t * will be uppercased (in a locale-insensitive fashion) prior to\n\t * the main logic of this method kicking in.\n\t * @param nameSuffix suffix of the constant names to search (may be {@code null})\n\t * @return the set of constant names\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nameSuffix"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "Set<String>",
    "signature": "public Set<String> getNamesForSuffix(@Nullable String nameSuffix)",
    "source_code": "\tpublic Set<String> getNamesForSuffix(@Nullable String nameSuffix) {\n\t\tString suffixToUse = (nameSuffix != null ? nameSuffix.trim().toUpperCase(Locale.ENGLISH) : \"\");\n\t\tSet<String> names = new HashSet<>();\n\t\tfor (String code : this.fieldCache.keySet()) {\n\t\t\tif (code.endsWith(suffixToUse)) {\n\t\t\t\tnames.add(code);\n\t\t\t}\n\t\t}\n\t\treturn names;\n\t}"
  },
  "org.springframework.core.Constants#getSize()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the number of constants exposed.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "int",
    "signature": "public int getSize()",
    "source_code": "\tpublic final int getSize() {\n\t\treturn this.fieldCache.size();\n\t}"
  },
  "org.springframework.core.Constants#getValues(namePrefix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return all values of the given group of constants.\n\t * <p>Note that this method assumes that constants are named\n\t * in accordance with the standard Java convention for constant\n\t * values (i.e. all uppercase). The supplied {@code namePrefix}\n\t * will be uppercased (in a locale-insensitive fashion) prior to\n\t * the main logic of this method kicking in.\n\t * @param namePrefix prefix of the constant names to search (may be {@code null})\n\t * @return the set of values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "namePrefix"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "Set<Object>",
    "signature": "public Set<Object> getValues(@Nullable String namePrefix)",
    "source_code": "\tpublic Set<Object> getValues(@Nullable String namePrefix) {\n\t\tString prefixToUse = (namePrefix != null ? namePrefix.trim().toUpperCase(Locale.ENGLISH) : \"\");\n\t\tSet<Object> values = new HashSet<>();\n\t\tthis.fieldCache.forEach((code, value) -> {\n\t\t\tif (code.startsWith(prefixToUse)) {\n\t\t\t\tvalues.add(value);\n\t\t\t}\n\t\t});\n\t\treturn values;\n\t}"
  },
  "org.springframework.core.Constants#getValuesForProperty(propertyName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return all values of the group of constants for the\n\t * given bean property name.\n\t * @param propertyName the name of the bean property\n\t * @return the set of values\n\t * @see #propertyToConstantNamePrefix\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName"
    ],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "Set<Object>",
    "signature": "public Set<Object> getValuesForProperty(String propertyName)",
    "source_code": "\tpublic Set<Object> getValuesForProperty(String propertyName) {\n\t\treturn getValues(propertyToConstantNamePrefix(propertyName));\n\t}"
  },
  "org.springframework.core.Constants#getValuesForSuffix(nameSuffix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return all values of the given group of constants.\n\t * <p>Note that this method assumes that constants are named\n\t * in accordance with the standard Java convention for constant\n\t * values (i.e. all uppercase). The supplied {@code nameSuffix}\n\t * will be uppercased (in a locale-insensitive fashion) prior to\n\t * the main logic of this method kicking in.\n\t * @param nameSuffix suffix of the constant names to search (may be {@code null})\n\t * @return the set of values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nameSuffix"
    ],
    "position": {
      "column": 1,
      "line": 247
    },
    "return": "Set<Object>",
    "signature": "public Set<Object> getValuesForSuffix(@Nullable String nameSuffix)",
    "source_code": "\tpublic Set<Object> getValuesForSuffix(@Nullable String nameSuffix) {\n\t\tString suffixToUse = (nameSuffix != null ? nameSuffix.trim().toUpperCase(Locale.ENGLISH) : \"\");\n\t\tSet<Object> values = new HashSet<>();\n\t\tthis.fieldCache.forEach((code, value) -> {\n\t\t\tif (code.endsWith(suffixToUse)) {\n\t\t\t\tvalues.add(value);\n\t\t\t}\n\t\t});\n\t\treturn values;\n\t}"
  },
  "org.springframework.core.Constants#propertyToConstantNamePrefix(propertyName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given bean property name to a constant name prefix.\n\t * <p>Uses a common naming idiom: turning all lower case characters to\n\t * upper case, and prepending upper case characters with an underscore.\n\t * <p>Example: \"imageSize\" &rarr; \"IMAGE_SIZE\"<br>\n\t * Example: \"imagesize\" &rarr; \"IMAGESIZE\".<br>\n\t * Example: \"ImageSize\" &rarr; \"_IMAGE_SIZE\".<br>\n\t * Example: \"IMAGESIZE\" &rarr; \"_I_M_A_G_E_S_I_Z_E\"\n\t * @param propertyName the name of the bean property\n\t * @return the corresponding constant name prefix\n\t * @see #getValuesForProperty\n\t * @see #toCodeForProperty\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName"
    ],
    "position": {
      "column": 1,
      "line": 322
    },
    "return": "String",
    "signature": "public String propertyToConstantNamePrefix(String propertyName)",
    "source_code": "\tpublic String propertyToConstantNamePrefix(String propertyName) {\n\t\tStringBuilder parsedPrefix = new StringBuilder();\n\t\tfor (int i = 0; i < propertyName.length(); i++) {\n\t\t\tchar c = propertyName.charAt(i);\n\t\t\tif (Character.isUpperCase(c)) {\n\t\t\t\tparsedPrefix.append('_');\n\t\t\t\tparsedPrefix.append(c);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparsedPrefix.append(Character.toUpperCase(c));\n\t\t\t}\n\t\t}\n\t\treturn parsedPrefix.toString();\n\t}"
  },
  "org.springframework.core.Constants#toCode(value,namePrefix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Look up the given value within the given group of constants.\n\t * <p>Will return the first match.\n\t * @param value constant value to look up\n\t * @param namePrefix prefix of the constant names to search (may be {@code null})\n\t * @return the name of the constant field\n\t * @throws ConstantException if the value wasn't found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "namePrefix"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "String",
    "signature": "public String toCode(Object value, @Nullable String namePrefix)",
    "source_code": "\tpublic String toCode(Object value, @Nullable String namePrefix) throws ConstantException {\n\t\tString prefixToUse = (namePrefix != null ? namePrefix.trim().toUpperCase(Locale.ENGLISH) : \"\");\n\t\tfor (Map.Entry<String, Object> entry : this.fieldCache.entrySet()) {\n\t\t\tif (entry.getKey().startsWith(prefixToUse) && entry.getValue().equals(value)) {\n\t\t\t\treturn entry.getKey();\n\t\t\t}\n\t\t}\n\t\tthrow new ConstantException(this.className, prefixToUse, value);\n\t}"
  },
  "org.springframework.core.Constants#toCodeForProperty(value,propertyName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Look up the given value within the group of constants for\n\t * the given bean property name. Will return the first match.\n\t * @param value constant value to look up\n\t * @param propertyName the name of the bean property\n\t * @return the name of the constant field\n\t * @throws ConstantException if the value wasn't found\n\t * @see #propertyToConstantNamePrefix\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "propertyName"
    ],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "String",
    "signature": "public String toCodeForProperty(Object value, String propertyName)",
    "source_code": "\tpublic String toCodeForProperty(Object value, String propertyName) throws ConstantException {\n\t\treturn toCode(value, propertyToConstantNamePrefix(propertyName));\n\t}"
  },
  "org.springframework.core.Constants#toCodeForSuffix(value,nameSuffix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Look up the given value within the given group of constants.\n\t * <p>Will return the first match.\n\t * @param value constant value to look up\n\t * @param nameSuffix suffix of the constant names to search (may be {@code null})\n\t * @return the name of the constant field\n\t * @throws ConstantException if the value wasn't found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "nameSuffix"
    ],
    "position": {
      "column": 1,
      "line": 298
    },
    "return": "String",
    "signature": "public String toCodeForSuffix(Object value, @Nullable String nameSuffix)",
    "source_code": "\tpublic String toCodeForSuffix(Object value, @Nullable String nameSuffix) throws ConstantException {\n\t\tString suffixToUse = (nameSuffix != null ? nameSuffix.trim().toUpperCase(Locale.ENGLISH) : \"\");\n\t\tfor (Map.Entry<String, Object> entry : this.fieldCache.entrySet()) {\n\t\t\tif (entry.getKey().endsWith(suffixToUse) && entry.getValue().equals(value)) {\n\t\t\t\treturn entry.getKey();\n\t\t\t}\n\t\t}\n\t\tthrow new ConstantException(this.className, suffixToUse, value);\n\t}"
  },
  "org.springframework.core.ParameterizedTypeReference": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * The purpose of this class is to enable capturing and passing a generic\n * {@link Type}. In order to capture the generic type and retain it at runtime,\n * you need to create a subclass (ideally as anonymous inline class) as follows:\n *\n * <pre class=\"code\">\n * ParameterizedTypeReference&lt;List&lt;String&gt;&gt; typeRef = new ParameterizedTypeReference&lt;List&lt;String&gt;&gt;() {};\n * </pre>\n *\n * <p>The resulting {@code typeRef} instance can then be used to obtain a {@link Type}\n * instance that carries the captured parameterized type information at runtime.\n * For more information on \"super type tokens\" see the link to Neal Gafter's blog post.\n *\n * @author Arjen Poutsma\n * @author Rossen Stoyanchev\n * @since 3.2\n * @param <T> the referenced type\n * @see <a href=\"https://gafter.blogspot.nl/2006/12/super-type-tokens.html\">Neal Gafter on Super Type Tokens</a>\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "signature": "public class ParameterizedTypeReference",
    "source_code": "public abstract class ParameterizedTypeReference<T> {\n\n\tprivate final Type type;\n\n\n\tprotected ParameterizedTypeReference() {\n\t\tClass<?> parameterizedTypeReferenceSubclass = findParameterizedTypeReferenceSubclass(getClass());\n\t\tType type = parameterizedTypeReferenceSubclass.getGenericSuperclass();\n\t\tAssert.isInstanceOf(ParameterizedType.class, type, \"Type must be a parameterized type\");\n\t\tParameterizedType parameterizedType = (ParameterizedType) type;\n\t\tType[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n\t\tAssert.isTrue(actualTypeArguments.length == 1, \"Number of type arguments must be 1\");\n\t\tthis.type = actualTypeArguments[0];\n\t}\n\n\tprivate ParameterizedTypeReference(Type type) {\n\t\tthis.type = type;\n\t}\n\n\n\tpublic Type getType() {\n\t\treturn this.type;\n\t}\n\n\t@Override\n\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof ParameterizedTypeReference<?> that && this.type.equals(that.type)));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.type.hashCode();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"ParameterizedTypeReference<\" + this.type + \">\";\n\t}\n\n\n\t/**\n\t * Build a {@code ParameterizedTypeReference} wrapping the given type.\n\t * @param type a generic type (possibly obtained via reflection,\n\t * e.g. from {@link java.lang.reflect.Method#getGenericReturnType()})\n\t * @return a corresponding reference which may be passed into\n\t * {@code ParameterizedTypeReference}-accepting methods\n\t * @since 4.3.12\n\t */\n\tpublic static <T> ParameterizedTypeReference<T> forType(Type type) {\n\t\treturn new ParameterizedTypeReference<>(type) {\n\t\t};\n\t}\n\n\tprivate static Class<?> findParameterizedTypeReferenceSubclass(Class<?> child) {\n\t\tClass<?> parent = child.getSuperclass();\n\t\tif (Object.class == parent) {\n\t\t\tthrow new IllegalStateException(\"Expected ParameterizedTypeReference superclass\");\n\t\t}\n\t\telse if (ParameterizedTypeReference.class == parent) {\n\t\t\treturn child;\n\t\t}\n\t\telse {\n\t\t\treturn findParameterizedTypeReferenceSubclass(parent);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.core.ParameterizedTypeReference#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof ParameterizedTypeReference<?> that && this.type.equals(that.type)));\n\t}"
  },
  "org.springframework.core.ParameterizedTypeReference#forType(type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@code ParameterizedTypeReference} wrapping the given type.\n\t * @param type a generic type (possibly obtained via reflection,\n\t * e.g. from {@link java.lang.reflect.Method#getGenericReturnType()})\n\t * @return a corresponding reference which may be passed into\n\t * {@code ParameterizedTypeReference}-accepting methods\n\t * @since 4.3.12\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "ParameterizedTypeReference<T>",
    "signature": "public ParameterizedTypeReference<T> forType(Type type)",
    "source_code": "\tpublic static <T> ParameterizedTypeReference<T> forType(Type type) {\n\t\treturn new ParameterizedTypeReference<>(type) {\n\t\t};\n\t}"
  },
  "org.springframework.core.ParameterizedTypeReference#getType()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "Type",
    "signature": "public Type getType()",
    "source_code": "\tpublic Type getType() {\n\t\treturn this.type;\n\t}"
  },
  "org.springframework.core.ParameterizedTypeReference#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.type.hashCode();\n\t}"
  },
  "org.springframework.core.ParameterizedTypeReference#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn \"ParameterizedTypeReference<\" + this.type + \">\";\n\t}"
  },
  "org.springframework.core.ReactiveAdapterRegistry": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A registry of adapters to adapt Reactive Streams {@link Publisher} to/from\n * various async/reactive types such as {@code CompletableFuture}, RxJava\n * {@code Flowable}, and others.\n *\n * <p>By default, depending on classpath availability, adapters are registered\n * for Reactor, RxJava 3, {@link CompletableFuture}, {@code Flow.Publisher},\n * and Kotlin Coroutines' {@code Deferred} and {@code Flow}.\n *\n * @author Rossen Stoyanchev\n * @author Sebastien Deleuze\n * @author Juergen Hoeller\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "signature": "public class ReactiveAdapterRegistry",
    "source_code": "public class ReactiveAdapterRegistry {\n\n\t@Nullable\n\tprivate static volatile ReactiveAdapterRegistry sharedInstance;\n\n\tprivate static final boolean reactorPresent;\n\n\tprivate static final boolean rxjava3Present;\n\n\tprivate static final boolean kotlinCoroutinesPresent;\n\n\tprivate static final boolean mutinyPresent;\n\n\tstatic {\n\t\tClassLoader classLoader = ReactiveAdapterRegistry.class.getClassLoader();\n\t\treactorPresent = ClassUtils.isPresent(\"reactor.core.publisher.Flux\", classLoader);\n\t\trxjava3Present = ClassUtils.isPresent(\"io.reactivex.rxjava3.core.Flowable\", classLoader);\n\t\tkotlinCoroutinesPresent = ClassUtils.isPresent(\"kotlinx.coroutines.reactor.MonoKt\", classLoader);\n\t\tmutinyPresent = ClassUtils.isPresent(\"io.smallrye.mutiny.Multi\", classLoader);\n\t}\n\n\tprivate final List<ReactiveAdapter> adapters = new ArrayList<>();\n\n\n\t/**\n\t * Create a registry and auto-register default adapters.\n\t * @see #getSharedInstance()\n\t */\n\tpublic ReactiveAdapterRegistry() {\n\t\t// Reactor\n\t\tif (reactorPresent) {\n\t\t\tnew ReactorRegistrar().registerAdapters(this);\n\t\t}\n\n\t\t// RxJava\n\t\tif (rxjava3Present) {\n\t\t\tnew RxJava3Registrar().registerAdapters(this);\n\t\t}\n\n\t\t// Kotlin Coroutines\n\t\tif (reactorPresent && kotlinCoroutinesPresent) {\n\t\t\tnew CoroutinesRegistrar().registerAdapters(this);\n\t\t}\n\n\t\t// SmallRye Mutiny\n\t\tif (mutinyPresent) {\n\t\t\tnew MutinyRegistrar().registerAdapters(this);\n\t\t}\n\t}\n\n\n\t/**\n\t * Whether the registry has any adapters.\n\t */\n\tpublic boolean hasAdapters() {\n\t\treturn !this.adapters.isEmpty();\n\t}\n\n\t/**\n\t * Register a reactive type along with functions to adapt to and from a\n\t * Reactive Streams {@link Publisher}. The function arguments assume that\n\t * their input is neither {@code null} nor {@link Optional}.\n\t */\n\tpublic void registerReactiveType(ReactiveTypeDescriptor descriptor,\n\t\t\tFunction<Object, Publisher<?>> toAdapter, Function<Publisher<?>, Object> fromAdapter) {\n\n\t\tif (reactorPresent) {\n\t\t\tthis.adapters.add(new ReactorAdapter(descriptor, toAdapter, fromAdapter));\n\t\t}\n\t\telse {\n\t\t\tthis.adapters.add(new ReactiveAdapter(descriptor, toAdapter, fromAdapter));\n\t\t}\n\t}\n\n\t/**\n\t * Get the adapter for the given reactive type.\n\t * @return the corresponding adapter, or {@code null} if none available\n\t */\n\t@Nullable\n\tpublic ReactiveAdapter getAdapter(Class<?> reactiveType) {\n\t\treturn getAdapter(reactiveType, null);\n\t}\n\n\t/**\n\t * Get the adapter for the given reactive type. Or if a \"source\" object is\n\t * provided, its actual type is used instead.\n\t * @param reactiveType the reactive type\n\t * (may be {@code null} if a concrete source object is given)\n\t * @param source an instance of the reactive type\n\t * (i.e. to adapt from; may be {@code null} if the reactive type is specified)\n\t * @return the corresponding adapter, or {@code null} if none available\n\t */\n\t@Nullable\n\tpublic ReactiveAdapter getAdapter(@Nullable Class<?> reactiveType, @Nullable Object source) {\n\t\tif (this.adapters.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tObject sourceToUse = (source instanceof Optional<?> optional ? optional.orElse(null) : source);\n\t\tClass<?> clazz = (sourceToUse != null ? sourceToUse.getClass() : reactiveType);\n\t\tif (clazz == null) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (ReactiveAdapter adapter : this.adapters) {\n\t\t\tif (adapter.getReactiveType() == clazz) {\n\t\t\t\treturn adapter;\n\t\t\t}\n\t\t}\n\t\tfor (ReactiveAdapter adapter : this.adapters) {\n\t\t\tif (adapter.getReactiveType().isAssignableFrom(clazz)) {\n\t\t\t\treturn adapter;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\n\t/**\n\t * Return a shared default {@code ReactiveAdapterRegistry} instance,\n\t * lazily building it once needed.\n\t * <p><b>NOTE:</b> We highly recommend passing a long-lived, pre-configured\n\t * {@code ReactiveAdapterRegistry} instance for customization purposes.\n\t * This accessor is only meant as a fallback for code paths that want to\n\t * fall back on a default instance if one isn't provided.\n\t * @return the shared {@code ReactiveAdapterRegistry} instance\n\t * @since 5.0.2\n\t */\n\tpublic static ReactiveAdapterRegistry getSharedInstance() {\n\t\tReactiveAdapterRegistry registry = sharedInstance;\n\t\tif (registry == null) {\n\t\t\tsynchronized (ReactiveAdapterRegistry.class) {\n\t\t\t\tregistry = sharedInstance;\n\t\t\t\tif (registry == null) {\n\t\t\t\t\tregistry = new ReactiveAdapterRegistry();\n\t\t\t\t\tsharedInstance = registry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn registry;\n\t}\n\n\n\t/**\n\t * ReactiveAdapter variant that wraps adapted Publishers as {@link Flux} or\n\t * {@link Mono} depending on {@link ReactiveTypeDescriptor#isMultiValue()}.\n\t * This is important in places where only the stream and stream element type\n\t * information is available like encoders and decoders.\n\t */\n\tprivate static class ReactorAdapter extends ReactiveAdapter {\n\n\t\tReactorAdapter(ReactiveTypeDescriptor descriptor,\n\t\t\t\tFunction<Object, Publisher<?>> toPublisherFunction,\n\t\t\t\tFunction<Publisher<?>, Object> fromPublisherFunction) {\n\n\t\t\tsuper(descriptor, toPublisherFunction, fromPublisherFunction);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> Publisher<T> toPublisher(@Nullable Object source) {\n\t\t\tPublisher<T> publisher = super.toPublisher(source);\n\t\t\treturn (isMultiValue() ? Flux.from(publisher) : Mono.from(publisher));\n\t\t}\n\t}\n\n\n\tprivate static class ReactorRegistrar {\n\n\t\tprivate static final Flow.Publisher<?> EMPTY_FLOW = JdkFlowAdapter.publisherToFlowPublisher(Flux.empty());\n\n\t\tvoid registerAdapters(ReactiveAdapterRegistry registry) {\n\t\t\t// Register Flux and Mono before Publisher...\n\n\t\t\tregistry.registerReactiveType(\n\t\t\t\t\tReactiveTypeDescriptor.singleOptionalValue(Mono.class, Mono::empty),\n\t\t\t\t\tsource -> (Mono<?>) source,\n\t\t\t\t\tMono::from);\n\n\t\t\tregistry.registerReactiveType(\n\t\t\t\t\tReactiveTypeDescriptor.multiValue(Flux.class, Flux::empty),\n\t\t\t\t\tsource -> (Flux<?>) source,\n\t\t\t\t\tFlux::from);\n\n\t\t\tregistry.registerReactiveType(\n\t\t\t\t\tReactiveTypeDescriptor.multiValue(Publisher.class, Flux::empty),\n\t\t\t\t\tsource -> (Publisher<?>) source,\n\t\t\t\t\tsource -> source);\n\n\t\t\tregistry.registerReactiveType(\n\t\t\t\t\tReactiveTypeDescriptor.nonDeferredAsyncValue(CompletionStage.class, EmptyCompletableFuture::new),\n\t\t\t\t\tsource -> Mono.fromCompletionStage((CompletionStage<?>) source),\n\t\t\t\t\tsource -> Mono.from(source).toFuture());\n\n\t\t\tregistry.registerReactiveType(\n\t\t\t\t\tReactiveTypeDescriptor.multiValue(Flow.Publisher.class, () -> EMPTY_FLOW),\n\t\t\t\t\tsource -> JdkFlowAdapter.flowPublisherToFlux((Flow.Publisher<?>) source),\n\t\t\t\t\tJdkFlowAdapter::publisherToFlowPublisher);\n\t\t}\n\t}\n\n\n\tprivate static class EmptyCompletableFuture<T> extends CompletableFuture<T> {\n\n\t\tEmptyCompletableFuture() {\n\t\t\tcomplete(null);\n\t\t}\n\t}\n\n\n\tprivate static class RxJava3Registrar {\n\n\t\tvoid registerAdapters(ReactiveAdapterRegistry registry) {\n\t\t\tregistry.registerReactiveType(\n\t\t\t\t\tReactiveTypeDescriptor.multiValue(\n\t\t\t\t\t\t\tio.reactivex.rxjava3.core.Flowable.class,\n\t\t\t\t\t\t\tio.reactivex.rxjava3.core.Flowable::empty),\n\t\t\t\t\tsource -> (io.reactivex.rxjava3.core.Flowable<?>) source,\n\t\t\t\t\tio.reactivex.rxjava3.core.Flowable::fromPublisher);\n\n\t\t\tregistry.registerReactiveType(\n\t\t\t\t\tReactiveTypeDescriptor.multiValue(\n\t\t\t\t\t\t\tio.reactivex.rxjava3.core.Observable.class,\n\t\t\t\t\t\t\tio.reactivex.rxjava3.core.Observable::empty),\n\t\t\t\t\tsource -> ((io.reactivex.rxjava3.core.Observable<?>) source).toFlowable(\n\t\t\t\t\t\t\tio.reactivex.rxjava3.core.BackpressureStrategy.BUFFER),\n\t\t\t\t\tio.reactivex.rxjava3.core.Observable::fromPublisher);\n\n\t\t\tregistry.registerReactiveType(\n\t\t\t\t\tReactiveTypeDescriptor.singleRequiredValue(io.reactivex.rxjava3.core.Single.class),\n\t\t\t\t\tsource -> ((io.reactivex.rxjava3.core.Single<?>) source).toFlowable(),\n\t\t\t\t\tio.reactivex.rxjava3.core.Single::fromPublisher);\n\n\t\t\tregistry.registerReactiveType(\n\t\t\t\t\tReactiveTypeDescriptor.singleOptionalValue(\n\t\t\t\t\t\t\tio.reactivex.rxjava3.core.Maybe.class,\n\t\t\t\t\t\t\tio.reactivex.rxjava3.core.Maybe::empty),\n\t\t\t\t\tsource -> ((io.reactivex.rxjava3.core.Maybe<?>) source).toFlowable(),\n\t\t\t\t\tio.reactivex.rxjava3.core.Maybe::fromPublisher);\n\n\t\t\tregistry.registerReactiveType(\n\t\t\t\t\tReactiveTypeDescriptor.noValue(\n\t\t\t\t\t\t\tio.reactivex.rxjava3.core.Completable.class,\n\t\t\t\t\t\t\tio.reactivex.rxjava3.core.Completable::complete),\n\t\t\t\t\tsource -> ((io.reactivex.rxjava3.core.Completable) source).toFlowable(),\n\t\t\t\t\tio.reactivex.rxjava3.core.Completable::fromPublisher);\n\t\t}\n\t}\n\n\n\tprivate static class CoroutinesRegistrar {\n\n\t\t@SuppressWarnings(\"KotlinInternalInJava\")\n\t\tvoid registerAdapters(ReactiveAdapterRegistry registry) {\n\t\t\tregistry.registerReactiveType(\n\t\t\t\t\tReactiveTypeDescriptor.singleOptionalValue(Deferred.class,\n\t\t\t\t\t\t\t() -> CompletableDeferredKt.CompletableDeferred(null)),\n\t\t\t\t\tsource -> CoroutinesUtils.deferredToMono((Deferred<?>) source),\n\t\t\t\t\tsource -> CoroutinesUtils.monoToDeferred(Mono.from(source)));\n\n\t\t\tregistry.registerReactiveType(\n\t\t\t\t\tReactiveTypeDescriptor.multiValue(kotlinx.coroutines.flow.Flow.class, kotlinx.coroutines.flow.FlowKt::emptyFlow),\n\t\t\t\t\tsource -> kotlinx.coroutines.reactor.ReactorFlowKt.asFlux((kotlinx.coroutines.flow.Flow<?>) source),\n\t\t\t\t\tkotlinx.coroutines.reactive.ReactiveFlowKt::asFlow);\n\t\t}\n\t}\n\n\n\tprivate static class MutinyRegistrar {\n\n\t\tvoid registerAdapters(ReactiveAdapterRegistry registry) {\n\t\t\tregistry.registerReactiveType(\n\t\t\t\t\tReactiveTypeDescriptor.singleOptionalValue(\n\t\t\t\t\t\t\tio.smallrye.mutiny.Uni.class,\n\t\t\t\t\t\t\t() -> io.smallrye.mutiny.Uni.createFrom().nothing()),\n\t\t\t\t\tuni -> ((io.smallrye.mutiny.Uni<?>) uni).convert().toPublisher(),\n\t\t\t\t\tpublisher -> io.smallrye.mutiny.Uni.createFrom().publisher(publisher));\n\n\t\t\tregistry.registerReactiveType(\n\t\t\t\t\tReactiveTypeDescriptor.multiValue(\n\t\t\t\t\t\t\tio.smallrye.mutiny.Multi.class,\n\t\t\t\t\t\t\t() -> io.smallrye.mutiny.Multi.createFrom().empty()),\n\t\t\t\t\tmulti -> (io.smallrye.mutiny.Multi<?>) multi,\n\t\t\t\t\tpublisher -> io.smallrye.mutiny.Multi.createFrom().publisher(publisher));\n\t\t}\n\t}\n\n\n\t/**\n\t * {@code BlockHoundIntegration} for spring-core classes.\n\t * Explicitly allows locking within {@link ConcurrentReferenceHashMap}.\n\t * @since 5.2.4\n\t */\n\tpublic static class SpringCoreBlockHoundIntegration implements BlockHoundIntegration {\n\n\t\t@Override\n\t\tpublic void applyTo(BlockHound.Builder builder) {\n\t\t\t// Avoid hard references potentially anywhere in spring-core (no need for structural dependency)\n\n\t\t\tString className = \"org.springframework.util.ConcurrentReferenceHashMap$Segment\";\n\t\t\tbuilder.allowBlockingCallsInside(className, \"doTask\");\n\t\t\tbuilder.allowBlockingCallsInside(className, \"clear\");\n\t\t\tbuilder.allowBlockingCallsInside(className, \"restructure\");\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.core.ReactiveAdapterRegistry#applyTo(builder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "builder"
    ],
    "position": {
      "column": 1,
      "line": 348
    },
    "return": "void",
    "signature": "public void applyTo(BlockHound.Builder builder)",
    "source_code": "\t\tpublic void applyTo(BlockHound.Builder builder) {\n\t\t\t// Avoid hard references potentially anywhere in spring-core (no need for structural dependency)\n\n\t\t\tString className = \"org.springframework.util.ConcurrentReferenceHashMap$Segment\";\n\t\t\tbuilder.allowBlockingCallsInside(className, \"doTask\");\n\t\t\tbuilder.allowBlockingCallsInside(className, \"clear\");\n\t\t\tbuilder.allowBlockingCallsInside(className, \"restructure\");\n\t\t}"
  },
  "org.springframework.core.ReactiveAdapterRegistry#getAdapter(reactiveType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the adapter for the given reactive type.\n\t * @return the corresponding adapter, or {@code null} if none available\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "reactiveType"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "ReactiveAdapter",
    "signature": "public ReactiveAdapter getAdapter(Class<?> reactiveType)",
    "source_code": "\tpublic ReactiveAdapter getAdapter(Class<?> reactiveType) {\n\t\treturn getAdapter(reactiveType, null);\n\t}"
  },
  "org.springframework.core.ReactiveAdapterRegistry#getAdapter(reactiveType,source)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the adapter for the given reactive type. Or if a \"source\" object is\n\t * provided, its actual type is used instead.\n\t * @param reactiveType the reactive type\n\t * (may be {@code null} if a concrete source object is given)\n\t * @param source an instance of the reactive type\n\t * (i.e. to adapt from; may be {@code null} if the reactive type is specified)\n\t * @return the corresponding adapter, or {@code null} if none available\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "reactiveType",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "ReactiveAdapter",
    "signature": "public ReactiveAdapter getAdapter(@Nullable Class<?> reactiveType, @Nullable Object source)",
    "source_code": "\tpublic ReactiveAdapter getAdapter(@Nullable Class<?> reactiveType, @Nullable Object source) {\n\t\tif (this.adapters.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tObject sourceToUse = (source instanceof Optional<?> optional ? optional.orElse(null) : source);\n\t\tClass<?> clazz = (sourceToUse != null ? sourceToUse.getClass() : reactiveType);\n\t\tif (clazz == null) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (ReactiveAdapter adapter : this.adapters) {\n\t\t\tif (adapter.getReactiveType() == clazz) {\n\t\t\t\treturn adapter;\n\t\t\t}\n\t\t}\n\t\tfor (ReactiveAdapter adapter : this.adapters) {\n\t\t\tif (adapter.getReactiveType().isAssignableFrom(clazz)) {\n\t\t\t\treturn adapter;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.core.ReactiveAdapterRegistry#getSharedInstance()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a shared default {@code ReactiveAdapterRegistry} instance,\n\t * lazily building it once needed.\n\t * <p><b>NOTE:</b> We highly recommend passing a long-lived, pre-configured\n\t * {@code ReactiveAdapterRegistry} instance for customization purposes.\n\t * This accessor is only meant as a fallback for code paths that want to\n\t * fall back on a default instance if one isn't provided.\n\t * @return the shared {@code ReactiveAdapterRegistry} instance\n\t * @since 5.0.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "ReactiveAdapterRegistry",
    "signature": "public ReactiveAdapterRegistry getSharedInstance()",
    "source_code": "\tpublic static ReactiveAdapterRegistry getSharedInstance() {\n\t\tReactiveAdapterRegistry registry = sharedInstance;\n\t\tif (registry == null) {\n\t\t\tsynchronized (ReactiveAdapterRegistry.class) {\n\t\t\t\tregistry = sharedInstance;\n\t\t\t\tif (registry == null) {\n\t\t\t\t\tregistry = new ReactiveAdapterRegistry();\n\t\t\t\t\tsharedInstance = registry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn registry;\n\t}"
  },
  "org.springframework.core.ReactiveAdapterRegistry#hasAdapters()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the registry has any adapters.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "boolean",
    "signature": "public boolean hasAdapters()",
    "source_code": "\tpublic boolean hasAdapters() {\n\t\treturn !this.adapters.isEmpty();\n\t}"
  },
  "org.springframework.core.ReactiveAdapterRegistry#registerReactiveType(descriptor,Function<Object,toAdapter,Function<Publisher<?>,fromAdapter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a reactive type along with functions to adapt to and from a\n\t * Reactive Streams {@link Publisher}. The function arguments assume that\n\t * their input is neither {@code null} nor {@link Optional}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "Function<Object",
      "toAdapter",
      "Function<Publisher<?>",
      "fromAdapter"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "void",
    "signature": "public void registerReactiveType(ReactiveTypeDescriptor descriptor,\n\t\t\tFunction<Object, Publisher<?>> toAdapter, Function<Publisher<?>, Object> fromAdapter)",
    "source_code": "\tpublic void registerReactiveType(ReactiveTypeDescriptor descriptor,"
  },
  "org.springframework.core.ReactiveAdapterRegistry#toPublisher(source)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source"
    ],
    "position": {
      "column": 1,
      "line": 212
    },
    "return": "Publisher<T>",
    "signature": "public Publisher<T> toPublisher(@Nullable Object source)",
    "source_code": "\t\tpublic <T> Publisher<T> toPublisher(@Nullable Object source) {\n\t\t\tPublisher<T> publisher = super.toPublisher(source);\n\t\t\treturn (isMultiValue() ? Flux.from(publisher) : Mono.from(publisher));\n\t\t}"
  },
  "org.springframework.core.SpringCoreBlockHoundIntegration": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@code BlockHoundIntegration} for spring-core classes.\n\t * Explicitly allows locking within {@link ConcurrentReferenceHashMap}.\n\t * @since 5.2.4\n\t */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 345
    },
    "signature": "public class SpringCoreBlockHoundIntegration",
    "source_code": "\tpublic static class SpringCoreBlockHoundIntegration implements BlockHoundIntegration {\n\n\t\t@Override\n\t\tpublic void applyTo(BlockHound.Builder builder) {\n\t\t\t// Avoid hard references potentially anywhere in spring-core (no need for structural dependency)\n\n\t\t\tString className = \"org.springframework.util.ConcurrentReferenceHashMap$Segment\";\n\t\t\tbuilder.allowBlockingCallsInside(className, \"doTask\");\n\t\t\tbuilder.allowBlockingCallsInside(className, \"clear\");\n\t\t\tbuilder.allowBlockingCallsInside(className, \"restructure\");\n\t\t}\n\t}"
  },
  "org.springframework.core.codec.Decoder": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Strategy for decoding a {@link DataBuffer} input stream into an output stream\n * of elements of type {@code <T>}.\n *\n * @author Sebastien Deleuze\n * @author Rossen Stoyanchev\n * @since 5.0\n * @param <T> the type of elements in the output stream\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "signature": "public interface Decoder",
    "source_code": "public interface Decoder<T> {\n\n\t/**\n\t * Whether the decoder supports the given target element type and the MIME\n\t * type of the source stream.\n\t * @param elementType the target element type for the output stream\n\t * @param mimeType the mime type associated with the stream to decode\n\t * (can be {@code null} if not specified)\n\t * @return {@code true} if supported, {@code false} otherwise\n\t */\n\tboolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType);\n\n\t/**\n\t * Decode a {@link DataBuffer} input stream into a Flux of {@code T}.\n\t * @param inputStream the {@code DataBuffer} input stream to decode\n\t * @param elementType the expected type of elements in the output stream;\n\t * this type must have been previously passed to the {@link #canDecode}\n\t * method and it must have returned {@code true}.\n\t * @param mimeType the MIME type associated with the input stream (optional)\n\t * @param hints additional information about how to do decode\n\t * @return the output stream with decoded elements\n\t */\n\tFlux<T> decode(Publisher<DataBuffer> inputStream, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints);\n\n\t/**\n\t * Decode a {@link DataBuffer} input stream into a Mono of {@code T}.\n\t * @param inputStream the {@code DataBuffer} input stream to decode\n\t * @param elementType the expected type of elements in the output stream;\n\t * this type must have been previously passed to the {@link #canDecode}\n\t * method and it must have returned {@code true}.\n\t * @param mimeType the MIME type associated with the input stream (optional)\n\t * @param hints additional information about how to do decode\n\t * @return the output stream with the decoded element\n\t */\n\tMono<T> decodeToMono(Publisher<DataBuffer> inputStream, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints);\n\n\t/**\n\t * Decode a data buffer to an Object of type T. This is useful for scenarios,\n\t * that distinct messages (or events) are decoded and handled individually,\n\t * in fully aggregated form.\n\t * @param buffer the {@code DataBuffer} to decode\n\t * @param targetType the expected output type\n\t * @param mimeType the MIME type associated with the data\n\t * @param hints additional information about how to do decode\n\t * @return the decoded value, possibly {@code null}\n\t * @since 5.2\n\t */\n\t@Nullable\n\tdefault T decode(DataBuffer buffer, ResolvableType targetType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) throws DecodingException {\n\n\t\tCompletableFuture<T> future = decodeToMono(Mono.just(buffer), targetType, mimeType, hints).toFuture();\n\t\tAssert.state(future.isDone(), \"DataBuffer decoding should have completed.\");\n\n\t\tThrowable failure;\n\t\ttry {\n\t\t\treturn future.get();\n\t\t}\n\t\tcatch (ExecutionException ex) {\n\t\t\tfailure = ex.getCause();\n\t\t}\n\t\tcatch (InterruptedException ex) {\n\t\t\tfailure = ex;\n\t\t}\n\t\tthrow (failure instanceof CodecException codecException ? codecException :\n\t\t\t\tnew DecodingException(\"Failed to decode: \" + failure.getMessage(), failure));\n\t}\n\n\t/**\n\t * Return the list of MIME types supported by this Decoder. The list may not\n\t * apply to every possible target element type and calls to this method\n\t * should typically be guarded via {@link #canDecode(ResolvableType, MimeType)\n\t * canDecode(elementType, null)}. The list may also exclude MIME types\n\t * supported only for a specific element type. Alternatively, use\n\t * {@link #getDecodableMimeTypes(ResolvableType)} for a more precise list.\n\t * @return the list of supported MIME types\n\t */\n\tList<MimeType> getDecodableMimeTypes();\n\n\t/**\n\t * Return the list of MIME types supported by this Decoder for the given type\n\t * of element. This list may differ from {@link #getDecodableMimeTypes()}\n\t * if the Decoder doesn't support the given element type or if it supports\n\t * it only for a subset of MIME types.\n\t * @param targetType the type of element to check for decoding\n\t * @return the list of MIME types supported for the given target type\n\t * @since 5.3.4\n\t */\n\tdefault List<MimeType> getDecodableMimeTypes(ResolvableType targetType) {\n\t\treturn (canDecode(targetType, null) ? getDecodableMimeTypes() : Collections.emptyList());\n\t}\n\n}"
  },
  "org.springframework.core.convert.TypeDescriptor#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 782
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object obj) {\n\t\t\treturn (this == obj || (obj instanceof AnnotatedElementAdapter that &&\n\t\t\t\t\tArrays.equals(this.annotations, that.annotations)));\n\t\t}"
  },
  "org.springframework.core.io.buffer.Netty5DataBuffer#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 340
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof Netty5DataBuffer that && this.buffer.equals(that.buffer)));\n\t}"
  },
  "org.springframework.core.io.buffer.Netty5DataBuffer#equals(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 340
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof Netty5DataBuffer dataBuffer &&\n\t\t\t\tthis.buffer.equals(dataBuffer.buffer)));\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Implementation of the {@code DataBuffer} interface that wraps a Netty 4\n * {@link ByteBuf}. Typically constructed with {@link NettyDataBufferFactory}.\n *\n * @author Arjen Poutsma\n * @author Brian Clozel\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 40
    },
    "signature": "public class NettyDataBuffer",
    "source_code": "public class NettyDataBuffer implements PooledDataBuffer {\n\n\tprivate ByteBuf byteBuf;\n\n\tprivate final NettyDataBufferFactory dataBufferFactory;\n\n\n\t/**\n\t * Create a new {@code NettyDataBuffer} based on the given {@code ByteBuff}.\n\t * @param byteBuf the buffer to base this buffer on\n\t */\n\tNettyDataBuffer(ByteBuf byteBuf, NettyDataBufferFactory dataBufferFactory) {\n\t\tAssert.notNull(byteBuf, \"ByteBuf must not be null\");\n\t\tAssert.notNull(dataBufferFactory, \"NettyDataBufferFactory must not be null\");\n\t\tthis.byteBuf = byteBuf;\n\t\tthis.dataBufferFactory = dataBufferFactory;\n\t}\n\n\n\t/**\n\t * Directly exposes the native {@code ByteBuf} that this buffer is based on.\n\t * @return the wrapped byte buffer\n\t */\n\tpublic ByteBuf getNativeBuffer() {\n\t\treturn this.byteBuf;\n\t}\n\n\t@Override\n\tpublic NettyDataBufferFactory factory() {\n\t\treturn this.dataBufferFactory;\n\t}\n\n\t@Override\n\tpublic int indexOf(IntPredicate predicate, int fromIndex) {\n\t\tAssert.notNull(predicate, \"IntPredicate must not be null\");\n\t\tif (fromIndex < 0) {\n\t\t\tfromIndex = 0;\n\t\t}\n\t\telse if (fromIndex >= this.byteBuf.writerIndex()) {\n\t\t\treturn -1;\n\t\t}\n\t\tint length = this.byteBuf.writerIndex() - fromIndex;\n\t\treturn this.byteBuf.forEachByte(fromIndex, length, predicate.negate()::test);\n\t}\n\n\t@Override\n\tpublic int lastIndexOf(IntPredicate predicate, int fromIndex) {\n\t\tAssert.notNull(predicate, \"IntPredicate must not be null\");\n\t\tif (fromIndex < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tfromIndex = Math.min(fromIndex, this.byteBuf.writerIndex() - 1);\n\t\treturn this.byteBuf.forEachByteDesc(0, fromIndex + 1, predicate.negate()::test);\n\t}\n\n\t@Override\n\tpublic int readableByteCount() {\n\t\treturn this.byteBuf.readableBytes();\n\t}\n\n\t@Override\n\tpublic int writableByteCount() {\n\t\treturn this.byteBuf.writableBytes();\n\t}\n\n\t@Override\n\tpublic int readPosition() {\n\t\treturn this.byteBuf.readerIndex();\n\t}\n\n\t@Override\n\tpublic NettyDataBuffer readPosition(int readPosition) {\n\t\tthis.byteBuf.readerIndex(readPosition);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic int writePosition() {\n\t\treturn this.byteBuf.writerIndex();\n\t}\n\n\t@Override\n\tpublic NettyDataBuffer writePosition(int writePosition) {\n\t\tthis.byteBuf.writerIndex(writePosition);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic byte getByte(int index) {\n\t\treturn this.byteBuf.getByte(index);\n\t}\n\n\t@Override\n\tpublic int capacity() {\n\t\treturn this.byteBuf.capacity();\n\t}\n\n\t@Override\n\t@Deprecated\n\tpublic NettyDataBuffer capacity(int capacity) {\n\t\tthis.byteBuf.capacity(capacity);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic DataBuffer ensureWritable(int capacity) {\n\t\tthis.byteBuf.ensureWritable(capacity);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic byte read() {\n\t\treturn this.byteBuf.readByte();\n\t}\n\n\t@Override\n\tpublic NettyDataBuffer read(byte[] destination) {\n\t\tthis.byteBuf.readBytes(destination);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic NettyDataBuffer read(byte[] destination, int offset, int length) {\n\t\tthis.byteBuf.readBytes(destination, offset, length);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic NettyDataBuffer write(byte b) {\n\t\tthis.byteBuf.writeByte(b);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic NettyDataBuffer write(byte[] source) {\n\t\tthis.byteBuf.writeBytes(source);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic NettyDataBuffer write(byte[] source, int offset, int length) {\n\t\tthis.byteBuf.writeBytes(source, offset, length);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic NettyDataBuffer write(DataBuffer... dataBuffers) {\n\t\tif (!ObjectUtils.isEmpty(dataBuffers)) {\n\t\t\tif (hasNettyDataBuffers(dataBuffers)) {\n\t\t\t\tByteBuf[] nativeBuffers = new ByteBuf[dataBuffers.length];\n\t\t\t\tfor (int i = 0; i < dataBuffers.length; i++) {\n\t\t\t\t\tnativeBuffers[i] = ((NettyDataBuffer) dataBuffers[i]).getNativeBuffer();\n\t\t\t\t}\n\t\t\t\twrite(nativeBuffers);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tByteBuffer[] byteBuffers = new ByteBuffer[dataBuffers.length];\n\t\t\t\tfor (int i = 0; i < dataBuffers.length; i++) {\n\t\t\t\t\tbyteBuffers[i] = ByteBuffer.allocate(dataBuffers[i].readableByteCount());\n\t\t\t\t\tdataBuffers[i].toByteBuffer(byteBuffers[i]);\n\t\t\t\t}\n\t\t\t\twrite(byteBuffers);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\tprivate static boolean hasNettyDataBuffers(DataBuffer[] buffers) {\n\t\tfor (DataBuffer buffer : buffers) {\n\t\t\tif (!(buffer instanceof NettyDataBuffer)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic NettyDataBuffer write(ByteBuffer... buffers) {\n\t\tif (!ObjectUtils.isEmpty(buffers)) {\n\t\t\tfor (ByteBuffer buffer : buffers) {\n\t\t\t\tthis.byteBuf.writeBytes(buffer);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Writes one or more Netty {@link ByteBuf ByteBufs} to this buffer,\n\t * starting at the current writing position.\n\t * @param byteBufs the buffers to write into this buffer\n\t * @return this buffer\n\t */\n\tpublic NettyDataBuffer write(ByteBuf... byteBufs) {\n\t\tif (!ObjectUtils.isEmpty(byteBufs)) {\n\t\t\tfor (ByteBuf byteBuf : byteBufs) {\n\t\t\t\tthis.byteBuf.writeBytes(byteBuf);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic DataBuffer write(CharSequence charSequence, Charset charset) {\n\t\tAssert.notNull(charSequence, \"CharSequence must not be null\");\n\t\tAssert.notNull(charset, \"Charset must not be null\");\n\t\tif (StandardCharsets.UTF_8.equals(charset)) {\n\t\t\tByteBufUtil.writeUtf8(this.byteBuf, charSequence);\n\t\t}\n\t\telse if (StandardCharsets.US_ASCII.equals(charset)) {\n\t\t\tByteBufUtil.writeAscii(this.byteBuf, charSequence);\n\t\t}\n\t\telse {\n\t\t\treturn PooledDataBuffer.super.write(charSequence, charset);\n\t\t}\n\t\treturn this;\n\t}\n\n\t@Override\n\t@Deprecated\n\tpublic NettyDataBuffer slice(int index, int length) {\n\t\tByteBuf slice = this.byteBuf.slice(index, length);\n\t\treturn new NettyDataBuffer(slice, this.dataBufferFactory);\n\t}\n\n\t@Override\n\t@Deprecated\n\tpublic NettyDataBuffer retainedSlice(int index, int length) {\n\t\tByteBuf slice = this.byteBuf.retainedSlice(index, length);\n\t\treturn new NettyDataBuffer(slice, this.dataBufferFactory);\n\t}\n\n\t@Override\n\tpublic NettyDataBuffer split(int index) {\n\t\tByteBuf split = this.byteBuf.retainedSlice(0, index);\n\t\tint writerIndex = this.byteBuf.writerIndex();\n\t\tint readerIndex = this.byteBuf.readerIndex();\n\n\t\tsplit.writerIndex(Math.min(writerIndex, index));\n\t\tsplit.readerIndex(Math.min(readerIndex, index));\n\n\t\tthis.byteBuf = this.byteBuf.slice(index, this.byteBuf.capacity() - index);\n\t\tthis.byteBuf.writerIndex(Math.max(writerIndex, index) - index);\n\t\tthis.byteBuf.readerIndex(Math.max(readerIndex, index) - index);\n\n\t\treturn new NettyDataBuffer(split, this.dataBufferFactory);\n\t}\n\n\t@Override\n\t@Deprecated\n\tpublic ByteBuffer asByteBuffer() {\n\t\treturn this.byteBuf.nioBuffer();\n\t}\n\n\t@Override\n\t@Deprecated\n\tpublic ByteBuffer asByteBuffer(int index, int length) {\n\t\treturn this.byteBuf.nioBuffer(index, length);\n\t}\n\n\t@Override\n\t@Deprecated\n\tpublic ByteBuffer toByteBuffer(int index, int length) {\n\t\tByteBuffer result = this.byteBuf.isDirect() ?\n\t\t\t\tByteBuffer.allocateDirect(length) :\n\t\t\t\tByteBuffer.allocate(length);\n\n\t\tthis.byteBuf.getBytes(index, result);\n\n\t\treturn result.flip();\n\t}\n\n\t@Override\n\tpublic void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length) {\n\t\tAssert.notNull(dest, \"Dest must not be null\");\n\n\t\tdest = dest.duplicate().clear();\n\t\tdest.put(destPos, this.byteBuf.nioBuffer(), srcPos, length);\n\t}\n\n\t@Override\n\tpublic DataBuffer.ByteBufferIterator readableByteBuffers() {\n\t\tByteBuffer[] readable = this.byteBuf.nioBuffers(this.byteBuf.readerIndex(), this.byteBuf.readableBytes());\n\t\treturn new ByteBufferIterator(readable, true);\n\t}\n\n\t@Override\n\tpublic DataBuffer.ByteBufferIterator writableByteBuffers() {\n\t\tByteBuffer[] writable = this.byteBuf.nioBuffers(this.byteBuf.writerIndex(), this.byteBuf.writableBytes());\n\t\treturn new ByteBufferIterator(writable, false);\n\t}\n\n\t@Override\n\tpublic String toString(Charset charset) {\n\t\tAssert.notNull(charset, \"Charset must not be null\");\n\t\treturn this.byteBuf.toString(charset);\n\t}\n\n\t@Override\n\tpublic String toString(int index, int length, Charset charset) {\n\t\tAssert.notNull(charset, \"Charset must not be null\");\n\t\treturn this.byteBuf.toString(index, length, charset);\n\t}\n\n\t@Override\n\tpublic boolean isAllocated() {\n\t\treturn this.byteBuf.refCnt() > 0;\n\t}\n\n\t@Override\n\tpublic PooledDataBuffer retain() {\n\t\treturn new NettyDataBuffer(this.byteBuf.retain(), this.dataBufferFactory);\n\t}\n\n\t@Override\n\tpublic PooledDataBuffer touch(Object hint) {\n\t\tthis.byteBuf.touch(hint);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic boolean release() {\n\t\treturn this.byteBuf.release();\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof NettyDataBuffer that && this.byteBuf.equals(that.byteBuf)));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.byteBuf.hashCode();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn this.byteBuf.toString();\n\t}\n\n\n\tprivate static final class ByteBufferIterator implements DataBuffer.ByteBufferIterator {\n\n\t\tprivate final ByteBuffer[] byteBuffers;\n\n\t\tprivate final boolean readOnly;\n\n\t\tprivate int cursor = 0;\n\n\n\t\tpublic ByteBufferIterator(ByteBuffer[] byteBuffers, boolean readOnly) {\n\t\t\tthis.byteBuffers = byteBuffers;\n\t\t\tthis.readOnly = readOnly;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn this.cursor < this.byteBuffers.length;\n\t\t}\n\n\t\t@Override\n\t\tpublic ByteBuffer next() {\n\t\t\tint index = this.cursor;\n\t\t\tif (index < this.byteBuffers.length) {\n\t\t\t\tthis.cursor = index + 1;\n\t\t\t\tByteBuffer next = this.byteBuffers[index];\n\t\t\t\treturn this.readOnly ? next.asReadOnlyBuffer() : next;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void close() {\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#asByteBuffer()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 289
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer asByteBuffer()",
    "source_code": "\tpublic ByteBuffer asByteBuffer() {\n\t\treturn this.byteBuf.nioBuffer();\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#asByteBuffer(index,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 295
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer asByteBuffer(int index, int length)",
    "source_code": "\tpublic ByteBuffer asByteBuffer(int index, int length) {\n\t\treturn this.byteBuf.nioBuffer(index, length);\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#capacity()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "int",
    "signature": "public int capacity()",
    "source_code": "\tpublic int capacity() {\n\t\treturn this.byteBuf.capacity();\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#capacity(capacity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "NettyDataBuffer",
    "signature": "public NettyDataBuffer capacity(int capacity)",
    "source_code": "\tpublic NettyDataBuffer capacity(int capacity) {\n\t\tthis.byteBuf.capacity(capacity);\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#close()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 414
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\t\tpublic void close() {\n\t\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#ensureWritable(capacity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer ensureWritable(int capacity)",
    "source_code": "\tpublic DataBuffer ensureWritable(int capacity) {\n\t\tthis.byteBuf.ensureWritable(capacity);\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 366
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof NettyDataBuffer that && this.byteBuf.equals(that.byteBuf)));\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#factory()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "NettyDataBufferFactory",
    "signature": "public NettyDataBufferFactory factory()",
    "source_code": "\tpublic NettyDataBufferFactory factory() {\n\t\treturn this.dataBufferFactory;\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#getByte(index)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "byte",
    "signature": "public byte getByte(int index)",
    "source_code": "\tpublic byte getByte(int index) {\n\t\treturn this.byteBuf.getByte(index);\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#getNativeBuffer()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Directly exposes the native {@code ByteBuf} that this buffer is based on.\n\t * @return the wrapped byte buffer\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "ByteBuf",
    "signature": "public ByteBuf getNativeBuffer()",
    "source_code": "\tpublic ByteBuf getNativeBuffer() {\n\t\treturn this.byteBuf;\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#hasNext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 396
    },
    "return": "boolean",
    "signature": "public boolean hasNext()",
    "source_code": "\t\tpublic boolean hasNext() {\n\t\t\treturn this.cursor < this.byteBuffers.length;\n\t\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 371
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.byteBuf.hashCode();\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#indexOf(predicate,fromIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "fromIndex"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "int",
    "signature": "public int indexOf(IntPredicate predicate, int fromIndex)",
    "source_code": "\tpublic int indexOf(IntPredicate predicate, int fromIndex) {\n\t\tAssert.notNull(predicate, \"IntPredicate must not be null\");\n\t\tif (fromIndex < 0) {\n\t\t\tfromIndex = 0;\n\t\t}\n\t\telse if (fromIndex >= this.byteBuf.writerIndex()) {\n\t\t\treturn -1;\n\t\t}\n\t\tint length = this.byteBuf.writerIndex() - fromIndex;\n\t\treturn this.byteBuf.forEachByte(fromIndex, length, predicate.negate()::test);\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#isAllocated()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 344
    },
    "return": "boolean",
    "signature": "public boolean isAllocated()",
    "source_code": "\tpublic boolean isAllocated() {\n\t\treturn this.byteBuf.refCnt() > 0;\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#lastIndexOf(predicate,fromIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "fromIndex"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "int",
    "signature": "public int lastIndexOf(IntPredicate predicate, int fromIndex)",
    "source_code": "\tpublic int lastIndexOf(IntPredicate predicate, int fromIndex) {\n\t\tAssert.notNull(predicate, \"IntPredicate must not be null\");\n\t\tif (fromIndex < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tfromIndex = Math.min(fromIndex, this.byteBuf.writerIndex() - 1);\n\t\treturn this.byteBuf.forEachByteDesc(0, fromIndex + 1, predicate.negate()::test);\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#next()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 401
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer next()",
    "source_code": "\t\tpublic ByteBuffer next() {\n\t\t\tint index = this.cursor;\n\t\t\tif (index < this.byteBuffers.length) {\n\t\t\t\tthis.cursor = index + 1;\n\t\t\t\tByteBuffer next = this.byteBuffers[index];\n\t\t\t\treturn this.readOnly ? next.asReadOnlyBuffer() : next;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#read()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "byte",
    "signature": "public byte read()",
    "source_code": "\tpublic byte read() {\n\t\treturn this.byteBuf.readByte();\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#read(destination)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "NettyDataBuffer",
    "signature": "public NettyDataBuffer read(byte[] destination)",
    "source_code": "\tpublic NettyDataBuffer read(byte[] destination) {\n\t\tthis.byteBuf.readBytes(destination);\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#read(destination,offset,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "NettyDataBuffer",
    "signature": "public NettyDataBuffer read(byte[] destination, int offset, int length)",
    "source_code": "\tpublic NettyDataBuffer read(byte[] destination, int offset, int length) {\n\t\tthis.byteBuf.readBytes(destination, offset, length);\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#readPosition()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "int",
    "signature": "public int readPosition()",
    "source_code": "\tpublic int readPosition() {\n\t\treturn this.byteBuf.readerIndex();\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#readPosition(readPosition)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "readPosition"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "NettyDataBuffer",
    "signature": "public NettyDataBuffer readPosition(int readPosition)",
    "source_code": "\tpublic NettyDataBuffer readPosition(int readPosition) {\n\t\tthis.byteBuf.readerIndex(readPosition);\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#readableByteCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "int",
    "signature": "public int readableByteCount()",
    "source_code": "\tpublic int readableByteCount() {\n\t\treturn this.byteBuf.readableBytes();\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#release()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 360
    },
    "return": "boolean",
    "signature": "public boolean release()",
    "source_code": "\tpublic boolean release() {\n\t\treturn this.byteBuf.release();\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#retain()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 349
    },
    "return": "PooledDataBuffer",
    "signature": "public PooledDataBuffer retain()",
    "source_code": "\tpublic PooledDataBuffer retain() {\n\t\treturn new NettyDataBuffer(this.byteBuf.retain(), this.dataBufferFactory);\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#retainedSlice(index,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "NettyDataBuffer",
    "signature": "public NettyDataBuffer retainedSlice(int index, int length)",
    "source_code": "\tpublic NettyDataBuffer retainedSlice(int index, int length) {\n\t\tByteBuf slice = this.byteBuf.retainedSlice(index, length);\n\t\treturn new NettyDataBuffer(slice, this.dataBufferFactory);\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#slice(index,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 259
    },
    "return": "NettyDataBuffer",
    "signature": "public NettyDataBuffer slice(int index, int length)",
    "source_code": "\tpublic NettyDataBuffer slice(int index, int length) {\n\t\tByteBuf slice = this.byteBuf.slice(index, length);\n\t\treturn new NettyDataBuffer(slice, this.dataBufferFactory);\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#split(index)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "NettyDataBuffer",
    "signature": "public NettyDataBuffer split(int index)",
    "source_code": "\tpublic NettyDataBuffer split(int index) {\n\t\tByteBuf split = this.byteBuf.retainedSlice(0, index);\n\t\tint writerIndex = this.byteBuf.writerIndex();\n\t\tint readerIndex = this.byteBuf.readerIndex();\n\n\t\tsplit.writerIndex(Math.min(writerIndex, index));\n\t\tsplit.readerIndex(Math.min(readerIndex, index));\n\n\t\tthis.byteBuf = this.byteBuf.slice(index, this.byteBuf.capacity() - index);\n\t\tthis.byteBuf.writerIndex(Math.max(writerIndex, index) - index);\n\t\tthis.byteBuf.readerIndex(Math.max(readerIndex, index) - index);\n\n\t\treturn new NettyDataBuffer(split, this.dataBufferFactory);\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#toByteBuffer(index,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 301
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer toByteBuffer(int index, int length)",
    "source_code": "\tpublic ByteBuffer toByteBuffer(int index, int length) {\n\t\tByteBuffer result = this.byteBuf.isDirect() ?\n\t\t\t\tByteBuffer.allocateDirect(length) :\n\t\t\t\tByteBuffer.allocate(length);\n\n\t\tthis.byteBuf.getBytes(index, result);\n\n\t\treturn result.flip();\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#toByteBuffer(srcPos,dest,destPos,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "srcPos",
      "dest",
      "destPos",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 312
    },
    "return": "void",
    "signature": "public void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length)",
    "source_code": "\tpublic void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length) {\n\t\tAssert.notNull(dest, \"Dest must not be null\");\n\n\t\tdest = dest.duplicate().clear();\n\t\tdest.put(destPos, this.byteBuf.nioBuffer(), srcPos, length);\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 376
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn this.byteBuf.toString();\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#toString(charset)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 332
    },
    "return": "String",
    "signature": "public String toString(Charset charset)",
    "source_code": "\tpublic String toString(Charset charset) {\n\t\tAssert.notNull(charset, \"Charset must not be null\");\n\t\treturn this.byteBuf.toString(charset);\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#toString(index,length,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 338
    },
    "return": "String",
    "signature": "public String toString(int index, int length, Charset charset)",
    "source_code": "\tpublic String toString(int index, int length, Charset charset) {\n\t\tAssert.notNull(charset, \"Charset must not be null\");\n\t\treturn this.byteBuf.toString(index, length, charset);\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#touch(hint)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hint"
    ],
    "position": {
      "column": 1,
      "line": 354
    },
    "return": "PooledDataBuffer",
    "signature": "public PooledDataBuffer touch(Object hint)",
    "source_code": "\tpublic PooledDataBuffer touch(Object hint) {\n\t\tthis.byteBuf.touch(hint);\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#writableByteCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "int",
    "signature": "public int writableByteCount()",
    "source_code": "\tpublic int writableByteCount() {\n\t\treturn this.byteBuf.writableBytes();\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#write(b)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "NettyDataBuffer",
    "signature": "public NettyDataBuffer write(byte b)",
    "source_code": "\tpublic NettyDataBuffer write(byte b) {\n\t\tthis.byteBuf.writeByte(b);\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#write(buffers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "buffers"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "NettyDataBuffer",
    "signature": "public NettyDataBuffer write(ByteBuffer... buffers)",
    "source_code": "\tpublic NettyDataBuffer write(ByteBuffer... buffers) {\n\t\tif (!ObjectUtils.isEmpty(buffers)) {\n\t\t\tfor (ByteBuffer buffer : buffers) {\n\t\t\t\tthis.byteBuf.writeBytes(buffer);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#write(byteBufs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Writes one or more Netty {@link ByteBuf ByteBufs} to this buffer,\n\t * starting at the current writing position.\n\t * @param byteBufs the buffers to write into this buffer\n\t * @return this buffer\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "byteBufs"
    ],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "NettyDataBuffer",
    "signature": "public NettyDataBuffer write(ByteBuf... byteBufs)",
    "source_code": "\tpublic NettyDataBuffer write(ByteBuf... byteBufs) {\n\t\tif (!ObjectUtils.isEmpty(byteBufs)) {\n\t\t\tfor (ByteBuf byteBuf : byteBufs) {\n\t\t\t\tthis.byteBuf.writeBytes(byteBuf);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#write(charSequence,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "charSequence",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer write(CharSequence charSequence, Charset charset)",
    "source_code": "\tpublic DataBuffer write(CharSequence charSequence, Charset charset) {\n\t\tAssert.notNull(charSequence, \"CharSequence must not be null\");\n\t\tAssert.notNull(charset, \"Charset must not be null\");\n\t\tif (StandardCharsets.UTF_8.equals(charset)) {\n\t\t\tByteBufUtil.writeUtf8(this.byteBuf, charSequence);\n\t\t}\n\t\telse if (StandardCharsets.US_ASCII.equals(charset)) {\n\t\t\tByteBufUtil.writeAscii(this.byteBuf, charSequence);\n\t\t}\n\t\telse {\n\t\t\treturn PooledDataBuffer.super.write(charSequence, charset);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#write(dataBuffers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataBuffers"
    ],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "NettyDataBuffer",
    "signature": "public NettyDataBuffer write(DataBuffer... dataBuffers)",
    "source_code": "\tpublic NettyDataBuffer write(DataBuffer... dataBuffers) {\n\t\tif (!ObjectUtils.isEmpty(dataBuffers)) {\n\t\t\tif (hasNettyDataBuffers(dataBuffers)) {\n\t\t\t\tByteBuf[] nativeBuffers = new ByteBuf[dataBuffers.length];\n\t\t\t\tfor (int i = 0; i < dataBuffers.length; i++) {\n\t\t\t\t\tnativeBuffers[i] = ((NettyDataBuffer) dataBuffers[i]).getNativeBuffer();\n\t\t\t\t}\n\t\t\t\twrite(nativeBuffers);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tByteBuffer[] byteBuffers = new ByteBuffer[dataBuffers.length];\n\t\t\t\tfor (int i = 0; i < dataBuffers.length; i++) {\n\t\t\t\t\tbyteBuffers[i] = ByteBuffer.allocate(dataBuffers[i].readableByteCount());\n\t\t\t\t\tdataBuffers[i].toByteBuffer(byteBuffers[i]);\n\t\t\t\t}\n\t\t\t\twrite(byteBuffers);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#write(source)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source"
    ],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "NettyDataBuffer",
    "signature": "public NettyDataBuffer write(byte[] source)",
    "source_code": "\tpublic NettyDataBuffer write(byte[] source) {\n\t\tthis.byteBuf.writeBytes(source);\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#write(source,offset,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "NettyDataBuffer",
    "signature": "public NettyDataBuffer write(byte[] source, int offset, int length)",
    "source_code": "\tpublic NettyDataBuffer write(byte[] source, int offset, int length) {\n\t\tthis.byteBuf.writeBytes(source, offset, length);\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#writePosition()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "int",
    "signature": "public int writePosition()",
    "source_code": "\tpublic int writePosition() {\n\t\treturn this.byteBuf.writerIndex();\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBuffer#writePosition(writePosition)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "writePosition"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "NettyDataBuffer",
    "signature": "public NettyDataBuffer writePosition(int writePosition)",
    "source_code": "\tpublic NettyDataBuffer writePosition(int writePosition) {\n\t\tthis.byteBuf.writerIndex(writePosition);\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.type.StandardClassMetadata": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link ClassMetadata} implementation that uses standard reflection\n * to introspect a given {@code Class}.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 2.5\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 34
    },
    "signature": "public class StandardClassMetadata",
    "source_code": "public class StandardClassMetadata implements ClassMetadata {\n\n\tprivate final Class<?> introspectedClass;\n\n\n\t/**\n\t * Create a new StandardClassMetadata wrapper for the given Class.\n\t * @param introspectedClass the Class to introspect\n\t * @deprecated since 5.2 in favor of {@link StandardAnnotationMetadata}\n\t */\n\t@Deprecated\n\tpublic StandardClassMetadata(Class<?> introspectedClass) {\n\t\tAssert.notNull(introspectedClass, \"Class must not be null\");\n\t\tthis.introspectedClass = introspectedClass;\n\t}\n\n\t/**\n\t * Return the underlying Class.\n\t */\n\tpublic final Class<?> getIntrospectedClass() {\n\t\treturn this.introspectedClass;\n\t}\n\n\n\t@Override\n\tpublic String getClassName() {\n\t\treturn this.introspectedClass.getName();\n\t}\n\n\t@Override\n\tpublic boolean isInterface() {\n\t\treturn this.introspectedClass.isInterface();\n\t}\n\n\t@Override\n\tpublic boolean isAnnotation() {\n\t\treturn this.introspectedClass.isAnnotation();\n\t}\n\n\t@Override\n\tpublic boolean isAbstract() {\n\t\treturn Modifier.isAbstract(this.introspectedClass.getModifiers());\n\t}\n\n\t@Override\n\tpublic boolean isFinal() {\n\t\treturn Modifier.isFinal(this.introspectedClass.getModifiers());\n\t}\n\n\t@Override\n\tpublic boolean isIndependent() {\n\t\treturn (!hasEnclosingClass() ||\n\t\t\t\t(this.introspectedClass.getDeclaringClass() != null &&\n\t\t\t\t\t\tModifier.isStatic(this.introspectedClass.getModifiers())));\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic String getEnclosingClassName() {\n\t\tClass<?> enclosingClass = this.introspectedClass.getEnclosingClass();\n\t\treturn (enclosingClass != null ? enclosingClass.getName() : null);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic String getSuperClassName() {\n\t\tClass<?> superClass = this.introspectedClass.getSuperclass();\n\t\treturn (superClass != null ? superClass.getName() : null);\n\t}\n\n\t@Override\n\tpublic String[] getInterfaceNames() {\n\t\tClass<?>[] ifcs = this.introspectedClass.getInterfaces();\n\t\tString[] ifcNames = new String[ifcs.length];\n\t\tfor (int i = 0; i < ifcs.length; i++) {\n\t\t\tifcNames[i] = ifcs[i].getName();\n\t\t}\n\t\treturn ifcNames;\n\t}\n\n\t@Override\n\tpublic String[] getMemberClassNames() {\n\t\tLinkedHashSet<String> memberClassNames = new LinkedHashSet<>(4);\n\t\tfor (Class<?> nestedClass : this.introspectedClass.getDeclaredClasses()) {\n\t\t\tmemberClassNames.add(nestedClass.getName());\n\t\t}\n\t\treturn StringUtils.toStringArray(memberClassNames);\n\t}\n\n\t@Override\n\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof StandardClassMetadata that &&\n\t\t\t\tgetIntrospectedClass().equals(that.getIntrospectedClass())));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn getIntrospectedClass().hashCode();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getClassName();\n\t}\n\n}"
  },
  "org.springframework.core.type.StandardClassMetadata#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof StandardClassMetadata that &&\n\t\t\t\tgetIntrospectedClass().equals(that.getIntrospectedClass())));\n\t}"
  },
  "org.springframework.core.type.StandardClassMetadata#getClassName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "String",
    "signature": "public String getClassName()",
    "source_code": "\tpublic String getClassName() {\n\t\treturn this.introspectedClass.getName();\n\t}"
  },
  "org.springframework.core.type.StandardClassMetadata#getEnclosingClassName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "String",
    "signature": "public String getEnclosingClassName()",
    "source_code": "\tpublic String getEnclosingClassName() {\n\t\tClass<?> enclosingClass = this.introspectedClass.getEnclosingClass();\n\t\treturn (enclosingClass != null ? enclosingClass.getName() : null);\n\t}"
  },
  "org.springframework.core.type.StandardClassMetadata#getInterfaceNames()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "String[]",
    "signature": "public String[] getInterfaceNames()",
    "source_code": "\tpublic String[] getInterfaceNames() {\n\t\tClass<?>[] ifcs = this.introspectedClass.getInterfaces();\n\t\tString[] ifcNames = new String[ifcs.length];\n\t\tfor (int i = 0; i < ifcs.length; i++) {\n\t\t\tifcNames[i] = ifcs[i].getName();\n\t\t}\n\t\treturn ifcNames;\n\t}"
  },
  "org.springframework.core.type.StandardClassMetadata#getMemberClassNames()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "String[]",
    "signature": "public String[] getMemberClassNames()",
    "source_code": "\tpublic String[] getMemberClassNames() {\n\t\tLinkedHashSet<String> memberClassNames = new LinkedHashSet<>(4);\n\t\tfor (Class<?> nestedClass : this.introspectedClass.getDeclaredClasses()) {\n\t\t\tmemberClassNames.add(nestedClass.getName());\n\t\t}\n\t\treturn StringUtils.toStringArray(memberClassNames);\n\t}"
  },
  "org.springframework.core.type.StandardClassMetadata#getSuperClassName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "String",
    "signature": "public String getSuperClassName()",
    "source_code": "\tpublic String getSuperClassName() {\n\t\tClass<?> superClass = this.introspectedClass.getSuperclass();\n\t\treturn (superClass != null ? superClass.getName() : null);\n\t}"
  },
  "org.springframework.core.type.StandardClassMetadata#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn getIntrospectedClass().hashCode();\n\t}"
  },
  "org.springframework.core.type.StandardClassMetadata#isAbstract()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "boolean",
    "signature": "public boolean isAbstract()",
    "source_code": "\tpublic boolean isAbstract() {\n\t\treturn Modifier.isAbstract(this.introspectedClass.getModifiers());\n\t}"
  },
  "org.springframework.core.type.StandardClassMetadata#isAnnotation()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "boolean",
    "signature": "public boolean isAnnotation()",
    "source_code": "\tpublic boolean isAnnotation() {\n\t\treturn this.introspectedClass.isAnnotation();\n\t}"
  },
  "org.springframework.core.type.StandardClassMetadata#isFinal()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "boolean",
    "signature": "public boolean isFinal()",
    "source_code": "\tpublic boolean isFinal() {\n\t\treturn Modifier.isFinal(this.introspectedClass.getModifiers());\n\t}"
  },
  "org.springframework.core.type.StandardClassMetadata#isIndependent()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "boolean",
    "signature": "public boolean isIndependent()",
    "source_code": "\tpublic boolean isIndependent() {\n\t\treturn (!hasEnclosingClass() ||\n\t\t\t\t(this.introspectedClass.getDeclaringClass() != null &&\n\t\t\t\t\t\tModifier.isStatic(this.introspectedClass.getModifiers())));\n\t}"
  },
  "org.springframework.core.type.StandardClassMetadata#isInterface()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "boolean",
    "signature": "public boolean isInterface()",
    "source_code": "\tpublic boolean isInterface() {\n\t\treturn this.introspectedClass.isInterface();\n\t}"
  },
  "org.springframework.core.type.StandardClassMetadata#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn getClassName();\n\t}"
  },
  "org.springframework.core.type.StandardMethodMetadata": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link MethodMetadata} implementation that uses standard reflection\n * to introspect a given {@code Method}.\n *\n * @author Juergen Hoeller\n * @author Mark Pollack\n * @author Chris Beams\n * @author Phillip Webb\n * @author Sam Brannen\n * @since 3.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public class StandardMethodMetadata",
    "source_code": "public class StandardMethodMetadata implements MethodMetadata {\n\n\tprivate final Method introspectedMethod;\n\n\tprivate final boolean nestedAnnotationsAsMap;\n\n\tprivate final MergedAnnotations mergedAnnotations;\n\n\n\t/**\n\t * Create a new StandardMethodMetadata wrapper for the given Method.\n\t * @param introspectedMethod the Method to introspect\n\t * @deprecated since 5.2 in favor of obtaining instances via {@link AnnotationMetadata}\n\t */\n\t@Deprecated\n\tpublic StandardMethodMetadata(Method introspectedMethod) {\n\t\tthis(introspectedMethod, false);\n\t}\n\n\t/**\n\t * Create a new StandardMethodMetadata wrapper for the given Method,\n\t * providing the option to return any nested annotations or annotation arrays in the\n\t * form of {@link org.springframework.core.annotation.AnnotationAttributes} instead\n\t * of actual {@link java.lang.annotation.Annotation} instances.\n\t * @param introspectedMethod the Method to introspect\n\t * @param nestedAnnotationsAsMap return nested annotations and annotation arrays as\n\t * {@link org.springframework.core.annotation.AnnotationAttributes} for compatibility\n\t * with ASM-based {@link AnnotationMetadata} implementations\n\t * @since 3.1.1\n\t */\n\tStandardMethodMetadata(Method introspectedMethod, boolean nestedAnnotationsAsMap) {\n\t\tAssert.notNull(introspectedMethod, \"Method must not be null\");\n\t\tthis.introspectedMethod = introspectedMethod;\n\t\tthis.nestedAnnotationsAsMap = nestedAnnotationsAsMap;\n\t\tthis.mergedAnnotations = MergedAnnotations.from(\n\t\t\t\tintrospectedMethod, SearchStrategy.DIRECT, RepeatableContainers.none());\n\t}\n\n\n\t@Override\n\tpublic MergedAnnotations getAnnotations() {\n\t\treturn this.mergedAnnotations;\n\t}\n\n\t/**\n\t * Return the underlying Method.\n\t */\n\tpublic final Method getIntrospectedMethod() {\n\t\treturn this.introspectedMethod;\n\t}\n\n\t@Override\n\tpublic String getMethodName() {\n\t\treturn this.introspectedMethod.getName();\n\t}\n\n\t@Override\n\tpublic String getDeclaringClassName() {\n\t\treturn this.introspectedMethod.getDeclaringClass().getName();\n\t}\n\n\t@Override\n\tpublic String getReturnTypeName() {\n\t\treturn this.introspectedMethod.getReturnType().getName();\n\t}\n\n\t@Override\n\tpublic boolean isAbstract() {\n\t\treturn Modifier.isAbstract(this.introspectedMethod.getModifiers());\n\t}\n\n\t@Override\n\tpublic boolean isStatic() {\n\t\treturn Modifier.isStatic(this.introspectedMethod.getModifiers());\n\t}\n\n\t@Override\n\tpublic boolean isFinal() {\n\t\treturn Modifier.isFinal(this.introspectedMethod.getModifiers());\n\t}\n\n\t@Override\n\tpublic boolean isOverridable() {\n\t\treturn !isStatic() && !isFinal() && !isPrivate();\n\t}\n\n\tprivate boolean isPrivate() {\n\t\treturn Modifier.isPrivate(this.introspectedMethod.getModifiers());\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Map<String, Object> getAnnotationAttributes(String annotationName, boolean classValuesAsString) {\n\t\tif (this.nestedAnnotationsAsMap) {\n\t\t\treturn MethodMetadata.super.getAnnotationAttributes(annotationName, classValuesAsString);\n\t\t}\n\t\treturn AnnotatedElementUtils.getMergedAnnotationAttributes(this.introspectedMethod,\n\t\t\t\tannotationName, classValuesAsString, false);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic MultiValueMap<String, Object> getAllAnnotationAttributes(String annotationName, boolean classValuesAsString) {\n\t\tif (this.nestedAnnotationsAsMap) {\n\t\t\treturn MethodMetadata.super.getAllAnnotationAttributes(annotationName, classValuesAsString);\n\t\t}\n\t\treturn AnnotatedElementUtils.getAllAnnotationAttributes(this.introspectedMethod,\n\t\t\t\tannotationName, classValuesAsString, false);\n\t}\n\n\t@Override\n\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof StandardMethodMetadata that &&\n\t\t\t\tthis.introspectedMethod.equals(that.introspectedMethod)));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.introspectedMethod.hashCode();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn this.introspectedMethod.toString();\n\t}\n\n}"
  },
  "org.springframework.core.type.StandardMethodMetadata#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof StandardMethodMetadata that &&\n\t\t\t\tthis.introspectedMethod.equals(that.introspectedMethod)));\n\t}"
  },
  "org.springframework.core.type.StandardMethodMetadata#getAllAnnotationAttributes(annotationName,classValuesAsString)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationName",
      "classValuesAsString"
    ],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "Object>",
    "signature": "public Object> getAllAnnotationAttributes(String annotationName, boolean classValuesAsString)",
    "source_code": "\tpublic MultiValueMap<String, Object> getAllAnnotationAttributes(String annotationName, boolean classValuesAsString) {\n\t\tif (this.nestedAnnotationsAsMap) {\n\t\t\treturn MethodMetadata.super.getAllAnnotationAttributes(annotationName, classValuesAsString);\n\t\t}\n\t\treturn AnnotatedElementUtils.getAllAnnotationAttributes(this.introspectedMethod,\n\t\t\t\tannotationName, classValuesAsString, false);\n\t}"
  },
  "org.springframework.core.type.StandardMethodMetadata#getAnnotationAttributes(annotationName,classValuesAsString)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationName",
      "classValuesAsString"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "Object>",
    "signature": "public Object> getAnnotationAttributes(String annotationName, boolean classValuesAsString)",
    "source_code": "\tpublic Map<String, Object> getAnnotationAttributes(String annotationName, boolean classValuesAsString) {\n\t\tif (this.nestedAnnotationsAsMap) {\n\t\t\treturn MethodMetadata.super.getAnnotationAttributes(annotationName, classValuesAsString);\n\t\t}\n\t\treturn AnnotatedElementUtils.getMergedAnnotationAttributes(this.introspectedMethod,\n\t\t\t\tannotationName, classValuesAsString, false);\n\t}"
  },
  "org.springframework.core.type.StandardMethodMetadata#getAnnotations()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "MergedAnnotations",
    "signature": "public MergedAnnotations getAnnotations()",
    "source_code": "\tpublic MergedAnnotations getAnnotations() {\n\t\treturn this.mergedAnnotations;\n\t}"
  },
  "org.springframework.core.type.StandardMethodMetadata#getDeclaringClassName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "String",
    "signature": "public String getDeclaringClassName()",
    "source_code": "\tpublic String getDeclaringClassName() {\n\t\treturn this.introspectedMethod.getDeclaringClass().getName();\n\t}"
  },
  "org.springframework.core.type.StandardMethodMetadata#getIntrospectedMethod()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the underlying Method.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "Method",
    "signature": "public Method getIntrospectedMethod()",
    "source_code": "\tpublic final Method getIntrospectedMethod() {\n\t\treturn this.introspectedMethod;\n\t}"
  },
  "org.springframework.core.type.StandardMethodMetadata#getMethodName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "String",
    "signature": "public String getMethodName()",
    "source_code": "\tpublic String getMethodName() {\n\t\treturn this.introspectedMethod.getName();\n\t}"
  },
  "org.springframework.core.type.StandardMethodMetadata#getReturnTypeName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "String",
    "signature": "public String getReturnTypeName()",
    "source_code": "\tpublic String getReturnTypeName() {\n\t\treturn this.introspectedMethod.getReturnType().getName();\n\t}"
  },
  "org.springframework.core.type.StandardMethodMetadata#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.introspectedMethod.hashCode();\n\t}"
  },
  "org.springframework.core.type.StandardMethodMetadata#isAbstract()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "boolean",
    "signature": "public boolean isAbstract()",
    "source_code": "\tpublic boolean isAbstract() {\n\t\treturn Modifier.isAbstract(this.introspectedMethod.getModifiers());\n\t}"
  },
  "org.springframework.core.type.StandardMethodMetadata#isFinal()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "boolean",
    "signature": "public boolean isFinal()",
    "source_code": "\tpublic boolean isFinal() {\n\t\treturn Modifier.isFinal(this.introspectedMethod.getModifiers());\n\t}"
  },
  "org.springframework.core.type.StandardMethodMetadata#isOverridable()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "boolean",
    "signature": "public boolean isOverridable()",
    "source_code": "\tpublic boolean isOverridable() {\n\t\treturn !isStatic() && !isFinal() && !isPrivate();\n\t}"
  },
  "org.springframework.core.type.StandardMethodMetadata#isStatic()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "boolean",
    "signature": "public boolean isStatic()",
    "source_code": "\tpublic boolean isStatic() {\n\t\treturn Modifier.isStatic(this.introspectedMethod.getModifiers());\n\t}"
  },
  "org.springframework.core.type.StandardMethodMetadata#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn this.introspectedMethod.toString();\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof SimpleAnnotationMetadata that && this.className.equals(that.className)));\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#getAnnotatedMethods(annotationName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationName"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "Set<MethodMetadata>",
    "signature": "public Set<MethodMetadata> getAnnotatedMethods(String annotationName)",
    "source_code": "\tpublic Set<MethodMetadata> getAnnotatedMethods(String annotationName) {\n\t\tSet<MethodMetadata> result = new LinkedHashSet<>(4);\n\t\tfor (MethodMetadata annotatedMethod : this.declaredMethods) {\n\t\t\tif (annotatedMethod.isAnnotated(annotationName)) {\n\t\t\t\tresult.add(annotatedMethod);\n\t\t\t}\n\t\t}\n\t\treturn Collections.unmodifiableSet(result);\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#getAnnotationTypes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "Set<String>",
    "signature": "public Set<String> getAnnotationTypes()",
    "source_code": "\tpublic Set<String> getAnnotationTypes() {\n\t\tSet<String> annotationTypes = this.annotationTypes;\n\t\tif (annotationTypes == null) {\n\t\t\tannotationTypes = Collections.unmodifiableSet(\n\t\t\t\t\tAnnotationMetadata.super.getAnnotationTypes());\n\t\t\tthis.annotationTypes = annotationTypes;\n\t\t}\n\t\treturn annotationTypes;\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#getAnnotations()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "MergedAnnotations",
    "signature": "public MergedAnnotations getAnnotations()",
    "source_code": "\tpublic MergedAnnotations getAnnotations() {\n\t\treturn this.annotations;\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#getClassName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "String",
    "signature": "public String getClassName()",
    "source_code": "\tpublic String getClassName() {\n\t\treturn this.className;\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#getDeclaredMethods()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "Set<MethodMetadata>",
    "signature": "public Set<MethodMetadata> getDeclaredMethods()",
    "source_code": "\tpublic Set<MethodMetadata> getDeclaredMethods() {\n\t\treturn Collections.unmodifiableSet(this.declaredMethods);\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#getDeclaringClassName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "String",
    "signature": "public String getDeclaringClassName()",
    "source_code": "\tpublic String getDeclaringClassName() {\n\t\treturn this.declaringClassName;\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#getEnclosingClassName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "String",
    "signature": "public String getEnclosingClassName()",
    "source_code": "\tpublic String getEnclosingClassName() {\n\t\treturn this.enclosingClassName;\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#getInterfaceNames()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "String[]",
    "signature": "public String[] getInterfaceNames()",
    "source_code": "\tpublic String[] getInterfaceNames() {\n\t\treturn StringUtils.toStringArray(this.interfaceNames);\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#getMemberClassNames()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "String[]",
    "signature": "public String[] getMemberClassNames()",
    "source_code": "\tpublic String[] getMemberClassNames() {\n\t\treturn StringUtils.toStringArray(this.memberClassNames);\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#getMethodName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "String",
    "signature": "public String getMethodName()",
    "source_code": "\tpublic String getMethodName() {\n\t\treturn this.methodName;\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#getReturnTypeName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "String",
    "signature": "public String getReturnTypeName()",
    "source_code": "\tpublic String getReturnTypeName() {\n\t\treturn this.returnTypeName;\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#getSuperClassName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "String",
    "signature": "public String getSuperClassName()",
    "source_code": "\tpublic String getSuperClassName() {\n\t\treturn this.superClassName;\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.className.hashCode();\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#isAbstract()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "boolean",
    "signature": "public boolean isAbstract()",
    "source_code": "\tpublic boolean isAbstract() {\n\t\treturn (this.access & Opcodes.ACC_ABSTRACT) != 0;\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#isAnnotation()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "boolean",
    "signature": "public boolean isAnnotation()",
    "source_code": "\tpublic boolean isAnnotation() {\n\t\treturn (this.access & Opcodes.ACC_ANNOTATION) != 0;\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#isFinal()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "boolean",
    "signature": "public boolean isFinal()",
    "source_code": "\tpublic boolean isFinal() {\n\t\treturn (this.access & Opcodes.ACC_FINAL) != 0;\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#isIndependent()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "boolean",
    "signature": "public boolean isIndependent()",
    "source_code": "\tpublic boolean isIndependent() {\n\t\treturn (this.enclosingClassName == null || this.independentInnerClass);\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#isInterface()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "boolean",
    "signature": "public boolean isInterface()",
    "source_code": "\tpublic boolean isInterface() {\n\t\treturn (this.access & Opcodes.ACC_INTERFACE) != 0;\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#isOverridable()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "boolean",
    "signature": "public boolean isOverridable()",
    "source_code": "\tpublic boolean isOverridable() {\n\t\treturn !isStatic() && !isFinal() && !isPrivate();\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#isStatic()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "boolean",
    "signature": "public boolean isStatic()",
    "source_code": "\tpublic boolean isStatic() {\n\t\treturn (this.access & Opcodes.ACC_STATIC) != 0;\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn this.className;\n\t}"
  },
  "org.springframework.format.datetime.standard.<unknown>#convert(source)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source"
    ],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "Long",
    "signature": "public Long convert(Instant source)",
    "source_code": "\t\tpublic Long convert(Instant source) {\n\t\t\treturn source.toEpochMilli();\n\t\t}"
  },
  "org.springframework.format.datetime.standard.<unknown>#registerConverters(registry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Install the converters into the converter registry.\n\t * @param registry the converter registry\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "return": "void",
    "signature": "public void registerConverters(ConverterRegistry registry)",
    "source_code": "\tpublic static void registerConverters(ConverterRegistry registry) {\n\t\tDateFormatterRegistrar.addDateConverters(registry);\n\n\t\tregistry.addConverter(new LocalDateTimeToLocalDateConverter());\n\t\tregistry.addConverter(new LocalDateTimeToLocalTimeConverter());\n\t\tregistry.addConverter(new ZonedDateTimeToLocalDateConverter());\n\t\tregistry.addConverter(new ZonedDateTimeToLocalTimeConverter());\n\t\tregistry.addConverter(new ZonedDateTimeToLocalDateTimeConverter());\n\t\tregistry.addConverter(new ZonedDateTimeToOffsetDateTimeConverter());\n\t\tregistry.addConverter(new ZonedDateTimeToInstantConverter());\n\t\tregistry.addConverter(new OffsetDateTimeToLocalDateConverter());\n\t\tregistry.addConverter(new OffsetDateTimeToLocalTimeConverter());\n\t\tregistry.addConverter(new OffsetDateTimeToLocalDateTimeConverter());\n\t\tregistry.addConverter(new OffsetDateTimeToZonedDateTimeConverter());\n\t\tregistry.addConverter(new OffsetDateTimeToInstantConverter());\n\t\tregistry.addConverter(new CalendarToZonedDateTimeConverter());\n\t\tregistry.addConverter(new CalendarToOffsetDateTimeConverter());\n\t\tregistry.addConverter(new CalendarToLocalDateConverter());\n\t\tregistry.addConverter(new CalendarToLocalTimeConverter());\n\t\tregistry.addConverter(new CalendarToLocalDateTimeConverter());\n\t\tregistry.addConverter(new CalendarToInstantConverter());\n\t\tregistry.addConverter(new LongToInstantConverter());\n\t\tregistry.addConverter(new InstantToLongConverter());\n\t}"
  },
  "org.springframework.format.datetime.standard.DateTimeContext": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A context that holds user-specific <code>java.time</code> (JSR-310) settings\n * such as the user's Chronology (calendar system) and time zone.\n * <p>A {@code null} property value indicates the user has not specified a setting.\n *\n * @author Juergen Hoeller\n * @since 4.0\n * @see DateTimeContextHolder\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "signature": "public class DateTimeContext",
    "source_code": "public class DateTimeContext {\n\n\t@Nullable\n\tprivate Chronology chronology;\n\n\t@Nullable\n\tprivate ZoneId timeZone;\n\n\n\t/**\n\t * Set the user's chronology (calendar system).\n\t */\n\tpublic void setChronology(@Nullable Chronology chronology) {\n\t\tthis.chronology = chronology;\n\t}\n\n\t/**\n\t * Return the user's chronology (calendar system), if any.\n\t */\n\t@Nullable\n\tpublic Chronology getChronology() {\n\t\treturn this.chronology;\n\t}\n\n\t/**\n\t * Set the user's time zone.\n\t * <p>Alternatively, set a {@link TimeZoneAwareLocaleContext} on\n\t * {@link LocaleContextHolder}. This context class will fall back to\n\t * checking the locale context if no setting has been provided here.\n\t * @see org.springframework.context.i18n.LocaleContextHolder#getTimeZone()\n\t * @see org.springframework.context.i18n.LocaleContextHolder#setLocaleContext\n\t */\n\tpublic void setTimeZone(@Nullable ZoneId timeZone) {\n\t\tthis.timeZone = timeZone;\n\t}\n\n\t/**\n\t * Return the user's time zone, if any.\n\t */\n\t@Nullable\n\tpublic ZoneId getTimeZone() {\n\t\treturn this.timeZone;\n\t}\n\n\n\t/**\n\t * Get the DateTimeFormatter with this context's settings applied to the\n\t * base {@code formatter}.\n\t * @param formatter the base formatter that establishes default\n\t * formatting rules, generally context-independent\n\t * @return the contextual DateTimeFormatter\n\t */\n\tpublic DateTimeFormatter getFormatter(DateTimeFormatter formatter) {\n\t\tif (this.chronology != null) {\n\t\t\tformatter = formatter.withChronology(this.chronology);\n\t\t}\n\t\tif (this.timeZone != null) {\n\t\t\tformatter = formatter.withZone(this.timeZone);\n\t\t}\n\t\telse {\n\t\t\tLocaleContext localeContext = LocaleContextHolder.getLocaleContext();\n\t\t\tif (localeContext instanceof TimeZoneAwareLocaleContext timeZoneAware) {\n\t\t\t\tTimeZone timeZone = timeZoneAware.getTimeZone();\n\t\t\t\tif (timeZone != null) {\n\t\t\t\t\tformatter = formatter.withZone(timeZone.toZoneId());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn formatter;\n\t}\n\n}"
  },
  "org.springframework.format.datetime.standard.DateTimeContext#getChronology()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the user's chronology (calendar system), if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "Chronology",
    "signature": "public Chronology getChronology()",
    "source_code": "\tpublic Chronology getChronology() {\n\t\treturn this.chronology;\n\t}"
  },
  "org.springframework.format.datetime.standard.DateTimeContext#getFormatter(formatter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the DateTimeFormatter with this context's settings applied to the\n\t * base {@code formatter}.\n\t * @param formatter the base formatter that establishes default\n\t * formatting rules, generally context-independent\n\t * @return the contextual DateTimeFormatter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "formatter"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "DateTimeFormatter",
    "signature": "public DateTimeFormatter getFormatter(DateTimeFormatter formatter)",
    "source_code": "\tpublic DateTimeFormatter getFormatter(DateTimeFormatter formatter) {\n\t\tif (this.chronology != null) {\n\t\t\tformatter = formatter.withChronology(this.chronology);\n\t\t}\n\t\tif (this.timeZone != null) {\n\t\t\tformatter = formatter.withZone(this.timeZone);\n\t\t}\n\t\telse {\n\t\t\tLocaleContext localeContext = LocaleContextHolder.getLocaleContext();\n\t\t\tif (localeContext instanceof TimeZoneAwareLocaleContext timeZoneAware) {\n\t\t\t\tTimeZone timeZone = timeZoneAware.getTimeZone();\n\t\t\t\tif (timeZone != null) {\n\t\t\t\t\tformatter = formatter.withZone(timeZone.toZoneId());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn formatter;\n\t}"
  },
  "org.springframework.format.datetime.standard.DateTimeContext#getTimeZone()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the user's time zone, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "ZoneId",
    "signature": "public ZoneId getTimeZone()",
    "source_code": "\tpublic ZoneId getTimeZone() {\n\t\treturn this.timeZone;\n\t}"
  },
  "org.springframework.format.datetime.standard.DateTimeContext#setChronology(chronology)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the user's chronology (calendar system).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "chronology"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "return": "void",
    "signature": "public void setChronology(@Nullable Chronology chronology)",
    "source_code": "\tpublic void setChronology(@Nullable Chronology chronology) {\n\t\tthis.chronology = chronology;\n\t}"
  },
  "org.springframework.format.datetime.standard.DateTimeContext#setTimeZone(timeZone)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the user's time zone.\n\t * <p>Alternatively, set a {@link TimeZoneAwareLocaleContext} on\n\t * {@link LocaleContextHolder}. This context class will fall back to\n\t * checking the locale context if no setting has been provided here.\n\t * @see org.springframework.context.i18n.LocaleContextHolder#getTimeZone()\n\t * @see org.springframework.context.i18n.LocaleContextHolder#setLocaleContext\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeZone"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "void",
    "signature": "public void setTimeZone(@Nullable ZoneId timeZone)",
    "source_code": "\tpublic void setTimeZone(@Nullable ZoneId timeZone) {\n\t\tthis.timeZone = timeZone;\n\t}"
  },
  "org.springframework.format.number.PercentStyleFormatter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A formatter for number values in percent style.\n *\n * <p>Delegates to {@link java.text.NumberFormat#getPercentInstance(Locale)}.\n * Configures BigDecimal parsing so there is no loss in precision.\n * The {@link #parse(String, Locale)} routine always returns a BigDecimal.\n *\n * @author Keith Donald\n * @author Juergen Hoeller\n * @since 4.2\n * @see #setLenient\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 35
    },
    "signature": "public class PercentStyleFormatter",
    "source_code": "public class PercentStyleFormatter extends AbstractNumberFormatter {\n\n\t@Override\n\tprotected NumberFormat getNumberFormat(Locale locale) {\n\t\tNumberFormat format = NumberFormat.getPercentInstance(locale);\n\t\tif (format instanceof DecimalFormat decimalFormat) {\n\t\t\tdecimalFormat.setParseBigDecimal(true);\n\t\t}\n\t\treturn format;\n\t}\n\n}"
  },
  "org.springframework.format.number.PercentStyleFormatter#getNumberFormat(locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "return": "NumberFormat",
    "signature": "protected NumberFormat getNumberFormat(Locale locale)",
    "source_code": "\tprotected NumberFormat getNumberFormat(Locale locale) {\n\t\tNumberFormat format = NumberFormat.getPercentInstance(locale);\n\t\tif (format instanceof DecimalFormat decimalFormat) {\n\t\t\tdecimalFormat.setParseBigDecimal(true);\n\t\t}\n\t\treturn format;\n\t}"
  },
  "org.springframework.format.support.FormattingConversionServiceFactoryBean": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A factory providing convenient access to a {@code FormattingConversionService}\n * configured with converters and formatters for common types such as numbers and\n * datetimes.\n *\n * <p>Additional converters and formatters can be registered declaratively through\n * {@link #setConverters(Set)} and {@link #setFormatters(Set)}. Another option\n * is to register converters and formatters in code by implementing the\n * {@link FormatterRegistrar} interface. You can then configure provide the set\n * of registrars to use through {@link #setFormatterRegistrars(Set)}.\n *\n * <p>A good example for registering converters and formatters in code is\n * {@code JodaTimeFormatterRegistrar}, which registers a number of\n * date-related formatters and converters. For a more detailed list of cases\n * see {@link #setFormatterRegistrars(Set)}\n *\n * <p>Like all {@code FactoryBean} implementations, this class is suitable for\n * use when configuring a Spring application context using Spring {@code <beans>}\n * XML. When configuring the container with\n * {@link org.springframework.context.annotation.Configuration @Configuration}\n * classes, simply instantiate, configure and return the appropriate\n * {@code FormattingConversionService} object from a\n * {@link org.springframework.context.annotation.Bean @Bean} method.\n *\n * @author Keith Donald\n * @author Juergen Hoeller\n * @author Rossen Stoyanchev\n * @author Chris Beams\n * @since 3.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "signature": "public class FormattingConversionServiceFactoryBean",
    "source_code": "public class FormattingConversionServiceFactoryBean"
  },
  "org.springframework.format.support.FormattingConversionServiceFactoryBean#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tthis.conversionService = new DefaultFormattingConversionService(this.embeddedValueResolver, this.registerDefaultFormatters);\n\t\tConversionServiceFactory.registerConverters(this.converters, this.conversionService);\n\t\tregisterFormatters(this.conversionService);\n\t}"
  },
  "org.springframework.format.support.FormattingConversionServiceFactoryBean#getObject()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "FormattingConversionService",
    "signature": "public FormattingConversionService getObject()",
    "source_code": "\tpublic FormattingConversionService getObject() {\n\t\treturn this.conversionService;\n\t}"
  },
  "org.springframework.format.support.FormattingConversionServiceFactoryBean#isSingleton()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "boolean",
    "signature": "public boolean isSingleton()",
    "source_code": "\tpublic boolean isSingleton() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.format.support.FormattingConversionServiceFactoryBean#setConverters(converters)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the set of custom converter objects that should be added.\n\t * @param converters instances of any of the following:\n\t * {@link org.springframework.core.convert.converter.Converter},\n\t * {@link org.springframework.core.convert.converter.ConverterFactory},\n\t * {@link org.springframework.core.convert.converter.GenericConverter}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "converters"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "void",
    "signature": "public void setConverters(Set<?> converters)",
    "source_code": "\tpublic void setConverters(Set<?> converters) {\n\t\tthis.converters = converters;\n\t}"
  },
  "org.springframework.format.support.FormattingConversionServiceFactoryBean#setEmbeddedValueResolver(embeddedValueResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "embeddedValueResolver"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "void",
    "signature": "public void setEmbeddedValueResolver(StringValueResolver embeddedValueResolver)",
    "source_code": "\tpublic void setEmbeddedValueResolver(StringValueResolver embeddedValueResolver) {\n\t\tthis.embeddedValueResolver = embeddedValueResolver;\n\t}"
  },
  "org.springframework.format.support.FormattingConversionServiceFactoryBean#setFormatterRegistrars(formatterRegistrars)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * <p>Configure the set of FormatterRegistrars to invoke to register\n\t * Converters and Formatters in addition to those added declaratively\n\t * via {@link #setConverters(Set)} and {@link #setFormatters(Set)}.\n\t * <p>FormatterRegistrars are useful when registering multiple related\n\t * converters and formatters for a formatting category, such as Date\n\t * formatting. All types related needed to support the formatting\n\t * category can be registered from one place.\n\t * <p>FormatterRegistrars can also be used to register Formatters\n\t * indexed under a specific field type different from its own &lt;T&gt;,\n\t * or when registering a Formatter from a Printer/Parser pair.\n\t * @see FormatterRegistry#addFormatterForFieldType(Class, Formatter)\n\t * @see FormatterRegistry#addFormatterForFieldType(Class, Printer, Parser)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "formatterRegistrars"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "void",
    "signature": "public void setFormatterRegistrars(Set<FormatterRegistrar> formatterRegistrars)",
    "source_code": "\tpublic void setFormatterRegistrars(Set<FormatterRegistrar> formatterRegistrars) {\n\t\tthis.formatterRegistrars = formatterRegistrars;\n\t}"
  },
  "org.springframework.format.support.FormattingConversionServiceFactoryBean#setFormatters(formatters)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the set of custom formatter objects that should be added.\n\t * @param formatters instances of {@link Formatter} or {@link AnnotationFormatterFactory}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "formatters"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "public void setFormatters(Set<?> formatters)",
    "source_code": "\tpublic void setFormatters(Set<?> formatters) {\n\t\tthis.formatters = formatters;\n\t}"
  },
  "org.springframework.format.support.FormattingConversionServiceFactoryBean#setRegisterDefaultFormatters(registerDefaultFormatters)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Indicate whether default formatters should be registered or not.\n\t * <p>By default, built-in formatters are registered. This flag can be used\n\t * to turn that off and rely on explicitly registered formatters only.\n\t * @see #setFormatters(Set)\n\t * @see #setFormatterRegistrars(Set)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registerDefaultFormatters"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "void",
    "signature": "public void setRegisterDefaultFormatters(boolean registerDefaultFormatters)",
    "source_code": "\tpublic void setRegisterDefaultFormatters(boolean registerDefaultFormatters) {\n\t\tthis.registerDefaultFormatters = registerDefaultFormatters;\n\t}"
  },
  "org.springframework.http.HttpMethod#equals(o)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "boolean",
    "signature": "public boolean equals(Object o)",
    "source_code": "\tpublic boolean equals(Object o) {\n\t\tif (this == o) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (o instanceof HttpMethod otherMethod) {\n\t\t\treturn this.name.equals(otherMethod.name);\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.http.HttpMethod#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj) || (obj instanceof HttpMethod that && this.name.equals(that.name));\n\t}"
  },
  "org.springframework.http.client.SimpleClientHttpRequestFactory": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link ClientHttpRequestFactory} implementation that uses standard JDK facilities.\n *\n * @author Arjen Poutsma\n * @author Juergen Hoeller\n * @since 3.0\n * @see java.net.HttpURLConnection\n * @see HttpComponentsClientHttpRequestFactory\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "signature": "public class SimpleClientHttpRequestFactory",
    "source_code": "public class SimpleClientHttpRequestFactory implements ClientHttpRequestFactory {\n\n\tprivate static final int DEFAULT_CHUNK_SIZE = 4096;\n\n\n\t@Nullable\n\tprivate Proxy proxy;\n\n\tprivate boolean bufferRequestBody = true;\n\n\tprivate int chunkSize = DEFAULT_CHUNK_SIZE;\n\n\tprivate int connectTimeout = -1;\n\n\tprivate int readTimeout = -1;\n\n\tprivate boolean outputStreaming = true;\n\n\n\t/**\n\t * Set the {@link Proxy} to use for this request factory.\n\t */\n\tpublic void setProxy(Proxy proxy) {\n\t\tthis.proxy = proxy;\n\t}\n\n\t/**\n\t * Indicate whether this request factory should buffer the\n\t * {@linkplain ClientHttpRequest#getBody() request body} internally.\n\t * <p>Default is {@code true}. When sending large amounts of data via POST or PUT,\n\t * it is recommended to change this property to {@code false}, so as not to run\n\t * out of memory. This will result in a {@link ClientHttpRequest} that either\n\t * streams directly to the underlying {@link HttpURLConnection} (if the\n\t * {@link org.springframework.http.HttpHeaders#getContentLength() Content-Length}\n\t * is known in advance), or that will use \"Chunked transfer encoding\"\n\t * (if the {@code Content-Length} is not known in advance).\n\t * @see #setChunkSize(int)\n\t * @see HttpURLConnection#setFixedLengthStreamingMode(int)\n\t */\n\tpublic void setBufferRequestBody(boolean bufferRequestBody) {\n\t\tthis.bufferRequestBody = bufferRequestBody;\n\t}\n\n\t/**\n\t * Set the number of bytes to write in each chunk when not buffering request\n\t * bodies locally.\n\t * <p>Note that this parameter is only used when\n\t * {@link #setBufferRequestBody(boolean) bufferRequestBody} is set to {@code false},\n\t * and the {@link org.springframework.http.HttpHeaders#getContentLength() Content-Length}\n\t * is not known in advance.\n\t * @see #setBufferRequestBody(boolean)\n\t */\n\tpublic void setChunkSize(int chunkSize) {\n\t\tthis.chunkSize = chunkSize;\n\t}\n\n\t/**\n\t * Set the underlying URLConnection's connect timeout (in milliseconds).\n\t * A timeout value of 0 specifies an infinite timeout.\n\t * <p>Default is the system's default timeout.\n\t * @see URLConnection#setConnectTimeout(int)\n\t */\n\tpublic void setConnectTimeout(int connectTimeout) {\n\t\tthis.connectTimeout = connectTimeout;\n\t}\n\n\t/**\n\t * Set the underlying URLConnection's read timeout (in milliseconds).\n\t * A timeout value of 0 specifies an infinite timeout.\n\t * <p>Default is the system's default timeout.\n\t * @see URLConnection#setReadTimeout(int)\n\t */\n\tpublic void setReadTimeout(int readTimeout) {\n\t\tthis.readTimeout = readTimeout;\n\t}\n\n\t/**\n\t * Set if the underlying URLConnection can be set to 'output streaming' mode.\n\t * Default is {@code true}.\n\t * <p>When output streaming is enabled, authentication and redirection cannot be handled automatically.\n\t * If output streaming is disabled, the {@link HttpURLConnection#setFixedLengthStreamingMode} and\n\t * {@link HttpURLConnection#setChunkedStreamingMode} methods of the underlying connection will never\n\t * be called.\n\t * @param outputStreaming if output streaming is enabled\n\t */\n\tpublic void setOutputStreaming(boolean outputStreaming) {\n\t\tthis.outputStreaming = outputStreaming;\n\t}\n\n\n\t@Override\n\tpublic ClientHttpRequest createRequest(URI uri, HttpMethod httpMethod) throws IOException {\n\t\tHttpURLConnection connection = openConnection(uri.toURL(), this.proxy);\n\t\tprepareConnection(connection, httpMethod.name());\n\n\t\tif (this.bufferRequestBody) {\n\t\t\treturn new SimpleBufferingClientHttpRequest(connection, this.outputStreaming);\n\t\t}\n\t\telse {\n\t\t\treturn new SimpleStreamingClientHttpRequest(connection, this.chunkSize, this.outputStreaming);\n\t\t}\n\t}\n\n\t/**\n\t * Opens and returns a connection to the given URL.\n\t * <p>The default implementation uses the given {@linkplain #setProxy(java.net.Proxy) proxy} -\n\t * if any - to open a connection.\n\t * @param url the URL to open a connection to\n\t * @param proxy the proxy to use, may be {@code null}\n\t * @return the opened connection\n\t * @throws IOException in case of I/O errors\n\t */\n\tprotected HttpURLConnection openConnection(URL url, @Nullable Proxy proxy) throws IOException {\n\t\tURLConnection urlConnection = (proxy != null ? url.openConnection(proxy) : url.openConnection());\n\t\tif (!(urlConnection instanceof HttpURLConnection httpUrlConnection)) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"HttpURLConnection required for [\" + url + \"] but got: \" + urlConnection);\n\t\t}\n\t\treturn httpUrlConnection;\n\t}\n\n\t/**\n\t * Template method for preparing the given {@link HttpURLConnection}.\n\t * <p>The default implementation prepares the connection for input and output, and sets the HTTP method.\n\t * @param connection the connection to prepare\n\t * @param httpMethod the HTTP request method ({@code GET}, {@code POST}, etc.)\n\t * @throws IOException in case of I/O errors\n\t */\n\tprotected void prepareConnection(HttpURLConnection connection, String httpMethod) throws IOException {\n\t\tif (this.connectTimeout >= 0) {\n\t\t\tconnection.setConnectTimeout(this.connectTimeout);\n\t\t}\n\t\tif (this.readTimeout >= 0) {\n\t\t\tconnection.setReadTimeout(this.readTimeout);\n\t\t}\n\n\t\tboolean mayWrite =\n\t\t\t\t(\"POST\".equals(httpMethod) || \"PUT\".equals(httpMethod) ||\n\t\t\t\t\t\t\"PATCH\".equals(httpMethod) || \"DELETE\".equals(httpMethod));\n\n\t\tconnection.setDoInput(true);\n\t\tconnection.setInstanceFollowRedirects(\"GET\".equals(httpMethod));\n\t\tconnection.setDoOutput(mayWrite);\n\t\tconnection.setRequestMethod(httpMethod);\n\t}\n\n}"
  },
  "org.springframework.http.client.SimpleClientHttpRequestFactory#createRequest(uri,httpMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uri",
      "httpMethod"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "ClientHttpRequest",
    "signature": "public ClientHttpRequest createRequest(URI uri, HttpMethod httpMethod)",
    "source_code": "\tpublic ClientHttpRequest createRequest(URI uri, HttpMethod httpMethod) throws IOException {\n\t\tHttpURLConnection connection = openConnection(uri.toURL(), this.proxy);\n\t\tprepareConnection(connection, httpMethod.name());\n\n\t\tif (this.bufferRequestBody) {\n\t\t\treturn new SimpleBufferingClientHttpRequest(connection, this.outputStreaming);\n\t\t}\n\t\telse {\n\t\t\treturn new SimpleStreamingClientHttpRequest(connection, this.chunkSize, this.outputStreaming);\n\t\t}\n\t}"
  },
  "org.springframework.http.client.SimpleClientHttpRequestFactory#openConnection(url,proxy)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Opens and returns a connection to the given URL.\n\t * <p>The default implementation uses the given {@linkplain #setProxy(java.net.Proxy) proxy} -\n\t * if any - to open a connection.\n\t * @param url the URL to open a connection to\n\t * @param proxy the proxy to use, may be {@code null}\n\t * @return the opened connection\n\t * @throws IOException in case of I/O errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "url",
      "proxy"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "HttpURLConnection",
    "signature": "protected HttpURLConnection openConnection(URL url, @Nullable Proxy proxy)",
    "source_code": "\tprotected HttpURLConnection openConnection(URL url, @Nullable Proxy proxy) throws IOException {\n\t\tURLConnection urlConnection = (proxy != null ? url.openConnection(proxy) : url.openConnection());\n\t\tif (!(urlConnection instanceof HttpURLConnection httpUrlConnection)) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"HttpURLConnection required for [\" + url + \"] but got: \" + urlConnection);\n\t\t}\n\t\treturn httpUrlConnection;\n\t}"
  },
  "org.springframework.http.client.SimpleClientHttpRequestFactory#prepareConnection(connection,httpMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Template method for preparing the given {@link HttpURLConnection}.\n\t * <p>The default implementation prepares the connection for input and output, and sets the HTTP method.\n\t * @param connection the connection to prepare\n\t * @param httpMethod the HTTP request method ({@code GET}, {@code POST}, etc.)\n\t * @throws IOException in case of I/O errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "connection",
      "httpMethod"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "void",
    "signature": "protected void prepareConnection(HttpURLConnection connection, String httpMethod)",
    "source_code": "\tprotected void prepareConnection(HttpURLConnection connection, String httpMethod) throws IOException {\n\t\tif (this.connectTimeout >= 0) {\n\t\t\tconnection.setConnectTimeout(this.connectTimeout);\n\t\t}\n\t\tif (this.readTimeout >= 0) {\n\t\t\tconnection.setReadTimeout(this.readTimeout);\n\t\t}\n\n\t\tboolean mayWrite =\n\t\t\t\t(\"POST\".equals(httpMethod) || \"PUT\".equals(httpMethod) ||\n\t\t\t\t\t\t\"PATCH\".equals(httpMethod) || \"DELETE\".equals(httpMethod));\n\n\t\tconnection.setDoInput(true);\n\t\tconnection.setInstanceFollowRedirects(\"GET\".equals(httpMethod));\n\t\tconnection.setDoOutput(mayWrite);\n\t\tconnection.setRequestMethod(httpMethod);\n\t}"
  },
  "org.springframework.http.client.SimpleClientHttpRequestFactory#setBufferRequestBody(bufferRequestBody)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Indicate whether this request factory should buffer the\n\t * {@linkplain ClientHttpRequest#getBody() request body} internally.\n\t * <p>Default is {@code true}. When sending large amounts of data via POST or PUT,\n\t * it is recommended to change this property to {@code false}, so as not to run\n\t * out of memory. This will result in a {@link ClientHttpRequest} that either\n\t * streams directly to the underlying {@link HttpURLConnection} (if the\n\t * {@link org.springframework.http.HttpHeaders#getContentLength() Content-Length}\n\t * is known in advance), or that will use \"Chunked transfer encoding\"\n\t * (if the {@code Content-Length} is not known in advance).\n\t * @see #setChunkSize(int)\n\t * @see HttpURLConnection#setFixedLengthStreamingMode(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bufferRequestBody"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "void",
    "signature": "public void setBufferRequestBody(boolean bufferRequestBody)",
    "source_code": "\tpublic void setBufferRequestBody(boolean bufferRequestBody) {\n\t\tthis.bufferRequestBody = bufferRequestBody;\n\t}"
  },
  "org.springframework.http.client.SimpleClientHttpRequestFactory#setChunkSize(chunkSize)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the number of bytes to write in each chunk when not buffering request\n\t * bodies locally.\n\t * <p>Note that this parameter is only used when\n\t * {@link #setBufferRequestBody(boolean) bufferRequestBody} is set to {@code false},\n\t * and the {@link org.springframework.http.HttpHeaders#getContentLength() Content-Length}\n\t * is not known in advance.\n\t * @see #setBufferRequestBody(boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "chunkSize"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "void",
    "signature": "public void setChunkSize(int chunkSize)",
    "source_code": "\tpublic void setChunkSize(int chunkSize) {\n\t\tthis.chunkSize = chunkSize;\n\t}"
  },
  "org.springframework.http.client.SimpleClientHttpRequestFactory#setConnectTimeout(connectTimeout)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the underlying URLConnection's connect timeout (in milliseconds).\n\t * A timeout value of 0 specifies an infinite timeout.\n\t * <p>Default is the system's default timeout.\n\t * @see URLConnection#setConnectTimeout(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connectTimeout"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "public void setConnectTimeout(int connectTimeout)",
    "source_code": "\tpublic void setConnectTimeout(int connectTimeout) {\n\t\tthis.connectTimeout = connectTimeout;\n\t}"
  },
  "org.springframework.http.client.SimpleClientHttpRequestFactory#setOutputStreaming(outputStreaming)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set if the underlying URLConnection can be set to 'output streaming' mode.\n\t * Default is {@code true}.\n\t * <p>When output streaming is enabled, authentication and redirection cannot be handled automatically.\n\t * If output streaming is disabled, the {@link HttpURLConnection#setFixedLengthStreamingMode} and\n\t * {@link HttpURLConnection#setChunkedStreamingMode} methods of the underlying connection will never\n\t * be called.\n\t * @param outputStreaming if output streaming is enabled\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outputStreaming"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "void",
    "signature": "public void setOutputStreaming(boolean outputStreaming)",
    "source_code": "\tpublic void setOutputStreaming(boolean outputStreaming) {\n\t\tthis.outputStreaming = outputStreaming;\n\t}"
  },
  "org.springframework.http.client.SimpleClientHttpRequestFactory#setProxy(proxy)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link Proxy} to use for this request factory.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "void",
    "signature": "public void setProxy(Proxy proxy)",
    "source_code": "\tpublic void setProxy(Proxy proxy) {\n\t\tthis.proxy = proxy;\n\t}"
  },
  "org.springframework.http.client.SimpleClientHttpRequestFactory#setReadTimeout(readTimeout)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the underlying URLConnection's read timeout (in milliseconds).\n\t * A timeout value of 0 specifies an infinite timeout.\n\t * <p>Default is the system's default timeout.\n\t * @see URLConnection#setReadTimeout(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "readTimeout"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "void",
    "signature": "public void setReadTimeout(int readTimeout)",
    "source_code": "\tpublic void setReadTimeout(int readTimeout) {\n\t\tthis.readTimeout = readTimeout;\n\t}"
  },
  "org.springframework.http.codec.multipart.MultipartHttpMessageWriter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link HttpMessageWriter} for writing a {@code MultiValueMap<String, ?>}\n * as multipart form data, i.e. {@code \"multipart/form-data\"}, to the body\n * of a request.\n *\n * <p>The serialization of individual parts is delegated to other writers.\n * By default only {@link String} and {@link Resource} parts are supported but\n * you can configure others through a constructor argument.\n *\n * <p>This writer can be configured with a {@link FormHttpMessageWriter} to\n * delegate to. It is the preferred way of supporting both form data and\n * multipart data (as opposed to registering each writer separately) so that\n * when the {@link MediaType} is not specified and generics are not present on\n * the target element type, we can inspect the values in the actual map and\n * decide whether to write plain form data (String values only) or otherwise.\n *\n * @author Sebastien Deleuze\n * @author Rossen Stoyanchev\n * @since 5.0\n * @see FormHttpMessageWriter\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "signature": "public class MultipartHttpMessageWriter",
    "source_code": "public class MultipartHttpMessageWriter extends MultipartWriterSupport"
  },
  "org.springframework.http.codec.multipart.MultipartHttpMessageWriter#beforeCommit(action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "action"
    ],
    "position": {
      "column": 1,
      "line": 336
    },
    "return": "void",
    "signature": "public void beforeCommit(Supplier<? extends Mono<Void>> action)",
    "source_code": "\t\tpublic void beforeCommit(Supplier<? extends Mono<Void>> action) {\n\t\t\tthis.committed.set(true);\n\t\t}"
  },
  "org.springframework.http.codec.multipart.MultipartHttpMessageWriter#bufferFactory()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 331
    },
    "return": "DataBufferFactory",
    "signature": "public DataBufferFactory bufferFactory()",
    "source_code": "\t\tpublic DataBufferFactory bufferFactory() {\n\t\t\treturn this.bufferFactory;\n\t\t}"
  },
  "org.springframework.http.codec.multipart.MultipartHttpMessageWriter#canWrite(elementType,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "boolean",
    "signature": "public boolean canWrite(ResolvableType elementType, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canWrite(ResolvableType elementType, @Nullable MediaType mediaType) {\n\t\tif (MultiValueMap.class.isAssignableFrom(elementType.toClass())) {\n\t\t\tif (mediaType == null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (MediaType supportedMediaType : getWritableMediaTypes()) {\n\t\t\t\tif (supportedMediaType.isCompatibleWith(mediaType)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.http.codec.multipart.MultipartHttpMessageWriter#getBody()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 361
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> getBody()",
    "source_code": "\t\tpublic Flux<DataBuffer> getBody() {\n\t\t\treturn (this.body != null ? this.body :\n\t\t\t\t\tFlux.error(new IllegalStateException(\"Body has not been written yet\")));\n\t\t}"
  },
  "org.springframework.http.codec.multipart.MultipartHttpMessageWriter#getFormWriter()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured form writer.\n\t * @since 5.1.13\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "String>>",
    "signature": "public String>> getFormWriter()",
    "source_code": "\tpublic HttpMessageWriter<MultiValueMap<String, String>> getFormWriter() {\n\t\treturn this.formWriter;\n\t}"
  },
  "org.springframework.http.codec.multipart.MultipartHttpMessageWriter#getHeaders()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 326
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders getHeaders()",
    "source_code": "\t\tpublic HttpHeaders getHeaders() {\n\t\t\treturn (this.body != null ? HttpHeaders.readOnlyHttpHeaders(this.headers) : this.headers);\n\t\t}"
  },
  "org.springframework.http.codec.multipart.MultipartHttpMessageWriter#isCommitted()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "boolean",
    "signature": "public boolean isCommitted()",
    "source_code": "\t\tpublic boolean isCommitted() {\n\t\t\treturn this.committed.get();\n\t\t}"
  },
  "org.springframework.http.codec.multipart.MultipartHttpMessageWriter#setComplete()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 367
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> setComplete()",
    "source_code": "\t\tpublic Mono<Void> setComplete() {\n\t\t\treturn Mono.error(new UnsupportedOperationException());\n\t\t}"
  },
  "org.springframework.http.codec.multipart.MultipartHttpMessageWriter#write(MultiValueMap<String,inputStream,elementType,mediaType,outputMessage,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "inputStream",
      "elementType",
      "mediaType",
      "outputMessage",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> write(Publisher<? extends MultiValueMap<String, ?>> inputStream,\n\t\t\tResolvableType elementType, @Nullable MediaType mediaType, ReactiveHttpOutputMessage outputMessage,\n\t\t\tMap<String, Object> hints)",
    "source_code": "\tpublic Mono<Void> write(Publisher<? extends MultiValueMap<String, ?>> inputStream,"
  },
  "org.springframework.http.codec.multipart.MultipartHttpMessageWriter#writeAndFlushWith(body)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body"
    ],
    "position": {
      "column": 1,
      "line": 357
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> writeAndFlushWith(Publisher<? extends Publisher<? extends DataBuffer>> body)",
    "source_code": "\t\tpublic Mono<Void> writeAndFlushWith(Publisher<? extends Publisher<? extends DataBuffer>> body) {\n\t\t\treturn Mono.error(new UnsupportedOperationException());\n\t\t}"
  },
  "org.springframework.http.codec.multipart.MultipartHttpMessageWriter#writeWith(body)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body"
    ],
    "position": {
      "column": 1,
      "line": 346
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> writeWith(Publisher<? extends DataBuffer> body)",
    "source_code": "\t\tpublic Mono<Void> writeWith(Publisher<? extends DataBuffer> body) {\n\t\t\tif (this.body != null) {\n\t\t\t\treturn Mono.error(new IllegalStateException(\"Multiple calls to writeWith() not supported\"));\n\t\t\t}\n\t\t\tthis.body = generatePartHeaders(this.headers, this.bufferFactory).concatWith(body);\n\n\t\t\t// We don't actually want to write (just save the body Flux)\n\t\t\treturn Mono.empty();\n\t\t}"
  },
  "org.springframework.http.server.<unknown>#elements()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "List<Element>",
    "signature": "public List<Element> elements()",
    "source_code": "\tpublic List<Element> elements() {\n\t\treturn this.elements;\n\t}"
  },
  "org.springframework.http.server.<unknown>#encodedSequence()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "String",
    "signature": "public String encodedSequence()",
    "source_code": "\t\tpublic String encodedSequence() {\n\t\t\treturn this.encodedSequence;\n\t\t}"
  },
  "org.springframework.http.server.<unknown>#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object obj) {\n\t\t\treturn (this == obj) || (obj instanceof PathSegment that && value().equals(that.value()));\n\t\t}"
  },
  "org.springframework.http.server.<unknown>#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 289
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\t\tpublic int hashCode() {\n\t\t\treturn this.value.hashCode();\n\t\t}"
  },
  "org.springframework.http.server.<unknown>#parameters()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 279
    },
    "return": "String>",
    "signature": "public String> parameters()",
    "source_code": "\t\tpublic MultiValueMap<String, String> parameters() {\n\t\t\treturn this.parameters;\n\t\t}"
  },
  "org.springframework.http.server.<unknown>#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 294
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn \"[value='\" + this.value + \"']\";\n\t\t}"
  },
  "org.springframework.http.server.<unknown>#value()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "String",
    "signature": "public String value()",
    "source_code": "\t\tpublic String value() {\n\t\t\treturn this.value;\n\t\t}"
  },
  "org.springframework.http.server.<unknown>#valueToMatch()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 269
    },
    "return": "String",
    "signature": "public String valueToMatch()",
    "source_code": "\t\tpublic String valueToMatch() {\n\t\t\treturn this.valueToMatch;\n\t\t}"
  },
  "org.springframework.http.server.<unknown>#valueToMatchAsChars()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "char[]",
    "signature": "public char[] valueToMatchAsChars()",
    "source_code": "\t\tpublic char[] valueToMatchAsChars() {\n\t\t\treturn this.valueToMatch.toCharArray();\n\t\t}"
  },
  "org.springframework.jdbc.core.namedparam.MapSqlParameterSource": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link SqlParameterSource} implementation that holds a given Map of parameters.\n *\n * <p>This class is intended for passing in a simple Map of parameter values\n * to the methods of the {@link NamedParameterJdbcTemplate} class.\n *\n * <p>The {@code addValue} methods on this class will make adding several values\n * easier. The methods return a reference to the {@link MapSqlParameterSource}\n * itself, so you can chain several method calls together within a single statement.\n *\n * @author Thomas Risberg\n * @author Juergen Hoeller\n * @since 2.0\n * @see #addValue(String, Object)\n * @see #addValue(String, Object, int)\n * @see #registerSqlType\n * @see NamedParameterJdbcTemplate\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "signature": "public class MapSqlParameterSource",
    "source_code": "public class MapSqlParameterSource extends AbstractSqlParameterSource {\n\n\tprivate final Map<String, Object> values = new LinkedHashMap<>();\n\n\n\t/**\n\t * Create an empty MapSqlParameterSource,\n\t * with values to be added via {@code addValue}.\n\t * @see #addValue(String, Object)\n\t */\n\tpublic MapSqlParameterSource() {\n\t}\n\n\t/**\n\t * Create a new MapSqlParameterSource, with one value\n\t * comprised of the supplied arguments.\n\t * @param paramName the name of the parameter\n\t * @param value the value of the parameter\n\t * @see #addValue(String, Object)\n\t */\n\tpublic MapSqlParameterSource(String paramName, @Nullable Object value) {\n\t\taddValue(paramName, value);\n\t}\n\n\t/**\n\t * Create a new MapSqlParameterSource based on a Map.\n\t * @param values a Map holding existing parameter values (can be {@code null})\n\t */\n\tpublic MapSqlParameterSource(@Nullable Map<String, ?> values) {\n\t\taddValues(values);\n\t}\n\n\n\t/**\n\t * Add a parameter to this parameter source.\n\t * @param paramName the name of the parameter\n\t * @param value the value of the parameter\n\t * @return a reference to this parameter source,\n\t * so it's possible to chain several calls together\n\t */\n\tpublic MapSqlParameterSource addValue(String paramName, @Nullable Object value) {\n\t\tAssert.notNull(paramName, \"Parameter name must not be null\");\n\t\tthis.values.put(paramName, value);\n\t\tif (value instanceof SqlParameterValue sqlParameterValue) {\n\t\t\tregisterSqlType(paramName, sqlParameterValue.getSqlType());\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a parameter to this parameter source.\n\t * @param paramName the name of the parameter\n\t * @param value the value of the parameter\n\t * @param sqlType the SQL type of the parameter\n\t * @return a reference to this parameter source,\n\t * so it's possible to chain several calls together\n\t */\n\tpublic MapSqlParameterSource addValue(String paramName, @Nullable Object value, int sqlType) {\n\t\tAssert.notNull(paramName, \"Parameter name must not be null\");\n\t\tthis.values.put(paramName, value);\n\t\tregisterSqlType(paramName, sqlType);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a parameter to this parameter source.\n\t * @param paramName the name of the parameter\n\t * @param value the value of the parameter\n\t * @param sqlType the SQL type of the parameter\n\t * @param typeName the type name of the parameter\n\t * @return a reference to this parameter source,\n\t * so it's possible to chain several calls together\n\t */\n\tpublic MapSqlParameterSource addValue(String paramName, @Nullable Object value, int sqlType, String typeName) {\n\t\tAssert.notNull(paramName, \"Parameter name must not be null\");\n\t\tthis.values.put(paramName, value);\n\t\tregisterSqlType(paramName, sqlType);\n\t\tregisterTypeName(paramName, typeName);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a Map of parameters to this parameter source.\n\t * @param values a Map holding existing parameter values (can be {@code null})\n\t * @return a reference to this parameter source,\n\t * so it's possible to chain several calls together\n\t */\n\tpublic MapSqlParameterSource addValues(@Nullable Map<String, ?> values) {\n\t\tif (values != null) {\n\t\t\tvalues.forEach((key, value) -> {\n\t\t\t\tthis.values.put(key, value);\n\t\t\t\tif (value instanceof SqlParameterValue sqlParameterValue) {\n\t\t\t\t\tregisterSqlType(key, sqlParameterValue.getSqlType());\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Expose the current parameter values as read-only Map.\n\t */\n\tpublic Map<String, Object> getValues() {\n\t\treturn Collections.unmodifiableMap(this.values);\n\t}\n\n\n\t@Override\n\tpublic boolean hasValue(String paramName) {\n\t\treturn this.values.containsKey(paramName);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Object getValue(String paramName) {\n\t\tif (!hasValue(paramName)) {\n\t\t\tthrow new IllegalArgumentException(\"No value registered for key '\" + paramName + \"'\");\n\t\t}\n\t\treturn this.values.get(paramName);\n\t}\n\n\t@Override\n\t@NonNull\n\tpublic String[] getParameterNames() {\n\t\treturn StringUtils.toStringArray(this.values.keySet());\n\t}\n\n}"
  },
  "org.springframework.jdbc.core.namedparam.MapSqlParameterSource#addValue(paramName,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a parameter to this parameter source.\n\t * @param paramName the name of the parameter\n\t * @param value the value of the parameter\n\t * @return a reference to this parameter source,\n\t * so it's possible to chain several calls together\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "MapSqlParameterSource",
    "signature": "public MapSqlParameterSource addValue(String paramName, @Nullable Object value)",
    "source_code": "\tpublic MapSqlParameterSource addValue(String paramName, @Nullable Object value) {\n\t\tAssert.notNull(paramName, \"Parameter name must not be null\");\n\t\tthis.values.put(paramName, value);\n\t\tif (value instanceof SqlParameterValue sqlParameterValue) {\n\t\t\tregisterSqlType(paramName, sqlParameterValue.getSqlType());\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.MapSqlParameterSource#addValue(paramName,value,sqlType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a parameter to this parameter source.\n\t * @param paramName the name of the parameter\n\t * @param value the value of the parameter\n\t * @param sqlType the SQL type of the parameter\n\t * @return a reference to this parameter source,\n\t * so it's possible to chain several calls together\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName",
      "value",
      "sqlType"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "MapSqlParameterSource",
    "signature": "public MapSqlParameterSource addValue(String paramName, @Nullable Object value, int sqlType)",
    "source_code": "\tpublic MapSqlParameterSource addValue(String paramName, @Nullable Object value, int sqlType) {\n\t\tAssert.notNull(paramName, \"Parameter name must not be null\");\n\t\tthis.values.put(paramName, value);\n\t\tregisterSqlType(paramName, sqlType);\n\t\treturn this;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.MapSqlParameterSource#addValue(paramName,value,sqlType,typeName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a parameter to this parameter source.\n\t * @param paramName the name of the parameter\n\t * @param value the value of the parameter\n\t * @param sqlType the SQL type of the parameter\n\t * @param typeName the type name of the parameter\n\t * @return a reference to this parameter source,\n\t * so it's possible to chain several calls together\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName",
      "value",
      "sqlType",
      "typeName"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "MapSqlParameterSource",
    "signature": "public MapSqlParameterSource addValue(String paramName, @Nullable Object value, int sqlType, String typeName)",
    "source_code": "\tpublic MapSqlParameterSource addValue(String paramName, @Nullable Object value, int sqlType, String typeName) {\n\t\tAssert.notNull(paramName, \"Parameter name must not be null\");\n\t\tthis.values.put(paramName, value);\n\t\tregisterSqlType(paramName, sqlType);\n\t\tregisterTypeName(paramName, typeName);\n\t\treturn this;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.MapSqlParameterSource#addValues(Map<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a Map of parameters to this parameter source.\n\t * @param values a Map holding existing parameter values (can be {@code null})\n\t * @return a reference to this parameter source,\n\t * so it's possible to chain several calls together\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "MapSqlParameterSource",
    "signature": "public MapSqlParameterSource addValues(@Nullable Map<String, ?> values)",
    "source_code": "\tpublic MapSqlParameterSource addValues(@Nullable Map<String, ?> values) {\n\t\tif (values != null) {\n\t\t\tvalues.forEach((key, value) -> {\n\t\t\t\tthis.values.put(key, value);\n\t\t\t\tif (value instanceof SqlParameterValue sqlParameterValue) {\n\t\t\t\t\tregisterSqlType(key, sqlParameterValue.getSqlType());\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.MapSqlParameterSource#getParameterNames()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "String[]",
    "signature": "public String[] getParameterNames()",
    "source_code": "\tpublic String[] getParameterNames() {\n\t\treturn StringUtils.toStringArray(this.values.keySet());\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.MapSqlParameterSource#getValue(paramName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "Object",
    "signature": "public Object getValue(String paramName)",
    "source_code": "\tpublic Object getValue(String paramName) {\n\t\tif (!hasValue(paramName)) {\n\t\t\tthrow new IllegalArgumentException(\"No value registered for key '\" + paramName + \"'\");\n\t\t}\n\t\treturn this.values.get(paramName);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.MapSqlParameterSource#getValues()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Expose the current parameter values as read-only Map.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "Object>",
    "signature": "public Object> getValues()",
    "source_code": "\tpublic Map<String, Object> getValues() {\n\t\treturn Collections.unmodifiableMap(this.values);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.MapSqlParameterSource#hasValue(paramName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "boolean",
    "signature": "public boolean hasValue(String paramName)",
    "source_code": "\tpublic boolean hasValue(String paramName) {\n\t\treturn this.values.containsKey(paramName);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.SqlParameterSourceUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Class that provides helper methods for the use of {@link SqlParameterSource},\n * in particular with {@link NamedParameterJdbcTemplate}.\n *\n * @author Thomas Risberg\n * @author Juergen Hoeller\n * @since 2.5\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 35
    },
    "signature": "public class SqlParameterSourceUtils",
    "source_code": "public abstract class SqlParameterSourceUtils {\n\n\t/**\n\t * Create an array of {@link SqlParameterSource} objects populated with data\n\t * from the values passed in (either a {@link Map} or a bean object).\n\t * This will define what is included in a batch operation.\n\t * @param candidates object array of objects containing the values to be used\n\t * @return an array of {@link SqlParameterSource}\n\t * @see MapSqlParameterSource\n\t * @see BeanPropertySqlParameterSource\n\t * @see NamedParameterJdbcTemplate#batchUpdate(String, SqlParameterSource[])\n\t */\n\tpublic static SqlParameterSource[] createBatch(Object... candidates) {\n\t\treturn createBatch(Arrays.asList(candidates));\n\t}\n\n\t/**\n\t * Create an array of {@link SqlParameterSource} objects populated with data\n\t * from the values passed in (either a {@link Map} or a bean object).\n\t * This will define what is included in a batch operation.\n\t * @param candidates collection of objects containing the values to be used\n\t * @return an array of {@link SqlParameterSource}\n\t * @since 5.0.2\n\t * @see MapSqlParameterSource\n\t * @see BeanPropertySqlParameterSource\n\t * @see NamedParameterJdbcTemplate#batchUpdate(String, SqlParameterSource[])\n\t */\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n\tpublic static SqlParameterSource[] createBatch(Collection<?> candidates) {\n\t\tSqlParameterSource[] batch = new SqlParameterSource[candidates.size()];\n\t\tint i = 0;\n\t\tfor (Object candidate : candidates) {\n\t\t\tbatch[i] = (candidate instanceof Map map ? new MapSqlParameterSource(map) :\n\t\t\t\t\tnew BeanPropertySqlParameterSource(candidate));\n\t\t\ti++;\n\t\t}\n\t\treturn batch;\n\t}\n\n\t/**\n\t * Create an array of {@link MapSqlParameterSource} objects populated with data from\n\t * the values passed in. This will define what is included in a batch operation.\n\t * @param valueMaps array of {@link Map} instances containing the values to be used\n\t * @return an array of {@link SqlParameterSource}\n\t * @see MapSqlParameterSource\n\t * @see NamedParameterJdbcTemplate#batchUpdate(String, Map[])\n\t */\n\tpublic static SqlParameterSource[] createBatch(Map<String, ?>[] valueMaps) {\n\t\tSqlParameterSource[] batch = new SqlParameterSource[valueMaps.length];\n\t\tfor (int i = 0; i < valueMaps.length; i++) {\n\t\t\tbatch[i] = new MapSqlParameterSource(valueMaps[i]);\n\t\t}\n\t\treturn batch;\n\t}\n\n\t/**\n\t * Create a wrapped value if parameter has type information, plain object if not.\n\t * @param source the source of parameter values and type information\n\t * @param parameterName the name of the parameter\n\t * @return the value object\n\t * @see SqlParameterValue\n\t */\n\t@Nullable\n\tpublic static Object getTypedValue(SqlParameterSource source, String parameterName) {\n\t\tint sqlType = source.getSqlType(parameterName);\n\t\tif (sqlType != SqlParameterSource.TYPE_UNKNOWN) {\n\t\t\treturn new SqlParameterValue(sqlType, source.getTypeName(parameterName), source.getValue(parameterName));\n\t\t}\n\t\telse {\n\t\t\treturn source.getValue(parameterName);\n\t\t}\n\t}\n\n\t/**\n\t * Create a Map of case-insensitive parameter names together with the original name.\n\t * @param parameterSource the source of parameter names\n\t * @return the Map that can be used for case-insensitive matching of parameter names\n\t */\n\tpublic static Map<String, String> extractCaseInsensitiveParameterNames(SqlParameterSource parameterSource) {\n\t\tMap<String, String> caseInsensitiveParameterNames = new HashMap<>();\n\t\tString[] paramNames = parameterSource.getParameterNames();\n\t\tif (paramNames != null) {\n\t\t\tfor (String name : paramNames) {\n\t\t\t\tcaseInsensitiveParameterNames.put(name.toLowerCase(), name);\n\t\t\t}\n\t\t}\n\t\treturn caseInsensitiveParameterNames;\n\t}\n\n}"
  },
  "org.springframework.jdbc.core.namedparam.SqlParameterSourceUtils#createBatch(Map<String,valueMaps)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an array of {@link MapSqlParameterSource} objects populated with data from\n\t * the values passed in. This will define what is included in a batch operation.\n\t * @param valueMaps array of {@link Map} instances containing the values to be used\n\t * @return an array of {@link SqlParameterSource}\n\t * @see MapSqlParameterSource\n\t * @see NamedParameterJdbcTemplate#batchUpdate(String, Map[])\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "valueMaps"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "SqlParameterSource[]",
    "signature": "public SqlParameterSource[] createBatch(Map<String, ?>[] valueMaps)",
    "source_code": "\tpublic static SqlParameterSource[] createBatch(Map<String, ?>[] valueMaps) {\n\t\tSqlParameterSource[] batch = new SqlParameterSource[valueMaps.length];\n\t\tfor (int i = 0; i < valueMaps.length; i++) {\n\t\t\tbatch[i] = new MapSqlParameterSource(valueMaps[i]);\n\t\t}\n\t\treturn batch;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.SqlParameterSourceUtils#createBatch(candidates)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an array of {@link SqlParameterSource} objects populated with data\n\t * from the values passed in (either a {@link Map} or a bean object).\n\t * This will define what is included in a batch operation.\n\t * @param candidates collection of objects containing the values to be used\n\t * @return an array of {@link SqlParameterSource}\n\t * @since 5.0.2\n\t * @see MapSqlParameterSource\n\t * @see BeanPropertySqlParameterSource\n\t * @see NamedParameterJdbcTemplate#batchUpdate(String, SqlParameterSource[])\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "candidates"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "SqlParameterSource[]",
    "signature": "public SqlParameterSource[] createBatch(Collection<?> candidates)",
    "source_code": "\tpublic static SqlParameterSource[] createBatch(Collection<?> candidates) {\n\t\tSqlParameterSource[] batch = new SqlParameterSource[candidates.size()];\n\t\tint i = 0;\n\t\tfor (Object candidate : candidates) {\n\t\t\tbatch[i] = (candidate instanceof Map map ? new MapSqlParameterSource(map) :\n\t\t\t\t\tnew BeanPropertySqlParameterSource(candidate));\n\t\t\ti++;\n\t\t}\n\t\treturn batch;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.SqlParameterSourceUtils#extractCaseInsensitiveParameterNames(parameterSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a Map of case-insensitive parameter names together with the original name.\n\t * @param parameterSource the source of parameter names\n\t * @return the Map that can be used for case-insensitive matching of parameter names\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterSource"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "String>",
    "signature": "public String> extractCaseInsensitiveParameterNames(SqlParameterSource parameterSource)",
    "source_code": "\tpublic static Map<String, String> extractCaseInsensitiveParameterNames(SqlParameterSource parameterSource) {\n\t\tMap<String, String> caseInsensitiveParameterNames = new HashMap<>();\n\t\tString[] paramNames = parameterSource.getParameterNames();\n\t\tif (paramNames != null) {\n\t\t\tfor (String name : paramNames) {\n\t\t\t\tcaseInsensitiveParameterNames.put(name.toLowerCase(), name);\n\t\t\t}\n\t\t}\n\t\treturn caseInsensitiveParameterNames;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.SqlParameterSourceUtils#getTypedValue(source,parameterName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a wrapped value if parameter has type information, plain object if not.\n\t * @param source the source of parameter values and type information\n\t * @param parameterName the name of the parameter\n\t * @return the value object\n\t * @see SqlParameterValue\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "parameterName"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "Object",
    "signature": "public Object getTypedValue(SqlParameterSource source, String parameterName)",
    "source_code": "\tpublic static Object getTypedValue(SqlParameterSource source, String parameterName) {\n\t\tint sqlType = source.getSqlType(parameterName);\n\t\tif (sqlType != SqlParameterSource.TYPE_UNKNOWN) {\n\t\t\treturn new SqlParameterValue(sqlType, source.getTypeName(parameterName), source.getValue(parameterName));\n\t\t}\n\t\telse {\n\t\t\treturn source.getValue(parameterName);\n\t\t}\n\t}"
  },
  "org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Implementation of the {@link JmxAttributeSource} interface that\n * reads annotations and exposes the corresponding attributes.\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @author Jennifer Hickey\n * @author Stephane Nicoll\n * @since 1.2\n * @see ManagedResource\n * @see ManagedAttribute\n * @see ManagedOperation\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "signature": "public class AnnotationJmxAttributeSource",
    "source_code": "public class AnnotationJmxAttributeSource implements JmxAttributeSource, BeanFactoryAware {\n\n\t@Nullable\n\tprivate StringValueResolver embeddedValueResolver;\n\n\n\t@Override\n\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tif (beanFactory instanceof ConfigurableBeanFactory cbf) {\n\t\t\tthis.embeddedValueResolver = new EmbeddedValueResolver(cbf);\n\t\t}\n\t}\n\n\n\t@Override\n\t@Nullable\n\tpublic org.springframework.jmx.export.metadata.ManagedResource getManagedResource(Class<?> beanClass) throws InvalidMetadataException {\n\t\tMergedAnnotation<ManagedResource> ann = MergedAnnotations.from(beanClass, SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t.get(ManagedResource.class).withNonMergedAttributes();\n\t\tif (!ann.isPresent()) {\n\t\t\treturn null;\n\t\t}\n\t\tClass<?> declaringClass = (Class<?>) ann.getSource();\n\t\tClass<?> target = (declaringClass != null && !declaringClass.isInterface() ? declaringClass : beanClass);\n\t\tif (!Modifier.isPublic(target.getModifiers())) {\n\t\t\tthrow new InvalidMetadataException(\"@ManagedResource class '\" + target.getName() + \"' must be public\");\n\t\t}\n\n\t\torg.springframework.jmx.export.metadata.ManagedResource bean = new org.springframework.jmx.export.metadata.ManagedResource();\n\t\tMap<String, Object> map = ann.asMap();\n\t\tList<PropertyValue> list = new ArrayList<>(map.size());\n\t\tmap.forEach((attrName, attrValue) -> {\n\t\t\tif (!\"value\".equals(attrName)) {\n\t\t\t\tObject value = attrValue;\n\t\t\t\tif (this.embeddedValueResolver != null && value instanceof String text) {\n\t\t\t\t\tvalue = this.embeddedValueResolver.resolveStringValue(text);\n\t\t\t\t}\n\t\t\t\tlist.add(new PropertyValue(attrName, value));\n\t\t\t}\n\t\t});\n\t\tPropertyAccessorFactory.forBeanPropertyAccess(bean).setPropertyValues(new MutablePropertyValues(list));\n\t\treturn bean;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic org.springframework.jmx.export.metadata.ManagedAttribute getManagedAttribute(Method method) throws InvalidMetadataException {\n\t\tMergedAnnotation<ManagedAttribute> ann = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t.get(ManagedAttribute.class).withNonMergedAttributes();\n\t\tif (!ann.isPresent()) {\n\t\t\treturn null;\n\t\t}\n\n\t\torg.springframework.jmx.export.metadata.ManagedAttribute bean = new org.springframework.jmx.export.metadata.ManagedAttribute();\n\t\tMap<String, Object> map = ann.asMap();\n\t\tMutablePropertyValues pvs = new MutablePropertyValues(map);\n\t\tpvs.removePropertyValue(\"defaultValue\");\n\t\tPropertyAccessorFactory.forBeanPropertyAccess(bean).setPropertyValues(pvs);\n\t\tString defaultValue = (String) map.get(\"defaultValue\");\n\t\tif (defaultValue.length() > 0) {\n\t\t\tbean.setDefaultValue(defaultValue);\n\t\t}\n\t\treturn bean;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic org.springframework.jmx.export.metadata.ManagedMetric getManagedMetric(Method method) throws InvalidMetadataException {\n\t\tMergedAnnotation<ManagedMetric> ann = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t.get(ManagedMetric.class).withNonMergedAttributes();\n\n\t\treturn copyPropertiesToBean(ann, org.springframework.jmx.export.metadata.ManagedMetric.class);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic org.springframework.jmx.export.metadata.ManagedOperation getManagedOperation(Method method) throws InvalidMetadataException {\n\t\tMergedAnnotation<ManagedOperation> ann = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t.get(ManagedOperation.class).withNonMergedAttributes();\n\n\t\treturn copyPropertiesToBean(ann, org.springframework.jmx.export.metadata.ManagedOperation.class);\n\t}\n\n\t@Override\n\tpublic org.springframework.jmx.export.metadata.ManagedOperationParameter[] getManagedOperationParameters(Method method)\n\t\t\tthrows InvalidMetadataException {\n\n\t\tList<MergedAnnotation<? extends Annotation>> anns = getRepeatableAnnotations(\n\t\t\t\tmethod, ManagedOperationParameter.class, ManagedOperationParameters.class);\n\n\t\treturn copyPropertiesToBeanArray(anns, org.springframework.jmx.export.metadata.ManagedOperationParameter.class);\n\t}\n\n\t@Override\n\tpublic org.springframework.jmx.export.metadata.ManagedNotification[] getManagedNotifications(Class<?> clazz)\n\t\t\tthrows InvalidMetadataException {\n\n\t\tList<MergedAnnotation<? extends Annotation>> anns = getRepeatableAnnotations(\n\t\t\t\tclazz, ManagedNotification.class, ManagedNotifications.class);\n\n\t\treturn copyPropertiesToBeanArray(anns, org.springframework.jmx.export.metadata.ManagedNotification.class);\n\t}\n\n\n\tprivate static List<MergedAnnotation<? extends Annotation>> getRepeatableAnnotations(\n\t\t\tAnnotatedElement annotatedElement, Class<? extends Annotation> annotationType,\n\t\t\tClass<? extends Annotation> containerAnnotationType) {\n\n\t\treturn MergedAnnotations.from(annotatedElement, SearchStrategy.TYPE_HIERARCHY,\n\t\t\t\tRepeatableContainers.of(annotationType, containerAnnotationType))\n\t\t\t\t.stream(annotationType)\n\t\t\t\t.filter(MergedAnnotationPredicates.firstRunOf(MergedAnnotation::getAggregateIndex))\n\t\t\t\t.map(MergedAnnotation::withNonMergedAttributes)\n\t\t\t\t.collect(Collectors.toList());\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate static <T> T[] copyPropertiesToBeanArray(\n\t\t\tList<MergedAnnotation<? extends Annotation>> anns, Class<T> beanClass) {\n\n\t\tT[] beans = (T[]) Array.newInstance(beanClass, anns.size());\n\t\tint i = 0;\n\t\tfor (MergedAnnotation<? extends Annotation> ann : anns) {\n\t\t\tbeans[i++] = copyPropertiesToBean(ann, beanClass);\n\t\t}\n\t\treturn beans;\n\t}\n\n\t@Nullable\n\tprivate static <T> T copyPropertiesToBean(MergedAnnotation<? extends Annotation> ann, Class<T> beanClass) {\n\t\tif (!ann.isPresent()) {\n\t\t\treturn null;\n\t\t}\n\t\tT bean = BeanUtils.instantiateClass(beanClass);\n\t\tBeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(bean);\n\t\tbw.setPropertyValues(new MutablePropertyValues(ann.asMap()));\n\t\treturn bean;\n\t}\n\n}"
  },
  "org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "void",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tif (beanFactory instanceof ConfigurableBeanFactory cbf) {\n\t\t\tthis.embeddedValueResolver = new EmbeddedValueResolver(cbf);\n\t\t}\n\t}"
  },
  "org.springframework.jmx.export.notification.ModelMBeanNotificationPublisher": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link NotificationPublisher} implementation that uses the infrastructure\n * provided by the {@link ModelMBean} interface to track\n * {@link javax.management.NotificationListener javax.management.NotificationListeners}\n * and send {@link Notification Notifications} to those listeners.\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @author Rick Evans\n * @since 2.0\n * @see javax.management.modelmbean.ModelMBeanNotificationBroadcaster\n * @see NotificationPublisherAware\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "signature": "public class ModelMBeanNotificationPublisher",
    "source_code": "public class ModelMBeanNotificationPublisher implements NotificationPublisher {\n\n\t/**\n\t * The {@link ModelMBean} instance wrapping the managed resource into which this\n\t * {@code NotificationPublisher} will be injected.\n\t */\n\tprivate final ModelMBeanNotificationBroadcaster modelMBean;\n\n\t/**\n\t * The {@link ObjectName} associated with the {@link ModelMBean modelMBean}.\n\t */\n\tprivate final ObjectName objectName;\n\n\t/**\n\t * The managed resource associated with the {@link ModelMBean modelMBean}.\n\t */\n\tprivate final Object managedResource;\n\n\n\t/**\n\t * Create a new instance of the {@link ModelMBeanNotificationPublisher} class\n\t * that will publish all {@link javax.management.Notification Notifications}\n\t * to the supplied {@link ModelMBean}.\n\t * @param modelMBean the target {@link ModelMBean}; must not be {@code null}\n\t * @param objectName the {@link ObjectName} of the source {@link ModelMBean}\n\t * @param managedResource the managed resource exposed by the supplied {@link ModelMBean}\n\t * @throws IllegalArgumentException if any of the parameters is {@code null}\n\t */\n\tpublic ModelMBeanNotificationPublisher(\n\t\t\tModelMBeanNotificationBroadcaster modelMBean, ObjectName objectName, Object managedResource) {\n\n\t\tAssert.notNull(modelMBean, \"'modelMBean' must not be null\");\n\t\tAssert.notNull(objectName, \"'objectName' must not be null\");\n\t\tAssert.notNull(managedResource, \"'managedResource' must not be null\");\n\t\tthis.modelMBean = modelMBean;\n\t\tthis.objectName = objectName;\n\t\tthis.managedResource = managedResource;\n\t}\n\n\n\t/**\n\t * Send the supplied {@link Notification} using the wrapped\n\t * {@link ModelMBean} instance.\n\t * @param notification the {@link Notification} to be sent\n\t * @throws IllegalArgumentException if the supplied {@code notification} is {@code null}\n\t * @throws UnableToSendNotificationException if the supplied {@code notification} could not be sent\n\t */\n\t@Override\n\tpublic void sendNotification(Notification notification) {\n\t\tAssert.notNull(notification, \"Notification must not be null\");\n\t\treplaceNotificationSourceIfNecessary(notification);\n\t\ttry {\n\t\t\tif (notification instanceof AttributeChangeNotification acn) {\n\t\t\t\tthis.modelMBean.sendAttributeChangeNotification(acn);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.modelMBean.sendNotification(notification);\n\t\t\t}\n\t\t}\n\t\tcatch (MBeanException ex) {\n\t\t\tthrow new UnableToSendNotificationException(\"Unable to send notification [\" + notification + \"]\", ex);\n\t\t}\n\t}\n\n\t/**\n\t * Replaces the notification source if necessary to do so.\n\t * From the {@link Notification javadoc}:\n\t * <i>\"It is strongly recommended that notification senders use the object name\n\t * rather than a reference to the MBean object as the source.\"</i>\n\t * @param notification the {@link Notification} whose\n\t * {@link javax.management.Notification#getSource()} might need massaging\n\t */\n\tprivate void replaceNotificationSourceIfNecessary(Notification notification) {\n\t\tif (notification.getSource() == null || notification.getSource().equals(this.managedResource)) {\n\t\t\tnotification.setSource(this.objectName);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.jmx.export.notification.ModelMBeanNotificationPublisher#sendNotification(notification)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Send the supplied {@link Notification} using the wrapped\n\t * {@link ModelMBean} instance.\n\t * @param notification the {@link Notification} to be sent\n\t * @throws IllegalArgumentException if the supplied {@code notification} is {@code null}\n\t * @throws UnableToSendNotificationException if the supplied {@code notification} could not be sent\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "notification"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "void",
    "signature": "public void sendNotification(Notification notification)",
    "source_code": "\tpublic void sendNotification(Notification notification) {\n\t\tAssert.notNull(notification, \"Notification must not be null\");\n\t\treplaceNotificationSourceIfNecessary(notification);\n\t\ttry {\n\t\t\tif (notification instanceof AttributeChangeNotification acn) {\n\t\t\t\tthis.modelMBean.sendAttributeChangeNotification(acn);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.modelMBean.sendNotification(notification);\n\t\t\t}\n\t\t}\n\t\tcatch (MBeanException ex) {\n\t\t\tthrow new UnableToSendNotificationException(\"Unable to send notification [\" + notification + \"]\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jmx.support.ObjectNameManager": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Helper class for the creation of {@link javax.management.ObjectName} instances.\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @since 1.2\n * @see javax.management.ObjectName#getInstance(String)\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 32
    },
    "signature": "public class ObjectNameManager",
    "source_code": "public final class ObjectNameManager {\n\n\tprivate ObjectNameManager() {\n\t}\n\n\n\t/**\n\t * Retrieve the {@link ObjectName} instance corresponding to the supplied name.\n\t * @param name the name in {@code ObjectName} or {@code String} format\n\t * @return the {@code ObjectName} instance\n\t * @throws MalformedObjectNameException in case of an invalid object name specification\n\t * @see ObjectName#ObjectName(String)\n\t * @see ObjectName#getInstance(String)\n\t */\n\tpublic static ObjectName getInstance(Object name) throws MalformedObjectNameException {\n\t\tif (name instanceof ObjectName objectName) {\n\t\t\treturn objectName;\n\t\t}\n\t\tif (!(name instanceof String text)) {\n\t\t\tthrow new MalformedObjectNameException(\"Invalid ObjectName value type [\" +\n\t\t\t\t\tname.getClass().getName() + \"]: only ObjectName and String supported.\");\n\t\t}\n\t\treturn getInstance(text);\n\t}\n\n\t/**\n\t * Retrieve the {@code ObjectName} instance corresponding to the supplied name.\n\t * @param objectName the {@code ObjectName} in {@code String} format\n\t * @return the {@code ObjectName} instance\n\t * @throws MalformedObjectNameException in case of an invalid object name specification\n\t * @see ObjectName#ObjectName(String)\n\t * @see ObjectName#getInstance(String)\n\t */\n\tpublic static ObjectName getInstance(String objectName) throws MalformedObjectNameException {\n\t\treturn ObjectName.getInstance(objectName);\n\t}\n\n\t/**\n\t * Retrieve an {@code ObjectName} instance for the specified domain and a\n\t * single property with the supplied key and value.\n\t * @param domainName the domain name for the {@code ObjectName}\n\t * @param key the key for the single property in the {@code ObjectName}\n\t * @param value the value for the single property in the {@code ObjectName}\n\t * @return the {@code ObjectName} instance\n\t * @throws MalformedObjectNameException in case of an invalid object name specification\n\t * @see ObjectName#ObjectName(String, String, String)\n\t * @see ObjectName#getInstance(String, String, String)\n\t */\n\tpublic static ObjectName getInstance(String domainName, String key, String value)\n\t\t\tthrows MalformedObjectNameException {\n\n\t\treturn ObjectName.getInstance(domainName, key, value);\n\t}\n\n\t/**\n\t * Retrieve an {@code ObjectName} instance with the specified domain name\n\t * and the supplied key/name properties.\n\t * @param domainName the domain name for the {@code ObjectName}\n\t * @param properties the properties for the {@code ObjectName}\n\t * @return the {@code ObjectName} instance\n\t * @throws MalformedObjectNameException in case of an invalid object name specification\n\t * @see ObjectName#ObjectName(String, java.util.Hashtable)\n\t * @see ObjectName#getInstance(String, java.util.Hashtable)\n\t */\n\tpublic static ObjectName getInstance(String domainName, Hashtable<String, String> properties)\n\t\t\tthrows MalformedObjectNameException {\n\n\t\treturn ObjectName.getInstance(domainName, properties);\n\t}\n\n}"
  },
  "org.springframework.jmx.support.ObjectNameManager#getInstance(domainName,Hashtable<String,properties)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve an {@code ObjectName} instance with the specified domain name\n\t * and the supplied key/name properties.\n\t * @param domainName the domain name for the {@code ObjectName}\n\t * @param properties the properties for the {@code ObjectName}\n\t * @return the {@code ObjectName} instance\n\t * @throws MalformedObjectNameException in case of an invalid object name specification\n\t * @see ObjectName#ObjectName(String, java.util.Hashtable)\n\t * @see ObjectName#getInstance(String, java.util.Hashtable)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "domainName",
      "Hashtable<String",
      "properties"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "ObjectName",
    "signature": "public ObjectName getInstance(String domainName, Hashtable<String, String> properties)",
    "source_code": "\tpublic static ObjectName getInstance(String domainName, Hashtable<String, String> properties)"
  },
  "org.springframework.jmx.support.ObjectNameManager#getInstance(domainName,key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve an {@code ObjectName} instance for the specified domain and a\n\t * single property with the supplied key and value.\n\t * @param domainName the domain name for the {@code ObjectName}\n\t * @param key the key for the single property in the {@code ObjectName}\n\t * @param value the value for the single property in the {@code ObjectName}\n\t * @return the {@code ObjectName} instance\n\t * @throws MalformedObjectNameException in case of an invalid object name specification\n\t * @see ObjectName#ObjectName(String, String, String)\n\t * @see ObjectName#getInstance(String, String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "domainName",
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "ObjectName",
    "signature": "public ObjectName getInstance(String domainName, String key, String value)",
    "source_code": "\tpublic static ObjectName getInstance(String domainName, String key, String value)"
  },
  "org.springframework.jmx.support.ObjectNameManager#getInstance(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the {@link ObjectName} instance corresponding to the supplied name.\n\t * @param name the name in {@code ObjectName} or {@code String} format\n\t * @return the {@code ObjectName} instance\n\t * @throws MalformedObjectNameException in case of an invalid object name specification\n\t * @see ObjectName#ObjectName(String)\n\t * @see ObjectName#getInstance(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "return": "ObjectName",
    "signature": "public ObjectName getInstance(Object name)",
    "source_code": "\tpublic static ObjectName getInstance(Object name) throws MalformedObjectNameException {\n\t\tif (name instanceof ObjectName objectName) {\n\t\t\treturn objectName;\n\t\t}\n\t\tif (!(name instanceof String text)) {\n\t\t\tthrow new MalformedObjectNameException(\"Invalid ObjectName value type [\" +\n\t\t\t\t\tname.getClass().getName() + \"]: only ObjectName and String supported.\");\n\t\t}\n\t\treturn getInstance(text);\n\t}"
  },
  "org.springframework.jmx.support.ObjectNameManager#getInstance(objectName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the {@code ObjectName} instance corresponding to the supplied name.\n\t * @param objectName the {@code ObjectName} in {@code String} format\n\t * @return the {@code ObjectName} instance\n\t * @throws MalformedObjectNameException in case of an invalid object name specification\n\t * @see ObjectName#ObjectName(String)\n\t * @see ObjectName#getInstance(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "objectName"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "ObjectName",
    "signature": "public ObjectName getInstance(String objectName)",
    "source_code": "\tpublic static ObjectName getInstance(String objectName) throws MalformedObjectNameException {\n\t\treturn ObjectName.getInstance(objectName);\n\t}"
  },
  "org.springframework.jndi.JndiObjectFactoryBean": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link org.springframework.beans.factory.FactoryBean} that looks up a\n * JNDI object. Exposes the object found in JNDI for bean references,\n * e.g. for data access object's \"dataSource\" property in case of a\n * {@link javax.sql.DataSource}.\n *\n * <p>The typical usage will be to register this as singleton factory\n * (e.g. for a certain JNDI-bound DataSource) in an application context,\n * and give bean references to application services that need it.\n *\n * <p>The default behavior is to look up the JNDI object on startup and cache it.\n * This can be customized through the \"lookupOnStartup\" and \"cache\" properties,\n * using a {@link JndiObjectTargetSource} underneath. Note that you need to specify\n * a \"proxyInterface\" in such a scenario, since the actual JNDI object type is not\n * known in advance.\n *\n * <p>Of course, bean classes in a Spring environment may look up e.g. a DataSource\n * from JNDI themselves. This class simply enables central configuration of the\n * JNDI name, and easy switching to non-JNDI alternatives. The latter is\n * particularly convenient for test setups, reuse in standalone clients, etc.\n *\n * <p>Note that switching to e.g. DriverManagerDataSource is just a matter of\n * configuration: Simply replace the definition of this FactoryBean with a\n * {@link org.springframework.jdbc.datasource.DriverManagerDataSource} definition!\n *\n * @author Juergen Hoeller\n * @since 22.05.2003\n * @see #setProxyInterface\n * @see #setLookupOnStartup\n * @see #setCache\n * @see JndiObjectTargetSource\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "signature": "public class JndiObjectFactoryBean",
    "source_code": "public class JndiObjectFactoryBean extends JndiObjectLocator"
  },
  "org.springframework.jndi.JndiObjectFactoryBean#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Look up the JNDI object and store it.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() throws IllegalArgumentException, NamingException {\n\t\tsuper.afterPropertiesSet();\n\n\t\tif (this.proxyInterfaces != null || !this.lookupOnStartup || !this.cache || this.exposeAccessContext) {\n\t\t\t// We need to create a proxy for this...\n\t\t\tif (this.defaultObject != null) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"'defaultObject' is not supported in combination with 'proxyInterface'\");\n\t\t\t}\n\t\t\t// We need a proxy and a JndiObjectTargetSource.\n\t\t\tthis.jndiObject = JndiObjectProxyFactory.createJndiObjectProxy(this);\n\t\t}\n\t\telse {\n\t\t\tif (this.defaultObject != null && getExpectedType() != null &&\n\t\t\t\t\t!getExpectedType().isInstance(this.defaultObject)) {\n\t\t\t\tTypeConverter converter = (this.beanFactory != null ?\n\t\t\t\t\t\tthis.beanFactory.getTypeConverter() : new SimpleTypeConverter());\n\t\t\t\ttry {\n\t\t\t\t\tthis.defaultObject = converter.convertIfNecessary(this.defaultObject, getExpectedType());\n\t\t\t\t}\n\t\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Default object [\" + this.defaultObject + \"] of type [\" +\n\t\t\t\t\t\t\tthis.defaultObject.getClass().getName() + \"] is not of expected type [\" +\n\t\t\t\t\t\t\tgetExpectedType().getName() + \"] and cannot be converted either\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Locate specified JNDI object.\n\t\t\tthis.jndiObject = lookupWithFallback();\n\t\t}\n\t}"
  },
  "org.springframework.jndi.JndiObjectFactoryBean#getObject()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the singleton JNDI object.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "Object",
    "signature": "public Object getObject()",
    "source_code": "\tpublic Object getObject() {\n\t\treturn this.jndiObject;\n\t}"
  },
  "org.springframework.jndi.JndiObjectFactoryBean#invoke(invocation)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "invocation"
    ],
    "position": {
      "column": 1,
      "line": 372
    },
    "return": "Object",
    "signature": "public Object invoke(MethodInvocation invocation)",
    "source_code": "\t\tpublic Object invoke(MethodInvocation invocation) throws Throwable {\n\t\t\tContext ctx = (isEligible(invocation.getMethod()) ? this.jndiTemplate.getContext() : null);\n\t\t\ttry {\n\t\t\t\treturn invocation.proceed();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.jndiTemplate.releaseContext(ctx);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.jndi.JndiObjectFactoryBean#isEligible(method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 382
    },
    "return": "boolean",
    "signature": "protected boolean isEligible(Method method)",
    "source_code": "\t\tprotected boolean isEligible(Method method) {\n\t\t\treturn (Object.class != method.getDeclaringClass());\n\t\t}"
  },
  "org.springframework.jndi.JndiObjectFactoryBean#isSingleton()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 294
    },
    "return": "boolean",
    "signature": "public boolean isSingleton()",
    "source_code": "\tpublic boolean isSingleton() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.jndi.JndiObjectFactoryBean#lookupWithFallback()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Lookup variant that returns the specified \"defaultObject\"\n\t * (if any) in case of lookup failure.\n\t * @return the located object, or the \"defaultObject\" as fallback\n\t * @throws NamingException in case of lookup failure without fallback\n\t * @see #setDefaultObject\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "Object",
    "signature": "protected Object lookupWithFallback()",
    "source_code": "\tprotected Object lookupWithFallback() throws NamingException {\n\t\tClassLoader originalClassLoader = ClassUtils.overrideThreadContextClassLoader(this.beanClassLoader);\n\t\ttry {\n\t\t\treturn lookup();\n\t\t}\n\t\tcatch (TypeMismatchNamingException ex) {\n\t\t\t// Always let TypeMismatchNamingException through -\n\t\t\t// we don't want to fall back to the defaultObject in this case.\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (NamingException ex) {\n\t\t\tif (this.defaultObject != null) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"JNDI lookup failed - returning specified default object instead\", ex);\n\t\t\t\t}\n\t\t\t\telse if (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"JNDI lookup failed - returning specified default object instead: \" + ex);\n\t\t\t\t}\n\t\t\t\treturn this.defaultObject;\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t\tfinally {\n\t\t\tif (originalClassLoader != null) {\n\t\t\t\tThread.currentThread().setContextClassLoader(originalClassLoader);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jndi.JndiObjectFactoryBean#setBeanClassLoader(classLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "void",
    "signature": "public void setBeanClassLoader(ClassLoader classLoader)",
    "source_code": "\tpublic void setBeanClassLoader(ClassLoader classLoader) {\n\t\tthis.beanClassLoader = classLoader;\n\t}"
  },
  "org.springframework.jndi.JndiObjectFactoryBean#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "void",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tif (beanFactory instanceof ConfigurableBeanFactory cbf) {\n\t\t\t// Just optional - for getting a specifically configured TypeConverter if needed.\n\t\t\t// We'll simply fall back to a SimpleTypeConverter if no specific one available.\n\t\t\tthis.beanFactory = cbf;\n\t\t}\n\t}"
  },
  "org.springframework.jndi.JndiObjectFactoryBean#setCache(cache)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to cache the JNDI object once it has been located.\n\t * Default is \"true\".\n\t * <p>Can be turned off to allow for hot redeployment of JNDI objects.\n\t * In this case, the JNDI object will be fetched for each invocation.\n\t * <p>For hot redeployment, a proxy interface needs to be specified.\n\t * @see #setProxyInterface\n\t * @see #setLookupOnStartup\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cache"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "void",
    "signature": "public void setCache(boolean cache)",
    "source_code": "\tpublic void setCache(boolean cache) {\n\t\tthis.cache = cache;\n\t}"
  },
  "org.springframework.jndi.JndiObjectFactoryBean#setDefaultObject(defaultObject)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify a default object to fall back to if the JNDI lookup fails.\n\t * Default is none.\n\t * <p>This can be an arbitrary bean reference or literal value.\n\t * It is typically used for literal values in scenarios where the JNDI environment\n\t * might define specific config settings but those are not required to be present.\n\t * <p>Note: This is only supported for lookup on startup.\n\t * If specified together with {@link #setExpectedType}, the specified value\n\t * needs to be either of that type or convertible to it.\n\t * @see #setLookupOnStartup\n\t * @see ConfigurableBeanFactory#getTypeConverter()\n\t * @see SimpleTypeConverter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultObject"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "void",
    "signature": "public void setDefaultObject(Object defaultObject)",
    "source_code": "\tpublic void setDefaultObject(Object defaultObject) {\n\t\tthis.defaultObject = defaultObject;\n\t}"
  },
  "org.springframework.jndi.JndiObjectFactoryBean#setExposeAccessContext(exposeAccessContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to expose the JNDI environment context for all access to the target\n\t * object, i.e. for all method invocations on the exposed object reference.\n\t * <p>Default is \"false\", i.e. to only expose the JNDI context for object lookup.\n\t * Switch this flag to \"true\" in order to expose the JNDI environment (including\n\t * the authorization context) for each method invocation, as needed by WebLogic\n\t * for JNDI-obtained factories (e.g. JDBC DataSource, JMS ConnectionFactory)\n\t * with authorization requirements.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exposeAccessContext"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "void",
    "signature": "public void setExposeAccessContext(boolean exposeAccessContext)",
    "source_code": "\tpublic void setExposeAccessContext(boolean exposeAccessContext) {\n\t\tthis.exposeAccessContext = exposeAccessContext;\n\t}"
  },
  "org.springframework.jndi.JndiObjectFactoryBean#setLookupOnStartup(lookupOnStartup)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to look up the JNDI object on startup. Default is \"true\".\n\t * <p>Can be turned off to allow for late availability of the JNDI object.\n\t * In this case, the JNDI object will be fetched on first access.\n\t * <p>For a lazy lookup, a proxy interface needs to be specified.\n\t * @see #setProxyInterface\n\t * @see #setCache\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lookupOnStartup"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "void",
    "signature": "public void setLookupOnStartup(boolean lookupOnStartup)",
    "source_code": "\tpublic void setLookupOnStartup(boolean lookupOnStartup) {\n\t\tthis.lookupOnStartup = lookupOnStartup;\n\t}"
  },
  "org.springframework.jndi.JndiObjectFactoryBean#setProxyInterface(proxyInterface)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the proxy interface to use for the JNDI object.\n\t * <p>Typically used in conjunction with \"lookupOnStartup\"=false and/or \"cache\"=false.\n\t * Needs to be specified because the actual JNDI object type is not known\n\t * in advance in case of a lazy lookup.\n\t * @see #setProxyInterfaces\n\t * @see #setLookupOnStartup\n\t * @see #setCache\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxyInterface"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "void",
    "signature": "public void setProxyInterface(Class<?> proxyInterface)",
    "source_code": "\tpublic void setProxyInterface(Class<?> proxyInterface) {\n\t\tthis.proxyInterfaces = new Class<?>[] {proxyInterface};\n\t}"
  },
  "org.springframework.jndi.JndiObjectFactoryBean#setProxyInterfaces(proxyInterfaces)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify multiple proxy interfaces to use for the JNDI object.\n\t * <p>Typically used in conjunction with \"lookupOnStartup\"=false and/or \"cache\"=false.\n\t * Note that proxy interfaces will be autodetected from a specified \"expectedType\",\n\t * if necessary.\n\t * @see #setExpectedType\n\t * @see #setLookupOnStartup\n\t * @see #setCache\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxyInterfaces"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "void",
    "signature": "public void setProxyInterfaces(Class<?>... proxyInterfaces)",
    "source_code": "\tpublic void setProxyInterfaces(Class<?>... proxyInterfaces) {\n\t\tthis.proxyInterfaces = proxyInterfaces;\n\t}"
  },
  "org.springframework.messaging.CONTENT_TYPE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The key for the message content type.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "signature": "public String CONTENT_TYPE",
    "source_code": "\tpublic static final String CONTENT_TYPE = \"contentType\";",
    "type": "String"
  },
  "org.springframework.messaging.ERROR_CHANNEL": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The key for the message error channel.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "signature": "public String ERROR_CHANNEL",
    "source_code": "\tpublic static final String ERROR_CHANNEL = \"errorChannel\";",
    "type": "String"
  },
  "org.springframework.messaging.ID": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The key for the Message ID. This is an automatically generated UUID and\n\t * should never be explicitly set in the header map <b>except</b> in the\n\t * case of Message deserialization where the serialized Message's generated\n\t * UUID is being restored.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "signature": "public String ID",
    "source_code": "\tpublic static final String ID = \"id\";",
    "type": "String"
  },
  "org.springframework.messaging.ID_VALUE_NONE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * UUID for none.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "signature": "public UUID ID_VALUE_NONE",
    "source_code": "\tpublic static final UUID ID_VALUE_NONE = new UUID(0,0);",
    "type": "UUID"
  },
  "org.springframework.messaging.MessageHeaders": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * The headers for a {@link Message}.\n *\n * <p><b>IMPORTANT</b>: This class is immutable. Any mutating operation such as\n * {@code put(..)}, {@code putAll(..)} and others will throw\n * {@link UnsupportedOperationException}.\n * <p>Subclasses do have access to the raw headers, however, via {@link #getRawHeaders()}.\n *\n * <p>One way to create message headers is to use the\n * {@link org.springframework.messaging.support.MessageBuilder MessageBuilder}:\n * <pre class=\"code\">\n * MessageBuilder.withPayload(\"foo\").setHeader(\"key1\", \"value1\").setHeader(\"key2\", \"value2\");\n * </pre>\n *\n * A second option is to create {@link org.springframework.messaging.support.GenericMessage}\n * passing a payload as {@link Object} and headers as a {@link Map java.util.Map}:\n * <pre class=\"code\">\n * Map headers = new HashMap();\n * headers.put(\"key1\", \"value1\");\n * headers.put(\"key2\", \"value2\");\n * new GenericMessage(\"foo\", headers);\n * </pre>\n *\n * A third option is to use {@link org.springframework.messaging.support.MessageHeaderAccessor}\n * or one of its subclasses to create specific categories of headers.\n *\n * @author Arjen Poutsma\n * @author Mark Fisher\n * @author Gary Russell\n * @author Juergen Hoeller\n * @since 4.0\n * @see org.springframework.messaging.support.MessageBuilder\n * @see org.springframework.messaging.support.MessageHeaderAccessor\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "signature": "public class MessageHeaders",
    "source_code": "public class MessageHeaders implements Map<String, Object>, Serializable {\n\n\t/**\n\t * UUID for none.\n\t */\n\tpublic static final UUID ID_VALUE_NONE = new UUID(0,0);\n\n\t/**\n\t * The key for the Message ID. This is an automatically generated UUID and\n\t * should never be explicitly set in the header map <b>except</b> in the\n\t * case of Message deserialization where the serialized Message's generated\n\t * UUID is being restored.\n\t */\n\tpublic static final String ID = \"id\";\n\n\t/**\n\t * The key for the message timestamp.\n\t */\n\tpublic static final String TIMESTAMP = \"timestamp\";\n\n\t/**\n\t * The key for the message content type.\n\t */\n\tpublic static final String CONTENT_TYPE = \"contentType\";\n\n\t/**\n\t * The key for the message reply channel.\n\t */\n\tpublic static final String REPLY_CHANNEL = \"replyChannel\";\n\n\t/**\n\t * The key for the message error channel.\n\t */\n\tpublic static final String ERROR_CHANNEL = \"errorChannel\";\n\n\n\tprivate static final long serialVersionUID = 7035068984263400920L;\n\n\tprivate static final Log logger = LogFactory.getLog(MessageHeaders.class);\n\n\tprivate static final IdGenerator defaultIdGenerator = new AlternativeJdkIdGenerator();\n\n\t@Nullable\n\tprivate static volatile IdGenerator idGenerator;\n\n\t@SuppressWarnings(\"serial\")\n\tprivate final Map<String, Object> headers;\n\n\n\t/**\n\t * Construct a {@link MessageHeaders} with the given headers. An {@link #ID} and\n\t * {@link #TIMESTAMP} headers will also be added, overriding any existing values.\n\t * @param headers a map with headers to add\n\t */\n\tpublic MessageHeaders(@Nullable Map<String, Object> headers) {\n\t\tthis(headers, null, null);\n\t}\n\n\t/**\n\t * Constructor providing control over the ID and TIMESTAMP header values.\n\t * @param headers a map with headers to add\n\t * @param id the {@link #ID} header value\n\t * @param timestamp the {@link #TIMESTAMP} header value\n\t */\n\tprotected MessageHeaders(@Nullable Map<String, Object> headers, @Nullable UUID id, @Nullable Long timestamp) {\n\t\tthis.headers = (headers != null ? new HashMap<>(headers) : new HashMap<>());\n\n\t\tif (id == null) {\n\t\t\tthis.headers.put(ID, getIdGenerator().generateId());\n\t\t}\n\t\telse if (id == ID_VALUE_NONE) {\n\t\t\tthis.headers.remove(ID);\n\t\t}\n\t\telse {\n\t\t\tthis.headers.put(ID, id);\n\t\t}\n\n\t\tif (timestamp == null) {\n\t\t\tthis.headers.put(TIMESTAMP, System.currentTimeMillis());\n\t\t}\n\t\telse if (timestamp < 0) {\n\t\t\tthis.headers.remove(TIMESTAMP);\n\t\t}\n\t\telse {\n\t\t\tthis.headers.put(TIMESTAMP, timestamp);\n\t\t}\n\t}\n\n\t/**\n\t * Copy constructor which allows for ignoring certain entries.\n\t * Used for serialization without non-serializable entries.\n\t * @param original the MessageHeaders to copy\n\t * @param keysToIgnore the keys of the entries to ignore\n\t */\n\tprivate MessageHeaders(MessageHeaders original, Set<String> keysToIgnore) {\n\t\tthis.headers = CollectionUtils.newHashMap(original.headers.size());\n\t\toriginal.headers.forEach((key, value) -> {\n\t\t\tif (!keysToIgnore.contains(key)) {\n\t\t\t\tthis.headers.put(key, value);\n\t\t\t}\n\t\t});\n\t}\n\n\n\tprotected Map<String, Object> getRawHeaders() {\n\t\treturn this.headers;\n\t}\n\n\tprotected static IdGenerator getIdGenerator() {\n\t\tIdGenerator generator = idGenerator;\n\t\treturn (generator != null ? generator : defaultIdGenerator);\n\t}\n\n\t@Nullable\n\tpublic UUID getId() {\n\t\treturn get(ID, UUID.class);\n\t}\n\n\t@Nullable\n\tpublic Long getTimestamp() {\n\t\treturn get(TIMESTAMP, Long.class);\n\t}\n\n\t@Nullable\n\tpublic Object getReplyChannel() {\n\t\treturn get(REPLY_CHANNEL);\n\t}\n\n\t@Nullable\n\tpublic Object getErrorChannel() {\n\t\treturn get(ERROR_CHANNEL);\n\t}\n\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Nullable\n\tpublic <T> T get(Object key, Class<T> type) {\n\t\tObject value = this.headers.get(key);\n\t\tif (value == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (!type.isAssignableFrom(value.getClass())) {\n\t\t\tthrow new IllegalArgumentException(\"Incorrect type specified for header '\" +\n\t\t\t\t\tkey + \"'. Expected [\" + type + \"] but actual type is [\" + value.getClass() + \"]\");\n\t\t}\n\t\treturn (T) value;\n\t}\n\n\n\t// Delegating Map implementation\n\n\t@Override\n\tpublic boolean containsKey(Object key) {\n\t\treturn this.headers.containsKey(key);\n\t}\n\n\t@Override\n\tpublic boolean containsValue(Object value) {\n\t\treturn this.headers.containsValue(value);\n\t}\n\n\t@Override\n\tpublic Set<Map.Entry<String, Object>> entrySet() {\n\t\treturn Collections.unmodifiableMap(this.headers).entrySet();\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Object get(Object key) {\n\t\treturn this.headers.get(key);\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn this.headers.isEmpty();\n\t}\n\n\t@Override\n\tpublic Set<String> keySet() {\n\t\treturn Collections.unmodifiableSet(this.headers.keySet());\n\t}\n\n\t@Override\n\tpublic int size() {\n\t\treturn this.headers.size();\n\t}\n\n\t@Override\n\tpublic Collection<Object> values() {\n\t\treturn Collections.unmodifiableCollection(this.headers.values());\n\t}\n\n\n\t// Unsupported Map operations\n\n\t/**\n\t * Since MessageHeaders are immutable, the call to this method\n\t * will result in {@link UnsupportedOperationException}.\n\t */\n\t@Override\n\tpublic Object put(String key, Object value) {\n\t\tthrow new UnsupportedOperationException(\"MessageHeaders is immutable\");\n\t}\n\n\t/**\n\t * Since MessageHeaders are immutable, the call to this method\n\t * will result in {@link UnsupportedOperationException}.\n\t */\n\t@Override\n\tpublic void putAll(Map<? extends String, ? extends Object> map) {\n\t\tthrow new UnsupportedOperationException(\"MessageHeaders is immutable\");\n\t}\n\n\t/**\n\t * Since MessageHeaders are immutable, the call to this method\n\t * will result in {@link UnsupportedOperationException}.\n\t */\n\t@Override\n\tpublic Object remove(Object key) {\n\t\tthrow new UnsupportedOperationException(\"MessageHeaders is immutable\");\n\t}\n\n\t/**\n\t * Since MessageHeaders are immutable, the call to this method\n\t * will result in {@link UnsupportedOperationException}.\n\t */\n\t@Override\n\tpublic void clear() {\n\t\tthrow new UnsupportedOperationException(\"MessageHeaders is immutable\");\n\t}\n\n\n\t// Serialization methods\n\n\tprivate void writeObject(ObjectOutputStream out) throws IOException {\n\t\tSet<String> keysToIgnore = new HashSet<>();\n\t\tthis.headers.forEach((key, value) -> {\n\t\t\tif (!(value instanceof Serializable)) {\n\t\t\t\tkeysToIgnore.add(key);\n\t\t\t}\n\t\t});\n\n\t\tif (keysToIgnore.isEmpty()) {\n\t\t\t// All entries are serializable -> serialize the regular MessageHeaders instance\n\t\t\tout.defaultWriteObject();\n\t\t}\n\t\telse {\n\t\t\t// Some non-serializable entries -> serialize a temporary MessageHeaders copy\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Ignoring non-serializable message headers: \" + keysToIgnore);\n\t\t\t}\n\t\t\tout.writeObject(new MessageHeaders(this, keysToIgnore));\n\t\t}\n\t}\n\n\tprivate void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n\t\tin.defaultReadObject();\n\t}\n\n\n\t// equals, hashCode, toString\n\n\t@Override\n\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof MessageHeaders that && this.headers.equals(that.headers)));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.headers.hashCode();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn this.headers.toString();\n\t}\n\n}"
  },
  "org.springframework.messaging.MessageHeaders#clear()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Since MessageHeaders are immutable, the call to this method\n\t * will result in {@link UnsupportedOperationException}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 300
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\tpublic void clear() {\n\t\tthrow new UnsupportedOperationException(\"MessageHeaders is immutable\");\n\t}"
  },
  "org.springframework.messaging.MessageHeaders#containsKey(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "boolean",
    "signature": "public boolean containsKey(Object key)",
    "source_code": "\tpublic boolean containsKey(Object key) {\n\t\treturn this.headers.containsKey(key);\n\t}"
  },
  "org.springframework.messaging.MessageHeaders#containsValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "boolean",
    "signature": "public boolean containsValue(Object value)",
    "source_code": "\tpublic boolean containsValue(Object value) {\n\t\treturn this.headers.containsValue(value);\n\t}"
  },
  "org.springframework.messaging.MessageHeaders#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 336
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof MessageHeaders that && this.headers.equals(that.headers)));\n\t}"
  },
  "org.springframework.messaging.MessageHeaders#get(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "Object",
    "signature": "public Object get(Object key)",
    "source_code": "\tpublic Object get(Object key) {\n\t\treturn this.headers.get(key);\n\t}"
  },
  "org.springframework.messaging.MessageHeaders#get(key,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "T",
    "signature": "public T get(Object key, Class<T> type)",
    "source_code": "\tpublic <T> T get(Object key, Class<T> type) {\n\t\tObject value = this.headers.get(key);\n\t\tif (value == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (!type.isAssignableFrom(value.getClass())) {\n\t\t\tthrow new IllegalArgumentException(\"Incorrect type specified for header '\" +\n\t\t\t\t\tkey + \"'. Expected [\" + type + \"] but actual type is [\" + value.getClass() + \"]\");\n\t\t}\n\t\treturn (T) value;\n\t}"
  },
  "org.springframework.messaging.MessageHeaders#getErrorChannel()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "Object",
    "signature": "public Object getErrorChannel()",
    "source_code": "\tpublic Object getErrorChannel() {\n\t\treturn get(ERROR_CHANNEL);\n\t}"
  },
  "org.springframework.messaging.MessageHeaders#getId()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "UUID",
    "signature": "public UUID getId()",
    "source_code": "\tpublic UUID getId() {\n\t\treturn get(ID, UUID.class);\n\t}"
  },
  "org.springframework.messaging.MessageHeaders#getIdGenerator()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "IdGenerator",
    "signature": "protected IdGenerator getIdGenerator()",
    "source_code": "\tprotected static IdGenerator getIdGenerator() {\n\t\tIdGenerator generator = idGenerator;\n\t\treturn (generator != null ? generator : defaultIdGenerator);\n\t}"
  },
  "org.springframework.messaging.MessageHeaders#getRawHeaders()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "Object>",
    "signature": "protected Object> getRawHeaders()",
    "source_code": "\tprotected Map<String, Object> getRawHeaders() {\n\t\treturn this.headers;\n\t}"
  },
  "org.springframework.messaging.MessageHeaders#getReplyChannel()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 197
    },
    "return": "Object",
    "signature": "public Object getReplyChannel()",
    "source_code": "\tpublic Object getReplyChannel() {\n\t\treturn get(REPLY_CHANNEL);\n\t}"
  },
  "org.springframework.messaging.MessageHeaders#getTimestamp()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "Long",
    "signature": "public Long getTimestamp()",
    "source_code": "\tpublic Long getTimestamp() {\n\t\treturn get(TIMESTAMP, Long.class);\n\t}"
  },
  "org.springframework.messaging.MessageHeaders#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.headers.hashCode();\n\t}"
  },
  "org.springframework.messaging.MessageHeaders#isEmpty()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "boolean",
    "signature": "public boolean isEmpty()",
    "source_code": "\tpublic boolean isEmpty() {\n\t\treturn this.headers.isEmpty();\n\t}"
  },
  "org.springframework.messaging.MessageHeaders#keySet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "Set<String>",
    "signature": "public Set<String> keySet()",
    "source_code": "\tpublic Set<String> keySet() {\n\t\treturn Collections.unmodifiableSet(this.headers.keySet());\n\t}"
  },
  "org.springframework.messaging.MessageHeaders#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Since MessageHeaders are immutable, the call to this method\n\t * will result in {@link UnsupportedOperationException}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "Object",
    "signature": "public Object put(String key, Object value)",
    "source_code": "\tpublic Object put(String key, Object value) {\n\t\tthrow new UnsupportedOperationException(\"MessageHeaders is immutable\");\n\t}"
  },
  "org.springframework.messaging.MessageHeaders#putAll(String,map)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Since MessageHeaders are immutable, the call to this method\n\t * will result in {@link UnsupportedOperationException}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends Object> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends Object> map) {\n\t\tthrow new UnsupportedOperationException(\"MessageHeaders is immutable\");\n\t}"
  },
  "org.springframework.messaging.MessageHeaders#remove(key)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Since MessageHeaders are immutable, the call to this method\n\t * will result in {@link UnsupportedOperationException}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "Object",
    "signature": "public Object remove(Object key)",
    "source_code": "\tpublic Object remove(Object key) {\n\t\tthrow new UnsupportedOperationException(\"MessageHeaders is immutable\");\n\t}"
  },
  "org.springframework.messaging.MessageHeaders#size()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "int",
    "signature": "public int size()",
    "source_code": "\tpublic int size() {\n\t\treturn this.headers.size();\n\t}"
  },
  "org.springframework.messaging.MessageHeaders#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 346
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn this.headers.toString();\n\t}"
  },
  "org.springframework.messaging.MessageHeaders#values()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "Collection<Object>",
    "signature": "public Collection<Object> values()",
    "source_code": "\tpublic Collection<Object> values() {\n\t\treturn Collections.unmodifiableCollection(this.headers.values());\n\t}"
  },
  "org.springframework.messaging.REPLY_CHANNEL": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The key for the message reply channel.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "signature": "public String REPLY_CHANNEL",
    "source_code": "\tpublic static final String REPLY_CHANNEL = \"replyChannel\";",
    "type": "String"
  },
  "org.springframework.messaging.TIMESTAMP": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The key for the message timestamp.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "signature": "public String TIMESTAMP",
    "source_code": "\tpublic static final String TIMESTAMP = \"timestamp\";",
    "type": "String"
  },
  "org.springframework.messaging.converter.AbstractJsonMessageConverter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Common base class for plain JSON converters, e.g. Gson and JSON-B.\n *\n * @author Juergen Hoeller\n * @since 5.3\n * @see GsonMessageConverter\n * @see JsonbMessageConverter\n * @see #fromJson(Reader, Type)\n * @see #fromJson(String, Type)\n * @see #toJson(Object, Type)\n * @see #toJson(Object, Type, Writer)\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public class AbstractJsonMessageConverter",
    "source_code": "public abstract class AbstractJsonMessageConverter extends AbstractMessageConverter {\n\n\tprivate static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;\n\n\n\tprotected AbstractJsonMessageConverter() {\n\t\tsuper(new MimeType(\"application\", \"json\"));\n\t}\n\n\n\t@Override\n\tprotected boolean supports(Class<?> clazz) {\n\t\treturn true;\n\t}\n\n\t@Override\n\t@Nullable\n\tprotected Object convertFromInternal(Message<?> message, Class<?> targetClass, @Nullable Object conversionHint) {\n\t\ttry {\n\t\t\tType resolvedType = getResolvedType(targetClass, conversionHint);\n\t\t\tObject payload = message.getPayload();\n\t\t\tif (ClassUtils.isAssignableValue(targetClass, payload)) {\n\t\t\t\treturn payload;\n\t\t\t}\n\t\t\telse if (payload instanceof byte[] bytes) {\n\t\t\t\treturn fromJson(getReader(bytes, message.getHeaders()), resolvedType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Assuming a text-based source payload\n\t\t\t\treturn fromJson(payload.toString(), resolvedType);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new MessageConversionException(message, \"Could not read JSON: \" + ex.getMessage(), ex);\n\t\t}\n\t}\n\n\t@Override\n\t@Nullable\n\tprotected Object convertToInternal(Object payload, @Nullable MessageHeaders headers, @Nullable Object conversionHint) {\n\t\ttry {\n\t\t\tType resolvedType = getResolvedType(payload.getClass(), conversionHint);\n\t\t\tif (byte[].class == getSerializedPayloadClass()) {\n\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream(1024);\n\t\t\t\tWriter writer = getWriter(out, headers);\n\t\t\t\ttoJson(payload, resolvedType, writer);\n\t\t\t\twriter.flush();\n\t\t\t\treturn out.toByteArray();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Assuming a text-based target payload\n\t\t\t\treturn toJson(payload, resolvedType);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new MessageConversionException(\"Could not write JSON: \" + ex.getMessage(), ex);\n\t\t}\n\t}\n\n\n\tprivate Reader getReader(byte[] payload, @Nullable MessageHeaders headers) {\n\t\tInputStream in = new ByteArrayInputStream(payload);\n\t\treturn new InputStreamReader(in, getCharsetToUse(headers));\n\t}\n\n\tprivate Writer getWriter(ByteArrayOutputStream out, @Nullable MessageHeaders headers) {\n\t\treturn new OutputStreamWriter(out, getCharsetToUse(headers));\n\t}\n\n\tprivate Charset getCharsetToUse(@Nullable MessageHeaders headers) {\n\t\tMimeType mimeType = getMimeType(headers);\n\t\treturn (mimeType != null && mimeType.getCharset() != null ? mimeType.getCharset() : DEFAULT_CHARSET);\n\t}\n\n\n\tprotected abstract Object fromJson(Reader reader, Type resolvedType);\n\n\tprotected abstract Object fromJson(String payload, Type resolvedType);\n\n\tprotected abstract void toJson(Object payload, Type resolvedType, Writer writer);\n\n\tprotected abstract String toJson(Object payload, Type resolvedType);\n\n}"
  },
  "org.springframework.messaging.converter.AbstractJsonMessageConverter#convertFromInternal(message,targetClass,conversionHint)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "targetClass",
      "conversionHint"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "Object",
    "signature": "protected Object convertFromInternal(Message<?> message, Class<?> targetClass, @Nullable Object conversionHint)",
    "source_code": "\tprotected Object convertFromInternal(Message<?> message, Class<?> targetClass, @Nullable Object conversionHint) {\n\t\ttry {\n\t\t\tType resolvedType = getResolvedType(targetClass, conversionHint);\n\t\t\tObject payload = message.getPayload();\n\t\t\tif (ClassUtils.isAssignableValue(targetClass, payload)) {\n\t\t\t\treturn payload;\n\t\t\t}\n\t\t\telse if (payload instanceof byte[] bytes) {\n\t\t\t\treturn fromJson(getReader(bytes, message.getHeaders()), resolvedType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Assuming a text-based source payload\n\t\t\t\treturn fromJson(payload.toString(), resolvedType);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new MessageConversionException(message, \"Could not read JSON: \" + ex.getMessage(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.converter.AbstractJsonMessageConverter#convertToInternal(payload,headers,conversionHint)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "payload",
      "headers",
      "conversionHint"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "Object",
    "signature": "protected Object convertToInternal(Object payload, @Nullable MessageHeaders headers, @Nullable Object conversionHint)",
    "source_code": "\tprotected Object convertToInternal(Object payload, @Nullable MessageHeaders headers, @Nullable Object conversionHint) {\n\t\ttry {\n\t\t\tType resolvedType = getResolvedType(payload.getClass(), conversionHint);\n\t\t\tif (byte[].class == getSerializedPayloadClass()) {\n\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream(1024);\n\t\t\t\tWriter writer = getWriter(out, headers);\n\t\t\t\ttoJson(payload, resolvedType, writer);\n\t\t\t\twriter.flush();\n\t\t\t\treturn out.toByteArray();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Assuming a text-based target payload\n\t\t\t\treturn toJson(payload, resolvedType);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new MessageConversionException(\"Could not write JSON: \" + ex.getMessage(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.converter.AbstractJsonMessageConverter#fromJson(payload,resolvedType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "payload",
      "resolvedType"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "Object",
    "signature": "protected Object fromJson(String payload, Type resolvedType)",
    "source_code": "\tprotected abstract Object fromJson(String payload, Type resolvedType);"
  },
  "org.springframework.messaging.converter.AbstractJsonMessageConverter#fromJson(reader,resolvedType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "reader",
      "resolvedType"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "Object",
    "signature": "protected Object fromJson(Reader reader, Type resolvedType)",
    "source_code": "\tprotected abstract Object fromJson(Reader reader, Type resolvedType);"
  },
  "org.springframework.messaging.converter.AbstractJsonMessageConverter#supports(clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "boolean",
    "signature": "protected boolean supports(Class<?> clazz)",
    "source_code": "\tprotected boolean supports(Class<?> clazz) {\n\t\treturn true;\n\t}"
  },
  "org.springframework.messaging.converter.AbstractJsonMessageConverter#toJson(payload,resolvedType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "payload",
      "resolvedType"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "String",
    "signature": "protected String toJson(Object payload, Type resolvedType)",
    "source_code": "\tprotected abstract String toJson(Object payload, Type resolvedType);"
  },
  "org.springframework.messaging.converter.AbstractJsonMessageConverter#toJson(payload,resolvedType,writer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "payload",
      "resolvedType",
      "writer"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "protected void toJson(Object payload, Type resolvedType, Writer writer)",
    "source_code": "\tprotected abstract void toJson(Object payload, Type resolvedType, Writer writer);"
  },
  "org.springframework.messaging.converter.CompositeMessageConverter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A {@link MessageConverter} that delegates to a list of registered converters\n * to be invoked until one of them returns a non-null result.\n *\n * <p>As of 4.2.1, this composite converter implements {@link SmartMessageConverter}\n * in order to support the delegation of conversion hints.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class CompositeMessageConverter",
    "source_code": "public class CompositeMessageConverter implements SmartMessageConverter {\n\n\tprivate final List<MessageConverter> converters;\n\n\n\t/**\n\t * Create an instance with the given converters.\n\t */\n\tpublic CompositeMessageConverter(Collection<MessageConverter> converters) {\n\t\tAssert.notEmpty(converters, \"Converters must not be empty\");\n\t\tthis.converters = new ArrayList<>(converters);\n\t}\n\n\n\t@Override\n\t@Nullable\n\tpublic Object fromMessage(Message<?> message, Class<?> targetClass) {\n\t\tfor (MessageConverter converter : getConverters()) {\n\t\t\tObject result = converter.fromMessage(message, targetClass);\n\t\t\tif (result != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Object fromMessage(Message<?> message, Class<?> targetClass, @Nullable Object conversionHint) {\n\t\tfor (MessageConverter converter : getConverters()) {\n\t\t\tObject result = (converter instanceof SmartMessageConverter smartMessageConverter ?\n\t\t\t\t\tsmartMessageConverter.fromMessage(message, targetClass, conversionHint) :\n\t\t\t\t\tconverter.fromMessage(message, targetClass));\n\t\t\tif (result != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Message<?> toMessage(Object payload, @Nullable MessageHeaders headers) {\n\t\tfor (MessageConverter converter : getConverters()) {\n\t\t\tMessage<?> result = converter.toMessage(payload, headers);\n\t\t\tif (result != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Message<?> toMessage(Object payload, @Nullable MessageHeaders headers, @Nullable Object conversionHint) {\n\t\tfor (MessageConverter converter : getConverters()) {\n\t\t\tMessage<?> result = (converter instanceof SmartMessageConverter smartMessageConverter ?\n\t\t\t\t\tsmartMessageConverter.toMessage(payload, headers, conversionHint) :\n\t\t\t\t\tconverter.toMessage(payload, headers));\n\t\t\tif (result != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\n\t/**\n\t * Return the underlying list of delegate converters.\n\t */\n\tpublic List<MessageConverter> getConverters() {\n\t\treturn this.converters;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"CompositeMessageConverter[converters=\" + getConverters() + \"]\";\n\t}\n\n}"
  },
  "org.springframework.messaging.converter.CompositeMessageConverter#fromMessage(message,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "return": "Object",
    "signature": "public Object fromMessage(Message<?> message, Class<?> targetClass)",
    "source_code": "\tpublic Object fromMessage(Message<?> message, Class<?> targetClass) {\n\t\tfor (MessageConverter converter : getConverters()) {\n\t\t\tObject result = converter.fromMessage(message, targetClass);\n\t\t\tif (result != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.messaging.converter.CompositeMessageConverter#fromMessage(message,targetClass,conversionHint)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "targetClass",
      "conversionHint"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "Object",
    "signature": "public Object fromMessage(Message<?> message, Class<?> targetClass, @Nullable Object conversionHint)",
    "source_code": "\tpublic Object fromMessage(Message<?> message, Class<?> targetClass, @Nullable Object conversionHint) {\n\t\tfor (MessageConverter converter : getConverters()) {\n\t\t\tObject result = (converter instanceof SmartMessageConverter smartMessageConverter ?\n\t\t\t\t\tsmartMessageConverter.fromMessage(message, targetClass, conversionHint) :\n\t\t\t\t\tconverter.fromMessage(message, targetClass));\n\t\t\tif (result != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.messaging.converter.CompositeMessageConverter#getConverters()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the underlying list of delegate converters.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "List<MessageConverter>",
    "signature": "public List<MessageConverter> getConverters()",
    "source_code": "\tpublic List<MessageConverter> getConverters() {\n\t\treturn this.converters;\n\t}"
  },
  "org.springframework.messaging.converter.CompositeMessageConverter#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn \"CompositeMessageConverter[converters=\" + getConverters() + \"]\";\n\t}"
  },
  "org.springframework.messaging.converter.DefaultContentTypeResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A default {@link ContentTypeResolver} that checks the\n * {@link MessageHeaders#CONTENT_TYPE} header or falls back to a default value.\n *\n * <p>The header value is expected to be a {@link org.springframework.util.MimeType}\n * or a {@code String} that can be parsed into a {@code MimeType}.\n *\n * @author Rossen Stoyanchev\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 33
    },
    "signature": "public class DefaultContentTypeResolver",
    "source_code": "public class DefaultContentTypeResolver implements ContentTypeResolver {\n\n\t@Nullable\n\tprivate MimeType defaultMimeType;\n\n\n\t/**\n\t * Set the default MIME type to use when there is no\n\t * {@link MessageHeaders#CONTENT_TYPE} header present.\n\t * <p>This property does not have a default value.\n\t */\n\tpublic void setDefaultMimeType(@Nullable MimeType defaultMimeType) {\n\t\tthis.defaultMimeType = defaultMimeType;\n\t}\n\n\t/**\n\t * Return the default MIME type to use if no\n\t * {@link MessageHeaders#CONTENT_TYPE} header is present.\n\t */\n\t@Nullable\n\tpublic MimeType getDefaultMimeType() {\n\t\treturn this.defaultMimeType;\n\t}\n\n\n\t@Override\n\t@Nullable\n\tpublic MimeType resolve(@Nullable MessageHeaders headers) {\n\t\tif (headers == null || headers.get(MessageHeaders.CONTENT_TYPE) == null) {\n\t\t\treturn this.defaultMimeType;\n\t\t}\n\t\tObject value = headers.get(MessageHeaders.CONTENT_TYPE);\n\t\tif (value == null) {\n\t\t\treturn null;\n\t\t}\n\t\telse if (value instanceof MimeType mimeType) {\n\t\t\treturn mimeType;\n\t\t}\n\t\telse if (value instanceof String text) {\n\t\t\treturn MimeType.valueOf(text);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Unknown type for contentType header value: \" + value.getClass());\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"DefaultContentTypeResolver[\" + \"defaultMimeType=\" + this.defaultMimeType + \"]\";\n\t}\n\n}"
  },
  "org.springframework.messaging.converter.DefaultContentTypeResolver#getDefaultMimeType()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the default MIME type to use if no\n\t * {@link MessageHeaders#CONTENT_TYPE} header is present.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 53
    },
    "return": "MimeType",
    "signature": "public MimeType getDefaultMimeType()",
    "source_code": "\tpublic MimeType getDefaultMimeType() {\n\t\treturn this.defaultMimeType;\n\t}"
  },
  "org.springframework.messaging.converter.DefaultContentTypeResolver#resolve(headers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "MimeType",
    "signature": "public MimeType resolve(@Nullable MessageHeaders headers)",
    "source_code": "\tpublic MimeType resolve(@Nullable MessageHeaders headers) {\n\t\tif (headers == null || headers.get(MessageHeaders.CONTENT_TYPE) == null) {\n\t\t\treturn this.defaultMimeType;\n\t\t}\n\t\tObject value = headers.get(MessageHeaders.CONTENT_TYPE);\n\t\tif (value == null) {\n\t\t\treturn null;\n\t\t}\n\t\telse if (value instanceof MimeType mimeType) {\n\t\t\treturn mimeType;\n\t\t}\n\t\telse if (value instanceof String text) {\n\t\t\treturn MimeType.valueOf(text);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Unknown type for contentType header value: \" + value.getClass());\n\t\t}\n\t}"
  },
  "org.springframework.messaging.converter.DefaultContentTypeResolver#setDefaultMimeType(defaultMimeType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the default MIME type to use when there is no\n\t * {@link MessageHeaders#CONTENT_TYPE} header present.\n\t * <p>This property does not have a default value.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultMimeType"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "return": "void",
    "signature": "public void setDefaultMimeType(@Nullable MimeType defaultMimeType)",
    "source_code": "\tpublic void setDefaultMimeType(@Nullable MimeType defaultMimeType) {\n\t\tthis.defaultMimeType = defaultMimeType;\n\t}"
  },
  "org.springframework.messaging.converter.DefaultContentTypeResolver#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn \"DefaultContentTypeResolver[\" + \"defaultMimeType=\" + this.defaultMimeType + \"]\";\n\t}"
  },
  "org.springframework.messaging.converter.MarshallingMessageConverter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Implementation of {@link MessageConverter} that can read and write XML using Spring's\n * {@link Marshaller} and {@link Unmarshaller} abstractions.\n *\n * <p>This converter requires a {@code Marshaller} and {@code Unmarshaller} before it can\n * be used. These can be injected by the {@linkplain #MarshallingMessageConverter(Marshaller)\n * constructor} or {@linkplain #setMarshaller(Marshaller) bean properties}.\n *\n * @author Arjen Poutsma\n * @since 4.2\n * @see Marshaller\n * @see Unmarshaller\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "signature": "public class MarshallingMessageConverter",
    "source_code": "public class MarshallingMessageConverter extends AbstractMessageConverter {\n\n\t@Nullable\n\tprivate Marshaller marshaller;\n\n\t@Nullable\n\tprivate Unmarshaller unmarshaller;\n\n\n\t/**\n\t * Default construct allowing for {@link #setMarshaller(Marshaller)} and/or\n\t * {@link #setUnmarshaller(Unmarshaller)} to be invoked separately.\n\t */\n\tpublic MarshallingMessageConverter() {\n\t\tthis(new MimeType(\"application\", \"xml\"), new MimeType(\"text\", \"xml\"),\n\t\t\t\tnew MimeType(\"application\", \"*+xml\"));\n\t}\n\n\t/**\n\t * Constructor with a given list of MIME types to support.\n\t * @param supportedMimeTypes the MIME types\n\t */\n\tpublic MarshallingMessageConverter(MimeType... supportedMimeTypes) {\n\t\tsuper(supportedMimeTypes);\n\t}\n\n\t/**\n\t * Constructor with {@link Marshaller}. If the given {@link Marshaller} also\n\t * implements {@link Unmarshaller}, it is also used for unmarshalling.\n\t * <p>Note that all {@code Marshaller} implementations in Spring also implement\n\t * {@code Unmarshaller} so that you can safely use this constructor.\n\t * @param marshaller object used as marshaller and unmarshaller\n\t */\n\tpublic MarshallingMessageConverter(Marshaller marshaller) {\n\t\tthis();\n\t\tAssert.notNull(marshaller, \"Marshaller must not be null\");\n\t\tthis.marshaller = marshaller;\n\t\tif (marshaller instanceof Unmarshaller _unmarshaller) {\n\t\t\tthis.unmarshaller = _unmarshaller;\n\t\t}\n\t}\n\n\n\t/**\n\t * Set the {@link Marshaller} to be used by this message converter.\n\t */\n\tpublic void setMarshaller(@Nullable Marshaller marshaller) {\n\t\tthis.marshaller = marshaller;\n\t}\n\n\t/**\n\t * Return the configured Marshaller.\n\t */\n\t@Nullable\n\tpublic Marshaller getMarshaller() {\n\t\treturn this.marshaller;\n\t}\n\n\t/**\n\t * Set the {@link Unmarshaller} to be used by this message converter.\n\t */\n\tpublic void setUnmarshaller(@Nullable Unmarshaller unmarshaller) {\n\t\tthis.unmarshaller = unmarshaller;\n\t}\n\n\t/**\n\t * Return the configured unmarshaller.\n\t */\n\t@Nullable\n\tpublic Unmarshaller getUnmarshaller() {\n\t\treturn this.unmarshaller;\n\t}\n\n\n\t@Override\n\tprotected boolean canConvertFrom(Message<?> message, Class<?> targetClass) {\n\t\treturn (supportsMimeType(message.getHeaders()) && this.unmarshaller != null &&\n\t\t\t\tthis.unmarshaller.supports(targetClass));\n\t}\n\n\t@Override\n\tprotected boolean canConvertTo(Object payload, @Nullable MessageHeaders headers) {\n\t\treturn (supportsMimeType(headers) && this.marshaller != null &&\n\t\t\t\tthis.marshaller.supports(payload.getClass()));\n\t}\n\n\t@Override\n\tprotected boolean supports(Class<?> clazz) {\n\t\t// should not be called, since we override canConvertFrom/canConvertTo instead\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\t@Nullable\n\tprotected Object convertFromInternal(Message<?> message, Class<?> targetClass, @Nullable Object conversionHint) {\n\t\tAssert.state(this.unmarshaller != null, \"Property 'unmarshaller' is required\");\n\t\ttry {\n\t\t\tSource source = getSource(message.getPayload());\n\t\t\tObject result = this.unmarshaller.unmarshal(source);\n\t\t\tif (!targetClass.isInstance(result)) {\n\t\t\t\tthrow new TypeMismatchException(result, targetClass);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new MessageConversionException(message, \"Could not unmarshal XML: \" + ex.getMessage(), ex);\n\t\t}\n\t}\n\n\tprivate Source getSource(Object payload) {\n\t\tif (payload instanceof byte[] bytes) {\n\t\t\treturn new StreamSource(new ByteArrayInputStream(bytes));\n\t\t}\n\t\telse {\n\t\t\treturn new StreamSource(new StringReader(payload.toString()));\n\t\t}\n\t}\n\n\t@Override\n\t@Nullable\n\tprotected Object convertToInternal(Object payload, @Nullable MessageHeaders headers,\n\t\t\t@Nullable Object conversionHint) {\n\n\t\tAssert.state(this.marshaller != null, \"Property 'marshaller' is required\");\n\t\ttry {\n\t\t\tif (byte[].class == getSerializedPayloadClass()) {\n\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream(1024);\n\t\t\t\tResult result = new StreamResult(out);\n\t\t\t\tthis.marshaller.marshal(payload, result);\n\t\t\t\tpayload = out.toByteArray();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tWriter writer = new StringWriter(1024);\n\t\t\t\tResult result = new StreamResult(writer);\n\t\t\t\tthis.marshaller.marshal(payload, result);\n\t\t\t\tpayload = writer.toString();\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new MessageConversionException(\"Could not marshal XML: \" + ex.getMessage(), ex);\n\t\t}\n\t\treturn payload;\n\t}\n\n}"
  },
  "org.springframework.messaging.converter.MarshallingMessageConverter#canConvertFrom(message,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "boolean",
    "signature": "protected boolean canConvertFrom(Message<?> message, Class<?> targetClass)",
    "source_code": "\tprotected boolean canConvertFrom(Message<?> message, Class<?> targetClass) {\n\t\treturn (supportsMimeType(message.getHeaders()) && this.unmarshaller != null &&\n\t\t\t\tthis.unmarshaller.supports(targetClass));\n\t}"
  },
  "org.springframework.messaging.converter.MarshallingMessageConverter#canConvertTo(payload,headers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "payload",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "boolean",
    "signature": "protected boolean canConvertTo(Object payload, @Nullable MessageHeaders headers)",
    "source_code": "\tprotected boolean canConvertTo(Object payload, @Nullable MessageHeaders headers) {\n\t\treturn (supportsMimeType(headers) && this.marshaller != null &&\n\t\t\t\tthis.marshaller.supports(payload.getClass()));\n\t}"
  },
  "org.springframework.messaging.converter.MarshallingMessageConverter#convertFromInternal(message,targetClass,conversionHint)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "targetClass",
      "conversionHint"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "Object",
    "signature": "protected Object convertFromInternal(Message<?> message, Class<?> targetClass, @Nullable Object conversionHint)",
    "source_code": "\tprotected Object convertFromInternal(Message<?> message, Class<?> targetClass, @Nullable Object conversionHint) {\n\t\tAssert.state(this.unmarshaller != null, \"Property 'unmarshaller' is required\");\n\t\ttry {\n\t\t\tSource source = getSource(message.getPayload());\n\t\t\tObject result = this.unmarshaller.unmarshal(source);\n\t\t\tif (!targetClass.isInstance(result)) {\n\t\t\t\tthrow new TypeMismatchException(result, targetClass);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new MessageConversionException(message, \"Could not unmarshal XML: \" + ex.getMessage(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.converter.MarshallingMessageConverter#convertToInternal(payload,headers,conversionHint)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "payload",
      "headers",
      "conversionHint"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "Object",
    "signature": "protected Object convertToInternal(Object payload, @Nullable MessageHeaders headers,\n\t\t\t@Nullable Object conversionHint)",
    "source_code": "\tprotected Object convertToInternal(Object payload, @Nullable MessageHeaders headers,"
  },
  "org.springframework.messaging.converter.MarshallingMessageConverter#getMarshaller()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured Marshaller.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "Marshaller",
    "signature": "public Marshaller getMarshaller()",
    "source_code": "\tpublic Marshaller getMarshaller() {\n\t\treturn this.marshaller;\n\t}"
  },
  "org.springframework.messaging.converter.MarshallingMessageConverter#getUnmarshaller()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured unmarshaller.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "Unmarshaller",
    "signature": "public Unmarshaller getUnmarshaller()",
    "source_code": "\tpublic Unmarshaller getUnmarshaller() {\n\t\treturn this.unmarshaller;\n\t}"
  },
  "org.springframework.messaging.converter.MarshallingMessageConverter#setMarshaller(marshaller)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link Marshaller} to be used by this message converter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "marshaller"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void setMarshaller(@Nullable Marshaller marshaller)",
    "source_code": "\tpublic void setMarshaller(@Nullable Marshaller marshaller) {\n\t\tthis.marshaller = marshaller;\n\t}"
  },
  "org.springframework.messaging.converter.MarshallingMessageConverter#setUnmarshaller(unmarshaller)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link Unmarshaller} to be used by this message converter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "unmarshaller"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "void",
    "signature": "public void setUnmarshaller(@Nullable Unmarshaller unmarshaller)",
    "source_code": "\tpublic void setUnmarshaller(@Nullable Unmarshaller unmarshaller) {\n\t\tthis.unmarshaller = unmarshaller;\n\t}"
  },
  "org.springframework.messaging.converter.MarshallingMessageConverter#supports(clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "boolean",
    "signature": "protected boolean supports(Class<?> clazz)",
    "source_code": "\tprotected boolean supports(Class<?> clazz) {\n\t\t// should not be called, since we override canConvertFrom/canConvertTo instead\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.messaging.core.AbstractMessageSendingTemplate": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract base class for implementations of {@link MessageSendingOperations}.\n *\n * @author Mark Fisher\n * @author Rossen Stoyanchev\n * @author Stephane Nicoll\n * @since 4.0\n * @param <D> the destination type\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "signature": "public class AbstractMessageSendingTemplate",
    "source_code": "public abstract class AbstractMessageSendingTemplate<D> implements MessageSendingOperations<D> {\n\n\t/**\n\t * Name of the header that can be set to provide further information\n\t * (e.g. a {@code MethodParameter} instance) about the origin of the\n\t * payload, to be taken into account as a conversion hint.\n\t * @since 4.2\n\t */\n\tpublic static final String CONVERSION_HINT_HEADER = \"conversionHint\";\n\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\t@Nullable\n\tprivate D defaultDestination;\n\n\tprivate MessageConverter converter = new SimpleMessageConverter();\n\n\n\t/**\n\t * Configure the default destination to use in send methods that don't have\n\t * a destination argument. If a default destination is not configured, send methods\n\t * without a destination argument will raise an exception if invoked.\n\t */\n\tpublic void setDefaultDestination(@Nullable D defaultDestination) {\n\t\tthis.defaultDestination = defaultDestination;\n\t}\n\n\t/**\n\t * Return the configured default destination.\n\t */\n\t@Nullable\n\tpublic D getDefaultDestination() {\n\t\treturn this.defaultDestination;\n\t}\n\n\t/**\n\t * Set the {@link MessageConverter} to use in {@code convertAndSend} methods.\n\t * <p>By default, {@link SimpleMessageConverter} is used.\n\t * @param messageConverter the message converter to use\n\t */\n\tpublic void setMessageConverter(MessageConverter messageConverter) {\n\t\tAssert.notNull(messageConverter, \"MessageConverter must not be null\");\n\t\tthis.converter = messageConverter;\n\t}\n\n\t/**\n\t * Return the configured {@link MessageConverter}.\n\t */\n\tpublic MessageConverter getMessageConverter() {\n\t\treturn this.converter;\n\t}\n\n\n\t@Override\n\tpublic void send(Message<?> message) {\n\t\tsend(getRequiredDefaultDestination(), message);\n\t}\n\n\tprotected final D getRequiredDefaultDestination() {\n\t\tAssert.state(this.defaultDestination != null, \"No 'defaultDestination' configured\");\n\t\treturn this.defaultDestination;\n\t}\n\n\t@Override\n\tpublic void send(D destination, Message<?> message) {\n\t\tdoSend(destination, message);\n\t}\n\n\tprotected abstract void doSend(D destination, Message<?> message);\n\n\n\t@Override\n\tpublic void convertAndSend(Object payload) throws MessagingException {\n\t\tconvertAndSend(payload, null);\n\t}\n\n\t@Override\n\tpublic void convertAndSend(D destination, Object payload) throws MessagingException {\n\t\tconvertAndSend(destination, payload, (Map<String, Object>) null);\n\t}\n\n\t@Override\n\tpublic void convertAndSend(D destination, Object payload, @Nullable Map<String, Object> headers)\n\t\t\tthrows MessagingException {\n\n\t\tconvertAndSend(destination, payload, headers, null);\n\t}\n\n\t@Override\n\tpublic void convertAndSend(Object payload, @Nullable MessagePostProcessor postProcessor)\n\t\t\tthrows MessagingException {\n\n\t\tconvertAndSend(getRequiredDefaultDestination(), payload, postProcessor);\n\t}\n\n\t@Override\n\tpublic void convertAndSend(D destination, Object payload, @Nullable MessagePostProcessor postProcessor)\n\t\t\tthrows MessagingException {\n\n\t\tconvertAndSend(destination, payload, null, postProcessor);\n\t}\n\n\t@Override\n\tpublic void convertAndSend(D destination, Object payload, @Nullable Map<String, Object> headers,\n\t\t\t@Nullable MessagePostProcessor postProcessor) throws MessagingException {\n\n\t\tMessage<?> message = doConvert(payload, headers, postProcessor);\n\t\tsend(destination, message);\n\t}\n\n\t/**\n\t * Convert the given Object to serialized form, possibly using a\n\t * {@link MessageConverter}, wrap it as a message with the given\n\t * headers and apply the given post processor.\n\t * @param payload the Object to use as payload\n\t * @param headers the headers for the message to send\n\t * @param postProcessor the post processor to apply to the message\n\t * @return the converted message\n\t */\n\tprotected Message<?> doConvert(Object payload, @Nullable Map<String, Object> headers,\n\t\t\t@Nullable MessagePostProcessor postProcessor) {\n\n\t\tMessageHeaders messageHeaders = null;\n\t\tObject conversionHint = (headers != null ? headers.get(CONVERSION_HINT_HEADER) : null);\n\n\t\tMap<String, Object> headersToUse = processHeadersToSend(headers);\n\t\tif (headersToUse != null) {\n\t\t\tmessageHeaders = (headersToUse instanceof MessageHeaders _messageHeaders ?\n\t\t\t\t\t_messageHeaders : new MessageHeaders(headersToUse));\n\t\t}\n\n\t\tMessageConverter converter = getMessageConverter();\n\t\tMessage<?> message = (converter instanceof SmartMessageConverter smartMessageConverter ?\n\t\t\t\tsmartMessageConverter.toMessage(payload, messageHeaders, conversionHint) :\n\t\t\t\tconverter.toMessage(payload, messageHeaders));\n\t\tif (message == null) {\n\t\t\tString payloadType = payload.getClass().getName();\n\t\t\tObject contentType = (messageHeaders != null ? messageHeaders.get(MessageHeaders.CONTENT_TYPE) : null);\n\t\t\tthrow new MessageConversionException(\"Unable to convert payload with type='\" + payloadType +\n\t\t\t\t\t\"', contentType='\" + contentType + \"', converter=[\" + getMessageConverter() + \"]\");\n\t\t}\n\t\tif (postProcessor != null) {\n\t\t\tmessage = postProcessor.postProcessMessage(message);\n\t\t}\n\t\treturn message;\n\t}\n\n\t/**\n\t * Provides access to the map of input headers before a send operation.\n\t * Subclasses can modify the headers and then return the same or a different map.\n\t * <p>This default implementation in this class returns the input map.\n\t * @param headers the headers to send (or {@code null} if none)\n\t * @return the actual headers to send (or {@code null} if none)\n\t */\n\t@Nullable\n\tprotected Map<String, Object> processHeadersToSend(@Nullable Map<String, Object> headers) {\n\t\treturn headers;\n\t}\n\n}"
  },
  "org.springframework.messaging.core.AbstractMessageSendingTemplate#convertAndSend(destination,payload)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "payload"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "void",
    "signature": "public void convertAndSend(D destination, Object payload)",
    "source_code": "\tpublic void convertAndSend(D destination, Object payload) throws MessagingException {\n\t\tconvertAndSend(destination, payload, (Map<String, Object>) null);\n\t}"
  },
  "org.springframework.messaging.core.AbstractMessageSendingTemplate#convertAndSend(destination,payload,Map<String,headers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "payload",
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void convertAndSend(D destination, Object payload, @Nullable Map<String, Object> headers)",
    "source_code": "\tpublic void convertAndSend(D destination, Object payload, @Nullable Map<String, Object> headers)"
  },
  "org.springframework.messaging.core.AbstractMessageSendingTemplate#convertAndSend(destination,payload,Map<String,headers,postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "payload",
      "Map<String",
      "headers",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "void",
    "signature": "public void convertAndSend(D destination, Object payload, @Nullable Map<String, Object> headers,\n\t\t\t@Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend(D destination, Object payload, @Nullable Map<String, Object> headers,"
  },
  "org.springframework.messaging.core.AbstractMessageSendingTemplate#convertAndSend(destination,payload,postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "payload",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "void",
    "signature": "public void convertAndSend(D destination, Object payload, @Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend(D destination, Object payload, @Nullable MessagePostProcessor postProcessor)"
  },
  "org.springframework.messaging.core.AbstractMessageSendingTemplate#convertAndSend(payload)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "payload"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "void",
    "signature": "public void convertAndSend(Object payload)",
    "source_code": "\tpublic void convertAndSend(Object payload) throws MessagingException {\n\t\tconvertAndSend(payload, null);\n\t}"
  },
  "org.springframework.messaging.core.AbstractMessageSendingTemplate#convertAndSend(payload,postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "payload",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "void",
    "signature": "public void convertAndSend(Object payload, @Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend(Object payload, @Nullable MessagePostProcessor postProcessor)"
  },
  "org.springframework.messaging.core.AbstractMessageSendingTemplate#doSend(destination,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "destination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "protected void doSend(D destination, Message<?> message)",
    "source_code": "\tprotected abstract void doSend(D destination, Message<?> message);"
  },
  "org.springframework.messaging.core.AbstractMessageSendingTemplate#getDefaultDestination()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured default destination.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "D",
    "signature": "public D getDefaultDestination()",
    "source_code": "\tpublic D getDefaultDestination() {\n\t\treturn this.defaultDestination;\n\t}"
  },
  "org.springframework.messaging.core.AbstractMessageSendingTemplate#getMessageConverter()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured {@link MessageConverter}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "MessageConverter",
    "signature": "public MessageConverter getMessageConverter()",
    "source_code": "\tpublic MessageConverter getMessageConverter() {\n\t\treturn this.converter;\n\t}"
  },
  "org.springframework.messaging.core.AbstractMessageSendingTemplate#getRequiredDefaultDestination()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "D",
    "signature": "protected D getRequiredDefaultDestination()",
    "source_code": "\tprotected final D getRequiredDefaultDestination() {\n\t\tAssert.state(this.defaultDestination != null, \"No 'defaultDestination' configured\");\n\t\treturn this.defaultDestination;\n\t}"
  },
  "org.springframework.messaging.core.AbstractMessageSendingTemplate#processHeadersToSend(Map<String,headers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Provides access to the map of input headers before a send operation.\n\t * Subclasses can modify the headers and then return the same or a different map.\n\t * <p>This default implementation in this class returns the input map.\n\t * @param headers the headers to send (or {@code null} if none)\n\t * @return the actual headers to send (or {@code null} if none)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "Object>",
    "signature": "protected Object> processHeadersToSend(@Nullable Map<String, Object> headers)",
    "source_code": "\tprotected Map<String, Object> processHeadersToSend(@Nullable Map<String, Object> headers) {\n\t\treturn headers;\n\t}"
  },
  "org.springframework.messaging.core.AbstractMessageSendingTemplate#send(destination,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "void",
    "signature": "public void send(D destination, Message<?> message)",
    "source_code": "\tpublic void send(D destination, Message<?> message) {\n\t\tdoSend(destination, message);\n\t}"
  },
  "org.springframework.messaging.core.AbstractMessageSendingTemplate#send(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void send(Message<?> message)",
    "source_code": "\tpublic void send(Message<?> message) {\n\t\tsend(getRequiredDefaultDestination(), message);\n\t}"
  },
  "org.springframework.messaging.core.AbstractMessageSendingTemplate#setDefaultDestination(defaultDestination)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the default destination to use in send methods that don't have\n\t * a destination argument. If a default destination is not configured, send methods\n\t * without a destination argument will raise an exception if invoked.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultDestination"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "void",
    "signature": "public void setDefaultDestination(@Nullable D defaultDestination)",
    "source_code": "\tpublic void setDefaultDestination(@Nullable D defaultDestination) {\n\t\tthis.defaultDestination = defaultDestination;\n\t}"
  },
  "org.springframework.messaging.core.AbstractMessageSendingTemplate#setMessageConverter(messageConverter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link MessageConverter} to use in {@code convertAndSend} methods.\n\t * <p>By default, {@link SimpleMessageConverter} is used.\n\t * @param messageConverter the message converter to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageConverter"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "void",
    "signature": "public void setMessageConverter(MessageConverter messageConverter)",
    "source_code": "\tpublic void setMessageConverter(MessageConverter messageConverter) {\n\t\tAssert.notNull(messageConverter, \"MessageConverter must not be null\");\n\t\tthis.converter = messageConverter;\n\t}"
  },
  "org.springframework.messaging.core.CONVERSION_HINT_HEADER": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Name of the header that can be set to provide further information\n\t * (e.g. a {@code MethodParameter} instance) about the origin of the\n\t * payload, to be taken into account as a conversion hint.\n\t * @since 4.2\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "public String CONVERSION_HINT_HEADER",
    "source_code": "\tpublic static final String CONVERSION_HINT_HEADER = \"conversionHint\";",
    "type": "String"
  },
  "org.springframework.messaging.core.DEFAULT_RECEIVE_TIMEOUT_HEADER": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The default header key used for a receive timeout.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "signature": "public String DEFAULT_RECEIVE_TIMEOUT_HEADER",
    "source_code": "\tpublic static final String DEFAULT_RECEIVE_TIMEOUT_HEADER = \"receiveTimeout\";",
    "type": "String"
  },
  "org.springframework.messaging.core.DEFAULT_SEND_TIMEOUT_HEADER": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The default header key used for a send timeout.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "signature": "public String DEFAULT_SEND_TIMEOUT_HEADER",
    "source_code": "\tpublic static final String DEFAULT_SEND_TIMEOUT_HEADER = \"sendTimeout\";",
    "type": "String"
  },
  "org.springframework.messaging.core.GenericMessagingTemplate": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A messaging template that resolves destinations names to {@link MessageChannel}'s\n * to send and receive messages from.\n *\n * @author Mark Fisher\n * @author Rossen Stoyanchev\n * @author Gary Russell\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "signature": "public class GenericMessagingTemplate",
    "source_code": "public class GenericMessagingTemplate extends AbstractDestinationResolvingMessagingTemplate<MessageChannel>"
  },
  "org.springframework.messaging.core.GenericMessagingTemplate#doSend(channel,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "channel",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "void",
    "signature": "protected void doSend(MessageChannel channel, Message<?> message)",
    "source_code": "\tprotected final void doSend(MessageChannel channel, Message<?> message) {\n\t\tdoSend(channel, message, sendTimeout(message));\n\t}"
  },
  "org.springframework.messaging.core.GenericMessagingTemplate#doSend(channel,message,timeout)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "channel",
      "message",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "void",
    "signature": "protected void doSend(MessageChannel channel, Message<?> message, long timeout)",
    "source_code": "\tprotected final void doSend(MessageChannel channel, Message<?> message, long timeout) {\n\t\tAssert.notNull(channel, \"MessageChannel is required\");\n\n\t\tMessage<?> messageToSend = message;\n\t\tMessageHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, MessageHeaderAccessor.class);\n\t\tif (accessor != null && accessor.isMutable()) {\n\t\t\taccessor.removeHeader(this.sendTimeoutHeader);\n\t\t\taccessor.removeHeader(this.receiveTimeoutHeader);\n\t\t\taccessor.setImmutable();\n\t\t}\n\t\telse if (message.getHeaders().containsKey(this.sendTimeoutHeader)\n\t\t\t\t|| message.getHeaders().containsKey(this.receiveTimeoutHeader)) {\n\t\t\tmessageToSend = MessageBuilder.fromMessage(message)\n\t\t\t\t\t.setHeader(this.sendTimeoutHeader, null)\n\t\t\t\t\t.setHeader(this.receiveTimeoutHeader, null)\n\t\t\t\t\t.build();\n\t\t}\n\n\t\tboolean sent = (timeout >= 0 ? channel.send(messageToSend, timeout) : channel.send(messageToSend));\n\n\t\tif (!sent) {\n\t\t\tthrow new MessageDeliveryException(message,\n\t\t\t\t\t\"Failed to send message to channel '\" + channel + \"' within timeout: \" + timeout);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.core.GenericMessagingTemplate#getReceiveTimeout()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured receive operation timeout value.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "long",
    "signature": "public long getReceiveTimeout()",
    "source_code": "\tpublic long getReceiveTimeout() {\n\t\treturn this.receiveTimeout;\n\t}"
  },
  "org.springframework.messaging.core.GenericMessagingTemplate#getReceiveTimeoutHeader()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured receive-timeout header.\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "String",
    "signature": "public String getReceiveTimeoutHeader()",
    "source_code": "\tpublic String getReceiveTimeoutHeader() {\n\t\treturn this.receiveTimeoutHeader;\n\t}"
  },
  "org.springframework.messaging.core.GenericMessagingTemplate#getSendTimeout()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured default send operation timeout value.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "long",
    "signature": "public long getSendTimeout()",
    "source_code": "\tpublic long getSendTimeout() {\n\t\treturn this.sendTimeout;\n\t}"
  },
  "org.springframework.messaging.core.GenericMessagingTemplate#getSendTimeoutHeader()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured send-timeout header.\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "String",
    "signature": "public String getSendTimeoutHeader()",
    "source_code": "\tpublic String getSendTimeoutHeader() {\n\t\treturn this.sendTimeoutHeader;\n\t}"
  },
  "org.springframework.messaging.core.GenericMessagingTemplate#send(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "boolean",
    "signature": "public boolean send(Message<?> message)",
    "source_code": "\t\tpublic boolean send(Message<?> message) {\n\t\t\treturn this.send(message, -1);\n\t\t}"
  },
  "org.springframework.messaging.core.GenericMessagingTemplate#send(message,timeout)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 339
    },
    "return": "boolean",
    "signature": "public boolean send(Message<?> message, long timeout)",
    "source_code": "\t\tpublic boolean send(Message<?> message, long timeout) {\n\t\t\tthis.replyMessage = message;\n\t\t\tboolean alreadyReceivedReply = this.hasReceived;\n\t\t\tthis.replyLatch.countDown();\n\n\t\t\tString errorDescription = null;\n\t\t\tif (this.hasTimedOut) {\n\t\t\t\terrorDescription = \"Reply message received but the receiving thread has exited due to a timeout\";\n\t\t\t}\n\t\t\telse if (alreadyReceivedReply) {\n\t\t\t\terrorDescription = \"Reply message received but the receiving thread has already received a reply\";\n\t\t\t}\n\t\t\telse if (this.hasSendFailed) {\n\t\t\t\terrorDescription = \"Reply message received but the receiving thread has exited due to \" +\n\t\t\t\t\t\t\"an exception while sending the request message\";\n\t\t\t}\n\n\t\t\tif (errorDescription != null) {\n\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\tlogger.warn(errorDescription + \": \" + message);\n\t\t\t\t}\n\t\t\t\tif (this.throwExceptionOnLateReply) {\n\t\t\t\t\tthrow new MessageDeliveryException(message, errorDescription);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}"
  },
  "org.springframework.messaging.core.GenericMessagingTemplate#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "void",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n\t\tsetDestinationResolver(new BeanFactoryMessageChannelDestinationResolver(beanFactory));\n\t}"
  },
  "org.springframework.messaging.core.GenericMessagingTemplate#setReceiveTimeout(receiveTimeout)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the default timeout value to use for receive operations.\n\t * May be overridden for individual messages when using sendAndReceive\n\t * operations.\n\t * @param receiveTimeout the receive timeout in milliseconds\n\t * @see #setReceiveTimeoutHeader(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "receiveTimeout"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "void",
    "signature": "public void setReceiveTimeout(long receiveTimeout)",
    "source_code": "\tpublic void setReceiveTimeout(long receiveTimeout) {\n\t\tthis.receiveTimeout = receiveTimeout;\n\t}"
  },
  "org.springframework.messaging.core.GenericMessagingTemplate#setReceiveTimeoutHeader(receiveTimeoutHeader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of the header used to determine the send timeout (if present).\n\t * Default {@value #DEFAULT_RECEIVE_TIMEOUT_HEADER}.\n\t * The header is removed before sending the message to avoid propagation.\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "receiveTimeoutHeader"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "void",
    "signature": "public void setReceiveTimeoutHeader(String receiveTimeoutHeader)",
    "source_code": "\tpublic void setReceiveTimeoutHeader(String receiveTimeoutHeader) {\n\t\tAssert.notNull(receiveTimeoutHeader, \"'receiveTimeoutHeader' cannot be null\");\n\t\tthis.receiveTimeoutHeader = receiveTimeoutHeader;\n\t}"
  },
  "org.springframework.messaging.core.GenericMessagingTemplate#setSendFailed(hasSendError)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hasSendError"
    ],
    "position": {
      "column": 1,
      "line": 300
    },
    "return": "void",
    "signature": "public void setSendFailed(boolean hasSendError)",
    "source_code": "\t\tpublic void setSendFailed(boolean hasSendError) {\n\t\t\tthis.hasSendFailed = hasSendError;\n\t\t}"
  },
  "org.springframework.messaging.core.GenericMessagingTemplate#setSendTimeout(sendTimeout)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the default timeout value to use for send operations.\n\t * May be overridden for individual messages.\n\t * @param sendTimeout the send timeout in milliseconds\n\t * @see #setSendTimeoutHeader(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sendTimeout"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "void",
    "signature": "public void setSendTimeout(long sendTimeout)",
    "source_code": "\tpublic void setSendTimeout(long sendTimeout) {\n\t\tthis.sendTimeout = sendTimeout;\n\t}"
  },
  "org.springframework.messaging.core.GenericMessagingTemplate#setSendTimeoutHeader(sendTimeoutHeader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of the header used to determine the send timeout (if present).\n\t * Default {@value #DEFAULT_SEND_TIMEOUT_HEADER}.\n\t * <p>The header is removed before sending the message to avoid propagation.\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sendTimeoutHeader"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "public void setSendTimeoutHeader(String sendTimeoutHeader)",
    "source_code": "\tpublic void setSendTimeoutHeader(String sendTimeoutHeader) {\n\t\tAssert.notNull(sendTimeoutHeader, \"'sendTimeoutHeader' cannot be null\");\n\t\tthis.sendTimeoutHeader = sendTimeoutHeader;\n\t}"
  },
  "org.springframework.messaging.core.GenericMessagingTemplate#setThrowExceptionOnLateReply(throwExceptionOnLateReply)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the thread sending a reply should have an exception raised if the\n\t * receiving thread isn't going to receive the reply either because it timed out,\n\t * or because it already received a reply, or because it got an exception while\n\t * sending the request message.\n\t * <p>The default value is {@code false} in which case only a WARN message is logged.\n\t * If set to {@code true} a {@link MessageDeliveryException} is raised in addition\n\t * to the log message.\n\t * @param throwExceptionOnLateReply whether to throw an exception or not\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "throwExceptionOnLateReply"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "void",
    "signature": "public void setThrowExceptionOnLateReply(boolean throwExceptionOnLateReply)",
    "source_code": "\tpublic void setThrowExceptionOnLateReply(boolean throwExceptionOnLateReply) {\n\t\tthis.throwExceptionOnLateReply = throwExceptionOnLateReply;\n\t}"
  },
  "org.springframework.messaging.core.logger": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.messaging.handler.DestinationPatternsMessageCondition": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link MessageCondition} to match the destination header of a Message\n * against one or more patterns through a {@link RouteMatcher}.\n *\n * @author Rossen Stoyanchev\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "signature": "public class DestinationPatternsMessageCondition",
    "source_code": "public class DestinationPatternsMessageCondition"
  },
  "org.springframework.messaging.handler.DestinationPatternsMessageCondition#combine(other)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns a new instance with URL patterns from the current instance (\"this\") and\n\t * the \"other\" instance as follows:\n\t * <ul>\n\t * <li>If there are patterns in both instances, combine the patterns in \"this\" with\n\t * the patterns in \"other\" using {@link org.springframework.util.PathMatcher#combine(String, String)}.\n\t * <li>If only one instance has patterns, use them.\n\t * <li>If neither instance has patterns, use an empty String (i.e. \"\").\n\t * </ul>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "DestinationPatternsMessageCondition",
    "signature": "public DestinationPatternsMessageCondition combine(DestinationPatternsMessageCondition other)",
    "source_code": "\tpublic DestinationPatternsMessageCondition combine(DestinationPatternsMessageCondition other) {\n\t\tSet<String> result = new LinkedHashSet<>();\n\t\tif (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {\n\t\t\tfor (String pattern1 : this.patterns) {\n\t\t\t\tfor (String pattern2 : other.patterns) {\n\t\t\t\t\tresult.add(this.routeMatcher.combine(pattern1, pattern2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!this.patterns.isEmpty()) {\n\t\t\tresult.addAll(this.patterns);\n\t\t}\n\t\telse if (!other.patterns.isEmpty()) {\n\t\t\tresult.addAll(other.patterns);\n\t\t}\n\t\telse {\n\t\t\tresult.add(\"\");\n\t\t}\n\t\treturn new DestinationPatternsMessageCondition(result, this.routeMatcher);\n\t}"
  },
  "org.springframework.messaging.handler.DestinationPatternsMessageCondition#compareTo(other,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Compare the two conditions based on the destination patterns they contain.\n\t * Patterns are compared one at a time, from top to bottom via\n\t * {@link org.springframework.util.PathMatcher#getPatternComparator(String)}.\n\t * If all compared patterns match equally, but one instance has more patterns,\n\t * it is considered a closer match.\n\t * <p>It is assumed that both instances have been obtained via\n\t * {@link #getMatchingCondition(Message)} to ensure they contain only patterns\n\t * that match the request and are sorted with the best matches on top.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "int",
    "signature": "public int compareTo(DestinationPatternsMessageCondition other, Message<?> message)",
    "source_code": "\tpublic int compareTo(DestinationPatternsMessageCondition other, Message<?> message) {\n\t\tObject destination = message.getHeaders().get(LOOKUP_DESTINATION_HEADER);\n\t\tif (destination == null) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tComparator<String> patternComparator = getPatternComparator(destination);\n\t\tIterator<String> iterator = this.patterns.iterator();\n\t\tIterator<String> iteratorOther = other.patterns.iterator();\n\t\twhile (iterator.hasNext() && iteratorOther.hasNext()) {\n\t\t\tint result = patternComparator.compare(iterator.next(), iteratorOther.next());\n\t\t\tif (result != 0) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tif (iterator.hasNext()) {\n\t\t\treturn -1;\n\t\t}\n\t\telse if (iteratorOther.hasNext()) {\n\t\t\treturn 1;\n\t\t}\n\t\telse {\n\t\t\treturn 0;\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.DestinationPatternsMessageCondition#getContent()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "Collection<String>",
    "signature": "protected Collection<String> getContent()",
    "source_code": "\tprotected Collection<String> getContent() {\n\t\treturn this.patterns;\n\t}"
  },
  "org.springframework.messaging.handler.DestinationPatternsMessageCondition#getMatchingCondition(message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check if any of the patterns match the given Message destination and return an instance\n\t * that is guaranteed to contain matching patterns, sorted via\n\t * {@link org.springframework.util.PathMatcher#getPatternComparator(String)}.\n\t * @param message the message to match to\n\t * @return the same instance if the condition contains no patterns;\n\t * or a new condition with sorted matching patterns;\n\t * or {@code null} either if a destination can not be extracted or there is no match\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "DestinationPatternsMessageCondition",
    "signature": "public DestinationPatternsMessageCondition getMatchingCondition(Message<?> message)",
    "source_code": "\tpublic DestinationPatternsMessageCondition getMatchingCondition(Message<?> message) {\n\t\tObject destination = message.getHeaders().get(LOOKUP_DESTINATION_HEADER);\n\t\tif (destination == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (this.patterns.isEmpty()) {\n\t\t\treturn this;\n\t\t}\n\n\t\tList<String> matches = null;\n\t\tfor (String pattern : this.patterns) {\n\t\t\tif (pattern.equals(destination) || matchPattern(pattern, destination)) {\n\t\t\t\tif (matches == null) {\n\t\t\t\t\tmatches = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tmatches.add(pattern);\n\t\t\t}\n\t\t}\n\t\tif (CollectionUtils.isEmpty(matches)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tmatches.sort(getPatternComparator(destination));\n\t\treturn new DestinationPatternsMessageCondition(new LinkedHashSet<>(matches), this.routeMatcher);\n\t}"
  },
  "org.springframework.messaging.handler.DestinationPatternsMessageCondition#getPatterns()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "Set<String>",
    "signature": "public Set<String> getPatterns()",
    "source_code": "\tpublic Set<String> getPatterns() {\n\t\treturn this.patterns;\n\t}"
  },
  "org.springframework.messaging.handler.DestinationPatternsMessageCondition#getToStringInfix()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "String",
    "signature": "protected String getToStringInfix()",
    "source_code": "\tprotected String getToStringInfix() {\n\t\treturn \" || \";\n\t}"
  },
  "org.springframework.messaging.handler.LOOKUP_DESTINATION_HEADER": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The name of the \"lookup destination\" header.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "public String LOOKUP_DESTINATION_HEADER",
    "source_code": "\tpublic static final String LOOKUP_DESTINATION_HEADER = \"lookupDestination\";",
    "type": "String"
  },
  "org.springframework.messaging.handler.annotation.support.DefaultMessageHandlerMethodFactory": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * The default {@link MessageHandlerMethodFactory} implementation creating an\n * {@link InvocableHandlerMethod} with the necessary\n * {@link HandlerMethodArgumentResolver} instances to detect and process\n * most of the use cases defined by\n * {@link org.springframework.messaging.handler.annotation.MessageMapping MessageMapping}.\n *\n * <p>Extra method argument resolvers can be added to customize the method\n * signature that can be handled.\n *\n * <p>By default, the validation process redirects to a no-op implementation, see\n * {@link #setValidator(Validator)} to customize it. The {@link ConversionService}\n * can be customized in a similar manner to tune how the message payload\n * can be converted\n *\n * @author Stephane Nicoll\n * @author Juergen Hoeller\n * @since 4.1\n * @see #setConversionService\n * @see #setValidator\n * @see #setCustomArgumentResolvers\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "signature": "public class DefaultMessageHandlerMethodFactory",
    "source_code": "public class DefaultMessageHandlerMethodFactory"
  },
  "org.springframework.messaging.handler.annotation.support.DefaultMessageHandlerMethodFactory#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tif (this.messageConverter == null) {\n\t\t\tthis.messageConverter = new GenericMessageConverter(this.conversionService);\n\t\t}\n\t\tif (this.argumentResolvers.getResolvers().isEmpty()) {\n\t\t\tthis.argumentResolvers.addResolvers(initArgumentResolvers());\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.annotation.support.DefaultMessageHandlerMethodFactory#createInvocableHandlerMethod(bean,method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "InvocableHandlerMethod",
    "signature": "public InvocableHandlerMethod createInvocableHandlerMethod(Object bean, Method method)",
    "source_code": "\tpublic InvocableHandlerMethod createInvocableHandlerMethod(Object bean, Method method) {\n\t\tInvocableHandlerMethod handlerMethod = new InvocableHandlerMethod(bean, method);\n\t\thandlerMethod.setMessageMethodArgumentResolvers(this.argumentResolvers);\n\t\treturn handlerMethod;\n\t}"
  },
  "org.springframework.messaging.handler.annotation.support.DefaultMessageHandlerMethodFactory#initArgumentResolvers()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "List<HandlerMethodArgumentResolver>",
    "signature": "protected List<HandlerMethodArgumentResolver> initArgumentResolvers()",
    "source_code": "\tprotected List<HandlerMethodArgumentResolver> initArgumentResolvers() {\n\t\tList<HandlerMethodArgumentResolver> resolvers = new ArrayList<>();\n\t\tConfigurableBeanFactory beanFactory = (this.beanFactory instanceof ConfigurableBeanFactory cbf ?\n\t\t\t\tcbf : null);\n\n\t\t// Annotation-based argument resolution\n\t\tresolvers.add(new HeaderMethodArgumentResolver(this.conversionService, beanFactory));\n\t\tresolvers.add(new HeadersMethodArgumentResolver());\n\n\t\t// Type-based argument resolution\n\t\tresolvers.add(new MessageMethodArgumentResolver(this.messageConverter));\n\n\t\tif (this.customArgumentResolvers != null) {\n\t\t\tresolvers.addAll(this.customArgumentResolvers);\n\t\t}\n\n\t\tAssert.notNull(this.messageConverter, \"MessageConverter not configured\");\n\t\tresolvers.add(new PayloadMethodArgumentResolver(this.messageConverter, this.validator));\n\n\t\treturn resolvers;\n\t}"
  },
  "org.springframework.messaging.handler.annotation.support.DefaultMessageHandlerMethodFactory#setArgumentResolvers(argumentResolvers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the complete list of supported argument types effectively overriding\n\t * the ones configured by default. This is an advanced option. For most use cases\n\t * it should be sufficient to use {@link #setCustomArgumentResolvers(java.util.List)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argumentResolvers"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "void",
    "signature": "public void setArgumentResolvers(@Nullable List<HandlerMethodArgumentResolver> argumentResolvers)",
    "source_code": "\tpublic void setArgumentResolvers(@Nullable List<HandlerMethodArgumentResolver> argumentResolvers) {\n\t\tif (argumentResolvers == null) {\n\t\t\tthis.argumentResolvers.clear();\n\t\t\treturn;\n\t\t}\n\t\tthis.argumentResolvers.addResolvers(argumentResolvers);\n\t}"
  },
  "org.springframework.messaging.handler.annotation.support.DefaultMessageHandlerMethodFactory#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A {@link BeanFactory} only needs to be available for placeholder resolution\n\t * in handler method arguments; it's optional otherwise.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "void",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t}"
  },
  "org.springframework.messaging.handler.annotation.support.DefaultMessageHandlerMethodFactory#setConversionService(conversionService)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link ConversionService} to use to convert the original\n\t * message payload or headers.\n\t * @see HeaderMethodArgumentResolver\n\t * @see GenericMessageConverter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "void",
    "signature": "public void setConversionService(ConversionService conversionService)",
    "source_code": "\tpublic void setConversionService(ConversionService conversionService) {\n\t\tthis.conversionService = conversionService;\n\t}"
  },
  "org.springframework.messaging.handler.annotation.support.DefaultMessageHandlerMethodFactory#setCustomArgumentResolvers(customArgumentResolvers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the list of custom {@code HandlerMethodArgumentResolver}s that will be used\n\t * after resolvers for supported argument type.\n\t * @param customArgumentResolvers the list of resolvers (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "customArgumentResolvers"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "void",
    "signature": "public void setCustomArgumentResolvers(List<HandlerMethodArgumentResolver> customArgumentResolvers)",
    "source_code": "\tpublic void setCustomArgumentResolvers(List<HandlerMethodArgumentResolver> customArgumentResolvers) {\n\t\tthis.customArgumentResolvers = customArgumentResolvers;\n\t}"
  },
  "org.springframework.messaging.handler.annotation.support.DefaultMessageHandlerMethodFactory#setMessageConverter(messageConverter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link MessageConverter} to use. By default a {@link GenericMessageConverter}\n\t * is used.\n\t * @see GenericMessageConverter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageConverter"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "public void setMessageConverter(MessageConverter messageConverter)",
    "source_code": "\tpublic void setMessageConverter(MessageConverter messageConverter) {\n\t\tthis.messageConverter = messageConverter;\n\t}"
  },
  "org.springframework.messaging.handler.annotation.support.DefaultMessageHandlerMethodFactory#setValidator(validator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Validator instance used for validating {@code @Payload} arguments.\n\t * @see org.springframework.validation.annotation.Validated\n\t * @see PayloadMethodArgumentResolver\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "validator"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "void",
    "signature": "public void setValidator(Validator validator)",
    "source_code": "\tpublic void setValidator(Validator validator) {\n\t\tthis.validator = validator;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.InvocableHandlerMethod": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Extension of {@link HandlerMethod} that invokes the underlying method with\n * argument values resolved from the current HTTP request through a list of\n * {@link HandlerMethodArgumentResolver}.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public class InvocableHandlerMethod",
    "source_code": "public class InvocableHandlerMethod extends HandlerMethod {\n\n\tprivate static final Object[] EMPTY_ARGS = new Object[0];\n\n\n\tprivate HandlerMethodArgumentResolverComposite resolvers = new HandlerMethodArgumentResolverComposite();\n\n\tprivate ParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer();\n\n\n\t/**\n\t * Create an instance from a {@code HandlerMethod}.\n\t */\n\tpublic InvocableHandlerMethod(HandlerMethod handlerMethod) {\n\t\tsuper(handlerMethod);\n\t}\n\n\t/**\n\t * Create an instance from a bean instance and a method.\n\t */\n\tpublic InvocableHandlerMethod(Object bean, Method method) {\n\t\tsuper(bean, method);\n\t}\n\n\t/**\n\t * Construct a new handler method with the given bean instance, method name and parameters.\n\t * @param bean the object bean\n\t * @param methodName the method name\n\t * @param parameterTypes the method parameter types\n\t * @throws NoSuchMethodException when the method cannot be found\n\t */\n\tpublic InvocableHandlerMethod(Object bean, String methodName, Class<?>... parameterTypes)\n\t\t\tthrows NoSuchMethodException {\n\n\t\tsuper(bean, methodName, parameterTypes);\n\t}\n\n\n\t/**\n\t * Set {@link HandlerMethodArgumentResolver HandlerMethodArgumentResolvers} to use for resolving method argument values.\n\t */\n\tpublic void setMessageMethodArgumentResolvers(HandlerMethodArgumentResolverComposite argumentResolvers) {\n\t\tthis.resolvers = argumentResolvers;\n\t}\n\n\t/**\n\t * Set the ParameterNameDiscoverer for resolving parameter names when needed\n\t * (e.g. default request attribute name).\n\t * <p>Default is a {@link org.springframework.core.DefaultParameterNameDiscoverer}.\n\t */\n\tpublic void setParameterNameDiscoverer(ParameterNameDiscoverer parameterNameDiscoverer) {\n\t\tthis.parameterNameDiscoverer = parameterNameDiscoverer;\n\t}\n\n\n\t/**\n\t * Invoke the method after resolving its argument values in the context of the given message.\n\t * <p>Argument values are commonly resolved through\n\t * {@link HandlerMethodArgumentResolver HandlerMethodArgumentResolvers}.\n\t * The {@code providedArgs} parameter however may supply argument values to be used directly,\n\t * i.e. without argument resolution.\n\t * <p>Delegates to {@link #getMethodArgumentValues} and calls {@link #doInvoke} with the\n\t * resolved arguments.\n\t * @param message the current message being processed\n\t * @param providedArgs \"given\" arguments matched by type, not resolved\n\t * @return the raw value returned by the invoked method\n\t * @throws Exception raised if no suitable argument resolver can be found,\n\t * or if the method raised an exception\n\t * @see #getMethodArgumentValues\n\t * @see #doInvoke\n\t */\n\t@Nullable\n\tpublic Object invoke(Message<?> message, Object... providedArgs) throws Exception {\n\t\tObject[] args = getMethodArgumentValues(message, providedArgs);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Arguments: \" + Arrays.toString(args));\n\t\t}\n\t\treturn doInvoke(args);\n\t}\n\n\t/**\n\t * Get the method argument values for the current message, checking the provided\n\t * argument values and falling back to the configured argument resolvers.\n\t * <p>The resulting array will be passed into {@link #doInvoke}.\n\t * @since 5.1.2\n\t */\n\tprotected Object[] getMethodArgumentValues(Message<?> message, Object... providedArgs) throws Exception {\n\t\tMethodParameter[] parameters = getMethodParameters();\n\t\tif (ObjectUtils.isEmpty(parameters)) {\n\t\t\treturn EMPTY_ARGS;\n\t\t}\n\n\t\tObject[] args = new Object[parameters.length];\n\t\tfor (int i = 0; i < parameters.length; i++) {\n\t\t\tMethodParameter parameter = parameters[i];\n\t\t\tparameter.initParameterNameDiscovery(this.parameterNameDiscoverer);\n\t\t\targs[i] = findProvidedArgument(parameter, providedArgs);\n\t\t\tif (args[i] != null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!this.resolvers.supportsParameter(parameter)) {\n\t\t\t\tthrow new MethodArgumentResolutionException(\n\t\t\t\t\t\tmessage, parameter, formatArgumentError(parameter, \"No suitable resolver\"));\n\t\t\t}\n\t\t\ttry {\n\t\t\t\targs[i] = this.resolvers.resolveArgument(parameter, message);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\t// Leave stack trace for later, exception may actually be resolved and handled...\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tString exMsg = ex.getMessage();\n\t\t\t\t\tif (exMsg != null && !exMsg.contains(parameter.getExecutable().toGenericString())) {\n\t\t\t\t\t\tlogger.debug(formatArgumentError(parameter, exMsg));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\t\treturn args;\n\t}\n\n\t/**\n\t * Invoke the handler method with the given argument values.\n\t */\n\t@Nullable\n\tprotected Object doInvoke(Object... args) throws Exception {\n\t\ttry {\n\t\t\treturn getBridgedMethod().invoke(getBean(), args);\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\tassertTargetBean(getBridgedMethod(), getBean(), args);\n\t\t\tString text = (ex.getMessage() == null || ex.getCause() instanceof NullPointerException) ?\n\t\t\t\t\t\"Illegal argument\": ex.getMessage();\n\t\t\tthrow new IllegalStateException(formatInvokeError(text, args), ex);\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\t// Unwrap for HandlerExceptionResolvers ...\n\t\t\tThrowable targetException = ex.getTargetException();\n\t\t\tif (targetException instanceof RuntimeException runtimeException) {\n\t\t\t\tthrow runtimeException;\n\t\t\t}\n\t\t\telse if (targetException instanceof Error error) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\telse if (targetException instanceof Exception exception) {\n\t\t\t\tthrow exception;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalStateException(formatInvokeError(\"Invocation failure\", args), targetException);\n\t\t\t}\n\t\t}\n\t}\n\n\tMethodParameter getAsyncReturnValueType(@Nullable Object returnValue) {\n\t\treturn new AsyncResultMethodParameter(returnValue);\n\t}\n\n\n\tprivate class AsyncResultMethodParameter extends HandlerMethodParameter {\n\n\t\t@Nullable\n\t\tprivate final Object returnValue;\n\n\t\tprivate final ResolvableType returnType;\n\n\t\tpublic AsyncResultMethodParameter(@Nullable Object returnValue) {\n\t\t\tsuper(-1);\n\t\t\tthis.returnValue = returnValue;\n\t\t\tthis.returnType = ResolvableType.forType(super.getGenericParameterType()).getGeneric();\n\t\t}\n\n\t\tprotected AsyncResultMethodParameter(AsyncResultMethodParameter original) {\n\t\t\tsuper(original);\n\t\t\tthis.returnValue = original.returnValue;\n\t\t\tthis.returnType = original.returnType;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<?> getParameterType() {\n\t\t\tif (this.returnValue != null) {\n\t\t\t\treturn this.returnValue.getClass();\n\t\t\t}\n\t\t\tif (!ResolvableType.NONE.equals(this.returnType)) {\n\t\t\t\treturn this.returnType.toClass();\n\t\t\t}\n\t\t\treturn super.getParameterType();\n\t\t}\n\n\t\t@Override\n\t\tpublic Type getGenericParameterType() {\n\t\t\treturn this.returnType.getType();\n\t\t}\n\n\t\t@Override\n\t\tpublic AsyncResultMethodParameter clone() {\n\t\t\treturn new AsyncResultMethodParameter(this);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.messaging.handler.invocation.InvocableHandlerMethod#clone()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "AsyncResultMethodParameter",
    "signature": "public AsyncResultMethodParameter clone()",
    "source_code": "\t\tpublic AsyncResultMethodParameter clone() {\n\t\t\treturn new AsyncResultMethodParameter(this);\n\t\t}"
  },
  "org.springframework.messaging.handler.invocation.InvocableHandlerMethod#doInvoke(args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the handler method with the given argument values.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "args"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "Object",
    "signature": "protected Object doInvoke(Object... args)",
    "source_code": "\tprotected Object doInvoke(Object... args) throws Exception {\n\t\ttry {\n\t\t\treturn getBridgedMethod().invoke(getBean(), args);\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\tassertTargetBean(getBridgedMethod(), getBean(), args);\n\t\t\tString text = (ex.getMessage() == null || ex.getCause() instanceof NullPointerException) ?\n\t\t\t\t\t\"Illegal argument\": ex.getMessage();\n\t\t\tthrow new IllegalStateException(formatInvokeError(text, args), ex);\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\t// Unwrap for HandlerExceptionResolvers ...\n\t\t\tThrowable targetException = ex.getTargetException();\n\t\t\tif (targetException instanceof RuntimeException runtimeException) {\n\t\t\t\tthrow runtimeException;\n\t\t\t}\n\t\t\telse if (targetException instanceof Error error) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\telse if (targetException instanceof Exception exception) {\n\t\t\t\tthrow exception;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalStateException(formatInvokeError(\"Invocation failure\", args), targetException);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.invocation.InvocableHandlerMethod#getGenericParameterType()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 231
    },
    "return": "Type",
    "signature": "public Type getGenericParameterType()",
    "source_code": "\t\tpublic Type getGenericParameterType() {\n\t\t\treturn this.returnType.getType();\n\t\t}"
  },
  "org.springframework.messaging.handler.invocation.InvocableHandlerMethod#getMethodArgumentValues(message,providedArgs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the method argument values for the current message, checking the provided\n\t * argument values and falling back to the configured argument resolvers.\n\t * <p>The resulting array will be passed into {@link #doInvoke}.\n\t * @since 5.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "Object[]",
    "signature": "protected Object[] getMethodArgumentValues(Message<?> message, Object... providedArgs)",
    "source_code": "\tprotected Object[] getMethodArgumentValues(Message<?> message, Object... providedArgs) throws Exception {\n\t\tMethodParameter[] parameters = getMethodParameters();\n\t\tif (ObjectUtils.isEmpty(parameters)) {\n\t\t\treturn EMPTY_ARGS;\n\t\t}\n\n\t\tObject[] args = new Object[parameters.length];\n\t\tfor (int i = 0; i < parameters.length; i++) {\n\t\t\tMethodParameter parameter = parameters[i];\n\t\t\tparameter.initParameterNameDiscovery(this.parameterNameDiscoverer);\n\t\t\targs[i] = findProvidedArgument(parameter, providedArgs);\n\t\t\tif (args[i] != null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!this.resolvers.supportsParameter(parameter)) {\n\t\t\t\tthrow new MethodArgumentResolutionException(\n\t\t\t\t\t\tmessage, parameter, formatArgumentError(parameter, \"No suitable resolver\"));\n\t\t\t}\n\t\t\ttry {\n\t\t\t\targs[i] = this.resolvers.resolveArgument(parameter, message);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\t// Leave stack trace for later, exception may actually be resolved and handled...\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tString exMsg = ex.getMessage();\n\t\t\t\t\tif (exMsg != null && !exMsg.contains(parameter.getExecutable().toGenericString())) {\n\t\t\t\t\t\tlogger.debug(formatArgumentError(parameter, exMsg));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\t\treturn args;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.InvocableHandlerMethod#invoke(message,providedArgs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the method after resolving its argument values in the context of the given message.\n\t * <p>Argument values are commonly resolved through\n\t * {@link HandlerMethodArgumentResolver HandlerMethodArgumentResolvers}.\n\t * The {@code providedArgs} parameter however may supply argument values to be used directly,\n\t * i.e. without argument resolution.\n\t * <p>Delegates to {@link #getMethodArgumentValues} and calls {@link #doInvoke} with the\n\t * resolved arguments.\n\t * @param message the current message being processed\n\t * @param providedArgs \"given\" arguments matched by type, not resolved\n\t * @return the raw value returned by the invoked method\n\t * @throws Exception raised if no suitable argument resolver can be found,\n\t * or if the method raised an exception\n\t * @see #getMethodArgumentValues\n\t * @see #doInvoke\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "Object",
    "signature": "public Object invoke(Message<?> message, Object... providedArgs)",
    "source_code": "\tpublic Object invoke(Message<?> message, Object... providedArgs) throws Exception {\n\t\tObject[] args = getMethodArgumentValues(message, providedArgs);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Arguments: \" + Arrays.toString(args));\n\t\t}\n\t\treturn doInvoke(args);\n\t}"
  },
  "org.springframework.messaging.handler.invocation.InvocableHandlerMethod#setMessageMethodArgumentResolvers(argumentResolvers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set {@link HandlerMethodArgumentResolver HandlerMethodArgumentResolvers} to use for resolving method argument values.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argumentResolvers"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void setMessageMethodArgumentResolvers(HandlerMethodArgumentResolverComposite argumentResolvers)",
    "source_code": "\tpublic void setMessageMethodArgumentResolvers(HandlerMethodArgumentResolverComposite argumentResolvers) {\n\t\tthis.resolvers = argumentResolvers;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.InvocableHandlerMethod#setParameterNameDiscoverer(parameterNameDiscoverer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the ParameterNameDiscoverer for resolving parameter names when needed\n\t * (e.g. default request attribute name).\n\t * <p>Default is a {@link org.springframework.core.DefaultParameterNameDiscoverer}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterNameDiscoverer"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "void",
    "signature": "public void setParameterNameDiscoverer(ParameterNameDiscoverer parameterNameDiscoverer)",
    "source_code": "\tpublic void setParameterNameDiscoverer(ParameterNameDiscoverer parameterNameDiscoverer) {\n\t\tthis.parameterNameDiscoverer = parameterNameDiscoverer;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract base class for reactive HandlerMethod-based message handling.\n * Provides most of the logic required to discover handler methods at startup,\n * find a matching handler method at runtime for a given message and invoke it.\n *\n * <p>Also supports discovering and invoking exception handling methods to process\n * exceptions raised during message handling.\n *\n * @author Rossen Stoyanchev\n * @since 5.2\n * @param <T> the type of the Object that contains information mapping information\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "signature": "public class AbstractMethodMessageHandler",
    "source_code": "public abstract class AbstractMethodMessageHandler<T>"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 247
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\n\t\tList<? extends HandlerMethodArgumentResolver> resolvers = initArgumentResolvers();\n\t\tif (resolvers.isEmpty()) {\n\t\t\tresolvers = new ArrayList<>(this.argumentResolverConfigurer.getCustomResolvers());\n\t\t}\n\t\tthis.invocableHelper.addArgumentResolvers(resolvers);\n\n\t\tList<? extends HandlerMethodReturnValueHandler> handlers = initReturnValueHandlers();\n\t\tif (handlers.isEmpty()) {\n\t\t\thandlers = new ArrayList<>(this.returnValueHandlerConfigurer.getCustomHandlers());\n\t\t}\n\t\tthis.invocableHelper.addReturnValueHandlers(handlers);\n\n\t\tinitHandlerMethods();\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler#compare(match1,match2)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "match1",
      "match2"
    ],
    "position": {
      "column": 1,
      "line": 588
    },
    "return": "int",
    "signature": "public int compare(Match<T> match1, Match<T> match2)",
    "source_code": "\t\tpublic int compare(Match<T> match1, Match<T> match2) {\n\t\t\treturn this.comparator.compare(match1.mapping, match2.mapping);\n\t\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler#createExceptionMethodResolverFor(beanType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a concrete instance of {@link AbstractExceptionHandlerMethodResolver}\n\t * that finds exception handling methods based on some criteria, e.g. based\n\t * on the presence of {@code @MessageExceptionHandler}.\n\t * @param beanType the class in which an exception occurred during handling\n\t * @return the resolver to use\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanType"
    ],
    "position": {
      "column": 1,
      "line": 554
    },
    "return": "AbstractExceptionHandlerMethodResolver",
    "signature": "protected AbstractExceptionHandlerMethodResolver createExceptionMethodResolverFor(Class<?> beanType)",
    "source_code": "\tprotected abstract AbstractExceptionHandlerMethodResolver createExceptionMethodResolverFor(Class<?> beanType);"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler#detectHandlerMethods(handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Detect if the given handler has any methods that can handle messages and if\n\t * so register it with the extracted mapping information.\n\t * <p><strong>Note:</strong> This method is protected and can be invoked by\n\t * subclasses, but this should be done on startup only as documented in\n\t * {@link #registerHandlerMethod}.\n\t * @param handler the handler to check, either an instance of a Spring bean name\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "void",
    "signature": "protected void detectHandlerMethods(Object handler)",
    "source_code": "\tprotected final void detectHandlerMethods(Object handler) {\n\t\tClass<?> handlerType;\n\t\tif (handler instanceof String handlerName) {\n\t\t\tApplicationContext context = getApplicationContext();\n\t\t\tAssert.state(context != null, \"ApplicationContext is required for resolving handler bean names\");\n\t\t\thandlerType = context.getType(handlerName);\n\t\t}\n\t\telse {\n\t\t\thandlerType = handler.getClass();\n\t\t}\n\t\tif (handlerType != null) {\n\t\t\tfinal Class<?> userType = ClassUtils.getUserClass(handlerType);\n\t\t\tMap<Method, T> methods = MethodIntrospector.selectMethods(userType,\n\t\t\t\t\t(MethodIntrospector.MetadataLookup<T>) method -> getMappingForMethod(method, userType));\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(formatMappings(userType, methods));\n\t\t\t}\n\t\t\tmethods.forEach((key, value) -> registerHandlerMethod(handler, key, value));\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler#extendMapping(mapping,handlerMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This method is invoked just before mappings are added. It allows\n\t * subclasses to update the mapping with the {@link HandlerMethod} in mind.\n\t * This can be useful when the method signature is used to refine the\n\t * mapping, e.g. based on the cardinality of input and output.\n\t * <p>By default this method returns the mapping that is passed in.\n\t * @param mapping the mapping to be added\n\t * @param handlerMethod the target handler for the mapping\n\t * @return a new mapping or the same\n\t * @since 5.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "T",
    "signature": "protected T extendMapping(T mapping, HandlerMethod handlerMethod)",
    "source_code": "\tprotected T extendMapping(T mapping, HandlerMethod handlerMethod) {\n\t\treturn mapping;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler#getApplicationContext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 197
    },
    "return": "ApplicationContext",
    "signature": "public ApplicationContext getApplicationContext()",
    "source_code": "\tpublic ApplicationContext getApplicationContext() {\n\t\treturn this.applicationContext;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler#getArgumentResolverConfigurer()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured custom resolvers for handler method arguments.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "ArgumentResolverConfigurer",
    "signature": "public ArgumentResolverConfigurer getArgumentResolverConfigurer()",
    "source_code": "\tpublic ArgumentResolverConfigurer getArgumentResolverConfigurer() {\n\t\treturn this.argumentResolverConfigurer;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler#getArgumentResolvers()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the argument resolvers initialized during {@link #afterPropertiesSet()}.\n\t * Primarily for internal use in subclasses.\n\t * @since 5.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "HandlerMethodArgumentResolverComposite",
    "signature": "protected HandlerMethodArgumentResolverComposite getArgumentResolvers()",
    "source_code": "\tprotected HandlerMethodArgumentResolverComposite getArgumentResolvers() {\n\t\treturn this.invocableHelper.getArgumentResolvers();\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler#getBeanName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "String",
    "signature": "public String getBeanName()",
    "source_code": "\tpublic String getBeanName() {\n\t\treturn (this.beanName != null ? this.beanName :\n\t\t\t\tgetClass().getSimpleName() + \"@\" + ObjectUtils.getIdentityHexString(this));\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler#getDestinationLookup()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a read-only multi-value map with a direct lookup of mappings,\n\t * (e.g. for non-pattern destinations).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "T>",
    "signature": "public T> getDestinationLookup()",
    "source_code": "\tpublic MultiValueMap<String, T> getDestinationLookup() {\n\t\treturn CollectionUtils.unmodifiableMultiValueMap(CollectionUtils.toMultiValueMap(this.destinationLookup));\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler#getDirectLookupMappings(mapping)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return String-based destinations for the given mapping, if any, that can\n\t * be used to find matches with a direct lookup (i.e. non-patterns).\n\t * <p><strong>Note:</strong> This is completely optional. The mapping\n\t * metadata for a subclass may support neither direct lookups, nor String\n\t * based destinations.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping"
    ],
    "position": {
      "column": 1,
      "line": 440
    },
    "return": "Set<String>",
    "signature": "protected Set<String> getDirectLookupMappings(T mapping)",
    "source_code": "\tprotected abstract Set<String> getDirectLookupMappings(T mapping);"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler#getHandlerMethods()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a read-only map with all handler methods and their mappings.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "HandlerMethod>",
    "signature": "public HandlerMethod> getHandlerMethods()",
    "source_code": "\tpublic Map<T, HandlerMethod> getHandlerMethods() {\n\t\treturn Collections.unmodifiableMap(this.handlerMethods);\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler#getMappingComparator(message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a comparator for sorting matching mappings.\n\t * The returned comparator should sort 'better' matches higher.\n\t * @param message the current Message\n\t * @return the comparator, never {@code null}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 535
    },
    "return": "Comparator<T>",
    "signature": "protected Comparator<T> getMappingComparator(Message<?> message)",
    "source_code": "\tprotected abstract Comparator<T> getMappingComparator(Message<?> message);"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler#getMappingForMethod(method,handlerType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain the mapping for the given method, if any.\n\t * @param method the method to check\n\t * @param handlerType the handler type, possibly a subtype of the method's declaring class\n\t * @return the mapping, or {@code null} if the method is not mapped\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "handlerType"
    ],
    "position": {
      "column": 1,
      "line": 369
    },
    "return": "T",
    "signature": "protected T getMappingForMethod(Method method, Class<?> handlerType)",
    "source_code": "\tprotected abstract T getMappingForMethod(Method method, Class<?> handlerType);"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler#getMatchingMapping(mapping,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check if a mapping matches the current message and return a possibly\n\t * new mapping with conditions relevant to the current request.\n\t * @param mapping the mapping to get a match for\n\t * @param message the message being handled\n\t * @return the match or {@code null} if there is no match\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 527
    },
    "return": "T",
    "signature": "protected T getMatchingMapping(T mapping, Message<?> message)",
    "source_code": "\tprotected abstract T getMatchingMapping(T mapping, Message<?> message);"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler#getReactiveAdapterRegistry()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured registry for adapting reactive types.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "ReactiveAdapterRegistry",
    "signature": "public ReactiveAdapterRegistry getReactiveAdapterRegistry()",
    "source_code": "\tpublic ReactiveAdapterRegistry getReactiveAdapterRegistry() {\n\t\treturn this.invocableHelper.getReactiveAdapterRegistry();\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler#getReturnValueHandlerConfigurer()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured return value handlers.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "ReturnValueHandlerConfigurer",
    "signature": "public ReturnValueHandlerConfigurer getReturnValueHandlerConfigurer()",
    "source_code": "\tpublic ReturnValueHandlerConfigurer getReturnValueHandlerConfigurer() {\n\t\treturn this.returnValueHandlerConfigurer;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler#handleMatch(mapping,handlerMethod,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "handlerMethod",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 459
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> handleMatch(T mapping, HandlerMethod handlerMethod, Message<?> message)",
    "source_code": "\tprotected Mono<Void> handleMatch(T mapping, HandlerMethod handlerMethod, Message<?> message) {\n\t\thandlerMethod = handlerMethod.createWithResolvedBean();\n\t\treturn this.invocableHelper.handleMessage(handlerMethod, message);\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler#handleMessage(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 444
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> handleMessage(Message<?> message)",
    "source_code": "\tpublic Mono<Void> handleMessage(Message<?> message) throws MessagingException {\n\t\tMatch<T> match = null;\n\t\ttry {\n\t\t\tmatch = getHandlerMethod(message);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\treturn Mono.error(ex);\n\t\t}\n\t\tif (match == null) {\n\t\t\t// handleNoMatch would have been invoked already\n\t\t\treturn Mono.empty();\n\t\t}\n\t\treturn handleMatch(match.mapping, match.handlerMethod, message);\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler#handleNoMatch(destination,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked when no matching handler is found.\n\t * @param destination the destination\n\t * @param message the message\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "destination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 542
    },
    "return": "void",
    "signature": "protected void handleNoMatch(@Nullable RouteMatcher.Route destination, Message<?> message)",
    "source_code": "\tprotected void handleNoMatch(@Nullable RouteMatcher.Route destination, Message<?> message) {\n\t\tlogger.debug(\"No handlers for destination '\" +\n\t\t\t\t(destination != null ? destination.value() : \"\") + \"'\");\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler#registerExceptionHandlerAdvice(bean,resolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses can invoke this method to populate the MessagingAdviceBean cache\n\t * (e.g. to support \"global\" {@code @MessageExceptionHandler}).\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "resolver"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "void",
    "signature": "protected void registerExceptionHandlerAdvice(MessagingAdviceBean bean, AbstractExceptionHandlerMethodResolver resolver)",
    "source_code": "\tprotected void registerExceptionHandlerAdvice("
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler#registerHandlerMethod(handler,method,mapping)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a handler method and its unique mapping.\n\t * <p><strong>Note:</strong> As of 5.3 this method is public (rather than\n\t * protected) and can be used both at startup and at runtime.\n\t * @param handler the bean name of the handler or the handler instance\n\t * @param method the method to register\n\t * @param mapping the mapping conditions associated with the handler method\n\t * @throws IllegalStateException if another method was already registered\n\t * under the same mapping\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handler",
      "method",
      "mapping"
    ],
    "position": {
      "column": 1,
      "line": 381
    },
    "return": "void",
    "signature": "public void registerHandlerMethod(Object handler, Method method, T mapping)",
    "source_code": "\tpublic final void registerHandlerMethod(Object handler, Method method, T mapping) {\n\t\tAssert.notNull(mapping, \"Mapping must not be null\");\n\t\tHandlerMethod newHandlerMethod = createHandlerMethod(handler, method);\n\t\tHandlerMethod oldHandlerMethod = this.handlerMethods.get(mapping);\n\n\t\tif (oldHandlerMethod != null && !oldHandlerMethod.equals(newHandlerMethod)) {\n\t\t\tthrow new IllegalStateException(\"Ambiguous mapping found. Cannot map '\" + newHandlerMethod.getBean() +\n\t\t\t\t\t\"' bean method \\n\" + newHandlerMethod + \"\\nto \" + mapping + \": There is already '\" +\n\t\t\t\t\toldHandlerMethod.getBean() + \"' bean method\\n\" + oldHandlerMethod + \" mapped.\");\n\t\t}\n\n\t\tmapping = extendMapping(mapping, newHandlerMethod);\n\t\tthis.handlerMethods.put(mapping, newHandlerMethod);\n\n\t\tfor (String pattern : getDirectLookupMappings(mapping)) {\n\t\t\tList<T> values = this.destinationLookup.computeIfAbsent(pattern, p -> new CopyOnWriteArrayList<>());\n\t\t\tvalues.add(mapping);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler#setApplicationContext(applicationContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "applicationContext"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "void",
    "signature": "public void setApplicationContext(@Nullable ApplicationContext applicationContext)",
    "source_code": "\tpublic void setApplicationContext(@Nullable ApplicationContext applicationContext) {\n\t\tthis.applicationContext = applicationContext;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler#setArgumentResolverConfigurer(configurer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure custom resolvers for handler method arguments.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "configurer"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "public void setArgumentResolverConfigurer(ArgumentResolverConfigurer configurer)",
    "source_code": "\tpublic void setArgumentResolverConfigurer(ArgumentResolverConfigurer configurer) {\n\t\tAssert.notNull(configurer, \"ArgumentResolverConfigurer is required\");\n\t\tthis.argumentResolverConfigurer = configurer;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler#setBeanName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "void",
    "signature": "public void setBeanName(String name)",
    "source_code": "\tpublic void setBeanName(String name) {\n\t\tthis.beanName = name;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler#setHandlerPredicate(handlerPredicate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a predicate for selecting which Spring beans to check for the\n\t * presence of message handler methods.\n\t * <p>This is not set by default. However, subclasses may initialize it to\n\t * some default strategy (e.g. {@code @Controller} classes).\n\t * @see #setHandlers(List)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handlerPredicate"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "void",
    "signature": "public void setHandlerPredicate(@Nullable Predicate<Class<?>> handlerPredicate)",
    "source_code": "\tpublic void setHandlerPredicate(@Nullable Predicate<Class<?>> handlerPredicate) {\n\t\tthis.handlerPredicate = handlerPredicate;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler#setHandlers(handlers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Manually configure the handlers to check for the presence of message\n\t * handling methods, which also disables auto-detection via a\n\t * {@link #setHandlerPredicate(Predicate) handlerPredicate}. If you do not\n\t * want to disable auto-detection, then call this method first, and then set\n\t * the handler predicate.\n\t * @param handlers the handlers to check\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handlers"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "void",
    "signature": "public void setHandlers(List<Object> handlers)",
    "source_code": "\tpublic void setHandlers(List<Object> handlers) {\n\t\tthis.handlers = handlers;\n\t\tthis.handlerPredicate = null;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler#setReactiveAdapterRegistry(registry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the registry for adapting various reactive types.\n\t * <p>By default this is an instance of {@link ReactiveAdapterRegistry} with\n\t * default settings.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "void",
    "signature": "public void setReactiveAdapterRegistry(ReactiveAdapterRegistry registry)",
    "source_code": "\tpublic void setReactiveAdapterRegistry(ReactiveAdapterRegistry registry) {\n\t\tthis.invocableHelper.setReactiveAdapterRegistry(registry);\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler#setReturnValueHandlerConfigurer(configurer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure custom return value handlers for handler methods.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "configurer"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "void",
    "signature": "public void setReturnValueHandlerConfigurer(ReturnValueHandlerConfigurer configurer)",
    "source_code": "\tpublic void setReturnValueHandlerConfigurer(ReturnValueHandlerConfigurer configurer) {\n\t\tAssert.notNull(configurer, \"ReturnValueHandlerConfigurer is required\");\n\t\tthis.returnValueHandlerConfigurer = configurer;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 573
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn this.mapping.toString();\n\t\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.logger": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.messaging.rsocket.<unknown>#build()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "RSocketStrategies",
    "signature": "public RSocketStrategies build()",
    "source_code": "\t\tpublic RSocketStrategies build() {\n\t\t\tRouteMatcher matcher = (this.routeMatcher != null ? this.routeMatcher : initRouteMatcher());\n\n\t\t\tReactiveAdapterRegistry registry = (this.adapterRegistry != null ?\n\t\t\t\t\tthis.adapterRegistry : ReactiveAdapterRegistry.getSharedInstance());\n\n\t\t\tDataBufferFactory factory = (this.bufferFactory != null ?\n\t\t\t\t\tthis.bufferFactory : new NettyDataBufferFactory(PooledByteBufAllocator.DEFAULT));\n\n\t\t\tMetadataExtractor extractor = (this.metadataExtractor != null ?\n\t\t\t\t\tthis.metadataExtractor : new DefaultMetadataExtractor(this.decoders));\n\n\t\t\tif (extractor instanceof MetadataExtractorRegistry metadataExtractorRegistry) {\n\t\t\t\tthis.metadataExtractors.forEach(consumer -> consumer.accept(metadataExtractorRegistry));\n\t\t\t}\n\n\t\t\treturn new DefaultRSocketStrategies(\n\t\t\t\t\tthis.encoders, this.decoders, matcher, registry, factory, extractor);\n\t\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#data(data)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "data"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "RequestSpec",
    "signature": "public RequestSpec data(Object data)",
    "source_code": "\t\tpublic RequestSpec data(Object data) {\n\t\t\tAssert.notNull(data, \"'data' must not be null\");\n\t\t\tcreatePayload(data, ResolvableType.NONE);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#data(producer,elementClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "producer",
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "RequestSpec",
    "signature": "public RequestSpec data(Object producer, Class<?> elementClass)",
    "source_code": "\t\tpublic RequestSpec data(Object producer, Class<?> elementClass) {\n\t\t\tAssert.notNull(producer, \"'producer' must not be null\");\n\t\t\tAssert.notNull(elementClass, \"'elementClass' must not be null\");\n\t\t\tReactiveAdapter adapter = getAdapter(producer.getClass());\n\t\t\tAssert.notNull(adapter, () -> \"'producer' type is unknown to ReactiveAdapterRegistry: \" +\n\t\t\t\t\tproducer.getClass().getName());\n\t\t\tcreatePayload(adapter.toPublisher(producer), ResolvableType.forClass(elementClass));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#data(producer,elementTypeRef)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "producer",
      "elementTypeRef"
    ],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "RequestSpec",
    "signature": "public RequestSpec data(Object producer, ParameterizedTypeReference<?> elementTypeRef)",
    "source_code": "\t\tpublic RequestSpec data(Object producer, ParameterizedTypeReference<?> elementTypeRef) {\n\t\t\tAssert.notNull(producer, \"'producer' must not be null\");\n\t\t\tAssert.notNull(elementTypeRef, \"'elementTypeRef' must not be null\");\n\t\t\tReactiveAdapter adapter = getAdapter(producer.getClass());\n\t\t\tAssert.notNull(adapter, () -> \"'producer' type is unknown to ReactiveAdapterRegistry: \" +\n\t\t\t\t\tproducer.getClass().getName());\n\t\t\tcreatePayload(adapter.toPublisher(producer), ResolvableType.forType(elementTypeRef));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#dataBufferFactory()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "DataBufferFactory",
    "signature": "public DataBufferFactory dataBufferFactory()",
    "source_code": "\tpublic DataBufferFactory dataBufferFactory() {\n\t\treturn this.bufferFactory;\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#dataBufferFactory(bufferFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bufferFactory"
    ],
    "position": {
      "column": 1,
      "line": 195
    },
    "return": "Builder",
    "signature": "public Builder dataBufferFactory(@Nullable DataBufferFactory bufferFactory)",
    "source_code": "\t\tpublic Builder dataBufferFactory(@Nullable DataBufferFactory bufferFactory) {\n\t\t\tthis.bufferFactory = bufferFactory;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#dataMimeType()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "MimeType",
    "signature": "public MimeType dataMimeType()",
    "source_code": "\tpublic MimeType dataMimeType() {\n\t\treturn this.dataMimeType;\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#decoder(decoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "decoder"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "Builder",
    "signature": "public Builder decoder(Decoder<?>... decoder)",
    "source_code": "\t\tpublic Builder decoder(Decoder<?>... decoder) {\n\t\t\tthis.decoders.addAll(Arrays.asList(decoder));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#decoders(consumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "consumer"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "Builder",
    "signature": "public Builder decoders(Consumer<List<Decoder<?>>> consumer)",
    "source_code": "\t\tpublic Builder decoders(Consumer<List<Decoder<?>>> consumer) {\n\t\t\tconsumer.accept(this.decoders);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#encoder(encoders)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encoders"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "Builder",
    "signature": "public Builder encoder(Encoder<?>... encoders)",
    "source_code": "\t\tpublic Builder encoder(Encoder<?>... encoders) {\n\t\t\tthis.encoders.addAll(Arrays.asList(encoders));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#encoders(consumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "consumer"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "Builder",
    "signature": "public Builder encoders(Consumer<List<Encoder<?>>> consumer)",
    "source_code": "\t\tpublic Builder encoders(Consumer<List<Encoder<?>>> consumer) {\n\t\t\tconsumer.accept(this.encoders);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#metadata(configurer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "configurer"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "RequestSpec",
    "signature": "public RequestSpec metadata(Consumer<MetadataSpec<?>> configurer)",
    "source_code": "\t\tpublic RequestSpec metadata(Consumer<MetadataSpec<?>> configurer) {\n\t\t\tconfigurer.accept(this);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#metadata(metadata,mimeType)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "metadata",
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "RequestSpec",
    "signature": "public RequestSpec metadata(Object metadata, MimeType mimeType)",
    "source_code": "\t\tpublic RequestSpec metadata(Object metadata, MimeType mimeType) {\n\t\t\tthis.metadataEncoder.metadata(metadata, mimeType);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#metadataExtractor()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "MetadataExtractor",
    "signature": "public MetadataExtractor metadataExtractor()",
    "source_code": "\tpublic MetadataExtractor metadataExtractor() {\n\t\treturn this.metadataExtractor;\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#metadataExtractor(metadataExtractor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "metadataExtractor"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "Builder",
    "signature": "public Builder metadataExtractor(@Nullable MetadataExtractor metadataExtractor)",
    "source_code": "\t\tpublic Builder metadataExtractor(@Nullable MetadataExtractor metadataExtractor) {\n\t\t\tthis.metadataExtractor = metadataExtractor;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#metadataExtractorRegistry(consumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "consumer"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "Builder",
    "signature": "public Builder metadataExtractorRegistry(Consumer<MetadataExtractorRegistry> consumer)",
    "source_code": "\t\tpublic Builder metadataExtractorRegistry(Consumer<MetadataExtractorRegistry> consumer) {\n\t\t\tthis.metadataExtractors.add(consumer);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#metadataMimeType()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "MimeType",
    "signature": "public MimeType metadataMimeType()",
    "source_code": "\tpublic MimeType metadataMimeType() {\n\t\treturn this.metadataMimeType;\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#reactiveAdapterRegistry()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "ReactiveAdapterRegistry",
    "signature": "public ReactiveAdapterRegistry reactiveAdapterRegistry()",
    "source_code": "\tpublic ReactiveAdapterRegistry reactiveAdapterRegistry() {\n\t\treturn this.adapterRegistry;\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#reactiveAdapterStrategy(registry)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "Builder",
    "signature": "public Builder reactiveAdapterStrategy(@Nullable ReactiveAdapterRegistry registry)",
    "source_code": "\t\tpublic Builder reactiveAdapterStrategy(@Nullable ReactiveAdapterRegistry registry) {\n\t\t\tthis.adapterRegistry = registry;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#retrieveFlux(dataType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataType"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "Flux<T>",
    "signature": "public Flux<T> retrieveFlux(Class<T> dataType)",
    "source_code": "\t\tpublic <T> Flux<T> retrieveFlux(Class<T> dataType) {\n\t\t\treturn retrieveFlux(ResolvableType.forClass(dataType));\n\t\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#retrieveFlux(dataTypeRef)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataTypeRef"
    ],
    "position": {
      "column": 1,
      "line": 307
    },
    "return": "Flux<T>",
    "signature": "public Flux<T> retrieveFlux(ParameterizedTypeReference<T> dataTypeRef)",
    "source_code": "\t\tpublic <T> Flux<T> retrieveFlux(ParameterizedTypeReference<T> dataTypeRef) {\n\t\t\treturn retrieveFlux(ResolvableType.forType(dataTypeRef));\n\t\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#retrieveMono(dataType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataType"
    ],
    "position": {
      "column": 1,
      "line": 279
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> retrieveMono(Class<T> dataType)",
    "source_code": "\t\tpublic <T> Mono<T> retrieveMono(Class<T> dataType) {\n\t\t\treturn retrieveMono(ResolvableType.forClass(dataType));\n\t\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#retrieveMono(dataTypeRef)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataTypeRef"
    ],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> retrieveMono(ParameterizedTypeReference<T> dataTypeRef)",
    "source_code": "\t\tpublic <T> Mono<T> retrieveMono(ParameterizedTypeReference<T> dataTypeRef) {\n\t\t\treturn retrieveMono(ResolvableType.forType(dataTypeRef));\n\t\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#route(route,vars)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "route",
      "vars"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "RequestSpec",
    "signature": "public RequestSpec route(String route, Object... vars)",
    "source_code": "\tpublic RequestSpec route(String route, Object... vars) {\n\t\treturn new DefaultRequestSpec(route, vars);\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#routeMatcher()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "RouteMatcher",
    "signature": "public RouteMatcher routeMatcher()",
    "source_code": "\tpublic RouteMatcher routeMatcher() {\n\t\treturn this.routeMatcher;\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#routeMatcher(routeMatcher)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "routeMatcher"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "Builder",
    "signature": "public Builder routeMatcher(@Nullable RouteMatcher routeMatcher)",
    "source_code": "\t\tpublic Builder routeMatcher(@Nullable RouteMatcher routeMatcher) {\n\t\t\tthis.routeMatcher = routeMatcher;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#rsocket()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "RSocket",
    "signature": "public RSocket rsocket()",
    "source_code": "\tpublic RSocket rsocket() {\n\t\treturn this.rsocket;\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#rsocketClient()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "RSocketClient",
    "signature": "public RSocketClient rsocketClient()",
    "source_code": "\tpublic RSocketClient rsocketClient() {\n\t\treturn this.rsocketClient;\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#send()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> send()",
    "source_code": "\t\tpublic Mono<Void> send() {\n\t\t\treturn rsocketClient.fireAndForget(getPayloadMono());\n\t\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#sendMetadata()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 269
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> sendMetadata()",
    "source_code": "\t\tpublic Mono<Void> sendMetadata() {\n\t\t\treturn rsocketClient.metadataPush(getPayloadMono());\n\t\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#strategies()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "RSocketStrategies",
    "signature": "public RSocketStrategies strategies()",
    "source_code": "\tpublic RSocketStrategies strategies() {\n\t\treturn this.strategies;\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.<unknown>#fireAndForget(payload)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "payload"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> fireAndForget(Payload payload)",
    "source_code": "\tpublic Mono<Void> fireAndForget(Payload payload) {\n\t\treturn handle(payload, FrameType.REQUEST_FNF);\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.<unknown>#handleConnectionSetupPayload(payload)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Wrap the {@link ConnectionSetupPayload} with a {@link Message} and\n\t * delegate to {@link #handle(Payload, FrameType)} for handling.\n\t * @param payload the connection payload\n\t * @return completion handle for success or error\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "payload"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> handleConnectionSetupPayload(ConnectionSetupPayload payload)",
    "source_code": "\tpublic Mono<Void> handleConnectionSetupPayload(ConnectionSetupPayload payload) {\n\t\t// frameDecoder does not apply to connectionSetupPayload\n\t\t// so retain here since handle expects it.\n\t\tpayload.retain();\n\t\treturn handle(payload, FrameType.SETUP);\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.<unknown>#metadataPush(payload)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "payload"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> metadataPush(Payload payload)",
    "source_code": "\tpublic Mono<Void> metadataPush(Payload payload) {\n\t\t// Not very useful until createHeaders does more with metadata\n\t\treturn handle(payload, FrameType.METADATA_PUSH);\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.<unknown>#requestChannel(payloads)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "payloads"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "Flux<Payload>",
    "signature": "public Flux<Payload> requestChannel(Publisher<Payload> payloads)",
    "source_code": "\tpublic Flux<Payload> requestChannel(Publisher<Payload> payloads) {\n\t\treturn Flux.from(payloads)\n\t\t\t\t.switchOnFirst((signal, innerFlux) -> {\n\t\t\t\t\tPayload firstPayload = signal.get();\n\t\t\t\t\treturn firstPayload == null ? innerFlux :\n\t\t\t\t\t\t\thandleAndReply(firstPayload, FrameType.REQUEST_CHANNEL, innerFlux);\n\t\t\t\t});\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.<unknown>#requestResponse(payload)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "payload"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "Mono<Payload>",
    "signature": "public Mono<Payload> requestResponse(Payload payload)",
    "source_code": "\tpublic Mono<Payload> requestResponse(Payload payload) {\n\t\treturn handleAndReply(payload, FrameType.REQUEST_RESPONSE, Flux.just(payload)).next();\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.<unknown>#requestStream(payload)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "payload"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "Flux<Payload>",
    "signature": "public Flux<Payload> requestStream(Payload payload)",
    "source_code": "\tpublic Flux<Payload> requestStream(Payload payload) {\n\t\treturn handleAndReply(payload, FrameType.REQUEST_STREAM, Flux.just(payload));\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.RSocketMessageHandler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Extension of {@link MessageMappingMessageHandler} for handling RSocket\n * requests with {@link ConnectMapping @ConnectMapping} and\n * {@link MessageMapping @MessageMapping} methods.\n *\n * <p>For server scenarios this class can be declared as a bean in Spring\n * configuration and that would detect {@code @MessageMapping} methods in\n * {@code @Controller} beans. What beans are checked can be changed through a\n * {@link #setHandlerPredicate(Predicate) handlerPredicate}. Given an instance\n * of this class, you can then use {@link #responder()} to obtain a\n * {@link SocketAcceptor} adapter to register with the\n * {@link io.rsocket.core.RSocketServer}.\n *\n * <p>For a client, possibly in the same process as a server, consider using the\n * static factory method {@link #responder(RSocketStrategies, Object...)} to\n * obtain a client responder to be registered via\n * {@link org.springframework.messaging.rsocket.RSocketRequester.Builder#rsocketConnector\n * RSocketRequester.Builder}.\n *\n * <p>For {@code @MessageMapping} methods, this class automatically determines\n * the RSocket interaction type based on the input and output cardinality of the\n * method. See the\n * <a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#rsocket-annot-responders\">\n * \"Annotated Responders\"</a> section of the Spring Framework reference for more details.\n *\n * @author Rossen Stoyanchev\n * @since 5.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "signature": "public class RSocketMessageHandler",
    "source_code": "public class RSocketMessageHandler extends MessageMappingMessageHandler {\n\n\tprivate final List<Encoder<?>> encoders = new ArrayList<>();\n\n\tprivate RSocketStrategies strategies = RSocketStrategies.create();\n\n\t@Nullable\n\tprivate MimeType defaultDataMimeType;\n\n\tprivate MimeType defaultMetadataMimeType = MimeTypeUtils.parseMimeType(\n\t\t\tWellKnownMimeType.MESSAGE_RSOCKET_COMPOSITE_METADATA.getString());\n\n\n\tpublic RSocketMessageHandler() {\n\t\tsetRSocketStrategies(this.strategies);\n\t}\n\n\n\t/**\n\t * Configure the encoders to use for encoding handler method return values.\n\t * <p>When {@link #setRSocketStrategies(RSocketStrategies) rsocketStrategies}\n\t * is set, this property is re-initialized with the encoders in it, and\n\t * likewise when this property is set the {@code RSocketStrategies} are\n\t * mutated to change the encoders in it.\n\t * <p>By default this is set to the\n\t * {@linkplain org.springframework.messaging.rsocket.RSocketStrategies.Builder#encoder(Encoder[]) defaults}\n\t * from {@code RSocketStrategies}.\n\t */\n\tpublic void setEncoders(List<? extends Encoder<?>> encoders) {\n\t\tthis.encoders.clear();\n\t\tthis.encoders.addAll(encoders);\n\t\tthis.strategies = this.strategies.mutate()\n\t\t\t\t.encoders(list -> {\n\t\t\t\t\tlist.clear();\n\t\t\t\t\tlist.addAll(encoders);\n\t\t\t\t})\n\t\t\t\t.build();\n\t}\n\n\t/**\n\t * Return the configured {@link #setEncoders(List) encoders}.\n\t */\n\tpublic List<? extends Encoder<?>> getEncoders() {\n\t\treturn this.encoders;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t * <p>When {@link #setRSocketStrategies(RSocketStrategies) rsocketStrategies}\n\t * is set, this property is re-initialized with the decoders in it, and\n\t * likewise when this property is set the {@code RSocketStrategies} are\n\t * mutated to change the decoders in them.\n\t * <p>By default this is set to the\n\t * {@linkplain org.springframework.messaging.rsocket.RSocketStrategies.Builder#decoder(Decoder[]) defaults}\n\t * from {@code RSocketStrategies}.\n\t */\n\t@Override\n\tpublic void setDecoders(List<? extends Decoder<?>> decoders) {\n\t\tsuper.setDecoders(decoders);\n\t\tthis.strategies = this.strategies.mutate()\n\t\t\t\t.decoders(list -> {\n\t\t\t\t\tlist.clear();\n\t\t\t\t\tlist.addAll(decoders);\n\t\t\t\t})\n\t\t\t\t.build();\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t * <p>When {@link #setRSocketStrategies(RSocketStrategies) rsocketStrategies}\n\t * is set, this property is re-initialized with the route matcher in it, and\n\t * likewise when this property is set the {@code RSocketStrategies} are\n\t * mutated to change the matcher in it.\n\t * <p>By default this is set to the\n\t * {@linkplain org.springframework.messaging.rsocket.RSocketStrategies.Builder#routeMatcher(RouteMatcher) defaults}\n\t * from {@code RSocketStrategies}.\n\t */\n\t@Override\n\tpublic void setRouteMatcher(@Nullable RouteMatcher routeMatcher) {\n\t\tsuper.setRouteMatcher(routeMatcher);\n\t\tthis.strategies = this.strategies.mutate().routeMatcher(routeMatcher).build();\n\t}\n\n\t/**\n\t * Configure the registry for adapting various reactive types.\n\t * <p>When {@link #setRSocketStrategies(RSocketStrategies) rsocketStrategies}\n\t * is set, this property is re-initialized with the registry in it, and\n\t * likewise when this property is set the {@code RSocketStrategies} are\n\t * mutated to change the registry in it.\n\t * <p>By default this is set to the\n\t * {@link org.springframework.messaging.rsocket.RSocketStrategies.Builder#reactiveAdapterStrategy(ReactiveAdapterRegistry) defaults}\n\t * from {@code RSocketStrategies}.\n\t */\n\t@Override\n\tpublic void setReactiveAdapterRegistry(ReactiveAdapterRegistry registry) {\n\t\tsuper.setReactiveAdapterRegistry(registry);\n\t\tthis.strategies = this.strategies.mutate().reactiveAdapterStrategy(registry).build();\n\t}\n\n\t/**\n\t * Configure a {@link MetadataExtractor} to extract the route along with\n\t * other metadata.\n\t * <p>When {@link #setRSocketStrategies(RSocketStrategies) rsocketStrategies}\n\t * is set, this property is re-initialized with the extractor in it, and\n\t * likewise when this property is set the {@code RSocketStrategies} are\n\t * mutated to change the extractor in it.\n\t * <p>By default this is set to the\n\t * {@link org.springframework.messaging.rsocket.RSocketStrategies.Builder#metadataExtractor(MetadataExtractor) defaults}\n\t * from {@code RSocketStrategies}.\n\t * @param extractor the extractor to use\n\t */\n\tpublic void setMetadataExtractor(MetadataExtractor extractor) {\n\t\tthis.strategies = this.strategies.mutate().metadataExtractor(extractor).build();\n\t}\n\n\t/**\n\t * Return the configured {@link #setMetadataExtractor MetadataExtractor}.\n\t */\n\tpublic MetadataExtractor getMetadataExtractor() {\n\t\treturn this.strategies.metadataExtractor();\n\t}\n\n\t/**\n\t * Configure this handler through an {@link RSocketStrategies} instance which\n\t * can be re-used to initialize a client-side {@link RSocketRequester}.\n\t * <p>When this property is set, in turn it sets the following:\n\t * <ul>\n\t * <li>{@link #setDecoders(List)}\n\t * <li>{@link #setEncoders(List)}\n\t * <li>{@link #setRouteMatcher(RouteMatcher)}\n\t * <li>{@link #setMetadataExtractor(MetadataExtractor)}\n\t * <li>{@link #setReactiveAdapterRegistry(ReactiveAdapterRegistry)}\n\t * </ul>\n\t * <p>By default this is set to {@link RSocketStrategies#create()} which in\n\t * turn sets default settings for all related properties.\n\t */\n\tpublic void setRSocketStrategies(RSocketStrategies rsocketStrategies) {\n\t\tthis.strategies = rsocketStrategies;\n\t\tthis.encoders.clear();\n\t\tthis.encoders.addAll(this.strategies.encoders());\n\t\tsuper.setDecoders(this.strategies.decoders());\n\t\tsuper.setRouteMatcher(this.strategies.routeMatcher());\n\t\tsuper.setReactiveAdapterRegistry(this.strategies.reactiveAdapterRegistry());\n\t}\n\n\t/**\n\t * Return the {@link #setRSocketStrategies configured} {@code RSocketStrategies}.\n\t */\n\tpublic RSocketStrategies getRSocketStrategies() {\n\t\treturn this.strategies;\n\t}\n\n\t/**\n\t * Configure the default content type to use for data payloads if the\n\t * {@code SETUP} frame did not specify one.\n\t * <p>By default this is not set.\n\t * @param mimeType the MimeType to use\n\t */\n\tpublic void setDefaultDataMimeType(@Nullable MimeType mimeType) {\n\t\tthis.defaultDataMimeType = mimeType;\n\t}\n\n\t/**\n\t * Return the configured\n\t * {@link #setDefaultDataMimeType defaultDataMimeType}, or {@code null}.\n\t */\n\t@Nullable\n\tpublic MimeType getDefaultDataMimeType() {\n\t\treturn this.defaultDataMimeType;\n\t}\n\n\t/**\n\t * Configure the default {@code MimeType} for payload data if the\n\t * {@code SETUP} frame did not specify one.\n\t * <p>By default this is set to {@code \"message/x.rsocket.composite-metadata.v0\"}\n\t * @param mimeType the MimeType to use\n\t */\n\tpublic void setDefaultMetadataMimeType(MimeType mimeType) {\n\t\tAssert.notNull(mimeType, \"'metadataMimeType' is required\");\n\t\tthis.defaultMetadataMimeType = mimeType;\n\t}\n\n\t/**\n\t * Return the configured\n\t * {@link #setDefaultMetadataMimeType defaultMetadataMimeType}.\n\t */\n\tpublic MimeType getDefaultMetadataMimeType() {\n\t\treturn this.defaultMetadataMimeType;\n\t}\n\n\n\t@Override\n\tpublic void afterPropertiesSet() {\n\n\t\t// Add argument resolver before parent initializes argument resolution\n\t\tgetArgumentResolverConfigurer().addCustomResolver(new RSocketRequesterMethodArgumentResolver());\n\n\t\tsuper.afterPropertiesSet();\n\n\t\tgetHandlerMethods().forEach((composite, handler) -> {\n\t\t\tif (composite.getMessageConditions().contains(RSocketFrameTypeMessageCondition.CONNECT_CONDITION)) {\n\t\t\t\tMethodParameter returnType = handler.getReturnType();\n\t\t\t\tif (getCardinality(returnType) > 0) {\n\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\"Invalid @ConnectMapping method. \" +\n\t\t\t\t\t\t\t\t\t\"Return type must be void or a void async type: \" + handler);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t@Override\n\tprotected List<? extends HandlerMethodReturnValueHandler> initReturnValueHandlers() {\n\t\tList<HandlerMethodReturnValueHandler> handlers = new ArrayList<>();\n\t\thandlers.add(new RSocketPayloadReturnValueHandler(this.encoders, getReactiveAdapterRegistry()));\n\t\thandlers.addAll(getReturnValueHandlerConfigurer().getCustomHandlers());\n\t\treturn handlers;\n\t}\n\n\n\t@Override\n\t@Nullable\n\tprotected CompositeMessageCondition getCondition(AnnotatedElement element) {\n\t\tMessageMapping ann1 = AnnotatedElementUtils.findMergedAnnotation(element, MessageMapping.class);\n\t\tif (ann1 != null && ann1.value().length > 0) {\n\t\t\treturn new CompositeMessageCondition(\n\t\t\t\t\tRSocketFrameTypeMessageCondition.EMPTY_CONDITION,\n\t\t\t\t\tnew DestinationPatternsMessageCondition(processDestinations(ann1.value()), obtainRouteMatcher()));\n\t\t}\n\t\tConnectMapping ann2 = AnnotatedElementUtils.findMergedAnnotation(element, ConnectMapping.class);\n\t\tif (ann2 != null) {\n\t\t\tString[] patterns = processDestinations(ann2.value());\n\t\t\treturn new CompositeMessageCondition(\n\t\t\t\t\tRSocketFrameTypeMessageCondition.CONNECT_CONDITION,\n\t\t\t\t\tnew DestinationPatternsMessageCondition(patterns, obtainRouteMatcher()));\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tprotected CompositeMessageCondition extendMapping(CompositeMessageCondition composite, HandlerMethod handler) {\n\n\t\tList<MessageCondition<?>> conditions = composite.getMessageConditions();\n\t\tAssert.isTrue(conditions.size() == 2 &&\n\t\t\t\t\t\tconditions.get(0) instanceof RSocketFrameTypeMessageCondition &&\n\t\t\t\t\t\tconditions.get(1) instanceof DestinationPatternsMessageCondition,\n\t\t\t\t\"Unexpected message condition types\");\n\n\t\tif (conditions.get(0) != RSocketFrameTypeMessageCondition.EMPTY_CONDITION) {\n\t\t\treturn composite;\n\t\t}\n\n\t\tint responseCardinality = getCardinality(handler.getReturnType());\n\t\tint requestCardinality = 0;\n\t\tfor (MethodParameter parameter : handler.getMethodParameters()) {\n\t\t\tif (getArgumentResolvers().getArgumentResolver(parameter) instanceof PayloadMethodArgumentResolver) {\n\t\t\t\trequestCardinality = getCardinality(parameter);\n\t\t\t}\n\t\t}\n\n\t\treturn new CompositeMessageCondition(\n\t\t\t\tRSocketFrameTypeMessageCondition.getCondition(requestCardinality, responseCardinality),\n\t\t\t\tconditions.get(1));\n\t}\n\n\tprivate int getCardinality(MethodParameter parameter) {\n\t\tClass<?> clazz = parameter.getParameterType();\n\t\tReactiveAdapter adapter = getReactiveAdapterRegistry().getAdapter(clazz);\n\t\tif (adapter == null) {\n\t\t\treturn clazz.equals(void.class) ? 0 : 1;\n\t\t}\n\t\telse if (parameter.nested().getNestedParameterType().equals(Void.class)) {\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn adapter.isMultiValue() ? 2 : 1;\n\t\t}\n\t}\n\n\t@Override\n\tprotected void handleNoMatch(@Nullable RouteMatcher.Route destination, Message<?> message) {\n\t\tFrameType frameType = RSocketFrameTypeMessageCondition.getFrameType(message);\n\t\tif (frameType == FrameType.SETUP || frameType == FrameType.METADATA_PUSH) {\n\t\t\treturn;  // optional handling\n\t\t}\n\t\tif (frameType == FrameType.REQUEST_FNF) {\n\t\t\t// Can't propagate error to client, so just log\n\t\t\tlogger.warn(\"No handler for fireAndForget to '\" + destination + \"'\");\n\t\t\treturn;\n\t\t}\n\n\t\tSet<FrameType> frameTypes = getHandlerMethods().keySet().stream()\n\t\t\t\t.map(CompositeMessageCondition::getMessageConditions)\n\t\t\t\t.filter(conditions -> conditions.get(1).getMatchingCondition(message) != null)\n\t\t\t\t.map(conditions -> (RSocketFrameTypeMessageCondition) conditions.get(0))\n\t\t\t\t.flatMap(condition -> condition.getFrameTypes().stream())\n\t\t\t\t.collect(Collectors.toSet());\n\n\t\tthrow new MessageDeliveryException(frameTypes.isEmpty() ?\n\t\t\t\t\"No handler for destination '\" + destination + \"'\" :\n\t\t\t\t\"Destination '\" + destination + \"' does not support \" + frameType + \". \" +\n\t\t\t\t\t\t\"Supported interaction(s): \" + frameTypes);\n\t}\n\n\t/**\n\t * Return an RSocket {@link SocketAcceptor} backed by this\n\t * {@code RSocketMessageHandler} instance that can be plugged in as a\n\t * {@link io.rsocket.core.RSocketConnector#acceptor(SocketAcceptor) client} or\n\t * {@link io.rsocket.core.RSocketServer#acceptor(SocketAcceptor) server}\n\t * RSocket responder.\n\t * <p>The initial {@link ConnectionSetupPayload} is handled through\n\t * {@link ConnectMapping @ConnectionMapping} methods that can be asynchronous\n\t * and return {@code Mono<Void>} with an error signal preventing the\n\t * connection. Such a method can also start requests to the client but that\n\t * must be done decoupled from handling and from the current thread.\n\t * <p>Subsequent requests on the connection can be handled with\n\t * {@link MessageMapping MessageMapping} methods.\n\t */\n\tpublic SocketAcceptor responder() {\n\t\treturn (setupPayload, sendingRSocket) -> {\n\t\t\tMessagingRSocket responder;\n\t\t\ttry {\n\t\t\t\tresponder = createResponder(setupPayload, sendingRSocket);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\treturn Mono.error(ex);\n\t\t\t}\n\t\t\treturn responder.handleConnectionSetupPayload(setupPayload).then(Mono.just(responder));\n\t\t};\n\t}\n\n\tprivate MessagingRSocket createResponder(ConnectionSetupPayload setupPayload, RSocket rsocket) {\n\t\tString str = setupPayload.dataMimeType();\n\t\tMimeType dataMimeType = StringUtils.hasText(str) ? MimeTypeUtils.parseMimeType(str) : this.defaultDataMimeType;\n\t\tAssert.notNull(dataMimeType, \"No `dataMimeType` in ConnectionSetupPayload and no default value\");\n\t\tAssert.isTrue(isDataMimeTypeSupported(dataMimeType), () -> \"Data MimeType '\" + dataMimeType + \"' not supported\");\n\n\t\tstr = setupPayload.metadataMimeType();\n\t\tMimeType metaMimeType = StringUtils.hasText(str) ? MimeTypeUtils.parseMimeType(str) : this.defaultMetadataMimeType;\n\t\tAssert.notNull(metaMimeType, \"No `metadataMimeType` in ConnectionSetupPayload and no default value\");\n\n\t\tRSocketRequester requester = RSocketRequester.wrap(rsocket, dataMimeType, metaMimeType, this.strategies);\n\t\treturn new MessagingRSocket(dataMimeType, metaMimeType, getMetadataExtractor(),\n\t\t\t\trequester, this, obtainRouteMatcher(), this.strategies);\n\t}\n\n\tprivate boolean isDataMimeTypeSupported(MimeType dataMimeType) {\n\t\tfor (Encoder<?> encoder : getEncoders()) {\n\t\t\tfor (MimeType encodable : encoder.getEncodableMimeTypes()) {\n\t\t\t\tif (encodable.isCompatibleWith(dataMimeType)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Static factory method to create an RSocket {@link SocketAcceptor}\n\t * backed by handlers with annotated methods. Effectively a shortcut for:\n\t * <pre class=\"code\">\n\t * RSocketMessageHandler handler = new RSocketMessageHandler();\n\t * handler.setHandlers(handlers);\n\t * handler.setRSocketStrategies(strategies);\n\t * handler.afterPropertiesSet();\n\t *\n\t * SocketAcceptor acceptor = handler.responder();\n\t * </pre>\n\t * <p>This is intended for programmatic creation and registration of a\n\t * client-side responder. For example:\n\t * <pre class=\"code\">\n\t * SocketAcceptor responder =\n\t *         RSocketMessageHandler.responder(strategies, new ClientHandler());\n\t *\n\t * RSocketRequester.builder()\n\t *         .rsocketConnector(connector -&gt; connector.acceptor(responder))\n\t *         .connectTcp(\"localhost\", server.address().getPort());\n\t * </pre>\n\t *\n\t * <p>Note that the given handlers do not need to have any stereotype\n\t * annotations such as {@code @Controller} which helps to avoid overlap with\n\t * server side handlers that may be used in the same application. However,\n\t * for more advanced scenarios, e.g. discovering handlers through a custom\n\t * stereotype annotation, consider declaring {@code RSocketMessageHandler}\n\t * as a bean, and then obtain the responder from it.\n\t * @param strategies the strategies to set on the created\n\t * {@code RSocketMessageHandler}\n\t * @param candidateHandlers a list of Objects and/or Classes with annotated\n\t * handler methods; used to call {@link #setHandlers(List)} with\n\t * on the created {@code RSocketMessageHandler}\n\t * @return a configurer that may be passed into\n\t * {@link org.springframework.messaging.rsocket.RSocketRequester.Builder#rsocketConnector}\n\t * @since 5.2.6\n\t */\n\tpublic static SocketAcceptor responder(RSocketStrategies strategies, Object... candidateHandlers) {\n\t\tAssert.notEmpty(candidateHandlers, \"No handlers\");\n\t\tList<Object> handlers = new ArrayList<>(candidateHandlers.length);\n\t\tfor (Object obj : candidateHandlers) {\n\t\t\thandlers.add(obj instanceof Class<?> clazz ? BeanUtils.instantiateClass(clazz) : obj);\n\t\t}\n\t\tRSocketMessageHandler handler = new RSocketMessageHandler();\n\t\thandler.setHandlers(handlers);\n\t\thandler.setRSocketStrategies(strategies);\n\t\thandler.afterPropertiesSet();\n\t\treturn handler.responder();\n\t}\n\n}"
  },
  "org.springframework.messaging.rsocket.annotation.support.RSocketMessageHandler#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\n\t\t// Add argument resolver before parent initializes argument resolution\n\t\tgetArgumentResolverConfigurer().addCustomResolver(new RSocketRequesterMethodArgumentResolver());\n\n\t\tsuper.afterPropertiesSet();\n\n\t\tgetHandlerMethods().forEach((composite, handler) -> {\n\t\t\tif (composite.getMessageConditions().contains(RSocketFrameTypeMessageCondition.CONNECT_CONDITION)) {\n\t\t\t\tMethodParameter returnType = handler.getReturnType();\n\t\t\t\tif (getCardinality(returnType) > 0) {\n\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\"Invalid @ConnectMapping method. \" +\n\t\t\t\t\t\t\t\t\t\"Return type must be void or a void async type: \" + handler);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.RSocketMessageHandler#extendMapping(composite,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "composite",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 329
    },
    "return": "CompositeMessageCondition",
    "signature": "protected CompositeMessageCondition extendMapping(CompositeMessageCondition composite, HandlerMethod handler)",
    "source_code": "\tprotected CompositeMessageCondition extendMapping(CompositeMessageCondition composite, HandlerMethod handler) {\n\n\t\tList<MessageCondition<?>> conditions = composite.getMessageConditions();\n\t\tAssert.isTrue(conditions.size() == 2 &&\n\t\t\t\t\t\tconditions.get(0) instanceof RSocketFrameTypeMessageCondition &&\n\t\t\t\t\t\tconditions.get(1) instanceof DestinationPatternsMessageCondition,\n\t\t\t\t\"Unexpected message condition types\");\n\n\t\tif (conditions.get(0) != RSocketFrameTypeMessageCondition.EMPTY_CONDITION) {\n\t\t\treturn composite;\n\t\t}\n\n\t\tint responseCardinality = getCardinality(handler.getReturnType());\n\t\tint requestCardinality = 0;\n\t\tfor (MethodParameter parameter : handler.getMethodParameters()) {\n\t\t\tif (getArgumentResolvers().getArgumentResolver(parameter) instanceof PayloadMethodArgumentResolver) {\n\t\t\t\trequestCardinality = getCardinality(parameter);\n\t\t\t}\n\t\t}\n\n\t\treturn new CompositeMessageCondition(\n\t\t\t\tRSocketFrameTypeMessageCondition.getCondition(requestCardinality, responseCardinality),\n\t\t\t\tconditions.get(1));\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.RSocketMessageHandler#getCondition(element)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "element"
    ],
    "position": {
      "column": 1,
      "line": 311
    },
    "return": "CompositeMessageCondition",
    "signature": "protected CompositeMessageCondition getCondition(AnnotatedElement element)",
    "source_code": "\tprotected CompositeMessageCondition getCondition(AnnotatedElement element) {\n\t\tMessageMapping ann1 = AnnotatedElementUtils.findMergedAnnotation(element, MessageMapping.class);\n\t\tif (ann1 != null && ann1.value().length > 0) {\n\t\t\treturn new CompositeMessageCondition(\n\t\t\t\t\tRSocketFrameTypeMessageCondition.EMPTY_CONDITION,\n\t\t\t\t\tnew DestinationPatternsMessageCondition(processDestinations(ann1.value()), obtainRouteMatcher()));\n\t\t}\n\t\tConnectMapping ann2 = AnnotatedElementUtils.findMergedAnnotation(element, ConnectMapping.class);\n\t\tif (ann2 != null) {\n\t\t\tString[] patterns = processDestinations(ann2.value());\n\t\t\treturn new CompositeMessageCondition(\n\t\t\t\t\tRSocketFrameTypeMessageCondition.CONNECT_CONDITION,\n\t\t\t\t\tnew DestinationPatternsMessageCondition(patterns, obtainRouteMatcher()));\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.RSocketMessageHandler#getDefaultDataMimeType()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured\n\t * {@link #setDefaultDataMimeType defaultDataMimeType}, or {@code null}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "MimeType",
    "signature": "public MimeType getDefaultDataMimeType()",
    "source_code": "\tpublic MimeType getDefaultDataMimeType() {\n\t\treturn this.defaultDataMimeType;\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.RSocketMessageHandler#getDefaultMetadataMimeType()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured\n\t * {@link #setDefaultMetadataMimeType defaultMetadataMimeType}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 275
    },
    "return": "MimeType",
    "signature": "public MimeType getDefaultMetadataMimeType()",
    "source_code": "\tpublic MimeType getDefaultMetadataMimeType() {\n\t\treturn this.defaultMetadataMimeType;\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.RSocketMessageHandler#getMetadataExtractor()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured {@link #setMetadataExtractor MetadataExtractor}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "MetadataExtractor",
    "signature": "public MetadataExtractor getMetadataExtractor()",
    "source_code": "\tpublic MetadataExtractor getMetadataExtractor() {\n\t\treturn this.strategies.metadataExtractor();\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.RSocketMessageHandler#getRSocketStrategies()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link #setRSocketStrategies configured} {@code RSocketStrategies}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "RSocketStrategies",
    "signature": "public RSocketStrategies getRSocketStrategies()",
    "source_code": "\tpublic RSocketStrategies getRSocketStrategies() {\n\t\treturn this.strategies;\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.RSocketMessageHandler#handleNoMatch(destination,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "destination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 369
    },
    "return": "void",
    "signature": "protected void handleNoMatch(@Nullable RouteMatcher.Route destination, Message<?> message)",
    "source_code": "\tprotected void handleNoMatch(@Nullable RouteMatcher.Route destination, Message<?> message) {\n\t\tFrameType frameType = RSocketFrameTypeMessageCondition.getFrameType(message);\n\t\tif (frameType == FrameType.SETUP || frameType == FrameType.METADATA_PUSH) {\n\t\t\treturn;  // optional handling\n\t\t}\n\t\tif (frameType == FrameType.REQUEST_FNF) {\n\t\t\t// Can't propagate error to client, so just log\n\t\t\tlogger.warn(\"No handler for fireAndForget to '\" + destination + \"'\");\n\t\t\treturn;\n\t\t}\n\n\t\tSet<FrameType> frameTypes = getHandlerMethods().keySet().stream()\n\t\t\t\t.map(CompositeMessageCondition::getMessageConditions)\n\t\t\t\t.filter(conditions -> conditions.get(1).getMatchingCondition(message) != null)\n\t\t\t\t.map(conditions -> (RSocketFrameTypeMessageCondition) conditions.get(0))\n\t\t\t\t.flatMap(condition -> condition.getFrameTypes().stream())\n\t\t\t\t.collect(Collectors.toSet());\n\n\t\tthrow new MessageDeliveryException(frameTypes.isEmpty() ?\n\t\t\t\t\"No handler for destination '\" + destination + \"'\" :\n\t\t\t\t\"Destination '\" + destination + \"' does not support \" + frameType + \". \" +\n\t\t\t\t\t\t\"Supported interaction(s): \" + frameTypes);\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.RSocketMessageHandler#responder()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return an RSocket {@link SocketAcceptor} backed by this\n\t * {@code RSocketMessageHandler} instance that can be plugged in as a\n\t * {@link io.rsocket.core.RSocketConnector#acceptor(SocketAcceptor) client} or\n\t * {@link io.rsocket.core.RSocketServer#acceptor(SocketAcceptor) server}\n\t * RSocket responder.\n\t * <p>The initial {@link ConnectionSetupPayload} is handled through\n\t * {@link ConnectMapping @ConnectionMapping} methods that can be asynchronous\n\t * and return {@code Mono<Void>} with an error signal preventing the\n\t * connection. Such a method can also start requests to the client but that\n\t * must be done decoupled from handling and from the current thread.\n\t * <p>Subsequent requests on the connection can be handled with\n\t * {@link MessageMapping MessageMapping} methods.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 407
    },
    "return": "SocketAcceptor",
    "signature": "public SocketAcceptor responder()",
    "source_code": "\tpublic SocketAcceptor responder() {\n\t\treturn (setupPayload, sendingRSocket) -> {\n\t\t\tMessagingRSocket responder;\n\t\t\ttry {\n\t\t\t\tresponder = createResponder(setupPayload, sendingRSocket);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\treturn Mono.error(ex);\n\t\t\t}\n\t\t\treturn responder.handleConnectionSetupPayload(setupPayload).then(Mono.just(responder));\n\t\t};\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.RSocketMessageHandler#responder(strategies,candidateHandlers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create an RSocket {@link SocketAcceptor}\n\t * backed by handlers with annotated methods. Effectively a shortcut for:\n\t * <pre class=\"code\">\n\t * RSocketMessageHandler handler = new RSocketMessageHandler();\n\t * handler.setHandlers(handlers);\n\t * handler.setRSocketStrategies(strategies);\n\t * handler.afterPropertiesSet();\n\t *\n\t * SocketAcceptor acceptor = handler.responder();\n\t * </pre>\n\t * <p>This is intended for programmatic creation and registration of a\n\t * client-side responder. For example:\n\t * <pre class=\"code\">\n\t * SocketAcceptor responder =\n\t *         RSocketMessageHandler.responder(strategies, new ClientHandler());\n\t *\n\t * RSocketRequester.builder()\n\t *         .rsocketConnector(connector -&gt; connector.acceptor(responder))\n\t *         .connectTcp(\"localhost\", server.address().getPort());\n\t * </pre>\n\t *\n\t * <p>Note that the given handlers do not need to have any stereotype\n\t * annotations such as {@code @Controller} which helps to avoid overlap with\n\t * server side handlers that may be used in the same application. However,\n\t * for more advanced scenarios, e.g. discovering handlers through a custom\n\t * stereotype annotation, consider declaring {@code RSocketMessageHandler}\n\t * as a bean, and then obtain the responder from it.\n\t * @param strategies the strategies to set on the created\n\t * {@code RSocketMessageHandler}\n\t * @param candidateHandlers a list of Objects and/or Classes with annotated\n\t * handler methods; used to call {@link #setHandlers(List)} with\n\t * on the created {@code RSocketMessageHandler}\n\t * @return a configurer that may be passed into\n\t * {@link org.springframework.messaging.rsocket.RSocketRequester.Builder#rsocketConnector}\n\t * @since 5.2.6\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "strategies",
      "candidateHandlers"
    ],
    "position": {
      "column": 1,
      "line": 483
    },
    "return": "SocketAcceptor",
    "signature": "public SocketAcceptor responder(RSocketStrategies strategies, Object... candidateHandlers)",
    "source_code": "\tpublic static SocketAcceptor responder(RSocketStrategies strategies, Object... candidateHandlers) {\n\t\tAssert.notEmpty(candidateHandlers, \"No handlers\");\n\t\tList<Object> handlers = new ArrayList<>(candidateHandlers.length);\n\t\tfor (Object obj : candidateHandlers) {\n\t\t\thandlers.add(obj instanceof Class<?> clazz ? BeanUtils.instantiateClass(clazz) : obj);\n\t\t}\n\t\tRSocketMessageHandler handler = new RSocketMessageHandler();\n\t\thandler.setHandlers(handlers);\n\t\thandler.setRSocketStrategies(strategies);\n\t\thandler.afterPropertiesSet();\n\t\treturn handler.responder();\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.RSocketMessageHandler#setDecoders(decoders)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p>When {@link #setRSocketStrategies(RSocketStrategies) rsocketStrategies}\n\t * is set, this property is re-initialized with the decoders in it, and\n\t * likewise when this property is set the {@code RSocketStrategies} are\n\t * mutated to change the decoders in them.\n\t * <p>By default this is set to the\n\t * {@linkplain org.springframework.messaging.rsocket.RSocketStrategies.Builder#decoder(Decoder[]) defaults}\n\t * from {@code RSocketStrategies}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "decoders"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "void",
    "signature": "public void setDecoders(List<? extends Decoder<?>> decoders)",
    "source_code": "\tpublic void setDecoders(List<? extends Decoder<?>> decoders) {\n\t\tsuper.setDecoders(decoders);\n\t\tthis.strategies = this.strategies.mutate()\n\t\t\t\t.decoders(list -> {\n\t\t\t\t\tlist.clear();\n\t\t\t\t\tlist.addAll(decoders);\n\t\t\t\t})\n\t\t\t\t.build();\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.RSocketMessageHandler#setDefaultDataMimeType(mimeType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the default content type to use for data payloads if the\n\t * {@code SETUP} frame did not specify one.\n\t * <p>By default this is not set.\n\t * @param mimeType the MimeType to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 247
    },
    "return": "void",
    "signature": "public void setDefaultDataMimeType(@Nullable MimeType mimeType)",
    "source_code": "\tpublic void setDefaultDataMimeType(@Nullable MimeType mimeType) {\n\t\tthis.defaultDataMimeType = mimeType;\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.RSocketMessageHandler#setDefaultMetadataMimeType(mimeType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the default {@code MimeType} for payload data if the\n\t * {@code SETUP} frame did not specify one.\n\t * <p>By default this is set to {@code \"message/x.rsocket.composite-metadata.v0\"}\n\t * @param mimeType the MimeType to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "void",
    "signature": "public void setDefaultMetadataMimeType(MimeType mimeType)",
    "source_code": "\tpublic void setDefaultMetadataMimeType(MimeType mimeType) {\n\t\tAssert.notNull(mimeType, \"'metadataMimeType' is required\");\n\t\tthis.defaultMetadataMimeType = mimeType;\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.RSocketMessageHandler#setEncoders(encoders)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the encoders to use for encoding handler method return values.\n\t * <p>When {@link #setRSocketStrategies(RSocketStrategies) rsocketStrategies}\n\t * is set, this property is re-initialized with the encoders in it, and\n\t * likewise when this property is set the {@code RSocketStrategies} are\n\t * mutated to change the encoders in it.\n\t * <p>By default this is set to the\n\t * {@linkplain org.springframework.messaging.rsocket.RSocketStrategies.Builder#encoder(Encoder[]) defaults}\n\t * from {@code RSocketStrategies}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encoders"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "void",
    "signature": "public void setEncoders(List<? extends Encoder<?>> encoders)",
    "source_code": "\tpublic void setEncoders(List<? extends Encoder<?>> encoders) {\n\t\tthis.encoders.clear();\n\t\tthis.encoders.addAll(encoders);\n\t\tthis.strategies = this.strategies.mutate()\n\t\t\t\t.encoders(list -> {\n\t\t\t\t\tlist.clear();\n\t\t\t\t\tlist.addAll(encoders);\n\t\t\t\t})\n\t\t\t\t.build();\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.RSocketMessageHandler#setMetadataExtractor(extractor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a {@link MetadataExtractor} to extract the route along with\n\t * other metadata.\n\t * <p>When {@link #setRSocketStrategies(RSocketStrategies) rsocketStrategies}\n\t * is set, this property is re-initialized with the extractor in it, and\n\t * likewise when this property is set the {@code RSocketStrategies} are\n\t * mutated to change the extractor in it.\n\t * <p>By default this is set to the\n\t * {@link org.springframework.messaging.rsocket.RSocketStrategies.Builder#metadataExtractor(MetadataExtractor) defaults}\n\t * from {@code RSocketStrategies}.\n\t * @param extractor the extractor to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "extractor"
    ],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "void",
    "signature": "public void setMetadataExtractor(MetadataExtractor extractor)",
    "source_code": "\tpublic void setMetadataExtractor(MetadataExtractor extractor) {\n\t\tthis.strategies = this.strategies.mutate().metadataExtractor(extractor).build();\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.RSocketMessageHandler#setRSocketStrategies(rsocketStrategies)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure this handler through an {@link RSocketStrategies} instance which\n\t * can be re-used to initialize a client-side {@link RSocketRequester}.\n\t * <p>When this property is set, in turn it sets the following:\n\t * <ul>\n\t * <li>{@link #setDecoders(List)}\n\t * <li>{@link #setEncoders(List)}\n\t * <li>{@link #setRouteMatcher(RouteMatcher)}\n\t * <li>{@link #setMetadataExtractor(MetadataExtractor)}\n\t * <li>{@link #setReactiveAdapterRegistry(ReactiveAdapterRegistry)}\n\t * </ul>\n\t * <p>By default this is set to {@link RSocketStrategies#create()} which in\n\t * turn sets default settings for all related properties.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rsocketStrategies"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "void",
    "signature": "public void setRSocketStrategies(RSocketStrategies rsocketStrategies)",
    "source_code": "\tpublic void setRSocketStrategies(RSocketStrategies rsocketStrategies) {\n\t\tthis.strategies = rsocketStrategies;\n\t\tthis.encoders.clear();\n\t\tthis.encoders.addAll(this.strategies.encoders());\n\t\tsuper.setDecoders(this.strategies.decoders());\n\t\tsuper.setRouteMatcher(this.strategies.routeMatcher());\n\t\tsuper.setReactiveAdapterRegistry(this.strategies.reactiveAdapterRegistry());\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.RSocketMessageHandler#setReactiveAdapterRegistry(registry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the registry for adapting various reactive types.\n\t * <p>When {@link #setRSocketStrategies(RSocketStrategies) rsocketStrategies}\n\t * is set, this property is re-initialized with the registry in it, and\n\t * likewise when this property is set the {@code RSocketStrategies} are\n\t * mutated to change the registry in it.\n\t * <p>By default this is set to the\n\t * {@link org.springframework.messaging.rsocket.RSocketStrategies.Builder#reactiveAdapterStrategy(ReactiveAdapterRegistry) defaults}\n\t * from {@code RSocketStrategies}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "void",
    "signature": "public void setReactiveAdapterRegistry(ReactiveAdapterRegistry registry)",
    "source_code": "\tpublic void setReactiveAdapterRegistry(ReactiveAdapterRegistry registry) {\n\t\tsuper.setReactiveAdapterRegistry(registry);\n\t\tthis.strategies = this.strategies.mutate().reactiveAdapterStrategy(registry).build();\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.RSocketMessageHandler#setRouteMatcher(routeMatcher)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p>When {@link #setRSocketStrategies(RSocketStrategies) rsocketStrategies}\n\t * is set, this property is re-initialized with the route matcher in it, and\n\t * likewise when this property is set the {@code RSocketStrategies} are\n\t * mutated to change the matcher in it.\n\t * <p>By default this is set to the\n\t * {@linkplain org.springframework.messaging.rsocket.RSocketStrategies.Builder#routeMatcher(RouteMatcher) defaults}\n\t * from {@code RSocketStrategies}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "routeMatcher"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "void",
    "signature": "public void setRouteMatcher(@Nullable RouteMatcher routeMatcher)",
    "source_code": "\tpublic void setRouteMatcher(@Nullable RouteMatcher routeMatcher) {\n\t\tsuper.setRouteMatcher(routeMatcher);\n\t\tthis.strategies = this.strategies.mutate().routeMatcher(routeMatcher).build();\n\t}"
  },
  "org.springframework.messaging.rsocket.service.DestinationVariableArgumentResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link RSocketServiceArgumentResolver} for a\n * {@link DestinationVariable @DestinationVariable} annotated argument.\n *\n * <p>The argument is treated as a single route variable, or in case of a\n * Collection or an array, as multiple route variables.\n *\n * @author Rossen Stoyanchev\n * @since 6.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 35
    },
    "signature": "public class DestinationVariableArgumentResolver",
    "source_code": "public class DestinationVariableArgumentResolver implements RSocketServiceArgumentResolver {\n\n\t@Override\n\tpublic boolean resolve(\n\t\t\t@Nullable Object argument, MethodParameter parameter, RSocketRequestValues.Builder requestValues) {\n\n\t\tDestinationVariable annot = parameter.getParameterAnnotation(DestinationVariable.class);\n\t\tif (annot == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (argument != null) {\n\t\t\tif (argument instanceof Collection<?> collection) {\n\t\t\t\tcollection.forEach(requestValues::addRouteVariable);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (argument.getClass().isArray()) {\n\t\t\t\tfor (Object variable : (Object[]) argument) {\n\t\t\t\t\trequestValues.addRouteVariable(variable);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\trequestValues.addRouteVariable(argument);\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n}"
  },
  "org.springframework.messaging.rsocket.service.DestinationVariableArgumentResolver#resolve(argument,parameter,requestValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argument",
      "parameter",
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "return": "boolean",
    "signature": "public boolean resolve(@Nullable Object argument, MethodParameter parameter, RSocketRequestValues.Builder requestValues)",
    "source_code": "\tpublic boolean resolve("
  },
  "org.springframework.messaging.simp.SimpMessageMappingInfo": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link MessageCondition} for SImple Messaging Protocols. Encapsulates the following\n * request mapping conditions:\n * <ol>\n * <li>{@link SimpMessageTypeMessageCondition}\n * <li>{@link DestinationPatternsMessageCondition}\n * </ol>\n *\n * @author Rossen Stoyanchev\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 36
    },
    "signature": "public class SimpMessageMappingInfo",
    "source_code": "public class SimpMessageMappingInfo implements MessageCondition<SimpMessageMappingInfo> {\n\n\tprivate final CompositeMessageCondition delegate;\n\n\n\tpublic SimpMessageMappingInfo(SimpMessageTypeMessageCondition messageTypeMessageCondition,\n\t\t\tDestinationPatternsMessageCondition destinationConditions) {\n\n\t\tthis.delegate = new CompositeMessageCondition(messageTypeMessageCondition, destinationConditions);\n\t}\n\n\tprivate SimpMessageMappingInfo(CompositeMessageCondition delegate) {\n\t\tthis.delegate = delegate;\n\t}\n\n\n\tpublic SimpMessageTypeMessageCondition getMessageTypeMessageCondition() {\n\t\treturn this.delegate.getCondition(SimpMessageTypeMessageCondition.class);\n\t}\n\n\tpublic DestinationPatternsMessageCondition getDestinationConditions() {\n\t\treturn this.delegate.getCondition(DestinationPatternsMessageCondition.class);\n\t}\n\n\n\t@Override\n\tpublic SimpMessageMappingInfo combine(SimpMessageMappingInfo other) {\n\t\treturn new SimpMessageMappingInfo(this.delegate.combine(other.delegate));\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic SimpMessageMappingInfo getMatchingCondition(Message<?> message) {\n\t\tCompositeMessageCondition condition = this.delegate.getMatchingCondition(message);\n\t\treturn condition != null ? new SimpMessageMappingInfo(condition) : null;\n\t}\n\n\t@Override\n\tpublic int compareTo(SimpMessageMappingInfo other, Message<?> message) {\n\t\treturn this.delegate.compareTo(other.delegate, message);\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj) || (obj instanceof SimpMessageMappingInfo that && this.delegate.equals(that.delegate));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.delegate.hashCode();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn this.delegate.toString();\n\t}\n\n}"
  },
  "org.springframework.messaging.simp.SimpMessageMappingInfo#combine(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "SimpMessageMappingInfo",
    "signature": "public SimpMessageMappingInfo combine(SimpMessageMappingInfo other)",
    "source_code": "\tpublic SimpMessageMappingInfo combine(SimpMessageMappingInfo other) {\n\t\treturn new SimpMessageMappingInfo(this.delegate.combine(other.delegate));\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessageMappingInfo#compareTo(other,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "int",
    "signature": "public int compareTo(SimpMessageMappingInfo other, Message<?> message)",
    "source_code": "\tpublic int compareTo(SimpMessageMappingInfo other, Message<?> message) {\n\t\treturn this.delegate.compareTo(other.delegate, message);\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessageMappingInfo#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj) || (obj instanceof SimpMessageMappingInfo that && this.delegate.equals(that.delegate));\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessageMappingInfo#getDestinationConditions()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "DestinationPatternsMessageCondition",
    "signature": "public DestinationPatternsMessageCondition getDestinationConditions()",
    "source_code": "\tpublic DestinationPatternsMessageCondition getDestinationConditions() {\n\t\treturn this.delegate.getCondition(DestinationPatternsMessageCondition.class);\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessageMappingInfo#getMatchingCondition(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "SimpMessageMappingInfo",
    "signature": "public SimpMessageMappingInfo getMatchingCondition(Message<?> message)",
    "source_code": "\tpublic SimpMessageMappingInfo getMatchingCondition(Message<?> message) {\n\t\tCompositeMessageCondition condition = this.delegate.getMatchingCondition(message);\n\t\treturn condition != null ? new SimpMessageMappingInfo(condition) : null;\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessageMappingInfo#getMessageTypeMessageCondition()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "SimpMessageTypeMessageCondition",
    "signature": "public SimpMessageTypeMessageCondition getMessageTypeMessageCondition()",
    "source_code": "\tpublic SimpMessageTypeMessageCondition getMessageTypeMessageCondition() {\n\t\treturn this.delegate.getCondition(SimpMessageTypeMessageCondition.class);\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessageMappingInfo#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.delegate.hashCode();\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessageMappingInfo#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn this.delegate.toString();\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessagingTemplate": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * An implementation of\n * {@link org.springframework.messaging.simp.SimpMessageSendingOperations}.\n *\n * <p>Also provides methods for sending messages to a user. See\n * {@link org.springframework.messaging.simp.user.UserDestinationResolver\n * UserDestinationResolver}\n * for more on user destinations.\n *\n * @author Rossen Stoyanchev\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public class SimpMessagingTemplate",
    "source_code": "public class SimpMessagingTemplate extends AbstractMessageSendingTemplate<String>"
  },
  "org.springframework.messaging.simp.SimpMessagingTemplate#convertAndSendToUser(user,destination,payload)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "user",
      "destination",
      "payload"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "void",
    "signature": "public void convertAndSendToUser(String user, String destination, Object payload)",
    "source_code": "\tpublic void convertAndSendToUser(String user, String destination, Object payload) throws MessagingException {\n\t\tconvertAndSendToUser(user, destination, payload, (MessagePostProcessor) null);\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessagingTemplate#convertAndSendToUser(user,destination,payload,Map<String,headers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "user",
      "destination",
      "payload",
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "void",
    "signature": "public void convertAndSendToUser(String user, String destination, Object payload,\n\t\t\t@Nullable Map<String, Object> headers)",
    "source_code": "\tpublic void convertAndSendToUser(String user, String destination, Object payload,"
  },
  "org.springframework.messaging.simp.SimpMessagingTemplate#convertAndSendToUser(user,destination,payload,Map<String,headers,postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "user",
      "destination",
      "payload",
      "Map<String",
      "headers",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "void",
    "signature": "public void convertAndSendToUser(String user, String destination, Object payload,\n\t\t\t@Nullable Map<String, Object> headers, @Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSendToUser(String user, String destination, Object payload,"
  },
  "org.springframework.messaging.simp.SimpMessagingTemplate#convertAndSendToUser(user,destination,payload,postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "user",
      "destination",
      "payload",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "void",
    "signature": "public void convertAndSendToUser(String user, String destination, Object payload,\n\t\t\t@Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSendToUser(String user, String destination, Object payload,"
  },
  "org.springframework.messaging.simp.SimpMessagingTemplate#doSend(destination,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "destination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "void",
    "signature": "protected void doSend(String destination, Message<?> message)",
    "source_code": "\tprotected void doSend(String destination, Message<?> message) {\n\t\tAssert.notNull(destination, \"Destination must not be null\");\n\n\t\tSimpMessageHeaderAccessor simpAccessor =\n\t\t\t\tMessageHeaderAccessor.getAccessor(message, SimpMessageHeaderAccessor.class);\n\n\t\tif (simpAccessor != null) {\n\t\t\tif (simpAccessor.isMutable()) {\n\t\t\t\tsimpAccessor.setDestination(destination);\n\t\t\t\tsimpAccessor.setMessageTypeIfNotSet(SimpMessageType.MESSAGE);\n\t\t\t\tsimpAccessor.setImmutable();\n\t\t\t\tsendInternal(message);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Try and keep the original accessor type\n\t\t\t\tsimpAccessor = (SimpMessageHeaderAccessor) MessageHeaderAccessor.getMutableAccessor(message);\n\t\t\t\tinitHeaders(simpAccessor);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tsimpAccessor = SimpMessageHeaderAccessor.wrap(message);\n\t\t\tinitHeaders(simpAccessor);\n\t\t}\n\n\t\tsimpAccessor.setDestination(destination);\n\t\tsimpAccessor.setMessageTypeIfNotSet(SimpMessageType.MESSAGE);\n\t\tmessage = MessageBuilder.createMessage(message.getPayload(), simpAccessor.getMessageHeaders());\n\t\tsendInternal(message);\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessagingTemplate#getHeaderInitializer()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured header initializer.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "MessageHeaderInitializer",
    "signature": "public MessageHeaderInitializer getHeaderInitializer()",
    "source_code": "\tpublic MessageHeaderInitializer getHeaderInitializer() {\n\t\treturn this.headerInitializer;\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessagingTemplate#getMessageChannel()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured message channel.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "MessageChannel",
    "signature": "public MessageChannel getMessageChannel()",
    "source_code": "\tpublic MessageChannel getMessageChannel() {\n\t\treturn this.messageChannel;\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessagingTemplate#getSendTimeout()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured send timeout (in milliseconds).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "long",
    "signature": "public long getSendTimeout()",
    "source_code": "\tpublic long getSendTimeout() {\n\t\treturn this.sendTimeout;\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessagingTemplate#getUserDestinationPrefix()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured user destination prefix.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "String",
    "signature": "public String getUserDestinationPrefix()",
    "source_code": "\tpublic String getUserDestinationPrefix() {\n\t\treturn this.destinationPrefix;\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessagingTemplate#processHeadersToSend(Map<String,headers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Creates a new map and puts the given headers under the key\n\t * {@link NativeMessageHeaderAccessor#NATIVE_HEADERS NATIVE_HEADERS NATIVE_HEADERS NATIVE_HEADERS}.\n\t * effectively treats the input header map as headers to be sent out to the\n\t * destination.\n\t * <p>However if the given headers already contain the key\n\t * {@code NATIVE_HEADERS NATIVE_HEADERS} then the same headers instance is\n\t * returned without changes.\n\t * <p>Also if the given headers were prepared and obtained with\n\t * {@link SimpMessageHeaderAccessor#getMessageHeaders()} then the same headers\n\t * instance is also returned without changes.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "Object>",
    "signature": "protected Object> processHeadersToSend(@Nullable Map<String, Object> headers)",
    "source_code": "\tprotected Map<String, Object> processHeadersToSend(@Nullable Map<String, Object> headers) {\n\t\tif (headers == null) {\n\t\t\tSimpMessageHeaderAccessor headerAccessor = SimpMessageHeaderAccessor.create(SimpMessageType.MESSAGE);\n\t\t\tinitHeaders(headerAccessor);\n\t\t\theaderAccessor.setLeaveMutable(true);\n\t\t\treturn headerAccessor.getMessageHeaders();\n\t\t}\n\t\tif (headers.containsKey(NativeMessageHeaderAccessor.NATIVE_HEADERS)) {\n\t\t\treturn headers;\n\t\t}\n\t\tif (headers instanceof MessageHeaders messageHeaders) {\n\t\t\tSimpMessageHeaderAccessor accessor =\n\t\t\t\t\tMessageHeaderAccessor.getAccessor(messageHeaders, SimpMessageHeaderAccessor.class);\n\t\t\tif (accessor != null) {\n\t\t\t\treturn headers;\n\t\t\t}\n\t\t}\n\n\t\tSimpMessageHeaderAccessor headerAccessor = SimpMessageHeaderAccessor.create(SimpMessageType.MESSAGE);\n\t\tinitHeaders(headerAccessor);\n\t\theaders.forEach((key, value) -> headerAccessor.setNativeHeader(key, (value != null ? value.toString() : null)));\n\t\treturn headerAccessor.getMessageHeaders();\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessagingTemplate#send(message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * If the headers of the given message already contain a\n\t * {@link org.springframework.messaging.simp.SimpMessageHeaderAccessor#DESTINATION_HEADER\n\t * SimpMessageHeaderAccessor#DESTINATION_HEADER} then the message is sent without\n\t * further changes.\n\t * <p>If a destination header is not already present ,the message is sent\n\t * to the configured {@link #setDefaultDestination(Object) defaultDestination}\n\t * or an exception an {@code IllegalStateException} is raised if that isn't\n\t * configured.\n\t * @param message the message to send (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "void",
    "signature": "public void send(Message<?> message)",
    "source_code": "\tpublic void send(Message<?> message) {\n\t\tAssert.notNull(message, \"Message must not be null\");\n\t\tString destination = SimpMessageHeaderAccessor.getDestination(message.getHeaders());\n\t\tif (destination != null) {\n\t\t\tsendInternal(message);\n\t\t\treturn;\n\t\t}\n\t\tdoSend(getRequiredDefaultDestination(), message);\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessagingTemplate#setHeaderInitializer(headerInitializer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a {@link MessageHeaderInitializer} to apply to the headers of all\n\t * messages created through the {@code SimpMessagingTemplate}.\n\t * <p>By default, this property is not set.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerInitializer"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "void",
    "signature": "public void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer)",
    "source_code": "\tpublic void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer) {\n\t\tthis.headerInitializer = headerInitializer;\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessagingTemplate#setSendTimeout(sendTimeout)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the timeout value to use for send operations (in milliseconds).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sendTimeout"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "void",
    "signature": "public void setSendTimeout(long sendTimeout)",
    "source_code": "\tpublic void setSendTimeout(long sendTimeout) {\n\t\tthis.sendTimeout = sendTimeout;\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessagingTemplate#setUserDestinationPrefix(prefix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the prefix to use for destinations targeting a specific user.\n\t * <p>The default value is \"/user/\".\n\t * @see org.springframework.messaging.simp.user.UserDestinationMessageHandler\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "prefix"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void setUserDestinationPrefix(String prefix)",
    "source_code": "\tpublic void setUserDestinationPrefix(String prefix) {\n\t\tAssert.hasText(prefix, \"User destination prefix must not be empty\");\n\t\tthis.destinationPrefix = (prefix.endsWith(\"/\") ? prefix : prefix + \"/\");\n\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A {@link HandlerMethodReturnValueHandler} for sending to destinations specified in a\n * {@link SendTo} or {@link SendToUser} method-level annotations.\n *\n * <p>The value returned from the method is converted, and turned to a {@link Message} and\n * sent through the provided {@link MessageChannel}. The message is then enriched with the\n * session id of the input message as well as the destination from the annotation(s).\n * If multiple destinations are specified, a copy of the message is sent to each destination.\n *\n * @author Rossen Stoyanchev\n * @author Sebastien Deleuze\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "signature": "public class SendToMethodReturnValueHandler",
    "source_code": "public class SendToMethodReturnValueHandler implements HandlerMethodReturnValueHandler {\n\n\tprivate final SimpMessageSendingOperations messagingTemplate;\n\n\tprivate final boolean annotationRequired;\n\n\tprivate String defaultDestinationPrefix = \"/topic\";\n\n\tprivate String defaultUserDestinationPrefix = \"/queue\";\n\n\tprivate final PropertyPlaceholderHelper placeholderHelper = new PropertyPlaceholderHelper(\"{\", \"}\", null, false);\n\n\t@Nullable\n\tprivate MessageHeaderInitializer headerInitializer;\n\n\n\tpublic SendToMethodReturnValueHandler(SimpMessageSendingOperations messagingTemplate, boolean annotationRequired) {\n\t\tAssert.notNull(messagingTemplate, \"'messagingTemplate' must not be null\");\n\t\tthis.messagingTemplate = messagingTemplate;\n\t\tthis.annotationRequired = annotationRequired;\n\t}\n\n\n\t/**\n\t * Configure a default prefix to add to message destinations in cases where a method\n\t * is not annotated with {@link SendTo @SendTo} or does not specify any destinations\n\t * through the annotation's value attribute.\n\t * <p>By default, the prefix is set to \"/topic\".\n\t */\n\tpublic void setDefaultDestinationPrefix(String defaultDestinationPrefix) {\n\t\tthis.defaultDestinationPrefix = defaultDestinationPrefix;\n\t}\n\n\t/**\n\t * Return the configured default destination prefix.\n\t * @see #setDefaultDestinationPrefix(String)\n\t */\n\tpublic String getDefaultDestinationPrefix() {\n\t\treturn this.defaultDestinationPrefix;\n\t}\n\n\t/**\n\t * Configure a default prefix to add to message destinations in cases where a\n\t * method is annotated with {@link SendToUser @SendToUser} but does not specify\n\t * any destinations through the annotation's value attribute.\n\t * <p>By default, the prefix is set to \"/queue\".\n\t */\n\tpublic void setDefaultUserDestinationPrefix(String prefix) {\n\t\tthis.defaultUserDestinationPrefix = prefix;\n\t}\n\n\t/**\n\t * Return the configured default user destination prefix.\n\t * @see #setDefaultUserDestinationPrefix(String)\n\t */\n\tpublic String getDefaultUserDestinationPrefix() {\n\t\treturn this.defaultUserDestinationPrefix;\n\t}\n\n\t/**\n\t * Configure a {@link MessageHeaderInitializer} to apply to the headers of all\n\t * messages sent to the client outbound channel.\n\t * <p>By default this property is not set.\n\t */\n\tpublic void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer) {\n\t\tthis.headerInitializer = headerInitializer;\n\t}\n\n\t/**\n\t * Return the configured header initializer.\n\t */\n\t@Nullable\n\tpublic MessageHeaderInitializer getHeaderInitializer() {\n\t\treturn this.headerInitializer;\n\t}\n\n\n\t@Override\n\tpublic boolean supportsReturnType(MethodParameter returnType) {\n\t\treturn (returnType.hasMethodAnnotation(SendTo.class) ||\n\t\t\t\tAnnotatedElementUtils.hasAnnotation(returnType.getDeclaringClass(), SendTo.class) ||\n\t\t\t\treturnType.hasMethodAnnotation(SendToUser.class) ||\n\t\t\t\tAnnotatedElementUtils.hasAnnotation(returnType.getDeclaringClass(), SendToUser.class) ||\n\t\t\t\t!this.annotationRequired);\n\t}\n\n\t@Override\n\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, Message<?> message)\n\t\t\tthrows Exception {\n\n\t\tif (returnValue == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tMessageHeaders headers = message.getHeaders();\n\t\tString sessionId = SimpMessageHeaderAccessor.getSessionId(headers);\n\t\tDestinationHelper destinationHelper = getDestinationHelper(headers, returnType);\n\n\t\tSendToUser sendToUser = destinationHelper.getSendToUser();\n\t\tif (sendToUser != null) {\n\t\t\tboolean broadcast = sendToUser.broadcast();\n\t\t\tString user = getUserName(message, headers);\n\t\t\tif (user == null) {\n\t\t\t\tif (sessionId == null) {\n\t\t\t\t\tthrow new MissingSessionUserException(message);\n\t\t\t\t}\n\t\t\t\tuser = sessionId;\n\t\t\t\tbroadcast = false;\n\t\t\t}\n\t\t\tString[] destinations = getTargetDestinations(sendToUser, message, this.defaultUserDestinationPrefix);\n\t\t\tfor (String destination : destinations) {\n\t\t\t\tdestination = destinationHelper.expandTemplateVars(destination);\n\t\t\t\tif (broadcast) {\n\t\t\t\t\tthis.messagingTemplate.convertAndSendToUser(\n\t\t\t\t\t\t\tuser, destination, returnValue, createHeaders(null, returnType));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.messagingTemplate.convertAndSendToUser(\n\t\t\t\t\t\t\tuser, destination, returnValue, createHeaders(sessionId, returnType));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSendTo sendTo = destinationHelper.getSendTo();\n\t\tif (sendTo != null || sendToUser == null) {\n\t\t\tString[] destinations = getTargetDestinations(sendTo, message, this.defaultDestinationPrefix);\n\t\t\tfor (String destination : destinations) {\n\t\t\t\tdestination = destinationHelper.expandTemplateVars(destination);\n\t\t\t\tthis.messagingTemplate.convertAndSend(destination, returnValue, createHeaders(sessionId, returnType));\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate DestinationHelper getDestinationHelper(MessageHeaders headers, MethodParameter returnType) {\n\t\tSendToUser m1 = AnnotatedElementUtils.findMergedAnnotation(returnType.getExecutable(), SendToUser.class);\n\t\tSendTo m2 = AnnotatedElementUtils.findMergedAnnotation(returnType.getExecutable(), SendTo.class);\n\t\tif ((m1 != null && !ObjectUtils.isEmpty(m1.value())) || (m2 != null && !ObjectUtils.isEmpty(m2.value()))) {\n\t\t\treturn new DestinationHelper(headers, m1, m2);\n\t\t}\n\n\t\tSendToUser c1 = AnnotatedElementUtils.findMergedAnnotation(returnType.getDeclaringClass(), SendToUser.class);\n\t\tSendTo c2 = AnnotatedElementUtils.findMergedAnnotation(returnType.getDeclaringClass(), SendTo.class);\n\t\tif ((c1 != null && !ObjectUtils.isEmpty(c1.value())) || (c2 != null && !ObjectUtils.isEmpty(c2.value()))) {\n\t\t\treturn new DestinationHelper(headers, c1, c2);\n\t\t}\n\n\t\treturn (m1 != null || m2 != null ?\n\t\t\t\tnew DestinationHelper(headers, m1, m2) : new DestinationHelper(headers, c1, c2));\n\t}\n\n\t@Nullable\n\tprotected String getUserName(Message<?> message, MessageHeaders headers) {\n\t\tPrincipal principal = SimpMessageHeaderAccessor.getUser(headers);\n\t\tif (principal != null) {\n\t\t\treturn (principal instanceof DestinationUserNameProvider provider ?\n\t\t\t\t\tprovider.getDestinationUserName() : principal.getName());\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected String[] getTargetDestinations(@Nullable Annotation annotation, Message<?> message, String defaultPrefix) {\n\t\tif (annotation != null) {\n\t\t\tString[] value = (String[]) AnnotationUtils.getValue(annotation);\n\t\t\tif (!ObjectUtils.isEmpty(value)) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\n\t\tString name = DestinationPatternsMessageCondition.LOOKUP_DESTINATION_HEADER;\n\t\tString destination = (String) message.getHeaders().get(name);\n\t\tif (!StringUtils.hasText(destination)) {\n\t\t\tthrow new IllegalStateException(\"No lookup destination header in \" + message);\n\t\t}\n\n\t\treturn (destination.startsWith(\"/\") ?\n\t\t\t\tnew String[] {defaultPrefix + destination} : new String[] {defaultPrefix + '/' + destination});\n\t}\n\n\tprivate MessageHeaders createHeaders(@Nullable String sessionId, MethodParameter returnType) {\n\t\tSimpMessageHeaderAccessor headerAccessor = SimpMessageHeaderAccessor.create(SimpMessageType.MESSAGE);\n\t\tif (getHeaderInitializer() != null) {\n\t\t\tgetHeaderInitializer().initHeaders(headerAccessor);\n\t\t}\n\t\tif (sessionId != null) {\n\t\t\theaderAccessor.setSessionId(sessionId);\n\t\t}\n\t\theaderAccessor.setHeader(AbstractMessageSendingTemplate.CONVERSION_HINT_HEADER, returnType);\n\t\theaderAccessor.setLeaveMutable(true);\n\t\treturn headerAccessor.getMessageHeaders();\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"SendToMethodReturnValueHandler [annotationRequired=\" + this.annotationRequired + \"]\";\n\t}\n\n\n\tprivate class DestinationHelper {\n\n\t\tprivate final PlaceholderResolver placeholderResolver;\n\n\t\t@Nullable\n\t\tprivate final SendTo sendTo;\n\n\t\t@Nullable\n\t\tprivate final SendToUser sendToUser;\n\n\n\t\tpublic DestinationHelper(MessageHeaders headers, @Nullable SendToUser sendToUser, @Nullable SendTo sendTo) {\n\t\t\tMap<String, String> variables = getTemplateVariables(headers);\n\t\t\tthis.placeholderResolver = variables::get;\n\t\t\tthis.sendTo = sendTo;\n\t\t\tthis.sendToUser = sendToUser;\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tprivate Map<String, String> getTemplateVariables(MessageHeaders headers) {\n\t\t\tString name = DestinationVariableMethodArgumentResolver.DESTINATION_TEMPLATE_VARIABLES_HEADER;\n\t\t\treturn (Map<String, String>) headers.getOrDefault(name, Collections.emptyMap());\n\t\t}\n\n\t\t@Nullable\n\t\tpublic SendTo getSendTo() {\n\t\t\treturn this.sendTo;\n\t\t}\n\n\t\t@Nullable\n\t\tpublic SendToUser getSendToUser() {\n\t\t\treturn this.sendToUser;\n\t\t}\n\n\t\tpublic String expandTemplateVars(String destination) {\n\t\t\treturn placeholderHelper.replacePlaceholders(destination, this.placeholderResolver);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandler#expandTemplateVars(destination)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "String",
    "signature": "public String expandTemplateVars(String destination)",
    "source_code": "\t\tpublic String expandTemplateVars(String destination) {\n\t\t\treturn placeholderHelper.replacePlaceholders(destination, this.placeholderResolver);\n\t\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandler#getDefaultDestinationPrefix()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured default destination prefix.\n\t * @see #setDefaultDestinationPrefix(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "String",
    "signature": "public String getDefaultDestinationPrefix()",
    "source_code": "\tpublic String getDefaultDestinationPrefix() {\n\t\treturn this.defaultDestinationPrefix;\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandler#getDefaultUserDestinationPrefix()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured default user destination prefix.\n\t * @see #setDefaultUserDestinationPrefix(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "String",
    "signature": "public String getDefaultUserDestinationPrefix()",
    "source_code": "\tpublic String getDefaultUserDestinationPrefix() {\n\t\treturn this.defaultUserDestinationPrefix;\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandler#getHeaderInitializer()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured header initializer.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "MessageHeaderInitializer",
    "signature": "public MessageHeaderInitializer getHeaderInitializer()",
    "source_code": "\tpublic MessageHeaderInitializer getHeaderInitializer() {\n\t\treturn this.headerInitializer;\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandler#getSendTo()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "SendTo",
    "signature": "public SendTo getSendTo()",
    "source_code": "\t\tpublic SendTo getSendTo() {\n\t\t\treturn this.sendTo;\n\t\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandler#getSendToUser()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 289
    },
    "return": "SendToUser",
    "signature": "public SendToUser getSendToUser()",
    "source_code": "\t\tpublic SendToUser getSendToUser() {\n\t\t\treturn this.sendToUser;\n\t\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandler#getTargetDestinations(annotation,message,defaultPrefix)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "annotation",
      "message",
      "defaultPrefix"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "String[]",
    "signature": "protected String[] getTargetDestinations(@Nullable Annotation annotation, Message<?> message, String defaultPrefix)",
    "source_code": "\tprotected String[] getTargetDestinations(@Nullable Annotation annotation, Message<?> message, String defaultPrefix) {\n\t\tif (annotation != null) {\n\t\t\tString[] value = (String[]) AnnotationUtils.getValue(annotation);\n\t\t\tif (!ObjectUtils.isEmpty(value)) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\n\t\tString name = DestinationPatternsMessageCondition.LOOKUP_DESTINATION_HEADER;\n\t\tString destination = (String) message.getHeaders().get(name);\n\t\tif (!StringUtils.hasText(destination)) {\n\t\t\tthrow new IllegalStateException(\"No lookup destination header in \" + message);\n\t\t}\n\n\t\treturn (destination.startsWith(\"/\") ?\n\t\t\t\tnew String[] {defaultPrefix + destination} : new String[] {defaultPrefix + '/' + destination});\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandler#getUserName(message,headers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 212
    },
    "return": "String",
    "signature": "protected String getUserName(Message<?> message, MessageHeaders headers)",
    "source_code": "\tprotected String getUserName(Message<?> message, MessageHeaders headers) {\n\t\tPrincipal principal = SimpMessageHeaderAccessor.getUser(headers);\n\t\tif (principal != null) {\n\t\t\treturn (principal instanceof DestinationUserNameProvider provider ?\n\t\t\t\t\tprovider.getDestinationUserName() : principal.getName());\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandler#handleReturnValue(returnValue,returnType,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, Message<?> message)",
    "source_code": "\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, Message<?> message)"
  },
  "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandler#setDefaultDestinationPrefix(defaultDestinationPrefix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a default prefix to add to message destinations in cases where a method\n\t * is not annotated with {@link SendTo @SendTo} or does not specify any destinations\n\t * through the annotation's value attribute.\n\t * <p>By default, the prefix is set to \"/topic\".\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultDestinationPrefix"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "void",
    "signature": "public void setDefaultDestinationPrefix(String defaultDestinationPrefix)",
    "source_code": "\tpublic void setDefaultDestinationPrefix(String defaultDestinationPrefix) {\n\t\tthis.defaultDestinationPrefix = defaultDestinationPrefix;\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandler#setDefaultUserDestinationPrefix(prefix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a default prefix to add to message destinations in cases where a\n\t * method is annotated with {@link SendToUser @SendToUser} but does not specify\n\t * any destinations through the annotation's value attribute.\n\t * <p>By default, the prefix is set to \"/queue\".\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "prefix"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "void",
    "signature": "public void setDefaultUserDestinationPrefix(String prefix)",
    "source_code": "\tpublic void setDefaultUserDestinationPrefix(String prefix) {\n\t\tthis.defaultUserDestinationPrefix = prefix;\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandler#setHeaderInitializer(headerInitializer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a {@link MessageHeaderInitializer} to apply to the headers of all\n\t * messages sent to the client outbound channel.\n\t * <p>By default this property is not set.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerInitializer"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "void",
    "signature": "public void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer)",
    "source_code": "\tpublic void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer) {\n\t\tthis.headerInitializer = headerInitializer;\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandler#supportsReturnType(returnType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnType"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "boolean",
    "signature": "public boolean supportsReturnType(MethodParameter returnType)",
    "source_code": "\tpublic boolean supportsReturnType(MethodParameter returnType) {\n\t\treturn (returnType.hasMethodAnnotation(SendTo.class) ||\n\t\t\t\tAnnotatedElementUtils.hasAnnotation(returnType.getDeclaringClass(), SendTo.class) ||\n\t\t\t\treturnType.hasMethodAnnotation(SendToUser.class) ||\n\t\t\t\tAnnotatedElementUtils.hasAnnotation(returnType.getDeclaringClass(), SendToUser.class) ||\n\t\t\t\t!this.annotationRequired);\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandler#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn \"SendToMethodReturnValueHandler [annotationRequired=\" + this.annotationRequired + \"]\";\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A handler for messages delegating to {@link MessageMapping @MessageMapping}\n * and {@link SubscribeMapping @SubscribeMapping} annotated methods.\n *\n * <p>Supports Ant-style path patterns with template variables.\n *\n * @author Rossen Stoyanchev\n * @author Brian Clozel\n * @author Juergen Hoeller\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "signature": "public class SimpAnnotationMethodMessageHandler",
    "source_code": "public class SimpAnnotationMethodMessageHandler extends AbstractMethodMessageHandler<SimpMessageMappingInfo>"
  },
  "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler#createExceptionHandlerMethodResolverFor(beanType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanType"
    ],
    "position": {
      "column": 1,
      "line": 519
    },
    "return": "AbstractExceptionHandlerMethodResolver",
    "signature": "protected AbstractExceptionHandlerMethodResolver createExceptionHandlerMethodResolverFor(Class<?> beanType)",
    "source_code": "\tprotected AbstractExceptionHandlerMethodResolver createExceptionHandlerMethodResolverFor(Class<?> beanType) {\n\t\treturn new AnnotationExceptionHandlerMethodResolver(beanType);\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler#getConversionService()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured {@link ConversionService}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 212
    },
    "return": "ConversionService",
    "signature": "public ConversionService getConversionService()",
    "source_code": "\tpublic ConversionService getConversionService() {\n\t\treturn this.conversionService;\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler#getDestination(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 457
    },
    "return": "String",
    "signature": "protected String getDestination(Message<?> message)",
    "source_code": "\tprotected String getDestination(Message<?> message) {\n\t\treturn SimpMessageHeaderAccessor.getDestination(message.getHeaders());\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler#getDirectLookupDestinations(mapping)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping"
    ],
    "position": {
      "column": 1,
      "line": 445
    },
    "return": "Set<String>",
    "signature": "protected Set<String> getDirectLookupDestinations(SimpMessageMappingInfo mapping)",
    "source_code": "\tprotected Set<String> getDirectLookupDestinations(SimpMessageMappingInfo mapping) {\n\t\tSet<String> result = new LinkedHashSet<>();\n\t\tfor (String pattern : mapping.getDestinationConditions().getPatterns()) {\n\t\t\tif (!this.pathMatcher.isPattern(pattern)) {\n\t\t\t\tresult.add(pattern);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler#getHandlerMethodLogger()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 372
    },
    "return": "Log",
    "signature": "protected Log getHandlerMethodLogger()",
    "source_code": "\tprotected Log getHandlerMethodLogger() {\n\t\treturn SimpLogging.forLog(HandlerMethod.defaultLogger);\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler#getHeaderInitializer()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured header initializer.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 270
    },
    "return": "MessageHeaderInitializer",
    "signature": "public MessageHeaderInitializer getHeaderInitializer()",
    "source_code": "\tpublic MessageHeaderInitializer getHeaderInitializer() {\n\t\treturn this.headerInitializer;\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler#getLookupDestination(destination)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 462
    },
    "return": "String",
    "signature": "protected String getLookupDestination(@Nullable String destination)",
    "source_code": "\tprotected String getLookupDestination(@Nullable String destination) {\n\t\tif (destination == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (CollectionUtils.isEmpty(getDestinationPrefixes())) {\n\t\t\treturn destination;\n\t\t}\n\t\tfor (String prefix : getDestinationPrefixes()) {\n\t\t\tif (destination.startsWith(prefix)) {\n\t\t\t\tif (this.slashPathSeparator) {\n\t\t\t\t\treturn destination.substring(prefix.length() - 1);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn destination.substring(prefix.length());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler#getMappingComparator(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 490
    },
    "return": "Comparator<SimpMessageMappingInfo>",
    "signature": "protected Comparator<SimpMessageMappingInfo> getMappingComparator(final Message<?> message)",
    "source_code": "\tprotected Comparator<SimpMessageMappingInfo> getMappingComparator(final Message<?> message) {\n\t\treturn (info1, info2) -> info1.compareTo(info2, message);\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler#getMappingForMethod(method,handlerType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "handlerType"
    ],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "SimpMessageMappingInfo",
    "signature": "protected SimpMessageMappingInfo getMappingForMethod(Method method, Class<?> handlerType)",
    "source_code": "\tprotected SimpMessageMappingInfo getMappingForMethod(Method method, Class<?> handlerType) {\n\t\tMessageMapping messageAnn = AnnotatedElementUtils.findMergedAnnotation(method, MessageMapping.class);\n\t\tif (messageAnn != null) {\n\t\t\tMessageMapping typeAnn = AnnotatedElementUtils.findMergedAnnotation(handlerType, MessageMapping.class);\n\t\t\t// Only actually register it if there are destinations specified;\n\t\t\t// otherwise @MessageMapping is just being used as a (meta-annotation) marker.\n\t\t\tif (messageAnn.value().length > 0 || (typeAnn != null && typeAnn.value().length > 0)) {\n\t\t\t\tSimpMessageMappingInfo result = createMessageMappingCondition(messageAnn.value());\n\t\t\t\tif (typeAnn != null) {\n\t\t\t\t\tresult = createMessageMappingCondition(typeAnn.value()).combine(result);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tSubscribeMapping subscribeAnn = AnnotatedElementUtils.findMergedAnnotation(method, SubscribeMapping.class);\n\t\tif (subscribeAnn != null) {\n\t\t\tMessageMapping typeAnn = AnnotatedElementUtils.findMergedAnnotation(handlerType, MessageMapping.class);\n\t\t\t// Only actually register it if there are destinations specified;\n\t\t\t// otherwise @SubscribeMapping is just being used as a (meta-annotation) marker.\n\t\t\tif (subscribeAnn.value().length > 0 || (typeAnn != null && typeAnn.value().length > 0)) {\n\t\t\t\tSimpMessageMappingInfo result = createSubscribeMappingCondition(subscribeAnn.value());\n\t\t\t\tif (typeAnn != null) {\n\t\t\t\t\tresult = createMessageMappingCondition(typeAnn.value()).combine(result);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler#getMatchingMapping(mapping,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 484
    },
    "return": "SimpMessageMappingInfo",
    "signature": "protected SimpMessageMappingInfo getMatchingMapping(SimpMessageMappingInfo mapping, Message<?> message)",
    "source_code": "\tprotected SimpMessageMappingInfo getMatchingMapping(SimpMessageMappingInfo mapping, Message<?> message) {\n\t\treturn mapping.getMatchingCondition(message);\n\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler#getMessageConverter()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured {@link MessageConverter}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "MessageConverter",
    "signature": "public MessageConverter getMessageConverter()",
    "source_code": "\tpublic MessageConverter getMessageConverter() {\n\t\treturn this.messageConverter;\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler#getPathMatcher()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the PathMatcher implementation to use for matching destinations.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "PathMatcher",
    "signature": "public PathMatcher getPathMatcher()",
    "source_code": "\tpublic PathMatcher getPathMatcher() {\n\t\treturn this.pathMatcher;\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler#getReturnValueHandlerLogger()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 367
    },
    "return": "Log",
    "signature": "protected Log getReturnValueHandlerLogger()",
    "source_code": "\tprotected Log getReturnValueHandlerLogger() {\n\t\treturn SimpLogging.forLog(HandlerMethodReturnValueHandlerComposite.defaultLogger);\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler#getValidator()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured Validator instance.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "Validator",
    "signature": "public Validator getValidator()",
    "source_code": "\tpublic Validator getValidator() {\n\t\treturn this.validator;\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler#handleMatch(mapping,handlerMethod,lookupDestination,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "handlerMethod",
      "lookupDestination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 495
    },
    "return": "void",
    "signature": "protected void handleMatch(SimpMessageMappingInfo mapping, HandlerMethod handlerMethod,\n\t\t\tString lookupDestination, Message<?> message)",
    "source_code": "\tprotected void handleMatch(SimpMessageMappingInfo mapping, HandlerMethod handlerMethod,"
  },
  "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler#initArgumentResolvers()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 306
    },
    "return": "List<HandlerMethodArgumentResolver>",
    "signature": "protected List<HandlerMethodArgumentResolver> initArgumentResolvers()",
    "source_code": "\tprotected List<HandlerMethodArgumentResolver> initArgumentResolvers() {\n\t\tApplicationContext context = getApplicationContext();\n\t\tConfigurableBeanFactory beanFactory = (context instanceof ConfigurableApplicationContext cac ?\n\t\t\t\tcac.getBeanFactory() : null);\n\n\t\tList<HandlerMethodArgumentResolver> resolvers = new ArrayList<>();\n\n\t\t// Annotation-based argument resolution\n\t\tresolvers.add(new HeaderMethodArgumentResolver(this.conversionService, beanFactory));\n\t\tresolvers.add(new HeadersMethodArgumentResolver());\n\t\tresolvers.add(new DestinationVariableMethodArgumentResolver(this.conversionService));\n\n\t\t// Type-based argument resolution\n\t\tresolvers.add(new PrincipalMethodArgumentResolver());\n\t\tresolvers.add(new MessageMethodArgumentResolver(this.messageConverter));\n\n\t\tresolvers.addAll(getCustomArgumentResolvers());\n\t\tresolvers.add(new PayloadMethodArgumentResolver(this.messageConverter, this.validator));\n\n\t\treturn resolvers;\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler#isHandler(beanType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanType"
    ],
    "position": {
      "column": 1,
      "line": 378
    },
    "return": "boolean",
    "signature": "protected boolean isHandler(Class<?> beanType)",
    "source_code": "\tprotected boolean isHandler(Class<?> beanType) {\n\t\treturn AnnotatedElementUtils.hasAnnotation(beanType, Controller.class);\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler#isRunning()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 300
    },
    "return": "boolean",
    "signature": "public boolean isRunning()",
    "source_code": "\tpublic final boolean isRunning() {\n\t\treturn this.running;\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler#resolveEmbeddedValuesInDestinations(destinations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve placeholder values in the given array of destinations.\n\t * @return a new array with updated destinations\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "destinations"
    ],
    "position": {
      "column": 1,
      "line": 433
    },
    "return": "String[]",
    "signature": "protected String[] resolveEmbeddedValuesInDestinations(String[] destinations)",
    "source_code": "\tprotected String[] resolveEmbeddedValuesInDestinations(String[] destinations) {\n\t\tif (this.valueResolver == null) {\n\t\t\treturn destinations;\n\t\t}\n\t\tString[] result = new String[destinations.length];\n\t\tfor (int i = 0; i < destinations.length; i++) {\n\t\t\tresult[i] = this.valueResolver.resolveStringValue(destinations[i]);\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler#setConversionService(conversionService)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a {@link ConversionService} to use when resolving method arguments,\n\t * for example message header values.\n\t * <p>By default, {@link DefaultFormattingConversionService} is used.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "void",
    "signature": "public void setConversionService(ConversionService conversionService)",
    "source_code": "\tpublic void setConversionService(ConversionService conversionService) {\n\t\tthis.conversionService = conversionService;\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler#setDestinationPrefixes(prefixes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p>Destination prefixes are expected to be slash-separated Strings and\n\t * therefore a slash is automatically appended where missing to ensure a\n\t * proper prefix-based match (i.e. matching complete segments).\n\t * <p>Note however that the remaining portion of a destination after the\n\t * prefix may use a different separator (e.g. commonly \".\" in messaging)\n\t * depending on the configured {@code PathMatcher}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "prefixes"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "void",
    "signature": "public void setDestinationPrefixes(@Nullable Collection<String> prefixes)",
    "source_code": "\tpublic void setDestinationPrefixes(@Nullable Collection<String> prefixes) {\n\t\tsuper.setDestinationPrefixes(appendSlashes(prefixes));\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler#setEmbeddedValueResolver(resolver)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolver"
    ],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "void",
    "signature": "public void setEmbeddedValueResolver(StringValueResolver resolver)",
    "source_code": "\tpublic void setEmbeddedValueResolver(StringValueResolver resolver) {\n\t\tthis.valueResolver = resolver;\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler#setHeaderInitializer(headerInitializer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a {@link MessageHeaderInitializer} to pass on to\n\t * {@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers}\n\t * that send messages from controller return values.\n\t * <p>By default, this property is not set.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerInitializer"
    ],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "void",
    "signature": "public void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer)",
    "source_code": "\tpublic void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer) {\n\t\tthis.headerInitializer = headerInitializer;\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler#setMessageConverter(converter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a {@link MessageConverter} to use to convert the payload of a message from\n\t * its serialized form with a specific MIME type to an Object matching the target method\n\t * parameter. The converter is also used when sending a message to the message broker.\n\t * @see CompositeMessageConverter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "converter"
    ],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "void",
    "signature": "public void setMessageConverter(MessageConverter converter)",
    "source_code": "\tpublic void setMessageConverter(MessageConverter converter) {\n\t\tthis.messageConverter = converter;\n\t\t((AbstractMessageSendingTemplate<?>) this.clientMessagingTemplate).setMessageConverter(converter);\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler#setPathMatcher(pathMatcher)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the PathMatcher implementation to use for matching destinations\n\t * against configured destination patterns.\n\t * <p>By default, {@link AntPathMatcher} is used.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pathMatcher"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "void",
    "signature": "public void setPathMatcher(PathMatcher pathMatcher)",
    "source_code": "\tpublic void setPathMatcher(PathMatcher pathMatcher) {\n\t\tAssert.notNull(pathMatcher, \"PathMatcher must not be null\");\n\t\tthis.pathMatcher = pathMatcher;\n\t\tthis.slashPathSeparator = this.pathMatcher.combine(\"a\", \"a\").equals(\"a/a\");\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler#setValidator(validator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Validator instance used for validating {@code @Payload} arguments.\n\t * @see org.springframework.validation.annotation.Validated\n\t * @see PayloadMethodArgumentResolver\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "validator"
    ],
    "position": {
      "column": 1,
      "line": 247
    },
    "return": "void",
    "signature": "public void setValidator(@Nullable Validator validator)",
    "source_code": "\tpublic void setValidator(@Nullable Validator validator) {\n\t\tthis.validator = validator;\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler#start()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "void",
    "signature": "public void start()",
    "source_code": "\tpublic final void start() {\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\tthis.clientInboundChannel.subscribe(this);\n\t\t\tthis.running = true;\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler#stop()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "void",
    "signature": "public void stop()",
    "source_code": "\tpublic final void stop() {\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\tthis.running = false;\n\t\t\tthis.clientInboundChannel.unsubscribe(this);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler#stop(callback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "void",
    "signature": "public void stop(Runnable callback)",
    "source_code": "\tpublic final void stop(Runnable callback) {\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\tstop();\n\t\t\tcallback.run();\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract base class for a {@link MessageHandler} that broker messages to\n * registered subscribers.\n *\n * @author Rossen Stoyanchev\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "signature": "public class AbstractBrokerMessageHandler",
    "source_code": "public abstract class AbstractBrokerMessageHandler"
  },
  "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler#afterSendCompletion(message,channel,sent,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "channel",
      "sent",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 357
    },
    "return": "void",
    "signature": "public void afterSendCompletion(Message<?> message, MessageChannel channel, boolean sent, @Nullable Exception ex)",
    "source_code": "\t\tpublic void afterSendCompletion("
  },
  "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler#checkDestinationPrefix(destination)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether a message with the given destination should be processed. This is\n\t * the case if one of the following conditions is true:\n\t * <ol>\n\t * <li>The destination starts with one of the configured\n\t * {@link #getDestinationPrefixes() destination prefixes}.\n\t * <li>No prefixes are configured and the destination isn't matched\n\t * by the {@link #setUserDestinationPredicate(Predicate)\n\t * userDestinationPredicate}.\n\t * <li>The message has no destination.\n\t * </ol>\n\t * @param destination the destination to check\n\t * @return whether to process (true) or skip (false) the destination\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 301
    },
    "return": "boolean",
    "signature": "protected boolean checkDestinationPrefix(@Nullable String destination)",
    "source_code": "\tprotected boolean checkDestinationPrefix(@Nullable String destination) {\n\t\tif (destination == null) {\n\t\t\treturn true;\n\t\t}\n\t\tif (CollectionUtils.isEmpty(this.destinationPrefixes)) {\n\t\t\treturn !isUserDestination(destination);\n\t\t}\n\t\tfor (String prefix : this.destinationPrefixes) {\n\t\t\tif (destination.startsWith(prefix)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler#getApplicationEventPublisher()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "ApplicationEventPublisher",
    "signature": "public ApplicationEventPublisher getApplicationEventPublisher()",
    "source_code": "\tpublic ApplicationEventPublisher getApplicationEventPublisher() {\n\t\treturn this.eventPublisher;\n\t}"
  },
  "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler#getBrokerChannel()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "SubscribableChannel",
    "signature": "public SubscribableChannel getBrokerChannel()",
    "source_code": "\tpublic SubscribableChannel getBrokerChannel() {\n\t\treturn this.brokerChannel;\n\t}"
  },
  "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler#getClientInboundChannel()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "SubscribableChannel",
    "signature": "public SubscribableChannel getClientInboundChannel()",
    "source_code": "\tpublic SubscribableChannel getClientInboundChannel() {\n\t\treturn this.clientInboundChannel;\n\t}"
  },
  "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler#getClientOutboundChannel()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "MessageChannel",
    "signature": "public MessageChannel getClientOutboundChannel()",
    "source_code": "\tpublic MessageChannel getClientOutboundChannel() {\n\t\treturn this.clientOutboundChannel;\n\t}"
  },
  "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler#getClientOutboundChannelForSession(sessionId)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the MessageChannel to use for sending messages to clients, possibly\n\t * a per-session wrapper when {@code preservePublishOrder=true}.\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "sessionId"
    ],
    "position": {
      "column": 1,
      "line": 345
    },
    "return": "MessageChannel",
    "signature": "protected MessageChannel getClientOutboundChannelForSession(String sessionId)",
    "source_code": "\tprotected MessageChannel getClientOutboundChannelForSession(String sessionId) {\n\t\treturn this.preservePublishOrder ?\n\t\t\t\tnew OrderedMessageChannelDecorator(getClientOutboundChannel(), logger) : getClientOutboundChannel();\n\t}"
  },
  "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler#getDestinationPrefixes()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return destination prefixes to use to filter messages to forward\n\t * to the broker. Messages that have a destination and where the destination\n\t * doesn't match are ignored.\n\t * <p>By default this is not set.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "Collection<String>",
    "signature": "public Collection<String> getDestinationPrefixes()",
    "source_code": "\tpublic Collection<String> getDestinationPrefixes() {\n\t\treturn this.destinationPrefixes;\n\t}"
  },
  "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler#handleMessage(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "void",
    "signature": "public void handleMessage(Message<?> message)",
    "source_code": "\tpublic void handleMessage(Message<?> message) {\n\t\tif (!this.running) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(this + \" not running yet. Ignoring \" + message);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\thandleMessageInternal(message);\n\t}"
  },
  "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler#handleMessageInternal(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "void",
    "signature": "protected void handleMessageInternal(Message<?> message)",
    "source_code": "\tprotected abstract void handleMessageInternal(Message<?> message);"
  },
  "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler#isAutoStartup()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 197
    },
    "return": "boolean",
    "signature": "public boolean isAutoStartup()",
    "source_code": "\tpublic boolean isAutoStartup() {\n\t\treturn this.autoStartup;\n\t}"
  },
  "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler#isBrokerAvailable()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the message broker is currently available and able to process messages.\n\t * <p>Note that this is in addition to the {@link #isRunning()} flag, which\n\t * indicates whether this message handler is running. In other words the message\n\t * handler must first be running and then the {@code #isBrokerAvailable()} flag\n\t * may still independently alternate between being on and off depending on the\n\t * concrete subclass implementation.\n\t * <p>Application components may implement\n\t * {@code org.springframework.context.ApplicationListener<BrokerAvailabilityEvent>}\n\t * to receive notifications when broker becomes available and unavailable.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 268
    },
    "return": "boolean",
    "signature": "public boolean isBrokerAvailable()",
    "source_code": "\tpublic boolean isBrokerAvailable() {\n\t\treturn this.brokerAvailable.get();\n\t}"
  },
  "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler#isPreservePublishOrder()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to ensure messages are received in the order of publication.\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "boolean",
    "signature": "public boolean isPreservePublishOrder()",
    "source_code": "\tpublic boolean isPreservePublishOrder() {\n\t\treturn this.preservePublishOrder;\n\t}"
  },
  "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler#isRunning()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether this message handler is currently running.\n\t * <p>Note that even when this message handler is running the\n\t * {@link #isBrokerAvailable()} flag may still independently alternate between\n\t * being on and off depending on the concrete subclass implementation.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 253
    },
    "return": "boolean",
    "signature": "public boolean isRunning()",
    "source_code": "\tpublic final boolean isRunning() {\n\t\treturn this.running;\n\t}"
  },
  "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler#publishBrokerAvailableEvent()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 320
    },
    "return": "void",
    "signature": "protected void publishBrokerAvailableEvent()",
    "source_code": "\tprotected void publishBrokerAvailableEvent() {\n\t\tboolean shouldPublish = this.brokerAvailable.compareAndSet(false, true);\n\t\tif (this.eventPublisher != null && shouldPublish) {\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(this.availableEvent);\n\t\t\t}\n\t\t\tthis.eventPublisher.publishEvent(this.availableEvent);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler#publishBrokerUnavailableEvent()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 330
    },
    "return": "void",
    "signature": "protected void publishBrokerUnavailableEvent()",
    "source_code": "\tprotected void publishBrokerUnavailableEvent() {\n\t\tboolean shouldPublish = this.brokerAvailable.compareAndSet(true, false);\n\t\tif (this.eventPublisher != null && shouldPublish) {\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(this.notAvailableEvent);\n\t\t\t}\n\t\t\tthis.eventPublisher.publishEvent(this.notAvailableEvent);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler#setApplicationEventPublisher(publisher)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "publisher"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "void",
    "signature": "public void setApplicationEventPublisher(@Nullable ApplicationEventPublisher publisher)",
    "source_code": "\tpublic void setApplicationEventPublisher(@Nullable ApplicationEventPublisher publisher) {\n\t\tthis.eventPublisher = publisher;\n\t}"
  },
  "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler#setAutoStartup(autoStartup)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "autoStartup"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "void",
    "signature": "public void setAutoStartup(boolean autoStartup)",
    "source_code": "\tpublic void setAutoStartup(boolean autoStartup) {\n\t\tthis.autoStartup = autoStartup;\n\t}"
  },
  "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler#setPreservePublishOrder(preservePublishOrder)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the client must receive messages in the order of publication.\n\t * <p>By default messages sent to the {@code \"clientOutboundChannel\"} may\n\t * not be processed in the same order because the channel is backed by a\n\t * ThreadPoolExecutor that in turn does not guarantee processing in order.\n\t * <p>When this flag is set to {@code true} messages within the same session\n\t * will be sent to the {@code \"clientOutboundChannel\"} one at a time in\n\t * order to preserve the order of publication. Enable this only if needed\n\t * since there is some performance overhead to keep messages in order.\n\t * @param preservePublishOrder whether to publish in order\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "preservePublishOrder"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "void",
    "signature": "public void setPreservePublishOrder(boolean preservePublishOrder)",
    "source_code": "\tpublic void setPreservePublishOrder(boolean preservePublishOrder) {\n\t\tOrderedMessageChannelDecorator.configureInterceptor(this.clientOutboundChannel, preservePublishOrder);\n\t\tthis.preservePublishOrder = preservePublishOrder;\n\t}"
  },
  "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler#setUserDestinationPredicate(predicate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a Predicate to identify messages with a user destination. When\n\t * no {@link #getDestinationPrefixes() destination prefixes} are configured,\n\t * this helps to recognize and skip user destination messages that need to\n\t * be pre-processed by the\n\t * {@link org.springframework.messaging.simp.user.UserDestinationMessageHandler}\n\t * before they reach the broker.\n\t * @param predicate the predicate to identify user messages with a non-null\n\t * destination as messages with a user destinations.\n\t * @since 5.3.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "void",
    "signature": "public void setUserDestinationPredicate(@Nullable Predicate<String> predicate)",
    "source_code": "\tpublic void setUserDestinationPredicate(@Nullable Predicate<String> predicate) {\n\t\tthis.userDestinationPredicate = predicate;\n\t}"
  },
  "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler#start()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "void",
    "signature": "public void start()",
    "source_code": "\tpublic void start() {\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\tlogger.info(\"Starting...\");\n\t\t\tthis.clientInboundChannel.subscribe(this);\n\t\t\tthis.brokerChannel.subscribe(this);\n\t\t\tif (this.clientInboundChannel instanceof InterceptableChannel ic) {\n\t\t\t\tic.addInterceptor(0, this.unsentDisconnectInterceptor);\n\t\t\t}\n\t\t\tstartInternal();\n\t\t\tthis.running = true;\n\t\t\tlogger.info(\"Started.\");\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler#startInternal()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "void",
    "signature": "protected void startInternal()",
    "source_code": "\tprotected void startInternal() {\n\t}"
  },
  "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler#stop()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "void",
    "signature": "public void stop()",
    "source_code": "\tpublic void stop() {\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\tlogger.info(\"Stopping...\");\n\t\t\tstopInternal();\n\t\t\tthis.clientInboundChannel.unsubscribe(this);\n\t\t\tthis.brokerChannel.unsubscribe(this);\n\t\t\tif (this.clientInboundChannel instanceof InterceptableChannel ic) {\n\t\t\t\tic.removeInterceptor(this.unsentDisconnectInterceptor);\n\t\t\t}\n\t\t\tthis.running = false;\n\t\t\tlogger.info(\"Stopped.\");\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler#stop(callback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "void",
    "signature": "public void stop(Runnable callback)",
    "source_code": "\tpublic final void stop(Runnable callback) {\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\tstop();\n\t\t\tcallback.run();\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler#stopInternal()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "void",
    "signature": "protected void stopInternal()",
    "source_code": "\tprotected void stopInternal() {\n\t}"
  },
  "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistry#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 477
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object obj) {\n\t\t\treturn (this == obj || (obj instanceof Subscription that && this.id.equals(that.id)));\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistry#equals(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 477
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other ||\n\t\t\t\t\t(other instanceof Subscription && this.id.equals(((Subscription) other).id)));\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A \"simple\" message broker that recognizes the message types defined in\n * {@link SimpMessageType}, keeps track of subscriptions with the help of a\n * {@link SubscriptionRegistry} and sends messages to subscribers.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "public class SimpleBrokerMessageHandler",
    "source_code": "public class SimpleBrokerMessageHandler extends AbstractBrokerMessageHandler {\n\n\tprivate static final byte[] EMPTY_PAYLOAD = new byte[0];\n\n\n\t@Nullable\n\tprivate PathMatcher pathMatcher;\n\n\t@Nullable\n\tprivate Integer cacheLimit;\n\n\t@Nullable\n\tprivate String selectorHeaderName = \"selector\";\n\n\t@Nullable\n\tprivate TaskScheduler taskScheduler;\n\n\t@Nullable\n\tprivate long[] heartbeatValue;\n\n\t@Nullable\n\tprivate MessageHeaderInitializer headerInitializer;\n\n\n\tprivate SubscriptionRegistry subscriptionRegistry;\n\n\tprivate final Map<String, SessionInfo> sessions = new ConcurrentHashMap<>();\n\n\t@Nullable\n\tprivate ScheduledFuture<?> heartbeatFuture;\n\n\n\t/**\n\t * Create a SimpleBrokerMessageHandler instance with the given message channels\n\t * and destination prefixes.\n\t * @param clientInboundChannel the channel for receiving messages from clients (e.g. WebSocket clients)\n\t * @param clientOutboundChannel the channel for sending messages to clients (e.g. WebSocket clients)\n\t * @param brokerChannel the channel for the application to send messages to the broker\n\t * @param destinationPrefixes prefixes to use to filter out messages\n\t */\n\tpublic SimpleBrokerMessageHandler(SubscribableChannel clientInboundChannel, MessageChannel clientOutboundChannel,\n\t\t\tSubscribableChannel brokerChannel, Collection<String> destinationPrefixes) {\n\n\t\tsuper(clientInboundChannel, clientOutboundChannel, brokerChannel, destinationPrefixes);\n\t\tthis.subscriptionRegistry = new DefaultSubscriptionRegistry();\n\t}\n\n\n\t/**\n\t * Configure a custom SubscriptionRegistry to use for storing subscriptions.\n\t * <p><strong>Note</strong> that when a custom PathMatcher is configured via\n\t * {@link #setPathMatcher}, if the custom registry is not an instance of\n\t * {@link DefaultSubscriptionRegistry}, the provided PathMatcher is not used\n\t * and must be configured directly on the custom registry.\n\t */\n\tpublic void setSubscriptionRegistry(SubscriptionRegistry subscriptionRegistry) {\n\t\tAssert.notNull(subscriptionRegistry, \"SubscriptionRegistry must not be null\");\n\t\tthis.subscriptionRegistry = subscriptionRegistry;\n\t\tinitPathMatcherToUse();\n\t\tinitCacheLimitToUse();\n\t\tinitSelectorHeaderNameToUse();\n\t}\n\n\tpublic SubscriptionRegistry getSubscriptionRegistry() {\n\t\treturn this.subscriptionRegistry;\n\t}\n\n\t/**\n\t * When configured, the given PathMatcher is passed down to the underlying\n\t * SubscriptionRegistry to use for matching destination to subscriptions.\n\t * <p>Default is a standard {@link org.springframework.util.AntPathMatcher}.\n\t * @since 4.1\n\t * @see #setSubscriptionRegistry\n\t * @see DefaultSubscriptionRegistry#setPathMatcher\n\t * @see org.springframework.util.AntPathMatcher\n\t */\n\tpublic void setPathMatcher(@Nullable PathMatcher pathMatcher) {\n\t\tthis.pathMatcher = pathMatcher;\n\t\tinitPathMatcherToUse();\n\t}\n\n\tprivate void initPathMatcherToUse() {\n\t\tif (this.pathMatcher != null && this.subscriptionRegistry instanceof DefaultSubscriptionRegistry defaultRegistry) {\n\t\t\tdefaultRegistry.setPathMatcher(this.pathMatcher);\n\t\t}\n\t}\n\n\t/**\n\t * When configured, the specified cache limit is passed down to the\n\t * underlying SubscriptionRegistry, overriding any default there.\n\t * <p>With a standard {@link DefaultSubscriptionRegistry}, the default\n\t * cache limit is 1024.\n\t * @since 4.3.2\n\t * @see #setSubscriptionRegistry\n\t * @see DefaultSubscriptionRegistry#setCacheLimit\n\t * @see DefaultSubscriptionRegistry#DEFAULT_CACHE_LIMIT\n\t */\n\tpublic void setCacheLimit(@Nullable Integer cacheLimit) {\n\t\tthis.cacheLimit = cacheLimit;\n\t\tinitCacheLimitToUse();\n\t}\n\n\tprivate void initCacheLimitToUse() {\n\t\tif (this.cacheLimit != null && this.subscriptionRegistry instanceof DefaultSubscriptionRegistry defaultRegistry) {\n\t\t\tdefaultRegistry.setCacheLimit(this.cacheLimit);\n\t\t}\n\t}\n\n\t/**\n\t * Configure the name of a header that a subscription message can have for\n\t * the purpose of filtering messages matched to the subscription. The header\n\t * value is expected to be a Spring EL boolean expression to be applied to\n\t * the headers of messages matched to the subscription.\n\t * <p>For example:\n\t * <pre>\n\t * headers.foo == 'bar'\n\t * </pre>\n\t * <p>By default this is set to \"selector\". You can set it to a different\n\t * name, or to {@code null} to turn off support for a selector header.\n\t * @param selectorHeaderName the name to use for a selector header\n\t * @since 4.3.17\n\t * @see #setSubscriptionRegistry\n\t * @see DefaultSubscriptionRegistry#setSelectorHeaderName(String)\n\t */\n\tpublic void setSelectorHeaderName(@Nullable String selectorHeaderName) {\n\t\tthis.selectorHeaderName = selectorHeaderName;\n\t\tinitSelectorHeaderNameToUse();\n\t}\n\n\tprivate void initSelectorHeaderNameToUse() {\n\t\tif (this.subscriptionRegistry instanceof DefaultSubscriptionRegistry defaultRegistry) {\n\t\t\tdefaultRegistry.setSelectorHeaderName(this.selectorHeaderName);\n\t\t}\n\t}\n\n\t/**\n\t * Configure the {@link org.springframework.scheduling.TaskScheduler} to\n\t * use for providing heartbeat support. Setting this property also sets the\n\t * {@link #setHeartbeatValue heartbeatValue} to \"10000, 10000\".\n\t * <p>By default this is not set.\n\t * @since 4.2\n\t */\n\tpublic void setTaskScheduler(@Nullable TaskScheduler taskScheduler) {\n\t\tthis.taskScheduler = taskScheduler;\n\t\tif (taskScheduler != null && this.heartbeatValue == null) {\n\t\t\tthis.heartbeatValue = new long[] {10000, 10000};\n\t\t}\n\t}\n\n\t/**\n\t * Return the configured TaskScheduler.\n\t * @since 4.2\n\t */\n\t@Nullable\n\tpublic TaskScheduler getTaskScheduler() {\n\t\treturn this.taskScheduler;\n\t}\n\n\t/**\n\t * Configure the value for the heart-beat settings. The first number\n\t * represents how often the server will write or send a heartbeat.\n\t * The second is how often the client should write. 0 means no heartbeats.\n\t * <p>By default this is set to \"0, 0\" unless the {@link #setTaskScheduler\n\t * taskScheduler} in which case the default becomes \"10000,10000\"\n\t * (in milliseconds).\n\t * @since 4.2\n\t */\n\tpublic void setHeartbeatValue(@Nullable long[] heartbeat) {\n\t\tif (heartbeat != null && (heartbeat.length != 2 || heartbeat[0] < 0 || heartbeat[1] < 0)) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid heart-beat: \" + Arrays.toString(heartbeat));\n\t\t}\n\t\tthis.heartbeatValue = heartbeat;\n\t}\n\n\t/**\n\t * The configured value for the heart-beat settings.\n\t * @since 4.2\n\t */\n\t@Nullable\n\tpublic long[] getHeartbeatValue() {\n\t\treturn this.heartbeatValue;\n\t}\n\n\t/**\n\t * Configure a {@link MessageHeaderInitializer} to apply to the headers\n\t * of all messages sent to the client outbound channel.\n\t * <p>By default this property is not set.\n\t * @since 4.1\n\t */\n\tpublic void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer) {\n\t\tthis.headerInitializer = headerInitializer;\n\t}\n\n\t/**\n\t * Return the configured header initializer.\n\t * @since 4.1\n\t */\n\t@Nullable\n\tpublic MessageHeaderInitializer getHeaderInitializer() {\n\t\treturn this.headerInitializer;\n\t}\n\n\n\t@Override\n\tpublic void startInternal() {\n\t\tpublishBrokerAvailableEvent();\n\t\tif (this.taskScheduler != null) {\n\t\t\tDuration interval = initHeartbeatTaskDelay();\n\t\t\tif (interval.toMillis() > 0) {\n\t\t\t\tthis.heartbeatFuture = this.taskScheduler.scheduleWithFixedDelay(new HeartbeatTask(), interval);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tAssert.isTrue(getHeartbeatValue() == null ||\n\t\t\t\t\t(getHeartbeatValue()[0] == 0 && getHeartbeatValue()[1] == 0),\n\t\t\t\t\t\"Heartbeat values configured but no TaskScheduler provided\");\n\t\t}\n\t}\n\n\tprivate Duration initHeartbeatTaskDelay() {\n\t\tif (getHeartbeatValue() == null) {\n\t\t\treturn Duration.ZERO;\n\t\t}\n\t\telse if (getHeartbeatValue()[0] > 0 && getHeartbeatValue()[1] > 0) {\n\t\t\treturn Duration.ofMillis(Math.min(getHeartbeatValue()[0], getHeartbeatValue()[1]));\n\t\t}\n\t\telse {\n\t\t\treturn Duration.ofMillis(getHeartbeatValue()[0] > 0 ? getHeartbeatValue()[0] : getHeartbeatValue()[1]);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void stopInternal() {\n\t\tpublishBrokerUnavailableEvent();\n\t\tif (this.heartbeatFuture != null) {\n\t\t\tthis.heartbeatFuture.cancel(true);\n\t\t}\n\t}\n\n\t@Override\n\tprotected void handleMessageInternal(Message<?> message) {\n\t\tMessageHeaders headers = message.getHeaders();\n\t\tString destination = SimpMessageHeaderAccessor.getDestination(headers);\n\t\tString sessionId = SimpMessageHeaderAccessor.getSessionId(headers);\n\n\t\tupdateSessionReadTime(sessionId);\n\n\t\tif (!checkDestinationPrefix(destination)) {\n\t\t\treturn;\n\t\t}\n\n\t\tSimpMessageType messageType = SimpMessageHeaderAccessor.getMessageType(headers);\n\t\tif (SimpMessageType.MESSAGE.equals(messageType)) {\n\t\t\tlogMessage(message);\n\t\t\tsendMessageToSubscribers(destination, message);\n\t\t}\n\t\telse if (SimpMessageType.CONNECT.equals(messageType)) {\n\t\t\tlogMessage(message);\n\t\t\tif (sessionId != null) {\n\t\t\t\tif (this.sessions.get(sessionId) != null) {\n\t\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\t\tlogger.warn(\"Ignoring CONNECT in session \" + sessionId + \". Already connected.\");\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tlong[] heartbeatIn = SimpMessageHeaderAccessor.getHeartbeat(headers);\n\t\t\t\tlong[] heartbeatOut = getHeartbeatValue();\n\t\t\t\tPrincipal user = SimpMessageHeaderAccessor.getUser(headers);\n\t\t\t\tMessageChannel outChannel = getClientOutboundChannelForSession(sessionId);\n\t\t\t\tthis.sessions.put(sessionId, new SessionInfo(sessionId, user, outChannel, heartbeatIn, heartbeatOut));\n\t\t\t\tSimpMessageHeaderAccessor connectAck = SimpMessageHeaderAccessor.create(SimpMessageType.CONNECT_ACK);\n\t\t\t\tinitHeaders(connectAck);\n\t\t\t\tconnectAck.setSessionId(sessionId);\n\t\t\t\tif (user != null) {\n\t\t\t\t\tconnectAck.setUser(user);\n\t\t\t\t}\n\t\t\t\tconnectAck.setHeader(SimpMessageHeaderAccessor.CONNECT_MESSAGE_HEADER, message);\n\t\t\t\tconnectAck.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, heartbeatOut);\n\t\t\t\tMessage<byte[]> messageOut = MessageBuilder.createMessage(EMPTY_PAYLOAD, connectAck.getMessageHeaders());\n\t\t\t\tgetClientOutboundChannel().send(messageOut);\n\t\t\t}\n\t\t}\n\t\telse if (SimpMessageType.DISCONNECT.equals(messageType)) {\n\t\t\tlogMessage(message);\n\t\t\tif (sessionId != null) {\n\t\t\t\tPrincipal user = SimpMessageHeaderAccessor.getUser(headers);\n\t\t\t\thandleDisconnect(sessionId, user, message);\n\t\t\t}\n\t\t}\n\t\telse if (SimpMessageType.SUBSCRIBE.equals(messageType)) {\n\t\t\tlogMessage(message);\n\t\t\tthis.subscriptionRegistry.registerSubscription(message);\n\t\t}\n\t\telse if (SimpMessageType.UNSUBSCRIBE.equals(messageType)) {\n\t\t\tlogMessage(message);\n\t\t\tthis.subscriptionRegistry.unregisterSubscription(message);\n\t\t}\n\t}\n\n\tprivate void updateSessionReadTime(@Nullable String sessionId) {\n\t\tif (sessionId != null) {\n\t\t\tSessionInfo info = this.sessions.get(sessionId);\n\t\t\tif (info != null) {\n\t\t\t\tinfo.setLastReadTime(System.currentTimeMillis());\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void logMessage(Message<?> message) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tSimpMessageHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, SimpMessageHeaderAccessor.class);\n\t\t\taccessor = (accessor != null ? accessor : SimpMessageHeaderAccessor.wrap(message));\n\t\t\tlogger.debug(\"Processing \" + accessor.getShortLogMessage(message.getPayload()));\n\t\t}\n\t}\n\n\tprivate void initHeaders(SimpMessageHeaderAccessor accessor) {\n\t\tif (getHeaderInitializer() != null) {\n\t\t\tgetHeaderInitializer().initHeaders(accessor);\n\t\t}\n\t}\n\n\tprivate void handleDisconnect(String sessionId, @Nullable Principal user, @Nullable Message<?> origMessage) {\n\t\tthis.sessions.remove(sessionId);\n\t\tthis.subscriptionRegistry.unregisterAllSubscriptions(sessionId);\n\t\tSimpMessageHeaderAccessor accessor = SimpMessageHeaderAccessor.create(SimpMessageType.DISCONNECT_ACK);\n\t\taccessor.setSessionId(sessionId);\n\t\tif (user != null) {\n\t\t\taccessor.setUser(user);\n\t\t}\n\t\tif (origMessage != null) {\n\t\t\taccessor.setHeader(SimpMessageHeaderAccessor.DISCONNECT_MESSAGE_HEADER, origMessage);\n\t\t}\n\t\tinitHeaders(accessor);\n\t\tMessage<byte[]> message = MessageBuilder.createMessage(EMPTY_PAYLOAD, accessor.getMessageHeaders());\n\t\tgetClientOutboundChannel().send(message);\n\t}\n\n\tprotected void sendMessageToSubscribers(@Nullable String destination, Message<?> message) {\n\t\tMultiValueMap<String,String> subscriptions = this.subscriptionRegistry.findSubscriptions(message);\n\t\tif (!subscriptions.isEmpty() && logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Broadcasting to \" + subscriptions.size() + \" sessions.\");\n\t\t}\n\t\tlong now = System.currentTimeMillis();\n\t\tsubscriptions.forEach((sessionId, subscriptionIds) -> {\n\t\t\tfor (String subscriptionId : subscriptionIds) {\n\t\t\t\tSimpMessageHeaderAccessor headerAccessor = SimpMessageHeaderAccessor.create(SimpMessageType.MESSAGE);\n\t\t\t\tinitHeaders(headerAccessor);\n\t\t\t\theaderAccessor.setSessionId(sessionId);\n\t\t\t\theaderAccessor.setSubscriptionId(subscriptionId);\n\t\t\t\theaderAccessor.copyHeadersIfAbsent(message.getHeaders());\n\t\t\t\theaderAccessor.setLeaveMutable(true);\n\t\t\t\tObject payload = message.getPayload();\n\t\t\t\tMessage<?> reply = MessageBuilder.createMessage(payload, headerAccessor.getMessageHeaders());\n\t\t\t\tSessionInfo info = this.sessions.get(sessionId);\n\t\t\t\tif (info != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tinfo.getClientOutboundChannel().send(reply);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\t\t\t\tlogger.error(\"Failed to send \" + message, ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tinfo.setLastWriteTime(now);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"SimpleBrokerMessageHandler [\" + this.subscriptionRegistry + \"]\";\n\t}\n\n\n\tprivate static class SessionInfo {\n\n\t\t/* STOMP spec: receiver SHOULD take into account an error margin */\n\t\tprivate static final long HEARTBEAT_MULTIPLIER = 3;\n\n\t\tprivate final String sessionId;\n\n\t\t@Nullable\n\t\tprivate final Principal user;\n\n\t\tprivate final MessageChannel clientOutboundChannel;\n\n\t\tprivate final long readInterval;\n\n\t\tprivate final long writeInterval;\n\n\t\tprivate volatile long lastReadTime;\n\n\t\tprivate volatile long lastWriteTime;\n\n\n\t\tpublic SessionInfo(String sessionId, @Nullable Principal user, MessageChannel outboundChannel,\n\t\t\t\t@Nullable long[] clientHeartbeat, @Nullable long[] serverHeartbeat) {\n\n\t\t\tthis.sessionId = sessionId;\n\t\t\tthis.user = user;\n\t\t\tthis.clientOutboundChannel = outboundChannel;\n\t\t\tif (clientHeartbeat != null && serverHeartbeat != null) {\n\t\t\t\tthis.readInterval = (clientHeartbeat[0] > 0 && serverHeartbeat[1] > 0 ?\n\t\t\t\t\t\tMath.max(clientHeartbeat[0], serverHeartbeat[1]) * HEARTBEAT_MULTIPLIER : 0);\n\t\t\t\tthis.writeInterval = (clientHeartbeat[1] > 0 && serverHeartbeat[0] > 0 ?\n\t\t\t\t\t\tMath.max(clientHeartbeat[1], serverHeartbeat[0]) : 0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.readInterval = 0;\n\t\t\t\tthis.writeInterval = 0;\n\t\t\t}\n\t\t\tthis.lastReadTime = this.lastWriteTime = System.currentTimeMillis();\n\t\t}\n\n\t\tpublic String getSessionId() {\n\t\t\treturn this.sessionId;\n\t\t}\n\n\t\t@Nullable\n\t\tpublic Principal getUser() {\n\t\t\treturn this.user;\n\t\t}\n\n\t\tpublic MessageChannel getClientOutboundChannel() {\n\t\t\treturn this.clientOutboundChannel;\n\t\t}\n\n\t\tpublic long getReadInterval() {\n\t\t\treturn this.readInterval;\n\t\t}\n\n\t\tpublic long getWriteInterval() {\n\t\t\treturn this.writeInterval;\n\t\t}\n\n\t\tpublic long getLastReadTime() {\n\t\t\treturn this.lastReadTime;\n\t\t}\n\n\t\tpublic void setLastReadTime(long lastReadTime) {\n\t\t\tthis.lastReadTime = lastReadTime;\n\t\t}\n\n\t\tpublic long getLastWriteTime() {\n\t\t\treturn this.lastWriteTime;\n\t\t}\n\n\t\tpublic void setLastWriteTime(long lastWriteTime) {\n\t\t\tthis.lastWriteTime = lastWriteTime;\n\t\t}\n\t}\n\n\n\tprivate class HeartbeatTask implements Runnable {\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tlong now = System.currentTimeMillis();\n\t\t\tfor (SessionInfo info : sessions.values()) {\n\t\t\t\tif (info.getReadInterval() > 0 && (now - info.getLastReadTime()) > info.getReadInterval()) {\n\t\t\t\t\thandleDisconnect(info.getSessionId(), info.getUser(), null);\n\t\t\t\t}\n\t\t\t\tif (info.getWriteInterval() > 0 && (now - info.getLastWriteTime()) > info.getWriteInterval()) {\n\t\t\t\t\tSimpMessageHeaderAccessor accessor = SimpMessageHeaderAccessor.create(SimpMessageType.HEARTBEAT);\n\t\t\t\t\taccessor.setSessionId(info.getSessionId());\n\t\t\t\t\tPrincipal user = info.getUser();\n\t\t\t\t\tif (user != null) {\n\t\t\t\t\t\taccessor.setUser(user);\n\t\t\t\t\t}\n\t\t\t\t\tinitHeaders(accessor);\n\t\t\t\t\taccessor.setLeaveMutable(true);\n\t\t\t\t\tMessageHeaders headers = accessor.getMessageHeaders();\n\t\t\t\t\tinfo.getClientOutboundChannel().send(MessageBuilder.createMessage(EMPTY_PAYLOAD, headers));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler#getClientOutboundChannel()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 478
    },
    "return": "MessageChannel",
    "signature": "public MessageChannel getClientOutboundChannel()",
    "source_code": "\t\tpublic MessageChannel getClientOutboundChannel() {\n\t\t\treturn this.clientOutboundChannel;\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler#getHeaderInitializer()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured header initializer.\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "MessageHeaderInitializer",
    "signature": "public MessageHeaderInitializer getHeaderInitializer()",
    "source_code": "\tpublic MessageHeaderInitializer getHeaderInitializer() {\n\t\treturn this.headerInitializer;\n\t}"
  },
  "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler#getHeartbeatValue()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The configured value for the heart-beat settings.\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "long[]",
    "signature": "public long[] getHeartbeatValue()",
    "source_code": "\tpublic long[] getHeartbeatValue() {\n\t\treturn this.heartbeatValue;\n\t}"
  },
  "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler#getLastReadTime()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 490
    },
    "return": "long",
    "signature": "public long getLastReadTime()",
    "source_code": "\t\tpublic long getLastReadTime() {\n\t\t\treturn this.lastReadTime;\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler#getLastWriteTime()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 498
    },
    "return": "long",
    "signature": "public long getLastWriteTime()",
    "source_code": "\t\tpublic long getLastWriteTime() {\n\t\t\treturn this.lastWriteTime;\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler#getReadInterval()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 482
    },
    "return": "long",
    "signature": "public long getReadInterval()",
    "source_code": "\t\tpublic long getReadInterval() {\n\t\t\treturn this.readInterval;\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler#getSessionId()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 469
    },
    "return": "String",
    "signature": "public String getSessionId()",
    "source_code": "\t\tpublic String getSessionId() {\n\t\t\treturn this.sessionId;\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler#getSubscriptionRegistry()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "SubscriptionRegistry",
    "signature": "public SubscriptionRegistry getSubscriptionRegistry()",
    "source_code": "\tpublic SubscriptionRegistry getSubscriptionRegistry() {\n\t\treturn this.subscriptionRegistry;\n\t}"
  },
  "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler#getTaskScheduler()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured TaskScheduler.\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "TaskScheduler",
    "signature": "public TaskScheduler getTaskScheduler()",
    "source_code": "\tpublic TaskScheduler getTaskScheduler() {\n\t\treturn this.taskScheduler;\n\t}"
  },
  "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler#getUser()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 474
    },
    "return": "Principal",
    "signature": "public Principal getUser()",
    "source_code": "\t\tpublic Principal getUser() {\n\t\t\treturn this.user;\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler#getWriteInterval()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 486
    },
    "return": "long",
    "signature": "public long getWriteInterval()",
    "source_code": "\t\tpublic long getWriteInterval() {\n\t\t\treturn this.writeInterval;\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler#handleMessageInternal(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "void",
    "signature": "protected void handleMessageInternal(Message<?> message)",
    "source_code": "\tprotected void handleMessageInternal(Message<?> message) {\n\t\tMessageHeaders headers = message.getHeaders();\n\t\tString destination = SimpMessageHeaderAccessor.getDestination(headers);\n\t\tString sessionId = SimpMessageHeaderAccessor.getSessionId(headers);\n\n\t\tupdateSessionReadTime(sessionId);\n\n\t\tif (!checkDestinationPrefix(destination)) {\n\t\t\treturn;\n\t\t}\n\n\t\tSimpMessageType messageType = SimpMessageHeaderAccessor.getMessageType(headers);\n\t\tif (SimpMessageType.MESSAGE.equals(messageType)) {\n\t\t\tlogMessage(message);\n\t\t\tsendMessageToSubscribers(destination, message);\n\t\t}\n\t\telse if (SimpMessageType.CONNECT.equals(messageType)) {\n\t\t\tlogMessage(message);\n\t\t\tif (sessionId != null) {\n\t\t\t\tif (this.sessions.get(sessionId) != null) {\n\t\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\t\tlogger.warn(\"Ignoring CONNECT in session \" + sessionId + \". Already connected.\");\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tlong[] heartbeatIn = SimpMessageHeaderAccessor.getHeartbeat(headers);\n\t\t\t\tlong[] heartbeatOut = getHeartbeatValue();\n\t\t\t\tPrincipal user = SimpMessageHeaderAccessor.getUser(headers);\n\t\t\t\tMessageChannel outChannel = getClientOutboundChannelForSession(sessionId);\n\t\t\t\tthis.sessions.put(sessionId, new SessionInfo(sessionId, user, outChannel, heartbeatIn, heartbeatOut));\n\t\t\t\tSimpMessageHeaderAccessor connectAck = SimpMessageHeaderAccessor.create(SimpMessageType.CONNECT_ACK);\n\t\t\t\tinitHeaders(connectAck);\n\t\t\t\tconnectAck.setSessionId(sessionId);\n\t\t\t\tif (user != null) {\n\t\t\t\t\tconnectAck.setUser(user);\n\t\t\t\t}\n\t\t\t\tconnectAck.setHeader(SimpMessageHeaderAccessor.CONNECT_MESSAGE_HEADER, message);\n\t\t\t\tconnectAck.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, heartbeatOut);\n\t\t\t\tMessage<byte[]> messageOut = MessageBuilder.createMessage(EMPTY_PAYLOAD, connectAck.getMessageHeaders());\n\t\t\t\tgetClientOutboundChannel().send(messageOut);\n\t\t\t}\n\t\t}\n\t\telse if (SimpMessageType.DISCONNECT.equals(messageType)) {\n\t\t\tlogMessage(message);\n\t\t\tif (sessionId != null) {\n\t\t\t\tPrincipal user = SimpMessageHeaderAccessor.getUser(headers);\n\t\t\t\thandleDisconnect(sessionId, user, message);\n\t\t\t}\n\t\t}\n\t\telse if (SimpMessageType.SUBSCRIBE.equals(messageType)) {\n\t\t\tlogMessage(message);\n\t\t\tthis.subscriptionRegistry.registerSubscription(message);\n\t\t}\n\t\telse if (SimpMessageType.UNSUBSCRIBE.equals(messageType)) {\n\t\t\tlogMessage(message);\n\t\t\tthis.subscriptionRegistry.unregisterSubscription(message);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler#run()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 511
    },
    "return": "void",
    "signature": "public void run()",
    "source_code": "\t\tpublic void run() {\n\t\t\tlong now = System.currentTimeMillis();\n\t\t\tfor (SessionInfo info : sessions.values()) {\n\t\t\t\tif (info.getReadInterval() > 0 && (now - info.getLastReadTime()) > info.getReadInterval()) {\n\t\t\t\t\thandleDisconnect(info.getSessionId(), info.getUser(), null);\n\t\t\t\t}\n\t\t\t\tif (info.getWriteInterval() > 0 && (now - info.getLastWriteTime()) > info.getWriteInterval()) {\n\t\t\t\t\tSimpMessageHeaderAccessor accessor = SimpMessageHeaderAccessor.create(SimpMessageType.HEARTBEAT);\n\t\t\t\t\taccessor.setSessionId(info.getSessionId());\n\t\t\t\t\tPrincipal user = info.getUser();\n\t\t\t\t\tif (user != null) {\n\t\t\t\t\t\taccessor.setUser(user);\n\t\t\t\t\t}\n\t\t\t\t\tinitHeaders(accessor);\n\t\t\t\t\taccessor.setLeaveMutable(true);\n\t\t\t\t\tMessageHeaders headers = accessor.getMessageHeaders();\n\t\t\t\t\tinfo.getClientOutboundChannel().send(MessageBuilder.createMessage(EMPTY_PAYLOAD, headers));\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler#sendMessageToSubscribers(destination,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "destination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 389
    },
    "return": "void",
    "signature": "protected void sendMessageToSubscribers(@Nullable String destination, Message<?> message)",
    "source_code": "\tprotected void sendMessageToSubscribers(@Nullable String destination, Message<?> message) {\n\t\tMultiValueMap<String,String> subscriptions = this.subscriptionRegistry.findSubscriptions(message);\n\t\tif (!subscriptions.isEmpty() && logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Broadcasting to \" + subscriptions.size() + \" sessions.\");\n\t\t}\n\t\tlong now = System.currentTimeMillis();\n\t\tsubscriptions.forEach((sessionId, subscriptionIds) -> {\n\t\t\tfor (String subscriptionId : subscriptionIds) {\n\t\t\t\tSimpMessageHeaderAccessor headerAccessor = SimpMessageHeaderAccessor.create(SimpMessageType.MESSAGE);\n\t\t\t\tinitHeaders(headerAccessor);\n\t\t\t\theaderAccessor.setSessionId(sessionId);\n\t\t\t\theaderAccessor.setSubscriptionId(subscriptionId);\n\t\t\t\theaderAccessor.copyHeadersIfAbsent(message.getHeaders());\n\t\t\t\theaderAccessor.setLeaveMutable(true);\n\t\t\t\tObject payload = message.getPayload();\n\t\t\t\tMessage<?> reply = MessageBuilder.createMessage(payload, headerAccessor.getMessageHeaders());\n\t\t\t\tSessionInfo info = this.sessions.get(sessionId);\n\t\t\t\tif (info != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tinfo.getClientOutboundChannel().send(reply);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\t\t\t\tlogger.error(\"Failed to send \" + message, ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tinfo.setLastWriteTime(now);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler#setCacheLimit(cacheLimit)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * When configured, the specified cache limit is passed down to the\n\t * underlying SubscriptionRegistry, overriding any default there.\n\t * <p>With a standard {@link DefaultSubscriptionRegistry}, the default\n\t * cache limit is 1024.\n\t * @since 4.3.2\n\t * @see #setSubscriptionRegistry\n\t * @see DefaultSubscriptionRegistry#setCacheLimit\n\t * @see DefaultSubscriptionRegistry#DEFAULT_CACHE_LIMIT\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cacheLimit"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "public void setCacheLimit(@Nullable Integer cacheLimit)",
    "source_code": "\tpublic void setCacheLimit(@Nullable Integer cacheLimit) {\n\t\tthis.cacheLimit = cacheLimit;\n\t\tinitCacheLimitToUse();\n\t}"
  },
  "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler#setHeaderInitializer(headerInitializer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a {@link MessageHeaderInitializer} to apply to the headers\n\t * of all messages sent to the client outbound channel.\n\t * <p>By default this property is not set.\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerInitializer"
    ],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "void",
    "signature": "public void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer)",
    "source_code": "\tpublic void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer) {\n\t\tthis.headerInitializer = headerInitializer;\n\t}"
  },
  "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler#setHeartbeatValue(heartbeat)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the value for the heart-beat settings. The first number\n\t * represents how often the server will write or send a heartbeat.\n\t * The second is how often the client should write. 0 means no heartbeats.\n\t * <p>By default this is set to \"0, 0\" unless the {@link #setTaskScheduler\n\t * taskScheduler} in which case the default becomes \"10000,10000\"\n\t * (in milliseconds).\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "heartbeat"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "void",
    "signature": "public void setHeartbeatValue(@Nullable long[] heartbeat)",
    "source_code": "\tpublic void setHeartbeatValue(@Nullable long[] heartbeat) {\n\t\tif (heartbeat != null && (heartbeat.length != 2 || heartbeat[0] < 0 || heartbeat[1] < 0)) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid heart-beat: \" + Arrays.toString(heartbeat));\n\t\t}\n\t\tthis.heartbeatValue = heartbeat;\n\t}"
  },
  "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler#setLastReadTime(lastReadTime)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lastReadTime"
    ],
    "position": {
      "column": 1,
      "line": 494
    },
    "return": "void",
    "signature": "public void setLastReadTime(long lastReadTime)",
    "source_code": "\t\tpublic void setLastReadTime(long lastReadTime) {\n\t\t\tthis.lastReadTime = lastReadTime;\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler#setLastWriteTime(lastWriteTime)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lastWriteTime"
    ],
    "position": {
      "column": 1,
      "line": 502
    },
    "return": "void",
    "signature": "public void setLastWriteTime(long lastWriteTime)",
    "source_code": "\t\tpublic void setLastWriteTime(long lastWriteTime) {\n\t\t\tthis.lastWriteTime = lastWriteTime;\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler#setPathMatcher(pathMatcher)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * When configured, the given PathMatcher is passed down to the underlying\n\t * SubscriptionRegistry to use for matching destination to subscriptions.\n\t * <p>Default is a standard {@link org.springframework.util.AntPathMatcher}.\n\t * @since 4.1\n\t * @see #setSubscriptionRegistry\n\t * @see DefaultSubscriptionRegistry#setPathMatcher\n\t * @see org.springframework.util.AntPathMatcher\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pathMatcher"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void setPathMatcher(@Nullable PathMatcher pathMatcher)",
    "source_code": "\tpublic void setPathMatcher(@Nullable PathMatcher pathMatcher) {\n\t\tthis.pathMatcher = pathMatcher;\n\t\tinitPathMatcherToUse();\n\t}"
  },
  "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler#setSelectorHeaderName(selectorHeaderName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the name of a header that a subscription message can have for\n\t * the purpose of filtering messages matched to the subscription. The header\n\t * value is expected to be a Spring EL boolean expression to be applied to\n\t * the headers of messages matched to the subscription.\n\t * <p>For example:\n\t * <pre>\n\t * headers.foo == 'bar'\n\t * </pre>\n\t * <p>By default this is set to \"selector\". You can set it to a different\n\t * name, or to {@code null} to turn off support for a selector header.\n\t * @param selectorHeaderName the name to use for a selector header\n\t * @since 4.3.17\n\t * @see #setSubscriptionRegistry\n\t * @see DefaultSubscriptionRegistry#setSelectorHeaderName(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "selectorHeaderName"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "void",
    "signature": "public void setSelectorHeaderName(@Nullable String selectorHeaderName)",
    "source_code": "\tpublic void setSelectorHeaderName(@Nullable String selectorHeaderName) {\n\t\tthis.selectorHeaderName = selectorHeaderName;\n\t\tinitSelectorHeaderNameToUse();\n\t}"
  },
  "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler#setSubscriptionRegistry(subscriptionRegistry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a custom SubscriptionRegistry to use for storing subscriptions.\n\t * <p><strong>Note</strong> that when a custom PathMatcher is configured via\n\t * {@link #setPathMatcher}, if the custom registry is not an instance of\n\t * {@link DefaultSubscriptionRegistry}, the provided PathMatcher is not used\n\t * and must be configured directly on the custom registry.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "subscriptionRegistry"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "void",
    "signature": "public void setSubscriptionRegistry(SubscriptionRegistry subscriptionRegistry)",
    "source_code": "\tpublic void setSubscriptionRegistry(SubscriptionRegistry subscriptionRegistry) {\n\t\tAssert.notNull(subscriptionRegistry, \"SubscriptionRegistry must not be null\");\n\t\tthis.subscriptionRegistry = subscriptionRegistry;\n\t\tinitPathMatcherToUse();\n\t\tinitCacheLimitToUse();\n\t\tinitSelectorHeaderNameToUse();\n\t}"
  },
  "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler#setTaskScheduler(taskScheduler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@link org.springframework.scheduling.TaskScheduler} to\n\t * use for providing heartbeat support. Setting this property also sets the\n\t * {@link #setHeartbeatValue heartbeatValue} to \"10000, 10000\".\n\t * <p>By default this is not set.\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "taskScheduler"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "void",
    "signature": "public void setTaskScheduler(@Nullable TaskScheduler taskScheduler)",
    "source_code": "\tpublic void setTaskScheduler(@Nullable TaskScheduler taskScheduler) {\n\t\tthis.taskScheduler = taskScheduler;\n\t\tif (taskScheduler != null && this.heartbeatValue == null) {\n\t\t\tthis.heartbeatValue = new long[] {10000, 10000};\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler#startInternal()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "void",
    "signature": "public void startInternal()",
    "source_code": "\tpublic void startInternal() {\n\t\tpublishBrokerAvailableEvent();\n\t\tif (this.taskScheduler != null) {\n\t\t\tDuration interval = initHeartbeatTaskDelay();\n\t\t\tif (interval.toMillis() > 0) {\n\t\t\t\tthis.heartbeatFuture = this.taskScheduler.scheduleWithFixedDelay(new HeartbeatTask(), interval);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tAssert.isTrue(getHeartbeatValue() == null ||\n\t\t\t\t\t(getHeartbeatValue()[0] == 0 && getHeartbeatValue()[1] == 0),\n\t\t\t\t\t\"Heartbeat values configured but no TaskScheduler provided\");\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler#stopInternal()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 283
    },
    "return": "void",
    "signature": "public void stopInternal()",
    "source_code": "\tpublic void stopInternal() {\n\t\tpublishBrokerUnavailableEvent();\n\t\tif (this.heartbeatFuture != null) {\n\t\t\tthis.heartbeatFuture.cancel(true);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 424
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn \"SimpleBrokerMessageHandler [\" + this.subscriptionRegistry + \"]\";\n\t}"
  },
  "org.springframework.messaging.simp.broker.logger": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = SimpLogging.forLogName(getClass());",
    "type": "Log"
  },
  "org.springframework.messaging.simp.stomp.ACCEPT_VERSION": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "signature": "public String ACCEPT_VERSION",
    "source_code": "\tpublic static final String ACCEPT_VERSION = \"accept-version\";",
    "type": "String"
  },
  "org.springframework.messaging.simp.stomp.ACK": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "signature": "public String ACK",
    "source_code": "\tpublic static final String ACK = \"ack\";",
    "type": "String"
  },
  "org.springframework.messaging.simp.stomp.CONTENT_LENGTH": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "signature": "public String CONTENT_LENGTH",
    "source_code": "\tpublic static final String CONTENT_LENGTH = \"content-length\"; // SEND, MESSAGE, ERROR",
    "type": "String"
  },
  "org.springframework.messaging.simp.stomp.CONTENT_TYPE": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "signature": "public String CONTENT_TYPE",
    "source_code": "\tpublic static final String CONTENT_TYPE = \"content-type\"; // SEND, MESSAGE, ERROR",
    "type": "String"
  },
  "org.springframework.messaging.simp.stomp.DESTINATION": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "signature": "public String DESTINATION",
    "source_code": "\tpublic static final String DESTINATION = \"destination\";",
    "type": "String"
  },
  "org.springframework.messaging.simp.stomp.HEARTBEAT": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "signature": "public String HEARTBEAT",
    "source_code": "\tpublic static final String HEARTBEAT = \"heart-beat\";",
    "type": "String"
  },
  "org.springframework.messaging.simp.stomp.HOST": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "signature": "public String HOST",
    "source_code": "\tpublic static final String HOST = \"host\";",
    "type": "String"
  },
  "org.springframework.messaging.simp.stomp.ID": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "signature": "public String ID",
    "source_code": "\tpublic static final String ID = \"id\";",
    "type": "String"
  },
  "org.springframework.messaging.simp.stomp.LOGIN": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "signature": "public String LOGIN",
    "source_code": "\tpublic static final String LOGIN = \"login\";",
    "type": "String"
  },
  "org.springframework.messaging.simp.stomp.MESSAGE_ID": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "signature": "public String MESSAGE_ID",
    "source_code": "\tpublic static final String MESSAGE_ID = \"message-id\";",
    "type": "String"
  },
  "org.springframework.messaging.simp.stomp.PASSCODE": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "signature": "public String PASSCODE",
    "source_code": "\tpublic static final String PASSCODE = \"passcode\";",
    "type": "String"
  },
  "org.springframework.messaging.simp.stomp.RECEIPT": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "signature": "public String RECEIPT",
    "source_code": "\tpublic static final String RECEIPT = \"receipt\"; // any client frame other than CONNECT",
    "type": "String"
  },
  "org.springframework.messaging.simp.stomp.RECEIPT_ID": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "signature": "public String RECEIPT_ID",
    "source_code": "\tpublic static final String RECEIPT_ID = \"receipt-id\";",
    "type": "String"
  },
  "org.springframework.messaging.simp.stomp.SERVER": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "signature": "public String SERVER",
    "source_code": "\tpublic static final String SERVER = \"server\";",
    "type": "String"
  },
  "org.springframework.messaging.simp.stomp.SESSION": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "signature": "public String SESSION",
    "source_code": "\tpublic static final String SESSION = \"session\";",
    "type": "String"
  },
  "org.springframework.messaging.simp.stomp.SUBSCRIPTION": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "signature": "public String SUBSCRIPTION",
    "source_code": "\tpublic static final String SUBSCRIPTION = \"subscription\";",
    "type": "String"
  },
  "org.springframework.messaging.simp.stomp.SYSTEM_SESSION_ID": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The system session ID.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "signature": "public String SYSTEM_SESSION_ID",
    "source_code": "\tpublic static final String SYSTEM_SESSION_ID = \"_system_\";",
    "type": "String"
  },
  "org.springframework.messaging.simp.stomp.Stats": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Contract for access to session counters.\n\t * @since 5.2\n\t */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 1137
    },
    "signature": "public interface Stats",
    "source_code": "\tpublic interface Stats {\n\n\t\t/**\n\t\t * The number of connection handlers.\n\t\t */\n\t\tint getTotalHandlers();\n\n\t\t/**\n\t\t * The number of CONNECT frames processed.\n\t\t */\n\t\tint getTotalConnect();\n\n\t\t/**\n\t\t * The number of CONNECTED frames processed.\n\t\t */\n\t\tint getTotalConnected();\n\n\t\t/**\n\t\t * The number of DISCONNECT frames processed.\n\t\t */\n\t\tint getTotalDisconnect();\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A {@link org.springframework.messaging.MessageHandler} that handles messages by\n * forwarding them to a STOMP broker.\n *\n * <p>For each new {@link SimpMessageType#CONNECT CONNECT} message, an independent TCP\n * connection to the broker is opened and used exclusively for all messages from the\n * client that originated the CONNECT message. Messages from the same client are\n * identified through the session id message header. Reversely, when the STOMP broker\n * sends messages back on the TCP connection, those messages are enriched with the\n * session id of the client and sent back downstream through the {@link MessageChannel}\n * provided to the constructor.\n *\n * <p>This class also automatically opens a default \"system\" TCP connection to the\n * message broker that is used for sending messages that originate from the server\n * application (as opposed to from a client). Such messages are not associated with\n * any client and therefore do not have a session id header. The \"system\" connection\n * is effectively shared and cannot be used to receive messages. Several properties\n * are provided to configure the \"system\" connection including:\n * <ul>\n * <li>{@link #setSystemLogin}</li>\n * <li>{@link #setSystemPasscode}</li>\n * <li>{@link #setSystemHeartbeatSendInterval}</li>\n * <li>{@link #setSystemHeartbeatReceiveInterval}</li>\n * </ul>\n *\n * @author Rossen Stoyanchev\n * @author Andy Wilkinson\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "signature": "public class StompBrokerRelayMessageHandler",
    "source_code": "public class StompBrokerRelayMessageHandler extends AbstractBrokerMessageHandler {\n\n\t/**\n\t * The system session ID.\n\t */\n\tpublic static final String SYSTEM_SESSION_ID = \"_system_\";\n\n\t/** STOMP recommended error of margin for receiving heartbeats. */\n\tprivate static final long HEARTBEAT_MULTIPLIER = 3;\n\n\t/**\n\t * Heartbeat starts once CONNECTED frame with heartbeat settings is received.\n\t * If CONNECTED doesn't arrive within a minute, we'll close the connection.\n\t */\n\tprivate static final int MAX_TIME_TO_CONNECTED_FRAME = 60 * 1000;\n\n\tprivate static final byte[] EMPTY_PAYLOAD = new byte[0];\n\n\tprivate static final CompletableFuture<Void> EMPTY_TASK = CompletableFuture.completedFuture(null);\n\n\tprivate static final StompHeaderAccessor HEART_BEAT_ACCESSOR;\n\n\tprivate static final Message<byte[]> HEARTBEAT_MESSAGE;\n\n\tprivate static final boolean reactorNettyClientPresent;\n\n\tprivate static final boolean reactorNetty2ClientPresent;\n\n\tstatic {\n\t\tHEART_BEAT_ACCESSOR = StompHeaderAccessor.createForHeartbeat();\n\t\tHEARTBEAT_MESSAGE = MessageBuilder.createMessage(\n\t\t\t\tStompDecoder.HEARTBEAT_PAYLOAD, HEART_BEAT_ACCESSOR.getMessageHeaders());\n\n\t\tClassLoader classLoader = StompBrokerRelayMessageHandler.class.getClassLoader();\n\t\treactorNettyClientPresent = ClassUtils.isPresent(\"reactor.netty.http.client.HttpClient\", classLoader);\n\t\treactorNetty2ClientPresent = ClassUtils.isPresent(\"reactor.netty5.http.client.HttpClient\", classLoader);\n\t}\n\n\n\tprivate String relayHost = \"127.0.0.1\";\n\n\tprivate int relayPort = 61613;\n\n\tprivate String clientLogin = \"guest\";\n\n\tprivate String clientPasscode = \"guest\";\n\n\tprivate String systemLogin = \"guest\";\n\n\tprivate String systemPasscode = \"guest\";\n\n\tprivate long systemHeartbeatSendInterval = 10000;\n\n\tprivate long systemHeartbeatReceiveInterval = 10000;\n\n\tprivate final Map<String, MessageHandler> systemSubscriptions = new HashMap<>(4);\n\n\t@Nullable\n\tprivate String virtualHost;\n\n\t@Nullable\n\tprivate TcpOperations<byte[]> tcpClient;\n\n\t@Nullable\n\tprivate MessageHeaderInitializer headerInitializer;\n\n\tprivate final DefaultStats stats = new DefaultStats();\n\n\tprivate final Map<String, RelayConnectionHandler> connectionHandlers = new ConcurrentHashMap<>();\n\n\t@Nullable\n\tprivate TaskScheduler taskScheduler;\n\n\n\t/**\n\t * Create a StompBrokerRelayMessageHandler instance with the given message channels\n\t * and destination prefixes.\n\t * @param inboundChannel the channel for receiving messages from clients (e.g. WebSocket clients)\n\t * @param outboundChannel the channel for sending messages to clients (e.g. WebSocket clients)\n\t * @param brokerChannel the channel for the application to send messages to the broker\n\t * @param destinationPrefixes the broker supported destination prefixes; destinations\n\t * that do not match the given prefix are ignored.\n\t */\n\tpublic StompBrokerRelayMessageHandler(SubscribableChannel inboundChannel, MessageChannel outboundChannel,\n\t\t\tSubscribableChannel brokerChannel, Collection<String> destinationPrefixes) {\n\n\t\tsuper(inboundChannel, outboundChannel, brokerChannel, destinationPrefixes);\n\t}\n\n\n\t/**\n\t * Set the STOMP message broker host.\n\t */\n\tpublic void setRelayHost(String relayHost) {\n\t\tAssert.hasText(relayHost, \"relayHost must not be empty\");\n\t\tthis.relayHost = relayHost;\n\t}\n\n\t/**\n\t * Return the STOMP message broker host.\n\t */\n\tpublic String getRelayHost() {\n\t\treturn this.relayHost;\n\t}\n\n\t/**\n\t * Set the STOMP message broker port.\n\t */\n\tpublic void setRelayPort(int relayPort) {\n\t\tthis.relayPort = relayPort;\n\t}\n\n\t/**\n\t * Return the STOMP message broker port.\n\t */\n\tpublic int getRelayPort() {\n\t\treturn this.relayPort;\n\t}\n\t/**\n\t * Set the login to use when creating connections to the STOMP broker on\n\t * behalf of connected clients.\n\t * <p>By default this is set to \"guest\".\n\t * @see #setSystemLogin(String)\n\t */\n\tpublic void setClientLogin(String clientLogin) {\n\t\tAssert.hasText(clientLogin, \"clientLogin must not be empty\");\n\t\tthis.clientLogin = clientLogin;\n\t}\n\n\t/**\n\t * Return the configured login to use for connections to the STOMP broker\n\t * on behalf of connected clients.\n\t * @see #getSystemLogin()\n\t */\n\tpublic String getClientLogin() {\n\t\treturn this.clientLogin;\n\t}\n\n\t/**\n\t * Set the client passcode to use to create connections to the STOMP broker on\n\t * behalf of connected clients.\n\t * <p>By default this is set to \"guest\".\n\t * @see #setSystemPasscode\n\t */\n\tpublic void setClientPasscode(String clientPasscode) {\n\t\tAssert.hasText(clientPasscode, \"clientPasscode must not be empty\");\n\t\tthis.clientPasscode = clientPasscode;\n\t}\n\n\t/**\n\t * Return the configured passcode to use for connections to the STOMP broker on\n\t * behalf of connected clients.\n\t * @see #getSystemPasscode()\n\t */\n\tpublic String getClientPasscode() {\n\t\treturn this.clientPasscode;\n\t}\n\n\t/**\n\t * Set the login for the shared \"system\" connection used to send messages to\n\t * the STOMP broker from within the application, i.e. messages not associated\n\t * with a specific client session (e.g. REST/HTTP request handling method).\n\t * <p>By default this is set to \"guest\".\n\t */\n\tpublic void setSystemLogin(String systemLogin) {\n\t\tAssert.hasText(systemLogin, \"systemLogin must not be empty\");\n\t\tthis.systemLogin = systemLogin;\n\t}\n\n\t/**\n\t * Return the login used for the shared \"system\" connection to the STOMP broker.\n\t */\n\tpublic String getSystemLogin() {\n\t\treturn this.systemLogin;\n\t}\n\n\t/**\n\t * Set the passcode for the shared \"system\" connection used to send messages to\n\t * the STOMP broker from within the application, i.e. messages not associated\n\t * with a specific client session (e.g. REST/HTTP request handling method).\n\t * <p>By default this is set to \"guest\".\n\t */\n\tpublic void setSystemPasscode(String systemPasscode) {\n\t\tthis.systemPasscode = systemPasscode;\n\t}\n\n\t/**\n\t * Return the passcode used for the shared \"system\" connection to the STOMP broker.\n\t */\n\tpublic String getSystemPasscode() {\n\t\treturn this.systemPasscode;\n\t}\n\n\n\t/**\n\t * Set the interval, in milliseconds, at which the \"system\" connection will, in the\n\t * absence of any other data being sent, send a heartbeat to the STOMP broker. A value\n\t * of zero will prevent heartbeats from being sent to the broker.\n\t * <p>The default value is 10000.\n\t * <p>See class-level documentation for more information on the \"system\" connection.\n\t */\n\tpublic void setSystemHeartbeatSendInterval(long systemHeartbeatSendInterval) {\n\t\tthis.systemHeartbeatSendInterval = systemHeartbeatSendInterval;\n\t}\n\n\t/**\n\t * Return the interval, in milliseconds, at which the \"system\" connection will\n\t * send heartbeats to the STOMP broker.\n\t */\n\tpublic long getSystemHeartbeatSendInterval() {\n\t\treturn this.systemHeartbeatSendInterval;\n\t}\n\n\t/**\n\t * Set the maximum interval, in milliseconds, at which the \"system\" connection\n\t * expects, in the absence of any other data, to receive a heartbeat from the STOMP\n\t * broker. A value of zero will configure the connection to expect not to receive\n\t * heartbeats from the broker.\n\t * <p>The default value is 10000.\n\t * <p>See class-level documentation for more information on the \"system\" connection.\n\t */\n\tpublic void setSystemHeartbeatReceiveInterval(long heartbeatReceiveInterval) {\n\t\tthis.systemHeartbeatReceiveInterval = heartbeatReceiveInterval;\n\t}\n\n\t/**\n\t * Return the interval, in milliseconds, at which the \"system\" connection expects\n\t * to receive heartbeats from the STOMP broker.\n\t */\n\tpublic long getSystemHeartbeatReceiveInterval() {\n\t\treturn this.systemHeartbeatReceiveInterval;\n\t}\n\n\t/**\n\t * Configure one more destinations to subscribe to on the shared \"system\"\n\t * connection along with MessageHandler's to handle received messages.\n\t * <p>This is for internal use in a multi-application server scenario where\n\t * servers forward messages to each other (e.g. unresolved user destinations).\n\t * @param subscriptions the destinations to subscribe to.\n\t */\n\tpublic void setSystemSubscriptions(@Nullable Map<String, MessageHandler> subscriptions) {\n\t\tthis.systemSubscriptions.clear();\n\t\tif (subscriptions != null) {\n\t\t\tthis.systemSubscriptions.putAll(subscriptions);\n\t\t}\n\t}\n\n\t/**\n\t * Return the configured map with subscriptions on the \"system\" connection.\n\t */\n\tpublic Map<String, MessageHandler> getSystemSubscriptions() {\n\t\treturn this.systemSubscriptions;\n\t}\n\n\t/**\n\t * Set the value of the \"host\" header to use in STOMP CONNECT frames. When this\n\t * property is configured, a \"host\" header will be added to every STOMP frame sent to\n\t * the STOMP broker. This may be useful for example in a cloud environment where the\n\t * actual host to which the TCP connection is established is different from the host\n\t * providing the cloud-based STOMP service.\n\t * <p>By default this property is not set.\n\t */\n\tpublic void setVirtualHost(@Nullable String virtualHost) {\n\t\tthis.virtualHost = virtualHost;\n\t}\n\n\t/**\n\t * Return the configured virtual host value.\n\t */\n\t@Nullable\n\tpublic String getVirtualHost() {\n\t\treturn this.virtualHost;\n\t}\n\n\t/**\n\t * Configure a TCP client for managing TCP connections to the STOMP broker.\n\t * <p>By default {@link ReactorNettyTcpClient} or\n\t * {@link ReactorNetty2TcpClient} is used.\n\t * <p><strong>Note:</strong> when this property is used, any\n\t * {@link #setRelayHost(String) host} or {@link #setRelayPort(int) port}\n\t * specified are effectively ignored.\n\t */\n\tpublic void setTcpClient(@Nullable TcpOperations<byte[]> tcpClient) {\n\t\tthis.tcpClient = tcpClient;\n\t}\n\n\t/**\n\t * Get the configured TCP client (never {@code null} unless not configured\n\t * invoked and this method is invoked before the handler is started and\n\t * hence a default implementation initialized).\n\t */\n\t@Nullable\n\tpublic TcpOperations<byte[]> getTcpClient() {\n\t\treturn this.tcpClient;\n\t}\n\n\t/**\n\t * Configure a {@link MessageHeaderInitializer} to apply to the headers of all\n\t * messages created through the {@code StompBrokerRelayMessageHandler} that\n\t * are sent to the client outbound message channel.\n\t * <p>By default this property is not set.\n\t */\n\tpublic void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer) {\n\t\tthis.headerInitializer = headerInitializer;\n\t}\n\n\t/**\n\t * Return the configured header initializer.\n\t */\n\t@Nullable\n\tpublic MessageHeaderInitializer getHeaderInitializer() {\n\t\treturn this.headerInitializer;\n\t}\n\n\t/**\n\t * Return a String describing internal state and counters.\n\t * Effectively {@code toString()} on {@link #getStats() getStats()}.\n\t */\n\tpublic String getStatsInfo() {\n\t\treturn this.stats.toString();\n\t}\n\n\t/**\n\t * Return a structured object with internal state and counters.\n\t * @since 5.2\n\t */\n\tpublic Stats getStats() {\n\t\treturn this.stats;\n\t}\n\n\n\t/**\n\t * Return the current count of TCP connection to the broker.\n\t */\n\tpublic int getConnectionCount() {\n\t\treturn this.connectionHandlers.size();\n\t}\n\n\t/**\n\t * Configure the {@link TaskScheduler} to use to reset client-to-broker\n\t * message count in the current heartbeat period. For more details, see\n\t * {@link org.springframework.messaging.simp.config.StompBrokerRelayRegistration#setTaskScheduler(TaskScheduler)}.\n\t * @param taskScheduler the scheduler to use\n\t * @since 5.3\n\t */\n\tpublic void setTaskScheduler(@Nullable TaskScheduler taskScheduler) {\n\t\tthis.taskScheduler = taskScheduler;\n\t}\n\n\t@Nullable\n\tpublic TaskScheduler getTaskScheduler() {\n\t\treturn this.taskScheduler;\n\t}\n\n\n\t@Override\n\tprotected void startInternal() {\n\t\tif (this.tcpClient == null) {\n\t\t\tthis.tcpClient = initTcpClient();\n\t\t}\n\n\t\tif (logger.isInfoEnabled()) {\n\t\t\tlogger.info(\"Starting \\\"system\\\" session, \" + this);\n\t\t}\n\n\t\tStompHeaderAccessor accessor = StompHeaderAccessor.create(StompCommand.CONNECT);\n\t\taccessor.setAcceptVersion(\"1.1,1.2\");\n\t\taccessor.setLogin(this.systemLogin);\n\t\taccessor.setPasscode(this.systemPasscode);\n\t\taccessor.setHeartbeat(this.systemHeartbeatSendInterval, this.systemHeartbeatReceiveInterval);\n\t\tString virtualHost = getVirtualHost();\n\t\tif (virtualHost != null) {\n\t\t\taccessor.setHost(virtualHost);\n\t\t}\n\t\taccessor.setSessionId(SYSTEM_SESSION_ID);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Forwarding \" + accessor.getShortLogMessage(EMPTY_PAYLOAD));\n\t\t}\n\n\t\tSystemSessionConnectionHandler handler = new SystemSessionConnectionHandler(accessor);\n\t\tthis.connectionHandlers.put(handler.getSessionId(), handler);\n\n\t\tthis.stats.incrementConnectCount();\n\t\tthis.tcpClient.connectAsync(handler, new FixedIntervalReconnectStrategy(5000));\n\n\t\tif (this.taskScheduler != null) {\n\t\t\tthis.taskScheduler.scheduleWithFixedDelay(new ClientSendMessageCountTask(), Duration.ofMillis(5000));\n\t\t}\n\t}\n\n\tprivate TcpOperations<byte[]> initTcpClient() {\n\t\tStompDecoder decoder = new StompDecoder();\n\t\tif (this.headerInitializer != null) {\n\t\t\tdecoder.setHeaderInitializer(this.headerInitializer);\n\t\t}\n\t\tif (reactorNettyClientPresent) {\n\t\t\tReactorNettyCodec<byte[]> codec = new StompReactorNettyCodec(decoder);\n\t\t\tReactorNettyTcpClient<byte[]> client = new ReactorNettyTcpClient<>(this.relayHost, this.relayPort, codec);\n\t\t\tclient.setLogger(SimpLogging.forLog(client.getLogger()));\n\t\t\treturn client;\n\t\t}\n\t\telse if (reactorNetty2ClientPresent) {\n\t\t\tTcpMessageCodec<byte[]> codec = new StompTcpMessageCodec(decoder);\n\t\t\tReactorNetty2TcpClient<byte[]> client = new ReactorNetty2TcpClient<>(this.relayHost, this.relayPort, codec);\n\t\t\tclient.setLogger(SimpLogging.forLog(client.getLogger()));\n\t\t\treturn client;\n\t\t}\n\t\tthrow new IllegalStateException(\"No compatible version of Reactor Netty\");\n\t}\n\n\t@Override\n\tprotected void stopInternal() {\n\t\tpublishBrokerUnavailableEvent();\n\t\tif (this.tcpClient != null) {\n\t\t\ttry {\n\t\t\t\tthis.tcpClient.shutdownAsync().get(5000, TimeUnit.MILLISECONDS);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tlogger.error(\"Error in shutdown of TCP client\", ex);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tprotected void handleMessageInternal(Message<?> message) {\n\t\tString sessionId = SimpMessageHeaderAccessor.getSessionId(message.getHeaders());\n\n\t\tif (!isBrokerAvailable()) {\n\t\t\tif (sessionId == null || SYSTEM_SESSION_ID.equals(sessionId)) {\n\t\t\t\tthrow new MessageDeliveryException(\"Message broker not active. Consider subscribing to \" +\n\t\t\t\t\t\t\"receive BrokerAvailabilityEvent's from an ApplicationListener Spring bean.\");\n\t\t\t}\n\t\t\tRelayConnectionHandler handler = this.connectionHandlers.get(sessionId);\n\t\t\tif (handler != null) {\n\t\t\t\thandler.sendStompErrorFrameToClient(\"Broker not available.\");\n\t\t\t\thandler.clearConnection();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tStompHeaderAccessor accessor = StompHeaderAccessor.create(StompCommand.ERROR);\n\t\t\t\tif (getHeaderInitializer() != null) {\n\t\t\t\t\tgetHeaderInitializer().initHeaders(accessor);\n\t\t\t\t}\n\t\t\t\taccessor.setSessionId(sessionId);\n\t\t\t\tPrincipal user = SimpMessageHeaderAccessor.getUser(message.getHeaders());\n\t\t\t\tif (user != null) {\n\t\t\t\t\taccessor.setUser(user);\n\t\t\t\t}\n\t\t\t\taccessor.setMessage(\"Broker not available.\");\n\t\t\t\tMessageHeaders headers = accessor.getMessageHeaders();\n\t\t\t\tgetClientOutboundChannel().send(MessageBuilder.createMessage(EMPTY_PAYLOAD, headers));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tStompHeaderAccessor stompHeaderAccessor;\n\t\tStompCommand command;\n\n\t\tMessageHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, MessageHeaderAccessor.class);\n\t\tif (accessor == null) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"No header accessor (not using the SimpMessagingTemplate?): \" + message);\n\t\t}\n\t\telse if (accessor instanceof StompHeaderAccessor _stompHeaderAccessor) {\n\t\t\tstompHeaderAccessor = _stompHeaderAccessor;\n\t\t\tcommand = stompHeaderAccessor.getCommand();\n\t\t}\n\t\telse if (accessor instanceof SimpMessageHeaderAccessor) {\n\t\t\tstompHeaderAccessor = StompHeaderAccessor.wrap(message);\n\t\t\tcommand = stompHeaderAccessor.getCommand();\n\t\t\tif (command == null) {\n\t\t\t\tcommand = stompHeaderAccessor.updateStompCommandAsClientMessage();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Unexpected header accessor type \" + accessor.getClass() + \" in \" + message);\n\t\t}\n\n\t\tif (sessionId == null) {\n\t\t\tif (!SimpMessageType.MESSAGE.equals(stompHeaderAccessor.getMessageType())) {\n\t\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\t\tlogger.error(\"Only STOMP SEND supported from within the server side. Ignoring \" + message);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsessionId = SYSTEM_SESSION_ID;\n\t\t\tstompHeaderAccessor.setSessionId(sessionId);\n\t\t}\n\n\t\tif (StompCommand.CONNECT.equals(command) || StompCommand.STOMP.equals(command)) {\n\t\t\tif (this.connectionHandlers.get(sessionId) != null) {\n\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\tlogger.warn(\"Ignoring CONNECT in session \" + sessionId + \". Already connected.\");\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(stompHeaderAccessor.getShortLogMessage(EMPTY_PAYLOAD));\n\t\t\t}\n\t\t\tstompHeaderAccessor = (stompHeaderAccessor.isMutable() ? stompHeaderAccessor : StompHeaderAccessor.wrap(message));\n\t\t\tstompHeaderAccessor.setLogin(this.clientLogin);\n\t\t\tstompHeaderAccessor.setPasscode(this.clientPasscode);\n\t\t\tif (getVirtualHost() != null) {\n\t\t\t\tstompHeaderAccessor.setHost(getVirtualHost());\n\t\t\t}\n\t\t\tRelayConnectionHandler handler = new RelayConnectionHandler(sessionId, stompHeaderAccessor);\n\t\t\tthis.connectionHandlers.put(sessionId, handler);\n\t\t\tthis.stats.incrementConnectCount();\n\t\t\tAssert.state(this.tcpClient != null, \"No TCP client available\");\n\t\t\tthis.tcpClient.connectAsync(handler);\n\t\t}\n\t\telse if (StompCommand.DISCONNECT.equals(command)) {\n\t\t\tRelayConnectionHandler handler = this.connectionHandlers.get(sessionId);\n\t\t\tif (handler == null) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Ignoring DISCONNECT in session \" + sessionId + \". Connection already cleaned up.\");\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.stats.incrementDisconnectCount();\n\t\t\thandler.forward(message, stompHeaderAccessor);\n\t\t}\n\t\telse {\n\t\t\tRelayConnectionHandler handler = this.connectionHandlers.get(sessionId);\n\t\t\tif (handler == null) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"No TCP connection for session \" + sessionId + \" in \" + message);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tString destination = stompHeaderAccessor.getDestination();\n\t\t\tif (command != null && command.requiresDestination() && !checkDestinationPrefix(destination)) {\n\t\t\t\t// Not a broker destination but send a heartbeat to keep the connection\n\t\t\t\tif (handler.shouldSendHeartbeatForIgnoredMessage()) {\n\t\t\t\t\thandler.forward(HEARTBEAT_MESSAGE, HEART_BEAT_ACCESSOR);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\thandler.forward(message, stompHeaderAccessor);\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"StompBrokerRelay[\" + getTcpClientInfo() + \"]\";\n\t}\n\n\tprivate String getTcpClientInfo() {\n\t\treturn this.tcpClient != null ? this.tcpClient.toString() : this.relayHost + \":\" + this.relayPort;\n\t}\n\n\n\tprivate class RelayConnectionHandler implements StompTcpConnectionHandler<byte[]> {\n\n\t\tprivate final String sessionId;\n\n\t\tprivate final StompHeaderAccessor connectHeaders;\n\n\t\tprivate final boolean isRemoteClientSession;\n\n\t\tprivate final MessageChannel outboundChannel;\n\n\t\t@Nullable\n\t\tprivate volatile TcpConnection<byte[]> tcpConnection;\n\n\t\tprivate volatile boolean isStompConnected;\n\n\t\tprivate long clientSendInterval;\n\n\t\t@Nullable\n\t\tprivate final AtomicInteger clientSendMessageCount;\n\n\t\tprivate long clientSendMessageTimestamp;\n\n\n\t\tprotected RelayConnectionHandler(String sessionId, StompHeaderAccessor connectHeaders) {\n\t\t\tthis(sessionId, connectHeaders, true);\n\t\t}\n\n\t\tprivate RelayConnectionHandler(String sessionId, StompHeaderAccessor connectHeaders, boolean isClientSession) {\n\t\t\tAssert.notNull(sessionId, \"'sessionId' must not be null\");\n\t\t\tAssert.notNull(connectHeaders, \"'connectHeaders' must not be null\");\n\t\t\tthis.sessionId = sessionId;\n\t\t\tthis.connectHeaders = connectHeaders;\n\t\t\tthis.isRemoteClientSession = isClientSession;\n\t\t\tthis.outboundChannel = getClientOutboundChannelForSession(sessionId);\n\t\t\tif (isClientSession && taskScheduler != null) {\n\t\t\t\tthis.clientSendInterval = connectHeaders.getHeartbeat()[0];\n\t\t\t}\n\t\t\tif (this.clientSendInterval > 0) {\n\t\t\t\tthis.clientSendMessageCount = new AtomicInteger();\n\t\t\t\tthis.clientSendMessageTimestamp = System.currentTimeMillis();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.clientSendMessageCount = null;\n\t\t\t}\n\t\t}\n\n\n\t\t@Override\n\t\tpublic String getSessionId() {\n\t\t\treturn this.sessionId;\n\t\t}\n\n\t\t@Override\n\t\tpublic StompHeaderAccessor getConnectHeaders() {\n\t\t\treturn this.connectHeaders;\n\t\t}\n\n\t\t@Nullable\n\t\tprotected TcpConnection<byte[]> getTcpConnection() {\n\t\t\treturn this.tcpConnection;\n\t\t}\n\n\t\t@Override\n\t\tpublic void afterConnected(TcpConnection<byte[]> connection) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"TCP connection \" + connection + \" opened in session=\" + getSessionId());\n\t\t\t}\n\t\t\tthis.tcpConnection = connection;\n\t\t\tconnection.onReadInactivity(() -> {\n\t\t\t\tif (this.tcpConnection != null && !this.isStompConnected) {\n\t\t\t\t\thandleTcpConnectionFailure(\"No CONNECTED frame received in \" +\n\t\t\t\t\t\t\tMAX_TIME_TO_CONNECTED_FRAME + \" ms.\", null);\n\t\t\t\t}\n\t\t\t}, MAX_TIME_TO_CONNECTED_FRAME);\n\t\t\tconnection.sendAsync(MessageBuilder.createMessage(EMPTY_PAYLOAD, this.connectHeaders.getMessageHeaders()));\n\t\t}\n\n\t\t@Override\n\t\tpublic void afterConnectFailure(Throwable ex) {\n\t\t\thandleTcpConnectionFailure(\"Failed to connect: \" + ex.getMessage(), ex);\n\t\t}\n\n\t\t/**\n\t\t * Invoked when any TCP connectivity issue is detected, i.e. failure to establish\n\t\t * the TCP connection, failure to send a message, missed heartbeat, etc.\n\t\t */\n\t\tprotected void handleTcpConnectionFailure(String error, @Nullable Throwable ex) {\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(\"TCP connection failure in session \" + this.sessionId + \": \" + error, ex);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tsendStompErrorFrameToClient(error);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\ttry {\n\t\t\t\t\tclearConnection();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Failure while clearing TCP connection state in session \" + this.sessionId, ex2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void sendStompErrorFrameToClient(String errorText) {\n\t\t\tif (this.isRemoteClientSession) {\n\t\t\t\tStompHeaderAccessor accessor = StompHeaderAccessor.create(StompCommand.ERROR);\n\t\t\t\tif (getHeaderInitializer() != null) {\n\t\t\t\t\tgetHeaderInitializer().initHeaders(accessor);\n\t\t\t\t}\n\t\t\t\taccessor.setSessionId(this.sessionId);\n\t\t\t\tPrincipal user = this.connectHeaders.getUser();\n\t\t\t\tif (user != null) {\n\t\t\t\t\taccessor.setUser(user);\n\t\t\t\t}\n\t\t\t\taccessor.setMessage(errorText);\n\t\t\t\taccessor.setLeaveMutable(true);\n\t\t\t\tMessage<?> errorMessage = MessageBuilder.createMessage(EMPTY_PAYLOAD, accessor.getMessageHeaders());\n\t\t\t\thandleInboundMessage(errorMessage);\n\t\t\t}\n\t\t}\n\n\t\tprotected void handleInboundMessage(Message<?> message) {\n\t\t\tif (this.isRemoteClientSession) {\n\t\t\t\tthis.outboundChannel.send(message);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleMessage(Message<byte[]> message) {\n\t\t\tStompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);\n\t\t\tAssert.state(accessor != null, \"No StompHeaderAccessor\");\n\t\t\taccessor.setSessionId(this.sessionId);\n\t\t\tPrincipal user = this.connectHeaders.getUser();\n\t\t\tif (user != null) {\n\t\t\t\taccessor.setUser(user);\n\t\t\t}\n\n\t\t\tStompCommand command = accessor.getCommand();\n\t\t\tif (StompCommand.CONNECTED.equals(command)) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Received \" + accessor.getShortLogMessage(EMPTY_PAYLOAD));\n\t\t\t\t}\n\t\t\t\tafterStompConnected(accessor);\n\t\t\t}\n\t\t\telse if (logger.isErrorEnabled() && StompCommand.ERROR.equals(command)) {\n\t\t\t\tlogger.error(\"Received \" + accessor.getShortLogMessage(message.getPayload()));\n\t\t\t}\n\t\t\telse if (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Received \" + accessor.getDetailedLogMessage(message.getPayload()));\n\t\t\t}\n\n\t\t\thandleInboundMessage(message);\n\t\t}\n\n\t\t/**\n\t\t * Invoked after the STOMP CONNECTED frame is received. At this point the\n\t\t * connection is ready for sending STOMP messages to the broker.\n\t\t */\n\t\tprotected void afterStompConnected(StompHeaderAccessor connectedHeaders) {\n\t\t\tthis.isStompConnected = true;\n\t\t\tstats.incrementConnectedCount();\n\t\t\tinitHeartbeats(connectedHeaders);\n\t\t}\n\n\t\tprotected void initHeartbeats(StompHeaderAccessor connectedHeaders) {\n\t\t\tif (taskScheduler != null) {\n\t\t\t\tlong interval = connectedHeaders.getHeartbeat()[1];\n\t\t\t\tthis.clientSendInterval = Math.max(interval, this.clientSendInterval);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Whether to forward a heartbeat message in lieu of a message with a non-broker\n\t\t * destination. This is done if client-side heartbeats are expected and if there\n\t\t * haven't been any other messages in the current heartbeat period.\n\t\t * @since 5.3\n\t\t */\n\t\tprotected boolean shouldSendHeartbeatForIgnoredMessage() {\n\t\t\treturn (this.clientSendMessageCount != null && this.clientSendMessageCount.get() == 0);\n\t\t}\n\n\t\t/**\n\t\t * Reset the clientSendMessageCount if the current heartbeat period has expired.\n\t\t * @since 5.3\n\t\t */\n\t\tvoid updateClientSendMessageCount(long now) {\n\t\t\tif (this.clientSendMessageCount != null && this.clientSendInterval > (now - this.clientSendMessageTimestamp)) {\n\t\t\t\tthis.clientSendMessageCount.set(0);\n\t\t\t\tthis.clientSendMessageTimestamp = now;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleFailure(Throwable ex) {\n\t\t\tif (this.tcpConnection != null) {\n\t\t\t\thandleTcpConnectionFailure(\"Transport failure: \" + ex.getMessage(), ex);\n\t\t\t}\n\t\t\telse if (logger.isErrorEnabled()) {\n\t\t\t\tlogger.error(\"Transport failure: \" + ex);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void afterConnectionClosed() {\n\t\t\tif (this.tcpConnection == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"TCP connection to broker closed in session \" + this.sessionId);\n\t\t\t\t}\n\t\t\t\tsendStompErrorFrameToClient(\"Connection to broker closed.\");\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\ttry {\n\t\t\t\t\t// Prevent clearConnection() from trying to close\n\t\t\t\t\tthis.tcpConnection = null;\n\t\t\t\t\tclearConnection();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t// Shouldn't happen with connection reset beforehand\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Forward the given message to the STOMP broker.\n\t\t * <p>The method checks whether we have an active TCP connection and have\n\t\t * received the STOMP CONNECTED frame. For client messages this should be\n\t\t * false only if we lose the TCP connection around the same time when a\n\t\t * client message is being forwarded, so we simply log the ignored message\n\t\t * at debug level. For messages from within the application being sent on\n\t\t * the \"system\" connection an exception is raised so that components sending\n\t\t * the message have a chance to handle it -- by default the broker message\n\t\t * channel is synchronous.\n\t\t * <p>Note that if messages arrive concurrently around the same time a TCP\n\t\t * connection is lost, there is a brief period of time before the connection\n\t\t * is reset when one or more messages may sneak through and an attempt made\n\t\t * to forward them. Rather than synchronizing to guard against that, this\n\t\t * method simply lets them try and fail. For client sessions that may\n\t\t * result in an additional STOMP ERROR frame(s) being sent downstream but\n\t\t * code handling that downstream should be idempotent in such cases.\n\t\t * @param message the message to send (never {@code null})\n\t\t * @return a future to wait for the result\n\t\t */\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic CompletableFuture<Void> forward(final Message<?> message, final StompHeaderAccessor accessor) {\n\t\t\tTcpConnection<byte[]> conn = this.tcpConnection;\n\n\t\t\tif (!this.isStompConnected || conn == null) {\n\t\t\t\tif (this.isRemoteClientSession) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"TCP connection closed already, ignoring \" +\n\t\t\t\t\t\t\t\taccessor.getShortLogMessage(message.getPayload()));\n\t\t\t\t\t}\n\t\t\t\t\treturn EMPTY_TASK;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalStateException(\"Cannot forward messages \" +\n\t\t\t\t\t\t\t(conn != null ? \"before STOMP CONNECTED. \" : \"while inactive. \") +\n\t\t\t\t\t\t\t\"Consider subscribing to receive BrokerAvailabilityEvent's from \" +\n\t\t\t\t\t\t\t\"an ApplicationListener Spring bean. Dropped \" +\n\t\t\t\t\t\t\taccessor.getShortLogMessage(message.getPayload()));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.clientSendMessageCount != null) {\n\t\t\t\tthis.clientSendMessageCount.incrementAndGet();\n\t\t\t}\n\n\t\t\tfinal Message<?> messageToSend = (accessor.isMutable() && accessor.isModified()) ?\n\t\t\t\t\tMessageBuilder.createMessage(message.getPayload(), accessor.getMessageHeaders()) : message;\n\n\t\t\tStompCommand command = accessor.getCommand();\n\t\t\tif (logger.isDebugEnabled() && (StompCommand.SEND.equals(command) || StompCommand.SUBSCRIBE.equals(command) ||\n\t\t\t\t\tStompCommand.UNSUBSCRIBE.equals(command) || StompCommand.DISCONNECT.equals(command))) {\n\t\t\t\tlogger.debug(\"Forwarding \" + accessor.getShortLogMessage(message.getPayload()));\n\t\t\t}\n\t\t\telse if (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Forwarding \" + accessor.getDetailedLogMessage(message.getPayload()));\n\t\t\t}\n\n\t\t\tCompletableFuture<Void> future = conn.sendAsync((Message<byte[]>) messageToSend);\n\t\t\tfuture.whenComplete((unused, throwable) -> {\n\t\t\t\tif (throwable == null) {\n\t\t\t\t\tif (accessor.getCommand() == StompCommand.DISCONNECT) {\n\t\t\t\t\t\tafterDisconnectSent(accessor);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (this.tcpConnection != null) {\n\t\t\t\t\t\thandleTcpConnectionFailure(\"failed to forward \" +\n\t\t\t\t\t\t\t\taccessor.getShortLogMessage(message.getPayload()), throwable);\n\t\t\t\t\t}\n\t\t\t\t\telse if (logger.isErrorEnabled()) {\n\t\t\t\t\t\tlogger.error(\"Failed to forward \" + accessor.getShortLogMessage(message.getPayload()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn future;\n\t\t}\n\n\t\t/**\n\t\t * After a DISCONNECT there should be no more client frames so we can\n\t\t * close the connection proactively. However, if the DISCONNECT has a\n\t\t * receipt header we leave the connection open and expect the server will\n\t\t * respond with a RECEIPT and then close the connection.\n\t\t * @see <a href=\"https://stomp.github.io/stomp-specification-1.2.html#DISCONNECT\">\n\t\t *     STOMP Specification 1.2 DISCONNECT</a>\n\t\t */\n\t\tprivate void afterDisconnectSent(StompHeaderAccessor accessor) {\n\t\t\tif (accessor.getReceipt() == null) {\n\t\t\t\ttry {\n\t\t\t\t\tclearConnection();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Failure while clearing TCP connection state in session \" + this.sessionId, ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Clean up state associated with the connection and close it.\n\t\t * Any exception arising from closing the connection are propagated.\n\t\t */\n\t\tpublic void clearConnection() {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Cleaning up connection state for session \" + this.sessionId);\n\t\t\t}\n\n\t\t\tif (this.isRemoteClientSession) {\n\t\t\t\tStompBrokerRelayMessageHandler.this.connectionHandlers.remove(this.sessionId);\n\t\t\t}\n\n\t\t\tthis.isStompConnected = false;\n\n\t\t\tTcpConnection<byte[]> conn = this.tcpConnection;\n\t\t\tthis.tcpConnection = null;\n\t\t\tif (conn != null) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Closing TCP connection \" + conn + \" in session \" + this.sessionId);\n\t\t\t\t}\n\t\t\t\tconn.close();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"StompConnectionHandler[sessionId=\" + this.sessionId + \"]\";\n\t\t}\n\t}\n\n\n\tprivate class SystemSessionConnectionHandler extends RelayConnectionHandler {\n\n\t\tpublic SystemSessionConnectionHandler(StompHeaderAccessor connectHeaders) {\n\t\t\tsuper(SYSTEM_SESSION_ID, connectHeaders, false);\n\t\t}\n\n\t\t@Override\n\t\tprotected void afterStompConnected(StompHeaderAccessor connectedHeaders) {\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(\"\\\"System\\\" session connected.\");\n\t\t\t}\n\t\t\tsuper.afterStompConnected(connectedHeaders);\n\t\t\tpublishBrokerAvailableEvent();\n\t\t\tsendSystemSubscriptions();\n\t\t}\n\n\t\t@Override\n\t\tprotected void initHeartbeats(StompHeaderAccessor connectedHeaders) {\n\t\t\tTcpConnection<byte[]> con = getTcpConnection();\n\t\t\tAssert.state(con != null, \"No TcpConnection available\");\n\n\t\t\tlong clientSendInterval = getConnectHeaders().getHeartbeat()[0];\n\t\t\tlong clientReceiveInterval = getConnectHeaders().getHeartbeat()[1];\n\t\t\tlong serverSendInterval = connectedHeaders.getHeartbeat()[0];\n\t\t\tlong serverReceiveInterval = connectedHeaders.getHeartbeat()[1];\n\n\t\t\tif (clientSendInterval > 0 && serverReceiveInterval > 0) {\n\t\t\t\tlong interval = Math.max(clientSendInterval, serverReceiveInterval);\n\t\t\t\tcon.onWriteInactivity(() ->\n\t\t\t\t\t\tcon.sendAsync(HEARTBEAT_MESSAGE).whenComplete((unused, ex) -> {\n\t\t\t\t\t\t\tif (ex != null) {\n\t\t\t\t\t\t\t\thandleTcpConnectionFailure(\"Failed to forward heartbeat: \" + ex.getMessage(), ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}), interval);\n\t\t\t}\n\t\t\tif (clientReceiveInterval > 0 && serverSendInterval > 0) {\n\t\t\t\tfinal long interval = Math.max(clientReceiveInterval, serverSendInterval) * HEARTBEAT_MULTIPLIER;\n\t\t\t\tcon.onReadInactivity(\n\t\t\t\t\t\t() -> handleTcpConnectionFailure(\"No messages received in \" + interval + \" ms.\", null), interval);\n\t\t\t}\n\t\t}\n\n\t\tprivate void sendSystemSubscriptions() {\n\t\t\tint i = 0;\n\t\t\tfor (String destination : getSystemSubscriptions().keySet()) {\n\t\t\t\tStompHeaderAccessor accessor = StompHeaderAccessor.create(StompCommand.SUBSCRIBE);\n\t\t\t\taccessor.setSubscriptionId(String.valueOf(i++));\n\t\t\t\taccessor.setDestination(destination);\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Subscribing to \" + destination + \" on \\\"system\\\" connection.\");\n\t\t\t\t}\n\t\t\t\tTcpConnection<byte[]> conn = getTcpConnection();\n\t\t\t\tif (conn != null) {\n\t\t\t\t\tMessageHeaders headers = accessor.getMessageHeaders();\n\t\t\t\t\tconn.sendAsync(MessageBuilder.createMessage(EMPTY_PAYLOAD, headers)).whenComplete((unused, ex) -> {\n\t\t\t\t\t\tif (ex != null) {\n\t\t\t\t\t\t\thandleTcpConnectionFailure(\"Failed to subscribe in \\\"system\\\" session.\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tprotected void handleInboundMessage(Message<?> message) {\n\t\t\tStompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);\n\t\t\tif (accessor != null && StompCommand.MESSAGE.equals(accessor.getCommand())) {\n\t\t\t\tString destination = accessor.getDestination();\n\t\t\t\tif (destination == null) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Got message on \\\"system\\\" connection, with no destination: \" +\n\t\t\t\t\t\t\t\taccessor.getDetailedLogMessage(message.getPayload()));\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!getSystemSubscriptions().containsKey(destination)) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Got message on \\\"system\\\" connection with no handler: \" +\n\t\t\t\t\t\t\t\taccessor.getDetailedLogMessage(message.getPayload()));\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tMessageHandler handler = getSystemSubscriptions().get(destination);\n\t\t\t\t\thandler.handleMessage(message);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Error while handling message on \\\"system\\\" connection.\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tprotected void handleTcpConnectionFailure(String errorMessage, @Nullable Throwable ex) {\n\t\t\tsuper.handleTcpConnectionFailure(errorMessage, ex);\n\t\t\tpublishBrokerUnavailableEvent();\n\t\t}\n\n\t\t@Override\n\t\tpublic void afterConnectionClosed() {\n\t\t\tsuper.afterConnectionClosed();\n\t\t\tpublishBrokerUnavailableEvent();\n\t\t}\n\n\t\t@Override\n\t\tpublic CompletableFuture<Void> forward(Message<?> message, StompHeaderAccessor accessor) {\n\t\t\ttry {\n\t\t\t\tCompletableFuture<Void> future = super.forward(message, accessor);\n\t\t\t\tif (message.getHeaders().get(SimpMessageHeaderAccessor.IGNORE_ERROR) == null) {\n\t\t\t\t\tfuture.get();\n\t\t\t\t}\n\t\t\t\treturn future;\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new MessageDeliveryException(message, ex);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tprotected boolean shouldSendHeartbeatForIgnoredMessage() {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\n\tprivate class ClientSendMessageCountTask implements Runnable {\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tlong now = System.currentTimeMillis();\n\t\t\tfor (RelayConnectionHandler handler : connectionHandlers.values()) {\n\t\t\t\thandler.updateClientSendMessageCount(now);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Contract for access to session counters.\n\t * @since 5.2\n\t */\n\tpublic interface Stats {\n\n\t\t/**\n\t\t * The number of connection handlers.\n\t\t */\n\t\tint getTotalHandlers();\n\n\t\t/**\n\t\t * The number of CONNECT frames processed.\n\t\t */\n\t\tint getTotalConnect();\n\n\t\t/**\n\t\t * The number of CONNECTED frames processed.\n\t\t */\n\t\tint getTotalConnected();\n\n\t\t/**\n\t\t * The number of DISCONNECT frames processed.\n\t\t */\n\t\tint getTotalDisconnect();\n\t}\n\n\n\tprivate class DefaultStats implements Stats {\n\n\t\tprivate final AtomicInteger connect = new AtomicInteger();\n\n\t\tprivate final AtomicInteger connected = new AtomicInteger();\n\n\t\tprivate final AtomicInteger disconnect = new AtomicInteger();\n\n\t\tpublic void incrementConnectCount() {\n\t\t\tthis.connect.incrementAndGet();\n\t\t}\n\n\t\tpublic void incrementConnectedCount() {\n\t\t\tthis.connected.incrementAndGet();\n\t\t}\n\n\t\tpublic void incrementDisconnectCount() {\n\t\t\tthis.disconnect.incrementAndGet();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getTotalHandlers() {\n\t\t\treturn connectionHandlers.size();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getTotalConnect() {\n\t\t\treturn this.connect.get();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getTotalConnected() {\n\t\t\treturn this.connected.get();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getTotalDisconnect() {\n\t\t\treturn this.disconnect.get();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn (connectionHandlers.size() + \" sessions, \" + getTcpClientInfo() +\n\t\t\t\t\t(isBrokerAvailable() ? \" (available)\" : \" (not available)\") +\n\t\t\t\t\t\", processed CONNECT(\" + this.connect.get() + \")-CONNECTED(\" +\n\t\t\t\t\tthis.connected.get() + \")-DISCONNECT(\" + this.disconnect.get() + \")\");\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#afterConnectFailure(ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 715
    },
    "return": "void",
    "signature": "public void afterConnectFailure(Throwable ex)",
    "source_code": "\t\tpublic void afterConnectFailure(Throwable ex) {\n\t\t\thandleTcpConnectionFailure(\"Failed to connect: \" + ex.getMessage(), ex);\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#afterConnected(connection)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connection"
    ],
    "position": {
      "column": 1,
      "line": 700
    },
    "return": "void",
    "signature": "public void afterConnected(TcpConnection<byte[]> connection)",
    "source_code": "\t\tpublic void afterConnected(TcpConnection<byte[]> connection) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"TCP connection \" + connection + \" opened in session=\" + getSessionId());\n\t\t\t}\n\t\t\tthis.tcpConnection = connection;\n\t\t\tconnection.onReadInactivity(() -> {\n\t\t\t\tif (this.tcpConnection != null && !this.isStompConnected) {\n\t\t\t\t\thandleTcpConnectionFailure(\"No CONNECTED frame received in \" +\n\t\t\t\t\t\t\tMAX_TIME_TO_CONNECTED_FRAME + \" ms.\", null);\n\t\t\t\t}\n\t\t\t}, MAX_TIME_TO_CONNECTED_FRAME);\n\t\t\tconnection.sendAsync(MessageBuilder.createMessage(EMPTY_PAYLOAD, this.connectHeaders.getMessageHeaders()));\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#afterConnectionClosed()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1095
    },
    "return": "void",
    "signature": "public void afterConnectionClosed()",
    "source_code": "\t\tpublic void afterConnectionClosed() {\n\t\t\tsuper.afterConnectionClosed();\n\t\t\tpublishBrokerUnavailableEvent();\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#afterStompConnected(connectedHeaders)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "connectedHeaders"
    ],
    "position": {
      "column": 1,
      "line": 1001
    },
    "return": "void",
    "signature": "protected void afterStompConnected(StompHeaderAccessor connectedHeaders)",
    "source_code": "\t\tprotected void afterStompConnected(StompHeaderAccessor connectedHeaders) {\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(\"\\\"System\\\" session connected.\");\n\t\t\t}\n\t\t\tsuper.afterStompConnected(connectedHeaders);\n\t\t\tpublishBrokerAvailableEvent();\n\t\t\tsendSystemSubscriptions();\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#clearConnection()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Clean up state associated with the connection and close it.\n\t\t * Any exception arising from closing the connection are propagated.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 966
    },
    "return": "void",
    "signature": "public void clearConnection()",
    "source_code": "\t\tpublic void clearConnection() {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Cleaning up connection state for session \" + this.sessionId);\n\t\t\t}\n\n\t\t\tif (this.isRemoteClientSession) {\n\t\t\t\tStompBrokerRelayMessageHandler.this.connectionHandlers.remove(this.sessionId);\n\t\t\t}\n\n\t\t\tthis.isStompConnected = false;\n\n\t\t\tTcpConnection<byte[]> conn = this.tcpConnection;\n\t\t\tthis.tcpConnection = null;\n\t\t\tif (conn != null) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Closing TCP connection \" + conn + \" in session \" + this.sessionId);\n\t\t\t\t}\n\t\t\t\tconn.close();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#forward(message,accessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "accessor"
    ],
    "position": {
      "column": 1,
      "line": 1101
    },
    "return": "CompletableFuture<Void>",
    "signature": "public CompletableFuture<Void> forward(Message<?> message, StompHeaderAccessor accessor)",
    "source_code": "\t\tpublic CompletableFuture<Void> forward(Message<?> message, StompHeaderAccessor accessor) {\n\t\t\ttry {\n\t\t\t\tCompletableFuture<Void> future = super.forward(message, accessor);\n\t\t\t\tif (message.getHeaders().get(SimpMessageHeaderAccessor.IGNORE_ERROR) == null) {\n\t\t\t\t\tfuture.get();\n\t\t\t\t}\n\t\t\t\treturn future;\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new MessageDeliveryException(message, ex);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#getClientLogin()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured login to use for connections to the STOMP broker\n\t * on behalf of connected clients.\n\t * @see #getSystemLogin()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "String",
    "signature": "public String getClientLogin()",
    "source_code": "\tpublic String getClientLogin() {\n\t\treturn this.clientLogin;\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#getClientPasscode()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured passcode to use for connections to the STOMP broker on\n\t * behalf of connected clients.\n\t * @see #getSystemPasscode()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "String",
    "signature": "public String getClientPasscode()",
    "source_code": "\tpublic String getClientPasscode() {\n\t\treturn this.clientPasscode;\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#getConnectHeaders()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 690
    },
    "return": "StompHeaderAccessor",
    "signature": "public StompHeaderAccessor getConnectHeaders()",
    "source_code": "\t\tpublic StompHeaderAccessor getConnectHeaders() {\n\t\t\treturn this.connectHeaders;\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#getConnectionCount()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the current count of TCP connection to the broker.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 417
    },
    "return": "int",
    "signature": "public int getConnectionCount()",
    "source_code": "\tpublic int getConnectionCount() {\n\t\treturn this.connectionHandlers.size();\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#getHeaderInitializer()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured header initializer.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 393
    },
    "return": "MessageHeaderInitializer",
    "signature": "public MessageHeaderInitializer getHeaderInitializer()",
    "source_code": "\tpublic MessageHeaderInitializer getHeaderInitializer() {\n\t\treturn this.headerInitializer;\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#getRelayHost()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the STOMP message broker host.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "String",
    "signature": "public String getRelayHost()",
    "source_code": "\tpublic String getRelayHost() {\n\t\treturn this.relayHost;\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#getRelayPort()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the STOMP message broker port.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "int",
    "signature": "public int getRelayPort()",
    "source_code": "\tpublic int getRelayPort() {\n\t\treturn this.relayPort;\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#getSessionId()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 685
    },
    "return": "String",
    "signature": "public String getSessionId()",
    "source_code": "\t\tpublic String getSessionId() {\n\t\t\treturn this.sessionId;\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#getStats()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a structured object with internal state and counters.\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 409
    },
    "return": "Stats",
    "signature": "public Stats getStats()",
    "source_code": "\tpublic Stats getStats() {\n\t\treturn this.stats;\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#getStatsInfo()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a String describing internal state and counters.\n\t * Effectively {@code toString()} on {@link #getStats() getStats()}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 401
    },
    "return": "String",
    "signature": "public String getStatsInfo()",
    "source_code": "\tpublic String getStatsInfo() {\n\t\treturn this.stats.toString();\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#getSystemHeartbeatReceiveInterval()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the interval, in milliseconds, at which the \"system\" connection expects\n\t * to receive heartbeats from the STOMP broker.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 312
    },
    "return": "long",
    "signature": "public long getSystemHeartbeatReceiveInterval()",
    "source_code": "\tpublic long getSystemHeartbeatReceiveInterval() {\n\t\treturn this.systemHeartbeatReceiveInterval;\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#getSystemHeartbeatSendInterval()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the interval, in milliseconds, at which the \"system\" connection will\n\t * send heartbeats to the STOMP broker.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "long",
    "signature": "public long getSystemHeartbeatSendInterval()",
    "source_code": "\tpublic long getSystemHeartbeatSendInterval() {\n\t\treturn this.systemHeartbeatSendInterval;\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#getSystemLogin()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the login used for the shared \"system\" connection to the STOMP broker.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "String",
    "signature": "public String getSystemLogin()",
    "source_code": "\tpublic String getSystemLogin() {\n\t\treturn this.systemLogin;\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#getSystemPasscode()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the passcode used for the shared \"system\" connection to the STOMP broker.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "String",
    "signature": "public String getSystemPasscode()",
    "source_code": "\tpublic String getSystemPasscode() {\n\t\treturn this.systemPasscode;\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#getSystemSubscriptions()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured map with subscriptions on the \"system\" connection.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "MessageHandler>",
    "signature": "public MessageHandler> getSystemSubscriptions()",
    "source_code": "\tpublic Map<String, MessageHandler> getSystemSubscriptions() {\n\t\treturn this.systemSubscriptions;\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#getTaskScheduler()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 433
    },
    "return": "TaskScheduler",
    "signature": "public TaskScheduler getTaskScheduler()",
    "source_code": "\tpublic TaskScheduler getTaskScheduler() {\n\t\treturn this.taskScheduler;\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#getTcpClient()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the configured TCP client (never {@code null} unless not configured\n\t * invoked and this method is invoked before the handler is started and\n\t * hence a default implementation initialized).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 375
    },
    "return": "TcpOperations<byte[]>",
    "signature": "public TcpOperations<byte[]> getTcpClient()",
    "source_code": "\tpublic TcpOperations<byte[]> getTcpClient() {\n\t\treturn this.tcpClient;\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#getTcpConnection()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 695
    },
    "return": "TcpConnection<byte[]>",
    "signature": "protected TcpConnection<byte[]> getTcpConnection()",
    "source_code": "\t\tprotected TcpConnection<byte[]> getTcpConnection() {\n\t\t\treturn this.tcpConnection;\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#getTotalConnect()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1187
    },
    "return": "int",
    "signature": "public int getTotalConnect()",
    "source_code": "\t\tpublic int getTotalConnect() {\n\t\t\treturn this.connect.get();\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#getTotalConnected()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1192
    },
    "return": "int",
    "signature": "public int getTotalConnected()",
    "source_code": "\t\tpublic int getTotalConnected() {\n\t\t\treturn this.connected.get();\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#getTotalDisconnect()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1197
    },
    "return": "int",
    "signature": "public int getTotalDisconnect()",
    "source_code": "\t\tpublic int getTotalDisconnect() {\n\t\t\treturn this.disconnect.get();\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#getTotalHandlers()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1182
    },
    "return": "int",
    "signature": "public int getTotalHandlers()",
    "source_code": "\t\tpublic int getTotalHandlers() {\n\t\t\treturn connectionHandlers.size();\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#getVirtualHost()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured virtual host value.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 353
    },
    "return": "String",
    "signature": "public String getVirtualHost()",
    "source_code": "\tpublic String getVirtualHost() {\n\t\treturn this.virtualHost;\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#handleFailure(ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 832
    },
    "return": "void",
    "signature": "public void handleFailure(Throwable ex)",
    "source_code": "\t\tpublic void handleFailure(Throwable ex) {\n\t\t\tif (this.tcpConnection != null) {\n\t\t\t\thandleTcpConnectionFailure(\"Transport failure: \" + ex.getMessage(), ex);\n\t\t\t}\n\t\t\telse if (logger.isErrorEnabled()) {\n\t\t\t\tlogger.error(\"Transport failure: \" + ex);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#handleInboundMessage(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 1058
    },
    "return": "void",
    "signature": "protected void handleInboundMessage(Message<?> message)",
    "source_code": "\t\tprotected void handleInboundMessage(Message<?> message) {\n\t\t\tStompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);\n\t\t\tif (accessor != null && StompCommand.MESSAGE.equals(accessor.getCommand())) {\n\t\t\t\tString destination = accessor.getDestination();\n\t\t\t\tif (destination == null) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Got message on \\\"system\\\" connection, with no destination: \" +\n\t\t\t\t\t\t\t\taccessor.getDetailedLogMessage(message.getPayload()));\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!getSystemSubscriptions().containsKey(destination)) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Got message on \\\"system\\\" connection with no handler: \" +\n\t\t\t\t\t\t\t\taccessor.getDetailedLogMessage(message.getPayload()));\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tMessageHandler handler = getSystemSubscriptions().get(destination);\n\t\t\t\t\thandler.handleMessage(message);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Error while handling message on \\\"system\\\" connection.\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#handleMessage(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 767
    },
    "return": "void",
    "signature": "public void handleMessage(Message<byte[]> message)",
    "source_code": "\t\tpublic void handleMessage(Message<byte[]> message) {\n\t\t\tStompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);\n\t\t\tAssert.state(accessor != null, \"No StompHeaderAccessor\");\n\t\t\taccessor.setSessionId(this.sessionId);\n\t\t\tPrincipal user = this.connectHeaders.getUser();\n\t\t\tif (user != null) {\n\t\t\t\taccessor.setUser(user);\n\t\t\t}\n\n\t\t\tStompCommand command = accessor.getCommand();\n\t\t\tif (StompCommand.CONNECTED.equals(command)) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Received \" + accessor.getShortLogMessage(EMPTY_PAYLOAD));\n\t\t\t\t}\n\t\t\t\tafterStompConnected(accessor);\n\t\t\t}\n\t\t\telse if (logger.isErrorEnabled() && StompCommand.ERROR.equals(command)) {\n\t\t\t\tlogger.error(\"Received \" + accessor.getShortLogMessage(message.getPayload()));\n\t\t\t}\n\t\t\telse if (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Received \" + accessor.getDetailedLogMessage(message.getPayload()));\n\t\t\t}\n\n\t\t\thandleInboundMessage(message);\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#handleMessageInternal(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 507
    },
    "return": "void",
    "signature": "protected void handleMessageInternal(Message<?> message)",
    "source_code": "\tprotected void handleMessageInternal(Message<?> message) {\n\t\tString sessionId = SimpMessageHeaderAccessor.getSessionId(message.getHeaders());\n\n\t\tif (!isBrokerAvailable()) {\n\t\t\tif (sessionId == null || SYSTEM_SESSION_ID.equals(sessionId)) {\n\t\t\t\tthrow new MessageDeliveryException(\"Message broker not active. Consider subscribing to \" +\n\t\t\t\t\t\t\"receive BrokerAvailabilityEvent's from an ApplicationListener Spring bean.\");\n\t\t\t}\n\t\t\tRelayConnectionHandler handler = this.connectionHandlers.get(sessionId);\n\t\t\tif (handler != null) {\n\t\t\t\thandler.sendStompErrorFrameToClient(\"Broker not available.\");\n\t\t\t\thandler.clearConnection();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tStompHeaderAccessor accessor = StompHeaderAccessor.create(StompCommand.ERROR);\n\t\t\t\tif (getHeaderInitializer() != null) {\n\t\t\t\t\tgetHeaderInitializer().initHeaders(accessor);\n\t\t\t\t}\n\t\t\t\taccessor.setSessionId(sessionId);\n\t\t\t\tPrincipal user = SimpMessageHeaderAccessor.getUser(message.getHeaders());\n\t\t\t\tif (user != null) {\n\t\t\t\t\taccessor.setUser(user);\n\t\t\t\t}\n\t\t\t\taccessor.setMessage(\"Broker not available.\");\n\t\t\t\tMessageHeaders headers = accessor.getMessageHeaders();\n\t\t\t\tgetClientOutboundChannel().send(MessageBuilder.createMessage(EMPTY_PAYLOAD, headers));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tStompHeaderAccessor stompHeaderAccessor;\n\t\tStompCommand command;\n\n\t\tMessageHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, MessageHeaderAccessor.class);\n\t\tif (accessor == null) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"No header accessor (not using the SimpMessagingTemplate?): \" + message);\n\t\t}\n\t\telse if (accessor instanceof StompHeaderAccessor _stompHeaderAccessor) {\n\t\t\tstompHeaderAccessor = _stompHeaderAccessor;\n\t\t\tcommand = stompHeaderAccessor.getCommand();\n\t\t}\n\t\telse if (accessor instanceof SimpMessageHeaderAccessor) {\n\t\t\tstompHeaderAccessor = StompHeaderAccessor.wrap(message);\n\t\t\tcommand = stompHeaderAccessor.getCommand();\n\t\t\tif (command == null) {\n\t\t\t\tcommand = stompHeaderAccessor.updateStompCommandAsClientMessage();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Unexpected header accessor type \" + accessor.getClass() + \" in \" + message);\n\t\t}\n\n\t\tif (sessionId == null) {\n\t\t\tif (!SimpMessageType.MESSAGE.equals(stompHeaderAccessor.getMessageType())) {\n\t\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\t\tlogger.error(\"Only STOMP SEND supported from within the server side. Ignoring \" + message);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsessionId = SYSTEM_SESSION_ID;\n\t\t\tstompHeaderAccessor.setSessionId(sessionId);\n\t\t}\n\n\t\tif (StompCommand.CONNECT.equals(command) || StompCommand.STOMP.equals(command)) {\n\t\t\tif (this.connectionHandlers.get(sessionId) != null) {\n\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\tlogger.warn(\"Ignoring CONNECT in session \" + sessionId + \". Already connected.\");\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(stompHeaderAccessor.getShortLogMessage(EMPTY_PAYLOAD));\n\t\t\t}\n\t\t\tstompHeaderAccessor = (stompHeaderAccessor.isMutable() ? stompHeaderAccessor : StompHeaderAccessor.wrap(message));\n\t\t\tstompHeaderAccessor.setLogin(this.clientLogin);\n\t\t\tstompHeaderAccessor.setPasscode(this.clientPasscode);\n\t\t\tif (getVirtualHost() != null) {\n\t\t\t\tstompHeaderAccessor.setHost(getVirtualHost());\n\t\t\t}\n\t\t\tRelayConnectionHandler handler = new RelayConnectionHandler(sessionId, stompHeaderAccessor);\n\t\t\tthis.connectionHandlers.put(sessionId, handler);\n\t\t\tthis.stats.incrementConnectCount();\n\t\t\tAssert.state(this.tcpClient != null, \"No TCP client available\");\n\t\t\tthis.tcpClient.connectAsync(handler);\n\t\t}\n\t\telse if (StompCommand.DISCONNECT.equals(command)) {\n\t\t\tRelayConnectionHandler handler = this.connectionHandlers.get(sessionId);\n\t\t\tif (handler == null) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Ignoring DISCONNECT in session \" + sessionId + \". Connection already cleaned up.\");\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.stats.incrementDisconnectCount();\n\t\t\thandler.forward(message, stompHeaderAccessor);\n\t\t}\n\t\telse {\n\t\t\tRelayConnectionHandler handler = this.connectionHandlers.get(sessionId);\n\t\t\tif (handler == null) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"No TCP connection for session \" + sessionId + \" in \" + message);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tString destination = stompHeaderAccessor.getDestination();\n\t\t\tif (command != null && command.requiresDestination() && !checkDestinationPrefix(destination)) {\n\t\t\t\t// Not a broker destination but send a heartbeat to keep the connection\n\t\t\t\tif (handler.shouldSendHeartbeatForIgnoredMessage()) {\n\t\t\t\t\thandler.forward(HEARTBEAT_MESSAGE, HEART_BEAT_ACCESSOR);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\thandler.forward(message, stompHeaderAccessor);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#handleTcpConnectionFailure(error,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Invoked when any TCP connectivity issue is detected, i.e. failure to establish\n\t\t * the TCP connection, failure to send a message, missed heartbeat, etc.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "error",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 723
    },
    "return": "void",
    "signature": "protected void handleTcpConnectionFailure(String error, @Nullable Throwable ex)",
    "source_code": "\t\tprotected void handleTcpConnectionFailure(String error, @Nullable Throwable ex) {\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(\"TCP connection failure in session \" + this.sessionId + \": \" + error, ex);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tsendStompErrorFrameToClient(error);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\ttry {\n\t\t\t\t\tclearConnection();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Failure while clearing TCP connection state in session \" + this.sessionId, ex2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#handleTcpConnectionFailure(errorMessage,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "errorMessage",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 1089
    },
    "return": "void",
    "signature": "protected void handleTcpConnectionFailure(String errorMessage, @Nullable Throwable ex)",
    "source_code": "\t\tprotected void handleTcpConnectionFailure(String errorMessage, @Nullable Throwable ex) {\n\t\t\tsuper.handleTcpConnectionFailure(errorMessage, ex);\n\t\t\tpublishBrokerUnavailableEvent();\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#incrementConnectCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1169
    },
    "return": "void",
    "signature": "public void incrementConnectCount()",
    "source_code": "\t\tpublic void incrementConnectCount() {\n\t\t\tthis.connect.incrementAndGet();\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#incrementConnectedCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1173
    },
    "return": "void",
    "signature": "public void incrementConnectedCount()",
    "source_code": "\t\tpublic void incrementConnectedCount() {\n\t\t\tthis.connected.incrementAndGet();\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#incrementDisconnectCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1177
    },
    "return": "void",
    "signature": "public void incrementDisconnectCount()",
    "source_code": "\t\tpublic void incrementDisconnectCount() {\n\t\t\tthis.disconnect.incrementAndGet();\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#initHeartbeats(connectedHeaders)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "connectedHeaders"
    ],
    "position": {
      "column": 1,
      "line": 1011
    },
    "return": "void",
    "signature": "protected void initHeartbeats(StompHeaderAccessor connectedHeaders)",
    "source_code": "\t\tprotected void initHeartbeats(StompHeaderAccessor connectedHeaders) {\n\t\t\tTcpConnection<byte[]> con = getTcpConnection();\n\t\t\tAssert.state(con != null, \"No TcpConnection available\");\n\n\t\t\tlong clientSendInterval = getConnectHeaders().getHeartbeat()[0];\n\t\t\tlong clientReceiveInterval = getConnectHeaders().getHeartbeat()[1];\n\t\t\tlong serverSendInterval = connectedHeaders.getHeartbeat()[0];\n\t\t\tlong serverReceiveInterval = connectedHeaders.getHeartbeat()[1];\n\n\t\t\tif (clientSendInterval > 0 && serverReceiveInterval > 0) {\n\t\t\t\tlong interval = Math.max(clientSendInterval, serverReceiveInterval);\n\t\t\t\tcon.onWriteInactivity(() ->\n\t\t\t\t\t\tcon.sendAsync(HEARTBEAT_MESSAGE).whenComplete((unused, ex) -> {\n\t\t\t\t\t\t\tif (ex != null) {\n\t\t\t\t\t\t\t\thandleTcpConnectionFailure(\"Failed to forward heartbeat: \" + ex.getMessage(), ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}), interval);\n\t\t\t}\n\t\t\tif (clientReceiveInterval > 0 && serverSendInterval > 0) {\n\t\t\t\tfinal long interval = Math.max(clientReceiveInterval, serverSendInterval) * HEARTBEAT_MULTIPLIER;\n\t\t\t\tcon.onReadInactivity(\n\t\t\t\t\t\t() -> handleTcpConnectionFailure(\"No messages received in \" + interval + \" ms.\", null), interval);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#run()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1124
    },
    "return": "void",
    "signature": "public void run()",
    "source_code": "\t\tpublic void run() {\n\t\t\tlong now = System.currentTimeMillis();\n\t\t\tfor (RelayConnectionHandler handler : connectionHandlers.values()) {\n\t\t\t\thandler.updateClientSendMessageCount(now);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#setClientLogin(clientLogin)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the login to use when creating connections to the STOMP broker on\n\t * behalf of connected clients.\n\t * <p>By default this is set to \"guest\".\n\t * @see #setSystemLogin(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clientLogin"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "void",
    "signature": "public void setClientLogin(String clientLogin)",
    "source_code": "\tpublic void setClientLogin(String clientLogin) {\n\t\tAssert.hasText(clientLogin, \"clientLogin must not be empty\");\n\t\tthis.clientLogin = clientLogin;\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#setClientPasscode(clientPasscode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the client passcode to use to create connections to the STOMP broker on\n\t * behalf of connected clients.\n\t * <p>By default this is set to \"guest\".\n\t * @see #setSystemPasscode\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clientPasscode"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "void",
    "signature": "public void setClientPasscode(String clientPasscode)",
    "source_code": "\tpublic void setClientPasscode(String clientPasscode) {\n\t\tAssert.hasText(clientPasscode, \"clientPasscode must not be empty\");\n\t\tthis.clientPasscode = clientPasscode;\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#setHeaderInitializer(headerInitializer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a {@link MessageHeaderInitializer} to apply to the headers of all\n\t * messages created through the {@code StompBrokerRelayMessageHandler} that\n\t * are sent to the client outbound message channel.\n\t * <p>By default this property is not set.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerInitializer"
    ],
    "position": {
      "column": 1,
      "line": 385
    },
    "return": "void",
    "signature": "public void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer)",
    "source_code": "\tpublic void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer) {\n\t\tthis.headerInitializer = headerInitializer;\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#setRelayHost(relayHost)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the STOMP message broker host.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "relayHost"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "void",
    "signature": "public void setRelayHost(String relayHost)",
    "source_code": "\tpublic void setRelayHost(String relayHost) {\n\t\tAssert.hasText(relayHost, \"relayHost must not be empty\");\n\t\tthis.relayHost = relayHost;\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#setRelayPort(relayPort)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the STOMP message broker port.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "relayPort"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "void",
    "signature": "public void setRelayPort(int relayPort)",
    "source_code": "\tpublic void setRelayPort(int relayPort) {\n\t\tthis.relayPort = relayPort;\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#setSystemHeartbeatReceiveInterval(heartbeatReceiveInterval)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the maximum interval, in milliseconds, at which the \"system\" connection\n\t * expects, in the absence of any other data, to receive a heartbeat from the STOMP\n\t * broker. A value of zero will configure the connection to expect not to receive\n\t * heartbeats from the broker.\n\t * <p>The default value is 10000.\n\t * <p>See class-level documentation for more information on the \"system\" connection.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "heartbeatReceiveInterval"
    ],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "void",
    "signature": "public void setSystemHeartbeatReceiveInterval(long heartbeatReceiveInterval)",
    "source_code": "\tpublic void setSystemHeartbeatReceiveInterval(long heartbeatReceiveInterval) {\n\t\tthis.systemHeartbeatReceiveInterval = heartbeatReceiveInterval;\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#setSystemHeartbeatSendInterval(systemHeartbeatSendInterval)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the interval, in milliseconds, at which the \"system\" connection will, in the\n\t * absence of any other data being sent, send a heartbeat to the STOMP broker. A value\n\t * of zero will prevent heartbeats from being sent to the broker.\n\t * <p>The default value is 10000.\n\t * <p>See class-level documentation for more information on the \"system\" connection.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "systemHeartbeatSendInterval"
    ],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "void",
    "signature": "public void setSystemHeartbeatSendInterval(long systemHeartbeatSendInterval)",
    "source_code": "\tpublic void setSystemHeartbeatSendInterval(long systemHeartbeatSendInterval) {\n\t\tthis.systemHeartbeatSendInterval = systemHeartbeatSendInterval;\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#setSystemLogin(systemLogin)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the login for the shared \"system\" connection used to send messages to\n\t * the STOMP broker from within the application, i.e. messages not associated\n\t * with a specific client session (e.g. REST/HTTP request handling method).\n\t * <p>By default this is set to \"guest\".\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "systemLogin"
    ],
    "position": {
      "column": 1,
      "line": 247
    },
    "return": "void",
    "signature": "public void setSystemLogin(String systemLogin)",
    "source_code": "\tpublic void setSystemLogin(String systemLogin) {\n\t\tAssert.hasText(systemLogin, \"systemLogin must not be empty\");\n\t\tthis.systemLogin = systemLogin;\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#setSystemPasscode(systemPasscode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the passcode for the shared \"system\" connection used to send messages to\n\t * the STOMP broker from within the application, i.e. messages not associated\n\t * with a specific client session (e.g. REST/HTTP request handling method).\n\t * <p>By default this is set to \"guest\".\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "systemPasscode"
    ],
    "position": {
      "column": 1,
      "line": 265
    },
    "return": "void",
    "signature": "public void setSystemPasscode(String systemPasscode)",
    "source_code": "\tpublic void setSystemPasscode(String systemPasscode) {\n\t\tthis.systemPasscode = systemPasscode;\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#setSystemSubscriptions(Map<String,subscriptions)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure one more destinations to subscribe to on the shared \"system\"\n\t * connection along with MessageHandler's to handle received messages.\n\t * <p>This is for internal use in a multi-application server scenario where\n\t * servers forward messages to each other (e.g. unresolved user destinations).\n\t * @param subscriptions the destinations to subscribe to.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "subscriptions"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "void",
    "signature": "public void setSystemSubscriptions(@Nullable Map<String, MessageHandler> subscriptions)",
    "source_code": "\tpublic void setSystemSubscriptions(@Nullable Map<String, MessageHandler> subscriptions) {\n\t\tthis.systemSubscriptions.clear();\n\t\tif (subscriptions != null) {\n\t\t\tthis.systemSubscriptions.putAll(subscriptions);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#setTaskScheduler(taskScheduler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@link TaskScheduler} to use to reset client-to-broker\n\t * message count in the current heartbeat period. For more details, see\n\t * {@link org.springframework.messaging.simp.config.StompBrokerRelayRegistration#setTaskScheduler(TaskScheduler)}.\n\t * @param taskScheduler the scheduler to use\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "taskScheduler"
    ],
    "position": {
      "column": 1,
      "line": 428
    },
    "return": "void",
    "signature": "public void setTaskScheduler(@Nullable TaskScheduler taskScheduler)",
    "source_code": "\tpublic void setTaskScheduler(@Nullable TaskScheduler taskScheduler) {\n\t\tthis.taskScheduler = taskScheduler;\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#setTcpClient(tcpClient)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a TCP client for managing TCP connections to the STOMP broker.\n\t * <p>By default {@link ReactorNettyTcpClient} or\n\t * {@link ReactorNetty2TcpClient} is used.\n\t * <p><strong>Note:</strong> when this property is used, any\n\t * {@link #setRelayHost(String) host} or {@link #setRelayPort(int) port}\n\t * specified are effectively ignored.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "tcpClient"
    ],
    "position": {
      "column": 1,
      "line": 365
    },
    "return": "void",
    "signature": "public void setTcpClient(@Nullable TcpOperations<byte[]> tcpClient)",
    "source_code": "\tpublic void setTcpClient(@Nullable TcpOperations<byte[]> tcpClient) {\n\t\tthis.tcpClient = tcpClient;\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#setVirtualHost(virtualHost)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value of the \"host\" header to use in STOMP CONNECT frames. When this\n\t * property is configured, a \"host\" header will be added to every STOMP frame sent to\n\t * the STOMP broker. This may be useful for example in a cloud environment where the\n\t * actual host to which the TCP connection is established is different from the host\n\t * providing the cloud-based STOMP service.\n\t * <p>By default this property is not set.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "virtualHost"
    ],
    "position": {
      "column": 1,
      "line": 345
    },
    "return": "void",
    "signature": "public void setVirtualHost(@Nullable String virtualHost)",
    "source_code": "\tpublic void setVirtualHost(@Nullable String virtualHost) {\n\t\tthis.virtualHost = virtualHost;\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#shouldSendHeartbeatForIgnoredMessage()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1115
    },
    "return": "boolean",
    "signature": "protected boolean shouldSendHeartbeatForIgnoredMessage()",
    "source_code": "\t\tprotected boolean shouldSendHeartbeatForIgnoredMessage() {\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#startInternal()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 439
    },
    "return": "void",
    "signature": "protected void startInternal()",
    "source_code": "\tprotected void startInternal() {\n\t\tif (this.tcpClient == null) {\n\t\t\tthis.tcpClient = initTcpClient();\n\t\t}\n\n\t\tif (logger.isInfoEnabled()) {\n\t\t\tlogger.info(\"Starting \\\"system\\\" session, \" + this);\n\t\t}\n\n\t\tStompHeaderAccessor accessor = StompHeaderAccessor.create(StompCommand.CONNECT);\n\t\taccessor.setAcceptVersion(\"1.1,1.2\");\n\t\taccessor.setLogin(this.systemLogin);\n\t\taccessor.setPasscode(this.systemPasscode);\n\t\taccessor.setHeartbeat(this.systemHeartbeatSendInterval, this.systemHeartbeatReceiveInterval);\n\t\tString virtualHost = getVirtualHost();\n\t\tif (virtualHost != null) {\n\t\t\taccessor.setHost(virtualHost);\n\t\t}\n\t\taccessor.setSessionId(SYSTEM_SESSION_ID);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Forwarding \" + accessor.getShortLogMessage(EMPTY_PAYLOAD));\n\t\t}\n\n\t\tSystemSessionConnectionHandler handler = new SystemSessionConnectionHandler(accessor);\n\t\tthis.connectionHandlers.put(handler.getSessionId(), handler);\n\n\t\tthis.stats.incrementConnectCount();\n\t\tthis.tcpClient.connectAsync(handler, new FixedIntervalReconnectStrategy(5000));\n\n\t\tif (this.taskScheduler != null) {\n\t\t\tthis.taskScheduler.scheduleWithFixedDelay(new ClientSendMessageCountTask(), Duration.ofMillis(5000));\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#stopInternal()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 494
    },
    "return": "void",
    "signature": "protected void stopInternal()",
    "source_code": "\tprotected void stopInternal() {\n\t\tpublishBrokerUnavailableEvent();\n\t\tif (this.tcpClient != null) {\n\t\t\ttry {\n\t\t\t\tthis.tcpClient.shutdownAsync().get(5000, TimeUnit.MILLISECONDS);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tlogger.error(\"Error in shutdown of TCP client\", ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1202
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn (connectionHandlers.size() + \" sessions, \" + getTcpClientInfo() +\n\t\t\t\t\t(isBrokerAvailable() ? \" (available)\" : \" (not available)\") +\n\t\t\t\t\t\", processed CONNECT(\" + this.connect.get() + \")-CONNECTED(\" +\n\t\t\t\t\tthis.connected.get() + \")-DISCONNECT(\" + this.disconnect.get() + \")\");\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Represents STOMP frame headers.\n *\n * <p>In addition to the normal methods defined by {@link Map}, this class offers\n * the following convenience methods:\n * <ul>\n * <li>{@link #getFirst(String)} return the first value for a header name</li>\n * <li>{@link #add(String, String)} add to the list of values for a header name</li>\n * <li>{@link #set(String, String)} set a header name to a single string value</li>\n * </ul>\n *\n * @author Rossen Stoyanchev\n * @since 4.2\n * @see <a href=\"https://stomp.github.io/stomp-specification-1.2.html#Frames_and_Headers\">\n * https://stomp.github.io/stomp-specification-1.2.html#Frames_and_Headers</a>\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "signature": "public class StompHeaders",
    "source_code": "public class StompHeaders implements MultiValueMap<String, String>, Serializable {\n\n\tprivate static final long serialVersionUID = 7514642206528452544L;\n\n\n\t// Standard headers (as defined in the spec)\n\n\tpublic static final String CONTENT_TYPE = \"content-type\"; // SEND, MESSAGE, ERROR\n\n\tpublic static final String CONTENT_LENGTH = \"content-length\"; // SEND, MESSAGE, ERROR\n\n\tpublic static final String RECEIPT = \"receipt\"; // any client frame other than CONNECT\n\n\t// CONNECT\n\n\tpublic static final String HOST = \"host\";\n\n\tpublic static final String ACCEPT_VERSION = \"accept-version\";\n\n\tpublic static final String LOGIN = \"login\";\n\n\tpublic static final String PASSCODE = \"passcode\";\n\n\tpublic static final String HEARTBEAT = \"heart-beat\";\n\n\t// CONNECTED\n\n\tpublic static final String SESSION = \"session\";\n\n\tpublic static final String SERVER = \"server\";\n\n\t// SEND\n\n\tpublic static final String DESTINATION = \"destination\";\n\n\t// SUBSCRIBE, UNSUBSCRIBE\n\n\tpublic static final String ID = \"id\";\n\n\tpublic static final String ACK = \"ack\";\n\n\t// MESSAGE\n\n\tpublic static final String SUBSCRIPTION = \"subscription\";\n\n\tpublic static final String MESSAGE_ID = \"message-id\";\n\n\t// RECEIPT\n\n\tpublic static final String RECEIPT_ID = \"receipt-id\";\n\n\n\t@SuppressWarnings(\"serial\")\n\tprivate final Map<String, List<String>> headers;\n\n\n\t/**\n\t * Create a new instance to be populated with new header values.\n\t */\n\tpublic StompHeaders() {\n\t\tthis(new LinkedMultiValueMap<>(3), false);\n\t}\n\n\tprivate StompHeaders(Map<String, List<String>> headers, boolean readOnly) {\n\t\tAssert.notNull(headers, \"'headers' must not be null\");\n\t\tif (readOnly) {\n\t\t\tMap<String, List<String>> map = new LinkedMultiValueMap<>(headers.size());\n\t\t\theaders.forEach((key, value) -> map.put(key, Collections.unmodifiableList(value)));\n\t\t\tthis.headers = Collections.unmodifiableMap(map);\n\t\t}\n\t\telse {\n\t\t\tthis.headers = headers;\n\t\t}\n\t}\n\n\n\t/**\n\t * Set the content-type header.\n\t * Applies to the SEND, MESSAGE, and ERROR frames.\n\t */\n\tpublic void setContentType(@Nullable MimeType mimeType) {\n\t\tif (mimeType != null) {\n\t\t\tAssert.isTrue(!mimeType.isWildcardType(), \"'Content-Type' cannot contain wildcard type '*'\");\n\t\t\tAssert.isTrue(!mimeType.isWildcardSubtype(), \"'Content-Type' cannot contain wildcard subtype '*'\");\n\t\t\tset(CONTENT_TYPE, mimeType.toString());\n\t\t}\n\t\telse {\n\t\t\tset(CONTENT_TYPE, null);\n\t\t}\n\t}\n\n\t/**\n\t * Return the content-type header value.\n\t */\n\t@Nullable\n\tpublic MimeType getContentType() {\n\t\tString value = getFirst(CONTENT_TYPE);\n\t\treturn (StringUtils.hasLength(value) ? MimeTypeUtils.parseMimeType(value) : null);\n\t}\n\n\t/**\n\t * Set the content-length header.\n\t * Applies to the SEND, MESSAGE, and ERROR frames.\n\t */\n\tpublic void setContentLength(long contentLength) {\n\t\tset(CONTENT_LENGTH, Long.toString(contentLength));\n\t}\n\n\t/**\n\t * Return the content-length header or -1 if unknown.\n\t */\n\tpublic long getContentLength() {\n\t\tString value = getFirst(CONTENT_LENGTH);\n\t\treturn (value != null ? Long.parseLong(value) : -1);\n\t}\n\n\t/**\n\t * Set the receipt header.\n\t * Applies to any client frame other than CONNECT.\n\t */\n\tpublic void setReceipt(@Nullable String receipt) {\n\t\tset(RECEIPT, receipt);\n\t}\n\n\t/**\n\t * Get the receipt header.\n\t */\n\t@Nullable\n\tpublic String getReceipt() {\n\t\treturn getFirst(RECEIPT);\n\t}\n\n\t/**\n\t * Set the host header.\n\t * Applies to the CONNECT frame.\n\t */\n\tpublic void setHost(@Nullable String host) {\n\t\tset(HOST, host);\n\t}\n\n\t/**\n\t * Get the host header.\n\t */\n\t@Nullable\n\tpublic String getHost() {\n\t\treturn getFirst(HOST);\n\t}\n\n\t/**\n\t * Set the accept-version header. Must be one of \"1.1\", \"1.2\", or both.\n\t * Applies to the CONNECT frame.\n\t * @since 5.0.7\n\t */\n\tpublic void setAcceptVersion(@Nullable String... acceptVersions) {\n\t\tif (ObjectUtils.isEmpty(acceptVersions)) {\n\t\t\tset(ACCEPT_VERSION, null);\n\t\t\treturn;\n\t\t}\n\t\tArrays.stream(acceptVersions).forEach(version ->\n\t\t\t\tAssert.isTrue(version != null && (version.equals(\"1.1\") || version.equals(\"1.2\")),\n\t\t\t\t\t\t() -> \"Invalid version: \" + version));\n\t\tset(ACCEPT_VERSION, StringUtils.arrayToCommaDelimitedString(acceptVersions));\n\t}\n\n\t/**\n\t * Get the accept-version header.\n\t * @since 5.0.7\n\t */\n\t@Nullable\n\tpublic String[] getAcceptVersion() {\n\t\tString value = getFirst(ACCEPT_VERSION);\n\t\treturn value != null ? StringUtils.commaDelimitedListToStringArray(value) : null;\n\t}\n\n\t/**\n\t * Set the login header.\n\t * Applies to the CONNECT frame.\n\t */\n\tpublic void setLogin(@Nullable String login) {\n\t\tset(LOGIN, login);\n\t}\n\n\t/**\n\t * Get the login header.\n\t */\n\t@Nullable\n\tpublic String getLogin() {\n\t\treturn getFirst(LOGIN);\n\t}\n\n\t/**\n\t * Set the passcode header.\n\t * Applies to the CONNECT frame.\n\t */\n\tpublic void setPasscode(@Nullable String passcode) {\n\t\tset(PASSCODE, passcode);\n\t}\n\n\t/**\n\t * Get the passcode header.\n\t */\n\t@Nullable\n\tpublic String getPasscode() {\n\t\treturn getFirst(PASSCODE);\n\t}\n\n\t/**\n\t * Set the heartbeat header.\n\t * Applies to the CONNECT and CONNECTED frames.\n\t */\n\tpublic void setHeartbeat(@Nullable long[] heartbeat) {\n\t\tif (heartbeat == null || heartbeat.length != 2) {\n\t\t\tthrow new IllegalArgumentException(\"Heart-beat array must be of length 2, not \" +\n\t\t\t\t\t(heartbeat != null ? heartbeat.length : \"null\"));\n\t\t}\n\t\tString value = heartbeat[0] + \",\" + heartbeat[1];\n\t\tif (heartbeat[0] < 0 || heartbeat[1] < 0) {\n\t\t\tthrow new IllegalArgumentException(\"Heart-beat values cannot be negative: \" + value);\n\t\t}\n\t\tset(HEARTBEAT, value);\n\t}\n\n\t/**\n\t * Get the heartbeat header.\n\t */\n\t@Nullable\n\tpublic long[] getHeartbeat() {\n\t\tString rawValue = getFirst(HEARTBEAT);\n\t\tString[] rawValues = StringUtils.split(rawValue, \",\");\n\t\tif (rawValues == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new long[] {Long.parseLong(rawValues[0]), Long.parseLong(rawValues[1])};\n\t}\n\n\t/**\n\t * Whether heartbeats are enabled. Returns {@code false} if\n\t * {@link #setHeartbeat} is set to \"0,0\", and {@code true} otherwise.\n\t */\n\tpublic boolean isHeartbeatEnabled() {\n\t\tlong[] heartbeat = getHeartbeat();\n\t\treturn (heartbeat != null && heartbeat[0] != 0 && heartbeat[1] != 0);\n\t}\n\n\t/**\n\t * Set the session header.\n\t * Applies to the CONNECTED frame.\n\t */\n\tpublic void setSession(@Nullable String session) {\n\t\tset(SESSION, session);\n\t}\n\n\t/**\n\t * Get the session header.\n\t */\n\t@Nullable\n\tpublic String getSession() {\n\t\treturn getFirst(SESSION);\n\t}\n\n\t/**\n\t * Set the server header.\n\t * Applies to the CONNECTED frame.\n\t */\n\tpublic void setServer(@Nullable String server) {\n\t\tset(SERVER, server);\n\t}\n\n\t/**\n\t * Get the server header.\n\t * Applies to the CONNECTED frame.\n\t */\n\t@Nullable\n\tpublic String getServer() {\n\t\treturn getFirst(SERVER);\n\t}\n\n\t/**\n\t * Set the destination header.\n\t */\n\tpublic void setDestination(@Nullable String destination) {\n\t\tset(DESTINATION, destination);\n\t}\n\n\t/**\n\t * Get the destination header.\n\t * Applies to the SEND, SUBSCRIBE, and MESSAGE frames.\n\t */\n\t@Nullable\n\tpublic String getDestination() {\n\t\treturn getFirst(DESTINATION);\n\t}\n\n\t/**\n\t * Set the id header.\n\t * Applies to the SUBSCR0BE, UNSUBSCRIBE, and ACK or NACK frames.\n\t */\n\tpublic void setId(@Nullable String id) {\n\t\tset(ID, id);\n\t}\n\n\t/**\n\t * Get the id header.\n\t */\n\t@Nullable\n\tpublic String getId() {\n\t\treturn getFirst(ID);\n\t}\n\n\t/**\n\t * Set the ack header to one of \"auto\", \"client\", or \"client-individual\".\n\t * Applies to the SUBSCRIBE and MESSAGE frames.\n\t */\n\tpublic void setAck(@Nullable String ack) {\n\t\tset(ACK, ack);\n\t}\n\n\t/**\n\t * Get the ack header.\n\t */\n\t@Nullable\n\tpublic String getAck() {\n\t\treturn getFirst(ACK);\n\t}\n\n\t/**\n\t * Set the login header.\n\t * Applies to the MESSAGE frame.\n\t */\n\tpublic void setSubscription(@Nullable String subscription) {\n\t\tset(SUBSCRIPTION, subscription);\n\t}\n\n\t/**\n\t * Get the subscription header.\n\t */\n\t@Nullable\n\tpublic String getSubscription() {\n\t\treturn getFirst(SUBSCRIPTION);\n\t}\n\n\t/**\n\t * Set the message-id header.\n\t * Applies to the MESSAGE frame.\n\t */\n\tpublic void setMessageId(@Nullable String messageId) {\n\t\tset(MESSAGE_ID, messageId);\n\t}\n\n\t/**\n\t * Get the message-id header.\n\t */\n\t@Nullable\n\tpublic String getMessageId() {\n\t\treturn getFirst(MESSAGE_ID);\n\t}\n\n\t/**\n\t * Set the receipt-id header.\n\t * Applies to the RECEIPT frame.\n\t */\n\tpublic void setReceiptId(@Nullable String receiptId) {\n\t\tset(RECEIPT_ID, receiptId);\n\t}\n\n\t/**\n\t * Get the receipt header.\n\t */\n\t@Nullable\n\tpublic String getReceiptId() {\n\t\treturn getFirst(RECEIPT_ID);\n\t}\n\n\t/**\n\t * Return the first header value for the given header name, if any.\n\t * @param headerName the header name\n\t * @return the first header value, or {@code null} if none\n\t */\n\t@Override\n\t@Nullable\n\tpublic String getFirst(String headerName) {\n\t\tList<String> headerValues = this.headers.get(headerName);\n\t\treturn headerValues != null ? headerValues.get(0) : null;\n\t}\n\n\t/**\n\t * Add the given, single header value under the given name.\n\t * @param headerName the header name\n\t * @param headerValue the header value\n\t * @throws UnsupportedOperationException if adding headers is not supported\n\t * @see #put(String, List)\n\t * @see #set(String, String)\n\t */\n\t@Override\n\tpublic void add(String headerName, @Nullable String headerValue) {\n\t\tList<String> headerValues = this.headers.computeIfAbsent(headerName, k -> new ArrayList<>(1));\n\t\theaderValues.add(headerValue);\n\t}\n\n\t@Override\n\tpublic void addAll(String headerName, List<? extends String> headerValues) {\n\t\tList<String> currentValues = this.headers.computeIfAbsent(headerName, k -> new ArrayList<>(1));\n\t\tcurrentValues.addAll(headerValues);\n\t}\n\n\t@Override\n\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this::addAll);\n\t}\n\n\t/**\n\t * Set the given, single header value under the given name.\n\t * @param headerName the header name\n\t * @param headerValue the header value\n\t * @throws UnsupportedOperationException if adding headers is not supported\n\t * @see #put(String, List)\n\t * @see #add(String, String)\n\t */\n\t@Override\n\tpublic void set(String headerName, @Nullable String headerValue) {\n\t\tList<String> headerValues = new ArrayList<>(1);\n\t\theaderValues.add(headerValue);\n\t\tthis.headers.put(headerName, headerValues);\n\t}\n\n\t@Override\n\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this::set);\n\t}\n\n\t@Override\n\tpublic Map<String, String> toSingleValueMap() {\n\t\tLinkedHashMap<String, String> singleValueMap = CollectionUtils.newLinkedHashMap(this.headers.size());\n\t\tthis.headers.forEach((key, value) -> singleValueMap.put(key, value.get(0)));\n\t\treturn singleValueMap;\n\t}\n\n\n\t// Map implementation\n\n\t@Override\n\tpublic int size() {\n\t\treturn this.headers.size();\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn this.headers.isEmpty();\n\t}\n\n\t@Override\n\tpublic boolean containsKey(Object key) {\n\t\treturn this.headers.containsKey(key);\n\t}\n\n\t@Override\n\tpublic boolean containsValue(Object value) {\n\t\treturn this.headers.containsValue(value);\n\t}\n\n\t@Override\n\tpublic List<String> get(Object key) {\n\t\treturn this.headers.get(key);\n\t}\n\n\t@Override\n\tpublic List<String> put(String key, List<String> value) {\n\t\treturn this.headers.put(key, value);\n\t}\n\n\t@Override\n\tpublic List<String> remove(Object key) {\n\t\treturn this.headers.remove(key);\n\t}\n\n\t@Override\n\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tthis.headers.putAll(map);\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\tthis.headers.clear();\n\t}\n\n\t@Override\n\tpublic Set<String> keySet() {\n\t\treturn this.headers.keySet();\n\t}\n\n\t@Override\n\tpublic Collection<List<String>> values() {\n\t\treturn this.headers.values();\n\t}\n\n\t@Override\n\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn this.headers.entrySet();\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof StompHeaders that && this.headers.equals(that.headers)));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.headers.hashCode();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn this.headers.toString();\n\t}\n\n\n\t/**\n\t * Return a {@code StompHeaders} object that can only be read, not written to.\n\t */\n\tpublic static StompHeaders readOnlyStompHeaders(@Nullable Map<String, List<String>> headers) {\n\t\treturn new StompHeaders((headers != null ? headers : Collections.emptyMap()), true);\n\t}\n\n}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#add(headerName,headerValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given, single header value under the given name.\n\t * @param headerName the header name\n\t * @param headerValue the header value\n\t * @throws UnsupportedOperationException if adding headers is not supported\n\t * @see #put(String, List)\n\t * @see #set(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValue"
    ],
    "position": {
      "column": 1,
      "line": 449
    },
    "return": "void",
    "signature": "public void add(String headerName, @Nullable String headerValue)",
    "source_code": "\tpublic void add(String headerName, @Nullable String headerValue) {\n\t\tList<String> headerValues = this.headers.computeIfAbsent(headerName, k -> new ArrayList<>(1));\n\t\theaderValues.add(headerValue);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#addAll(MultiValueMap<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 461
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this::addAll);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#addAll(headerName,headerValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 455
    },
    "return": "void",
    "signature": "public void addAll(String headerName, List<? extends String> headerValues)",
    "source_code": "\tpublic void addAll(String headerName, List<? extends String> headerValues) {\n\t\tList<String> currentValues = this.headers.computeIfAbsent(headerName, k -> new ArrayList<>(1));\n\t\tcurrentValues.addAll(headerValues);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#clear()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 536
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\tpublic void clear() {\n\t\tthis.headers.clear();\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#containsKey(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 506
    },
    "return": "boolean",
    "signature": "public boolean containsKey(Object key)",
    "source_code": "\tpublic boolean containsKey(Object key) {\n\t\treturn this.headers.containsKey(key);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#containsValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 511
    },
    "return": "boolean",
    "signature": "public boolean containsValue(Object value)",
    "source_code": "\tpublic boolean containsValue(Object value) {\n\t\treturn this.headers.containsValue(value);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#entrySet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 551
    },
    "return": "List<String>>>",
    "signature": "public List<String>>> entrySet()",
    "source_code": "\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn this.headers.entrySet();\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 557
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof StompHeaders that && this.headers.equals(that.headers)));\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#get(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 516
    },
    "return": "List<String>",
    "signature": "public List<String> get(Object key)",
    "source_code": "\tpublic List<String> get(Object key) {\n\t\treturn this.headers.get(key);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#getAcceptVersion()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the accept-version header.\n\t * @since 5.0.7\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "String[]",
    "signature": "public String[] getAcceptVersion()",
    "source_code": "\tpublic String[] getAcceptVersion() {\n\t\tString value = getFirst(ACCEPT_VERSION);\n\t\treturn value != null ? StringUtils.commaDelimitedListToStringArray(value) : null;\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#getAck()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the ack header.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 376
    },
    "return": "String",
    "signature": "public String getAck()",
    "source_code": "\tpublic String getAck() {\n\t\treturn getFirst(ACK);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#getContentLength()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the content-length header or -1 if unknown.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "long",
    "signature": "public long getContentLength()",
    "source_code": "\tpublic long getContentLength() {\n\t\tString value = getFirst(CONTENT_LENGTH);\n\t\treturn (value != null ? Long.parseLong(value) : -1);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#getContentType()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the content-type header value.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "MimeType",
    "signature": "public MimeType getContentType()",
    "source_code": "\tpublic MimeType getContentType() {\n\t\tString value = getFirst(CONTENT_TYPE);\n\t\treturn (StringUtils.hasLength(value) ? MimeTypeUtils.parseMimeType(value) : null);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#getDestination()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the destination header.\n\t * Applies to the SEND, SUBSCRIBE, and MESSAGE frames.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 344
    },
    "return": "String",
    "signature": "public String getDestination()",
    "source_code": "\tpublic String getDestination() {\n\t\treturn getFirst(DESTINATION);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#getFirst(headerName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the first header value for the given header name, if any.\n\t * @param headerName the header name\n\t * @return the first header value, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName"
    ],
    "position": {
      "column": 1,
      "line": 435
    },
    "return": "String",
    "signature": "public String getFirst(String headerName)",
    "source_code": "\tpublic String getFirst(String headerName) {\n\t\tList<String> headerValues = this.headers.get(headerName);\n\t\treturn headerValues != null ? headerValues.get(0) : null;\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#getHeartbeat()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the heartbeat header.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "long[]",
    "signature": "public long[] getHeartbeat()",
    "source_code": "\tpublic long[] getHeartbeat() {\n\t\tString rawValue = getFirst(HEARTBEAT);\n\t\tString[] rawValues = StringUtils.split(rawValue, \",\");\n\t\tif (rawValues == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new long[] {Long.parseLong(rawValues[0]), Long.parseLong(rawValues[1])};\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#getHost()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the host header.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "String",
    "signature": "public String getHost()",
    "source_code": "\tpublic String getHost() {\n\t\treturn getFirst(HOST);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#getId()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the id header.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 360
    },
    "return": "String",
    "signature": "public String getId()",
    "source_code": "\tpublic String getId() {\n\t\treturn getFirst(ID);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#getLogin()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the login header.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "String",
    "signature": "public String getLogin()",
    "source_code": "\tpublic String getLogin() {\n\t\treturn getFirst(LOGIN);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#getMessageId()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the message-id header.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 408
    },
    "return": "String",
    "signature": "public String getMessageId()",
    "source_code": "\tpublic String getMessageId() {\n\t\treturn getFirst(MESSAGE_ID);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#getPasscode()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the passcode header.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 257
    },
    "return": "String",
    "signature": "public String getPasscode()",
    "source_code": "\tpublic String getPasscode() {\n\t\treturn getFirst(PASSCODE);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#getReceipt()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the receipt header.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "String",
    "signature": "public String getReceipt()",
    "source_code": "\tpublic String getReceipt() {\n\t\treturn getFirst(RECEIPT);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#getReceiptId()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the receipt header.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 424
    },
    "return": "String",
    "signature": "public String getReceiptId()",
    "source_code": "\tpublic String getReceiptId() {\n\t\treturn getFirst(RECEIPT_ID);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#getServer()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the server header.\n\t * Applies to the CONNECTED frame.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 328
    },
    "return": "String",
    "signature": "public String getServer()",
    "source_code": "\tpublic String getServer() {\n\t\treturn getFirst(SERVER);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#getSession()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the session header.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 311
    },
    "return": "String",
    "signature": "public String getSession()",
    "source_code": "\tpublic String getSession() {\n\t\treturn getFirst(SESSION);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#getSubscription()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the subscription header.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 392
    },
    "return": "String",
    "signature": "public String getSubscription()",
    "source_code": "\tpublic String getSubscription() {\n\t\treturn getFirst(SUBSCRIPTION);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 562
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.headers.hashCode();\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#isEmpty()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 501
    },
    "return": "boolean",
    "signature": "public boolean isEmpty()",
    "source_code": "\tpublic boolean isEmpty() {\n\t\treturn this.headers.isEmpty();\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#isHeartbeatEnabled()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether heartbeats are enabled. Returns {@code false} if\n\t * {@link #setHeartbeat} is set to \"0,0\", and {@code true} otherwise.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 294
    },
    "return": "boolean",
    "signature": "public boolean isHeartbeatEnabled()",
    "source_code": "\tpublic boolean isHeartbeatEnabled() {\n\t\tlong[] heartbeat = getHeartbeat();\n\t\treturn (heartbeat != null && heartbeat[0] != 0 && heartbeat[1] != 0);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#keySet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 541
    },
    "return": "Set<String>",
    "signature": "public Set<String> keySet()",
    "source_code": "\tpublic Set<String> keySet() {\n\t\treturn this.headers.keySet();\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 521
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> value)",
    "source_code": "\tpublic List<String> put(String key, List<String> value) {\n\t\treturn this.headers.put(key, value);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#putAll(String,map)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 531
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tthis.headers.putAll(map);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#readOnlyStompHeaders(Map<String,headers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code StompHeaders} object that can only be read, not written to.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 575
    },
    "return": "StompHeaders",
    "signature": "public StompHeaders readOnlyStompHeaders(@Nullable Map<String, List<String>> headers)",
    "source_code": "\tpublic static StompHeaders readOnlyStompHeaders(@Nullable Map<String, List<String>> headers) {\n\t\treturn new StompHeaders((headers != null ? headers : Collections.emptyMap()), true);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#remove(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 526
    },
    "return": "List<String>",
    "signature": "public List<String> remove(Object key)",
    "source_code": "\tpublic List<String> remove(Object key) {\n\t\treturn this.headers.remove(key);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#set(headerName,headerValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the given, single header value under the given name.\n\t * @param headerName the header name\n\t * @param headerValue the header value\n\t * @throws UnsupportedOperationException if adding headers is not supported\n\t * @see #put(String, List)\n\t * @see #add(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValue"
    ],
    "position": {
      "column": 1,
      "line": 474
    },
    "return": "void",
    "signature": "public void set(String headerName, @Nullable String headerValue)",
    "source_code": "\tpublic void set(String headerName, @Nullable String headerValue) {\n\t\tList<String> headerValues = new ArrayList<>(1);\n\t\theaderValues.add(headerValue);\n\t\tthis.headers.put(headerName, headerValues);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#setAcceptVersion(acceptVersions)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the accept-version header. Must be one of \"1.1\", \"1.2\", or both.\n\t * Applies to the CONNECT frame.\n\t * @since 5.0.7\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "acceptVersions"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "void",
    "signature": "public void setAcceptVersion(@Nullable String... acceptVersions)",
    "source_code": "\tpublic void setAcceptVersion(@Nullable String... acceptVersions) {\n\t\tif (ObjectUtils.isEmpty(acceptVersions)) {\n\t\t\tset(ACCEPT_VERSION, null);\n\t\t\treturn;\n\t\t}\n\t\tArrays.stream(acceptVersions).forEach(version ->\n\t\t\t\tAssert.isTrue(version != null && (version.equals(\"1.1\") || version.equals(\"1.2\")),\n\t\t\t\t\t\t() -> \"Invalid version: \" + version));\n\t\tset(ACCEPT_VERSION, StringUtils.arrayToCommaDelimitedString(acceptVersions));\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#setAck(ack)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the ack header to one of \"auto\", \"client\", or \"client-individual\".\n\t * Applies to the SUBSCRIBE and MESSAGE frames.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ack"
    ],
    "position": {
      "column": 1,
      "line": 368
    },
    "return": "void",
    "signature": "public void setAck(@Nullable String ack)",
    "source_code": "\tpublic void setAck(@Nullable String ack) {\n\t\tset(ACK, ack);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#setAll(Map<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 481
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this::set);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#setContentLength(contentLength)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the content-length header.\n\t * Applies to the SEND, MESSAGE, and ERROR frames.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentLength"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "void",
    "signature": "public void setContentLength(long contentLength)",
    "source_code": "\tpublic void setContentLength(long contentLength) {\n\t\tset(CONTENT_LENGTH, Long.toString(contentLength));\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#setContentType(mimeType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the content-type header.\n\t * Applies to the SEND, MESSAGE, and ERROR frames.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "void",
    "signature": "public void setContentType(@Nullable MimeType mimeType)",
    "source_code": "\tpublic void setContentType(@Nullable MimeType mimeType) {\n\t\tif (mimeType != null) {\n\t\t\tAssert.isTrue(!mimeType.isWildcardType(), \"'Content-Type' cannot contain wildcard type '*'\");\n\t\t\tAssert.isTrue(!mimeType.isWildcardSubtype(), \"'Content-Type' cannot contain wildcard subtype '*'\");\n\t\t\tset(CONTENT_TYPE, mimeType.toString());\n\t\t}\n\t\telse {\n\t\t\tset(CONTENT_TYPE, null);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#setDestination(destination)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the destination header.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 335
    },
    "return": "void",
    "signature": "public void setDestination(@Nullable String destination)",
    "source_code": "\tpublic void setDestination(@Nullable String destination) {\n\t\tset(DESTINATION, destination);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#setHeartbeat(heartbeat)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the heartbeat header.\n\t * Applies to the CONNECT and CONNECTED frames.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "heartbeat"
    ],
    "position": {
      "column": 1,
      "line": 265
    },
    "return": "void",
    "signature": "public void setHeartbeat(@Nullable long[] heartbeat)",
    "source_code": "\tpublic void setHeartbeat(@Nullable long[] heartbeat) {\n\t\tif (heartbeat == null || heartbeat.length != 2) {\n\t\t\tthrow new IllegalArgumentException(\"Heart-beat array must be of length 2, not \" +\n\t\t\t\t\t(heartbeat != null ? heartbeat.length : \"null\"));\n\t\t}\n\t\tString value = heartbeat[0] + \",\" + heartbeat[1];\n\t\tif (heartbeat[0] < 0 || heartbeat[1] < 0) {\n\t\t\tthrow new IllegalArgumentException(\"Heart-beat values cannot be negative: \" + value);\n\t\t}\n\t\tset(HEARTBEAT, value);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#setHost(host)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the host header.\n\t * Applies to the CONNECT frame.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "host"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "void",
    "signature": "public void setHost(@Nullable String host)",
    "source_code": "\tpublic void setHost(@Nullable String host) {\n\t\tset(HOST, host);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#setId(id)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the id header.\n\t * Applies to the SUBSCR0BE, UNSUBSCRIBE, and ACK or NACK frames.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "id"
    ],
    "position": {
      "column": 1,
      "line": 352
    },
    "return": "void",
    "signature": "public void setId(@Nullable String id)",
    "source_code": "\tpublic void setId(@Nullable String id) {\n\t\tset(ID, id);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#setLogin(login)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the login header.\n\t * Applies to the CONNECT frame.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "login"
    ],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "void",
    "signature": "public void setLogin(@Nullable String login)",
    "source_code": "\tpublic void setLogin(@Nullable String login) {\n\t\tset(LOGIN, login);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#setMessageId(messageId)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the message-id header.\n\t * Applies to the MESSAGE frame.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageId"
    ],
    "position": {
      "column": 1,
      "line": 400
    },
    "return": "void",
    "signature": "public void setMessageId(@Nullable String messageId)",
    "source_code": "\tpublic void setMessageId(@Nullable String messageId) {\n\t\tset(MESSAGE_ID, messageId);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#setPasscode(passcode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the passcode header.\n\t * Applies to the CONNECT frame.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "passcode"
    ],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "void",
    "signature": "public void setPasscode(@Nullable String passcode)",
    "source_code": "\tpublic void setPasscode(@Nullable String passcode) {\n\t\tset(PASSCODE, passcode);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#setReceipt(receipt)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the receipt header.\n\t * Applies to any client frame other than CONNECT.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "receipt"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "void",
    "signature": "public void setReceipt(@Nullable String receipt)",
    "source_code": "\tpublic void setReceipt(@Nullable String receipt) {\n\t\tset(RECEIPT, receipt);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#setReceiptId(receiptId)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the receipt-id header.\n\t * Applies to the RECEIPT frame.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "receiptId"
    ],
    "position": {
      "column": 1,
      "line": 416
    },
    "return": "void",
    "signature": "public void setReceiptId(@Nullable String receiptId)",
    "source_code": "\tpublic void setReceiptId(@Nullable String receiptId) {\n\t\tset(RECEIPT_ID, receiptId);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#setServer(server)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the server header.\n\t * Applies to the CONNECTED frame.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "server"
    ],
    "position": {
      "column": 1,
      "line": 319
    },
    "return": "void",
    "signature": "public void setServer(@Nullable String server)",
    "source_code": "\tpublic void setServer(@Nullable String server) {\n\t\tset(SERVER, server);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#setSession(session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the session header.\n\t * Applies to the CONNECTED frame.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 303
    },
    "return": "void",
    "signature": "public void setSession(@Nullable String session)",
    "source_code": "\tpublic void setSession(@Nullable String session) {\n\t\tset(SESSION, session);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#setSubscription(subscription)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the login header.\n\t * Applies to the MESSAGE frame.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "subscription"
    ],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "void",
    "signature": "public void setSubscription(@Nullable String subscription)",
    "source_code": "\tpublic void setSubscription(@Nullable String subscription) {\n\t\tset(SUBSCRIPTION, subscription);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#size()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 496
    },
    "return": "int",
    "signature": "public int size()",
    "source_code": "\tpublic int size() {\n\t\treturn this.headers.size();\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#toSingleValueMap()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 486
    },
    "return": "String>",
    "signature": "public String> toSingleValueMap()",
    "source_code": "\tpublic Map<String, String> toSingleValueMap() {\n\t\tLinkedHashMap<String, String> singleValueMap = CollectionUtils.newLinkedHashMap(this.headers.size());\n\t\tthis.headers.forEach((key, value) -> singleValueMap.put(key, value.get(0)));\n\t\treturn singleValueMap;\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 567
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn this.headers.toString();\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#values()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 546
    },
    "return": "Collection<List<String>>",
    "signature": "public Collection<List<String>> values()",
    "source_code": "\tpublic Collection<List<String>> values() {\n\t\treturn this.headers.values();\n\t}"
  },
  "org.springframework.messaging.simp.user.MultiServerUserRegistry#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 458
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object obj) {\n\t\t\treturn (this == obj || (obj instanceof SimpSession that && this.id.equals(that.getId())));\n\t\t}"
  },
  "org.springframework.messaging.support.AbstractMessageChannel": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract base class for {@link MessageChannel} implementations.\n *\n * @author Rossen Stoyanchev\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "signature": "public class AbstractMessageChannel",
    "source_code": "public abstract class AbstractMessageChannel implements MessageChannel, InterceptableChannel, BeanNameAware {\n\n\tprotected Log logger = LogFactory.getLog(getClass());\n\n\tprivate String beanName;\n\n\tprivate final List<ChannelInterceptor> interceptors = new ArrayList<>(5);\n\n\n\tpublic AbstractMessageChannel() {\n\t\tthis.beanName = getClass().getSimpleName() + \"@\" + ObjectUtils.getIdentityHexString(this);\n\t}\n\n\n\t/**\n\t * Set an alternative logger to use than the one based on the class name.\n\t * @param logger the logger to use\n\t * @since 5.1\n\t */\n\tpublic void setLogger(Log logger) {\n\t\tthis.logger = logger;\n\t}\n\n\t/**\n\t * Return the currently configured Logger.\n\t * @since 5.1\n\t */\n\tpublic Log getLogger() {\n\t\treturn logger;\n\t}\n\n\t/**\n\t * A message channel uses the bean name primarily for logging purposes.\n\t */\n\t@Override\n\tpublic void setBeanName(String name) {\n\t\tthis.beanName = name;\n\t}\n\n\t/**\n\t * Return the bean name for this message channel.\n\t */\n\tpublic String getBeanName() {\n\t\treturn this.beanName;\n\t}\n\n\n\t@Override\n\tpublic void setInterceptors(List<ChannelInterceptor> interceptors) {\n\t\tAssert.noNullElements(interceptors, \"'interceptors' must not contain null elements\");\n\t\tthis.interceptors.clear();\n\t\tthis.interceptors.addAll(interceptors);\n\t}\n\n\t@Override\n\tpublic void addInterceptor(ChannelInterceptor interceptor) {\n\t\tAssert.notNull(interceptor, \"'interceptor' must not be null\");\n\t\tthis.interceptors.add(interceptor);\n\t}\n\n\t@Override\n\tpublic void addInterceptor(int index, ChannelInterceptor interceptor) {\n\t\tAssert.notNull(interceptor, \"'interceptor' must not be null\");\n\t\tthis.interceptors.add(index, interceptor);\n\t}\n\n\t@Override\n\tpublic List<ChannelInterceptor> getInterceptors() {\n\t\treturn Collections.unmodifiableList(this.interceptors);\n\t}\n\n\t@Override\n\tpublic boolean removeInterceptor(ChannelInterceptor interceptor) {\n\t\treturn this.interceptors.remove(interceptor);\n\t}\n\n\t@Override\n\tpublic ChannelInterceptor removeInterceptor(int index) {\n\t\treturn this.interceptors.remove(index);\n\t}\n\n\n\t@Override\n\tpublic final boolean send(Message<?> message) {\n\t\treturn send(message, INDEFINITE_TIMEOUT);\n\t}\n\n\t@Override\n\tpublic final boolean send(Message<?> message, long timeout) {\n\t\tAssert.notNull(message, \"Message must not be null\");\n\t\tMessage<?> messageToUse = message;\n\t\tChannelInterceptorChain chain = new ChannelInterceptorChain();\n\t\tboolean sent = false;\n\t\ttry {\n\t\t\tmessageToUse = chain.applyPreSend(messageToUse, this);\n\t\t\tif (messageToUse == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tsent = sendInternal(messageToUse, timeout);\n\t\t\tchain.applyPostSend(messageToUse, this, sent);\n\t\t\tchain.triggerAfterSendCompletion(messageToUse, this, sent, null);\n\t\t\treturn sent;\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tchain.triggerAfterSendCompletion(messageToUse, this, sent, ex);\n\t\t\tif (ex instanceof MessagingException messagingException) {\n\t\t\t\tthrow messagingException;\n\t\t\t}\n\t\t\tthrow new MessageDeliveryException(messageToUse,\"Failed to send message to \" + this, ex);\n\t\t}\n\t\tcatch (Throwable err) {\n\t\t\tMessageDeliveryException ex2 =\n\t\t\t\t\tnew MessageDeliveryException(messageToUse, \"Failed to send message to \" + this, err);\n\t\t\tchain.triggerAfterSendCompletion(messageToUse, this, sent, ex2);\n\t\t\tthrow ex2;\n\t\t}\n\t}\n\n\tprotected abstract boolean sendInternal(Message<?> message, long timeout);\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \"[\" + this.beanName + \"]\";\n\t}\n\n\n\t/**\n\t * Assists with the invocation of the configured channel interceptors.\n\t */\n\tprotected class ChannelInterceptorChain {\n\n\t\tprivate int sendInterceptorIndex = -1;\n\n\t\tprivate int receiveInterceptorIndex = -1;\n\n\t\t@Nullable\n\t\tpublic Message<?> applyPreSend(Message<?> message, MessageChannel channel) {\n\t\t\tMessage<?> messageToUse = message;\n\t\t\tfor (ChannelInterceptor interceptor : interceptors) {\n\t\t\t\tMessage<?> resolvedMessage = interceptor.preSend(messageToUse, channel);\n\t\t\t\tif (resolvedMessage == null) {\n\t\t\t\t\tString name = interceptor.getClass().getSimpleName();\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(name + \" returned null from preSend, i.e. precluding the send.\");\n\t\t\t\t\t}\n\t\t\t\t\ttriggerAfterSendCompletion(messageToUse, channel, false, null);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tmessageToUse = resolvedMessage;\n\t\t\t\tthis.sendInterceptorIndex++;\n\t\t\t}\n\t\t\treturn messageToUse;\n\t\t}\n\n\t\tpublic void applyPostSend(Message<?> message, MessageChannel channel, boolean sent) {\n\t\t\tfor (ChannelInterceptor interceptor : interceptors) {\n\t\t\t\tinterceptor.postSend(message, channel, sent);\n\t\t\t}\n\t\t}\n\n\t\tpublic void triggerAfterSendCompletion(Message<?> message, MessageChannel channel,\n\t\t\t\tboolean sent, @Nullable Exception ex) {\n\n\t\t\tfor (int i = this.sendInterceptorIndex; i >= 0; i--) {\n\t\t\t\tChannelInterceptor interceptor = interceptors.get(i);\n\t\t\t\ttry {\n\t\t\t\t\tinterceptor.afterSendCompletion(message, channel, sent, ex);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\tlogger.error(\"Exception from afterSendCompletion in \" + interceptor, ex2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic boolean applyPreReceive(MessageChannel channel) {\n\t\t\tfor (ChannelInterceptor interceptor : interceptors) {\n\t\t\t\tif (!interceptor.preReceive(channel)) {\n\t\t\t\t\ttriggerAfterReceiveCompletion(null, channel, null);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tthis.receiveInterceptorIndex++;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t@Nullable\n\t\tpublic Message<?> applyPostReceive(Message<?> message, MessageChannel channel) {\n\t\t\tMessage<?> messageToUse = message;\n\t\t\tfor (ChannelInterceptor interceptor : interceptors) {\n\t\t\t\tmessageToUse = interceptor.postReceive(messageToUse, channel);\n\t\t\t\tif (messageToUse == null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn messageToUse;\n\t\t}\n\n\t\tpublic void triggerAfterReceiveCompletion(\n\t\t\t\t@Nullable Message<?> message, MessageChannel channel, @Nullable Exception ex) {\n\n\t\t\tfor (int i = this.receiveInterceptorIndex; i >= 0; i--) {\n\t\t\t\tChannelInterceptor interceptor = interceptors.get(i);\n\t\t\t\ttry {\n\t\t\t\t\tinterceptor.afterReceiveCompletion(message, channel, ex);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\t\t\tlogger.error(\"Exception from afterReceiveCompletion in \" + interceptor, ex2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.messaging.support.AbstractMessageChannel#addInterceptor(index,interceptor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "interceptor"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "void",
    "signature": "public void addInterceptor(int index, ChannelInterceptor interceptor)",
    "source_code": "\tpublic void addInterceptor(int index, ChannelInterceptor interceptor) {\n\t\tAssert.notNull(interceptor, \"'interceptor' must not be null\");\n\t\tthis.interceptors.add(index, interceptor);\n\t}"
  },
  "org.springframework.messaging.support.AbstractMessageChannel#addInterceptor(interceptor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "interceptor"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "public void addInterceptor(ChannelInterceptor interceptor)",
    "source_code": "\tpublic void addInterceptor(ChannelInterceptor interceptor) {\n\t\tAssert.notNull(interceptor, \"'interceptor' must not be null\");\n\t\tthis.interceptors.add(interceptor);\n\t}"
  },
  "org.springframework.messaging.support.AbstractMessageChannel#applyPostSend(message,channel,sent)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "channel",
      "sent"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "void",
    "signature": "public void applyPostSend(Message<?> message, MessageChannel channel, boolean sent)",
    "source_code": "\t\tpublic void applyPostSend(Message<?> message, MessageChannel channel, boolean sent) {\n\t\t\tfor (ChannelInterceptor interceptor : interceptors) {\n\t\t\t\tinterceptor.postSend(message, channel, sent);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.support.AbstractMessageChannel#applyPreReceive(channel)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "channel"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "boolean",
    "signature": "public boolean applyPreReceive(MessageChannel channel)",
    "source_code": "\t\tpublic boolean applyPreReceive(MessageChannel channel) {\n\t\t\tfor (ChannelInterceptor interceptor : interceptors) {\n\t\t\t\tif (!interceptor.preReceive(channel)) {\n\t\t\t\t\ttriggerAfterReceiveCompletion(null, channel, null);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tthis.receiveInterceptorIndex++;\n\t\t\t}\n\t\t\treturn true;\n\t\t}"
  },
  "org.springframework.messaging.support.AbstractMessageChannel#getBeanName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the bean name for this message channel.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "String",
    "signature": "public String getBeanName()",
    "source_code": "\tpublic String getBeanName() {\n\t\treturn this.beanName;\n\t}"
  },
  "org.springframework.messaging.support.AbstractMessageChannel#getInterceptors()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "List<ChannelInterceptor>",
    "signature": "public List<ChannelInterceptor> getInterceptors()",
    "source_code": "\tpublic List<ChannelInterceptor> getInterceptors() {\n\t\treturn Collections.unmodifiableList(this.interceptors);\n\t}"
  },
  "org.springframework.messaging.support.AbstractMessageChannel#getLogger()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the currently configured Logger.\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "Log",
    "signature": "public Log getLogger()",
    "source_code": "\tpublic Log getLogger() {\n\t\treturn logger;\n\t}"
  },
  "org.springframework.messaging.support.AbstractMessageChannel#removeInterceptor(index)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "ChannelInterceptor",
    "signature": "public ChannelInterceptor removeInterceptor(int index)",
    "source_code": "\tpublic ChannelInterceptor removeInterceptor(int index) {\n\t\treturn this.interceptors.remove(index);\n\t}"
  },
  "org.springframework.messaging.support.AbstractMessageChannel#removeInterceptor(interceptor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "interceptor"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "boolean",
    "signature": "public boolean removeInterceptor(ChannelInterceptor interceptor)",
    "source_code": "\tpublic boolean removeInterceptor(ChannelInterceptor interceptor) {\n\t\treturn this.interceptors.remove(interceptor);\n\t}"
  },
  "org.springframework.messaging.support.AbstractMessageChannel#send(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "boolean",
    "signature": "public boolean send(Message<?> message)",
    "source_code": "\tpublic final boolean send(Message<?> message) {\n\t\treturn send(message, INDEFINITE_TIMEOUT);\n\t}"
  },
  "org.springframework.messaging.support.AbstractMessageChannel#send(message,timeout)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "boolean",
    "signature": "public boolean send(Message<?> message, long timeout)",
    "source_code": "\tpublic final boolean send(Message<?> message, long timeout) {\n\t\tAssert.notNull(message, \"Message must not be null\");\n\t\tMessage<?> messageToUse = message;\n\t\tChannelInterceptorChain chain = new ChannelInterceptorChain();\n\t\tboolean sent = false;\n\t\ttry {\n\t\t\tmessageToUse = chain.applyPreSend(messageToUse, this);\n\t\t\tif (messageToUse == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tsent = sendInternal(messageToUse, timeout);\n\t\t\tchain.applyPostSend(messageToUse, this, sent);\n\t\t\tchain.triggerAfterSendCompletion(messageToUse, this, sent, null);\n\t\t\treturn sent;\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tchain.triggerAfterSendCompletion(messageToUse, this, sent, ex);\n\t\t\tif (ex instanceof MessagingException messagingException) {\n\t\t\t\tthrow messagingException;\n\t\t\t}\n\t\t\tthrow new MessageDeliveryException(messageToUse,\"Failed to send message to \" + this, ex);\n\t\t}\n\t\tcatch (Throwable err) {\n\t\t\tMessageDeliveryException ex2 =\n\t\t\t\t\tnew MessageDeliveryException(messageToUse, \"Failed to send message to \" + this, err);\n\t\t\tchain.triggerAfterSendCompletion(messageToUse, this, sent, ex2);\n\t\t\tthrow ex2;\n\t\t}\n\t}"
  },
  "org.springframework.messaging.support.AbstractMessageChannel#sendInternal(message,timeout)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "boolean",
    "signature": "protected boolean sendInternal(Message<?> message, long timeout)",
    "source_code": "\tprotected abstract boolean sendInternal(Message<?> message, long timeout);"
  },
  "org.springframework.messaging.support.AbstractMessageChannel#setBeanName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A message channel uses the bean name primarily for logging purposes.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "void",
    "signature": "public void setBeanName(String name)",
    "source_code": "\tpublic void setBeanName(String name) {\n\t\tthis.beanName = name;\n\t}"
  },
  "org.springframework.messaging.support.AbstractMessageChannel#setInterceptors(interceptors)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "interceptors"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "void",
    "signature": "public void setInterceptors(List<ChannelInterceptor> interceptors)",
    "source_code": "\tpublic void setInterceptors(List<ChannelInterceptor> interceptors) {\n\t\tAssert.noNullElements(interceptors, \"'interceptors' must not contain null elements\");\n\t\tthis.interceptors.clear();\n\t\tthis.interceptors.addAll(interceptors);\n\t}"
  },
  "org.springframework.messaging.support.AbstractMessageChannel#setLogger(logger)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set an alternative logger to use than the one based on the class name.\n\t * @param logger the logger to use\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "logger"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "void",
    "signature": "public void setLogger(Log logger)",
    "source_code": "\tpublic void setLogger(Log logger) {\n\t\tthis.logger = logger;\n\t}"
  },
  "org.springframework.messaging.support.AbstractMessageChannel#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \"[\" + this.beanName + \"]\";\n\t}"
  },
  "org.springframework.messaging.support.AbstractMessageChannel#triggerAfterReceiveCompletion(message,channel,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "channel",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "void",
    "signature": "public void triggerAfterReceiveCompletion(@Nullable Message<?> message, MessageChannel channel, @Nullable Exception ex)",
    "source_code": "\t\tpublic void triggerAfterReceiveCompletion("
  },
  "org.springframework.messaging.support.AbstractMessageChannel#triggerAfterSendCompletion(message,channel,sent,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "channel",
      "sent",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "void",
    "signature": "public void triggerAfterSendCompletion(Message<?> message, MessageChannel channel,\n\t\t\t\tboolean sent, @Nullable Exception ex)",
    "source_code": "\t\tpublic void triggerAfterSendCompletion(Message<?> message, MessageChannel channel,"
  },
  "org.springframework.messaging.support.ChannelInterceptorChain": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assists with the invocation of the configured channel interceptors.\n\t */",
    "kind": "class",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "signature": "protected class ChannelInterceptorChain",
    "source_code": "\tprotected class ChannelInterceptorChain {\n\n\t\tprivate int sendInterceptorIndex = -1;\n\n\t\tprivate int receiveInterceptorIndex = -1;\n\n\t\t@Nullable\n\t\tpublic Message<?> applyPreSend(Message<?> message, MessageChannel channel) {\n\t\t\tMessage<?> messageToUse = message;\n\t\t\tfor (ChannelInterceptor interceptor : interceptors) {\n\t\t\t\tMessage<?> resolvedMessage = interceptor.preSend(messageToUse, channel);\n\t\t\t\tif (resolvedMessage == null) {\n\t\t\t\t\tString name = interceptor.getClass().getSimpleName();\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(name + \" returned null from preSend, i.e. precluding the send.\");\n\t\t\t\t\t}\n\t\t\t\t\ttriggerAfterSendCompletion(messageToUse, channel, false, null);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tmessageToUse = resolvedMessage;\n\t\t\t\tthis.sendInterceptorIndex++;\n\t\t\t}\n\t\t\treturn messageToUse;\n\t\t}\n\n\t\tpublic void applyPostSend(Message<?> message, MessageChannel channel, boolean sent) {\n\t\t\tfor (ChannelInterceptor interceptor : interceptors) {\n\t\t\t\tinterceptor.postSend(message, channel, sent);\n\t\t\t}\n\t\t}\n\n\t\tpublic void triggerAfterSendCompletion(Message<?> message, MessageChannel channel,\n\t\t\t\tboolean sent, @Nullable Exception ex) {\n\n\t\t\tfor (int i = this.sendInterceptorIndex; i >= 0; i--) {\n\t\t\t\tChannelInterceptor interceptor = interceptors.get(i);\n\t\t\t\ttry {\n\t\t\t\t\tinterceptor.afterSendCompletion(message, channel, sent, ex);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\tlogger.error(\"Exception from afterSendCompletion in \" + interceptor, ex2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic boolean applyPreReceive(MessageChannel channel) {\n\t\t\tfor (ChannelInterceptor interceptor : interceptors) {\n\t\t\t\tif (!interceptor.preReceive(channel)) {\n\t\t\t\t\ttriggerAfterReceiveCompletion(null, channel, null);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tthis.receiveInterceptorIndex++;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t@Nullable\n\t\tpublic Message<?> applyPostReceive(Message<?> message, MessageChannel channel) {\n\t\t\tMessage<?> messageToUse = message;\n\t\t\tfor (ChannelInterceptor interceptor : interceptors) {\n\t\t\t\tmessageToUse = interceptor.postReceive(messageToUse, channel);\n\t\t\t\tif (messageToUse == null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn messageToUse;\n\t\t}\n\n\t\tpublic void triggerAfterReceiveCompletion(\n\t\t\t\t@Nullable Message<?> message, MessageChannel channel, @Nullable Exception ex) {\n\n\t\t\tfor (int i = this.receiveInterceptorIndex; i >= 0; i--) {\n\t\t\t\tChannelInterceptor interceptor = interceptors.get(i);\n\t\t\t\ttry {\n\t\t\t\t\tinterceptor.afterReceiveCompletion(message, channel, ex);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\t\t\tlogger.error(\"Exception from afterReceiveCompletion in \" + interceptor, ex2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.messaging.support.ExecutorSubscribableChannel": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A {@link SubscribableChannel} that sends messages to each of its subscribers.\n *\n * @author Phillip Webb\n * @author Rossen Stoyanchev\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "signature": "public class ExecutorSubscribableChannel",
    "source_code": "public class ExecutorSubscribableChannel extends AbstractSubscribableChannel {\n\n\t@Nullable\n\tprivate final Executor executor;\n\n\tprivate final List<ExecutorChannelInterceptor> executorInterceptors = new ArrayList<>(4);\n\n\n\t/**\n\t * Create a new {@link ExecutorSubscribableChannel} instance\n\t * where messages will be sent in the callers thread.\n\t */\n\tpublic ExecutorSubscribableChannel() {\n\t\tthis(null);\n\t}\n\n\t/**\n\t * Create a new {@link ExecutorSubscribableChannel} instance\n\t * where messages will be sent via the specified executor.\n\t * @param executor the executor used to send the message,\n\t * or {@code null} to execute in the callers thread.\n\t */\n\tpublic ExecutorSubscribableChannel(@Nullable Executor executor) {\n\t\tthis.executor = executor;\n\t}\n\n\n\t@Nullable\n\tpublic Executor getExecutor() {\n\t\treturn this.executor;\n\t}\n\n\t@Override\n\tpublic void setInterceptors(List<ChannelInterceptor> interceptors) {\n\t\tsuper.setInterceptors(interceptors);\n\t\tthis.executorInterceptors.clear();\n\t\tinterceptors.forEach(this::updateExecutorInterceptorsFor);\n\t}\n\n\t@Override\n\tpublic void addInterceptor(ChannelInterceptor interceptor) {\n\t\tsuper.addInterceptor(interceptor);\n\t\tupdateExecutorInterceptorsFor(interceptor);\n\t}\n\n\t@Override\n\tpublic void addInterceptor(int index, ChannelInterceptor interceptor) {\n\t\tsuper.addInterceptor(index, interceptor);\n\t\tupdateExecutorInterceptorsFor(interceptor);\n\t}\n\n\tprivate void updateExecutorInterceptorsFor(ChannelInterceptor interceptor) {\n\t\tif (interceptor instanceof ExecutorChannelInterceptor executorChannelInterceptor) {\n\t\t\tthis.executorInterceptors.add(executorChannelInterceptor);\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic boolean sendInternal(Message<?> message, long timeout) {\n\t\tfor (MessageHandler handler : getSubscribers()) {\n\t\t\tSendTask sendTask = new SendTask(message, handler);\n\t\t\tif (this.executor == null) {\n\t\t\t\tsendTask.run();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.executor.execute(sendTask);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\n\t/**\n\t * Invoke a MessageHandler with ExecutorChannelInterceptors.\n\t */\n\tprivate class SendTask implements MessageHandlingRunnable {\n\n\t\tprivate final Message<?> inputMessage;\n\n\t\tprivate final MessageHandler messageHandler;\n\n\t\tprivate int interceptorIndex = -1;\n\n\t\tpublic SendTask(Message<?> message, MessageHandler messageHandler) {\n\t\t\tthis.inputMessage = message;\n\t\t\tthis.messageHandler = messageHandler;\n\t\t}\n\n\t\t@Override\n\t\tpublic Message<?> getMessage() {\n\t\t\treturn this.inputMessage;\n\t\t}\n\n\t\t@Override\n\t\tpublic MessageHandler getMessageHandler() {\n\t\t\treturn this.messageHandler;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tMessage<?> message = this.inputMessage;\n\t\t\ttry {\n\t\t\t\tmessage = applyBeforeHandle(message);\n\t\t\t\tif (message == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.messageHandler.handleMessage(message);\n\t\t\t\ttriggerAfterMessageHandled(message, null);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\ttriggerAfterMessageHandled(message, ex);\n\t\t\t\tif (ex instanceof MessagingException messagingException) {\n\t\t\t\t\tthrow messagingException;\n\t\t\t\t}\n\t\t\t\tString description = \"Failed to handle \" + message + \" to \" + this + \" in \" + this.messageHandler;\n\t\t\t\tthrow new MessageDeliveryException(message, description, ex);\n\t\t\t}\n\t\t\tcatch (Throwable err) {\n\t\t\t\tString description = \"Failed to handle \" + message + \" to \" + this + \" in \" + this.messageHandler;\n\t\t\t\tMessageDeliveryException ex2 = new MessageDeliveryException(message, description, err);\n\t\t\t\ttriggerAfterMessageHandled(message, ex2);\n\t\t\t\tthrow ex2;\n\t\t\t}\n\t\t}\n\n\t\t@Nullable\n\t\tprivate Message<?> applyBeforeHandle(Message<?> message) {\n\t\t\tMessage<?> messageToUse = message;\n\t\t\tfor (ExecutorChannelInterceptor interceptor : executorInterceptors) {\n\t\t\t\tmessageToUse = interceptor.beforeHandle(messageToUse, ExecutorSubscribableChannel.this, this.messageHandler);\n\t\t\t\tif (messageToUse == null) {\n\t\t\t\t\tString name = interceptor.getClass().getSimpleName();\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(name + \" returned null from beforeHandle, i.e. precluding the send.\");\n\t\t\t\t\t}\n\t\t\t\t\ttriggerAfterMessageHandled(message, null);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tthis.interceptorIndex++;\n\t\t\t}\n\t\t\treturn messageToUse;\n\t\t}\n\n\t\tprivate void triggerAfterMessageHandled(Message<?> message, @Nullable Exception ex) {\n\t\t\tfor (int i = this.interceptorIndex; i >= 0; i--) {\n\t\t\t\tExecutorChannelInterceptor interceptor = executorInterceptors.get(i);\n\t\t\t\ttry {\n\t\t\t\t\tinterceptor.afterMessageHandled(message, ExecutorSubscribableChannel.this, this.messageHandler, ex);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\tlogger.error(\"Exception from afterMessageHandled in \" + interceptor, ex2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.messaging.support.ExecutorSubscribableChannel#addInterceptor(index,interceptor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "interceptor"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void addInterceptor(int index, ChannelInterceptor interceptor)",
    "source_code": "\tpublic void addInterceptor(int index, ChannelInterceptor interceptor) {\n\t\tsuper.addInterceptor(index, interceptor);\n\t\tupdateExecutorInterceptorsFor(interceptor);\n\t}"
  },
  "org.springframework.messaging.support.ExecutorSubscribableChannel#addInterceptor(interceptor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "interceptor"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "void",
    "signature": "public void addInterceptor(ChannelInterceptor interceptor)",
    "source_code": "\tpublic void addInterceptor(ChannelInterceptor interceptor) {\n\t\tsuper.addInterceptor(interceptor);\n\t\tupdateExecutorInterceptorsFor(interceptor);\n\t}"
  },
  "org.springframework.messaging.support.ExecutorSubscribableChannel#getExecutor()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "Executor",
    "signature": "public Executor getExecutor()",
    "source_code": "\tpublic Executor getExecutor() {\n\t\treturn this.executor;\n\t}"
  },
  "org.springframework.messaging.support.ExecutorSubscribableChannel#getMessageHandler()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "MessageHandler",
    "signature": "public MessageHandler getMessageHandler()",
    "source_code": "\t\tpublic MessageHandler getMessageHandler() {\n\t\t\treturn this.messageHandler;\n\t\t}"
  },
  "org.springframework.messaging.support.ExecutorSubscribableChannel#run()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "void",
    "signature": "public void run()",
    "source_code": "\t\tpublic void run() {\n\t\t\tMessage<?> message = this.inputMessage;\n\t\t\ttry {\n\t\t\t\tmessage = applyBeforeHandle(message);\n\t\t\t\tif (message == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.messageHandler.handleMessage(message);\n\t\t\t\ttriggerAfterMessageHandled(message, null);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\ttriggerAfterMessageHandled(message, ex);\n\t\t\t\tif (ex instanceof MessagingException messagingException) {\n\t\t\t\t\tthrow messagingException;\n\t\t\t\t}\n\t\t\t\tString description = \"Failed to handle \" + message + \" to \" + this + \" in \" + this.messageHandler;\n\t\t\t\tthrow new MessageDeliveryException(message, description, ex);\n\t\t\t}\n\t\t\tcatch (Throwable err) {\n\t\t\t\tString description = \"Failed to handle \" + message + \" to \" + this + \" in \" + this.messageHandler;\n\t\t\t\tMessageDeliveryException ex2 = new MessageDeliveryException(message, description, err);\n\t\t\t\ttriggerAfterMessageHandled(message, ex2);\n\t\t\t\tthrow ex2;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.support.ExecutorSubscribableChannel#sendInternal(message,timeout)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "boolean",
    "signature": "public boolean sendInternal(Message<?> message, long timeout)",
    "source_code": "\tpublic boolean sendInternal(Message<?> message, long timeout) {\n\t\tfor (MessageHandler handler : getSubscribers()) {\n\t\t\tSendTask sendTask = new SendTask(message, handler);\n\t\t\tif (this.executor == null) {\n\t\t\t\tsendTask.run();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.executor.execute(sendTask);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.messaging.support.ExecutorSubscribableChannel#setInterceptors(interceptors)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "interceptors"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "void",
    "signature": "public void setInterceptors(List<ChannelInterceptor> interceptors)",
    "source_code": "\tpublic void setInterceptors(List<ChannelInterceptor> interceptors) {\n\t\tsuper.setInterceptors(interceptors);\n\t\tthis.executorInterceptors.clear();\n\t\tinterceptors.forEach(this::updateExecutorInterceptorsFor);\n\t}"
  },
  "org.springframework.messaging.support.logger": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.orm.ObjectOptimisticLockingFailureException": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Exception thrown on an optimistic locking violation for a mapped object.\n * Provides information about the persistent class and the identifier.\n *\n * @author Juergen Hoeller\n * @since 13.10.2003\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 30
    },
    "signature": "public class ObjectOptimisticLockingFailureException",
    "source_code": "public class ObjectOptimisticLockingFailureException extends OptimisticLockingFailureException {\n\n\t@Nullable\n\tprivate final Object persistentClass;\n\n\t@Nullable\n\tprivate final Object identifier;\n\n\n\t/**\n\t * Create a general ObjectOptimisticLockingFailureException with the given message,\n\t * without any information on the affected object.\n\t * @param msg the detail message\n\t * @param cause the source exception\n\t */\n\tpublic ObjectOptimisticLockingFailureException(String msg, Throwable cause) {\n\t\tsuper(msg, cause);\n\t\tthis.persistentClass = null;\n\t\tthis.identifier = null;\n\t}\n\n\t/**\n\t * Create a new ObjectOptimisticLockingFailureException for the given object,\n\t * with the default \"optimistic locking failed\" message.\n\t * @param persistentClass the persistent class\n\t * @param identifier the ID of the object for which the locking failed\n\t */\n\tpublic ObjectOptimisticLockingFailureException(Class<?> persistentClass, Object identifier) {\n\t\tthis(persistentClass, identifier, null);\n\t}\n\n\t/**\n\t * Create a new ObjectOptimisticLockingFailureException for the given object,\n\t * with the default \"optimistic locking failed\" message.\n\t * @param persistentClass the persistent class\n\t * @param identifier the ID of the object for which the locking failed\n\t * @param cause the source exception\n\t */\n\tpublic ObjectOptimisticLockingFailureException(\n\t\t\tClass<?> persistentClass, Object identifier, @Nullable Throwable cause) {\n\n\t\tthis(persistentClass, identifier,\n\t\t\t\t\"Object of class [\" + persistentClass.getName() + \"] with identifier [\" + identifier +\n\t\t\t\t\"]: optimistic locking failed\", cause);\n\t}\n\n\t/**\n\t * Create a new ObjectOptimisticLockingFailureException for the given object,\n\t * with the given explicit message.\n\t * @param persistentClass the persistent class\n\t * @param identifier the ID of the object for which the locking failed\n\t * @param msg the detail message\n\t * @param cause the source exception\n\t */\n\tpublic ObjectOptimisticLockingFailureException(\n\t\t\tClass<?> persistentClass, @Nullable Object identifier, String msg, @Nullable Throwable cause) {\n\n\t\tsuper(msg, cause);\n\t\tthis.persistentClass = persistentClass;\n\t\tthis.identifier = identifier;\n\t}\n\n\t/**\n\t * Create a new ObjectOptimisticLockingFailureException for the given object,\n\t * with the default \"optimistic locking failed\" message.\n\t * @param persistentClassName the name of the persistent class\n\t * @param identifier the ID of the object for which the locking failed\n\t */\n\tpublic ObjectOptimisticLockingFailureException(String persistentClassName, Object identifier) {\n\t\tthis(persistentClassName, identifier, null);\n\t}\n\n\t/**\n\t * Create a new ObjectOptimisticLockingFailureException for the given object,\n\t * with the default \"optimistic locking failed\" message.\n\t * @param persistentClassName the name of the persistent class\n\t * @param identifier the ID of the object for which the locking failed\n\t * @param cause the source exception\n\t */\n\tpublic ObjectOptimisticLockingFailureException(\n\t\t\tString persistentClassName, Object identifier, @Nullable Throwable cause) {\n\n\t\tthis(persistentClassName, identifier,\n\t\t\t\t\"Object of class [\" + persistentClassName + \"] with identifier [\" + identifier +\n\t\t\t\t\"]: optimistic locking failed\", cause);\n\t}\n\n\t/**\n\t * Create a new ObjectOptimisticLockingFailureException for the given object,\n\t * with the given explicit message.\n\t * @param persistentClassName the name of the persistent class\n\t * @param identifier the ID of the object for which the locking failed\n\t * @param msg the detail message\n\t * @param cause the source exception\n\t */\n\tpublic ObjectOptimisticLockingFailureException(\n\t\t\tString persistentClassName, @Nullable Object identifier, String msg, @Nullable Throwable cause) {\n\n\t\tsuper(msg, cause);\n\t\tthis.persistentClass = persistentClassName;\n\t\tthis.identifier = identifier;\n\t}\n\n\n\t/**\n\t * Return the persistent class of the object for which the locking failed.\n\t * If no Class was specified, this method returns null.\n\t */\n\t@Nullable\n\tpublic Class<?> getPersistentClass() {\n\t\treturn (this.persistentClass instanceof Class<?> clazz ? clazz : null);\n\t}\n\n\t/**\n\t * Return the name of the persistent class of the object for which the locking failed.\n\t * Will work for both Class objects and String names.\n\t */\n\t@Nullable\n\tpublic String getPersistentClassName() {\n\t\tif (this.persistentClass instanceof Class<?> clazz) {\n\t\t\treturn clazz.getName();\n\t\t}\n\t\treturn (this.persistentClass != null ? this.persistentClass.toString() : null);\n\t}\n\n\t/**\n\t * Return the identifier of the object for which the locking failed.\n\t */\n\t@Nullable\n\tpublic Object getIdentifier() {\n\t\treturn this.identifier;\n\t}\n\n}"
  },
  "org.springframework.orm.ObjectOptimisticLockingFailureException#getIdentifier()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the identifier of the object for which the locking failed.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "Object",
    "signature": "public Object getIdentifier()",
    "source_code": "\tpublic Object getIdentifier() {\n\t\treturn this.identifier;\n\t}"
  },
  "org.springframework.orm.ObjectOptimisticLockingFailureException#getPersistentClassName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the name of the persistent class of the object for which the locking failed.\n\t * Will work for both Class objects and String names.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "String",
    "signature": "public String getPersistentClassName()",
    "source_code": "\tpublic String getPersistentClassName() {\n\t\tif (this.persistentClass instanceof Class<?> clazz) {\n\t\t\treturn clazz.getName();\n\t\t}\n\t\treturn (this.persistentClass != null ? this.persistentClass.toString() : null);\n\t}"
  },
  "org.springframework.orm.ObjectRetrievalFailureException": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Exception thrown if a mapped object could not be retrieved via its identifier.\n * Provides information about the persistent class and the identifier.\n *\n * @author Juergen Hoeller\n * @since 13.10.2003\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 30
    },
    "signature": "public class ObjectRetrievalFailureException",
    "source_code": "public class ObjectRetrievalFailureException extends DataRetrievalFailureException {\n\n\t@Nullable\n\tprivate final Object persistentClass;\n\n\t@Nullable\n\tprivate final Object identifier;\n\n\n\t/**\n\t * Create a general ObjectRetrievalFailureException with the given message,\n\t * without any information on the affected object.\n\t * @param msg the detail message\n\t * @param cause the source exception\n\t */\n\tpublic ObjectRetrievalFailureException(String msg, Throwable cause) {\n\t\tsuper(msg, cause);\n\t\tthis.persistentClass = null;\n\t\tthis.identifier = null;\n\t}\n\n\t/**\n\t * Create a new ObjectRetrievalFailureException for the given object,\n\t * with the default \"not found\" message.\n\t * @param persistentClass the persistent class\n\t * @param identifier the ID of the object that should have been retrieved\n\t */\n\tpublic ObjectRetrievalFailureException(Class<?> persistentClass, Object identifier) {\n\t\tthis(persistentClass, identifier,\n\t\t\t\t\"Object of class [\" + persistentClass.getName() + \"] with identifier [\" + identifier + \"]: not found\",\n\t\t\t\tnull);\n\t}\n\n\t/**\n\t * Create a new ObjectRetrievalFailureException for the given object,\n\t * with the given explicit message and exception.\n\t * @param persistentClass the persistent class\n\t * @param identifier the ID of the object that should have been retrieved\n\t * @param msg the detail message\n\t * @param cause the source exception\n\t */\n\tpublic ObjectRetrievalFailureException(\n\t\t\tClass<?> persistentClass, @Nullable Object identifier, String msg, @Nullable Throwable cause) {\n\n\t\tsuper(msg, cause);\n\t\tthis.persistentClass = persistentClass;\n\t\tthis.identifier = identifier;\n\t}\n\n\t/**\n\t * Create a new ObjectRetrievalFailureException for the given object,\n\t * with the default \"not found\" message.\n\t * @param persistentClassName the name of the persistent class\n\t * @param identifier the ID of the object that should have been retrieved\n\t */\n\tpublic ObjectRetrievalFailureException(String persistentClassName, Object identifier) {\n\t\tthis(persistentClassName, identifier,\n\t\t\t\t\"Object of class [\" + persistentClassName + \"] with identifier [\" + identifier + \"]: not found\",\n\t\t\t\tnull);\n\t}\n\n\t/**\n\t * Create a new ObjectRetrievalFailureException for the given object,\n\t * with the given explicit message and exception.\n\t * @param persistentClassName the name of the persistent class\n\t * @param identifier the ID of the object that should have been retrieved\n\t * @param msg the detail message\n\t * @param cause the source exception\n\t */\n\tpublic ObjectRetrievalFailureException(\n\t\t\tString persistentClassName, @Nullable Object identifier, String msg, @Nullable Throwable cause) {\n\n\t\tsuper(msg, cause);\n\t\tthis.persistentClass = persistentClassName;\n\t\tthis.identifier = identifier;\n\t}\n\n\n\t/**\n\t * Return the persistent class of the object that was not found.\n\t * If no Class was specified, this method returns null.\n\t */\n\t@Nullable\n\tpublic Class<?> getPersistentClass() {\n\t\treturn (this.persistentClass instanceof Class<?> clazz ? clazz : null);\n\t}\n\n\t/**\n\t * Return the name of the persistent class of the object that was not found.\n\t * Will work for both Class objects and String names.\n\t */\n\t@Nullable\n\tpublic String getPersistentClassName() {\n\t\tif (this.persistentClass instanceof Class<?> clazz) {\n\t\t\treturn clazz.getName();\n\t\t}\n\t\treturn (this.persistentClass != null ? this.persistentClass.toString() : null);\n\t}\n\n\t/**\n\t * Return the identifier of the object that was not found.\n\t */\n\t@Nullable\n\tpublic Object getIdentifier() {\n\t\treturn this.identifier;\n\t}\n\n}"
  },
  "org.springframework.orm.ObjectRetrievalFailureException#getIdentifier()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the identifier of the object that was not found.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "Object",
    "signature": "public Object getIdentifier()",
    "source_code": "\tpublic Object getIdentifier() {\n\t\treturn this.identifier;\n\t}"
  },
  "org.springframework.orm.ObjectRetrievalFailureException#getPersistentClassName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the name of the persistent class of the object that was not found.\n\t * Will work for both Class objects and String names.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "String",
    "signature": "public String getPersistentClassName()",
    "source_code": "\tpublic String getPersistentClassName() {\n\t\tif (this.persistentClass instanceof Class<?> clazz) {\n\t\t\treturn clazz.getName();\n\t\t}\n\t\treturn (this.persistentClass != null ? this.persistentClass.toString() : null);\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Helper class that simplifies Hibernate data access code. Automatically\n * converts HibernateExceptions into DataAccessExceptions, following the\n * {@code org.springframework.dao} exception hierarchy.\n *\n * <p>The central method is {@code execute}, supporting Hibernate access code\n * implementing the {@link HibernateCallback} interface. It provides Hibernate Session\n * handling such that neither the HibernateCallback implementation nor the calling\n * code needs to explicitly care about retrieving/closing Hibernate Sessions,\n * or handling Session lifecycle exceptions. For typical single step actions,\n * there are various convenience methods (find, load, saveOrUpdate, delete).\n *\n * <p>Can be used within a service implementation via direct instantiation\n * with a SessionFactory reference, or get prepared in an application context\n * and given to services as bean reference. Note: The SessionFactory should\n * always be configured as bean in the application context, in the first case\n * given to the service directly, in the second case to the prepared template.\n *\n * <p><b>NOTE: Hibernate access code can also be coded against the native Hibernate\n * {@link Session}. Hence, for newly started projects, consider adopting the standard\n * Hibernate style of coding against {@link SessionFactory#getCurrentSession()}.\n * Alternatively, use {@link #execute(HibernateCallback)} with Java 8 lambda code blocks\n * against the callback-provided {@code Session} which results in elegant code as well,\n * decoupled from the Hibernate Session lifecycle. The remaining operations on this\n * HibernateTemplate are deprecated in the meantime and primarily exist as a migration\n * helper for older Hibernate 3.x/4.x data access code in existing applications.</b>\n *\n * @author Juergen Hoeller\n * @since 4.2\n * @see #setSessionFactory\n * @see HibernateCallback\n * @see Session\n * @see LocalSessionFactoryBean\n * @see HibernateTransactionManager\n * @see org.springframework.orm.hibernate5.support.OpenSessionInViewFilter\n * @see org.springframework.orm.hibernate5.support.OpenSessionInViewInterceptor\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "signature": "public class HibernateTemplate",
    "source_code": "public class HibernateTemplate implements HibernateOperations, InitializingBean {\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\t@Nullable\n\tprivate SessionFactory sessionFactory;\n\n\t@Nullable\n\tprivate String[] filterNames;\n\n\tprivate boolean exposeNativeSession = false;\n\n\tprivate boolean checkWriteOperations = true;\n\n\tprivate boolean cacheQueries = false;\n\n\t@Nullable\n\tprivate String queryCacheRegion;\n\n\tprivate int fetchSize = 0;\n\n\tprivate int maxResults = 0;\n\n\n\t/**\n\t * Create a new HibernateTemplate instance.\n\t */\n\tpublic HibernateTemplate() {\n\t}\n\n\t/**\n\t * Create a new HibernateTemplate instance.\n\t * @param sessionFactory the SessionFactory to create Sessions with\n\t */\n\tpublic HibernateTemplate(SessionFactory sessionFactory) {\n\t\tsetSessionFactory(sessionFactory);\n\t\tafterPropertiesSet();\n\t}\n\n\n\t/**\n\t * Set the Hibernate SessionFactory that should be used to create\n\t * Hibernate Sessions.\n\t */\n\tpublic void setSessionFactory(@Nullable SessionFactory sessionFactory) {\n\t\tthis.sessionFactory = sessionFactory;\n\t}\n\n\t/**\n\t * Return the Hibernate SessionFactory that should be used to create\n\t * Hibernate Sessions.\n\t */\n\t@Nullable\n\tpublic SessionFactory getSessionFactory() {\n\t\treturn this.sessionFactory;\n\t}\n\n\t/**\n\t * Obtain the SessionFactory for actual use.\n\t * @return the SessionFactory (never {@code null})\n\t * @throws IllegalStateException in case of no SessionFactory set\n\t * @since 5.0\n\t */\n\tprotected final SessionFactory obtainSessionFactory() {\n\t\tSessionFactory sessionFactory = getSessionFactory();\n\t\tAssert.state(sessionFactory != null, \"No SessionFactory set\");\n\t\treturn sessionFactory;\n\t}\n\n\t/**\n\t * Set one or more names of Hibernate filters to be activated for all\n\t * Sessions that this accessor works with.\n\t * <p>Each of those filters will be enabled at the beginning of each\n\t * operation and correspondingly disabled at the end of the operation.\n\t * This will work for newly opened Sessions as well as for existing\n\t * Sessions (for example, within a transaction).\n\t * @see #enableFilters(Session)\n\t * @see Session#enableFilter(String)\n\t */\n\tpublic void setFilterNames(@Nullable String... filterNames) {\n\t\tthis.filterNames = filterNames;\n\t}\n\n\t/**\n\t * Return the names of Hibernate filters to be activated, if any.\n\t */\n\t@Nullable\n\tpublic String[] getFilterNames() {\n\t\treturn this.filterNames;\n\t}\n\n\t/**\n\t * Set whether to expose the native Hibernate Session to\n\t * HibernateCallback code.\n\t * <p>Default is \"false\": a Session proxy will be returned, suppressing\n\t * {@code close} calls and automatically applying query cache\n\t * settings and transaction timeouts.\n\t * @see HibernateCallback\n\t * @see Session\n\t * @see #setCacheQueries\n\t * @see #setQueryCacheRegion\n\t * @see #prepareQuery\n\t * @see #prepareCriteria\n\t */\n\tpublic void setExposeNativeSession(boolean exposeNativeSession) {\n\t\tthis.exposeNativeSession = exposeNativeSession;\n\t}\n\n\t/**\n\t * Return whether to expose the native Hibernate Session to\n\t * HibernateCallback code, or rather a Session proxy.\n\t */\n\tpublic boolean isExposeNativeSession() {\n\t\treturn this.exposeNativeSession;\n\t}\n\n\t/**\n\t * Set whether to check that the Hibernate Session is not in read-only mode\n\t * in case of write operations (save/update/delete).\n\t * <p>Default is \"true\", for fail-fast behavior when attempting write operations\n\t * within a read-only transaction. Turn this off to allow save/update/delete\n\t * on a Session with flush mode MANUAL.\n\t * @see #checkWriteOperationAllowed\n\t * @see org.springframework.transaction.TransactionDefinition#isReadOnly\n\t */\n\tpublic void setCheckWriteOperations(boolean checkWriteOperations) {\n\t\tthis.checkWriteOperations = checkWriteOperations;\n\t}\n\n\t/**\n\t * Return whether to check that the Hibernate Session is not in read-only\n\t * mode in case of write operations (save/update/delete).\n\t */\n\tpublic boolean isCheckWriteOperations() {\n\t\treturn this.checkWriteOperations;\n\t}\n\n\t/**\n\t * Set whether to cache all queries executed by this template.\n\t * <p>If this is \"true\", all Query and Criteria objects created by\n\t * this template will be marked as cacheable (including all\n\t * queries through find methods).\n\t * <p>To specify the query region to be used for queries cached\n\t * by this template, set the \"queryCacheRegion\" property.\n\t * @see #setQueryCacheRegion\n\t * @see Query#setCacheable\n\t * @see Criteria#setCacheable\n\t */\n\tpublic void setCacheQueries(boolean cacheQueries) {\n\t\tthis.cacheQueries = cacheQueries;\n\t}\n\n\t/**\n\t * Return whether to cache all queries executed by this template.\n\t */\n\tpublic boolean isCacheQueries() {\n\t\treturn this.cacheQueries;\n\t}\n\n\t/**\n\t * Set the name of the cache region for queries executed by this template.\n\t * <p>If this is specified, it will be applied to all Query and Criteria objects\n\t * created by this template (including all queries through find methods).\n\t * <p>The cache region will not take effect unless queries created by this\n\t * template are configured to be cached via the \"cacheQueries\" property.\n\t * @see #setCacheQueries\n\t * @see Query#setCacheRegion\n\t * @see Criteria#setCacheRegion\n\t */\n\tpublic void setQueryCacheRegion(@Nullable String queryCacheRegion) {\n\t\tthis.queryCacheRegion = queryCacheRegion;\n\t}\n\n\t/**\n\t * Return the name of the cache region for queries executed by this template.\n\t */\n\t@Nullable\n\tpublic String getQueryCacheRegion() {\n\t\treturn this.queryCacheRegion;\n\t}\n\n\t/**\n\t * Set the fetch size for this HibernateTemplate. This is important for processing\n\t * large result sets: Setting this higher than the default value will increase\n\t * processing speed at the cost of memory consumption; setting this lower can\n\t * avoid transferring row data that will never be read by the application.\n\t * <p>Default is 0, indicating to use the JDBC driver's default.\n\t */\n\tpublic void setFetchSize(int fetchSize) {\n\t\tthis.fetchSize = fetchSize;\n\t}\n\n\t/**\n\t * Return the fetch size specified for this HibernateTemplate.\n\t */\n\tpublic int getFetchSize() {\n\t\treturn this.fetchSize;\n\t}\n\n\t/**\n\t * Set the maximum number of rows for this HibernateTemplate. This is important\n\t * for processing subsets of large result sets, avoiding to read and hold\n\t * the entire result set in the database or in the JDBC driver if we're\n\t * never interested in the entire result in the first place (for example,\n\t * when performing searches that might return a large number of matches).\n\t * <p>Default is 0, indicating to use the JDBC driver's default.\n\t */\n\tpublic void setMaxResults(int maxResults) {\n\t\tthis.maxResults = maxResults;\n\t}\n\n\t/**\n\t * Return the maximum number of rows specified for this HibernateTemplate.\n\t */\n\tpublic int getMaxResults() {\n\t\treturn this.maxResults;\n\t}\n\n\t@Override\n\tpublic void afterPropertiesSet() {\n\t\tif (getSessionFactory() == null) {\n\t\t\tthrow new IllegalArgumentException(\"Property 'sessionFactory' is required\");\n\t\t}\n\t}\n\n\n\t@Override\n\t@Nullable\n\tpublic <T> T execute(HibernateCallback<T> action) throws DataAccessException {\n\t\treturn doExecute(action, false);\n\t}\n\n\t/**\n\t * Execute the action specified by the given action object within a\n\t * native {@link Session}.\n\t * <p>This execute variant overrides the template-wide\n\t * {@link #isExposeNativeSession() \"exposeNativeSession\"} setting.\n\t * @param action callback object that specifies the Hibernate action\n\t * @return a result object returned by the action, or {@code null}\n\t * @throws DataAccessException in case of Hibernate errors\n\t */\n\t@Nullable\n\tpublic <T> T executeWithNativeSession(HibernateCallback<T> action) {\n\t\treturn doExecute(action, true);\n\t}\n\n\t/**\n\t * Execute the action specified by the given action object within a Session.\n\t * @param action callback object that specifies the Hibernate action\n\t * @param enforceNativeSession whether to enforce exposure of the native\n\t * Hibernate Session to callback code\n\t * @return a result object returned by the action, or {@code null}\n\t * @throws DataAccessException in case of Hibernate errors\n\t */\n\t@Nullable\n\tprotected <T> T doExecute(HibernateCallback<T> action, boolean enforceNativeSession) throws DataAccessException {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\n\t\tSession session = null;\n\t\tboolean isNew = false;\n\t\ttry {\n\t\t\tsession = obtainSessionFactory().getCurrentSession();\n\t\t}\n\t\tcatch (HibernateException ex) {\n\t\t\tlogger.debug(\"Could not retrieve pre-bound Hibernate session\", ex);\n\t\t}\n\t\tif (session == null) {\n\t\t\tsession = obtainSessionFactory().openSession();\n\t\t\tsession.setHibernateFlushMode(FlushMode.MANUAL);\n\t\t\tisNew = true;\n\t\t}\n\n\t\ttry {\n\t\t\tenableFilters(session);\n\t\t\tSession sessionToExpose =\n\t\t\t\t\t(enforceNativeSession || isExposeNativeSession() ? session : createSessionProxy(session));\n\t\t\treturn action.doInHibernate(sessionToExpose);\n\t\t}\n\t\tcatch (HibernateException ex) {\n\t\t\tthrow SessionFactoryUtils.convertHibernateAccessException(ex);\n\t\t}\n\t\tcatch (PersistenceException ex) {\n\t\t\tif (ex.getCause() instanceof HibernateException hibernateEx) {\n\t\t\t\tthrow SessionFactoryUtils.convertHibernateAccessException(hibernateEx);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\t// Callback code threw application exception...\n\t\t\tthrow ex;\n\t\t}\n\t\tfinally {\n\t\t\tif (isNew) {\n\t\t\t\tSessionFactoryUtils.closeSession(session);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdisableFilters(session);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Create a close-suppressing proxy for the given Hibernate Session.\n\t * The proxy also prepares returned Query and Criteria objects.\n\t * @param session the Hibernate Session to create a proxy for\n\t * @return the Session proxy\n\t * @see Session#close()\n\t * @see #prepareQuery\n\t * @see #prepareCriteria\n\t */\n\tprotected Session createSessionProxy(Session session) {\n\t\treturn (Session) Proxy.newProxyInstance(\n\t\t\t\tsession.getClass().getClassLoader(), new Class<?>[] {Session.class},\n\t\t\t\tnew CloseSuppressingInvocationHandler(session));\n\t}\n\n\t/**\n\t * Enable the specified filters on the given Session.\n\t * @param session the current Hibernate Session\n\t * @see #setFilterNames\n\t * @see Session#enableFilter(String)\n\t */\n\tprotected void enableFilters(Session session) {\n\t\tString[] filterNames = getFilterNames();\n\t\tif (filterNames != null) {\n\t\t\tfor (String filterName : filterNames) {\n\t\t\t\tsession.enableFilter(filterName);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Disable the specified filters on the given Session.\n\t * @param session the current Hibernate Session\n\t * @see #setFilterNames\n\t * @see Session#disableFilter(String)\n\t */\n\tprotected void disableFilters(Session session) {\n\t\tString[] filterNames = getFilterNames();\n\t\tif (filterNames != null) {\n\t\t\tfor (String filterName : filterNames) {\n\t\t\t\tsession.disableFilter(filterName);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t//-------------------------------------------------------------------------\n\t// Convenience methods for loading individual objects\n\t//-------------------------------------------------------------------------\n\n\t@Override\n\t@Nullable\n\tpublic <T> T get(Class<T> entityClass, Serializable id) throws DataAccessException {\n\t\treturn get(entityClass, id, null);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic <T> T get(Class<T> entityClass, Serializable id, @Nullable LockMode lockMode) throws DataAccessException {\n\t\treturn executeWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\treturn session.get(entityClass, id, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn session.get(entityClass, id);\n\t\t\t}\n\t\t});\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Object get(String entityName, Serializable id) throws DataAccessException {\n\t\treturn get(entityName, id, null);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Object get(String entityName, Serializable id, @Nullable LockMode lockMode) throws DataAccessException {\n\t\treturn executeWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\treturn session.get(entityName, id, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn session.get(entityName, id);\n\t\t\t}\n\t\t});\n\t}\n\n\t@Override\n\tpublic <T> T load(Class<T> entityClass, Serializable id) throws DataAccessException {\n\t\treturn load(entityClass, id, null);\n\t}\n\n\t@Override\n\tpublic <T> T load(Class<T> entityClass, Serializable id, @Nullable LockMode lockMode)\n\t\t\tthrows DataAccessException {\n\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\treturn session.load(entityClass, id, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn session.load(entityClass, id);\n\t\t\t}\n\t\t}));\n\t}\n\n\t@Override\n\tpublic Object load(String entityName, Serializable id) throws DataAccessException {\n\t\treturn load(entityName, id, null);\n\t}\n\n\t@Override\n\tpublic Object load(String entityName, Serializable id, @Nullable LockMode lockMode) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\treturn session.load(entityName, id, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn session.load(entityName, id);\n\t\t\t}\n\t\t}));\n\t}\n\n\t@Override\n\t@SuppressWarnings({\"unchecked\", \"deprecation\"})\n\tpublic <T> List<T> loadAll(Class<T> entityClass) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession((HibernateCallback<List<T>>) session -> {\n\t\t\tCriteria criteria = session.createCriteria(entityClass);\n\t\t\tcriteria.setResultTransformer(Criteria.DISTINCT_ROOT_ENTITY);\n\t\t\tprepareCriteria(criteria);\n\t\t\treturn criteria.list();\n\t\t}));\n\t}\n\n\t@Override\n\tpublic void load(Object entity, Serializable id) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tsession.load(entity, id);\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\tpublic void refresh(Object entity) throws DataAccessException {\n\t\trefresh(entity, null);\n\t}\n\n\t@Override\n\tpublic void refresh(Object entity, @Nullable LockMode lockMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.refresh(entity, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsession.refresh(entity);\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\tpublic boolean contains(Object entity) throws DataAccessException {\n\t\tBoolean result = executeWithNativeSession(session -> session.contains(entity));\n\t\tAssert.state(result != null, \"No contains result\");\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic void evict(Object entity) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tsession.evict(entity);\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\tpublic void initialize(Object proxy) throws DataAccessException {\n\t\ttry {\n\t\t\tHibernate.initialize(proxy);\n\t\t}\n\t\tcatch (HibernateException ex) {\n\t\t\tthrow SessionFactoryUtils.convertHibernateAccessException(ex);\n\t\t}\n\t}\n\n\t@Override\n\tpublic Filter enableFilter(String filterName) throws IllegalStateException {\n\t\tSession session = obtainSessionFactory().getCurrentSession();\n\t\tFilter filter = session.getEnabledFilter(filterName);\n\t\tif (filter == null) {\n\t\t\tfilter = session.enableFilter(filterName);\n\t\t}\n\t\treturn filter;\n\t}\n\n\n\t//-------------------------------------------------------------------------\n\t// Convenience methods for storing individual objects\n\t//-------------------------------------------------------------------------\n\n\t@Override\n\tpublic void lock(Object entity, LockMode lockMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entity);\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\tpublic void lock(String entityName, Object entity, LockMode lockMode)\n\t\t\tthrows DataAccessException {\n\n\t\texecuteWithNativeSession(session -> {\n\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entityName, entity);\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\tpublic Serializable save(Object entity) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\treturn session.save(entity);\n\t\t}));\n\t}\n\n\t@Override\n\tpublic Serializable save(String entityName, Object entity) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\treturn session.save(entityName, entity);\n\t\t}));\n\t}\n\n\t@Override\n\tpublic void update(Object entity) throws DataAccessException {\n\t\tupdate(entity, null);\n\t}\n\n\t@Override\n\tpublic void update(Object entity, @Nullable LockMode lockMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.update(entity);\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entity);\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\tpublic void update(String entityName, Object entity) throws DataAccessException {\n\t\tupdate(entityName, entity, null);\n\t}\n\n\t@Override\n\tpublic void update(String entityName, Object entity, @Nullable LockMode lockMode)\n\t\t\tthrows DataAccessException {\n\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.update(entityName, entity);\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entityName, entity);\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\tpublic void saveOrUpdate(Object entity) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.saveOrUpdate(entity);\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\tpublic void saveOrUpdate(String entityName, Object entity) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.saveOrUpdate(entityName, entity);\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\tpublic void replicate(Object entity, ReplicationMode replicationMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.replicate(entity, replicationMode);\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\tpublic void replicate(String entityName, Object entity, ReplicationMode replicationMode)\n\t\t\tthrows DataAccessException {\n\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.replicate(entityName, entity, replicationMode);\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\tpublic void persist(Object entity) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.persist(entity);\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\tpublic void persist(String entityName, Object entity) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.persist(entityName, entity);\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> T merge(T entity) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\treturn (T) session.merge(entity);\n\t\t}));\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> T merge(String entityName, T entity) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\treturn (T) session.merge(entityName, entity);\n\t\t}));\n\t}\n\n\t@Override\n\tpublic void delete(Object entity) throws DataAccessException {\n\t\tdelete(entity, null);\n\t}\n\n\t@Override\n\tpublic void delete(Object entity, @Nullable LockMode lockMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entity);\n\t\t\t}\n\t\t\tsession.delete(entity);\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\tpublic void delete(String entityName, Object entity) throws DataAccessException {\n\t\tdelete(entityName, entity, null);\n\t}\n\n\t@Override\n\tpublic void delete(String entityName, Object entity, @Nullable LockMode lockMode)\n\t\t\tthrows DataAccessException {\n\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entityName, entity);\n\t\t\t}\n\t\t\tsession.delete(entityName, entity);\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\tpublic void deleteAll(Collection<?> entities) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tfor (Object entity : entities) {\n\t\t\t\tsession.delete(entity);\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\tpublic void flush() throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tsession.flush();\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\tpublic void clear() throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tsession.clear();\n\t\t\treturn null;\n\t\t});\n\t}\n\n\n\t//-------------------------------------------------------------------------\n\t// Convenience finder methods for detached criteria\n\t//-------------------------------------------------------------------------\n\n\t@Override\n\tpublic List<?> findByCriteria(DetachedCriteria criteria) throws DataAccessException {\n\t\treturn findByCriteria(criteria, -1, -1);\n\t}\n\n\t@Override\n\tpublic List<?> findByCriteria(DetachedCriteria criteria, int firstResult, int maxResults)\n\t\t\tthrows DataAccessException {\n\n\t\tAssert.notNull(criteria, \"DetachedCriteria must not be null\");\n\t\treturn nonNull(executeWithNativeSession((HibernateCallback<List<?>>) session -> {\n\t\t\tCriteria executableCriteria = criteria.getExecutableCriteria(session);\n\t\t\tprepareCriteria(executableCriteria);\n\t\t\tif (firstResult >= 0) {\n\t\t\t\texecutableCriteria.setFirstResult(firstResult);\n\t\t\t}\n\t\t\tif (maxResults > 0) {\n\t\t\t\texecutableCriteria.setMaxResults(maxResults);\n\t\t\t}\n\t\t\treturn executableCriteria.list();\n\t\t}));\n\t}\n\n\t@Override\n\tpublic <T> List<T> findByExample(T exampleEntity) throws DataAccessException {\n\t\treturn findByExample(null, exampleEntity, -1, -1);\n\t}\n\n\t@Override\n\tpublic <T> List<T> findByExample(String entityName, T exampleEntity) throws DataAccessException {\n\t\treturn findByExample(entityName, exampleEntity, -1, -1);\n\t}\n\n\t@Override\n\tpublic <T> List<T> findByExample(T exampleEntity, int firstResult, int maxResults) throws DataAccessException {\n\t\treturn findByExample(null, exampleEntity, firstResult, maxResults);\n\t}\n\n\t@Override\n\t@SuppressWarnings({\"unchecked\", \"deprecation\"})\n\tpublic <T> List<T> findByExample(@Nullable String entityName, T exampleEntity, int firstResult, int maxResults)\n\t\t\tthrows DataAccessException {\n\n\t\tAssert.notNull(exampleEntity, \"Example entity must not be null\");\n\t\treturn nonNull(executeWithNativeSession((HibernateCallback<List<T>>) session -> {\n\t\t\tCriteria executableCriteria = (entityName != null ?\n\t\t\t\t\tsession.createCriteria(entityName) : session.createCriteria(exampleEntity.getClass()));\n\t\t\texecutableCriteria.add(Example.create(exampleEntity));\n\t\t\tprepareCriteria(executableCriteria);\n\t\t\tif (firstResult >= 0) {\n\t\t\t\texecutableCriteria.setFirstResult(firstResult);\n\t\t\t}\n\t\t\tif (maxResults > 0) {\n\t\t\t\texecutableCriteria.setMaxResults(maxResults);\n\t\t\t}\n\t\t\treturn executableCriteria.list();\n\t\t}));\n\t}\n\n\n\t//-------------------------------------------------------------------------\n\t// Convenience finder methods for HQL strings\n\t//-------------------------------------------------------------------------\n\n\t@Deprecated\n\t@Override\n\tpublic List<?> find(String queryString, @Nullable Object... values) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession((HibernateCallback<List<?>>) session -> {\n\t\t\tQuery<?> queryObject = session.createQuery(queryString);\n\t\t\tprepareQuery(queryObject);\n\t\t\tif (values != null) {\n\t\t\t\tfor (int i = 0; i < values.length; i++) {\n\t\t\t\t\tqueryObject.setParameter(i, values[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queryObject.list();\n\t\t}));\n\t}\n\n\t@Deprecated\n\t@Override\n\tpublic List<?> findByNamedParam(String queryString, String paramName, Object value)\n\t\t\tthrows DataAccessException {\n\n\t\treturn findByNamedParam(queryString, new String[] {paramName}, new Object[] {value});\n\t}\n\n\t@Deprecated\n\t@Override\n\tpublic List<?> findByNamedParam(String queryString, String[] paramNames, Object[] values)\n\t\t\tthrows DataAccessException {\n\n\t\tif (paramNames.length != values.length) {\n\t\t\tthrow new IllegalArgumentException(\"Length of paramNames array must match length of values array\");\n\t\t}\n\t\treturn nonNull(executeWithNativeSession((HibernateCallback<List<?>>) session -> {\n\t\t\tQuery<?> queryObject = session.createQuery(queryString);\n\t\t\tprepareQuery(queryObject);\n\t\t\tfor (int i = 0; i < values.length; i++) {\n\t\t\t\tapplyNamedParameterToQuery(queryObject, paramNames[i], values[i]);\n\t\t\t}\n\t\t\treturn queryObject.list();\n\t\t}));\n\t}\n\n\t@Deprecated\n\t@Override\n\tpublic List<?> findByValueBean(String queryString, Object valueBean) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession((HibernateCallback<List<?>>) session -> {\n\t\t\tQuery<?> queryObject = session.createQuery(queryString);\n\t\t\tprepareQuery(queryObject);\n\t\t\tqueryObject.setProperties(valueBean);\n\t\t\treturn queryObject.list();\n\t\t}));\n\t}\n\n\n\t//-------------------------------------------------------------------------\n\t// Convenience finder methods for named queries\n\t//-------------------------------------------------------------------------\n\n\t@Deprecated\n\t@Override\n\tpublic List<?> findByNamedQuery(String queryName, @Nullable Object... values) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession((HibernateCallback<List<?>>) session -> {\n\t\t\tQuery<?> queryObject = session.getNamedQuery(queryName);\n\t\t\tprepareQuery(queryObject);\n\t\t\tif (values != null) {\n\t\t\t\tfor (int i = 0; i < values.length; i++) {\n\t\t\t\t\tqueryObject.setParameter(i, values[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queryObject.list();\n\t\t}));\n\t}\n\n\t@Deprecated\n\t@Override\n\tpublic List<?> findByNamedQueryAndNamedParam(String queryName, String paramName, Object value)\n\t\t\tthrows DataAccessException {\n\n\t\treturn findByNamedQueryAndNamedParam(queryName, new String[] {paramName}, new Object[] {value});\n\t}\n\n\t@Deprecated\n\t@Override\n\tpublic List<?> findByNamedQueryAndNamedParam(\n\t\t\tString queryName, @Nullable String[] paramNames, @Nullable Object[] values)\n\t\t\tthrows DataAccessException {\n\n\t\tif (values != null && (paramNames == null || paramNames.length != values.length)) {\n\t\t\tthrow new IllegalArgumentException(\"Length of paramNames array must match length of values array\");\n\t\t}\n\t\treturn nonNull(executeWithNativeSession((HibernateCallback<List<?>>) session -> {\n\t\t\tQuery<?> queryObject = session.getNamedQuery(queryName);\n\t\t\tprepareQuery(queryObject);\n\t\t\tif (values != null) {\n\t\t\t\tfor (int i = 0; i < values.length; i++) {\n\t\t\t\t\tapplyNamedParameterToQuery(queryObject, paramNames[i], values[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queryObject.list();\n\t\t}));\n\t}\n\n\t@Deprecated\n\t@Override\n\tpublic List<?> findByNamedQueryAndValueBean(String queryName, Object valueBean) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession((HibernateCallback<List<?>>) session -> {\n\t\t\tQuery<?> queryObject = session.getNamedQuery(queryName);\n\t\t\tprepareQuery(queryObject);\n\t\t\tqueryObject.setProperties(valueBean);\n\t\t\treturn queryObject.list();\n\t\t}));\n\t}\n\n\n\t//-------------------------------------------------------------------------\n\t// Convenience query methods for iteration and bulk updates/deletes\n\t//-------------------------------------------------------------------------\n\n\t@SuppressWarnings(\"deprecation\")\n\t@Deprecated\n\t@Override\n\tpublic Iterator<?> iterate(String queryString, @Nullable Object... values) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession((HibernateCallback<Iterator<?>>) session -> {\n\t\t\tQuery<?> queryObject = session.createQuery(queryString);\n\t\t\tprepareQuery(queryObject);\n\t\t\tif (values != null) {\n\t\t\t\tfor (int i = 0; i < values.length; i++) {\n\t\t\t\t\tqueryObject.setParameter(i, values[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queryObject.iterate();\n\t\t}));\n\t}\n\n\t@Deprecated\n\t@Override\n\tpublic void closeIterator(Iterator<?> it) throws DataAccessException {\n\t\ttry {\n\t\t\tHibernate.close(it);\n\t\t}\n\t\tcatch (HibernateException ex) {\n\t\t\tthrow SessionFactoryUtils.convertHibernateAccessException(ex);\n\t\t}\n\t}\n\n\t@Deprecated\n\t@Override\n\tpublic int bulkUpdate(String queryString, @Nullable Object... values) throws DataAccessException {\n\t\tInteger result = executeWithNativeSession(session -> {\n\t\t\tQuery<?> queryObject = session.createQuery(queryString);\n\t\t\tprepareQuery(queryObject);\n\t\t\tif (values != null) {\n\t\t\t\tfor (int i = 0; i < values.length; i++) {\n\t\t\t\t\tqueryObject.setParameter(i, values[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queryObject.executeUpdate();\n\t\t});\n\t\tAssert.state(result != null, \"No update count\");\n\t\treturn result;\n\t}\n\n\n\t//-------------------------------------------------------------------------\n\t// Helper methods used by the operations above\n\t//-------------------------------------------------------------------------\n\n\t/**\n\t * Check whether write operations are allowed on the given Session.\n\t * <p>Default implementation throws an InvalidDataAccessApiUsageException in\n\t * case of {@code FlushMode.MANUAL}. Can be overridden in subclasses.\n\t * @param session current Hibernate Session\n\t * @throws InvalidDataAccessApiUsageException if write operations are not allowed\n\t * @see #setCheckWriteOperations\n\t * @see Session#getFlushMode()\n\t * @see FlushMode#MANUAL\n\t */\n\tprotected void checkWriteOperationAllowed(Session session) throws InvalidDataAccessApiUsageException {\n\t\tif (isCheckWriteOperations() && session.getHibernateFlushMode().lessThan(FlushMode.COMMIT)) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\"Write operations are not allowed in read-only mode (FlushMode.MANUAL): \"+\n\t\t\t\t\t\"Turn your Session into FlushMode.COMMIT/AUTO or remove 'readOnly' marker from transaction definition.\");\n\t\t}\n\t}\n\n\t/**\n\t * Prepare the given Criteria object, applying cache settings and/or\n\t * a transaction timeout.\n\t * @param criteria the Criteria object to prepare\n\t * @see #setCacheQueries\n\t * @see #setQueryCacheRegion\n\t */\n\tprotected void prepareCriteria(Criteria criteria) {\n\t\tif (isCacheQueries()) {\n\t\t\tcriteria.setCacheable(true);\n\t\t\tif (getQueryCacheRegion() != null) {\n\t\t\t\tcriteria.setCacheRegion(getQueryCacheRegion());\n\t\t\t}\n\t\t}\n\t\tif (getFetchSize() > 0) {\n\t\t\tcriteria.setFetchSize(getFetchSize());\n\t\t}\n\t\tif (getMaxResults() > 0) {\n\t\t\tcriteria.setMaxResults(getMaxResults());\n\t\t}\n\n\t\tResourceHolderSupport sessionHolder =\n\t\t\t\t(ResourceHolderSupport) TransactionSynchronizationManager.getResource(obtainSessionFactory());\n\t\tif (sessionHolder != null && sessionHolder.hasTimeout()) {\n\t\t\tcriteria.setTimeout(sessionHolder.getTimeToLiveInSeconds());\n\t\t}\n\t}\n\n\t/**\n\t * Prepare the given Query object, applying cache settings and/or\n\t * a transaction timeout.\n\t * @param queryObject the Query object to prepare\n\t * @see #setCacheQueries\n\t * @see #setQueryCacheRegion\n\t */\n\tprotected void prepareQuery(Query<?> queryObject) {\n\t\tif (isCacheQueries()) {\n\t\t\tqueryObject.setCacheable(true);\n\t\t\tif (getQueryCacheRegion() != null) {\n\t\t\t\tqueryObject.setCacheRegion(getQueryCacheRegion());\n\t\t\t}\n\t\t}\n\t\tif (getFetchSize() > 0) {\n\t\t\tqueryObject.setFetchSize(getFetchSize());\n\t\t}\n\t\tif (getMaxResults() > 0) {\n\t\t\tqueryObject.setMaxResults(getMaxResults());\n\t\t}\n\n\t\tResourceHolderSupport sessionHolder =\n\t\t\t\t(ResourceHolderSupport) TransactionSynchronizationManager.getResource(obtainSessionFactory());\n\t\tif (sessionHolder != null && sessionHolder.hasTimeout()) {\n\t\t\tqueryObject.setTimeout(sessionHolder.getTimeToLiveInSeconds());\n\t\t}\n\t}\n\n\t/**\n\t * Apply the given name parameter to the given Query object.\n\t * @param queryObject the Query object\n\t * @param paramName the name of the parameter\n\t * @param value the value of the parameter\n\t * @throws HibernateException if thrown by the Query object\n\t */\n\tprotected void applyNamedParameterToQuery(Query<?> queryObject, String paramName, Object value)\n\t\t\tthrows HibernateException {\n\n\t\tif (value instanceof Collection<?> collection) {\n\t\t\tqueryObject.setParameterList(paramName, collection);\n\t\t}\n\t\telse if (value instanceof Object[] array) {\n\t\t\tqueryObject.setParameterList(paramName, array);\n\t\t}\n\t\telse {\n\t\t\tqueryObject.setParameter(paramName, value);\n\t\t}\n\t}\n\n\tprivate static <T> T nonNull(@Nullable T result) {\n\t\tAssert.state(result != null, \"No result\");\n\t\treturn result;\n\t}\n\n\n\t/**\n\t * Invocation handler that suppresses close calls on Hibernate Sessions.\n\t * Also prepares returned Query and Criteria objects.\n\t * @see Session#close\n\t */\n\tprivate class CloseSuppressingInvocationHandler implements InvocationHandler {\n\n\t\tprivate final Session target;\n\n\t\tpublic CloseSuppressingInvocationHandler(Session target) {\n\t\t\tthis.target = target;\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\t// Invocation on Session interface coming in...\n\n\t\t\tswitch (method.getName()) {\n\t\t\t\tcase \"equals\":\n\t\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\t\treturn (proxy == args[0]);\n\t\t\t\tcase \"hashCode\":\n\t\t\t\t\t// Use hashCode of Session proxy.\n\t\t\t\t\treturn System.identityHashCode(proxy);\n\t\t\t\tcase \"close\":\n\t\t\t\t\t// Handle close method: suppress, not valid.\n\t\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Invoke method on target Session.\n\t\t\ttry {\n\t\t\t\tObject retVal = method.invoke(this.target, args);\n\n\t\t\t\t// If return value is a Query or Criteria, apply transaction timeout.\n\t\t\t\t// Applies to createQuery, getNamedQuery, createCriteria.\n\t\t\t\tif (retVal instanceof Criteria criteria) {\n\t\t\t\t\tprepareCriteria(criteria);\n\t\t\t\t}\n\t\t\t\telse if (retVal instanceof Query<?> query) {\n\t\t\t\t\tprepareQuery(query);\n\t\t\t\t}\n\n\t\t\t\treturn retVal;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow ex.getTargetException();\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tif (getSessionFactory() == null) {\n\t\t\tthrow new IllegalArgumentException(\"Property 'sessionFactory' is required\");\n\t\t}\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#applyNamedParameterToQuery(queryObject,paramName,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the given name parameter to the given Query object.\n\t * @param queryObject the Query object\n\t * @param paramName the name of the parameter\n\t * @param value the value of the parameter\n\t * @throws HibernateException if thrown by the Query object\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "queryObject",
      "paramName",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 1115
    },
    "return": "void",
    "signature": "protected void applyNamedParameterToQuery(Query<?> queryObject, String paramName, Object value)",
    "source_code": "\tprotected void applyNamedParameterToQuery(Query<?> queryObject, String paramName, Object value)"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#bulkUpdate(queryString,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queryString",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 1014
    },
    "return": "int",
    "signature": "public int bulkUpdate(String queryString, @Nullable Object... values)",
    "source_code": "\tpublic int bulkUpdate(String queryString, @Nullable Object... values) throws DataAccessException {\n\t\tInteger result = executeWithNativeSession(session -> {\n\t\t\tQuery<?> queryObject = session.createQuery(queryString);\n\t\t\tprepareQuery(queryObject);\n\t\t\tif (values != null) {\n\t\t\t\tfor (int i = 0; i < values.length; i++) {\n\t\t\t\t\tqueryObject.setParameter(i, values[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queryObject.executeUpdate();\n\t\t});\n\t\tAssert.state(result != null, \"No update count\");\n\t\treturn result;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#checkWriteOperationAllowed(session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether write operations are allowed on the given Session.\n\t * <p>Default implementation throws an InvalidDataAccessApiUsageException in\n\t * case of {@code FlushMode.MANUAL}. Can be overridden in subclasses.\n\t * @param session current Hibernate Session\n\t * @throws InvalidDataAccessApiUsageException if write operations are not allowed\n\t * @see #setCheckWriteOperations\n\t * @see Session#getFlushMode()\n\t * @see FlushMode#MANUAL\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 1044
    },
    "return": "void",
    "signature": "protected void checkWriteOperationAllowed(Session session)",
    "source_code": "\tprotected void checkWriteOperationAllowed(Session session) throws InvalidDataAccessApiUsageException {\n\t\tif (isCheckWriteOperations() && session.getHibernateFlushMode().lessThan(FlushMode.COMMIT)) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\"Write operations are not allowed in read-only mode (FlushMode.MANUAL): \"+\n\t\t\t\t\t\"Turn your Session into FlushMode.COMMIT/AUTO or remove 'readOnly' marker from transaction definition.\");\n\t\t}\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#clear()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 792
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\tpublic void clear() throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tsession.clear();\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#closeIterator(it)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "it"
    ],
    "position": {
      "column": 1,
      "line": 1003
    },
    "return": "void",
    "signature": "public void closeIterator(Iterator<?> it)",
    "source_code": "\tpublic void closeIterator(Iterator<?> it) throws DataAccessException {\n\t\ttry {\n\t\t\tHibernate.close(it);\n\t\t}\n\t\tcatch (HibernateException ex) {\n\t\t\tthrow SessionFactoryUtils.convertHibernateAccessException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#contains(entity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 553
    },
    "return": "boolean",
    "signature": "public boolean contains(Object entity)",
    "source_code": "\tpublic boolean contains(Object entity) throws DataAccessException {\n\t\tBoolean result = executeWithNativeSession(session -> session.contains(entity));\n\t\tAssert.state(result != null, \"No contains result\");\n\t\treturn result;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#createSessionProxy(session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a close-suppressing proxy for the given Hibernate Session.\n\t * The proxy also prepares returned Query and Criteria objects.\n\t * @param session the Hibernate Session to create a proxy for\n\t * @return the Session proxy\n\t * @see Session#close()\n\t * @see #prepareQuery\n\t * @see #prepareCriteria\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 400
    },
    "return": "Session",
    "signature": "protected Session createSessionProxy(Session session)",
    "source_code": "\tprotected Session createSessionProxy(Session session) {\n\t\treturn (Session) Proxy.newProxyInstance(\n\t\t\t\tsession.getClass().getClassLoader(), new Class<?>[] {Session.class},\n\t\t\t\tnew CloseSuppressingInvocationHandler(session));\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#delete(entity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 737
    },
    "return": "void",
    "signature": "public void delete(Object entity)",
    "source_code": "\tpublic void delete(Object entity) throws DataAccessException {\n\t\tdelete(entity, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#delete(entity,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 742
    },
    "return": "void",
    "signature": "public void delete(Object entity, @Nullable LockMode lockMode)",
    "source_code": "\tpublic void delete(Object entity, @Nullable LockMode lockMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entity);\n\t\t\t}\n\t\t\tsession.delete(entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#delete(entityName,entity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 754
    },
    "return": "void",
    "signature": "public void delete(String entityName, Object entity)",
    "source_code": "\tpublic void delete(String entityName, Object entity) throws DataAccessException {\n\t\tdelete(entityName, entity, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#delete(entityName,entity,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 759
    },
    "return": "void",
    "signature": "public void delete(String entityName, Object entity, @Nullable LockMode lockMode)",
    "source_code": "\tpublic void delete(String entityName, Object entity, @Nullable LockMode lockMode)"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#deleteAll(entities)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entities"
    ],
    "position": {
      "column": 1,
      "line": 773
    },
    "return": "void",
    "signature": "public void deleteAll(Collection<?> entities)",
    "source_code": "\tpublic void deleteAll(Collection<?> entities) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tfor (Object entity : entities) {\n\t\t\t\tsession.delete(entity);\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#disableFilters(session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Disable the specified filters on the given Session.\n\t * @param session the current Hibernate Session\n\t * @see #setFilterNames\n\t * @see Session#disableFilter(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 427
    },
    "return": "void",
    "signature": "protected void disableFilters(Session session)",
    "source_code": "\tprotected void disableFilters(Session session) {\n\t\tString[] filterNames = getFilterNames();\n\t\tif (filterNames != null) {\n\t\t\tfor (String filterName : filterNames) {\n\t\t\t\tsession.disableFilter(filterName);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#doExecute(action,enforceNativeSession)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the action specified by the given action object within a Session.\n\t * @param action callback object that specifies the Hibernate action\n\t * @param enforceNativeSession whether to enforce exposure of the native\n\t * Hibernate Session to callback code\n\t * @return a result object returned by the action, or {@code null}\n\t * @throws DataAccessException in case of Hibernate errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "action",
      "enforceNativeSession"
    ],
    "position": {
      "column": 1,
      "line": 345
    },
    "return": "T",
    "signature": "protected T doExecute(HibernateCallback<T> action, boolean enforceNativeSession)",
    "source_code": "\tprotected <T> T doExecute(HibernateCallback<T> action, boolean enforceNativeSession) throws DataAccessException {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\n\t\tSession session = null;\n\t\tboolean isNew = false;\n\t\ttry {\n\t\t\tsession = obtainSessionFactory().getCurrentSession();\n\t\t}\n\t\tcatch (HibernateException ex) {\n\t\t\tlogger.debug(\"Could not retrieve pre-bound Hibernate session\", ex);\n\t\t}\n\t\tif (session == null) {\n\t\t\tsession = obtainSessionFactory().openSession();\n\t\t\tsession.setHibernateFlushMode(FlushMode.MANUAL);\n\t\t\tisNew = true;\n\t\t}\n\n\t\ttry {\n\t\t\tenableFilters(session);\n\t\t\tSession sessionToExpose =\n\t\t\t\t\t(enforceNativeSession || isExposeNativeSession() ? session : createSessionProxy(session));\n\t\t\treturn action.doInHibernate(sessionToExpose);\n\t\t}\n\t\tcatch (HibernateException ex) {\n\t\t\tthrow SessionFactoryUtils.convertHibernateAccessException(ex);\n\t\t}\n\t\tcatch (PersistenceException ex) {\n\t\t\tif (ex.getCause() instanceof HibernateException hibernateEx) {\n\t\t\t\tthrow SessionFactoryUtils.convertHibernateAccessException(hibernateEx);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\t// Callback code threw application exception...\n\t\t\tthrow ex;\n\t\t}\n\t\tfinally {\n\t\t\tif (isNew) {\n\t\t\t\tSessionFactoryUtils.closeSession(session);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdisableFilters(session);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#enableFilter(filterName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "filterName"
    ],
    "position": {
      "column": 1,
      "line": 578
    },
    "return": "Filter",
    "signature": "public Filter enableFilter(String filterName)",
    "source_code": "\tpublic Filter enableFilter(String filterName) throws IllegalStateException {\n\t\tSession session = obtainSessionFactory().getCurrentSession();\n\t\tFilter filter = session.getEnabledFilter(filterName);\n\t\tif (filter == null) {\n\t\t\tfilter = session.enableFilter(filterName);\n\t\t}\n\t\treturn filter;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#enableFilters(session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Enable the specified filters on the given Session.\n\t * @param session the current Hibernate Session\n\t * @see #setFilterNames\n\t * @see Session#enableFilter(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 412
    },
    "return": "void",
    "signature": "protected void enableFilters(Session session)",
    "source_code": "\tprotected void enableFilters(Session session) {\n\t\tString[] filterNames = getFilterNames();\n\t\tif (filterNames != null) {\n\t\t\tfor (String filterName : filterNames) {\n\t\t\t\tsession.enableFilter(filterName);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#evict(entity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 560
    },
    "return": "void",
    "signature": "public void evict(Object entity)",
    "source_code": "\tpublic void evict(Object entity) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tsession.evict(entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#execute(action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "action"
    ],
    "position": {
      "column": 1,
      "line": 318
    },
    "return": "T",
    "signature": "public T execute(HibernateCallback<T> action)",
    "source_code": "\tpublic <T> T execute(HibernateCallback<T> action) throws DataAccessException {\n\t\treturn doExecute(action, false);\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#executeWithNativeSession(action)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the action specified by the given action object within a\n\t * native {@link Session}.\n\t * <p>This execute variant overrides the template-wide\n\t * {@link #isExposeNativeSession() \"exposeNativeSession\"} setting.\n\t * @param action callback object that specifies the Hibernate action\n\t * @return a result object returned by the action, or {@code null}\n\t * @throws DataAccessException in case of Hibernate errors\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "action"
    ],
    "position": {
      "column": 1,
      "line": 332
    },
    "return": "T",
    "signature": "public T executeWithNativeSession(HibernateCallback<T> action)",
    "source_code": "\tpublic <T> T executeWithNativeSession(HibernateCallback<T> action) {\n\t\treturn doExecute(action, true);\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#findByExample(entityName,exampleEntity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "exampleEntity"
    ],
    "position": {
      "column": 1,
      "line": 833
    },
    "return": "List<T>",
    "signature": "public List<T> findByExample(String entityName, T exampleEntity)",
    "source_code": "\tpublic <T> List<T> findByExample(String entityName, T exampleEntity) throws DataAccessException {\n\t\treturn findByExample(entityName, exampleEntity, -1, -1);\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#findByExample(entityName,exampleEntity,firstResult,maxResults)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "exampleEntity",
      "firstResult",
      "maxResults"
    ],
    "position": {
      "column": 1,
      "line": 844
    },
    "return": "List<T>",
    "signature": "public List<T> findByExample(@Nullable String entityName, T exampleEntity, int firstResult, int maxResults)",
    "source_code": "\tpublic <T> List<T> findByExample(@Nullable String entityName, T exampleEntity, int firstResult, int maxResults)"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#findByExample(exampleEntity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exampleEntity"
    ],
    "position": {
      "column": 1,
      "line": 828
    },
    "return": "List<T>",
    "signature": "public List<T> findByExample(T exampleEntity)",
    "source_code": "\tpublic <T> List<T> findByExample(T exampleEntity) throws DataAccessException {\n\t\treturn findByExample(null, exampleEntity, -1, -1);\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#findByExample(exampleEntity,firstResult,maxResults)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exampleEntity",
      "firstResult",
      "maxResults"
    ],
    "position": {
      "column": 1,
      "line": 838
    },
    "return": "List<T>",
    "signature": "public List<T> findByExample(T exampleEntity, int firstResult, int maxResults)",
    "source_code": "\tpublic <T> List<T> findByExample(T exampleEntity, int firstResult, int maxResults) throws DataAccessException {\n\t\treturn findByExample(null, exampleEntity, firstResult, maxResults);\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#flush()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 784
    },
    "return": "void",
    "signature": "public void flush()",
    "source_code": "\tpublic void flush() throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tsession.flush();\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#get(entityClass,id)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityClass",
      "id"
    ],
    "position": {
      "column": 1,
      "line": 443
    },
    "return": "T",
    "signature": "public T get(Class<T> entityClass, Serializable id)",
    "source_code": "\tpublic <T> T get(Class<T> entityClass, Serializable id) throws DataAccessException {\n\t\treturn get(entityClass, id, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#get(entityClass,id,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityClass",
      "id",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 449
    },
    "return": "T",
    "signature": "public T get(Class<T> entityClass, Serializable id, @Nullable LockMode lockMode)",
    "source_code": "\tpublic <T> T get(Class<T> entityClass, Serializable id, @Nullable LockMode lockMode) throws DataAccessException {\n\t\treturn executeWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\treturn session.get(entityClass, id, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn session.get(entityClass, id);\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#get(entityName,id)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "id"
    ],
    "position": {
      "column": 1,
      "line": 462
    },
    "return": "Object",
    "signature": "public Object get(String entityName, Serializable id)",
    "source_code": "\tpublic Object get(String entityName, Serializable id) throws DataAccessException {\n\t\treturn get(entityName, id, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#get(entityName,id,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "id",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 468
    },
    "return": "Object",
    "signature": "public Object get(String entityName, Serializable id, @Nullable LockMode lockMode)",
    "source_code": "\tpublic Object get(String entityName, Serializable id, @Nullable LockMode lockMode) throws DataAccessException {\n\t\treturn executeWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\treturn session.get(entityName, id, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn session.get(entityName, id);\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#getFetchSize()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the fetch size specified for this HibernateTemplate.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 285
    },
    "return": "int",
    "signature": "public int getFetchSize()",
    "source_code": "\tpublic int getFetchSize() {\n\t\treturn this.fetchSize;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#getFilterNames()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the names of Hibernate filters to be activated, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "String[]",
    "signature": "public String[] getFilterNames()",
    "source_code": "\tpublic String[] getFilterNames() {\n\t\treturn this.filterNames;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#getMaxResults()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the maximum number of rows specified for this HibernateTemplate.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "int",
    "signature": "public int getMaxResults()",
    "source_code": "\tpublic int getMaxResults() {\n\t\treturn this.maxResults;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#getQueryCacheRegion()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the name of the cache region for queries executed by this template.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "String",
    "signature": "public String getQueryCacheRegion()",
    "source_code": "\tpublic String getQueryCacheRegion() {\n\t\treturn this.queryCacheRegion;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#getSessionFactory()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the Hibernate SessionFactory that should be used to create\n\t * Hibernate Sessions.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "SessionFactory",
    "signature": "public SessionFactory getSessionFactory()",
    "source_code": "\tpublic SessionFactory getSessionFactory() {\n\t\treturn this.sessionFactory;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#initialize(proxy)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy"
    ],
    "position": {
      "column": 1,
      "line": 568
    },
    "return": "void",
    "signature": "public void initialize(Object proxy)",
    "source_code": "\tpublic void initialize(Object proxy) throws DataAccessException {\n\t\ttry {\n\t\t\tHibernate.initialize(proxy);\n\t\t}\n\t\tcatch (HibernateException ex) {\n\t\t\tthrow SessionFactoryUtils.convertHibernateAccessException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#invoke(proxy,method,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 1150
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\t// Invocation on Session interface coming in...\n\n\t\t\tswitch (method.getName()) {\n\t\t\t\tcase \"equals\":\n\t\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\t\treturn (proxy == args[0]);\n\t\t\t\tcase \"hashCode\":\n\t\t\t\t\t// Use hashCode of Session proxy.\n\t\t\t\t\treturn System.identityHashCode(proxy);\n\t\t\t\tcase \"close\":\n\t\t\t\t\t// Handle close method: suppress, not valid.\n\t\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Invoke method on target Session.\n\t\t\ttry {\n\t\t\t\tObject retVal = method.invoke(this.target, args);\n\n\t\t\t\t// If return value is a Query or Criteria, apply transaction timeout.\n\t\t\t\t// Applies to createQuery, getNamedQuery, createCriteria.\n\t\t\t\tif (retVal instanceof Criteria criteria) {\n\t\t\t\t\tprepareCriteria(criteria);\n\t\t\t\t}\n\t\t\t\telse if (retVal instanceof Query<?> query) {\n\t\t\t\t\tprepareQuery(query);\n\t\t\t\t}\n\n\t\t\t\treturn retVal;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow ex.getTargetException();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#isCacheQueries()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether to cache all queries executed by this template.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 245
    },
    "return": "boolean",
    "signature": "public boolean isCacheQueries()",
    "source_code": "\tpublic boolean isCacheQueries() {\n\t\treturn this.cacheQueries;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#isCheckWriteOperations()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether to check that the Hibernate Session is not in read-only\n\t * mode in case of write operations (save/update/delete).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "boolean",
    "signature": "public boolean isCheckWriteOperations()",
    "source_code": "\tpublic boolean isCheckWriteOperations() {\n\t\treturn this.checkWriteOperations;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#isExposeNativeSession()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether to expose the native Hibernate Session to\n\t * HibernateCallback code, or rather a Session proxy.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "boolean",
    "signature": "public boolean isExposeNativeSession()",
    "source_code": "\tpublic boolean isExposeNativeSession() {\n\t\treturn this.exposeNativeSession;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#load(entity,id)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "id"
    ],
    "position": {
      "column": 1,
      "line": 527
    },
    "return": "void",
    "signature": "public void load(Object entity, Serializable id)",
    "source_code": "\tpublic void load(Object entity, Serializable id) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tsession.load(entity, id);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#load(entityClass,id)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityClass",
      "id"
    ],
    "position": {
      "column": 1,
      "line": 480
    },
    "return": "T",
    "signature": "public T load(Class<T> entityClass, Serializable id)",
    "source_code": "\tpublic <T> T load(Class<T> entityClass, Serializable id) throws DataAccessException {\n\t\treturn load(entityClass, id, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#load(entityClass,id,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityClass",
      "id",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 485
    },
    "return": "T",
    "signature": "public T load(Class<T> entityClass, Serializable id, @Nullable LockMode lockMode)",
    "source_code": "\tpublic <T> T load(Class<T> entityClass, Serializable id, @Nullable LockMode lockMode)"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#load(entityName,id)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "id"
    ],
    "position": {
      "column": 1,
      "line": 499
    },
    "return": "Object",
    "signature": "public Object load(String entityName, Serializable id)",
    "source_code": "\tpublic Object load(String entityName, Serializable id) throws DataAccessException {\n\t\treturn load(entityName, id, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#load(entityName,id,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "id",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 504
    },
    "return": "Object",
    "signature": "public Object load(String entityName, Serializable id, @Nullable LockMode lockMode)",
    "source_code": "\tpublic Object load(String entityName, Serializable id, @Nullable LockMode lockMode) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\treturn session.load(entityName, id, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn session.load(entityName, id);\n\t\t\t}\n\t\t}));\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#loadAll(entityClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityClass"
    ],
    "position": {
      "column": 1,
      "line": 517
    },
    "return": "List<T>",
    "signature": "public List<T> loadAll(Class<T> entityClass)",
    "source_code": "\tpublic <T> List<T> loadAll(Class<T> entityClass) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession((HibernateCallback<List<T>>) session -> {\n\t\t\tCriteria criteria = session.createCriteria(entityClass);\n\t\t\tcriteria.setResultTransformer(Criteria.DISTINCT_ROOT_ENTITY);\n\t\t\tprepareCriteria(criteria);\n\t\t\treturn criteria.list();\n\t\t}));\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#lock(entity,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 593
    },
    "return": "void",
    "signature": "public void lock(Object entity, LockMode lockMode)",
    "source_code": "\tpublic void lock(Object entity, LockMode lockMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#lock(entityName,entity,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 601
    },
    "return": "void",
    "signature": "public void lock(String entityName, Object entity, LockMode lockMode)",
    "source_code": "\tpublic void lock(String entityName, Object entity, LockMode lockMode)"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#merge(entity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 720
    },
    "return": "T",
    "signature": "public T merge(T entity)",
    "source_code": "\tpublic <T> T merge(T entity) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\treturn (T) session.merge(entity);\n\t\t}));\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#merge(entityName,entity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 729
    },
    "return": "T",
    "signature": "public T merge(String entityName, T entity)",
    "source_code": "\tpublic <T> T merge(String entityName, T entity) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\treturn (T) session.merge(entityName, entity);\n\t\t}));\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#obtainSessionFactory()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain the SessionFactory for actual use.\n\t * @return the SessionFactory (never {@code null})\n\t * @throws IllegalStateException in case of no SessionFactory set\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "SessionFactory",
    "signature": "protected SessionFactory obtainSessionFactory()",
    "source_code": "\tprotected final SessionFactory obtainSessionFactory() {\n\t\tSessionFactory sessionFactory = getSessionFactory();\n\t\tAssert.state(sessionFactory != null, \"No SessionFactory set\");\n\t\treturn sessionFactory;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#persist(entity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 701
    },
    "return": "void",
    "signature": "public void persist(Object entity)",
    "source_code": "\tpublic void persist(Object entity) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.persist(entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#persist(entityName,entity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 710
    },
    "return": "void",
    "signature": "public void persist(String entityName, Object entity)",
    "source_code": "\tpublic void persist(String entityName, Object entity) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.persist(entityName, entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#prepareCriteria(criteria)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare the given Criteria object, applying cache settings and/or\n\t * a transaction timeout.\n\t * @param criteria the Criteria object to prepare\n\t * @see #setCacheQueries\n\t * @see #setQueryCacheRegion\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "criteria"
    ],
    "position": {
      "column": 1,
      "line": 1059
    },
    "return": "void",
    "signature": "protected void prepareCriteria(Criteria criteria)",
    "source_code": "\tprotected void prepareCriteria(Criteria criteria) {\n\t\tif (isCacheQueries()) {\n\t\t\tcriteria.setCacheable(true);\n\t\t\tif (getQueryCacheRegion() != null) {\n\t\t\t\tcriteria.setCacheRegion(getQueryCacheRegion());\n\t\t\t}\n\t\t}\n\t\tif (getFetchSize() > 0) {\n\t\t\tcriteria.setFetchSize(getFetchSize());\n\t\t}\n\t\tif (getMaxResults() > 0) {\n\t\t\tcriteria.setMaxResults(getMaxResults());\n\t\t}\n\n\t\tResourceHolderSupport sessionHolder =\n\t\t\t\t(ResourceHolderSupport) TransactionSynchronizationManager.getResource(obtainSessionFactory());\n\t\tif (sessionHolder != null && sessionHolder.hasTimeout()) {\n\t\t\tcriteria.setTimeout(sessionHolder.getTimeToLiveInSeconds());\n\t\t}\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#prepareQuery(queryObject)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare the given Query object, applying cache settings and/or\n\t * a transaction timeout.\n\t * @param queryObject the Query object to prepare\n\t * @see #setCacheQueries\n\t * @see #setQueryCacheRegion\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "queryObject"
    ],
    "position": {
      "column": 1,
      "line": 1087
    },
    "return": "void",
    "signature": "protected void prepareQuery(Query<?> queryObject)",
    "source_code": "\tprotected void prepareQuery(Query<?> queryObject) {\n\t\tif (isCacheQueries()) {\n\t\t\tqueryObject.setCacheable(true);\n\t\t\tif (getQueryCacheRegion() != null) {\n\t\t\t\tqueryObject.setCacheRegion(getQueryCacheRegion());\n\t\t\t}\n\t\t}\n\t\tif (getFetchSize() > 0) {\n\t\t\tqueryObject.setFetchSize(getFetchSize());\n\t\t}\n\t\tif (getMaxResults() > 0) {\n\t\t\tqueryObject.setMaxResults(getMaxResults());\n\t\t}\n\n\t\tResourceHolderSupport sessionHolder =\n\t\t\t\t(ResourceHolderSupport) TransactionSynchronizationManager.getResource(obtainSessionFactory());\n\t\tif (sessionHolder != null && sessionHolder.hasTimeout()) {\n\t\t\tqueryObject.setTimeout(sessionHolder.getTimeToLiveInSeconds());\n\t\t}\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#refresh(entity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 535
    },
    "return": "void",
    "signature": "public void refresh(Object entity)",
    "source_code": "\tpublic void refresh(Object entity) throws DataAccessException {\n\t\trefresh(entity, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#refresh(entity,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 540
    },
    "return": "void",
    "signature": "public void refresh(Object entity, @Nullable LockMode lockMode)",
    "source_code": "\tpublic void refresh(Object entity, @Nullable LockMode lockMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.refresh(entity, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsession.refresh(entity);\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#replicate(entity,replicationMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "replicationMode"
    ],
    "position": {
      "column": 1,
      "line": 681
    },
    "return": "void",
    "signature": "public void replicate(Object entity, ReplicationMode replicationMode)",
    "source_code": "\tpublic void replicate(Object entity, ReplicationMode replicationMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.replicate(entity, replicationMode);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#replicate(entityName,entity,replicationMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity",
      "replicationMode"
    ],
    "position": {
      "column": 1,
      "line": 690
    },
    "return": "void",
    "signature": "public void replicate(String entityName, Object entity, ReplicationMode replicationMode)",
    "source_code": "\tpublic void replicate(String entityName, Object entity, ReplicationMode replicationMode)"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#save(entity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 611
    },
    "return": "Serializable",
    "signature": "public Serializable save(Object entity)",
    "source_code": "\tpublic Serializable save(Object entity) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\treturn session.save(entity);\n\t\t}));\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#save(entityName,entity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 619
    },
    "return": "Serializable",
    "signature": "public Serializable save(String entityName, Object entity)",
    "source_code": "\tpublic Serializable save(String entityName, Object entity) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\treturn session.save(entityName, entity);\n\t\t}));\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#saveOrUpdate(entity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 663
    },
    "return": "void",
    "signature": "public void saveOrUpdate(Object entity)",
    "source_code": "\tpublic void saveOrUpdate(Object entity) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.saveOrUpdate(entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#saveOrUpdate(entityName,entity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 672
    },
    "return": "void",
    "signature": "public void saveOrUpdate(String entityName, Object entity)",
    "source_code": "\tpublic void saveOrUpdate(String entityName, Object entity) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.saveOrUpdate(entityName, entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#setCacheQueries(cacheQueries)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to cache all queries executed by this template.\n\t * <p>If this is \"true\", all Query and Criteria objects created by\n\t * this template will be marked as cacheable (including all\n\t * queries through find methods).\n\t * <p>To specify the query region to be used for queries cached\n\t * by this template, set the \"queryCacheRegion\" property.\n\t * @see #setQueryCacheRegion\n\t * @see Query#setCacheable\n\t * @see Criteria#setCacheable\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cacheQueries"
    ],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "void",
    "signature": "public void setCacheQueries(boolean cacheQueries)",
    "source_code": "\tpublic void setCacheQueries(boolean cacheQueries) {\n\t\tthis.cacheQueries = cacheQueries;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#setCheckWriteOperations(checkWriteOperations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to check that the Hibernate Session is not in read-only mode\n\t * in case of write operations (save/update/delete).\n\t * <p>Default is \"true\", for fail-fast behavior when attempting write operations\n\t * within a read-only transaction. Turn this off to allow save/update/delete\n\t * on a Session with flush mode MANUAL.\n\t * @see #checkWriteOperationAllowed\n\t * @see org.springframework.transaction.TransactionDefinition#isReadOnly\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "checkWriteOperations"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "void",
    "signature": "public void setCheckWriteOperations(boolean checkWriteOperations)",
    "source_code": "\tpublic void setCheckWriteOperations(boolean checkWriteOperations) {\n\t\tthis.checkWriteOperations = checkWriteOperations;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#setExposeNativeSession(exposeNativeSession)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to expose the native Hibernate Session to\n\t * HibernateCallback code.\n\t * <p>Default is \"false\": a Session proxy will be returned, suppressing\n\t * {@code close} calls and automatically applying query cache\n\t * settings and transaction timeouts.\n\t * @see HibernateCallback\n\t * @see Session\n\t * @see #setCacheQueries\n\t * @see #setQueryCacheRegion\n\t * @see #prepareQuery\n\t * @see #prepareCriteria\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exposeNativeSession"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "void",
    "signature": "public void setExposeNativeSession(boolean exposeNativeSession)",
    "source_code": "\tpublic void setExposeNativeSession(boolean exposeNativeSession) {\n\t\tthis.exposeNativeSession = exposeNativeSession;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#setFetchSize(fetchSize)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the fetch size for this HibernateTemplate. This is important for processing\n\t * large result sets: Setting this higher than the default value will increase\n\t * processing speed at the cost of memory consumption; setting this lower can\n\t * avoid transferring row data that will never be read by the application.\n\t * <p>Default is 0, indicating to use the JDBC driver's default.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fetchSize"
    ],
    "position": {
      "column": 1,
      "line": 278
    },
    "return": "void",
    "signature": "public void setFetchSize(int fetchSize)",
    "source_code": "\tpublic void setFetchSize(int fetchSize) {\n\t\tthis.fetchSize = fetchSize;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#setFilterNames(filterNames)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set one or more names of Hibernate filters to be activated for all\n\t * Sessions that this accessor works with.\n\t * <p>Each of those filters will be enabled at the beginning of each\n\t * operation and correspondingly disabled at the end of the operation.\n\t * This will work for newly opened Sessions as well as for existing\n\t * Sessions (for example, within a transaction).\n\t * @see #enableFilters(Session)\n\t * @see Session#enableFilter(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "filterNames"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "void",
    "signature": "public void setFilterNames(@Nullable String... filterNames)",
    "source_code": "\tpublic void setFilterNames(@Nullable String... filterNames) {\n\t\tthis.filterNames = filterNames;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#setMaxResults(maxResults)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the maximum number of rows for this HibernateTemplate. This is important\n\t * for processing subsets of large result sets, avoiding to read and hold\n\t * the entire result set in the database or in the JDBC driver if we're\n\t * never interested in the entire result in the first place (for example,\n\t * when performing searches that might return a large number of matches).\n\t * <p>Default is 0, indicating to use the JDBC driver's default.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "maxResults"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "void",
    "signature": "public void setMaxResults(int maxResults)",
    "source_code": "\tpublic void setMaxResults(int maxResults) {\n\t\tthis.maxResults = maxResults;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#setQueryCacheRegion(queryCacheRegion)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of the cache region for queries executed by this template.\n\t * <p>If this is specified, it will be applied to all Query and Criteria objects\n\t * created by this template (including all queries through find methods).\n\t * <p>The cache region will not take effect unless queries created by this\n\t * template are configured to be cached via the \"cacheQueries\" property.\n\t * @see #setCacheQueries\n\t * @see Query#setCacheRegion\n\t * @see Criteria#setCacheRegion\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queryCacheRegion"
    ],
    "position": {
      "column": 1,
      "line": 259
    },
    "return": "void",
    "signature": "public void setQueryCacheRegion(@Nullable String queryCacheRegion)",
    "source_code": "\tpublic void setQueryCacheRegion(@Nullable String queryCacheRegion) {\n\t\tthis.queryCacheRegion = queryCacheRegion;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#setSessionFactory(sessionFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Hibernate SessionFactory that should be used to create\n\t * Hibernate Sessions.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionFactory"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "void",
    "signature": "public void setSessionFactory(@Nullable SessionFactory sessionFactory)",
    "source_code": "\tpublic void setSessionFactory(@Nullable SessionFactory sessionFactory) {\n\t\tthis.sessionFactory = sessionFactory;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#update(entity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 627
    },
    "return": "void",
    "signature": "public void update(Object entity)",
    "source_code": "\tpublic void update(Object entity) throws DataAccessException {\n\t\tupdate(entity, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#update(entity,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 632
    },
    "return": "void",
    "signature": "public void update(Object entity, @Nullable LockMode lockMode)",
    "source_code": "\tpublic void update(Object entity, @Nullable LockMode lockMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.update(entity);\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entity);\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#update(entityName,entity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 644
    },
    "return": "void",
    "signature": "public void update(String entityName, Object entity)",
    "source_code": "\tpublic void update(String entityName, Object entity) throws DataAccessException {\n\t\tupdate(entityName, entity, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#update(entityName,entity,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 649
    },
    "return": "void",
    "signature": "public void update(String entityName, Object entity, @Nullable LockMode lockMode)",
    "source_code": "\tpublic void update(String entityName, Object entity, @Nullable LockMode lockMode)"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link FactoryBean} that creates a Hibernate {@link SessionFactory}. This is the usual\n * way to set up a shared Hibernate SessionFactory in a Spring application context; the\n * SessionFactory can then be passed to data access objects via dependency injection.\n *\n * <p>Compatible with Hibernate ORM 5.5/5.6, as of Spring Framework 6.0.\n * This Hibernate-specific {@code LocalSessionFactoryBean} can be an immediate alternative\n * to {@link org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean} for\n * common JPA purposes: The Hibernate {@code SessionFactory} will natively expose the JPA\n * {@code EntityManagerFactory} interface as well, and Hibernate {@code BeanContainer}\n * integration will be registered out of the box. In combination with\n * {@link HibernateTransactionManager}, this naturally allows for mixing JPA access code\n * with native Hibernate access code within the same transaction.\n *\n * @author Juergen Hoeller\n * @since 4.2\n * @see #setDataSource\n * @see #setPackagesToScan\n * @see HibernateTransactionManager\n * @see LocalSessionFactoryBuilder\n * @see org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "signature": "public class LocalSessionFactoryBean",
    "source_code": "public class LocalSessionFactoryBean extends HibernateExceptionTranslator"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 485
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() throws IOException {\n\t\tif (this.metadataSources != null && !this.metadataSourcesAccessed) {\n\t\t\t// Repeated initialization with no user-customized MetadataSources -> clear it.\n\t\t\tthis.metadataSources = null;\n\t\t}\n\n\t\tLocalSessionFactoryBuilder sfb = new LocalSessionFactoryBuilder(\n\t\t\t\tthis.dataSource, getResourceLoader(), getMetadataSources());\n\n\t\tif (this.configLocations != null) {\n\t\t\tfor (Resource resource : this.configLocations) {\n\t\t\t\t// Load Hibernate configuration from given location.\n\t\t\t\tsfb.configure(resource.getURL());\n\t\t\t}\n\t\t}\n\n\t\tif (this.mappingResources != null) {\n\t\t\t// Register given Hibernate mapping definitions, contained in resource files.\n\t\t\tfor (String mapping : this.mappingResources) {\n\t\t\t\tResource mr = new ClassPathResource(mapping.trim(), getResourceLoader().getClassLoader());\n\t\t\t\tsfb.addInputStream(mr.getInputStream());\n\t\t\t}\n\t\t}\n\n\t\tif (this.mappingLocations != null) {\n\t\t\t// Register given Hibernate mapping definitions, contained in resource files.\n\t\t\tfor (Resource resource : this.mappingLocations) {\n\t\t\t\tsfb.addInputStream(resource.getInputStream());\n\t\t\t}\n\t\t}\n\n\t\tif (this.cacheableMappingLocations != null) {\n\t\t\t// Register given cacheable Hibernate mapping definitions, read from the file system.\n\t\t\tfor (Resource resource : this.cacheableMappingLocations) {\n\t\t\t\tsfb.addCacheableFile(resource.getFile());\n\t\t\t}\n\t\t}\n\n\t\tif (this.mappingJarLocations != null) {\n\t\t\t// Register given Hibernate mapping definitions, contained in jar files.\n\t\t\tfor (Resource resource : this.mappingJarLocations) {\n\t\t\t\tsfb.addJar(resource.getFile());\n\t\t\t}\n\t\t}\n\n\t\tif (this.mappingDirectoryLocations != null) {\n\t\t\t// Register all Hibernate mapping definitions in the given directories.\n\t\t\tfor (Resource resource : this.mappingDirectoryLocations) {\n\t\t\t\tFile file = resource.getFile();\n\t\t\t\tif (!file.isDirectory()) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\t\"Mapping directory location [\" + resource + \"] does not denote a directory\");\n\t\t\t\t}\n\t\t\t\tsfb.addDirectory(file);\n\t\t\t}\n\t\t}\n\n\t\tif (this.entityInterceptor != null) {\n\t\t\tsfb.setInterceptor(this.entityInterceptor);\n\t\t}\n\n\t\tif (this.implicitNamingStrategy != null) {\n\t\t\tsfb.setImplicitNamingStrategy(this.implicitNamingStrategy);\n\t\t}\n\n\t\tif (this.physicalNamingStrategy != null) {\n\t\t\tsfb.setPhysicalNamingStrategy(this.physicalNamingStrategy);\n\t\t}\n\n\t\tif (this.jtaTransactionManager != null) {\n\t\t\tsfb.setJtaTransactionManager(this.jtaTransactionManager);\n\t\t}\n\n\t\tif (this.beanFactory != null) {\n\t\t\tsfb.setBeanContainer(this.beanFactory);\n\t\t}\n\n\t\tif (this.cacheRegionFactory != null) {\n\t\t\tsfb.setCacheRegionFactory(this.cacheRegionFactory);\n\t\t}\n\n\t\tif (this.multiTenantConnectionProvider != null) {\n\t\t\tsfb.setMultiTenantConnectionProvider(this.multiTenantConnectionProvider);\n\t\t}\n\n\t\tif (this.currentTenantIdentifierResolver != null) {\n\t\t\tsfb.setCurrentTenantIdentifierResolver(this.currentTenantIdentifierResolver);\n\t\t}\n\n\t\tif (this.hibernateProperties != null) {\n\t\t\tsfb.addProperties(this.hibernateProperties);\n\t\t}\n\n\t\tif (this.entityTypeFilters != null) {\n\t\t\tsfb.setEntityTypeFilters(this.entityTypeFilters);\n\t\t}\n\n\t\tif (this.annotatedClasses != null) {\n\t\t\tsfb.addAnnotatedClasses(this.annotatedClasses);\n\t\t}\n\n\t\tif (this.annotatedPackages != null) {\n\t\t\tsfb.addPackages(this.annotatedPackages);\n\t\t}\n\n\t\tif (this.packagesToScan != null) {\n\t\t\tsfb.scanPackages(this.packagesToScan);\n\t\t}\n\n\t\t// Build SessionFactory instance.\n\t\tthis.configuration = sfb;\n\t\tthis.sessionFactory = buildSessionFactory(sfb);\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#buildSessionFactory(sfb)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses can override this method to perform custom initialization\n\t * of the SessionFactory instance, creating it via the given Configuration\n\t * object that got prepared by this LocalSessionFactoryBean.\n\t * <p>The default implementation invokes LocalSessionFactoryBuilder's buildSessionFactory.\n\t * A custom implementation could prepare the instance in a specific way (e.g. applying\n\t * a custom ServiceRegistry) or use a custom SessionFactoryImpl subclass.\n\t * @param sfb a LocalSessionFactoryBuilder prepared by this LocalSessionFactoryBean\n\t * @return the SessionFactory instance\n\t * @see LocalSessionFactoryBuilder#buildSessionFactory\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "sfb"
    ],
    "position": {
      "column": 1,
      "line": 610
    },
    "return": "SessionFactory",
    "signature": "protected SessionFactory buildSessionFactory(LocalSessionFactoryBuilder sfb)",
    "source_code": "\tprotected SessionFactory buildSessionFactory(LocalSessionFactoryBuilder sfb) {\n\t\treturn (this.bootstrapExecutor != null ? sfb.buildSessionFactory(this.bootstrapExecutor) :\n\t\t\t\tsfb.buildSessionFactory());\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#destroy()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 646
    },
    "return": "void",
    "signature": "public void destroy()",
    "source_code": "\tpublic void destroy() {\n\t\tif (this.sessionFactory != null) {\n\t\t\tthis.sessionFactory.close();\n\t\t}\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#getConfiguration()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the Hibernate Configuration object used to build the SessionFactory.\n\t * Allows for access to configuration metadata stored there (rarely needed).\n\t * @throws IllegalStateException if the Configuration object has not been initialized yet\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 620
    },
    "return": "Configuration",
    "signature": "public Configuration getConfiguration()",
    "source_code": "\tpublic final Configuration getConfiguration() {\n\t\tif (this.configuration == null) {\n\t\t\tthrow new IllegalStateException(\"Configuration not initialized yet\");\n\t\t}\n\t\treturn this.configuration;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#getHibernateProperties()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the Hibernate properties, if any. Mainly available for\n\t * configuration through property paths that specify individual keys.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 335
    },
    "return": "Properties",
    "signature": "public Properties getHibernateProperties()",
    "source_code": "\tpublic Properties getHibernateProperties() {\n\t\tif (this.hibernateProperties == null) {\n\t\t\tthis.hibernateProperties = new Properties();\n\t\t}\n\t\treturn this.hibernateProperties;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#getMetadataSources()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the Hibernate {@link MetadataSources} to use.\n\t * <p>Can also be externally called to initialize and pre-populate a {@link MetadataSources}\n\t * instance which is then going to be used for {@link SessionFactory} building.\n\t * @return the MetadataSources to use (never {@code null})\n\t * @since 4.3\n\t * @see LocalSessionFactoryBuilder#LocalSessionFactoryBuilder(DataSource, ResourceLoader, MetadataSources)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 430
    },
    "return": "MetadataSources",
    "signature": "public MetadataSources getMetadataSources()",
    "source_code": "\tpublic MetadataSources getMetadataSources() {\n\t\tthis.metadataSourcesAccessed = true;\n\t\tif (this.metadataSources == null) {\n\t\t\tBootstrapServiceRegistryBuilder builder = new BootstrapServiceRegistryBuilder();\n\t\t\tif (this.resourcePatternResolver != null) {\n\t\t\t\tbuilder = builder.applyClassLoader(this.resourcePatternResolver.getClassLoader());\n\t\t\t}\n\t\t\tif (this.hibernateIntegrators != null) {\n\t\t\t\tfor (Integrator integrator : this.hibernateIntegrators) {\n\t\t\t\t\tbuilder = builder.applyIntegrator(integrator);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.metadataSources = new MetadataSources(builder.build());\n\t\t}\n\t\treturn this.metadataSources;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#getObject()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 630
    },
    "return": "SessionFactory",
    "signature": "public SessionFactory getObject()",
    "source_code": "\tpublic SessionFactory getObject() {\n\t\treturn this.sessionFactory;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#getResourceLoader()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the Spring {@link ResourceLoader} to use for Hibernate metadata.\n\t * @return the ResourceLoader to use (never {@code null})\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 461
    },
    "return": "ResourceLoader",
    "signature": "public ResourceLoader getResourceLoader()",
    "source_code": "\tpublic ResourceLoader getResourceLoader() {\n\t\tif (this.resourcePatternResolver == null) {\n\t\t\tthis.resourcePatternResolver = new PathMatchingResourcePatternResolver();\n\t\t}\n\t\treturn this.resourcePatternResolver;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#isSingleton()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 640
    },
    "return": "boolean",
    "signature": "public boolean isSingleton()",
    "source_code": "\tpublic boolean isSingleton() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#setAnnotatedClasses(annotatedClasses)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify annotated entity classes to register with this Hibernate SessionFactory.\n\t * @see Configuration#addAnnotatedClass(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedClasses"
    ],
    "position": {
      "column": 1,
      "line": 357
    },
    "return": "void",
    "signature": "public void setAnnotatedClasses(Class<?>... annotatedClasses)",
    "source_code": "\tpublic void setAnnotatedClasses(Class<?>... annotatedClasses) {\n\t\tthis.annotatedClasses = annotatedClasses;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#setAnnotatedPackages(annotatedPackages)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the names of annotated packages, for which package-level\n\t * annotation metadata will be read.\n\t * @see Configuration#addPackage(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedPackages"
    ],
    "position": {
      "column": 1,
      "line": 366
    },
    "return": "void",
    "signature": "public void setAnnotatedPackages(String... annotatedPackages)",
    "source_code": "\tpublic void setAnnotatedPackages(String... annotatedPackages) {\n\t\tthis.annotatedPackages = annotatedPackages;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Accept the containing {@link BeanFactory}, registering corresponding Hibernate\n\t * {@link org.hibernate.resource.beans.container.spi.BeanContainer} integration for\n\t * it if possible. This requires a Spring {@link ConfigurableListableBeanFactory}.\n\t * @since 5.1\n\t * @see SpringBeanContainer\n\t * @see LocalSessionFactoryBuilder#setBeanContainer\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 477
    },
    "return": "void",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tif (beanFactory instanceof ConfigurableListableBeanFactory clbf) {\n\t\t\tthis.beanFactory = clbf;\n\t\t}\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#setBootstrapExecutor(bootstrapExecutor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify an asynchronous executor for background bootstrapping,\n\t * e.g. a {@link org.springframework.core.task.SimpleAsyncTaskExecutor}.\n\t * <p>{@code SessionFactory} initialization will then switch into background\n\t * bootstrap mode, with a {@code SessionFactory} proxy immediately returned for\n\t * injection purposes instead of waiting for Hibernate's bootstrapping to complete.\n\t * However, note that the first actual call to a {@code SessionFactory} method will\n\t * then block until Hibernate's bootstrapping completed, if not ready by then.\n\t * For maximum benefit, make sure to avoid early {@code SessionFactory} calls\n\t * in init methods of related beans, even for metadata introspection purposes.\n\t * @since 4.3\n\t * @see LocalSessionFactoryBuilder#buildSessionFactory(AsyncTaskExecutor)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bootstrapExecutor"
    ],
    "position": {
      "column": 1,
      "line": 392
    },
    "return": "void",
    "signature": "public void setBootstrapExecutor(AsyncTaskExecutor bootstrapExecutor)",
    "source_code": "\tpublic void setBootstrapExecutor(AsyncTaskExecutor bootstrapExecutor) {\n\t\tthis.bootstrapExecutor = bootstrapExecutor;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#setCacheRegionFactory(cacheRegionFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Hibernate {@link RegionFactory} to use for the SessionFactory.\n\t * Allows for using a Spring-managed {@code RegionFactory} instance.\n\t * <p>Note: If this is set, the Hibernate settings should not define a\n\t * cache provider to avoid meaningless double configuration.\n\t * @since 5.1\n\t * @see LocalSessionFactoryBuilder#setCacheRegionFactory\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cacheRegionFactory"
    ],
    "position": {
      "column": 1,
      "line": 299
    },
    "return": "void",
    "signature": "public void setCacheRegionFactory(RegionFactory cacheRegionFactory)",
    "source_code": "\tpublic void setCacheRegionFactory(RegionFactory cacheRegionFactory) {\n\t\tthis.cacheRegionFactory = cacheRegionFactory;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#setCacheableMappingLocations(cacheableMappingLocations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set locations of cacheable Hibernate mapping files, for example as web app\n\t * resource \"/WEB-INF/mapping/example.hbm.xml\". Supports any resource location\n\t * via Spring's resource abstraction, as long as the resource can be resolved\n\t * in the file system.\n\t * <p>Can be used to add to mappings from a Hibernate XML config file,\n\t * or to specify all mappings locally.\n\t * @see Configuration#addCacheableFile(File)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cacheableMappingLocations"
    ],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "void",
    "signature": "public void setCacheableMappingLocations(Resource... cacheableMappingLocations)",
    "source_code": "\tpublic void setCacheableMappingLocations(Resource... cacheableMappingLocations) {\n\t\tthis.cacheableMappingLocations = cacheableMappingLocations;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#setConfigLocation(configLocation)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the location of a single Hibernate XML config file, for example as\n\t * classpath resource \"classpath:hibernate.cfg.xml\".\n\t * <p>Note: Can be omitted when all necessary properties and mapping\n\t * resources are specified locally via this bean.\n\t * @see Configuration#configure(java.net.URL)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "configLocation"
    ],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "void",
    "signature": "public void setConfigLocation(Resource configLocation)",
    "source_code": "\tpublic void setConfigLocation(Resource configLocation) {\n\t\tthis.configLocations = new Resource[] {configLocation};\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#setConfigLocations(configLocations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the locations of multiple Hibernate XML config files, for example as\n\t * classpath resources \"classpath:hibernate.cfg.xml,classpath:extension.cfg.xml\".\n\t * <p>Note: Can be omitted when all necessary properties and mapping\n\t * resources are specified locally via this bean.\n\t * @see Configuration#configure(java.net.URL)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "configLocations"
    ],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "void",
    "signature": "public void setConfigLocations(Resource... configLocations)",
    "source_code": "\tpublic void setConfigLocations(Resource... configLocations) {\n\t\tthis.configLocations = configLocations;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#setCurrentTenantIdentifierResolver(currentTenantIdentifierResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a {@link CurrentTenantIdentifierResolver} to be passed on to the SessionFactory.\n\t * @see LocalSessionFactoryBuilder#setCurrentTenantIdentifierResolver\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "currentTenantIdentifierResolver"
    ],
    "position": {
      "column": 1,
      "line": 316
    },
    "return": "void",
    "signature": "public void setCurrentTenantIdentifierResolver(CurrentTenantIdentifierResolver currentTenantIdentifierResolver)",
    "source_code": "\tpublic void setCurrentTenantIdentifierResolver(CurrentTenantIdentifierResolver currentTenantIdentifierResolver) {\n\t\tthis.currentTenantIdentifierResolver = currentTenantIdentifierResolver;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#setDataSource(dataSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the DataSource to be used by the SessionFactory.\n\t * If set, this will override corresponding settings in Hibernate properties.\n\t * <p>If this is set, the Hibernate settings should not define\n\t * a connection provider to avoid meaningless double configuration.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataSource"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "void",
    "signature": "public void setDataSource(DataSource dataSource)",
    "source_code": "\tpublic void setDataSource(DataSource dataSource) {\n\t\tthis.dataSource = dataSource;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#setEntityInterceptor(entityInterceptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a Hibernate entity interceptor that allows to inspect and change\n\t * property values before writing to and reading from the database.\n\t * Will get applied to any new Session created by this factory.\n\t * @see Configuration#setInterceptor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityInterceptor"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "void",
    "signature": "public void setEntityInterceptor(Interceptor entityInterceptor)",
    "source_code": "\tpublic void setEntityInterceptor(Interceptor entityInterceptor) {\n\t\tthis.entityInterceptor = entityInterceptor;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#setEntityTypeFilters(entityTypeFilters)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify custom type filters for Spring-based scanning for entity classes.\n\t * <p>Default is to search all specified packages for classes annotated with\n\t * {@code @jakarta.persistence.Entity}, {@code @jakarta.persistence.Embeddable}\n\t * or {@code @jakarta.persistence.MappedSuperclass}.\n\t * @see #setPackagesToScan\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityTypeFilters"
    ],
    "position": {
      "column": 1,
      "line": 349
    },
    "return": "void",
    "signature": "public void setEntityTypeFilters(TypeFilter... entityTypeFilters)",
    "source_code": "\tpublic void setEntityTypeFilters(TypeFilter... entityTypeFilters) {\n\t\tthis.entityTypeFilters = entityTypeFilters;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#setHibernateIntegrators(hibernateIntegrators)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify one or more Hibernate {@link Integrator} implementations to apply.\n\t * <p>This will only be applied for an internally built {@link MetadataSources}\n\t * instance. {@link #setMetadataSources} effectively overrides such settings,\n\t * with integrators to be applied to the externally built {@link MetadataSources}.\n\t * @since 5.1\n\t * @see #setMetadataSources\n\t * @see BootstrapServiceRegistryBuilder#applyIntegrator\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hibernateIntegrators"
    ],
    "position": {
      "column": 1,
      "line": 405
    },
    "return": "void",
    "signature": "public void setHibernateIntegrators(Integrator... hibernateIntegrators)",
    "source_code": "\tpublic void setHibernateIntegrators(Integrator... hibernateIntegrators) {\n\t\tthis.hibernateIntegrators = hibernateIntegrators;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#setHibernateProperties(hibernateProperties)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set Hibernate properties, such as \"hibernate.dialect\".\n\t * <p>Note: Do not specify a transaction provider here when using\n\t * Spring-driven transactions. It is also advisable to omit connection\n\t * provider settings and use a Spring-set DataSource instead.\n\t * @see #setDataSource\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hibernateProperties"
    ],
    "position": {
      "column": 1,
      "line": 327
    },
    "return": "void",
    "signature": "public void setHibernateProperties(Properties hibernateProperties)",
    "source_code": "\tpublic void setHibernateProperties(Properties hibernateProperties) {\n\t\tthis.hibernateProperties = hibernateProperties;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#setImplicitNamingStrategy(implicitNamingStrategy)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a Hibernate 5 {@link ImplicitNamingStrategy} for the SessionFactory.\n\t * @see Configuration#setImplicitNamingStrategy\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "implicitNamingStrategy"
    ],
    "position": {
      "column": 1,
      "line": 269
    },
    "return": "void",
    "signature": "public void setImplicitNamingStrategy(ImplicitNamingStrategy implicitNamingStrategy)",
    "source_code": "\tpublic void setImplicitNamingStrategy(ImplicitNamingStrategy implicitNamingStrategy) {\n\t\tthis.implicitNamingStrategy = implicitNamingStrategy;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#setJtaTransactionManager(jtaTransactionManager)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Spring {@link org.springframework.transaction.jta.JtaTransactionManager}\n\t * or the JTA {@link jakarta.transaction.TransactionManager} to be used with Hibernate,\n\t * if any. Implicitly sets up {@code JtaPlatform}.\n\t * @see LocalSessionFactoryBuilder#setJtaTransactionManager\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "jtaTransactionManager"
    ],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "void",
    "signature": "public void setJtaTransactionManager(Object jtaTransactionManager)",
    "source_code": "\tpublic void setJtaTransactionManager(Object jtaTransactionManager) {\n\t\tthis.jtaTransactionManager = jtaTransactionManager;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#setMappingDirectoryLocations(mappingDirectoryLocations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set locations of directories that contain Hibernate mapping resources,\n\t * like \"WEB-INF/mappings\".\n\t * <p>Can be used to add to mappings from a Hibernate XML config file,\n\t * or to specify all mappings locally.\n\t * @see Configuration#addDirectory(File)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappingDirectoryLocations"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "void",
    "signature": "public void setMappingDirectoryLocations(Resource... mappingDirectoryLocations)",
    "source_code": "\tpublic void setMappingDirectoryLocations(Resource... mappingDirectoryLocations) {\n\t\tthis.mappingDirectoryLocations = mappingDirectoryLocations;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#setMappingJarLocations(mappingJarLocations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set locations of jar files that contain Hibernate mapping resources,\n\t * like \"WEB-INF/lib/example.hbm.jar\".\n\t * <p>Can be used to add to mappings from a Hibernate XML config file,\n\t * or to specify all mappings locally.\n\t * @see Configuration#addJar(File)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappingJarLocations"
    ],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "void",
    "signature": "public void setMappingJarLocations(Resource... mappingJarLocations)",
    "source_code": "\tpublic void setMappingJarLocations(Resource... mappingJarLocations) {\n\t\tthis.mappingJarLocations = mappingJarLocations;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#setMappingLocations(mappingLocations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set locations of Hibernate mapping files, for example as classpath\n\t * resource \"classpath:example.hbm.xml\". Supports any resource location\n\t * via Spring's resource abstraction, for example relative paths like\n\t * \"WEB-INF/mappings/example.hbm.xml\" when running in an application context.\n\t * <p>Can be used to add to mappings from a Hibernate XML config file,\n\t * or to specify all mappings locally.\n\t * @see Configuration#addInputStream\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappingLocations"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "void",
    "signature": "public void setMappingLocations(Resource... mappingLocations)",
    "source_code": "\tpublic void setMappingLocations(Resource... mappingLocations) {\n\t\tthis.mappingLocations = mappingLocations;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#setMappingResources(mappingResources)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set Hibernate mapping resources to be found in the class path,\n\t * like \"example.hbm.xml\" or \"mypackage/example.hbm.xml\".\n\t * Analogous to mapping entries in a Hibernate XML config file.\n\t * Alternative to the more generic setMappingLocations method.\n\t * <p>Can be used to add to mappings from a Hibernate XML config file,\n\t * or to specify all mappings locally.\n\t * @see #setMappingLocations\n\t * @see Configuration#addResource\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappingResources"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "void",
    "signature": "public void setMappingResources(String... mappingResources)",
    "source_code": "\tpublic void setMappingResources(String... mappingResources) {\n\t\tthis.mappingResources = mappingResources;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#setMetadataSources(metadataSources)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify a Hibernate {@link MetadataSources} service to use (e.g. reusing an\n\t * existing one), potentially populated with a custom Hibernate bootstrap\n\t * {@link org.hibernate.service.ServiceRegistry} as well.\n\t * @since 4.3\n\t * @see MetadataSources#MetadataSources(ServiceRegistry)\n\t * @see BootstrapServiceRegistryBuilder#build()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "metadataSources"
    ],
    "position": {
      "column": 1,
      "line": 417
    },
    "return": "void",
    "signature": "public void setMetadataSources(MetadataSources metadataSources)",
    "source_code": "\tpublic void setMetadataSources(MetadataSources metadataSources) {\n\t\tthis.metadataSourcesAccessed = true;\n\t\tthis.metadataSources = metadataSources;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#setMultiTenantConnectionProvider(multiTenantConnectionProvider)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a {@link MultiTenantConnectionProvider} to be passed on to the SessionFactory.\n\t * @since 4.3\n\t * @see LocalSessionFactoryBuilder#setMultiTenantConnectionProvider\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "multiTenantConnectionProvider"
    ],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "void",
    "signature": "public void setMultiTenantConnectionProvider(MultiTenantConnectionProvider multiTenantConnectionProvider)",
    "source_code": "\tpublic void setMultiTenantConnectionProvider(MultiTenantConnectionProvider multiTenantConnectionProvider) {\n\t\tthis.multiTenantConnectionProvider = multiTenantConnectionProvider;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#setPackagesToScan(packagesToScan)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify packages to search for autodetection of your entity classes in the\n\t * classpath. This is analogous to Spring's component-scan feature\n\t * ({@link org.springframework.context.annotation.ClassPathBeanDefinitionScanner}).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "packagesToScan"
    ],
    "position": {
      "column": 1,
      "line": 375
    },
    "return": "void",
    "signature": "public void setPackagesToScan(String... packagesToScan)",
    "source_code": "\tpublic void setPackagesToScan(String... packagesToScan) {\n\t\tthis.packagesToScan = packagesToScan;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#setPhysicalNamingStrategy(physicalNamingStrategy)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a Hibernate 5 {@link PhysicalNamingStrategy} for the SessionFactory.\n\t * @see Configuration#setPhysicalNamingStrategy\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "physicalNamingStrategy"
    ],
    "position": {
      "column": 1,
      "line": 277
    },
    "return": "void",
    "signature": "public void setPhysicalNamingStrategy(PhysicalNamingStrategy physicalNamingStrategy)",
    "source_code": "\tpublic void setPhysicalNamingStrategy(PhysicalNamingStrategy physicalNamingStrategy) {\n\t\tthis.physicalNamingStrategy = physicalNamingStrategy;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBean#setResourceLoader(resourceLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify a Spring {@link ResourceLoader} to use for Hibernate metadata.\n\t * @param resourceLoader the ResourceLoader to use (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resourceLoader"
    ],
    "position": {
      "column": 1,
      "line": 452
    },
    "return": "void",
    "signature": "public void setResourceLoader(ResourceLoader resourceLoader)",
    "source_code": "\tpublic void setResourceLoader(ResourceLoader resourceLoader) {\n\t\tthis.resourcePatternResolver = ResourcePatternUtils.getResourcePatternResolver(resourceLoader);\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBuilder": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A Spring-provided extension of the standard Hibernate {@link Configuration} class,\n * adding {@link SpringSessionContext} as a default and providing convenient ways\n * to specify a JDBC {@link DataSource} and an application class loader.\n *\n * <p>This is designed for programmatic use, e.g. in {@code @Bean} factory methods;\n * consider using {@link LocalSessionFactoryBean} for XML bean definition files.\n * Typically combined with {@link HibernateTransactionManager} for declarative\n * transactions against the {@code SessionFactory} and its JDBC {@code DataSource}.\n *\n * <p>Compatible with Hibernate ORM 5.5/5.6, as of Spring Framework 6.0.\n * This Hibernate-specific factory builder can also be a convenient way to set up\n * a JPA {@code EntityManagerFactory} since the Hibernate {@code SessionFactory}\n * natively exposes the JPA {@code EntityManagerFactory} interface as well now.\n *\n * <p>This builder supports Hibernate {@code BeanContainer} integration,\n * {@link MetadataSources} from custom {@link BootstrapServiceRegistryBuilder}\n * setup, as well as other advanced Hibernate configuration options beyond the\n * standard JPA bootstrap contract.\n *\n * @author Juergen Hoeller\n * @since 4.2\n * @see HibernateTransactionManager\n * @see LocalSessionFactoryBean\n * @see #setBeanContainer\n * @see #LocalSessionFactoryBuilder(DataSource, ResourceLoader, MetadataSources)\n * @see BootstrapServiceRegistryBuilder\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "signature": "public class LocalSessionFactoryBuilder",
    "source_code": "public class LocalSessionFactoryBuilder extends Configuration {\n\n\tprivate static final String RESOURCE_PATTERN = \"/**/*.class\";\n\n\tprivate static final String PACKAGE_INFO_SUFFIX = \".package-info\";\n\n\tprivate static final TypeFilter[] DEFAULT_ENTITY_TYPE_FILTERS = new TypeFilter[] {\n\t\t\tnew AnnotationTypeFilter(Entity.class, false),\n\t\t\tnew AnnotationTypeFilter(Embeddable.class, false),\n\t\t\tnew AnnotationTypeFilter(MappedSuperclass.class, false)};\n\n\tprivate static final TypeFilter CONVERTER_TYPE_FILTER = new AnnotationTypeFilter(Converter.class, false);\n\n\n\tprivate final ResourcePatternResolver resourcePatternResolver;\n\n\t@Nullable\n\tprivate TypeFilter[] entityTypeFilters = DEFAULT_ENTITY_TYPE_FILTERS;\n\n\n\t/**\n\t * Create a new LocalSessionFactoryBuilder for the given DataSource.\n\t * @param dataSource the JDBC DataSource that the resulting Hibernate SessionFactory should be using\n\t * (may be {@code null})\n\t */\n\tpublic LocalSessionFactoryBuilder(@Nullable DataSource dataSource) {\n\t\tthis(dataSource, new PathMatchingResourcePatternResolver());\n\t}\n\n\t/**\n\t * Create a new LocalSessionFactoryBuilder for the given DataSource.\n\t * @param dataSource the JDBC DataSource that the resulting Hibernate SessionFactory should be using\n\t * (may be {@code null})\n\t * @param classLoader the ClassLoader to load application classes from\n\t */\n\tpublic LocalSessionFactoryBuilder(@Nullable DataSource dataSource, ClassLoader classLoader) {\n\t\tthis(dataSource, new PathMatchingResourcePatternResolver(classLoader));\n\t}\n\n\t/**\n\t * Create a new LocalSessionFactoryBuilder for the given DataSource.\n\t * @param dataSource the JDBC DataSource that the resulting Hibernate SessionFactory should be using\n\t * (may be {@code null})\n\t * @param resourceLoader the ResourceLoader to load application classes from\n\t */\n\tpublic LocalSessionFactoryBuilder(@Nullable DataSource dataSource, ResourceLoader resourceLoader) {\n\t\tthis(dataSource, resourceLoader, new MetadataSources(\n\t\t\t\tnew BootstrapServiceRegistryBuilder().applyClassLoader(resourceLoader.getClassLoader()).build()));\n\t}\n\n\t/**\n\t * Create a new LocalSessionFactoryBuilder for the given DataSource.\n\t * @param dataSource the JDBC DataSource that the resulting Hibernate SessionFactory should be using\n\t * (may be {@code null})\n\t * @param resourceLoader the ResourceLoader to load application classes from\n\t * @param metadataSources the Hibernate MetadataSources service to use (e.g. reusing an existing one)\n\t * @since 4.3\n\t */\n\tpublic LocalSessionFactoryBuilder(\n\t\t\t@Nullable DataSource dataSource, ResourceLoader resourceLoader, MetadataSources metadataSources) {\n\n\t\tsuper(metadataSources);\n\n\t\tgetProperties().put(AvailableSettings.CURRENT_SESSION_CONTEXT_CLASS, SpringSessionContext.class.getName());\n\t\tif (dataSource != null) {\n\t\t\tgetProperties().put(AvailableSettings.DATASOURCE, dataSource);\n\t\t}\n\t\tgetProperties().put(AvailableSettings.CONNECTION_HANDLING,\n\t\t\t\tPhysicalConnectionHandlingMode.DELAYED_ACQUISITION_AND_HOLD);\n\n\t\tgetProperties().put(AvailableSettings.CLASSLOADERS, Collections.singleton(resourceLoader.getClassLoader()));\n\t\tthis.resourcePatternResolver = ResourcePatternUtils.getResourcePatternResolver(resourceLoader);\n\t}\n\n\n\t/**\n\t * Set the Spring {@link JtaTransactionManager} or the JTA {@link TransactionManager}\n\t * to be used with Hibernate, if any. Allows for using a Spring-managed transaction\n\t * manager for Hibernate 5's session and cache synchronization, with the\n\t * \"hibernate.transaction.jta.platform\" automatically set to it.\n\t * <p>A passed-in Spring {@link JtaTransactionManager} needs to contain a JTA\n\t * {@link TransactionManager} reference to be usable here, except for the WebSphere\n\t * case where we'll automatically set {@code WebSphereExtendedJtaPlatform} accordingly.\n\t * <p>Note: If this is set, the Hibernate settings should not contain a JTA platform\n\t * setting to avoid meaningless double configuration.\n\t */\n\tpublic LocalSessionFactoryBuilder setJtaTransactionManager(Object jtaTransactionManager) {\n\t\tAssert.notNull(jtaTransactionManager, \"Transaction manager reference must not be null\");\n\n\t\tif (jtaTransactionManager instanceof JtaTransactionManager springJtaTm) {\n\t\t\tboolean webspherePresent = ClassUtils.isPresent(\"com.ibm.wsspi.uow.UOWManager\", getClass().getClassLoader());\n\t\t\tif (webspherePresent) {\n\t\t\t\tgetProperties().put(AvailableSettings.JTA_PLATFORM,\n\t\t\t\t\t\t\"org.hibernate.engine.transaction.jta.platform.internal.WebSphereExtendedJtaPlatform\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (springJtaTm.getTransactionManager() == null) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\t\"Can only apply JtaTransactionManager which has a TransactionManager reference set\");\n\t\t\t\t}\n\t\t\t\tgetProperties().put(AvailableSettings.JTA_PLATFORM,\n\t\t\t\t\t\tnew ConfigurableJtaPlatform(springJtaTm.getTransactionManager(), springJtaTm.getUserTransaction(),\n\t\t\t\t\t\t\t\tspringJtaTm.getTransactionSynchronizationRegistry()));\n\t\t\t}\n\t\t}\n\t\telse if (jtaTransactionManager instanceof TransactionManager jtaTm) {\n\t\t\tgetProperties().put(AvailableSettings.JTA_PLATFORM,\n\t\t\t\t\tnew ConfigurableJtaPlatform(jtaTm, null, null));\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Unknown transaction manager type: \" + jtaTransactionManager.getClass().getName());\n\t\t}\n\n\t\tgetProperties().put(AvailableSettings.TRANSACTION_COORDINATOR_STRATEGY, \"jta\");\n\t\tgetProperties().put(AvailableSettings.CONNECTION_HANDLING,\n\t\t\t\tPhysicalConnectionHandlingMode.DELAYED_ACQUISITION_AND_RELEASE_AFTER_STATEMENT);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set a Hibernate {@link org.hibernate.resource.beans.container.spi.BeanContainer}\n\t * for the given Spring {@link ConfigurableListableBeanFactory}.\n\t * <p>This enables autowiring of Hibernate attribute converters and entity listeners.\n\t * @since 5.1\n\t * @see SpringBeanContainer\n\t * @see AvailableSettings#BEAN_CONTAINER\n\t */\n\tpublic LocalSessionFactoryBuilder setBeanContainer(ConfigurableListableBeanFactory beanFactory) {\n\t\tgetProperties().put(AvailableSettings.BEAN_CONTAINER, new SpringBeanContainer(beanFactory));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the Hibernate {@link RegionFactory} to use for the SessionFactory.\n\t * Allows for using a Spring-managed {@code RegionFactory} instance.\n\t * <p>Note: If this is set, the Hibernate settings should not define a\n\t * cache provider to avoid meaningless double configuration.\n\t * @since 5.1\n\t * @see AvailableSettings#CACHE_REGION_FACTORY\n\t */\n\tpublic LocalSessionFactoryBuilder setCacheRegionFactory(RegionFactory cacheRegionFactory) {\n\t\tgetProperties().put(AvailableSettings.CACHE_REGION_FACTORY, cacheRegionFactory);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set a {@link MultiTenantConnectionProvider} to be passed on to the SessionFactory.\n\t * @since 4.3\n\t * @see AvailableSettings#MULTI_TENANT_CONNECTION_PROVIDER\n\t */\n\tpublic LocalSessionFactoryBuilder setMultiTenantConnectionProvider(MultiTenantConnectionProvider multiTenantConnectionProvider) {\n\t\tgetProperties().put(AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER, multiTenantConnectionProvider);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Overridden to reliably pass a {@link CurrentTenantIdentifierResolver} to the SessionFactory.\n\t * @since 4.3.2\n\t * @see AvailableSettings#MULTI_TENANT_IDENTIFIER_RESOLVER\n\t */\n\t@Override\n\tpublic void setCurrentTenantIdentifierResolver(CurrentTenantIdentifierResolver currentTenantIdentifierResolver) {\n\t\tgetProperties().put(AvailableSettings.MULTI_TENANT_IDENTIFIER_RESOLVER, currentTenantIdentifierResolver);\n\t\tsuper.setCurrentTenantIdentifierResolver(currentTenantIdentifierResolver);\n\t}\n\n\t/**\n\t * Specify custom type filters for Spring-based scanning for entity classes.\n\t * <p>Default is to search all specified packages for classes annotated with\n\t * {@code @jakarta.persistence.Entity}, {@code @jakarta.persistence.Embeddable}\n\t * or {@code @jakarta.persistence.MappedSuperclass}.\n\t * @see #scanPackages\n\t */\n\tpublic LocalSessionFactoryBuilder setEntityTypeFilters(TypeFilter... entityTypeFilters) {\n\t\tthis.entityTypeFilters = entityTypeFilters;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add the given annotated classes in a batch.\n\t * @see #addAnnotatedClass\n\t * @see #scanPackages\n\t */\n\tpublic LocalSessionFactoryBuilder addAnnotatedClasses(Class<?>... annotatedClasses) {\n\t\tfor (Class<?> annotatedClass : annotatedClasses) {\n\t\t\taddAnnotatedClass(annotatedClass);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add the given annotated packages in a batch.\n\t * @see #addPackage\n\t * @see #scanPackages\n\t */\n\tpublic LocalSessionFactoryBuilder addPackages(String... annotatedPackages) {\n\t\tfor (String annotatedPackage : annotatedPackages) {\n\t\t\taddPackage(annotatedPackage);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Perform Spring-based scanning for entity classes, registering them\n\t * as annotated classes with this {@code Configuration}.\n\t * @param packagesToScan one or more Java package names\n\t * @throws HibernateException if scanning fails for any reason\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic LocalSessionFactoryBuilder scanPackages(String... packagesToScan) throws HibernateException {\n\t\tSet<String> entityClassNames = new TreeSet<>();\n\t\tSet<String> converterClassNames = new TreeSet<>();\n\t\tSet<String> packageNames = new TreeSet<>();\n\t\ttry {\n\t\t\tfor (String pkg : packagesToScan) {\n\t\t\t\tString pattern = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +\n\t\t\t\t\t\tClassUtils.convertClassNameToResourcePath(pkg) + RESOURCE_PATTERN;\n\t\t\t\tResource[] resources = this.resourcePatternResolver.getResources(pattern);\n\t\t\t\tMetadataReaderFactory readerFactory = new CachingMetadataReaderFactory(this.resourcePatternResolver);\n\t\t\t\tfor (Resource resource : resources) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tMetadataReader reader = readerFactory.getMetadataReader(resource);\n\t\t\t\t\t\tString className = reader.getClassMetadata().getClassName();\n\t\t\t\t\t\tif (matchesEntityTypeFilter(reader, readerFactory)) {\n\t\t\t\t\t\t\tentityClassNames.add(className);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (CONVERTER_TYPE_FILTER.match(reader, readerFactory)) {\n\t\t\t\t\t\t\tconverterClassNames.add(className);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (className.endsWith(PACKAGE_INFO_SUFFIX)) {\n\t\t\t\t\t\t\tpackageNames.add(className.substring(0, className.length() - PACKAGE_INFO_SUFFIX.length()));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (FileNotFoundException ex) {\n\t\t\t\t\t\t// Ignore non-readable resource\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new MappingException(\"Failed to scan classpath for unlisted classes\", ex);\n\t\t}\n\t\ttry {\n\t\t\tClassLoader cl = this.resourcePatternResolver.getClassLoader();\n\t\t\tfor (String className : entityClassNames) {\n\t\t\t\taddAnnotatedClass(ClassUtils.forName(className, cl));\n\t\t\t}\n\t\t\tfor (String className : converterClassNames) {\n\t\t\t\taddAttributeConverter((Class<? extends AttributeConverter<?, ?>>) ClassUtils.forName(className, cl));\n\t\t\t}\n\t\t\tfor (String packageName : packageNames) {\n\t\t\t\taddPackage(packageName);\n\t\t\t}\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\tthrow new MappingException(\"Failed to load annotated classes from classpath\", ex);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Check whether any of the configured entity type filters matches\n\t * the current class descriptor contained in the metadata reader.\n\t */\n\tprivate boolean matchesEntityTypeFilter(MetadataReader reader, MetadataReaderFactory readerFactory) throws IOException {\n\t\tif (this.entityTypeFilters != null) {\n\t\t\tfor (TypeFilter filter : this.entityTypeFilters) {\n\t\t\t\tif (filter.match(reader, readerFactory)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Build the Hibernate {@code SessionFactory} through background bootstrapping,\n\t * using the given executor for a parallel initialization phase\n\t * (e.g. a {@link org.springframework.core.task.SimpleAsyncTaskExecutor}).\n\t * <p>{@code SessionFactory} initialization will then switch into background\n\t * bootstrap mode, with a {@code SessionFactory} proxy immediately returned for\n\t * injection purposes instead of waiting for Hibernate's bootstrapping to complete.\n\t * However, note that the first actual call to a {@code SessionFactory} method will\n\t * then block until Hibernate's bootstrapping completed, if not ready by then.\n\t * For maximum benefit, make sure to avoid early {@code SessionFactory} calls\n\t * in init methods of related beans, even for metadata introspection purposes.\n\t * @since 4.3\n\t * @see #buildSessionFactory()\n\t */\n\tpublic SessionFactory buildSessionFactory(AsyncTaskExecutor bootstrapExecutor) {\n\t\tAssert.notNull(bootstrapExecutor, \"AsyncTaskExecutor must not be null\");\n\t\treturn (SessionFactory) Proxy.newProxyInstance(this.resourcePatternResolver.getClassLoader(),\n\t\t\t\tnew Class<?>[] {SessionFactoryImplementor.class, InfrastructureProxy.class},\n\t\t\t\tnew BootstrapSessionFactoryInvocationHandler(bootstrapExecutor));\n\t}\n\n\n\t/**\n\t * Proxy invocation handler for background bootstrapping, only enforcing\n\t * a fully initialized target {@code SessionFactory} when actually needed.\n\t * @since 4.3\n\t */\n\tprivate class BootstrapSessionFactoryInvocationHandler implements InvocationHandler {\n\n\t\tprivate final Future<SessionFactory> sessionFactoryFuture;\n\n\t\tpublic BootstrapSessionFactoryInvocationHandler(AsyncTaskExecutor bootstrapExecutor) {\n\t\t\tthis.sessionFactoryFuture = bootstrapExecutor.submit(\n\t\t\t\t\t(Callable<SessionFactory>) LocalSessionFactoryBuilder.this::buildSessionFactory);\n\t\t}\n\n\t\t@Override\n\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\tswitch (method.getName()) {\n\t\t\t\tcase \"equals\":\n\t\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\t\treturn (proxy == args[0]);\n\t\t\t\tcase \"hashCode\":\n\t\t\t\t\t// Use hashCode of EntityManagerFactory proxy.\n\t\t\t\t\treturn System.identityHashCode(proxy);\n\t\t\t\tcase \"getProperties\":\n\t\t\t\t\treturn getProperties();\n\t\t\t\tcase \"getWrappedObject\":\n\t\t\t\t\t// Call coming in through InfrastructureProxy interface...\n\t\t\t\t\treturn getSessionFactory();\n\t\t\t}\n\n\t\t\t// Regular delegation to the target SessionFactory,\n\t\t\t// enforcing its full initialization...\n\t\t\ttry {\n\t\t\t\treturn method.invoke(getSessionFactory(), args);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow ex.getTargetException();\n\t\t\t}\n\t\t}\n\n\t\tprivate SessionFactory getSessionFactory() {\n\t\t\ttry {\n\t\t\t\treturn this.sessionFactoryFuture.get();\n\t\t\t}\n\t\t\tcatch (InterruptedException ex) {\n\t\t\t\tThread.currentThread().interrupt();\n\t\t\t\tthrow new IllegalStateException(\"Interrupted during initialization of Hibernate SessionFactory\", ex);\n\t\t\t}\n\t\t\tcatch (ExecutionException ex) {\n\t\t\t\tThrowable cause = ex.getCause();\n\t\t\t\tif (cause instanceof HibernateException hibernateException) {\n\t\t\t\t\t// Rethrow a provider configuration exception (possibly with a nested cause) directly\n\t\t\t\t\tthrow hibernateException;\n\t\t\t\t}\n\t\t\t\tthrow new IllegalStateException(\"Failed to asynchronously initialize Hibernate SessionFactory: \" +\n\t\t\t\t\t\tex.getMessage(), cause);\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBuilder#addAnnotatedClasses(annotatedClasses)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given annotated classes in a batch.\n\t * @see #addAnnotatedClass\n\t * @see #scanPackages\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedClasses"
    ],
    "position": {
      "column": 1,
      "line": 285
    },
    "return": "LocalSessionFactoryBuilder",
    "signature": "public LocalSessionFactoryBuilder addAnnotatedClasses(Class<?>... annotatedClasses)",
    "source_code": "\tpublic LocalSessionFactoryBuilder addAnnotatedClasses(Class<?>... annotatedClasses) {\n\t\tfor (Class<?> annotatedClass : annotatedClasses) {\n\t\t\taddAnnotatedClass(annotatedClass);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBuilder#addPackages(annotatedPackages)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given annotated packages in a batch.\n\t * @see #addPackage\n\t * @see #scanPackages\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedPackages"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "LocalSessionFactoryBuilder",
    "signature": "public LocalSessionFactoryBuilder addPackages(String... annotatedPackages)",
    "source_code": "\tpublic LocalSessionFactoryBuilder addPackages(String... annotatedPackages) {\n\t\tfor (String annotatedPackage : annotatedPackages) {\n\t\t\taddPackage(annotatedPackage);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBuilder#buildSessionFactory(bootstrapExecutor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build the Hibernate {@code SessionFactory} through background bootstrapping,\n\t * using the given executor for a parallel initialization phase\n\t * (e.g. a {@link org.springframework.core.task.SimpleAsyncTaskExecutor}).\n\t * <p>{@code SessionFactory} initialization will then switch into background\n\t * bootstrap mode, with a {@code SessionFactory} proxy immediately returned for\n\t * injection purposes instead of waiting for Hibernate's bootstrapping to complete.\n\t * However, note that the first actual call to a {@code SessionFactory} method will\n\t * then block until Hibernate's bootstrapping completed, if not ready by then.\n\t * For maximum benefit, make sure to avoid early {@code SessionFactory} calls\n\t * in init methods of related beans, even for metadata introspection purposes.\n\t * @since 4.3\n\t * @see #buildSessionFactory()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bootstrapExecutor"
    ],
    "position": {
      "column": 1,
      "line": 391
    },
    "return": "SessionFactory",
    "signature": "public SessionFactory buildSessionFactory(AsyncTaskExecutor bootstrapExecutor)",
    "source_code": "\tpublic SessionFactory buildSessionFactory(AsyncTaskExecutor bootstrapExecutor) {\n\t\tAssert.notNull(bootstrapExecutor, \"AsyncTaskExecutor must not be null\");\n\t\treturn (SessionFactory) Proxy.newProxyInstance(this.resourcePatternResolver.getClassLoader(),\n\t\t\t\tnew Class<?>[] {SessionFactoryImplementor.class, InfrastructureProxy.class},\n\t\t\t\tnew BootstrapSessionFactoryInvocationHandler(bootstrapExecutor));\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBuilder#invoke(proxy,method,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 414
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\tswitch (method.getName()) {\n\t\t\t\tcase \"equals\":\n\t\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\t\treturn (proxy == args[0]);\n\t\t\t\tcase \"hashCode\":\n\t\t\t\t\t// Use hashCode of EntityManagerFactory proxy.\n\t\t\t\t\treturn System.identityHashCode(proxy);\n\t\t\t\tcase \"getProperties\":\n\t\t\t\t\treturn getProperties();\n\t\t\t\tcase \"getWrappedObject\":\n\t\t\t\t\t// Call coming in through InfrastructureProxy interface...\n\t\t\t\t\treturn getSessionFactory();\n\t\t\t}\n\n\t\t\t// Regular delegation to the target SessionFactory,\n\t\t\t// enforcing its full initialization...\n\t\t\ttry {\n\t\t\t\treturn method.invoke(getSessionFactory(), args);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow ex.getTargetException();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBuilder#scanPackages(packagesToScan)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform Spring-based scanning for entity classes, registering them\n\t * as annotated classes with this {@code Configuration}.\n\t * @param packagesToScan one or more Java package names\n\t * @throws HibernateException if scanning fails for any reason\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "packagesToScan"
    ],
    "position": {
      "column": 1,
      "line": 311
    },
    "return": "LocalSessionFactoryBuilder",
    "signature": "public LocalSessionFactoryBuilder scanPackages(String... packagesToScan)",
    "source_code": "\tpublic LocalSessionFactoryBuilder scanPackages(String... packagesToScan) throws HibernateException {\n\t\tSet<String> entityClassNames = new TreeSet<>();\n\t\tSet<String> converterClassNames = new TreeSet<>();\n\t\tSet<String> packageNames = new TreeSet<>();\n\t\ttry {\n\t\t\tfor (String pkg : packagesToScan) {\n\t\t\t\tString pattern = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +\n\t\t\t\t\t\tClassUtils.convertClassNameToResourcePath(pkg) + RESOURCE_PATTERN;\n\t\t\t\tResource[] resources = this.resourcePatternResolver.getResources(pattern);\n\t\t\t\tMetadataReaderFactory readerFactory = new CachingMetadataReaderFactory(this.resourcePatternResolver);\n\t\t\t\tfor (Resource resource : resources) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tMetadataReader reader = readerFactory.getMetadataReader(resource);\n\t\t\t\t\t\tString className = reader.getClassMetadata().getClassName();\n\t\t\t\t\t\tif (matchesEntityTypeFilter(reader, readerFactory)) {\n\t\t\t\t\t\t\tentityClassNames.add(className);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (CONVERTER_TYPE_FILTER.match(reader, readerFactory)) {\n\t\t\t\t\t\t\tconverterClassNames.add(className);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (className.endsWith(PACKAGE_INFO_SUFFIX)) {\n\t\t\t\t\t\t\tpackageNames.add(className.substring(0, className.length() - PACKAGE_INFO_SUFFIX.length()));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (FileNotFoundException ex) {\n\t\t\t\t\t\t// Ignore non-readable resource\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new MappingException(\"Failed to scan classpath for unlisted classes\", ex);\n\t\t}\n\t\ttry {\n\t\t\tClassLoader cl = this.resourcePatternResolver.getClassLoader();\n\t\t\tfor (String className : entityClassNames) {\n\t\t\t\taddAnnotatedClass(ClassUtils.forName(className, cl));\n\t\t\t}\n\t\t\tfor (String className : converterClassNames) {\n\t\t\t\taddAttributeConverter((Class<? extends AttributeConverter<?, ?>>) ClassUtils.forName(className, cl));\n\t\t\t}\n\t\t\tfor (String packageName : packageNames) {\n\t\t\t\taddPackage(packageName);\n\t\t\t}\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\tthrow new MappingException(\"Failed to load annotated classes from classpath\", ex);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBuilder#setBeanContainer(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a Hibernate {@link org.hibernate.resource.beans.container.spi.BeanContainer}\n\t * for the given Spring {@link ConfigurableListableBeanFactory}.\n\t * <p>This enables autowiring of Hibernate attribute converters and entity listeners.\n\t * @since 5.1\n\t * @see SpringBeanContainer\n\t * @see AvailableSettings#BEAN_CONTAINER\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "LocalSessionFactoryBuilder",
    "signature": "public LocalSessionFactoryBuilder setBeanContainer(ConfigurableListableBeanFactory beanFactory)",
    "source_code": "\tpublic LocalSessionFactoryBuilder setBeanContainer(ConfigurableListableBeanFactory beanFactory) {\n\t\tgetProperties().put(AvailableSettings.BEAN_CONTAINER, new SpringBeanContainer(beanFactory));\n\t\treturn this;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBuilder#setCacheRegionFactory(cacheRegionFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Hibernate {@link RegionFactory} to use for the SessionFactory.\n\t * Allows for using a Spring-managed {@code RegionFactory} instance.\n\t * <p>Note: If this is set, the Hibernate settings should not define a\n\t * cache provider to avoid meaningless double configuration.\n\t * @since 5.1\n\t * @see AvailableSettings#CACHE_REGION_FACTORY\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cacheRegionFactory"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "LocalSessionFactoryBuilder",
    "signature": "public LocalSessionFactoryBuilder setCacheRegionFactory(RegionFactory cacheRegionFactory)",
    "source_code": "\tpublic LocalSessionFactoryBuilder setCacheRegionFactory(RegionFactory cacheRegionFactory) {\n\t\tgetProperties().put(AvailableSettings.CACHE_REGION_FACTORY, cacheRegionFactory);\n\t\treturn this;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBuilder#setCurrentTenantIdentifierResolver(currentTenantIdentifierResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Overridden to reliably pass a {@link CurrentTenantIdentifierResolver} to the SessionFactory.\n\t * @since 4.3.2\n\t * @see AvailableSettings#MULTI_TENANT_IDENTIFIER_RESOLVER\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "currentTenantIdentifierResolver"
    ],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "void",
    "signature": "public void setCurrentTenantIdentifierResolver(CurrentTenantIdentifierResolver currentTenantIdentifierResolver)",
    "source_code": "\tpublic void setCurrentTenantIdentifierResolver(CurrentTenantIdentifierResolver currentTenantIdentifierResolver) {\n\t\tgetProperties().put(AvailableSettings.MULTI_TENANT_IDENTIFIER_RESOLVER, currentTenantIdentifierResolver);\n\t\tsuper.setCurrentTenantIdentifierResolver(currentTenantIdentifierResolver);\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBuilder#setEntityTypeFilters(entityTypeFilters)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify custom type filters for Spring-based scanning for entity classes.\n\t * <p>Default is to search all specified packages for classes annotated with\n\t * {@code @jakarta.persistence.Entity}, {@code @jakarta.persistence.Embeddable}\n\t * or {@code @jakarta.persistence.MappedSuperclass}.\n\t * @see #scanPackages\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityTypeFilters"
    ],
    "position": {
      "column": 1,
      "line": 275
    },
    "return": "LocalSessionFactoryBuilder",
    "signature": "public LocalSessionFactoryBuilder setEntityTypeFilters(TypeFilter... entityTypeFilters)",
    "source_code": "\tpublic LocalSessionFactoryBuilder setEntityTypeFilters(TypeFilter... entityTypeFilters) {\n\t\tthis.entityTypeFilters = entityTypeFilters;\n\t\treturn this;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBuilder#setJtaTransactionManager(jtaTransactionManager)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Spring {@link JtaTransactionManager} or the JTA {@link TransactionManager}\n\t * to be used with Hibernate, if any. Allows for using a Spring-managed transaction\n\t * manager for Hibernate 5's session and cache synchronization, with the\n\t * \"hibernate.transaction.jta.platform\" automatically set to it.\n\t * <p>A passed-in Spring {@link JtaTransactionManager} needs to contain a JTA\n\t * {@link TransactionManager} reference to be usable here, except for the WebSphere\n\t * case where we'll automatically set {@code WebSphereExtendedJtaPlatform} accordingly.\n\t * <p>Note: If this is set, the Hibernate settings should not contain a JTA platform\n\t * setting to avoid meaningless double configuration.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "jtaTransactionManager"
    ],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "LocalSessionFactoryBuilder",
    "signature": "public LocalSessionFactoryBuilder setJtaTransactionManager(Object jtaTransactionManager)",
    "source_code": "\tpublic LocalSessionFactoryBuilder setJtaTransactionManager(Object jtaTransactionManager) {\n\t\tAssert.notNull(jtaTransactionManager, \"Transaction manager reference must not be null\");\n\n\t\tif (jtaTransactionManager instanceof JtaTransactionManager springJtaTm) {\n\t\t\tboolean webspherePresent = ClassUtils.isPresent(\"com.ibm.wsspi.uow.UOWManager\", getClass().getClassLoader());\n\t\t\tif (webspherePresent) {\n\t\t\t\tgetProperties().put(AvailableSettings.JTA_PLATFORM,\n\t\t\t\t\t\t\"org.hibernate.engine.transaction.jta.platform.internal.WebSphereExtendedJtaPlatform\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (springJtaTm.getTransactionManager() == null) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\t\"Can only apply JtaTransactionManager which has a TransactionManager reference set\");\n\t\t\t\t}\n\t\t\t\tgetProperties().put(AvailableSettings.JTA_PLATFORM,\n\t\t\t\t\t\tnew ConfigurableJtaPlatform(springJtaTm.getTransactionManager(), springJtaTm.getUserTransaction(),\n\t\t\t\t\t\t\t\tspringJtaTm.getTransactionSynchronizationRegistry()));\n\t\t\t}\n\t\t}\n\t\telse if (jtaTransactionManager instanceof TransactionManager jtaTm) {\n\t\t\tgetProperties().put(AvailableSettings.JTA_PLATFORM,\n\t\t\t\t\tnew ConfigurableJtaPlatform(jtaTm, null, null));\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Unknown transaction manager type: \" + jtaTransactionManager.getClass().getName());\n\t\t}\n\n\t\tgetProperties().put(AvailableSettings.TRANSACTION_COORDINATOR_STRATEGY, \"jta\");\n\t\tgetProperties().put(AvailableSettings.CONNECTION_HANDLING,\n\t\t\t\tPhysicalConnectionHandlingMode.DELAYED_ACQUISITION_AND_RELEASE_AFTER_STATEMENT);\n\n\t\treturn this;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBuilder#setMultiTenantConnectionProvider(multiTenantConnectionProvider)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a {@link MultiTenantConnectionProvider} to be passed on to the SessionFactory.\n\t * @since 4.3\n\t * @see AvailableSettings#MULTI_TENANT_CONNECTION_PROVIDER\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "multiTenantConnectionProvider"
    ],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "LocalSessionFactoryBuilder",
    "signature": "public LocalSessionFactoryBuilder setMultiTenantConnectionProvider(MultiTenantConnectionProvider multiTenantConnectionProvider)",
    "source_code": "\tpublic LocalSessionFactoryBuilder setMultiTenantConnectionProvider(MultiTenantConnectionProvider multiTenantConnectionProvider) {\n\t\tgetProperties().put(AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER, multiTenantConnectionProvider);\n\t\treturn this;\n\t}"
  },
  "org.springframework.orm.hibernate5.SpringFlushSynchronization": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Simple synchronization adapter that propagates a {@code flush()} call\n * to the underlying Hibernate Session. Used in combination with JTA.\n *\n * @author Juergen Hoeller\n * @since 4.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 31
    },
    "signature": "public class SpringFlushSynchronization",
    "source_code": "public class SpringFlushSynchronization implements TransactionSynchronization {\n\n\tprivate final Session session;\n\n\n\tpublic SpringFlushSynchronization(Session session) {\n\t\tthis.session = session;\n\t}\n\n\n\t@Override\n\tpublic void flush() {\n\t\tSessionFactoryUtils.flush(this.session, false);\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof SpringFlushSynchronization that && this.session == that.session));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.session.hashCode();\n\t}\n\n}"
  },
  "org.springframework.orm.hibernate5.SpringFlushSynchronization#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof SpringFlushSynchronization that && this.session == that.session));\n\t}"
  },
  "org.springframework.orm.hibernate5.SpringFlushSynchronization#flush()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 42
    },
    "return": "void",
    "signature": "public void flush()",
    "source_code": "\tpublic void flush() {\n\t\tSessionFactoryUtils.flush(this.session, false);\n\t}"
  },
  "org.springframework.orm.hibernate5.SpringFlushSynchronization#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 53
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.session.hashCode();\n\t}"
  },
  "org.springframework.orm.hibernate5.logger": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link org.springframework.beans.factory.FactoryBean} that creates a JPA\n * {@link jakarta.persistence.EntityManagerFactory} according to JPA's standard\n * <i>container</i> bootstrap contract. This is the most powerful way to set\n * up a shared JPA EntityManagerFactory in a Spring application context;\n * the EntityManagerFactory can then be passed to JPA-based DAOs via\n * dependency injection. Note that switching to a JNDI lookup or to a\n * {@link LocalEntityManagerFactoryBean} definition is just a matter of\n * configuration!\n *\n * <p>As with {@link LocalEntityManagerFactoryBean}, configuration settings\n * are usually read in from a {@code META-INF/persistence.xml} config file,\n * residing in the class path, according to the general JPA configuration contract.\n * However, this FactoryBean is more flexible in that you can override the location\n * of the {@code persistence.xml} file, specify the JDBC DataSources to link to,\n * etc. Furthermore, it allows for pluggable class instrumentation through Spring's\n * {@link org.springframework.instrument.classloading.LoadTimeWeaver} abstraction,\n * instead of being tied to a special VM agent specified on JVM startup.\n *\n * <p>Internally, this FactoryBean parses the {@code persistence.xml} file\n * itself and creates a corresponding {@link jakarta.persistence.spi.PersistenceUnitInfo}\n * object (with further configuration merged in, such as JDBC DataSources and the\n * Spring LoadTimeWeaver), to be passed to the chosen JPA\n * {@link jakarta.persistence.spi.PersistenceProvider}. This corresponds to a\n * local JPA container with full support for the standard JPA container contract.\n *\n * <p>The exposed EntityManagerFactory object will implement all the interfaces of\n * the underlying native EntityManagerFactory returned by the PersistenceProvider,\n * plus the {@link EntityManagerFactoryInfo} interface which exposes additional\n * metadata as assembled by this FactoryBean.\n *\n * @author Juergen Hoeller\n * @author Rod Johnson\n * @since 2.0\n * @see #setPersistenceXmlLocation\n * @see #setJpaProperties\n * @see #setJpaVendorAdapter\n * @see #setLoadTimeWeaver\n * @see #setDataSource\n * @see EntityManagerFactoryInfo\n * @see LocalEntityManagerFactoryBean\n * @see org.springframework.orm.jpa.support.SharedEntityManagerBean\n * @see jakarta.persistence.spi.PersistenceProvider#createContainerEntityManagerFactory\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "signature": "public class LocalContainerEntityManagerFactoryBean",
    "source_code": "public class LocalContainerEntityManagerFactoryBean extends AbstractEntityManagerFactoryBean"
  },
  "org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 336
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() throws PersistenceException {\n\t\tPersistenceUnitManager managerToUse = this.persistenceUnitManager;\n\t\tif (this.persistenceUnitManager == null) {\n\t\t\tthis.internalPersistenceUnitManager.afterPropertiesSet();\n\t\t\tmanagerToUse = this.internalPersistenceUnitManager;\n\t\t}\n\n\t\tthis.persistenceUnitInfo = determinePersistenceUnitInfo(managerToUse);\n\t\tJpaVendorAdapter jpaVendorAdapter = getJpaVendorAdapter();\n\t\tif (jpaVendorAdapter != null && this.persistenceUnitInfo instanceof SmartPersistenceUnitInfo smartInfo) {\n\t\t\tString rootPackage = jpaVendorAdapter.getPersistenceProviderRootPackage();\n\t\t\tif (rootPackage != null) {\n\t\t\t\tsmartInfo.setPersistenceProviderPackageName(rootPackage);\n\t\t\t}\n\t\t}\n\n\t\tsuper.afterPropertiesSet();\n\t}"
  },
  "org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean#createNativeEntityManagerFactory()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 356
    },
    "return": "EntityManagerFactory",
    "signature": "protected EntityManagerFactory createNativeEntityManagerFactory()",
    "source_code": "\tprotected EntityManagerFactory createNativeEntityManagerFactory() throws PersistenceException {\n\t\tAssert.state(this.persistenceUnitInfo != null, \"PersistenceUnitInfo not initialized\");\n\n\t\tPersistenceProvider provider = getPersistenceProvider();\n\t\tif (provider == null) {\n\t\t\tString providerClassName = this.persistenceUnitInfo.getPersistenceProviderClassName();\n\t\t\tif (providerClassName == null) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"No PersistenceProvider specified in EntityManagerFactory configuration, \" +\n\t\t\t\t\t\t\"and chosen PersistenceUnitInfo does not specify a provider class name either\");\n\t\t\t}\n\t\t\tClass<?> providerClass = ClassUtils.resolveClassName(providerClassName, getBeanClassLoader());\n\t\t\tprovider = (PersistenceProvider) BeanUtils.instantiateClass(providerClass);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Building JPA container EntityManagerFactory for persistence unit '\" +\n\t\t\t\t\tthis.persistenceUnitInfo.getPersistenceUnitName() + \"'\");\n\t\t}\n\t\tEntityManagerFactory emf =\n\t\t\t\tprovider.createContainerEntityManagerFactory(this.persistenceUnitInfo, getJpaPropertyMap());\n\t\tpostProcessEntityManagerFactory(emf, this.persistenceUnitInfo);\n\n\t\treturn emf;\n\t}"
  },
  "org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean#determinePersistenceUnitInfo(persistenceUnitManager)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the PersistenceUnitInfo to use for the EntityManagerFactory\n\t * created by this bean.\n\t * <p>The default implementation reads in all persistence unit infos from\n\t * {@code persistence.xml}, as defined in the JPA specification.\n\t * If no entity manager name was specified, it takes the first info in the\n\t * array as returned by the reader. Otherwise, it checks for a matching name.\n\t * @param persistenceUnitManager the PersistenceUnitManager to obtain from\n\t * @return the chosen PersistenceUnitInfo\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "persistenceUnitManager"
    ],
    "position": {
      "column": 1,
      "line": 393
    },
    "return": "PersistenceUnitInfo",
    "signature": "protected PersistenceUnitInfo determinePersistenceUnitInfo(PersistenceUnitManager persistenceUnitManager)",
    "source_code": "\tprotected PersistenceUnitInfo determinePersistenceUnitInfo(PersistenceUnitManager persistenceUnitManager) {\n\t\tif (getPersistenceUnitName() != null) {\n\t\t\treturn persistenceUnitManager.obtainPersistenceUnitInfo(getPersistenceUnitName());\n\t\t}\n\t\telse {\n\t\t\treturn persistenceUnitManager.obtainDefaultPersistenceUnitInfo();\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean#getDataSource()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 430
    },
    "return": "DataSource",
    "signature": "public DataSource getDataSource()",
    "source_code": "\tpublic DataSource getDataSource() {\n\t\tif (this.persistenceUnitInfo != null) {\n\t\t\treturn (this.persistenceUnitInfo.getJtaDataSource() != null ?\n\t\t\t\t\tthis.persistenceUnitInfo.getJtaDataSource() :\n\t\t\t\t\tthis.persistenceUnitInfo.getNonJtaDataSource());\n\t\t}\n\t\treturn (this.internalPersistenceUnitManager.getDefaultJtaDataSource() != null ?\n\t\t\t\tthis.internalPersistenceUnitManager.getDefaultJtaDataSource() :\n\t\t\t\tthis.internalPersistenceUnitManager.getDefaultDataSource());\n\t}"
  },
  "org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean#getPersistenceUnitInfo()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 416
    },
    "return": "PersistenceUnitInfo",
    "signature": "public PersistenceUnitInfo getPersistenceUnitInfo()",
    "source_code": "\tpublic PersistenceUnitInfo getPersistenceUnitInfo() {\n\t\treturn this.persistenceUnitInfo;\n\t}"
  },
  "org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean#getPersistenceUnitName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 422
    },
    "return": "String",
    "signature": "public String getPersistenceUnitName()",
    "source_code": "\tpublic String getPersistenceUnitName() {\n\t\tif (this.persistenceUnitInfo != null) {\n\t\t\treturn this.persistenceUnitInfo.getPersistenceUnitName();\n\t\t}\n\t\treturn super.getPersistenceUnitName();\n\t}"
  },
  "org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean#postProcessEntityManagerFactory(emf,pui)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Hook method allowing subclasses to customize the EntityManagerFactory\n\t * after its creation via the PersistenceProvider.\n\t * <p>The default implementation is empty.\n\t * @param emf the newly created EntityManagerFactory we are working with\n\t * @param pui the PersistenceUnitInfo used to configure the EntityManagerFactory\n\t * @see jakarta.persistence.spi.PersistenceProvider#createContainerEntityManagerFactory\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "emf",
      "pui"
    ],
    "position": {
      "column": 1,
      "line": 410
    },
    "return": "void",
    "signature": "protected void postProcessEntityManagerFactory(EntityManagerFactory emf, PersistenceUnitInfo pui)",
    "source_code": "\tprotected void postProcessEntityManagerFactory(EntityManagerFactory emf, PersistenceUnitInfo pui) {\n\t}"
  },
  "org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean#setDataSource(dataSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the JDBC DataSource that the JPA persistence provider is supposed\n\t * to use for accessing the database. This is an alternative to keeping the\n\t * JDBC configuration in {@code persistence.xml}, passing in a Spring-managed\n\t * DataSource instead.\n\t * <p>In JPA speak, a DataSource passed in here will be used as \"nonJtaDataSource\"\n\t * on the PersistenceUnitInfo passed to the PersistenceProvider, as well as\n\t * overriding data source configuration in {@code persistence.xml} (if any).\n\t * Note that this variant typically works for JTA transaction management as well;\n\t * if it does not, consider using the explicit {@link #setJtaDataSource} instead.\n\t * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>\n\t * @see jakarta.persistence.spi.PersistenceUnitInfo#getNonJtaDataSource()\n\t * @see #setPersistenceUnitManager\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataSource"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "void",
    "signature": "public void setDataSource(DataSource dataSource)",
    "source_code": "\tpublic void setDataSource(DataSource dataSource) {\n\t\tthis.internalPersistenceUnitManager.setDataSourceLookup(new SingleDataSourceLookup(dataSource));\n\t\tthis.internalPersistenceUnitManager.setDefaultDataSource(dataSource);\n\t}"
  },
  "org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean#setJtaDataSource(jtaDataSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the JDBC DataSource that the JPA persistence provider is supposed\n\t * to use for accessing the database. This is an alternative to keeping the\n\t * JDBC configuration in {@code persistence.xml}, passing in a Spring-managed\n\t * DataSource instead.\n\t * <p>In JPA speak, a DataSource passed in here will be used as \"jtaDataSource\"\n\t * on the PersistenceUnitInfo passed to the PersistenceProvider, as well as\n\t * overriding data source configuration in {@code persistence.xml} (if any).\n\t * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>\n\t * @see jakarta.persistence.spi.PersistenceUnitInfo#getJtaDataSource()\n\t * @see #setPersistenceUnitManager\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "jtaDataSource"
    ],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "void",
    "signature": "public void setJtaDataSource(DataSource jtaDataSource)",
    "source_code": "\tpublic void setJtaDataSource(DataSource jtaDataSource) {\n\t\tthis.internalPersistenceUnitManager.setDataSourceLookup(new SingleDataSourceLookup(jtaDataSource));\n\t\tthis.internalPersistenceUnitManager.setDefaultJtaDataSource(jtaDataSource);\n\t}"
  },
  "org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean#setLoadTimeWeaver(loadTimeWeaver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the Spring LoadTimeWeaver to use for class instrumentation according\n\t * to the JPA class transformer contract.\n\t * <p>It is a not required to specify a LoadTimeWeaver: Most providers will be\n\t * able to provide a subset of their functionality without class instrumentation\n\t * as well, or operate with their VM agent specified on JVM startup.\n\t * <p>In terms of Spring-provided weaving options, the most important ones are\n\t * InstrumentationLoadTimeWeaver, which requires a Spring-specific (but very general)\n\t * VM agent specified on JVM startup, and ReflectiveLoadTimeWeaver, which interacts\n\t * with an underlying ClassLoader based on specific extended methods being available\n\t * on it.\n\t * <p><b>NOTE:</b> As of Spring 2.5, the context's default LoadTimeWeaver (defined\n\t * as bean with name \"loadTimeWeaver\") will be picked up automatically, if available,\n\t * removing the need for LoadTimeWeaver configuration on each affected target bean.\n\t * Consider using the {@code context:load-time-weaver} XML tag for creating\n\t * such a shared LoadTimeWeaver (autodetecting the environment by default).\n\t * <p><b>NOTE:</b> Only applied if no external PersistenceUnitManager specified.\n\t * Otherwise, the external {@link #setPersistenceUnitManager PersistenceUnitManager}\n\t * is responsible for the weaving configuration.\n\t * @see org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver\n\t * @see org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "loadTimeWeaver"
    ],
    "position": {
      "column": 1,
      "line": 325
    },
    "return": "void",
    "signature": "public void setLoadTimeWeaver(LoadTimeWeaver loadTimeWeaver)",
    "source_code": "\tpublic void setLoadTimeWeaver(LoadTimeWeaver loadTimeWeaver) {\n\t\tthis.internalPersistenceUnitManager.setLoadTimeWeaver(loadTimeWeaver);\n\t}"
  },
  "org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean#setManagedTypes(managedTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link PersistenceManagedTypes} to use to build the list of managed types\n\t * as an alternative to entity scanning.\n\t * @param managedTypes the managed types\n\t * @since 6.0\n\t * @see DefaultPersistenceUnitManager#setManagedTypes(PersistenceManagedTypes)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "managedTypes"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "void",
    "signature": "public void setManagedTypes(PersistenceManagedTypes managedTypes)",
    "source_code": "\tpublic void setManagedTypes(PersistenceManagedTypes managedTypes) {\n\t\tthis.internalPersistenceUnitManager.setManagedTypes(managedTypes);\n\t}"
  },
  "org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean#setMappingResources(mappingResources)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify one or more mapping resources (equivalent to {@code <mapping-file>}\n\t * entries in {@code persistence.xml}) for the default persistence unit.\n\t * Can be used on its own or in combination with entity scanning in the classpath,\n\t * in both cases avoiding {@code persistence.xml}.\n\t * <p>Note that mapping resources must be relative to the classpath root,\n\t * e.g. \"META-INF/mappings.xml\" or \"com/mycompany/repository/mappings.xml\",\n\t * so that they can be loaded through {@code ClassLoader.getResource}.\n\t * <p>If no explicit mapping resources have been specified next to\n\t * {@link #setPackagesToScan packages to scan}, Spring's setup looks for a default\n\t * {@code META-INF/orm.xml} file in the classpath, registering it as a mapping\n\t * resource for the default unit if the mapping file is not co-located with a\n\t * {@code persistence.xml} file (in which case we assume it is only meant to be\n\t * used with the persistence units defined there, like in standard JPA).\n\t * <p>Note that specifying an empty array/list here suppresses the default\n\t * {@code META-INF/orm.xml} check. On the other hand, explicitly specifying\n\t * {@code META-INF/orm.xml} here will register that file even if it happens\n\t * to be co-located with a {@code persistence.xml} file.\n\t * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>\n\t * @see #setPersistenceUnitManager\n\t * @see DefaultPersistenceUnitManager#setMappingResources\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappingResources"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "void",
    "signature": "public void setMappingResources(String... mappingResources)",
    "source_code": "\tpublic void setMappingResources(String... mappingResources) {\n\t\tthis.internalPersistenceUnitManager.setMappingResources(mappingResources);\n\t}"
  },
  "org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean#setPackagesToScan(packagesToScan)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to use Spring-based scanning for entity classes in the classpath\n\t * instead of using JPA's standard scanning of jar files with {@code persistence.xml}\n\t * markers in them. In case of Spring-based scanning, no {@code persistence.xml}\n\t * is necessary; all you need to do is to specify base packages to search here.\n\t * <p>Default is none. Specify packages to search for autodetection of your entity\n\t * classes in the classpath. This is analogous to Spring's component-scan feature\n\t * ({@link org.springframework.context.annotation.ClassPathBeanDefinitionScanner}).\n\t * <p>Consider setting a {@link PersistenceManagedTypes} instead that allows the\n\t * scanning logic to be optimized by AOT processing.\n\t * <p><b>Note: There may be limitations in comparison to regular JPA scanning.</b>\n\t * In particular, JPA providers may pick up annotated packages for provider-specific\n\t * annotations only when driven by {@code persistence.xml}. As of 4.1, Spring's\n\t * scan can detect annotated packages as well if supported by the given\n\t * {@link JpaVendorAdapter} (e.g. for Hibernate).\n\t * <p>If no explicit {@link #setMappingResources mapping resources} have been\n\t * specified in addition to these packages, Spring's setup looks for a default\n\t * {@code META-INF/orm.xml} file in the classpath, registering it as a mapping\n\t * resource for the default unit if the mapping file is not co-located with a\n\t * {@code persistence.xml} file (in which case we assume it is only meant to be\n\t * used with the persistence units defined there, like in standard JPA).\n\t * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>\n\t * @param packagesToScan one or more base packages to search, analogous to\n\t * Spring's component-scan configuration for regular Spring components\n\t * @see #setPersistenceUnitManager\n\t * @see DefaultPersistenceUnitManager#setPackagesToScan\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "packagesToScan"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "void",
    "signature": "public void setPackagesToScan(String... packagesToScan)",
    "source_code": "\tpublic void setPackagesToScan(String... packagesToScan) {\n\t\tthis.internalPersistenceUnitManager.setPackagesToScan(packagesToScan);\n\t}"
  },
  "org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean#setPersistenceUnitManager(persistenceUnitManager)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the PersistenceUnitManager to use for obtaining the JPA persistence unit\n\t * that this FactoryBean is supposed to build an EntityManagerFactory for.\n\t * <p>The default is to rely on the local settings specified on this FactoryBean,\n\t * such as \"persistenceXmlLocation\", \"dataSource\" and \"loadTimeWeaver\".\n\t * <p>For reuse of existing persistence unit configuration or more advanced forms\n\t * of custom persistence unit handling, consider defining a separate\n\t * PersistenceUnitManager bean (typically a DefaultPersistenceUnitManager instance)\n\t * and linking it in here. {@code persistence.xml} location, DataSource\n\t * configuration and LoadTimeWeaver will be defined on that separate\n\t * DefaultPersistenceUnitManager bean in such a scenario.\n\t * @see #setPersistenceXmlLocation\n\t * @see #setDataSource\n\t * @see #setLoadTimeWeaver\n\t * @see org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "persistenceUnitManager"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "void",
    "signature": "public void setPersistenceUnitManager(PersistenceUnitManager persistenceUnitManager)",
    "source_code": "\tpublic void setPersistenceUnitManager(PersistenceUnitManager persistenceUnitManager) {\n\t\tthis.persistenceUnitManager = persistenceUnitManager;\n\t}"
  },
  "org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean#setPersistenceUnitName(persistenceUnitName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Uses the specified persistence unit name as the name of the default\n\t * persistence unit, if applicable.\n\t * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>\n\t * @see DefaultPersistenceUnitManager#setDefaultPersistenceUnitName\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "persistenceUnitName"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "void",
    "signature": "public void setPersistenceUnitName(@Nullable String persistenceUnitName)",
    "source_code": "\tpublic void setPersistenceUnitName(@Nullable String persistenceUnitName) {\n\t\tsuper.setPersistenceUnitName(persistenceUnitName);\n\t\tif (persistenceUnitName != null) {\n\t\t\tthis.internalPersistenceUnitManager.setDefaultPersistenceUnitName(persistenceUnitName);\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean#setPersistenceUnitPostProcessors(postProcessors)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the PersistenceUnitPostProcessors to be applied to the\n\t * PersistenceUnitInfo used for creating this EntityManagerFactory.\n\t * <p>Such post-processors can, for example, register further entity\n\t * classes and jar files, in addition to the metadata read from\n\t * {@code persistence.xml}.\n\t * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>\n\t * @see #setPersistenceUnitManager\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "postProcessors"
    ],
    "position": {
      "column": 1,
      "line": 298
    },
    "return": "void",
    "signature": "public void setPersistenceUnitPostProcessors(PersistenceUnitPostProcessor... postProcessors)",
    "source_code": "\tpublic void setPersistenceUnitPostProcessors(PersistenceUnitPostProcessor... postProcessors) {\n\t\tthis.internalPersistenceUnitManager.setPersistenceUnitPostProcessors(postProcessors);\n\t}"
  },
  "org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean#setPersistenceUnitRootLocation(defaultPersistenceUnitRootLocation)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a persistence unit root location for the default persistence unit.\n\t * <p>Default is \"classpath:\", that is, the root of the current classpath\n\t * (nearest root directory). To be overridden if unit-specific resolution\n\t * does not work and the classpath root is not appropriate either.\n\t * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>\n\t * @since 4.3.3\n\t * @see DefaultPersistenceUnitManager#setDefaultPersistenceUnitRootLocation\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultPersistenceUnitRootLocation"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "void",
    "signature": "public void setPersistenceUnitRootLocation(String defaultPersistenceUnitRootLocation)",
    "source_code": "\tpublic void setPersistenceUnitRootLocation(String defaultPersistenceUnitRootLocation) {\n\t\tthis.internalPersistenceUnitManager.setDefaultPersistenceUnitRootLocation(defaultPersistenceUnitRootLocation);\n\t}"
  },
  "org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean#setPersistenceXmlLocation(persistenceXmlLocation)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the location of the {@code persistence.xml} file\n\t * we want to use. This is a Spring resource location.\n\t * <p>Default is \"classpath:META-INF/persistence.xml\".\n\t * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>\n\t * @param persistenceXmlLocation a Spring resource String\n\t * identifying the location of the {@code persistence.xml} file\n\t * that this LocalContainerEntityManagerFactoryBean should parse\n\t * @see #setPersistenceUnitManager\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "persistenceXmlLocation"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "void",
    "signature": "public void setPersistenceXmlLocation(String persistenceXmlLocation)",
    "source_code": "\tpublic void setPersistenceXmlLocation(String persistenceXmlLocation) {\n\t\tthis.internalPersistenceUnitManager.setPersistenceXmlLocation(persistenceXmlLocation);\n\t}"
  },
  "org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean#setResourceLoader(resourceLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resourceLoader"
    ],
    "position": {
      "column": 1,
      "line": 330
    },
    "return": "void",
    "signature": "public void setResourceLoader(ResourceLoader resourceLoader)",
    "source_code": "\tpublic void setResourceLoader(ResourceLoader resourceLoader) {\n\t\tthis.internalPersistenceUnitManager.setResourceLoader(resourceLoader);\n\t}"
  },
  "org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean#setSharedCacheMode(sharedCacheMode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the JPA 2.0 shared cache mode for this persistence unit,\n\t * overriding a value in {@code persistence.xml} if set.\n\t * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>\n\t * @since 4.0\n\t * @see jakarta.persistence.spi.PersistenceUnitInfo#getSharedCacheMode()\n\t * @see #setPersistenceUnitManager\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sharedCacheMode"
    ],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "void",
    "signature": "public void setSharedCacheMode(SharedCacheMode sharedCacheMode)",
    "source_code": "\tpublic void setSharedCacheMode(SharedCacheMode sharedCacheMode) {\n\t\tthis.internalPersistenceUnitManager.setSharedCacheMode(sharedCacheMode);\n\t}"
  },
  "org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean#setValidationMode(validationMode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the JPA 2.0 validation mode for this persistence unit,\n\t * overriding a value in {@code persistence.xml} if set.\n\t * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>\n\t * @since 4.0\n\t * @see jakarta.persistence.spi.PersistenceUnitInfo#getValidationMode()\n\t * @see #setPersistenceUnitManager\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "validationMode"
    ],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "void",
    "signature": "public void setValidationMode(ValidationMode validationMode)",
    "source_code": "\tpublic void setValidationMode(ValidationMode validationMode) {\n\t\tthis.internalPersistenceUnitManager.setValidationMode(validationMode);\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.<unknown>#addTransformer(classTransformer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation delegates to the LoadTimeWeaver, if specified.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classTransformer"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "void",
    "signature": "public void addTransformer(ClassTransformer classTransformer)",
    "source_code": "\tpublic void addTransformer(ClassTransformer classTransformer) {\n\t\tif (this.loadTimeWeaver != null) {\n\t\t\tthis.loadTimeWeaver.addTransformer(new ClassFileTransformerAdapter(classTransformer));\n\t\t}\n\t\telse {\n\t\t\tLogFactory.getLog(getClass()).info(\"No LoadTimeWeaver setup: ignoring JPA class transformer\");\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.<unknown>#getClassLoader()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns the LoadTimeWeaver's instrumentable ClassLoader,\n\t * if specified.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "ClassLoader",
    "signature": "public ClassLoader getClassLoader()",
    "source_code": "\tpublic ClassLoader getClassLoader() {\n\t\treturn this.classLoader;\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.<unknown>#getNewTempClassLoader()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation delegates to the LoadTimeWeaver, if specified.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "ClassLoader",
    "signature": "public ClassLoader getNewTempClassLoader()",
    "source_code": "\tpublic ClassLoader getNewTempClassLoader() {\n\t\tClassLoader tcl = (this.loadTimeWeaver != null ? this.loadTimeWeaver.getThrowawayClassLoader() :\n\t\t\t\tnew SimpleThrowawayClassLoader(this.classLoader));\n\t\tString packageToExclude = getPersistenceProviderPackageName();\n\t\tif (packageToExclude != null && tcl instanceof DecoratingClassLoader dcl) {\n\t\t\tdcl.excludePackage(packageToExclude);\n\t\t}\n\t\treturn tcl;\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.<unknown>#init(classLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize this PersistenceUnitInfo with the current class loader\n\t * (instead of with a LoadTimeWeaver).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "void",
    "signature": "public void init(@Nullable ClassLoader classLoader)",
    "source_code": "\tpublic void init(@Nullable ClassLoader classLoader) {\n\t\tthis.classLoader = classLoader;\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.<unknown>#init(loadTimeWeaver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize this PersistenceUnitInfo with the LoadTimeWeaver SPI interface\n\t * used by Spring to add instrumentation to the current class loader.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "loadTimeWeaver"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "return": "void",
    "signature": "public void init(LoadTimeWeaver loadTimeWeaver)",
    "source_code": "\tpublic void init(LoadTimeWeaver loadTimeWeaver) {\n\t\tAssert.notNull(loadTimeWeaver, \"LoadTimeWeaver must not be null\");\n\t\tthis.loadTimeWeaver = loadTimeWeaver;\n\t\tthis.classLoader = loadTimeWeaver.getInstrumentableClassLoader();\n\t}"
  },
  "org.springframework.orm.jpa.vendor.<unknown>#createContainerEntityManagerFactory(info,properties)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "info",
      "properties"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "return": "EntityManagerFactory",
    "signature": "public EntityManagerFactory createContainerEntityManagerFactory(PersistenceUnitInfo info, Map properties)",
    "source_code": "\tpublic EntityManagerFactory createContainerEntityManagerFactory(PersistenceUnitInfo info, Map properties) {\n\t\tfinal List<String> mergedClassesAndPackages = new ArrayList<>(info.getManagedClassNames());\n\t\tif (info instanceof SmartPersistenceUnitInfo smartInfo) {\n\t\t\tmergedClassesAndPackages.addAll(smartInfo.getManagedPackages());\n\t\t}\n\t\treturn new EntityManagerFactoryBuilderImpl(\n\t\t\t\tnew PersistenceUnitInfoDescriptor(info) {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic List<String> getManagedClassNames() {\n\t\t\t\t\t\treturn mergedClassesAndPackages;\n\t\t\t\t\t}\n\t\t\t\t}, properties).build();\n\t}"
  },
  "org.springframework.orm.jpa.vendor.<unknown>#getManagedClassNames()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "List<String>",
    "signature": "public List<String> getManagedClassNames()",
    "source_code": "\t\t\t\t\tpublic List<String> getManagedClassNames() {\n\t\t\t\t\t\treturn mergedClassesAndPackages;\n\t\t\t\t\t}"
  },
  "org.springframework.oxm.support.AbstractMarshaller": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract implementation of the {@code Marshaller} and {@code Unmarshaller} interface.\n * This implementation inspects the given {@code Source} or {@code Result}, and\n * delegates further handling to overridable template methods.\n *\n * @author Arjen Poutsma\n * @author Juergen Hoeller\n * @since 3.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "signature": "public class AbstractMarshaller",
    "source_code": "public abstract class AbstractMarshaller implements Marshaller, Unmarshaller {\n\n\tprivate static final EntityResolver NO_OP_ENTITY_RESOLVER =\n\t\t\t(publicId, systemId) -> new InputSource(new StringReader(\"\"));\n\n\t/** Logger available to subclasses. */\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\tprivate boolean supportDtd = false;\n\n\tprivate boolean processExternalEntities = false;\n\n\t@Nullable\n\tprivate DocumentBuilderFactory documentBuilderFactory;\n\n\tprivate final Object documentBuilderFactoryMonitor = new Object();\n\n\n\t/**\n\t * Indicate whether DTD parsing should be supported.\n\t * <p>Default is {@code false} meaning that DTD is disabled.\n\t */\n\tpublic void setSupportDtd(boolean supportDtd) {\n\t\tthis.supportDtd = supportDtd;\n\t}\n\n\t/**\n\t * Return whether DTD parsing is supported.\n\t */\n\tpublic boolean isSupportDtd() {\n\t\treturn this.supportDtd;\n\t}\n\n\t/**\n\t * Indicate whether external XML entities are processed when unmarshalling.\n\t * <p>Default is {@code false}, meaning that external entities are not resolved.\n\t * Note that processing of external entities will only be enabled/disabled when the\n\t * {@code Source} passed to {@link #unmarshal(Source)} is a {@link SAXSource} or\n\t * {@link StreamSource}. It has no effect for {@link DOMSource} or {@link StAXSource}\n\t * instances.\n\t * <p><strong>Note:</strong> setting this option to {@code true} also\n\t * automatically sets {@link #setSupportDtd} to {@code true}.\n\t */\n\tpublic void setProcessExternalEntities(boolean processExternalEntities) {\n\t\tthis.processExternalEntities = processExternalEntities;\n\t\tif (processExternalEntities) {\n\t\t\tthis.supportDtd = true;\n\t\t}\n\t}\n\n\t/**\n\t * Return whether XML external entities are allowed.\n\t * @see #createXmlReader()\n\t */\n\tpublic boolean isProcessExternalEntities() {\n\t\treturn this.processExternalEntities;\n\t}\n\n\n\t/**\n\t * Build a new {@link Document} from this marshaller's {@link DocumentBuilderFactory},\n\t * as a placeholder for a DOM node.\n\t * @see #createDocumentBuilderFactory()\n\t * @see #createDocumentBuilder(DocumentBuilderFactory)\n\t */\n\tprotected Document buildDocument() {\n\t\ttry {\n\t\t\tDocumentBuilder documentBuilder;\n\t\t\tsynchronized (this.documentBuilderFactoryMonitor) {\n\t\t\t\tif (this.documentBuilderFactory == null) {\n\t\t\t\t\tthis.documentBuilderFactory = createDocumentBuilderFactory();\n\t\t\t\t}\n\t\t\t\tdocumentBuilder = createDocumentBuilder(this.documentBuilderFactory);\n\t\t\t}\n\t\t\treturn documentBuilder.newDocument();\n\t\t}\n\t\tcatch (ParserConfigurationException ex) {\n\t\t\tthrow new UnmarshallingFailureException(\"Could not create document placeholder: \" + ex.getMessage(), ex);\n\t\t}\n\t}\n\n\t/**\n\t * Create a {@code DocumentBuilder} that this marshaller will use for creating\n\t * DOM documents when passed an empty {@code DOMSource}.\n\t * <p>The resulting {@code DocumentBuilderFactory} is cached, so this method\n\t * will only be called once.\n\t * @return the DocumentBuilderFactory\n\t * @throws ParserConfigurationException if thrown by JAXP methods\n\t */\n\tprotected DocumentBuilderFactory createDocumentBuilderFactory() throws ParserConfigurationException {\n\t\tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n\t\tfactory.setValidating(false);\n\t\tfactory.setNamespaceAware(true);\n\t\tfactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", !isSupportDtd());\n\t\tfactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", isProcessExternalEntities());\n\t\treturn factory;\n\t}\n\n\t/**\n\t * Create a {@code DocumentBuilder} that this marshaller will use for creating\n\t * DOM documents when passed an empty {@code DOMSource}.\n\t * <p>Can be overridden in subclasses, adding further initialization of the builder.\n\t * @param factory the {@code DocumentBuilderFactory} that the DocumentBuilder should be created with\n\t * @return the {@code DocumentBuilder}\n\t * @throws ParserConfigurationException if thrown by JAXP methods\n\t */\n\tprotected DocumentBuilder createDocumentBuilder(DocumentBuilderFactory factory)\n\t\t\tthrows ParserConfigurationException {\n\n\t\tDocumentBuilder documentBuilder = factory.newDocumentBuilder();\n\t\tif (!isProcessExternalEntities()) {\n\t\t\tdocumentBuilder.setEntityResolver(NO_OP_ENTITY_RESOLVER);\n\t\t}\n\t\treturn documentBuilder;\n\t}\n\n\t/**\n\t * Create an {@code XMLReader} that this marshaller will when passed an empty {@code SAXSource}.\n\t * @return the XMLReader\n\t * @throws SAXException if thrown by JAXP methods\n\t * @throws ParserConfigurationException if thrown by JAXP methods\n\t */\n\tprotected XMLReader createXmlReader() throws SAXException, ParserConfigurationException {\n\t\tSAXParserFactory saxParserFactory = SAXParserFactory.newInstance();\n\t\tsaxParserFactory.setNamespaceAware(true);\n\t\tsaxParserFactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", !isSupportDtd());\n\t\tsaxParserFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", isProcessExternalEntities());\n\t\tSAXParser saxParser = saxParserFactory.newSAXParser();\n\t\tXMLReader xmlReader = saxParser.getXMLReader();\n\t\tif (!isProcessExternalEntities()) {\n\t\t\txmlReader.setEntityResolver(NO_OP_ENTITY_RESOLVER);\n\t\t}\n\t\treturn xmlReader;\n\t}\n\n\t/**\n\t * Determine the default encoding to use for marshalling or unmarshalling from\n\t * a byte stream, or {@code null} if none.\n\t * <p>The default implementation returns {@code null}.\n\t */\n\t@Nullable\n\tprotected String getDefaultEncoding() {\n\t\treturn null;\n\t}\n\n\n\t// Marshalling\n\n\t/**\n\t * Marshals the object graph with the given root into the provided {@code javax.xml.transform.Result}.\n\t * <p>This implementation inspects the given result, and calls {@code marshalDomResult},\n\t * {@code marshalSaxResult}, or {@code marshalStreamResult}.\n\t * @param graph the root of the object graph to marshal\n\t * @param result the result to marshal to\n\t * @throws IOException if an I/O exception occurs\n\t * @throws XmlMappingException if the given object cannot be marshalled to the result\n\t * @throws IllegalArgumentException if {@code result} if neither a {@code DOMResult},\n\t * a {@code SAXResult}, nor a {@code StreamResult}\n\t * @see #marshalDomResult(Object, javax.xml.transform.dom.DOMResult)\n\t * @see #marshalSaxResult(Object, javax.xml.transform.sax.SAXResult)\n\t * @see #marshalStreamResult(Object, javax.xml.transform.stream.StreamResult)\n\t */\n\t@Override\n\tpublic final void marshal(Object graph, Result result) throws IOException, XmlMappingException {\n\t\tif (result instanceof DOMResult domResult) {\n\t\t\tmarshalDomResult(graph, domResult);\n\t\t}\n\t\telse if (StaxUtils.isStaxResult(result)) {\n\t\t\tmarshalStaxResult(graph, result);\n\t\t}\n\t\telse if (result instanceof SAXResult saxResult) {\n\t\t\tmarshalSaxResult(graph, saxResult);\n\t\t}\n\t\telse if (result instanceof StreamResult streamResult) {\n\t\t\tmarshalStreamResult(graph, streamResult);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Unknown Result type: \" + result.getClass());\n\t\t}\n\t}\n\n\t/**\n\t * Template method for handling {@code DOMResult}s.\n\t * <p>This implementation delegates to {@code marshalDomNode}.\n\t * @param graph the root of the object graph to marshal\n\t * @param domResult the {@code DOMResult}\n\t * @throws XmlMappingException if the given object cannot be marshalled to the result\n\t * @throws IllegalArgumentException if the {@code domResult} is empty\n\t * @see #marshalDomNode(Object, org.w3c.dom.Node)\n\t */\n\tprotected void marshalDomResult(Object graph, DOMResult domResult) throws XmlMappingException {\n\t\tif (domResult.getNode() == null) {\n\t\t\tdomResult.setNode(buildDocument());\n\t\t}\n\t\tmarshalDomNode(graph, domResult.getNode());\n\t}\n\n\t/**\n\t * Template method for handling {@code StaxResult}s.\n\t * <p>This implementation delegates to {@code marshalXMLSteamWriter} or\n\t * {@code marshalXMLEventConsumer}, depending on what is contained in the\n\t * {@code StaxResult}.\n\t * @param graph the root of the object graph to marshal\n\t * @param staxResult a JAXP 1.4 {@link StAXSource}\n\t * @throws XmlMappingException if the given object cannot be marshalled to the result\n\t * @throws IllegalArgumentException if the {@code domResult} is empty\n\t * @see #marshalDomNode(Object, org.w3c.dom.Node)\n\t */\n\tprotected void marshalStaxResult(Object graph, Result staxResult) throws XmlMappingException {\n\t\tXMLStreamWriter streamWriter = StaxUtils.getXMLStreamWriter(staxResult);\n\t\tif (streamWriter != null) {\n\t\t\tmarshalXmlStreamWriter(graph, streamWriter);\n\t\t}\n\t\telse {\n\t\t\tXMLEventWriter eventWriter = StaxUtils.getXMLEventWriter(staxResult);\n\t\t\tif (eventWriter != null) {\n\t\t\t\tmarshalXmlEventWriter(graph, eventWriter);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"StaxResult contains neither XMLStreamWriter nor XMLEventConsumer\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Template method for handling {@code SAXResult}s.\n\t * <p>This implementation delegates to {@code marshalSaxHandlers}.\n\t * @param graph the root of the object graph to marshal\n\t * @param saxResult the {@code SAXResult}\n\t * @throws XmlMappingException if the given object cannot be marshalled to the result\n\t * @see #marshalSaxHandlers(Object, org.xml.sax.ContentHandler, org.xml.sax.ext.LexicalHandler)\n\t */\n\tprotected void marshalSaxResult(Object graph, SAXResult saxResult) throws XmlMappingException {\n\t\tContentHandler contentHandler = saxResult.getHandler();\n\t\tAssert.notNull(contentHandler, \"ContentHandler not set on SAXResult\");\n\t\tLexicalHandler lexicalHandler = saxResult.getLexicalHandler();\n\t\tmarshalSaxHandlers(graph, contentHandler, lexicalHandler);\n\t}\n\n\t/**\n\t * Template method for handling {@code StreamResult}s.\n\t * <p>This implementation delegates to {@code marshalOutputStream} or {@code marshalWriter},\n\t * depending on what is contained in the {@code StreamResult}\n\t * @param graph the root of the object graph to marshal\n\t * @param streamResult the {@code StreamResult}\n\t * @throws IOException if an I/O Exception occurs\n\t * @throws XmlMappingException if the given object cannot be marshalled to the result\n\t * @throws IllegalArgumentException if {@code streamResult} does neither\n\t * contain an {@code OutputStream} nor a {@code Writer}\n\t */\n\tprotected void marshalStreamResult(Object graph, StreamResult streamResult)\n\t\t\tthrows XmlMappingException, IOException {\n\n\t\tif (streamResult.getOutputStream() != null) {\n\t\t\tmarshalOutputStream(graph, streamResult.getOutputStream());\n\t\t}\n\t\telse if (streamResult.getWriter() != null) {\n\t\t\tmarshalWriter(graph, streamResult.getWriter());\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"StreamResult contains neither OutputStream nor Writer\");\n\t\t}\n\t}\n\n\n\t// Unmarshalling\n\n\t/**\n\t * Unmarshals the given provided {@code javax.xml.transform.Source} into an object graph.\n\t * <p>This implementation inspects the given result, and calls {@code unmarshalDomSource},\n\t * {@code unmarshalSaxSource}, or {@code unmarshalStreamSource}.\n\t * @param source the source to marshal from\n\t * @return the object graph\n\t * @throws IOException if an I/O Exception occurs\n\t * @throws XmlMappingException if the given source cannot be mapped to an object\n\t * @throws IllegalArgumentException if {@code source} is neither a {@code DOMSource},\n\t * a {@code SAXSource}, nor a {@code StreamSource}\n\t * @see #unmarshalDomSource(javax.xml.transform.dom.DOMSource)\n\t * @see #unmarshalSaxSource(javax.xml.transform.sax.SAXSource)\n\t * @see #unmarshalStreamSource(javax.xml.transform.stream.StreamSource)\n\t */\n\t@Override\n\tpublic final Object unmarshal(Source source) throws IOException, XmlMappingException {\n\t\tif (source instanceof DOMSource domSource) {\n\t\t\treturn unmarshalDomSource(domSource);\n\t\t}\n\t\telse if (StaxUtils.isStaxSource(source)) {\n\t\t\treturn unmarshalStaxSource(source);\n\t\t}\n\t\telse if (source instanceof SAXSource saxSource) {\n\t\t\treturn unmarshalSaxSource(saxSource);\n\t\t}\n\t\telse if (source instanceof StreamSource streamSource) {\n\t\t\treturn unmarshalStreamSource(streamSource);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Unknown Source type: \" + source.getClass());\n\t\t}\n\t}\n\n\t/**\n\t * Template method for handling {@code DOMSource}s.\n\t * <p>This implementation delegates to {@code unmarshalDomNode}.\n\t * If the given source is empty, an empty source {@code Document}\n\t * will be created as a placeholder.\n\t * @param domSource the {@code DOMSource}\n\t * @return the object graph\n\t * @throws XmlMappingException if the given source cannot be mapped to an object\n\t * @throws IllegalArgumentException if the {@code domSource} is empty\n\t * @see #unmarshalDomNode(org.w3c.dom.Node)\n\t */\n\tprotected Object unmarshalDomSource(DOMSource domSource) throws XmlMappingException {\n\t\tif (domSource.getNode() == null) {\n\t\t\tdomSource.setNode(buildDocument());\n\t\t}\n\t\ttry {\n\t\t\treturn unmarshalDomNode(domSource.getNode());\n\t\t}\n\t\tcatch (NullPointerException ex) {\n\t\t\tif (!isSupportDtd()) {\n\t\t\t\tthrow new UnmarshallingFailureException(\"NPE while unmarshalling. \" +\n\t\t\t\t\t\t\"This can happen on JDK 1.6 due to the presence of DTD \" +\n\t\t\t\t\t\t\"declarations, which are disabled.\", ex);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\t/**\n\t * Template method for handling {@code StaxSource}s.\n\t * <p>This implementation delegates to {@code unmarshalXmlStreamReader} or\n\t * {@code unmarshalXmlEventReader}.\n\t * @param staxSource the {@code StaxSource}\n\t * @return the object graph\n\t * @throws XmlMappingException if the given source cannot be mapped to an object\n\t */\n\tprotected Object unmarshalStaxSource(Source staxSource) throws XmlMappingException {\n\t\tXMLStreamReader streamReader = StaxUtils.getXMLStreamReader(staxSource);\n\t\tif (streamReader != null) {\n\t\t\treturn unmarshalXmlStreamReader(streamReader);\n\t\t}\n\t\telse {\n\t\t\tXMLEventReader eventReader = StaxUtils.getXMLEventReader(staxSource);\n\t\t\tif (eventReader != null) {\n\t\t\t\treturn unmarshalXmlEventReader(eventReader);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"StaxSource contains neither XMLStreamReader nor XMLEventReader\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Template method for handling {@code SAXSource}s.\n\t * <p>This implementation delegates to {@code unmarshalSaxReader}.\n\t * @param saxSource the {@code SAXSource}\n\t * @return the object graph\n\t * @throws XmlMappingException if the given source cannot be mapped to an object\n\t * @throws IOException if an I/O Exception occurs\n\t * @see #unmarshalSaxReader(org.xml.sax.XMLReader, org.xml.sax.InputSource)\n\t */\n\tprotected Object unmarshalSaxSource(SAXSource saxSource) throws XmlMappingException, IOException {\n\t\tif (saxSource.getXMLReader() == null) {\n\t\t\ttry {\n\t\t\t\tsaxSource.setXMLReader(createXmlReader());\n\t\t\t}\n\t\t\tcatch (SAXException | ParserConfigurationException ex) {\n\t\t\t\tthrow new UnmarshallingFailureException(\"Could not create XMLReader for SAXSource\", ex);\n\t\t\t}\n\t\t}\n\t\tif (saxSource.getInputSource() == null) {\n\t\t\tsaxSource.setInputSource(new InputSource());\n\t\t}\n\t\ttry {\n\t\t\treturn unmarshalSaxReader(saxSource.getXMLReader(), saxSource.getInputSource());\n\t\t}\n\t\tcatch (NullPointerException ex) {\n\t\t\tif (!isSupportDtd()) {\n\t\t\t\tthrow new UnmarshallingFailureException(\"NPE while unmarshalling. \" +\n\t\t\t\t\t\t\"This can happen on JDK 1.6 due to the presence of DTD \" +\n\t\t\t\t\t\t\"declarations, which are disabled.\");\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\t/**\n\t * Template method for handling {@code StreamSource}s.\n\t * <p>This implementation delegates to {@code unmarshalInputStream} or {@code unmarshalReader}.\n\t * @param streamSource the {@code StreamSource}\n\t * @return the object graph\n\t * @throws IOException if an I/O exception occurs\n\t * @throws XmlMappingException if the given source cannot be mapped to an object\n\t */\n\tprotected Object unmarshalStreamSource(StreamSource streamSource) throws XmlMappingException, IOException {\n\t\tif (streamSource.getInputStream() != null) {\n\t\t\tif (isProcessExternalEntities() && isSupportDtd()) {\n\t\t\t\treturn unmarshalInputStream(streamSource.getInputStream());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tInputSource inputSource = new InputSource(streamSource.getInputStream());\n\t\t\t\tinputSource.setEncoding(getDefaultEncoding());\n\t\t\t\treturn unmarshalSaxSource(new SAXSource(inputSource));\n\t\t\t}\n\t\t}\n\t\telse if (streamSource.getReader() != null) {\n\t\t\tif (isProcessExternalEntities() && isSupportDtd()) {\n\t\t\t\treturn unmarshalReader(streamSource.getReader());\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn unmarshalSaxSource(new SAXSource(new InputSource(streamSource.getReader())));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn unmarshalSaxSource(new SAXSource(new InputSource(streamSource.getSystemId())));\n\t\t}\n\t}\n\n\n\t// Abstract template methods\n\n\t/**\n\t * Abstract template method for marshalling the given object graph to a DOM {@code Node}.\n\t * <p>In practice, {@code node} is a {@code Document} node, a {@code DocumentFragment} node,\n\t * or a {@code Element} node. In other words, a node that accepts children.\n\t * @param graph the root of the object graph to marshal\n\t * @param node the DOM node that will contain the result tree\n\t * @throws XmlMappingException if the given object cannot be marshalled to the DOM node\n\t * @see org.w3c.dom.Document\n\t * @see org.w3c.dom.DocumentFragment\n\t * @see org.w3c.dom.Element\n\t */\n\tprotected abstract void marshalDomNode(Object graph, Node node)\n\t\t\tthrows XmlMappingException;\n\n\t/**\n\t * Abstract template method for marshalling the given object to a StAX {@code XMLEventWriter}.\n\t * @param graph the root of the object graph to marshal\n\t * @param eventWriter the {@code XMLEventWriter} to write to\n\t * @throws XmlMappingException if the given object cannot be marshalled to the DOM node\n\t */\n\tprotected abstract void marshalXmlEventWriter(Object graph, XMLEventWriter eventWriter)\n\t\t\tthrows XmlMappingException;\n\n\t/**\n\t * Abstract template method for marshalling the given object to a StAX {@code XMLStreamWriter}.\n\t * @param graph the root of the object graph to marshal\n\t * @param streamWriter the {@code XMLStreamWriter} to write to\n\t * @throws XmlMappingException if the given object cannot be marshalled to the DOM node\n\t */\n\tprotected abstract void marshalXmlStreamWriter(Object graph, XMLStreamWriter streamWriter)\n\t\t\tthrows XmlMappingException;\n\n\t/**\n\t * Abstract template method for marshalling the given object graph to a SAX {@code ContentHandler}.\n\t * @param graph the root of the object graph to marshal\n\t * @param contentHandler the SAX {@code ContentHandler}\n\t * @param lexicalHandler the SAX2 {@code LexicalHandler}. Can be {@code null}.\n\t * @throws XmlMappingException if the given object cannot be marshalled to the handlers\n\t */\n\tprotected abstract void marshalSaxHandlers(\n\t\t\tObject graph, ContentHandler contentHandler, @Nullable LexicalHandler lexicalHandler)\n\t\t\tthrows XmlMappingException;\n\n\t/**\n\t * Abstract template method for marshalling the given object graph to a {@code OutputStream}.\n\t * @param graph the root of the object graph to marshal\n\t * @param outputStream the {@code OutputStream} to write to\n\t * @throws XmlMappingException if the given object cannot be marshalled to the writer\n\t * @throws IOException if an I/O exception occurs\n\t */\n\tprotected abstract void marshalOutputStream(Object graph, OutputStream outputStream)\n\t\t\tthrows XmlMappingException, IOException;\n\n\t/**\n\t * Abstract template method for marshalling the given object graph to a {@code Writer}.\n\t * @param graph the root of the object graph to marshal\n\t * @param writer the {@code Writer} to write to\n\t * @throws XmlMappingException if the given object cannot be marshalled to the writer\n\t * @throws IOException if an I/O exception occurs\n\t */\n\tprotected abstract void marshalWriter(Object graph, Writer writer)\n\t\t\tthrows XmlMappingException, IOException;\n\n\t/**\n\t * Abstract template method for unmarshalling from a given DOM {@code Node}.\n\t * @param node the DOM node that contains the objects to be unmarshalled\n\t * @return the object graph\n\t * @throws XmlMappingException if the given DOM node cannot be mapped to an object\n\t */\n\tprotected abstract Object unmarshalDomNode(Node node) throws XmlMappingException;\n\n\t/**\n\t * Abstract template method for unmarshalling from a given Stax {@code XMLEventReader}.\n\t * @param eventReader the {@code XMLEventReader} to read from\n\t * @return the object graph\n\t * @throws XmlMappingException if the given event reader cannot be converted to an object\n\t */\n\tprotected abstract Object unmarshalXmlEventReader(XMLEventReader eventReader)\n\t\t\tthrows XmlMappingException;\n\n\t/**\n\t * Abstract template method for unmarshalling from a given Stax {@code XMLStreamReader}.\n\t * @param streamReader the {@code XMLStreamReader} to read from\n\t * @return the object graph\n\t * @throws XmlMappingException if the given stream reader cannot be converted to an object\n\t */\n\tprotected abstract Object unmarshalXmlStreamReader(XMLStreamReader streamReader)\n\t\t\tthrows XmlMappingException;\n\n\t/**\n\t * Abstract template method for unmarshalling using a given SAX {@code XMLReader}\n\t * and {@code InputSource}.\n\t * @param xmlReader the SAX {@code XMLReader} to parse with\n\t * @param inputSource the input source to parse from\n\t * @return the object graph\n\t * @throws XmlMappingException if the given reader and input source cannot be converted to an object\n\t * @throws IOException if an I/O exception occurs\n\t */\n\tprotected abstract Object unmarshalSaxReader(XMLReader xmlReader, InputSource inputSource)\n\t\t\tthrows XmlMappingException, IOException;\n\n\t/**\n\t * Abstract template method for unmarshalling from a given {@code InputStream}.\n\t * @param inputStream the {@code InputStreamStream} to read from\n\t * @return the object graph\n\t * @throws XmlMappingException if the given stream cannot be converted to an object\n\t * @throws IOException if an I/O exception occurs\n\t */\n\tprotected abstract Object unmarshalInputStream(InputStream inputStream)\n\t\t\tthrows XmlMappingException, IOException;\n\n\t/**\n\t * Abstract template method for unmarshalling from a given {@code Reader}.\n\t * @param reader the {@code Reader} to read from\n\t * @return the object graph\n\t * @throws XmlMappingException if the given reader cannot be converted to an object\n\t * @throws IOException if an I/O exception occurs\n\t */\n\tprotected abstract Object unmarshalReader(Reader reader)\n\t\t\tthrows XmlMappingException, IOException;\n\n}"
  },
  "org.springframework.oxm.support.AbstractMarshaller#buildDocument()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a new {@link Document} from this marshaller's {@link DocumentBuilderFactory},\n\t * as a placeholder for a DOM node.\n\t * @see #createDocumentBuilderFactory()\n\t * @see #createDocumentBuilder(DocumentBuilderFactory)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "Document",
    "signature": "protected Document buildDocument()",
    "source_code": "\tprotected Document buildDocument() {\n\t\ttry {\n\t\t\tDocumentBuilder documentBuilder;\n\t\t\tsynchronized (this.documentBuilderFactoryMonitor) {\n\t\t\t\tif (this.documentBuilderFactory == null) {\n\t\t\t\t\tthis.documentBuilderFactory = createDocumentBuilderFactory();\n\t\t\t\t}\n\t\t\t\tdocumentBuilder = createDocumentBuilder(this.documentBuilderFactory);\n\t\t\t}\n\t\t\treturn documentBuilder.newDocument();\n\t\t}\n\t\tcatch (ParserConfigurationException ex) {\n\t\t\tthrow new UnmarshallingFailureException(\"Could not create document placeholder: \" + ex.getMessage(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.oxm.support.AbstractMarshaller#createDocumentBuilder(factory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@code DocumentBuilder} that this marshaller will use for creating\n\t * DOM documents when passed an empty {@code DOMSource}.\n\t * <p>Can be overridden in subclasses, adding further initialization of the builder.\n\t * @param factory the {@code DocumentBuilderFactory} that the DocumentBuilder should be created with\n\t * @return the {@code DocumentBuilder}\n\t * @throws ParserConfigurationException if thrown by JAXP methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "factory"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "DocumentBuilder",
    "signature": "protected DocumentBuilder createDocumentBuilder(DocumentBuilderFactory factory)",
    "source_code": "\tprotected DocumentBuilder createDocumentBuilder(DocumentBuilderFactory factory)"
  },
  "org.springframework.oxm.support.AbstractMarshaller#createDocumentBuilderFactory()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@code DocumentBuilder} that this marshaller will use for creating\n\t * DOM documents when passed an empty {@code DOMSource}.\n\t * <p>The resulting {@code DocumentBuilderFactory} is cached, so this method\n\t * will only be called once.\n\t * @return the DocumentBuilderFactory\n\t * @throws ParserConfigurationException if thrown by JAXP methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "DocumentBuilderFactory",
    "signature": "protected DocumentBuilderFactory createDocumentBuilderFactory()",
    "source_code": "\tprotected DocumentBuilderFactory createDocumentBuilderFactory() throws ParserConfigurationException {\n\t\tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n\t\tfactory.setValidating(false);\n\t\tfactory.setNamespaceAware(true);\n\t\tfactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", !isSupportDtd());\n\t\tfactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", isProcessExternalEntities());\n\t\treturn factory;\n\t}"
  },
  "org.springframework.oxm.support.AbstractMarshaller#createXmlReader()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an {@code XMLReader} that this marshaller will when passed an empty {@code SAXSource}.\n\t * @return the XMLReader\n\t * @throws SAXException if thrown by JAXP methods\n\t * @throws ParserConfigurationException if thrown by JAXP methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 195
    },
    "return": "XMLReader",
    "signature": "protected XMLReader createXmlReader()",
    "source_code": "\tprotected XMLReader createXmlReader() throws SAXException, ParserConfigurationException {\n\t\tSAXParserFactory saxParserFactory = SAXParserFactory.newInstance();\n\t\tsaxParserFactory.setNamespaceAware(true);\n\t\tsaxParserFactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", !isSupportDtd());\n\t\tsaxParserFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", isProcessExternalEntities());\n\t\tSAXParser saxParser = saxParserFactory.newSAXParser();\n\t\tXMLReader xmlReader = saxParser.getXMLReader();\n\t\tif (!isProcessExternalEntities()) {\n\t\t\txmlReader.setEntityResolver(NO_OP_ENTITY_RESOLVER);\n\t\t}\n\t\treturn xmlReader;\n\t}"
  },
  "org.springframework.oxm.support.AbstractMarshaller#getDefaultEncoding()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the default encoding to use for marshalling or unmarshalling from\n\t * a byte stream, or {@code null} if none.\n\t * <p>The default implementation returns {@code null}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "String",
    "signature": "protected String getDefaultEncoding()",
    "source_code": "\tprotected String getDefaultEncoding() {\n\t\treturn null;\n\t}"
  },
  "org.springframework.oxm.support.AbstractMarshaller#isProcessExternalEntities()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether XML external entities are allowed.\n\t * @see #createXmlReader()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "boolean",
    "signature": "public boolean isProcessExternalEntities()",
    "source_code": "\tpublic boolean isProcessExternalEntities() {\n\t\treturn this.processExternalEntities;\n\t}"
  },
  "org.springframework.oxm.support.AbstractMarshaller#isSupportDtd()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether DTD parsing is supported.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "boolean",
    "signature": "public boolean isSupportDtd()",
    "source_code": "\tpublic boolean isSupportDtd() {\n\t\treturn this.supportDtd;\n\t}"
  },
  "org.springframework.oxm.support.AbstractMarshaller#marshal(graph,result)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Marshals the object graph with the given root into the provided {@code javax.xml.transform.Result}.\n\t * <p>This implementation inspects the given result, and calls {@code marshalDomResult},\n\t * {@code marshalSaxResult}, or {@code marshalStreamResult}.\n\t * @param graph the root of the object graph to marshal\n\t * @param result the result to marshal to\n\t * @throws IOException if an I/O exception occurs\n\t * @throws XmlMappingException if the given object cannot be marshalled to the result\n\t * @throws IllegalArgumentException if {@code result} if neither a {@code DOMResult},\n\t * a {@code SAXResult}, nor a {@code StreamResult}\n\t * @see #marshalDomResult(Object, javax.xml.transform.dom.DOMResult)\n\t * @see #marshalSaxResult(Object, javax.xml.transform.sax.SAXResult)\n\t * @see #marshalStreamResult(Object, javax.xml.transform.stream.StreamResult)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "graph",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "void",
    "signature": "public void marshal(Object graph, Result result)",
    "source_code": "\tpublic final void marshal(Object graph, Result result) throws IOException, XmlMappingException {\n\t\tif (result instanceof DOMResult domResult) {\n\t\t\tmarshalDomResult(graph, domResult);\n\t\t}\n\t\telse if (StaxUtils.isStaxResult(result)) {\n\t\t\tmarshalStaxResult(graph, result);\n\t\t}\n\t\telse if (result instanceof SAXResult saxResult) {\n\t\t\tmarshalSaxResult(graph, saxResult);\n\t\t}\n\t\telse if (result instanceof StreamResult streamResult) {\n\t\t\tmarshalStreamResult(graph, streamResult);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Unknown Result type: \" + result.getClass());\n\t\t}\n\t}"
  },
  "org.springframework.oxm.support.AbstractMarshaller#marshalDomNode(graph,node)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method for marshalling the given object graph to a DOM {@code Node}.\n\t * <p>In practice, {@code node} is a {@code Document} node, a {@code DocumentFragment} node,\n\t * or a {@code Element} node. In other words, a node that accepts children.\n\t * @param graph the root of the object graph to marshal\n\t * @param node the DOM node that will contain the result tree\n\t * @throws XmlMappingException if the given object cannot be marshalled to the DOM node\n\t * @see org.w3c.dom.Document\n\t * @see org.w3c.dom.DocumentFragment\n\t * @see org.w3c.dom.Element\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "node"
    ],
    "position": {
      "column": 1,
      "line": 505
    },
    "return": "void",
    "signature": "protected void marshalDomNode(Object graph, Node node)",
    "source_code": "\tprotected abstract void marshalDomNode(Object graph, Node node)"
  },
  "org.springframework.oxm.support.AbstractMarshaller#marshalDomResult(graph,domResult)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Template method for handling {@code DOMResult}s.\n\t * <p>This implementation delegates to {@code marshalDomNode}.\n\t * @param graph the root of the object graph to marshal\n\t * @param domResult the {@code DOMResult}\n\t * @throws XmlMappingException if the given object cannot be marshalled to the result\n\t * @throws IllegalArgumentException if the {@code domResult} is empty\n\t * @see #marshalDomNode(Object, org.w3c.dom.Node)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "domResult"
    ],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "void",
    "signature": "protected void marshalDomResult(Object graph, DOMResult domResult)",
    "source_code": "\tprotected void marshalDomResult(Object graph, DOMResult domResult) throws XmlMappingException {\n\t\tif (domResult.getNode() == null) {\n\t\t\tdomResult.setNode(buildDocument());\n\t\t}\n\t\tmarshalDomNode(graph, domResult.getNode());\n\t}"
  },
  "org.springframework.oxm.support.AbstractMarshaller#marshalOutputStream(graph,outputStream)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method for marshalling the given object graph to a {@code OutputStream}.\n\t * @param graph the root of the object graph to marshal\n\t * @param outputStream the {@code OutputStream} to write to\n\t * @throws XmlMappingException if the given object cannot be marshalled to the writer\n\t * @throws IOException if an I/O exception occurs\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "outputStream"
    ],
    "position": {
      "column": 1,
      "line": 544
    },
    "return": "void",
    "signature": "protected void marshalOutputStream(Object graph, OutputStream outputStream)",
    "source_code": "\tprotected abstract void marshalOutputStream(Object graph, OutputStream outputStream)"
  },
  "org.springframework.oxm.support.AbstractMarshaller#marshalSaxHandlers(graph,contentHandler,lexicalHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method for marshalling the given object graph to a SAX {@code ContentHandler}.\n\t * @param graph the root of the object graph to marshal\n\t * @param contentHandler the SAX {@code ContentHandler}\n\t * @param lexicalHandler the SAX2 {@code LexicalHandler}. Can be {@code null}.\n\t * @throws XmlMappingException if the given object cannot be marshalled to the handlers\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "contentHandler",
      "lexicalHandler"
    ],
    "position": {
      "column": 1,
      "line": 533
    },
    "return": "void",
    "signature": "protected void marshalSaxHandlers(Object graph, ContentHandler contentHandler, @Nullable LexicalHandler lexicalHandler)",
    "source_code": "\tprotected abstract void marshalSaxHandlers("
  },
  "org.springframework.oxm.support.AbstractMarshaller#marshalSaxResult(graph,saxResult)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Template method for handling {@code SAXResult}s.\n\t * <p>This implementation delegates to {@code marshalSaxHandlers}.\n\t * @param graph the root of the object graph to marshal\n\t * @param saxResult the {@code SAXResult}\n\t * @throws XmlMappingException if the given object cannot be marshalled to the result\n\t * @see #marshalSaxHandlers(Object, org.xml.sax.ContentHandler, org.xml.sax.ext.LexicalHandler)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "saxResult"
    ],
    "position": {
      "column": 1,
      "line": 305
    },
    "return": "void",
    "signature": "protected void marshalSaxResult(Object graph, SAXResult saxResult)",
    "source_code": "\tprotected void marshalSaxResult(Object graph, SAXResult saxResult) throws XmlMappingException {\n\t\tContentHandler contentHandler = saxResult.getHandler();\n\t\tAssert.notNull(contentHandler, \"ContentHandler not set on SAXResult\");\n\t\tLexicalHandler lexicalHandler = saxResult.getLexicalHandler();\n\t\tmarshalSaxHandlers(graph, contentHandler, lexicalHandler);\n\t}"
  },
  "org.springframework.oxm.support.AbstractMarshaller#marshalStaxResult(graph,staxResult)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Template method for handling {@code StaxResult}s.\n\t * <p>This implementation delegates to {@code marshalXMLSteamWriter} or\n\t * {@code marshalXMLEventConsumer}, depending on what is contained in the\n\t * {@code StaxResult}.\n\t * @param graph the root of the object graph to marshal\n\t * @param staxResult a JAXP 1.4 {@link StAXSource}\n\t * @throws XmlMappingException if the given object cannot be marshalled to the result\n\t * @throws IllegalArgumentException if the {@code domResult} is empty\n\t * @see #marshalDomNode(Object, org.w3c.dom.Node)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "staxResult"
    ],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "void",
    "signature": "protected void marshalStaxResult(Object graph, Result staxResult)",
    "source_code": "\tprotected void marshalStaxResult(Object graph, Result staxResult) throws XmlMappingException {\n\t\tXMLStreamWriter streamWriter = StaxUtils.getXMLStreamWriter(staxResult);\n\t\tif (streamWriter != null) {\n\t\t\tmarshalXmlStreamWriter(graph, streamWriter);\n\t\t}\n\t\telse {\n\t\t\tXMLEventWriter eventWriter = StaxUtils.getXMLEventWriter(staxResult);\n\t\t\tif (eventWriter != null) {\n\t\t\t\tmarshalXmlEventWriter(graph, eventWriter);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"StaxResult contains neither XMLStreamWriter nor XMLEventConsumer\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.oxm.support.AbstractMarshaller#marshalStreamResult(graph,streamResult)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Template method for handling {@code StreamResult}s.\n\t * <p>This implementation delegates to {@code marshalOutputStream} or {@code marshalWriter},\n\t * depending on what is contained in the {@code StreamResult}\n\t * @param graph the root of the object graph to marshal\n\t * @param streamResult the {@code StreamResult}\n\t * @throws IOException if an I/O Exception occurs\n\t * @throws XmlMappingException if the given object cannot be marshalled to the result\n\t * @throws IllegalArgumentException if {@code streamResult} does neither\n\t * contain an {@code OutputStream} nor a {@code Writer}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "streamResult"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "void",
    "signature": "protected void marshalStreamResult(Object graph, StreamResult streamResult)",
    "source_code": "\tprotected void marshalStreamResult(Object graph, StreamResult streamResult)"
  },
  "org.springframework.oxm.support.AbstractMarshaller#marshalWriter(graph,writer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method for marshalling the given object graph to a {@code Writer}.\n\t * @param graph the root of the object graph to marshal\n\t * @param writer the {@code Writer} to write to\n\t * @throws XmlMappingException if the given object cannot be marshalled to the writer\n\t * @throws IOException if an I/O exception occurs\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "writer"
    ],
    "position": {
      "column": 1,
      "line": 554
    },
    "return": "void",
    "signature": "protected void marshalWriter(Object graph, Writer writer)",
    "source_code": "\tprotected abstract void marshalWriter(Object graph, Writer writer)"
  },
  "org.springframework.oxm.support.AbstractMarshaller#marshalXmlEventWriter(graph,eventWriter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method for marshalling the given object to a StAX {@code XMLEventWriter}.\n\t * @param graph the root of the object graph to marshal\n\t * @param eventWriter the {@code XMLEventWriter} to write to\n\t * @throws XmlMappingException if the given object cannot be marshalled to the DOM node\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "eventWriter"
    ],
    "position": {
      "column": 1,
      "line": 514
    },
    "return": "void",
    "signature": "protected void marshalXmlEventWriter(Object graph, XMLEventWriter eventWriter)",
    "source_code": "\tprotected abstract void marshalXmlEventWriter(Object graph, XMLEventWriter eventWriter)"
  },
  "org.springframework.oxm.support.AbstractMarshaller#marshalXmlStreamWriter(graph,streamWriter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method for marshalling the given object to a StAX {@code XMLStreamWriter}.\n\t * @param graph the root of the object graph to marshal\n\t * @param streamWriter the {@code XMLStreamWriter} to write to\n\t * @throws XmlMappingException if the given object cannot be marshalled to the DOM node\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "streamWriter"
    ],
    "position": {
      "column": 1,
      "line": 523
    },
    "return": "void",
    "signature": "protected void marshalXmlStreamWriter(Object graph, XMLStreamWriter streamWriter)",
    "source_code": "\tprotected abstract void marshalXmlStreamWriter(Object graph, XMLStreamWriter streamWriter)"
  },
  "org.springframework.oxm.support.AbstractMarshaller#setProcessExternalEntities(processExternalEntities)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Indicate whether external XML entities are processed when unmarshalling.\n\t * <p>Default is {@code false}, meaning that external entities are not resolved.\n\t * Note that processing of external entities will only be enabled/disabled when the\n\t * {@code Source} passed to {@link #unmarshal(Source)} is a {@link SAXSource} or\n\t * {@link StreamSource}. It has no effect for {@link DOMSource} or {@link StAXSource}\n\t * instances.\n\t * <p><strong>Note:</strong> setting this option to {@code true} also\n\t * automatically sets {@link #setSupportDtd} to {@code true}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "processExternalEntities"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "void",
    "signature": "public void setProcessExternalEntities(boolean processExternalEntities)",
    "source_code": "\tpublic void setProcessExternalEntities(boolean processExternalEntities) {\n\t\tthis.processExternalEntities = processExternalEntities;\n\t\tif (processExternalEntities) {\n\t\t\tthis.supportDtd = true;\n\t\t}\n\t}"
  },
  "org.springframework.oxm.support.AbstractMarshaller#setSupportDtd(supportDtd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Indicate whether DTD parsing should be supported.\n\t * <p>Default is {@code false} meaning that DTD is disabled.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "supportDtd"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "void",
    "signature": "public void setSupportDtd(boolean supportDtd)",
    "source_code": "\tpublic void setSupportDtd(boolean supportDtd) {\n\t\tthis.supportDtd = supportDtd;\n\t}"
  },
  "org.springframework.oxm.support.AbstractMarshaller#unmarshal(source)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Unmarshals the given provided {@code javax.xml.transform.Source} into an object graph.\n\t * <p>This implementation inspects the given result, and calls {@code unmarshalDomSource},\n\t * {@code unmarshalSaxSource}, or {@code unmarshalStreamSource}.\n\t * @param source the source to marshal from\n\t * @return the object graph\n\t * @throws IOException if an I/O Exception occurs\n\t * @throws XmlMappingException if the given source cannot be mapped to an object\n\t * @throws IllegalArgumentException if {@code source} is neither a {@code DOMSource},\n\t * a {@code SAXSource}, nor a {@code StreamSource}\n\t * @see #unmarshalDomSource(javax.xml.transform.dom.DOMSource)\n\t * @see #unmarshalSaxSource(javax.xml.transform.sax.SAXSource)\n\t * @see #unmarshalStreamSource(javax.xml.transform.stream.StreamSource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source"
    ],
    "position": {
      "column": 1,
      "line": 355
    },
    "return": "Object",
    "signature": "public Object unmarshal(Source source)",
    "source_code": "\tpublic final Object unmarshal(Source source) throws IOException, XmlMappingException {\n\t\tif (source instanceof DOMSource domSource) {\n\t\t\treturn unmarshalDomSource(domSource);\n\t\t}\n\t\telse if (StaxUtils.isStaxSource(source)) {\n\t\t\treturn unmarshalStaxSource(source);\n\t\t}\n\t\telse if (source instanceof SAXSource saxSource) {\n\t\t\treturn unmarshalSaxSource(saxSource);\n\t\t}\n\t\telse if (source instanceof StreamSource streamSource) {\n\t\t\treturn unmarshalStreamSource(streamSource);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Unknown Source type: \" + source.getClass());\n\t\t}\n\t}"
  },
  "org.springframework.oxm.support.AbstractMarshaller#unmarshalDomNode(node)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method for unmarshalling from a given DOM {@code Node}.\n\t * @param node the DOM node that contains the objects to be unmarshalled\n\t * @return the object graph\n\t * @throws XmlMappingException if the given DOM node cannot be mapped to an object\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "node"
    ],
    "position": {
      "column": 1,
      "line": 563
    },
    "return": "Object",
    "signature": "protected Object unmarshalDomNode(Node node)",
    "source_code": "\tprotected abstract Object unmarshalDomNode(Node node) throws XmlMappingException;"
  },
  "org.springframework.oxm.support.AbstractMarshaller#unmarshalDomSource(domSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Template method for handling {@code DOMSource}s.\n\t * <p>This implementation delegates to {@code unmarshalDomNode}.\n\t * If the given source is empty, an empty source {@code Document}\n\t * will be created as a placeholder.\n\t * @param domSource the {@code DOMSource}\n\t * @return the object graph\n\t * @throws XmlMappingException if the given source cannot be mapped to an object\n\t * @throws IllegalArgumentException if the {@code domSource} is empty\n\t * @see #unmarshalDomNode(org.w3c.dom.Node)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "domSource"
    ],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "Object",
    "signature": "protected Object unmarshalDomSource(DOMSource domSource)",
    "source_code": "\tprotected Object unmarshalDomSource(DOMSource domSource) throws XmlMappingException {\n\t\tif (domSource.getNode() == null) {\n\t\t\tdomSource.setNode(buildDocument());\n\t\t}\n\t\ttry {\n\t\t\treturn unmarshalDomNode(domSource.getNode());\n\t\t}\n\t\tcatch (NullPointerException ex) {\n\t\t\tif (!isSupportDtd()) {\n\t\t\t\tthrow new UnmarshallingFailureException(\"NPE while unmarshalling. \" +\n\t\t\t\t\t\t\"This can happen on JDK 1.6 due to the presence of DTD \" +\n\t\t\t\t\t\t\"declarations, which are disabled.\", ex);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t}"
  },
  "org.springframework.oxm.support.AbstractMarshaller#unmarshalInputStream(inputStream)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method for unmarshalling from a given {@code InputStream}.\n\t * @param inputStream the {@code InputStreamStream} to read from\n\t * @return the object graph\n\t * @throws XmlMappingException if the given stream cannot be converted to an object\n\t * @throws IOException if an I/O exception occurs\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "inputStream"
    ],
    "position": {
      "column": 1,
      "line": 602
    },
    "return": "Object",
    "signature": "protected Object unmarshalInputStream(InputStream inputStream)",
    "source_code": "\tprotected abstract Object unmarshalInputStream(InputStream inputStream)"
  },
  "org.springframework.oxm.support.AbstractMarshaller#unmarshalReader(reader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method for unmarshalling from a given {@code Reader}.\n\t * @param reader the {@code Reader} to read from\n\t * @return the object graph\n\t * @throws XmlMappingException if the given reader cannot be converted to an object\n\t * @throws IOException if an I/O exception occurs\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "reader"
    ],
    "position": {
      "column": 1,
      "line": 612
    },
    "return": "Object",
    "signature": "protected Object unmarshalReader(Reader reader)",
    "source_code": "\tprotected abstract Object unmarshalReader(Reader reader)"
  },
  "org.springframework.oxm.support.AbstractMarshaller#unmarshalSaxReader(xmlReader,inputSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method for unmarshalling using a given SAX {@code XMLReader}\n\t * and {@code InputSource}.\n\t * @param xmlReader the SAX {@code XMLReader} to parse with\n\t * @param inputSource the input source to parse from\n\t * @return the object graph\n\t * @throws XmlMappingException if the given reader and input source cannot be converted to an object\n\t * @throws IOException if an I/O exception occurs\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "xmlReader",
      "inputSource"
    ],
    "position": {
      "column": 1,
      "line": 592
    },
    "return": "Object",
    "signature": "protected Object unmarshalSaxReader(XMLReader xmlReader, InputSource inputSource)",
    "source_code": "\tprotected abstract Object unmarshalSaxReader(XMLReader xmlReader, InputSource inputSource)"
  },
  "org.springframework.oxm.support.AbstractMarshaller#unmarshalSaxSource(saxSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Template method for handling {@code SAXSource}s.\n\t * <p>This implementation delegates to {@code unmarshalSaxReader}.\n\t * @param saxSource the {@code SAXSource}\n\t * @return the object graph\n\t * @throws XmlMappingException if the given source cannot be mapped to an object\n\t * @throws IOException if an I/O Exception occurs\n\t * @see #unmarshalSaxReader(org.xml.sax.XMLReader, org.xml.sax.InputSource)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "saxSource"
    ],
    "position": {
      "column": 1,
      "line": 434
    },
    "return": "Object",
    "signature": "protected Object unmarshalSaxSource(SAXSource saxSource)",
    "source_code": "\tprotected Object unmarshalSaxSource(SAXSource saxSource) throws XmlMappingException, IOException {\n\t\tif (saxSource.getXMLReader() == null) {\n\t\t\ttry {\n\t\t\t\tsaxSource.setXMLReader(createXmlReader());\n\t\t\t}\n\t\t\tcatch (SAXException | ParserConfigurationException ex) {\n\t\t\t\tthrow new UnmarshallingFailureException(\"Could not create XMLReader for SAXSource\", ex);\n\t\t\t}\n\t\t}\n\t\tif (saxSource.getInputSource() == null) {\n\t\t\tsaxSource.setInputSource(new InputSource());\n\t\t}\n\t\ttry {\n\t\t\treturn unmarshalSaxReader(saxSource.getXMLReader(), saxSource.getInputSource());\n\t\t}\n\t\tcatch (NullPointerException ex) {\n\t\t\tif (!isSupportDtd()) {\n\t\t\t\tthrow new UnmarshallingFailureException(\"NPE while unmarshalling. \" +\n\t\t\t\t\t\t\"This can happen on JDK 1.6 due to the presence of DTD \" +\n\t\t\t\t\t\t\"declarations, which are disabled.\");\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t}"
  },
  "org.springframework.oxm.support.AbstractMarshaller#unmarshalStaxSource(staxSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Template method for handling {@code StaxSource}s.\n\t * <p>This implementation delegates to {@code unmarshalXmlStreamReader} or\n\t * {@code unmarshalXmlEventReader}.\n\t * @param staxSource the {@code StaxSource}\n\t * @return the object graph\n\t * @throws XmlMappingException if the given source cannot be mapped to an object\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "staxSource"
    ],
    "position": {
      "column": 1,
      "line": 409
    },
    "return": "Object",
    "signature": "protected Object unmarshalStaxSource(Source staxSource)",
    "source_code": "\tprotected Object unmarshalStaxSource(Source staxSource) throws XmlMappingException {\n\t\tXMLStreamReader streamReader = StaxUtils.getXMLStreamReader(staxSource);\n\t\tif (streamReader != null) {\n\t\t\treturn unmarshalXmlStreamReader(streamReader);\n\t\t}\n\t\telse {\n\t\t\tXMLEventReader eventReader = StaxUtils.getXMLEventReader(staxSource);\n\t\t\tif (eventReader != null) {\n\t\t\t\treturn unmarshalXmlEventReader(eventReader);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"StaxSource contains neither XMLStreamReader nor XMLEventReader\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.oxm.support.AbstractMarshaller#unmarshalStreamSource(streamSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Template method for handling {@code StreamSource}s.\n\t * <p>This implementation delegates to {@code unmarshalInputStream} or {@code unmarshalReader}.\n\t * @param streamSource the {@code StreamSource}\n\t * @return the object graph\n\t * @throws IOException if an I/O exception occurs\n\t * @throws XmlMappingException if the given source cannot be mapped to an object\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "streamSource"
    ],
    "position": {
      "column": 1,
      "line": 467
    },
    "return": "Object",
    "signature": "protected Object unmarshalStreamSource(StreamSource streamSource)",
    "source_code": "\tprotected Object unmarshalStreamSource(StreamSource streamSource) throws XmlMappingException, IOException {\n\t\tif (streamSource.getInputStream() != null) {\n\t\t\tif (isProcessExternalEntities() && isSupportDtd()) {\n\t\t\t\treturn unmarshalInputStream(streamSource.getInputStream());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tInputSource inputSource = new InputSource(streamSource.getInputStream());\n\t\t\t\tinputSource.setEncoding(getDefaultEncoding());\n\t\t\t\treturn unmarshalSaxSource(new SAXSource(inputSource));\n\t\t\t}\n\t\t}\n\t\telse if (streamSource.getReader() != null) {\n\t\t\tif (isProcessExternalEntities() && isSupportDtd()) {\n\t\t\t\treturn unmarshalReader(streamSource.getReader());\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn unmarshalSaxSource(new SAXSource(new InputSource(streamSource.getReader())));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn unmarshalSaxSource(new SAXSource(new InputSource(streamSource.getSystemId())));\n\t\t}\n\t}"
  },
  "org.springframework.oxm.support.AbstractMarshaller#unmarshalXmlEventReader(eventReader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method for unmarshalling from a given Stax {@code XMLEventReader}.\n\t * @param eventReader the {@code XMLEventReader} to read from\n\t * @return the object graph\n\t * @throws XmlMappingException if the given event reader cannot be converted to an object\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "eventReader"
    ],
    "position": {
      "column": 1,
      "line": 571
    },
    "return": "Object",
    "signature": "protected Object unmarshalXmlEventReader(XMLEventReader eventReader)",
    "source_code": "\tprotected abstract Object unmarshalXmlEventReader(XMLEventReader eventReader)"
  },
  "org.springframework.oxm.support.AbstractMarshaller#unmarshalXmlStreamReader(streamReader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method for unmarshalling from a given Stax {@code XMLStreamReader}.\n\t * @param streamReader the {@code XMLStreamReader} to read from\n\t * @return the object graph\n\t * @throws XmlMappingException if the given stream reader cannot be converted to an object\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "streamReader"
    ],
    "position": {
      "column": 1,
      "line": 580
    },
    "return": "Object",
    "signature": "protected Object unmarshalXmlStreamReader(XMLStreamReader streamReader)",
    "source_code": "\tprotected abstract Object unmarshalXmlStreamReader(XMLStreamReader streamReader)"
  },
  "org.springframework.oxm.support.logger": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Logger available to subclasses. */",
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.r2dbc.connection.CONNECTION_SYNCHRONIZATION_ORDER": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Order value for ReactiveTransactionSynchronization objects that clean up R2DBC Connections.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "signature": "public int CONNECTION_SYNCHRONIZATION_ORDER",
    "source_code": "\tpublic static final int CONNECTION_SYNCHRONIZATION_ORDER = 1000;",
    "type": "int"
  },
  "org.springframework.r2dbc.connection.ConnectionFactoryUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Helper class that provides static methods for obtaining R2DBC Connections from\n * a {@link ConnectionFactory}.\n *\n * <p>Used internally by Spring's {@code DatabaseClient}, Spring's R2DBC operation\n * objects. Can also be used directly in application code.\n *\n * @author Mark Paluch\n * @author Christoph Strobl\n * @since 5.3\n * @see R2dbcTransactionManager\n * @see org.springframework.transaction.reactive.TransactionSynchronizationManager\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "signature": "public class ConnectionFactoryUtils",
    "source_code": "public abstract class ConnectionFactoryUtils {\n\n\t/**\n\t * Order value for ReactiveTransactionSynchronization objects that clean up R2DBC Connections.\n\t */\n\tpublic static final int CONNECTION_SYNCHRONIZATION_ORDER = 1000;\n\n\n\t/**\n\t * Obtain a {@link Connection} from the given {@link ConnectionFactory}.\n\t * Translates exceptions into the Spring hierarchy of unchecked generic\n\t * data access exceptions, simplifying calling code and making any\n\t * exception that is thrown more meaningful.\n\t * <p>Is aware of a corresponding Connection bound to the current\n\t * {@link TransactionSynchronizationManager}. Will bind a Connection to the\n\t * {@link TransactionSynchronizationManager} if transaction synchronization is active.\n\t * @param connectionFactory the {@link ConnectionFactory} to obtain\n\t * {@link Connection Connections} from\n\t * @return a R2DBC Connection from the given {@link ConnectionFactory}\n\t * @throws DataAccessResourceFailureException if the attempt to get a\n\t * {@link Connection} failed\n\t * @see #releaseConnection\n\t */\n\tpublic static Mono<Connection> getConnection(ConnectionFactory connectionFactory) {\n\t\treturn doGetConnection(connectionFactory)\n\t\t\t\t.onErrorMap(e -> new DataAccessResourceFailureException(\"Failed to obtain R2DBC Connection\", e));\n\t}\n\n\t/**\n\t * Actually obtain a R2DBC Connection from the given {@link ConnectionFactory}.\n\t * Same as {@link #getConnection}, but preserving the original exceptions.\n\t * <p>Is aware of a corresponding Connection bound to the current\n\t * {@link TransactionSynchronizationManager}. Will bind a Connection to the\n\t * {@link TransactionSynchronizationManager} if transaction synchronization is active\n\t * @param connectionFactory the {@link ConnectionFactory} to obtain Connections from\n\t * @return a R2DBC {@link Connection} from the given {@link ConnectionFactory}.\n\t */\n\tpublic static Mono<Connection> doGetConnection(ConnectionFactory connectionFactory) {\n\t\tAssert.notNull(connectionFactory, \"ConnectionFactory must not be null\");\n\t\treturn TransactionSynchronizationManager.forCurrentTransaction().flatMap(synchronizationManager -> {\n\n\t\t\tConnectionHolder conHolder = (ConnectionHolder) synchronizationManager.getResource(connectionFactory);\n\t\t\tif (conHolder != null && (conHolder.hasConnection() || conHolder.isSynchronizedWithTransaction())) {\n\t\t\t\tconHolder.requested();\n\t\t\t\tif (!conHolder.hasConnection()) {\n\t\t\t\t\treturn fetchConnection(connectionFactory).doOnNext(conHolder::setConnection);\n\t\t\t\t}\n\t\t\t\treturn Mono.just(conHolder.getConnection());\n\t\t\t}\n\t\t\t// Else we either got no holder or an empty thread-bound holder here.\n\n\t\t\tMono<Connection> con = fetchConnection(connectionFactory);\n\t\t\tif (synchronizationManager.isSynchronizationActive()) {\n\t\t\t\treturn con.flatMap(connection -> Mono.just(connection).doOnNext(conn -> {\n\t\t\t\t\t// Use same Connection for further R2DBC actions within the transaction.\n\t\t\t\t\t// Thread-bound object will get removed by synchronization at transaction completion.\n\t\t\t\t\tConnectionHolder holderToUse = conHolder;\n\t\t\t\t\tif (holderToUse == null) {\n\t\t\t\t\t\tholderToUse = new ConnectionHolder(conn);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tholderToUse.setConnection(conn);\n\t\t\t\t\t}\n\t\t\t\t\tholderToUse.requested();\n\t\t\t\t\tsynchronizationManager\n\t\t\t\t\t\t\t.registerSynchronization(new ConnectionSynchronization(holderToUse, connectionFactory));\n\t\t\t\t\tholderToUse.setSynchronizedWithTransaction(true);\n\t\t\t\t\tif (holderToUse != conHolder) {\n\t\t\t\t\t\tsynchronizationManager.bindResource(connectionFactory, holderToUse);\n\t\t\t\t\t}\n\t\t\t\t})      // Unexpected exception from external delegation call -> close Connection and rethrow.\n\t\t\t\t.onErrorResume(e -> releaseConnection(connection, connectionFactory).then(Mono.error(e))));\n\t\t\t}\n\t\t\treturn con;\n\t\t}).onErrorResume(NoTransactionException.class, e -> Mono.from(connectionFactory.create()));\n\t}\n\n\t/**\n\t * Actually fetch a {@link Connection} from the given {@link ConnectionFactory}.\n\t * @param connectionFactory the {@link ConnectionFactory} to obtain\n\t * {@link Connection}s from\n\t * @return a R2DBC {@link Connection} from the given {@link ConnectionFactory}\n\t * (never {@code null}).\n\t * @throws IllegalStateException if the {@link ConnectionFactory} returned a {@code null} value.\n\t * @see ConnectionFactory#create()\n\t */\n\tprivate static Mono<Connection> fetchConnection(ConnectionFactory connectionFactory) {\n\t\treturn Mono.from(connectionFactory.create());\n\t}\n\n\t/**\n\t * Close the given {@link Connection}, obtained from the given {@link ConnectionFactory}, if\n\t * it is not managed externally (that is, not bound to the subscription).\n\t * @param con the {@link Connection} to close if necessary\n\t * @param connectionFactory the {@link ConnectionFactory} that the Connection was obtained from\n\t * @see #getConnection\n\t */\n\tpublic static Mono<Void> releaseConnection(Connection con, ConnectionFactory connectionFactory) {\n\t\treturn doReleaseConnection(con, connectionFactory)\n\t\t\t\t.onErrorMap(e -> new DataAccessResourceFailureException(\"Failed to close R2DBC Connection\", e));\n\t}\n\n\t/**\n\t * Actually close the given {@link Connection}, obtained from the given\n\t * {@link ConnectionFactory}. Same as {@link #releaseConnection},\n\t * but preserving the original exception.\n\t * @param connection the {@link Connection} to close if necessary\n\t * @param connectionFactory the {@link ConnectionFactory} that the Connection was obtained from\n\t * @see #doGetConnection\n\t */\n\tpublic static Mono<Void> doReleaseConnection(Connection connection, ConnectionFactory connectionFactory) {\n\t\treturn TransactionSynchronizationManager.forCurrentTransaction()\n\t\t\t\t.flatMap(synchronizationManager -> {\n\t\t\tConnectionHolder conHolder = (ConnectionHolder) synchronizationManager.getResource(connectionFactory);\n\t\t\tif (conHolder != null && connectionEquals(conHolder, connection)) {\n\t\t\t\t// It's the transactional Connection: Don't close it.\n\t\t\t\tconHolder.released();\n\t\t\t}\n\t\t\treturn Mono.from(connection.close());\n\t\t}).onErrorResume(NoTransactionException.class, e -> Mono.from(connection.close()));\n\t}\n\n\t/**\n\t * Obtain the {@link ConnectionFactory} from the current {@link TransactionSynchronizationManager}.\n\t * @param connectionFactory the {@link ConnectionFactory} that the Connection was obtained from\n\t * @see TransactionSynchronizationManager\n\t */\n\tpublic static Mono<ConnectionFactory> currentConnectionFactory(ConnectionFactory connectionFactory) {\n\t\treturn TransactionSynchronizationManager.forCurrentTransaction()\n\t\t\t\t.filter(TransactionSynchronizationManager::isSynchronizationActive)\n\t\t\t\t.filter(synchronizationManager -> {\n\t\t\t\t\tConnectionHolder conHolder = (ConnectionHolder) synchronizationManager.getResource(connectionFactory);\n\t\t\t\t\treturn conHolder != null && (conHolder.hasConnection() || conHolder.isSynchronizedWithTransaction());\n\t\t\t\t}).map(synchronizationManager -> connectionFactory);\n\t}\n\n\t/**\n\t * Translate the given {@link R2dbcException} into a generic {@link DataAccessException}.\n\t * <p>The returned DataAccessException is supposed to contain the original\n\t * {@link R2dbcException} as root cause. However, client code may not generally\n\t * rely on this due to DataAccessExceptions possibly being caused by other resource\n\t * APIs as well. That said, a {@code getRootCause() instanceof R2dbcException}\n\t * check (and subsequent cast) is considered reliable when expecting R2DBC-based\n\t * access to have happened.\n\t * @param task readable text describing the task being attempted\n\t * @param sql the SQL query or update that caused the problem (if known)\n\t * @param ex the offending {@link R2dbcException}\n\t * @return the corresponding DataAccessException instance\n\t */\n\tpublic static DataAccessException convertR2dbcException(String task, @Nullable String sql, R2dbcException ex) {\n\t\tif (ex instanceof R2dbcTransientException) {\n\t\t\tif (ex instanceof R2dbcTransientResourceException) {\n\t\t\t\treturn new TransientDataAccessResourceException(buildMessage(task, sql, ex), ex);\n\t\t\t}\n\t\t\tif (ex instanceof R2dbcRollbackException) {\n\t\t\t\tif (\"40001\".equals(ex.getSqlState())) {\n\t\t\t\t\treturn new CannotAcquireLockException(buildMessage(task, sql, ex), ex);\n\t\t\t\t}\n\t\t\t\treturn new PessimisticLockingFailureException(buildMessage(task, sql, ex), ex);\n\t\t\t}\n\t\t\tif (ex instanceof R2dbcTimeoutException) {\n\t\t\t\treturn new QueryTimeoutException(buildMessage(task, sql, ex), ex);\n\t\t\t}\n\t\t}\n\t\telse if (ex instanceof R2dbcNonTransientException) {\n\t\t\tif (ex instanceof R2dbcNonTransientResourceException) {\n\t\t\t\treturn new DataAccessResourceFailureException(buildMessage(task, sql, ex), ex);\n\t\t\t}\n\t\t\tif (ex instanceof R2dbcDataIntegrityViolationException) {\n\t\t\t\tif (indicatesDuplicateKey(ex.getSqlState(), ex.getErrorCode())) {\n\t\t\t\t\treturn new DuplicateKeyException(buildMessage(task, sql, ex), ex);\n\t\t\t\t}\n\t\t\t\treturn new DataIntegrityViolationException(buildMessage(task, sql, ex), ex);\n\t\t\t}\n\t\t\tif (ex instanceof R2dbcPermissionDeniedException) {\n\t\t\t\treturn new PermissionDeniedDataAccessException(buildMessage(task, sql, ex), ex);\n\t\t\t}\n\t\t\tif (ex instanceof R2dbcBadGrammarException) {\n\t\t\t\treturn new BadSqlGrammarException(task, (sql != null ? sql : \"\"), ex);\n\t\t\t}\n\t\t}\n\t\treturn new UncategorizedR2dbcException(buildMessage(task, sql, ex), sql, ex);\n\t}\n\n\t/**\n\t * Check whether the given SQL state (and the associated error code in case\n\t * of a generic SQL state value) indicate a duplicate key exception. See\n\t * {@code org.springframework.jdbc.support.SQLStateSQLExceptionTranslator#indicatesDuplicateKey}.\n\t * @param sqlState the SQL state value\n\t * @param errorCode the error code value\n\t */\n\tstatic boolean indicatesDuplicateKey(@Nullable String sqlState, int errorCode) {\n\t\treturn (\"23505\".equals(sqlState) ||\n\t\t\t\t(\"23000\".equals(sqlState) &&\n\t\t\t\t\t\t(errorCode == 1 || errorCode == 1062 || errorCode == 2601 || errorCode == 2627)));\n\t}\n\n\t/**\n\t * Build a message {@code String} for the given {@link R2dbcException}.\n\t * <p>To be called by translator subclasses when creating an instance of a generic\n\t * {@link org.springframework.dao.DataAccessException} class.\n\t * @param task readable text describing the task being attempted\n\t * @param sql the SQL statement that caused the problem\n\t * @param ex the offending {@code R2dbcException}\n\t * @return the message {@code String} to use\n\t */\n\tprivate static String buildMessage(String task, @Nullable String sql, R2dbcException ex) {\n\t\treturn task + \"; \" + (sql != null ? (\"SQL [\" + sql + \"]; \") : \"\") + ex.getMessage();\n\t}\n\n\t/**\n\t * Determine whether the given two {@link Connection}s are equal, asking the target\n\t * {@link Connection} in case of a proxy. Used to detect equality even if the user\n\t * passed in a raw target Connection while the held one is a proxy.\n\t * @param conHolder the {@link ConnectionHolder} for the held {@link Connection} (potentially a proxy)\n\t * @param passedInCon the {@link Connection} passed-in by the user (potentially\n\t * a target {@link Connection} without proxy).\n\t * @return whether the given Connections are equal\n\t * @see #getTargetConnection\n\t */\n\tprivate static boolean connectionEquals(ConnectionHolder conHolder, Connection passedInCon) {\n\t\tif (!conHolder.hasConnection()) {\n\t\t\treturn false;\n\t\t}\n\t\tConnection heldCon = conHolder.getConnection();\n\t\t// Explicitly check for identity too: for Connection handles that do not implement\n\t\t// \"equals\" properly).\n\t\treturn (heldCon == passedInCon || heldCon.equals(passedInCon) || getTargetConnection(heldCon).equals(passedInCon));\n\t}\n\n\t/**\n\t * Return the innermost target {@link Connection} of the given {@link Connection}.\n\t * If the given {@link Connection} is wrapped, it will be unwrapped until a\n\t * plain {@link Connection} is found. Otherwise, the passed-in Connection\n\t * will be returned as-is.\n\t * @param con the {@link Connection} wrapper to unwrap\n\t * @return the innermost target Connection, or the passed-in one if not wrapped\n\t * @see Wrapped#unwrap()\n\t */\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n\tpublic static Connection getTargetConnection(Connection con) {\n\t\tObject conToUse = con;\n\t\twhile (conToUse instanceof Wrapped wrapped) {\n\t\t\tconToUse = wrapped.unwrap();\n\t\t}\n\t\treturn (Connection) conToUse;\n\t}\n\n\t/**\n\t * Determine the connection synchronization order to use for the given {@link ConnectionFactory}.\n\t * Decreased for every level of nesting that a {@link ConnectionFactory} has,\n\t * checked through the level of {@link DelegatingConnectionFactory} nesting.\n\t * @param connectionFactory the {@link ConnectionFactory} to check\n\t * @return the connection synchronization order to use\n\t * @see #CONNECTION_SYNCHRONIZATION_ORDER\n\t */\n\tprivate static int getConnectionSynchronizationOrder(ConnectionFactory connectionFactory) {\n\t\tint order = CONNECTION_SYNCHRONIZATION_ORDER;\n\t\tConnectionFactory current = connectionFactory;\n\t\twhile (current instanceof DelegatingConnectionFactory delegatingConnectionFactory) {\n\t\t\torder--;\n\t\t\tcurrent = delegatingConnectionFactory.getTargetConnectionFactory();\n\t\t}\n\t\treturn order;\n\t}\n\n\n\t/**\n\t * Callback for resource cleanup at the end of a non-native R2DBC transaction.\n\t */\n\tprivate static class ConnectionSynchronization implements TransactionSynchronization, Ordered {\n\n\t\tprivate final ConnectionHolder connectionHolder;\n\n\t\tprivate final ConnectionFactory connectionFactory;\n\n\t\tprivate final int order;\n\n\t\tprivate boolean holderActive = true;\n\n\t\tConnectionSynchronization(ConnectionHolder connectionHolder, ConnectionFactory connectionFactory) {\n\t\t\tthis.connectionHolder = connectionHolder;\n\t\t\tthis.connectionFactory = connectionFactory;\n\t\t\tthis.order = getConnectionSynchronizationOrder(connectionFactory);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getOrder() {\n\t\t\treturn this.order;\n\t\t}\n\n\t\t@Override\n\t\tpublic Mono<Void> suspend() {\n\t\t\tif (this.holderActive) {\n\t\t\t\treturn TransactionSynchronizationManager.forCurrentTransaction().flatMap(synchronizationManager -> {\n\t\t\t\t\tsynchronizationManager.unbindResource(this.connectionFactory);\n\t\t\t\t\tif (this.connectionHolder.hasConnection() && !this.connectionHolder.isOpen()) {\n\t\t\t\t\t\t// Release Connection on suspend if the application doesn't keep\n\t\t\t\t\t\t// a handle to it anymore. We will fetch a fresh Connection if the\n\t\t\t\t\t\t// application accesses the ConnectionHolder again after resume,\n\t\t\t\t\t\t// assuming that it will participate in the same transaction.\n\t\t\t\t\t\treturn releaseConnection(this.connectionHolder.getConnection(), this.connectionFactory)\n\t\t\t\t\t\t\t\t.doOnTerminate(() -> this.connectionHolder.setConnection(null));\n\t\t\t\t\t}\n\t\t\t\t\treturn Mono.empty();\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn Mono.empty();\n\t\t}\n\n\t\t@Override\n\t\tpublic Mono<Void> resume() {\n\t\t\tif (this.holderActive) {\n\t\t\t\treturn TransactionSynchronizationManager.forCurrentTransaction()\n\t\t\t\t\t\t.doOnNext(synchronizationManager ->\n\t\t\t\t\t\t\t\tsynchronizationManager.bindResource(this.connectionFactory, this.connectionHolder))\n\t\t\t\t\t\t.then();\n\t\t\t}\n\t\t\treturn Mono.empty();\n\t\t}\n\n\t\t@Override\n\t\tpublic Mono<Void> beforeCompletion() {\n\t\t\t// Release Connection early if the holder is not open anymore (that is,\n\t\t\t// not used by another resource that has its own cleanup via transaction\n\t\t\t// synchronization), to avoid issues with strict transaction implementations\n\t\t\t// that expect the close call before transaction completion.\n\t\t\tif (!this.connectionHolder.isOpen()) {\n\t\t\t\treturn TransactionSynchronizationManager.forCurrentTransaction().flatMap(synchronizationManager -> {\n\t\t\t\t\tsynchronizationManager.unbindResource(this.connectionFactory);\n\t\t\t\t\tthis.holderActive = false;\n\t\t\t\t\tif (this.connectionHolder.hasConnection()) {\n\t\t\t\t\t\treturn releaseConnection(this.connectionHolder.getConnection(), this.connectionFactory);\n\t\t\t\t\t}\n\t\t\t\t\treturn Mono.empty();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn Mono.empty();\n\t\t}\n\n\t\t@Override\n\t\tpublic Mono<Void> afterCompletion(int status) {\n\t\t\t// If we haven't closed the Connection in beforeCompletion,\n\t\t\t// close it now.\n\t\t\tif (this.holderActive) {\n\t\t\t\t// The bound ConnectionHolder might not be available anymore,\n\t\t\t\t// since afterCompletion might get called from a different thread.\n\t\t\t\treturn TransactionSynchronizationManager.forCurrentTransaction().flatMap(synchronizationManager -> {\n\t\t\t\t\tsynchronizationManager.unbindResourceIfPossible(this.connectionFactory);\n\t\t\t\t\tthis.holderActive = false;\n\t\t\t\t\tif (this.connectionHolder.hasConnection()) {\n\t\t\t\t\t\treturn releaseConnection(this.connectionHolder.getConnection(), this.connectionFactory)\n\t\t\t\t\t\t\t\t// Reset the ConnectionHolder: It might remain bound to the context.\n\t\t\t\t\t\t\t\t.doOnTerminate(() -> this.connectionHolder.setConnection(null));\n\t\t\t\t\t}\n\t\t\t\t\treturn Mono.empty();\n\t\t\t\t});\n\t\t\t}\n\t\t\tthis.connectionHolder.reset();\n\t\t\treturn Mono.empty();\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.r2dbc.connection.ConnectionFactoryUtils#afterCompletion(status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 407
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> afterCompletion(int status)",
    "source_code": "\t\tpublic Mono<Void> afterCompletion(int status) {\n\t\t\t// If we haven't closed the Connection in beforeCompletion,\n\t\t\t// close it now.\n\t\t\tif (this.holderActive) {\n\t\t\t\t// The bound ConnectionHolder might not be available anymore,\n\t\t\t\t// since afterCompletion might get called from a different thread.\n\t\t\t\treturn TransactionSynchronizationManager.forCurrentTransaction().flatMap(synchronizationManager -> {\n\t\t\t\t\tsynchronizationManager.unbindResourceIfPossible(this.connectionFactory);\n\t\t\t\t\tthis.holderActive = false;\n\t\t\t\t\tif (this.connectionHolder.hasConnection()) {\n\t\t\t\t\t\treturn releaseConnection(this.connectionHolder.getConnection(), this.connectionFactory)\n\t\t\t\t\t\t\t\t// Reset the ConnectionHolder: It might remain bound to the context.\n\t\t\t\t\t\t\t\t.doOnTerminate(() -> this.connectionHolder.setConnection(null));\n\t\t\t\t\t}\n\t\t\t\t\treturn Mono.empty();\n\t\t\t\t});\n\t\t\t}\n\t\t\tthis.connectionHolder.reset();\n\t\t\treturn Mono.empty();\n\t\t}"
  },
  "org.springframework.r2dbc.connection.ConnectionFactoryUtils#beforeCompletion()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 387
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> beforeCompletion()",
    "source_code": "\t\tpublic Mono<Void> beforeCompletion() {\n\t\t\t// Release Connection early if the holder is not open anymore (that is,\n\t\t\t// not used by another resource that has its own cleanup via transaction\n\t\t\t// synchronization), to avoid issues with strict transaction implementations\n\t\t\t// that expect the close call before transaction completion.\n\t\t\tif (!this.connectionHolder.isOpen()) {\n\t\t\t\treturn TransactionSynchronizationManager.forCurrentTransaction().flatMap(synchronizationManager -> {\n\t\t\t\t\tsynchronizationManager.unbindResource(this.connectionFactory);\n\t\t\t\t\tthis.holderActive = false;\n\t\t\t\t\tif (this.connectionHolder.hasConnection()) {\n\t\t\t\t\t\treturn releaseConnection(this.connectionHolder.getConnection(), this.connectionFactory);\n\t\t\t\t\t}\n\t\t\t\t\treturn Mono.empty();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn Mono.empty();\n\t\t}"
  },
  "org.springframework.r2dbc.connection.ConnectionFactoryUtils#convertR2dbcException(task,sql,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Translate the given {@link R2dbcException} into a generic {@link DataAccessException}.\n\t * <p>The returned DataAccessException is supposed to contain the original\n\t * {@link R2dbcException} as root cause. However, client code may not generally\n\t * rely on this due to DataAccessExceptions possibly being caused by other resource\n\t * APIs as well. That said, a {@code getRootCause() instanceof R2dbcException}\n\t * check (and subsequent cast) is considered reliable when expecting R2DBC-based\n\t * access to have happened.\n\t * @param task readable text describing the task being attempted\n\t * @param sql the SQL query or update that caused the problem (if known)\n\t * @param ex the offending {@link R2dbcException}\n\t * @return the corresponding DataAccessException instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "sql",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "DataAccessException",
    "signature": "public DataAccessException convertR2dbcException(String task, @Nullable String sql, R2dbcException ex)",
    "source_code": "\tpublic static DataAccessException convertR2dbcException(String task, @Nullable String sql, R2dbcException ex) {\n\t\tif (ex instanceof R2dbcTransientException) {\n\t\t\tif (ex instanceof R2dbcTransientResourceException) {\n\t\t\t\treturn new TransientDataAccessResourceException(buildMessage(task, sql, ex), ex);\n\t\t\t}\n\t\t\tif (ex instanceof R2dbcRollbackException) {\n\t\t\t\tif (\"40001\".equals(ex.getSqlState())) {\n\t\t\t\t\treturn new CannotAcquireLockException(buildMessage(task, sql, ex), ex);\n\t\t\t\t}\n\t\t\t\treturn new PessimisticLockingFailureException(buildMessage(task, sql, ex), ex);\n\t\t\t}\n\t\t\tif (ex instanceof R2dbcTimeoutException) {\n\t\t\t\treturn new QueryTimeoutException(buildMessage(task, sql, ex), ex);\n\t\t\t}\n\t\t}\n\t\telse if (ex instanceof R2dbcNonTransientException) {\n\t\t\tif (ex instanceof R2dbcNonTransientResourceException) {\n\t\t\t\treturn new DataAccessResourceFailureException(buildMessage(task, sql, ex), ex);\n\t\t\t}\n\t\t\tif (ex instanceof R2dbcDataIntegrityViolationException) {\n\t\t\t\tif (indicatesDuplicateKey(ex.getSqlState(), ex.getErrorCode())) {\n\t\t\t\t\treturn new DuplicateKeyException(buildMessage(task, sql, ex), ex);\n\t\t\t\t}\n\t\t\t\treturn new DataIntegrityViolationException(buildMessage(task, sql, ex), ex);\n\t\t\t}\n\t\t\tif (ex instanceof R2dbcPermissionDeniedException) {\n\t\t\t\treturn new PermissionDeniedDataAccessException(buildMessage(task, sql, ex), ex);\n\t\t\t}\n\t\t\tif (ex instanceof R2dbcBadGrammarException) {\n\t\t\t\treturn new BadSqlGrammarException(task, (sql != null ? sql : \"\"), ex);\n\t\t\t}\n\t\t}\n\t\treturn new UncategorizedR2dbcException(buildMessage(task, sql, ex), sql, ex);\n\t}"
  },
  "org.springframework.r2dbc.connection.ConnectionFactoryUtils#currentConnectionFactory(connectionFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain the {@link ConnectionFactory} from the current {@link TransactionSynchronizationManager}.\n\t * @param connectionFactory the {@link ConnectionFactory} that the Connection was obtained from\n\t * @see TransactionSynchronizationManager\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connectionFactory"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "Mono<ConnectionFactory>",
    "signature": "public Mono<ConnectionFactory> currentConnectionFactory(ConnectionFactory connectionFactory)",
    "source_code": "\tpublic static Mono<ConnectionFactory> currentConnectionFactory(ConnectionFactory connectionFactory) {\n\t\treturn TransactionSynchronizationManager.forCurrentTransaction()\n\t\t\t\t.filter(TransactionSynchronizationManager::isSynchronizationActive)\n\t\t\t\t.filter(synchronizationManager -> {\n\t\t\t\t\tConnectionHolder conHolder = (ConnectionHolder) synchronizationManager.getResource(connectionFactory);\n\t\t\t\t\treturn conHolder != null && (conHolder.hasConnection() || conHolder.isSynchronizedWithTransaction());\n\t\t\t\t}).map(synchronizationManager -> connectionFactory);\n\t}"
  },
  "org.springframework.r2dbc.connection.ConnectionFactoryUtils#doGetConnection(connectionFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Actually obtain a R2DBC Connection from the given {@link ConnectionFactory}.\n\t * Same as {@link #getConnection}, but preserving the original exceptions.\n\t * <p>Is aware of a corresponding Connection bound to the current\n\t * {@link TransactionSynchronizationManager}. Will bind a Connection to the\n\t * {@link TransactionSynchronizationManager} if transaction synchronization is active\n\t * @param connectionFactory the {@link ConnectionFactory} to obtain Connections from\n\t * @return a R2DBC {@link Connection} from the given {@link ConnectionFactory}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connectionFactory"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "Mono<Connection>",
    "signature": "public Mono<Connection> doGetConnection(ConnectionFactory connectionFactory)",
    "source_code": "\tpublic static Mono<Connection> doGetConnection(ConnectionFactory connectionFactory) {\n\t\tAssert.notNull(connectionFactory, \"ConnectionFactory must not be null\");\n\t\treturn TransactionSynchronizationManager.forCurrentTransaction().flatMap(synchronizationManager -> {\n\n\t\t\tConnectionHolder conHolder = (ConnectionHolder) synchronizationManager.getResource(connectionFactory);\n\t\t\tif (conHolder != null && (conHolder.hasConnection() || conHolder.isSynchronizedWithTransaction())) {\n\t\t\t\tconHolder.requested();\n\t\t\t\tif (!conHolder.hasConnection()) {\n\t\t\t\t\treturn fetchConnection(connectionFactory).doOnNext(conHolder::setConnection);\n\t\t\t\t}\n\t\t\t\treturn Mono.just(conHolder.getConnection());\n\t\t\t}\n\t\t\t// Else we either got no holder or an empty thread-bound holder here.\n\n\t\t\tMono<Connection> con = fetchConnection(connectionFactory);\n\t\t\tif (synchronizationManager.isSynchronizationActive()) {\n\t\t\t\treturn con.flatMap(connection -> Mono.just(connection).doOnNext(conn -> {\n\t\t\t\t\t// Use same Connection for further R2DBC actions within the transaction.\n\t\t\t\t\t// Thread-bound object will get removed by synchronization at transaction completion.\n\t\t\t\t\tConnectionHolder holderToUse = conHolder;\n\t\t\t\t\tif (holderToUse == null) {\n\t\t\t\t\t\tholderToUse = new ConnectionHolder(conn);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tholderToUse.setConnection(conn);\n\t\t\t\t\t}\n\t\t\t\t\tholderToUse.requested();\n\t\t\t\t\tsynchronizationManager\n\t\t\t\t\t\t\t.registerSynchronization(new ConnectionSynchronization(holderToUse, connectionFactory));\n\t\t\t\t\tholderToUse.setSynchronizedWithTransaction(true);\n\t\t\t\t\tif (holderToUse != conHolder) {\n\t\t\t\t\t\tsynchronizationManager.bindResource(connectionFactory, holderToUse);\n\t\t\t\t\t}\n\t\t\t\t})      // Unexpected exception from external delegation call -> close Connection and rethrow.\n\t\t\t\t.onErrorResume(e -> releaseConnection(connection, connectionFactory).then(Mono.error(e))));\n\t\t\t}\n\t\t\treturn con;\n\t\t}).onErrorResume(NoTransactionException.class, e -> Mono.from(connectionFactory.create()));\n\t}"
  },
  "org.springframework.r2dbc.connection.ConnectionFactoryUtils#doReleaseConnection(connection,connectionFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Actually close the given {@link Connection}, obtained from the given\n\t * {@link ConnectionFactory}. Same as {@link #releaseConnection},\n\t * but preserving the original exception.\n\t * @param connection the {@link Connection} to close if necessary\n\t * @param connectionFactory the {@link ConnectionFactory} that the Connection was obtained from\n\t * @see #doGetConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connection",
      "connectionFactory"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> doReleaseConnection(Connection connection, ConnectionFactory connectionFactory)",
    "source_code": "\tpublic static Mono<Void> doReleaseConnection(Connection connection, ConnectionFactory connectionFactory) {\n\t\treturn TransactionSynchronizationManager.forCurrentTransaction()\n\t\t\t\t.flatMap(synchronizationManager -> {\n\t\t\tConnectionHolder conHolder = (ConnectionHolder) synchronizationManager.getResource(connectionFactory);\n\t\t\tif (conHolder != null && connectionEquals(conHolder, connection)) {\n\t\t\t\t// It's the transactional Connection: Don't close it.\n\t\t\t\tconHolder.released();\n\t\t\t}\n\t\t\treturn Mono.from(connection.close());\n\t\t}).onErrorResume(NoTransactionException.class, e -> Mono.from(connection.close()));\n\t}"
  },
  "org.springframework.r2dbc.connection.ConnectionFactoryUtils#getConnection(connectionFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a {@link Connection} from the given {@link ConnectionFactory}.\n\t * Translates exceptions into the Spring hierarchy of unchecked generic\n\t * data access exceptions, simplifying calling code and making any\n\t * exception that is thrown more meaningful.\n\t * <p>Is aware of a corresponding Connection bound to the current\n\t * {@link TransactionSynchronizationManager}. Will bind a Connection to the\n\t * {@link TransactionSynchronizationManager} if transaction synchronization is active.\n\t * @param connectionFactory the {@link ConnectionFactory} to obtain\n\t * {@link Connection Connections} from\n\t * @return a R2DBC Connection from the given {@link ConnectionFactory}\n\t * @throws DataAccessResourceFailureException if the attempt to get a\n\t * {@link Connection} failed\n\t * @see #releaseConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connectionFactory"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "Mono<Connection>",
    "signature": "public Mono<Connection> getConnection(ConnectionFactory connectionFactory)",
    "source_code": "\tpublic static Mono<Connection> getConnection(ConnectionFactory connectionFactory) {\n\t\treturn doGetConnection(connectionFactory)\n\t\t\t\t.onErrorMap(e -> new DataAccessResourceFailureException(\"Failed to obtain R2DBC Connection\", e));\n\t}"
  },
  "org.springframework.r2dbc.connection.ConnectionFactoryUtils#getOrder()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 352
    },
    "return": "int",
    "signature": "public int getOrder()",
    "source_code": "\t\tpublic int getOrder() {\n\t\t\treturn this.order;\n\t\t}"
  },
  "org.springframework.r2dbc.connection.ConnectionFactoryUtils#getTargetConnection(con)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the innermost target {@link Connection} of the given {@link Connection}.\n\t * If the given {@link Connection} is wrapped, it will be unwrapped until a\n\t * plain {@link Connection} is found. Otherwise, the passed-in Connection\n\t * will be returned as-is.\n\t * @param con the {@link Connection} wrapper to unwrap\n\t * @return the innermost target Connection, or the passed-in one if not wrapped\n\t * @see Wrapped#unwrap()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con"
    ],
    "position": {
      "column": 1,
      "line": 305
    },
    "return": "Connection",
    "signature": "public Connection getTargetConnection(Connection con)",
    "source_code": "\tpublic static Connection getTargetConnection(Connection con) {\n\t\tObject conToUse = con;\n\t\twhile (conToUse instanceof Wrapped wrapped) {\n\t\t\tconToUse = wrapped.unwrap();\n\t\t}\n\t\treturn (Connection) conToUse;\n\t}"
  },
  "org.springframework.r2dbc.connection.ConnectionFactoryUtils#releaseConnection(con,connectionFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Close the given {@link Connection}, obtained from the given {@link ConnectionFactory}, if\n\t * it is not managed externally (that is, not bound to the subscription).\n\t * @param con the {@link Connection} to close if necessary\n\t * @param connectionFactory the {@link ConnectionFactory} that the Connection was obtained from\n\t * @see #getConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con",
      "connectionFactory"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> releaseConnection(Connection con, ConnectionFactory connectionFactory)",
    "source_code": "\tpublic static Mono<Void> releaseConnection(Connection con, ConnectionFactory connectionFactory) {\n\t\treturn doReleaseConnection(con, connectionFactory)\n\t\t\t\t.onErrorMap(e -> new DataAccessResourceFailureException(\"Failed to close R2DBC Connection\", e));\n\t}"
  },
  "org.springframework.r2dbc.connection.ConnectionFactoryUtils#resume()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 376
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> resume()",
    "source_code": "\t\tpublic Mono<Void> resume() {\n\t\t\tif (this.holderActive) {\n\t\t\t\treturn TransactionSynchronizationManager.forCurrentTransaction()\n\t\t\t\t\t\t.doOnNext(synchronizationManager ->\n\t\t\t\t\t\t\t\tsynchronizationManager.bindResource(this.connectionFactory, this.connectionHolder))\n\t\t\t\t\t\t.then();\n\t\t\t}\n\t\t\treturn Mono.empty();\n\t\t}"
  },
  "org.springframework.r2dbc.connection.ConnectionFactoryUtils#suspend()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 357
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> suspend()",
    "source_code": "\t\tpublic Mono<Void> suspend() {\n\t\t\tif (this.holderActive) {\n\t\t\t\treturn TransactionSynchronizationManager.forCurrentTransaction().flatMap(synchronizationManager -> {\n\t\t\t\t\tsynchronizationManager.unbindResource(this.connectionFactory);\n\t\t\t\t\tif (this.connectionHolder.hasConnection() && !this.connectionHolder.isOpen()) {\n\t\t\t\t\t\t// Release Connection on suspend if the application doesn't keep\n\t\t\t\t\t\t// a handle to it anymore. We will fetch a fresh Connection if the\n\t\t\t\t\t\t// application accesses the ConnectionHolder again after resume,\n\t\t\t\t\t\t// assuming that it will participate in the same transaction.\n\t\t\t\t\t\treturn releaseConnection(this.connectionHolder.getConnection(), this.connectionFactory)\n\t\t\t\t\t\t\t\t.doOnTerminate(() -> this.connectionHolder.setConnection(null));\n\t\t\t\t\t}\n\t\t\t\t\treturn Mono.empty();\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn Mono.empty();\n\t\t}"
  },
  "org.springframework.r2dbc.connection.lookup.AbstractRoutingConnectionFactory": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract {@link ConnectionFactory} implementation that routes\n * {@link #create()} calls to one of various target\n * {@link ConnectionFactory factories} based on a lookup key.\n * The latter is typically (but not necessarily) determined from some\n * subscriber context.\n *\n * <p> Allows to configure a {@link #setDefaultTargetConnectionFactory(Object)\n * default ConnectionFactory} as fallback.\n *\n * <p> Calls to {@link #getMetadata()} are routed to the\n * {@link #setDefaultTargetConnectionFactory(Object) default ConnectionFactory}\n * if configured.\n *\n * @author Mark Paluch\n * @author Jens Schauder\n * @since 5.3\n * @see #setTargetConnectionFactories\n * @see #setDefaultTargetConnectionFactory\n * @see #determineCurrentLookupKey()\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "signature": "public class AbstractRoutingConnectionFactory",
    "source_code": "public abstract class AbstractRoutingConnectionFactory implements ConnectionFactory, InitializingBean {\n\n\tprivate static final Object FALLBACK_MARKER = new Object();\n\n\n\t@Nullable\n\tprivate Map<?, ?> targetConnectionFactories;\n\n\t@Nullable\n\tprivate Object defaultTargetConnectionFactory;\n\n\tprivate boolean lenientFallback = true;\n\n\tprivate ConnectionFactoryLookup connectionFactoryLookup = new MapConnectionFactoryLookup();\n\n\t@Nullable\n\tprivate Map<Object, ConnectionFactory> resolvedConnectionFactories;\n\n\t@Nullable\n\tprivate ConnectionFactory resolvedDefaultConnectionFactory;\n\n\n\t/**\n\t * Specify the map of target {@link ConnectionFactory ConnectionFactories},\n\t * with the lookup key as key. The mapped value can either be a corresponding\n\t * {@link ConnectionFactory} instance or a connection factory name String (to be\n\t * resolved via a {@link #setConnectionFactoryLookup ConnectionFactoryLookup}).\n\t * <p>The key can be of arbitrary type; this class implements the generic lookup\n\t * process only. The concrete key representation will be handled by\n\t * {@link #resolveSpecifiedLookupKey(Object)} and {@link #determineCurrentLookupKey()}.\n\t */\n\tpublic void setTargetConnectionFactories(Map<?, ?> targetConnectionFactories) {\n\t\tthis.targetConnectionFactories = targetConnectionFactories;\n\t}\n\n\t/**\n\t * Specify the default target {@link ConnectionFactory}, if any.\n\t * <p>The mapped value can either be a corresponding {@link ConnectionFactory}\n\t * instance or a connection factory name {@link String} (to be resolved via a\n\t * {@link #setConnectionFactoryLookup ConnectionFactoryLookup}).\n\t * <p>This {@link ConnectionFactory} will be used as target if none of the keyed\n\t * {@link #setTargetConnectionFactories targetConnectionFactories} match the\n\t * {@link #determineCurrentLookupKey() current lookup key}.\n\t */\n\tpublic void setDefaultTargetConnectionFactory(Object defaultTargetConnectionFactory) {\n\t\tthis.defaultTargetConnectionFactory = defaultTargetConnectionFactory;\n\t}\n\n\t/**\n\t * Specify whether to apply a lenient fallback to the default {@link ConnectionFactory}\n\t * if no specific {@link ConnectionFactory} could be found for the current lookup key.\n\t * <p>Default is {@code true}, accepting lookup keys without a corresponding entry\n\t * in the target {@link ConnectionFactory} map - simply falling back to the default\n\t * {@link ConnectionFactory} in that case.\n\t * <p>Switch this flag to {@code false} if you would prefer the fallback to only\n\t * apply when no lookup key was emitted. Lookup keys without a {@link ConnectionFactory}\n\t * entry will then lead to an {@link IllegalStateException}.\n\t * @see #setTargetConnectionFactories\n\t * @see #setDefaultTargetConnectionFactory\n\t * @see #determineCurrentLookupKey()\n\t */\n\tpublic void setLenientFallback(boolean lenientFallback) {\n\t\tthis.lenientFallback = lenientFallback;\n\t}\n\n\t/**\n\t * Set the {@link ConnectionFactoryLookup} implementation to use for resolving\n\t * connection factory name Strings in the {@link #setTargetConnectionFactories\n\t * targetConnectionFactories} map.\n\t */\n\tpublic void setConnectionFactoryLookup(ConnectionFactoryLookup connectionFactoryLookup) {\n\t\tAssert.notNull(connectionFactoryLookup, \"ConnectionFactoryLookup must not be null\");\n\t\tthis.connectionFactoryLookup = connectionFactoryLookup;\n\t}\n\n\n\t@Override\n\tpublic void afterPropertiesSet() {\n\t\tAssert.notNull(this.targetConnectionFactories, \"Property 'targetConnectionFactories' must not be null\");\n\n\t\tthis.resolvedConnectionFactories = CollectionUtils.newHashMap(this.targetConnectionFactories.size());\n\t\tthis.targetConnectionFactories.forEach((key, value) -> {\n\t\t\tObject lookupKey = resolveSpecifiedLookupKey(key);\n\t\t\tConnectionFactory connectionFactory = resolveSpecifiedConnectionFactory(value);\n\t\t\tthis.resolvedConnectionFactories.put(lookupKey, connectionFactory);\n\t\t});\n\n\t\tif (this.defaultTargetConnectionFactory != null) {\n\t\t\tthis.resolvedDefaultConnectionFactory = resolveSpecifiedConnectionFactory(this.defaultTargetConnectionFactory);\n\t\t}\n\t}\n\n\t/**\n\t * Resolve the given lookup key object, as specified in the\n\t * {@link #setTargetConnectionFactories targetConnectionFactories} map,\n\t * into the actual lookup key to be used for matching with the\n\t * {@link #determineCurrentLookupKey() current lookup key}.\n\t * <p>The default implementation simply returns the given key as-is.\n\t * @param lookupKey the lookup key object as specified by the user\n\t * @return the lookup key as needed for matching.\n\t */\n\tprotected Object resolveSpecifiedLookupKey(Object lookupKey) {\n\t\treturn lookupKey;\n\t}\n\n\t/**\n\t * Resolve the specified connection factory object into a\n\t * {@link ConnectionFactory} instance.\n\t * <p>The default implementation handles {@link ConnectionFactory} instances\n\t * and connection factory names (to be resolved via a\n\t * {@link #setConnectionFactoryLookup ConnectionFactoryLookup}).\n\t * @param connectionFactory the connection factory value object as specified in the\n\t * {@link #setTargetConnectionFactories targetConnectionFactories} map\n\t * @return the resolved {@link ConnectionFactory} (never {@code null})\n\t * @throws IllegalArgumentException in case of an unsupported value type\n\t */\n\tprotected ConnectionFactory resolveSpecifiedConnectionFactory(Object connectionFactory)\n\t\t\tthrows IllegalArgumentException {\n\n\t\tif (connectionFactory instanceof ConnectionFactory factory) {\n\t\t\treturn factory;\n\t\t}\n\t\telse if (connectionFactory instanceof String factoryName) {\n\t\t\treturn this.connectionFactoryLookup.getConnectionFactory(factoryName);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Illegal connection factory value - \" +\n\t\t\t\t\t\"only 'io.r2dbc.spi.ConnectionFactory' and 'String' supported: \" + connectionFactory);\n\t\t}\n\t}\n\n\t@Override\n\tpublic Mono<Connection> create() {\n\t\treturn determineTargetConnectionFactory().map(ConnectionFactory::create).flatMap(Mono::from);\n\t}\n\n\t@Override\n\tpublic ConnectionFactoryMetadata getMetadata() {\n\t\tif (this.resolvedDefaultConnectionFactory != null) {\n\t\t\treturn this.resolvedDefaultConnectionFactory.getMetadata();\n\t\t}\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\"No default ConnectionFactory configured to retrieve ConnectionFactoryMetadata\");\n\t}\n\n\t/**\n\t * Retrieve the current target {@link ConnectionFactory}. Determines the\n\t * {@link #determineCurrentLookupKey() current lookup key}, performs a lookup\n\t * in the {@link #setTargetConnectionFactories targetConnectionFactories} map,\n\t * falls back to the specified {@link #setDefaultTargetConnectionFactory default\n\t * target ConnectionFactory} if necessary.\n\t * @return {@link Mono} that emits the current {@link ConnectionFactory} as\n\t * per {@link #determineCurrentLookupKey()}\n\t * @see #determineCurrentLookupKey()\n\t */\n\tprotected Mono<ConnectionFactory> determineTargetConnectionFactory() {\n\t\tAssert.state(this.resolvedConnectionFactories != null, \"ConnectionFactory router not initialized\");\n\n\t\tMono<Object> lookupKey = determineCurrentLookupKey().defaultIfEmpty(FALLBACK_MARKER);\n\n\t\treturn lookupKey.handle((key, sink) -> {\n\t\t\tConnectionFactory connectionFactory = this.resolvedConnectionFactories.get(key);\n\t\t\tif (connectionFactory == null && (key == FALLBACK_MARKER || this.lenientFallback)) {\n\t\t\t\tconnectionFactory = this.resolvedDefaultConnectionFactory;\n\t\t\t}\n\t\t\tif (connectionFactory == null) {\n\t\t\t\tsink.error(new IllegalStateException(String.format(\n\t\t\t\t\t\t\"Cannot determine target ConnectionFactory for lookup key '%s'\", key == FALLBACK_MARKER ? null : key)));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsink.next(connectionFactory);\n\t\t});\n\t}\n\n\t/**\n\t * Determine the current lookup key. This will typically be implemented to check a\n\t * subscriber context. Allows for arbitrary keys. The returned key needs to match the\n\t * stored lookup key type, as resolved by the {@link #resolveSpecifiedLookupKey} method.\n\t * @return {@link Mono} emitting the lookup key. May complete without emitting a value\n\t * if no lookup key available\n\t */\n\tprotected abstract Mono<Object> determineCurrentLookupKey();\n\n}"
  },
  "org.springframework.r2dbc.connection.lookup.AbstractRoutingConnectionFactory#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tAssert.notNull(this.targetConnectionFactories, \"Property 'targetConnectionFactories' must not be null\");\n\n\t\tthis.resolvedConnectionFactories = CollectionUtils.newHashMap(this.targetConnectionFactories.size());\n\t\tthis.targetConnectionFactories.forEach((key, value) -> {\n\t\t\tObject lookupKey = resolveSpecifiedLookupKey(key);\n\t\t\tConnectionFactory connectionFactory = resolveSpecifiedConnectionFactory(value);\n\t\t\tthis.resolvedConnectionFactories.put(lookupKey, connectionFactory);\n\t\t});\n\n\t\tif (this.defaultTargetConnectionFactory != null) {\n\t\t\tthis.resolvedDefaultConnectionFactory = resolveSpecifiedConnectionFactory(this.defaultTargetConnectionFactory);\n\t\t}\n\t}"
  },
  "org.springframework.r2dbc.connection.lookup.AbstractRoutingConnectionFactory#create()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "Mono<Connection>",
    "signature": "public Mono<Connection> create()",
    "source_code": "\tpublic Mono<Connection> create() {\n\t\treturn determineTargetConnectionFactory().map(ConnectionFactory::create).flatMap(Mono::from);\n\t}"
  },
  "org.springframework.r2dbc.connection.lookup.AbstractRoutingConnectionFactory#determineCurrentLookupKey()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the current lookup key. This will typically be implemented to check a\n\t * subscriber context. Allows for arbitrary keys. The returned key needs to match the\n\t * stored lookup key type, as resolved by the {@link #resolveSpecifiedLookupKey} method.\n\t * @return {@link Mono} emitting the lookup key. May complete without emitting a value\n\t * if no lookup key available\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "Mono<Object>",
    "signature": "protected Mono<Object> determineCurrentLookupKey()",
    "source_code": "\tprotected abstract Mono<Object> determineCurrentLookupKey();"
  },
  "org.springframework.r2dbc.connection.lookup.AbstractRoutingConnectionFactory#determineTargetConnectionFactory()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the current target {@link ConnectionFactory}. Determines the\n\t * {@link #determineCurrentLookupKey() current lookup key}, performs a lookup\n\t * in the {@link #setTargetConnectionFactories targetConnectionFactories} map,\n\t * falls back to the specified {@link #setDefaultTargetConnectionFactory default\n\t * target ConnectionFactory} if necessary.\n\t * @return {@link Mono} that emits the current {@link ConnectionFactory} as\n\t * per {@link #determineCurrentLookupKey()}\n\t * @see #determineCurrentLookupKey()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "Mono<ConnectionFactory>",
    "signature": "protected Mono<ConnectionFactory> determineTargetConnectionFactory()",
    "source_code": "\tprotected Mono<ConnectionFactory> determineTargetConnectionFactory() {\n\t\tAssert.state(this.resolvedConnectionFactories != null, \"ConnectionFactory router not initialized\");\n\n\t\tMono<Object> lookupKey = determineCurrentLookupKey().defaultIfEmpty(FALLBACK_MARKER);\n\n\t\treturn lookupKey.handle((key, sink) -> {\n\t\t\tConnectionFactory connectionFactory = this.resolvedConnectionFactories.get(key);\n\t\t\tif (connectionFactory == null && (key == FALLBACK_MARKER || this.lenientFallback)) {\n\t\t\t\tconnectionFactory = this.resolvedDefaultConnectionFactory;\n\t\t\t}\n\t\t\tif (connectionFactory == null) {\n\t\t\t\tsink.error(new IllegalStateException(String.format(\n\t\t\t\t\t\t\"Cannot determine target ConnectionFactory for lookup key '%s'\", key == FALLBACK_MARKER ? null : key)));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsink.next(connectionFactory);\n\t\t});\n\t}"
  },
  "org.springframework.r2dbc.connection.lookup.AbstractRoutingConnectionFactory#getMetadata()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "ConnectionFactoryMetadata",
    "signature": "public ConnectionFactoryMetadata getMetadata()",
    "source_code": "\tpublic ConnectionFactoryMetadata getMetadata() {\n\t\tif (this.resolvedDefaultConnectionFactory != null) {\n\t\t\treturn this.resolvedDefaultConnectionFactory.getMetadata();\n\t\t}\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\"No default ConnectionFactory configured to retrieve ConnectionFactoryMetadata\");\n\t}"
  },
  "org.springframework.r2dbc.connection.lookup.AbstractRoutingConnectionFactory#resolveSpecifiedConnectionFactory(connectionFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the specified connection factory object into a\n\t * {@link ConnectionFactory} instance.\n\t * <p>The default implementation handles {@link ConnectionFactory} instances\n\t * and connection factory names (to be resolved via a\n\t * {@link #setConnectionFactoryLookup ConnectionFactoryLookup}).\n\t * @param connectionFactory the connection factory value object as specified in the\n\t * {@link #setTargetConnectionFactories targetConnectionFactories} map\n\t * @return the resolved {@link ConnectionFactory} (never {@code null})\n\t * @throws IllegalArgumentException in case of an unsupported value type\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "connectionFactory"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "ConnectionFactory",
    "signature": "protected ConnectionFactory resolveSpecifiedConnectionFactory(Object connectionFactory)",
    "source_code": "\tprotected ConnectionFactory resolveSpecifiedConnectionFactory(Object connectionFactory)"
  },
  "org.springframework.r2dbc.connection.lookup.AbstractRoutingConnectionFactory#resolveSpecifiedLookupKey(lookupKey)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the given lookup key object, as specified in the\n\t * {@link #setTargetConnectionFactories targetConnectionFactories} map,\n\t * into the actual lookup key to be used for matching with the\n\t * {@link #determineCurrentLookupKey() current lookup key}.\n\t * <p>The default implementation simply returns the given key as-is.\n\t * @param lookupKey the lookup key object as specified by the user\n\t * @return the lookup key as needed for matching.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "lookupKey"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "Object",
    "signature": "protected Object resolveSpecifiedLookupKey(Object lookupKey)",
    "source_code": "\tprotected Object resolveSpecifiedLookupKey(Object lookupKey) {\n\t\treturn lookupKey;\n\t}"
  },
  "org.springframework.r2dbc.connection.lookup.AbstractRoutingConnectionFactory#setConnectionFactoryLookup(connectionFactoryLookup)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link ConnectionFactoryLookup} implementation to use for resolving\n\t * connection factory name Strings in the {@link #setTargetConnectionFactories\n\t * targetConnectionFactories} map.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connectionFactoryLookup"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "void",
    "signature": "public void setConnectionFactoryLookup(ConnectionFactoryLookup connectionFactoryLookup)",
    "source_code": "\tpublic void setConnectionFactoryLookup(ConnectionFactoryLookup connectionFactoryLookup) {\n\t\tAssert.notNull(connectionFactoryLookup, \"ConnectionFactoryLookup must not be null\");\n\t\tthis.connectionFactoryLookup = connectionFactoryLookup;\n\t}"
  },
  "org.springframework.r2dbc.connection.lookup.AbstractRoutingConnectionFactory#setDefaultTargetConnectionFactory(defaultTargetConnectionFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the default target {@link ConnectionFactory}, if any.\n\t * <p>The mapped value can either be a corresponding {@link ConnectionFactory}\n\t * instance or a connection factory name {@link String} (to be resolved via a\n\t * {@link #setConnectionFactoryLookup ConnectionFactoryLookup}).\n\t * <p>This {@link ConnectionFactory} will be used as target if none of the keyed\n\t * {@link #setTargetConnectionFactories targetConnectionFactories} match the\n\t * {@link #determineCurrentLookupKey() current lookup key}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultTargetConnectionFactory"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "public void setDefaultTargetConnectionFactory(Object defaultTargetConnectionFactory)",
    "source_code": "\tpublic void setDefaultTargetConnectionFactory(Object defaultTargetConnectionFactory) {\n\t\tthis.defaultTargetConnectionFactory = defaultTargetConnectionFactory;\n\t}"
  },
  "org.springframework.r2dbc.connection.lookup.AbstractRoutingConnectionFactory#setLenientFallback(lenientFallback)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether to apply a lenient fallback to the default {@link ConnectionFactory}\n\t * if no specific {@link ConnectionFactory} could be found for the current lookup key.\n\t * <p>Default is {@code true}, accepting lookup keys without a corresponding entry\n\t * in the target {@link ConnectionFactory} map - simply falling back to the default\n\t * {@link ConnectionFactory} in that case.\n\t * <p>Switch this flag to {@code false} if you would prefer the fallback to only\n\t * apply when no lookup key was emitted. Lookup keys without a {@link ConnectionFactory}\n\t * entry will then lead to an {@link IllegalStateException}.\n\t * @see #setTargetConnectionFactories\n\t * @see #setDefaultTargetConnectionFactory\n\t * @see #determineCurrentLookupKey()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lenientFallback"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "void",
    "signature": "public void setLenientFallback(boolean lenientFallback)",
    "source_code": "\tpublic void setLenientFallback(boolean lenientFallback) {\n\t\tthis.lenientFallback = lenientFallback;\n\t}"
  },
  "org.springframework.r2dbc.connection.lookup.AbstractRoutingConnectionFactory#setTargetConnectionFactories(Map<?,targetConnectionFactories)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the map of target {@link ConnectionFactory ConnectionFactories},\n\t * with the lookup key as key. The mapped value can either be a corresponding\n\t * {@link ConnectionFactory} instance or a connection factory name String (to be\n\t * resolved via a {@link #setConnectionFactoryLookup ConnectionFactoryLookup}).\n\t * <p>The key can be of arbitrary type; this class implements the generic lookup\n\t * process only. The concrete key representation will be handled by\n\t * {@link #resolveSpecifiedLookupKey(Object)} and {@link #determineCurrentLookupKey()}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "targetConnectionFactories"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void setTargetConnectionFactories(Map<?, ?> targetConnectionFactories)",
    "source_code": "\tpublic void setTargetConnectionFactories(Map<?, ?> targetConnectionFactories) {\n\t\tthis.targetConnectionFactories = targetConnectionFactories;\n\t}"
  },
  "org.springframework.scheduling.annotation.AsyncAnnotationAdvisor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Advisor that activates asynchronous method execution through the {@link Async}\n * annotation. This annotation can be used at the method and type level in\n * implementation classes as well as in service interfaces.\n *\n * <p>This advisor detects the EJB 3.1 {@code jakarta.ejb.Asynchronous}\n * annotation as well, treating it exactly like Spring's own {@code Async}.\n * Furthermore, a custom async annotation type may get specified through the\n * {@link #setAsyncAnnotationType \"asyncAnnotationType\"} property.\n *\n * @author Juergen Hoeller\n * @since 3.0\n * @see Async\n * @see AnnotationAsyncExecutionInterceptor\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "signature": "public class AsyncAnnotationAdvisor",
    "source_code": "public class AsyncAnnotationAdvisor extends AbstractPointcutAdvisor implements BeanFactoryAware {\n\n\tprivate final Advice advice;\n\n\tprivate Pointcut pointcut;\n\n\n\t/**\n\t * Create a new {@code AsyncAnnotationAdvisor} for bean-style configuration.\n\t */\n\tpublic AsyncAnnotationAdvisor() {\n\t\tthis((Supplier<Executor>) null, (Supplier<AsyncUncaughtExceptionHandler>) null);\n\t}\n\n\t/**\n\t * Create a new {@code AsyncAnnotationAdvisor} for the given task executor.\n\t * @param executor the task executor to use for asynchronous methods\n\t * (can be {@code null} to trigger default executor resolution)\n\t * @param exceptionHandler the {@link AsyncUncaughtExceptionHandler} to use to\n\t * handle unexpected exception thrown by asynchronous method executions\n\t * @see AnnotationAsyncExecutionInterceptor#getDefaultExecutor(BeanFactory)\n\t */\n\tpublic AsyncAnnotationAdvisor(\n\t\t\t@Nullable Executor executor, @Nullable AsyncUncaughtExceptionHandler exceptionHandler) {\n\n\t\tthis(SingletonSupplier.ofNullable(executor), SingletonSupplier.ofNullable(exceptionHandler));\n\t}\n\n\t/**\n\t * Create a new {@code AsyncAnnotationAdvisor} for the given task executor.\n\t * @param executor the task executor to use for asynchronous methods\n\t * (can be {@code null} to trigger default executor resolution)\n\t * @param exceptionHandler the {@link AsyncUncaughtExceptionHandler} to use to\n\t * handle unexpected exception thrown by asynchronous method executions\n\t * @since 5.1\n\t * @see AnnotationAsyncExecutionInterceptor#getDefaultExecutor(BeanFactory)\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic AsyncAnnotationAdvisor(\n\t\t\t@Nullable Supplier<Executor> executor, @Nullable Supplier<AsyncUncaughtExceptionHandler> exceptionHandler) {\n\n\t\tSet<Class<? extends Annotation>> asyncAnnotationTypes = new LinkedHashSet<>(2);\n\t\tasyncAnnotationTypes.add(Async.class);\n\n\t\tClassLoader classLoader = AsyncAnnotationAdvisor.class.getClassLoader();\n\t\ttry {\n\t\t\tasyncAnnotationTypes.add((Class<? extends Annotation>)\n\t\t\t\t\tClassUtils.forName(\"jakarta.ejb.Asynchronous\", classLoader));\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\t// If EJB API not present, simply ignore.\n\t\t}\n\t\ttry {\n\t\t\tasyncAnnotationTypes.add((Class<? extends Annotation>)\n\t\t\t\t\tClassUtils.forName(\"jakarta.enterprise.concurrent.Asynchronous\", classLoader));\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\t// If Jakarta Concurrent API not present, simply ignore.\n\t\t}\n\n\t\tthis.advice = buildAdvice(executor, exceptionHandler);\n\t\tthis.pointcut = buildPointcut(asyncAnnotationTypes);\n\t}\n\n\n\t/**\n\t * Set the 'async' annotation type.\n\t * <p>The default async annotation type is the {@link Async} annotation, as well\n\t * as the EJB 3.1 {@code jakarta.ejb.Asynchronous} annotation (if present).\n\t * <p>This setter property exists so that developers can provide their own\n\t * (non-Spring-specific) annotation type to indicate that a method is to\n\t * be executed asynchronously.\n\t * @param asyncAnnotationType the desired annotation type\n\t */\n\tpublic void setAsyncAnnotationType(Class<? extends Annotation> asyncAnnotationType) {\n\t\tAssert.notNull(asyncAnnotationType, \"'asyncAnnotationType' must not be null\");\n\t\tSet<Class<? extends Annotation>> asyncAnnotationTypes = new HashSet<>();\n\t\tasyncAnnotationTypes.add(asyncAnnotationType);\n\t\tthis.pointcut = buildPointcut(asyncAnnotationTypes);\n\t}\n\n\t/**\n\t * Set the {@code BeanFactory} to be used when looking up executors by qualifier.\n\t */\n\t@Override\n\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tif (this.advice instanceof BeanFactoryAware beanFactoryAware) {\n\t\t\tbeanFactoryAware.setBeanFactory(beanFactory);\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic Advice getAdvice() {\n\t\treturn this.advice;\n\t}\n\n\t@Override\n\tpublic Pointcut getPointcut() {\n\t\treturn this.pointcut;\n\t}\n\n\n\tprotected Advice buildAdvice(\n\t\t\t@Nullable Supplier<Executor> executor, @Nullable Supplier<AsyncUncaughtExceptionHandler> exceptionHandler) {\n\n\t\tAnnotationAsyncExecutionInterceptor interceptor = new AnnotationAsyncExecutionInterceptor(null);\n\t\tinterceptor.configure(executor, exceptionHandler);\n\t\treturn interceptor;\n\t}\n\n\t/**\n\t * Calculate a pointcut for the given async annotation types, if any.\n\t * @param asyncAnnotationTypes the async annotation types to introspect\n\t * @return the applicable Pointcut object, or {@code null} if none\n\t */\n\tprotected Pointcut buildPointcut(Set<Class<? extends Annotation>> asyncAnnotationTypes) {\n\t\tComposablePointcut result = null;\n\t\tfor (Class<? extends Annotation> asyncAnnotationType : asyncAnnotationTypes) {\n\t\t\tPointcut cpc = new AnnotationMatchingPointcut(asyncAnnotationType, true);\n\t\t\tPointcut mpc = new AnnotationMatchingPointcut(null, asyncAnnotationType, true);\n\t\t\tif (result == null) {\n\t\t\t\tresult = new ComposablePointcut(cpc);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.union(cpc);\n\t\t\t}\n\t\t\tresult = result.union(mpc);\n\t\t}\n\t\treturn (result != null ? result : Pointcut.TRUE);\n\t}\n\n}"
  },
  "org.springframework.scheduling.annotation.AsyncAnnotationAdvisor#buildAdvice(executor,exceptionHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "executor",
      "exceptionHandler"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "Advice",
    "signature": "protected Advice buildAdvice(@Nullable Supplier<Executor> executor, @Nullable Supplier<AsyncUncaughtExceptionHandler> exceptionHandler)",
    "source_code": "\tprotected Advice buildAdvice("
  },
  "org.springframework.scheduling.annotation.AsyncAnnotationAdvisor#buildPointcut(asyncAnnotationTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Calculate a pointcut for the given async annotation types, if any.\n\t * @param asyncAnnotationTypes the async annotation types to introspect\n\t * @return the applicable Pointcut object, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "asyncAnnotationTypes"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "Pointcut",
    "signature": "protected Pointcut buildPointcut(Set<Class<? extends Annotation>> asyncAnnotationTypes)",
    "source_code": "\tprotected Pointcut buildPointcut(Set<Class<? extends Annotation>> asyncAnnotationTypes) {\n\t\tComposablePointcut result = null;\n\t\tfor (Class<? extends Annotation> asyncAnnotationType : asyncAnnotationTypes) {\n\t\t\tPointcut cpc = new AnnotationMatchingPointcut(asyncAnnotationType, true);\n\t\t\tPointcut mpc = new AnnotationMatchingPointcut(null, asyncAnnotationType, true);\n\t\t\tif (result == null) {\n\t\t\t\tresult = new ComposablePointcut(cpc);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.union(cpc);\n\t\t\t}\n\t\t\tresult = result.union(mpc);\n\t\t}\n\t\treturn (result != null ? result : Pointcut.TRUE);\n\t}"
  },
  "org.springframework.scheduling.annotation.AsyncAnnotationAdvisor#getAdvice()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "Advice",
    "signature": "public Advice getAdvice()",
    "source_code": "\tpublic Advice getAdvice() {\n\t\treturn this.advice;\n\t}"
  },
  "org.springframework.scheduling.annotation.AsyncAnnotationAdvisor#getPointcut()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "Pointcut",
    "signature": "public Pointcut getPointcut()",
    "source_code": "\tpublic Pointcut getPointcut() {\n\t\treturn this.pointcut;\n\t}"
  },
  "org.springframework.scheduling.annotation.AsyncAnnotationAdvisor#setAsyncAnnotationType(asyncAnnotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the 'async' annotation type.\n\t * <p>The default async annotation type is the {@link Async} annotation, as well\n\t * as the EJB 3.1 {@code jakarta.ejb.Asynchronous} annotation (if present).\n\t * <p>This setter property exists so that developers can provide their own\n\t * (non-Spring-specific) annotation type to indicate that a method is to\n\t * be executed asynchronously.\n\t * @param asyncAnnotationType the desired annotation type\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "asyncAnnotationType"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "void",
    "signature": "public void setAsyncAnnotationType(Class<? extends Annotation> asyncAnnotationType)",
    "source_code": "\tpublic void setAsyncAnnotationType(Class<? extends Annotation> asyncAnnotationType) {\n\t\tAssert.notNull(asyncAnnotationType, \"'asyncAnnotationType' must not be null\");\n\t\tSet<Class<? extends Annotation>> asyncAnnotationTypes = new HashSet<>();\n\t\tasyncAnnotationTypes.add(asyncAnnotationType);\n\t\tthis.pointcut = buildPointcut(asyncAnnotationTypes);\n\t}"
  },
  "org.springframework.scheduling.annotation.AsyncAnnotationAdvisor#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@code BeanFactory} to be used when looking up executors by qualifier.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "void",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tif (this.advice instanceof BeanFactoryAware beanFactoryAware) {\n\t\t\tbeanFactoryAware.setBeanFactory(beanFactory);\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.annotation.AsyncResult": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A pass-through {@code Future} handle that can be used for method signatures\n * which are declared with a {@code Future} return type for asynchronous execution.\n *\n * <p>As of Spring 4.1, this class implements {@link ListenableFuture}, not just\n * plain {@link java.util.concurrent.Future}, along with the corresponding support\n * in {@code @Async} processing.\n *\n * <p>As of Spring 4.2, this class also supports passing execution exceptions back\n * to the caller.\n *\n * @author Juergen Hoeller\n * @author Rossen Stoyanchev\n * @since 3.0\n * @param <V> the value type\n * @see Async\n * @see #forValue(Object)\n * @see #forExecutionException(Throwable)\n * @deprecated as of 6.0, in favor of {@link CompletableFuture}\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "public class AsyncResult",
    "source_code": "public class AsyncResult<V> implements ListenableFuture<V> {\n\n\t@Nullable\n\tprivate final V value;\n\n\t@Nullable\n\tprivate final Throwable executionException;\n\n\n\t/**\n\t * Create a new AsyncResult holder.\n\t * @param value the value to pass through\n\t */\n\tpublic AsyncResult(@Nullable V value) {\n\t\tthis(value, null);\n\t}\n\n\t/**\n\t * Create a new AsyncResult holder.\n\t * @param value the value to pass through\n\t */\n\tprivate AsyncResult(@Nullable V value, @Nullable Throwable ex) {\n\t\tthis.value = value;\n\t\tthis.executionException = ex;\n\t}\n\n\n\t@Override\n\tpublic boolean cancel(boolean mayInterruptIfRunning) {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isCancelled() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isDone() {\n\t\treturn true;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic V get() throws ExecutionException {\n\t\tif (this.executionException != null) {\n\t\t\tthrow (this.executionException instanceof ExecutionException execEx ? execEx :\n\t\t\t\t\tnew ExecutionException(this.executionException));\n\t\t}\n\t\treturn this.value;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic V get(long timeout, TimeUnit unit) throws ExecutionException {\n\t\treturn get();\n\t}\n\n\t@Override\n\tpublic void addCallback(ListenableFutureCallback<? super V> callback) {\n\t\taddCallback(callback, callback);\n\t}\n\n\t@Override\n\tpublic void addCallback(SuccessCallback<? super V> successCallback, FailureCallback failureCallback) {\n\t\ttry {\n\t\t\tif (this.executionException != null) {\n\t\t\t\tfailureCallback.onFailure(exposedException(this.executionException));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsuccessCallback.onSuccess(this.value);\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\t// Ignore\n\t\t}\n\t}\n\n\t@Override\n\tpublic CompletableFuture<V> completable() {\n\t\tif (this.executionException != null) {\n\t\t\tCompletableFuture<V> completable = new CompletableFuture<>();\n\t\t\tcompletable.completeExceptionally(exposedException(this.executionException));\n\t\t\treturn completable;\n\t\t}\n\t\telse {\n\t\t\treturn CompletableFuture.completedFuture(this.value);\n\t\t}\n\t}\n\n\n\t/**\n\t * Create a new async result which exposes the given value from {@link Future#get()}.\n\t * @param value the value to expose\n\t * @since 4.2\n\t * @see Future#get()\n\t */\n\tpublic static <V> ListenableFuture<V> forValue(V value) {\n\t\treturn new AsyncResult<>(value, null);\n\t}\n\n\t/**\n\t * Create a new async result which exposes the given exception as an\n\t * {@link ExecutionException} from {@link Future#get()}.\n\t * @param ex the exception to expose (either an pre-built {@link ExecutionException}\n\t * or a cause to be wrapped in an {@link ExecutionException})\n\t * @since 4.2\n\t * @see ExecutionException\n\t */\n\tpublic static <V> ListenableFuture<V> forExecutionException(Throwable ex) {\n\t\treturn new AsyncResult<>(null, ex);\n\t}\n\n\t/**\n\t * Determine the exposed exception: either the cause of a given\n\t * {@link ExecutionException}, or the original exception as-is.\n\t * @param original the original as given to {@link #forExecutionException}\n\t * @return the exposed exception\n\t */\n\tprivate static Throwable exposedException(Throwable original) {\n\t\tif (original instanceof ExecutionException) {\n\t\t\tThrowable cause = original.getCause();\n\t\t\tif (cause != null) {\n\t\t\t\treturn cause;\n\t\t\t}\n\t\t}\n\t\treturn original;\n\t}\n\n}"
  },
  "org.springframework.scheduling.annotation.AsyncResult#addCallback(callback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "void",
    "signature": "public void addCallback(ListenableFutureCallback<? super V> callback)",
    "source_code": "\tpublic void addCallback(ListenableFutureCallback<? super V> callback) {\n\t\taddCallback(callback, callback);\n\t}"
  },
  "org.springframework.scheduling.annotation.AsyncResult#addCallback(successCallback,failureCallback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "successCallback",
      "failureCallback"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "void",
    "signature": "public void addCallback(SuccessCallback<? super V> successCallback, FailureCallback failureCallback)",
    "source_code": "\tpublic void addCallback(SuccessCallback<? super V> successCallback, FailureCallback failureCallback) {\n\t\ttry {\n\t\t\tif (this.executionException != null) {\n\t\t\t\tfailureCallback.onFailure(exposedException(this.executionException));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsuccessCallback.onSuccess(this.value);\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\t// Ignore\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.annotation.AsyncResult#cancel(mayInterruptIfRunning)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mayInterruptIfRunning"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "boolean",
    "signature": "public boolean cancel(boolean mayInterruptIfRunning)",
    "source_code": "\tpublic boolean cancel(boolean mayInterruptIfRunning) {\n\t\treturn false;\n\t}"
  },
  "org.springframework.scheduling.annotation.AsyncResult#completable()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "CompletableFuture<V>",
    "signature": "public CompletableFuture<V> completable()",
    "source_code": "\tpublic CompletableFuture<V> completable() {\n\t\tif (this.executionException != null) {\n\t\t\tCompletableFuture<V> completable = new CompletableFuture<>();\n\t\t\tcompletable.completeExceptionally(exposedException(this.executionException));\n\t\t\treturn completable;\n\t\t}\n\t\telse {\n\t\t\treturn CompletableFuture.completedFuture(this.value);\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.annotation.AsyncResult#forExecutionException(ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new async result which exposes the given exception as an\n\t * {@link ExecutionException} from {@link Future#get()}.\n\t * @param ex the exception to expose (either an pre-built {@link ExecutionException}\n\t * or a cause to be wrapped in an {@link ExecutionException})\n\t * @since 4.2\n\t * @see ExecutionException\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "ListenableFuture<V>",
    "signature": "public ListenableFuture<V> forExecutionException(Throwable ex)",
    "source_code": "\tpublic static <V> ListenableFuture<V> forExecutionException(Throwable ex) {\n\t\treturn new AsyncResult<>(null, ex);\n\t}"
  },
  "org.springframework.scheduling.annotation.AsyncResult#forValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new async result which exposes the given value from {@link Future#get()}.\n\t * @param value the value to expose\n\t * @since 4.2\n\t * @see Future#get()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "ListenableFuture<V>",
    "signature": "public ListenableFuture<V> forValue(V value)",
    "source_code": "\tpublic static <V> ListenableFuture<V> forValue(V value) {\n\t\treturn new AsyncResult<>(value, null);\n\t}"
  },
  "org.springframework.scheduling.annotation.AsyncResult#get()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "V",
    "signature": "public V get()",
    "source_code": "\tpublic V get() throws ExecutionException {\n\t\tif (this.executionException != null) {\n\t\t\tthrow (this.executionException instanceof ExecutionException execEx ? execEx :\n\t\t\t\t\tnew ExecutionException(this.executionException));\n\t\t}\n\t\treturn this.value;\n\t}"
  },
  "org.springframework.scheduling.annotation.AsyncResult#get(timeout,unit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeout",
      "unit"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "V",
    "signature": "public V get(long timeout, TimeUnit unit)",
    "source_code": "\tpublic V get(long timeout, TimeUnit unit) throws ExecutionException {\n\t\treturn get();\n\t}"
  },
  "org.springframework.scheduling.annotation.AsyncResult#isCancelled()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "boolean",
    "signature": "public boolean isCancelled()",
    "source_code": "\tpublic boolean isCancelled() {\n\t\treturn false;\n\t}"
  },
  "org.springframework.scheduling.annotation.AsyncResult#isDone()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "boolean",
    "signature": "public boolean isDone()",
    "source_code": "\tpublic boolean isDone() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.scheduling.annotation.DEFAULT_TASK_SCHEDULER_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The default name of the {@link TaskScheduler} bean to pick up: {@value}.\n\t * <p>Note that the initial lookup happens by type; this is just the fallback\n\t * in case of multiple scheduler beans found in the context.\n\t * @since 4.2\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "signature": "public String DEFAULT_TASK_SCHEDULER_BEAN_NAME",
    "source_code": "\tpublic static final String DEFAULT_TASK_SCHEDULER_BEAN_NAME = \"taskScheduler\";",
    "type": "String"
  },
  "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Bean post-processor that registers methods annotated with\n * {@link Scheduled @Scheduled} to be invoked by a\n * {@link org.springframework.scheduling.TaskScheduler} according to the\n * \"fixedRate\", \"fixedDelay\", or \"cron\" expression provided via the annotation.\n *\n * <p>This post-processor is automatically registered by Spring's\n * {@code <task:annotation-driven>} XML element, and also by the\n * {@link EnableScheduling @EnableScheduling} annotation.\n *\n * <p>Autodetects any {@link SchedulingConfigurer} instances in the container,\n * allowing for customization of the scheduler to be used or for fine-grained\n * control over task registration (e.g. registration of {@link Trigger} tasks).\n * See the {@link EnableScheduling @EnableScheduling} javadocs for complete usage\n * details.\n *\n * @author Mark Fisher\n * @author Juergen Hoeller\n * @author Chris Beams\n * @author Elizabeth Chatman\n * @author Victor Brown\n * @author Sam Brannen\n * @since 3.0\n * @see Scheduled\n * @see EnableScheduling\n * @see SchedulingConfigurer\n * @see org.springframework.scheduling.TaskScheduler\n * @see org.springframework.scheduling.config.ScheduledTaskRegistrar\n * @see AsyncAnnotationBeanPostProcessor\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "signature": "public class ScheduledAnnotationBeanPostProcessor",
    "source_code": "public class ScheduledAnnotationBeanPostProcessor"
  },
  "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor#afterSingletonsInstantiated()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "void",
    "signature": "public void afterSingletonsInstantiated()",
    "source_code": "\tpublic void afterSingletonsInstantiated() {\n\t\t// Remove resolved singleton classes from cache\n\t\tthis.nonAnnotatedClasses.clear();\n\n\t\tif (this.applicationContext == null) {\n\t\t\t// Not running in an ApplicationContext -> register tasks early...\n\t\t\tfinishRegistration();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor#createRunnable(target,method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link Runnable} for the given bean instance,\n\t * calling the specified scheduled method.\n\t * <p>The default implementation creates a {@link ScheduledMethodRunnable}.\n\t * @param target the target bean instance\n\t * @param method the scheduled method to call\n\t * @since 5.1\n\t * @see ScheduledMethodRunnable#ScheduledMethodRunnable(Object, Method)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 528
    },
    "return": "Runnable",
    "signature": "protected Runnable createRunnable(Object target, Method method)",
    "source_code": "\tprotected Runnable createRunnable(Object target, Method method) {\n\t\tAssert.isTrue(method.getParameterCount() == 0, \"Only no-arg methods may be annotated with @Scheduled\");\n\t\tMethod invocableMethod = AopUtils.selectInvocableMethod(method, target.getClass());\n\t\treturn new ScheduledMethodRunnable(target, invocableMethod);\n\t}"
  },
  "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor#destroy()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 593
    },
    "return": "void",
    "signature": "public void destroy()",
    "source_code": "\tpublic void destroy() {\n\t\tsynchronized (this.scheduledTasks) {\n\t\t\tCollection<Set<ScheduledTask>> allTasks = this.scheduledTasks.values();\n\t\t\tfor (Set<ScheduledTask> tasks : allTasks) {\n\t\t\t\tfor (ScheduledTask task : tasks) {\n\t\t\t\t\ttask.cancel();\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.scheduledTasks.clear();\n\t\t}\n\t\tthis.registrar.destroy();\n\t}"
  },
  "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor#getOrder()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "int",
    "signature": "public int getOrder()",
    "source_code": "\tpublic int getOrder() {\n\t\treturn LOWEST_PRECEDENCE;\n\t}"
  },
  "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor#getScheduledTasks()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return all currently scheduled tasks, from {@link Scheduled} methods\n\t * as well as from programmatic {@link SchedulingConfigurer} interaction.\n\t * @since 5.0.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 560
    },
    "return": "Set<ScheduledTask>",
    "signature": "public Set<ScheduledTask> getScheduledTasks()",
    "source_code": "\tpublic Set<ScheduledTask> getScheduledTasks() {\n\t\tSet<ScheduledTask> result = new LinkedHashSet<>();\n\t\tsynchronized (this.scheduledTasks) {\n\t\t\tCollection<Set<ScheduledTask>> allTasks = this.scheduledTasks.values();\n\t\t\tfor (Set<ScheduledTask> tasks : allTasks) {\n\t\t\t\tresult.addAll(tasks);\n\t\t\t}\n\t\t}\n\t\tresult.addAll(this.registrar.getScheduledTasks());\n\t\treturn result;\n\t}"
  },
  "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor#onApplicationEvent(event)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "event"
    ],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "void",
    "signature": "public void onApplicationEvent(ContextRefreshedEvent event)",
    "source_code": "\tpublic void onApplicationEvent(ContextRefreshedEvent event) {\n\t\tif (event.getApplicationContext() == this.applicationContext) {\n\t\t\t// Running in an ApplicationContext -> register tasks this late...\n\t\t\t// giving other ContextRefreshedEvent listeners a chance to perform\n\t\t\t// their work at the same time (e.g. Spring Batch's job registration).\n\t\t\tfinishRegistration();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor#postProcessAfterInitialization(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 352
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessAfterInitialization(Object bean, String beanName) {\n\t\tif (bean instanceof AopInfrastructureBean || bean instanceof TaskScheduler ||\n\t\t\t\tbean instanceof ScheduledExecutorService) {\n\t\t\t// Ignore AOP infrastructure such as scoped proxies.\n\t\t\treturn bean;\n\t\t}\n\n\t\tClass<?> targetClass = AopProxyUtils.ultimateTargetClass(bean);\n\t\tif (!this.nonAnnotatedClasses.contains(targetClass) &&\n\t\t\t\tAnnotationUtils.isCandidateClass(targetClass, List.of(Scheduled.class, Schedules.class))) {\n\t\t\tMap<Method, Set<Scheduled>> annotatedMethods = MethodIntrospector.selectMethods(targetClass,\n\t\t\t\t\t(MethodIntrospector.MetadataLookup<Set<Scheduled>>) method -> {\n\t\t\t\t\t\tSet<Scheduled> scheduledAnnotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(\n\t\t\t\t\t\t\t\tmethod, Scheduled.class, Schedules.class);\n\t\t\t\t\t\treturn (!scheduledAnnotations.isEmpty() ? scheduledAnnotations : null);\n\t\t\t\t\t});\n\t\t\tif (annotatedMethods.isEmpty()) {\n\t\t\t\tthis.nonAnnotatedClasses.add(targetClass);\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"No @Scheduled annotations found on bean class: \" + targetClass);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Non-empty set of methods\n\t\t\t\tannotatedMethods.forEach((method, scheduledAnnotations) ->\n\t\t\t\t\t\tscheduledAnnotations.forEach(scheduled -> processScheduled(scheduled, method, bean)));\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(annotatedMethods.size() + \" @Scheduled methods processed on bean '\" + beanName +\n\t\t\t\t\t\t\t\"': \" + annotatedMethods);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn bean;\n\t}"
  },
  "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor#postProcessBeforeDestruction(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 573
    },
    "return": "void",
    "signature": "public void postProcessBeforeDestruction(Object bean, String beanName)",
    "source_code": "\tpublic void postProcessBeforeDestruction(Object bean, String beanName) {\n\t\tSet<ScheduledTask> tasks;\n\t\tsynchronized (this.scheduledTasks) {\n\t\t\ttasks = this.scheduledTasks.remove(bean);\n\t\t}\n\t\tif (tasks != null) {\n\t\t\tfor (ScheduledTask task : tasks) {\n\t\t\t\ttask.cancel();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor#postProcessBeforeInitialization(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) {\n\t\treturn bean;\n\t}"
  },
  "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor#postProcessMergedBeanDefinition(beanDefinition,beanType,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanDefinition",
      "beanType",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 343
    },
    "return": "void",
    "signature": "public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName)",
    "source_code": "\tpublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {\n\t}"
  },
  "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor#processScheduled(scheduled,method,bean)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Process the given {@code @Scheduled} method declaration on the given bean.\n\t * @param scheduled the {@code @Scheduled} annotation\n\t * @param method the method that the annotation has been declared on\n\t * @param bean the target bean instance\n\t * @see #createRunnable(Object, Method)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "scheduled",
      "method",
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 394
    },
    "return": "void",
    "signature": "protected void processScheduled(Scheduled scheduled, Method method, Object bean)",
    "source_code": "\tprotected void processScheduled(Scheduled scheduled, Method method, Object bean) {\n\t\ttry {\n\t\t\tRunnable runnable = createRunnable(bean, method);\n\t\t\tboolean processedSchedule = false;\n\t\t\tString errorMessage =\n\t\t\t\t\t\"Exactly one of the 'cron', 'fixedDelay(String)', or 'fixedRate(String)' attributes is required\";\n\n\t\t\tSet<ScheduledTask> tasks = new LinkedHashSet<>(4);\n\n\t\t\t// Determine initial delay\n\t\t\tDuration initialDelay = toDuration(scheduled.initialDelay(), scheduled.timeUnit());\n\t\t\tString initialDelayString = scheduled.initialDelayString();\n\t\t\tif (StringUtils.hasText(initialDelayString)) {\n\t\t\t\tAssert.isTrue(initialDelay.isNegative(), \"Specify 'initialDelay' or 'initialDelayString', not both\");\n\t\t\t\tif (this.embeddedValueResolver != null) {\n\t\t\t\t\tinitialDelayString = this.embeddedValueResolver.resolveStringValue(initialDelayString);\n\t\t\t\t}\n\t\t\t\tif (StringUtils.hasLength(initialDelayString)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tinitialDelay = toDuration(initialDelayString, scheduled.timeUnit());\n\t\t\t\t\t}\n\t\t\t\t\tcatch (RuntimeException ex) {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\t\t\"Invalid initialDelayString value \\\"\" + initialDelayString + \"\\\" - cannot parse into long\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check cron expression\n\t\t\tString cron = scheduled.cron();\n\t\t\tif (StringUtils.hasText(cron)) {\n\t\t\t\tString zone = scheduled.zone();\n\t\t\t\tif (this.embeddedValueResolver != null) {\n\t\t\t\t\tcron = this.embeddedValueResolver.resolveStringValue(cron);\n\t\t\t\t\tzone = this.embeddedValueResolver.resolveStringValue(zone);\n\t\t\t\t}\n\t\t\t\tif (StringUtils.hasLength(cron)) {\n\t\t\t\t\tAssert.isTrue(initialDelay.isNegative(), \"'initialDelay' not supported for cron triggers\");\n\t\t\t\t\tprocessedSchedule = true;\n\t\t\t\t\tif (!Scheduled.CRON_DISABLED.equals(cron)) {\n\t\t\t\t\t\tTimeZone timeZone;\n\t\t\t\t\t\tif (StringUtils.hasText(zone)) {\n\t\t\t\t\t\t\ttimeZone = StringUtils.parseTimeZoneString(zone);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttimeZone = TimeZone.getDefault();\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttasks.add(this.registrar.scheduleCronTask(new CronTask(runnable, new CronTrigger(cron, timeZone))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// At this point we don't need to differentiate between initial delay set or not anymore\n\t\t\tif (initialDelay.isNegative()) {\n\t\t\t\tinitialDelay = Duration.ZERO;\n\t\t\t}\n\n\t\t\t// Check fixed delay\n\t\t\tDuration fixedDelay = toDuration(scheduled.fixedDelay(), scheduled.timeUnit());\n\t\t\tif (!fixedDelay.isNegative()) {\n\t\t\t\tAssert.isTrue(!processedSchedule, errorMessage);\n\t\t\t\tprocessedSchedule = true;\n\t\t\t\ttasks.add(this.registrar.scheduleFixedDelayTask(new FixedDelayTask(runnable, fixedDelay, initialDelay)));\n\t\t\t}\n\n\t\t\tString fixedDelayString = scheduled.fixedDelayString();\n\t\t\tif (StringUtils.hasText(fixedDelayString)) {\n\t\t\t\tif (this.embeddedValueResolver != null) {\n\t\t\t\t\tfixedDelayString = this.embeddedValueResolver.resolveStringValue(fixedDelayString);\n\t\t\t\t}\n\t\t\t\tif (StringUtils.hasLength(fixedDelayString)) {\n\t\t\t\t\tAssert.isTrue(!processedSchedule, errorMessage);\n\t\t\t\t\tprocessedSchedule = true;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfixedDelay = toDuration(fixedDelayString, scheduled.timeUnit());\n\t\t\t\t\t}\n\t\t\t\t\tcatch (RuntimeException ex) {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\t\t\"Invalid fixedDelayString value \\\"\" + fixedDelayString + \"\\\" - cannot parse into long\");\n\t\t\t\t\t}\n\t\t\t\t\ttasks.add(this.registrar.scheduleFixedDelayTask(new FixedDelayTask(runnable, fixedDelay, initialDelay)));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check fixed rate\n\t\t\tDuration fixedRate = toDuration(scheduled.fixedRate(), scheduled.timeUnit());\n\t\t\tif (!fixedRate.isNegative()) {\n\t\t\t\tAssert.isTrue(!processedSchedule, errorMessage);\n\t\t\t\tprocessedSchedule = true;\n\t\t\t\ttasks.add(this.registrar.scheduleFixedRateTask(new FixedRateTask(runnable, fixedRate, initialDelay)));\n\t\t\t}\n\t\t\tString fixedRateString = scheduled.fixedRateString();\n\t\t\tif (StringUtils.hasText(fixedRateString)) {\n\t\t\t\tif (this.embeddedValueResolver != null) {\n\t\t\t\t\tfixedRateString = this.embeddedValueResolver.resolveStringValue(fixedRateString);\n\t\t\t\t}\n\t\t\t\tif (StringUtils.hasLength(fixedRateString)) {\n\t\t\t\t\tAssert.isTrue(!processedSchedule, errorMessage);\n\t\t\t\t\tprocessedSchedule = true;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfixedRate = toDuration(fixedRateString, scheduled.timeUnit());\n\t\t\t\t\t}\n\t\t\t\t\tcatch (RuntimeException ex) {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\t\t\"Invalid fixedRateString value \\\"\" + fixedRateString + \"\\\" - cannot parse into long\");\n\t\t\t\t\t}\n\t\t\t\t\ttasks.add(this.registrar.scheduleFixedRateTask(new FixedRateTask(runnable, fixedRate, initialDelay)));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check whether we had any attribute set\n\t\t\tAssert.isTrue(processedSchedule, errorMessage);\n\n\t\t\t// Finally register the scheduled tasks\n\t\t\tsynchronized (this.scheduledTasks) {\n\t\t\t\tSet<ScheduledTask> regTasks = this.scheduledTasks.computeIfAbsent(bean, key -> new LinkedHashSet<>(4));\n\t\t\t\tregTasks.addAll(tasks);\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Encountered invalid @Scheduled method '\" + method.getName() + \"': \" + ex.getMessage());\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor#requiresDestruction(bean)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 586
    },
    "return": "boolean",
    "signature": "public boolean requiresDestruction(Object bean)",
    "source_code": "\tpublic boolean requiresDestruction(Object bean) {\n\t\tsynchronized (this.scheduledTasks) {\n\t\t\treturn this.scheduledTasks.containsKey(bean);\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor#setApplicationContext(applicationContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Setting an {@link ApplicationContext} is optional: If set, registered\n\t * tasks will be activated in the {@link ContextRefreshedEvent} phase;\n\t * if not set, it will happen at {@link #afterSingletonsInstantiated} time.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "applicationContext"
    ],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "void",
    "signature": "public void setApplicationContext(ApplicationContext applicationContext)",
    "source_code": "\tpublic void setApplicationContext(ApplicationContext applicationContext) {\n\t\tthis.applicationContext = applicationContext;\n\t\tif (this.beanFactory == null) {\n\t\t\tthis.beanFactory = applicationContext;\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Making a {@link BeanFactory} available is optional; if not set,\n\t * {@link SchedulingConfigurer} beans won't get autodetected and\n\t * a {@link #setScheduler scheduler} has to be explicitly configured.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "void",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t}"
  },
  "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor#setBeanName(beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "void",
    "signature": "public void setBeanName(String beanName)",
    "source_code": "\tpublic void setBeanName(String beanName) {\n\t\tthis.beanName = beanName;\n\t}"
  },
  "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor#setEmbeddedValueResolver(resolver)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolver"
    ],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "void",
    "signature": "public void setEmbeddedValueResolver(StringValueResolver resolver)",
    "source_code": "\tpublic void setEmbeddedValueResolver(StringValueResolver resolver) {\n\t\tthis.embeddedValueResolver = resolver;\n\t}"
  },
  "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor#setScheduler(scheduler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link org.springframework.scheduling.TaskScheduler} that will invoke\n\t * the scheduled methods, or a {@link java.util.concurrent.ScheduledExecutorService}\n\t * to be wrapped as a TaskScheduler.\n\t * <p>If not specified, default scheduler resolution will apply: searching for a\n\t * unique {@link TaskScheduler} bean in the context, or for a {@link TaskScheduler}\n\t * bean named \"taskScheduler\" otherwise; the same lookup will also be performed for\n\t * a {@link ScheduledExecutorService} bean. If neither of the two is resolvable,\n\t * a local single-threaded default scheduler will be created within the registrar.\n\t * @see #DEFAULT_TASK_SCHEDULER_BEAN_NAME\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scheduler"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "void",
    "signature": "public void setScheduler(Object scheduler)",
    "source_code": "\tpublic void setScheduler(Object scheduler) {\n\t\tthis.scheduler = scheduler;\n\t}"
  },
  "org.springframework.scheduling.annotation.logger": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.scheduling.concurrent.ConcurrentTaskExecutor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Adapter that takes a {@code java.util.concurrent.Executor} and exposes\n * a Spring {@link org.springframework.core.task.TaskExecutor} for it.\n * Also detects an extended {@code java.util.concurrent.ExecutorService}, adapting\n * the {@link org.springframework.core.task.AsyncTaskExecutor} interface accordingly.\n *\n * <p>Autodetects a JSR-236 {@link jakarta.enterprise.concurrent.ManagedExecutorService}\n * in order to expose {@link jakarta.enterprise.concurrent.ManagedTask} adapters for it,\n * exposing a long-running hint based on {@link SchedulingAwareRunnable} and an identity\n * name based on the given Runnable/Callable's {@code toString()}. For JSR-236 style\n * lookup in a Jakarta EE environment, consider using {@link DefaultManagedTaskExecutor}.\n *\n * <p>Note that there is a pre-built {@link ThreadPoolTaskExecutor} that allows\n * for defining a {@link java.util.concurrent.ThreadPoolExecutor} in bean style,\n * exposing it as a Spring {@link org.springframework.core.task.TaskExecutor} directly.\n * This is a convenient alternative to a raw ThreadPoolExecutor definition with\n * a separate definition of the present adapter class.\n *\n * @author Juergen Hoeller\n * @since 2.0\n * @see java.util.concurrent.Executor\n * @see java.util.concurrent.ExecutorService\n * @see java.util.concurrent.ThreadPoolExecutor\n * @see java.util.concurrent.Executors\n * @see DefaultManagedTaskExecutor\n * @see ThreadPoolTaskExecutor\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "signature": "public class ConcurrentTaskExecutor",
    "source_code": "public class ConcurrentTaskExecutor implements AsyncListenableTaskExecutor, SchedulingTaskExecutor {\n\n\t@Nullable\n\tprivate static Class<?> managedExecutorServiceClass;\n\n\tstatic {\n\t\ttry {\n\t\t\tmanagedExecutorServiceClass = ClassUtils.forName(\n\t\t\t\t\t\"jakarta.enterprise.concurrent.ManagedExecutorService\",\n\t\t\t\t\tConcurrentTaskScheduler.class.getClassLoader());\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\t// JSR-236 API not available...\n\t\t\tmanagedExecutorServiceClass = null;\n\t\t}\n\t}\n\n\tprivate Executor concurrentExecutor;\n\n\tprivate TaskExecutorAdapter adaptedExecutor;\n\n\n\t/**\n\t * Create a new ConcurrentTaskExecutor, using a single thread executor as default.\n\t * @see java.util.concurrent.Executors#newSingleThreadExecutor()\n\t */\n\tpublic ConcurrentTaskExecutor() {\n\t\tthis.concurrentExecutor = Executors.newSingleThreadExecutor();\n\t\tthis.adaptedExecutor = new TaskExecutorAdapter(this.concurrentExecutor);\n\t}\n\n\t/**\n\t * Create a new ConcurrentTaskExecutor, using the given {@link java.util.concurrent.Executor}.\n\t * <p>Autodetects a JSR-236 {@link jakarta.enterprise.concurrent.ManagedExecutorService}\n\t * in order to expose {@link jakarta.enterprise.concurrent.ManagedTask} adapters for it.\n\t * @param executor the {@link java.util.concurrent.Executor} to delegate to\n\t */\n\tpublic ConcurrentTaskExecutor(@Nullable Executor executor) {\n\t\tthis.concurrentExecutor = (executor != null ? executor : Executors.newSingleThreadExecutor());\n\t\tthis.adaptedExecutor = getAdaptedExecutor(this.concurrentExecutor);\n\t}\n\n\n\t/**\n\t * Specify the {@link java.util.concurrent.Executor} to delegate to.\n\t * <p>Autodetects a JSR-236 {@link jakarta.enterprise.concurrent.ManagedExecutorService}\n\t * in order to expose {@link jakarta.enterprise.concurrent.ManagedTask} adapters for it.\n\t */\n\tpublic final void setConcurrentExecutor(@Nullable Executor executor) {\n\t\tthis.concurrentExecutor = (executor != null ? executor : Executors.newSingleThreadExecutor());\n\t\tthis.adaptedExecutor = getAdaptedExecutor(this.concurrentExecutor);\n\t}\n\n\t/**\n\t * Return the {@link java.util.concurrent.Executor} that this adapter delegates to.\n\t */\n\tpublic final Executor getConcurrentExecutor() {\n\t\treturn this.concurrentExecutor;\n\t}\n\n\t/**\n\t * Specify a custom {@link TaskDecorator} to be applied to any {@link Runnable}\n\t * about to be executed.\n\t * <p>Note that such a decorator is not necessarily being applied to the\n\t * user-supplied {@code Runnable}/{@code Callable} but rather to the actual\n\t * execution callback (which may be a wrapper around the user-supplied task).\n\t * <p>The primary use case is to set some execution context around the task's\n\t * invocation, or to provide some monitoring/statistics for task execution.\n\t * <p><b>NOTE:</b> Exception handling in {@code TaskDecorator} implementations\n\t * is limited to plain {@code Runnable} execution via {@code execute} calls.\n\t * In case of {@code #submit} calls, the exposed {@code Runnable} will be a\n\t * {@code FutureTask} which does not propagate any exceptions; you might\n\t * have to cast it and call {@code Future#get} to evaluate exceptions.\n\t * @since 4.3\n\t */\n\tpublic final void setTaskDecorator(TaskDecorator taskDecorator) {\n\t\tthis.adaptedExecutor.setTaskDecorator(taskDecorator);\n\t}\n\n\n\t@Override\n\tpublic void execute(Runnable task) {\n\t\tthis.adaptedExecutor.execute(task);\n\t}\n\n\t@Deprecated\n\t@Override\n\tpublic void execute(Runnable task, long startTimeout) {\n\t\tthis.adaptedExecutor.execute(task, startTimeout);\n\t}\n\n\t@Override\n\tpublic Future<?> submit(Runnable task) {\n\t\treturn this.adaptedExecutor.submit(task);\n\t}\n\n\t@Override\n\tpublic <T> Future<T> submit(Callable<T> task) {\n\t\treturn this.adaptedExecutor.submit(task);\n\t}\n\n\t@Override\n\tpublic ListenableFuture<?> submitListenable(Runnable task) {\n\t\treturn this.adaptedExecutor.submitListenable(task);\n\t}\n\n\t@Override\n\tpublic <T> ListenableFuture<T> submitListenable(Callable<T> task) {\n\t\treturn this.adaptedExecutor.submitListenable(task);\n\t}\n\n\n\tprivate static TaskExecutorAdapter getAdaptedExecutor(Executor concurrentExecutor) {\n\t\tif (managedExecutorServiceClass != null && managedExecutorServiceClass.isInstance(concurrentExecutor)) {\n\t\t\treturn new ManagedTaskExecutorAdapter(concurrentExecutor);\n\t\t}\n\t\treturn new TaskExecutorAdapter(concurrentExecutor);\n\t}\n\n\n\t/**\n\t * TaskExecutorAdapter subclass that wraps all provided Runnables and Callables\n\t * with a JSR-236 ManagedTask, exposing a long-running hint based on\n\t * {@link SchedulingAwareRunnable} and an identity name based on the task's\n\t * {@code toString()} representation.\n\t */\n\tprivate static class ManagedTaskExecutorAdapter extends TaskExecutorAdapter {\n\n\t\tpublic ManagedTaskExecutorAdapter(Executor concurrentExecutor) {\n\t\t\tsuper(concurrentExecutor);\n\t\t}\n\n\t\t@Override\n\t\tpublic void execute(Runnable task) {\n\t\t\tsuper.execute(ManagedTaskBuilder.buildManagedTask(task, task.toString()));\n\t\t}\n\n\t\t@Override\n\t\tpublic Future<?> submit(Runnable task) {\n\t\t\treturn super.submit(ManagedTaskBuilder.buildManagedTask(task, task.toString()));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> Future<T> submit(Callable<T> task) {\n\t\t\treturn super.submit(ManagedTaskBuilder.buildManagedTask(task, task.toString()));\n\t\t}\n\n\t\t@Override\n\t\tpublic ListenableFuture<?> submitListenable(Runnable task) {\n\t\t\treturn super.submitListenable(ManagedTaskBuilder.buildManagedTask(task, task.toString()));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> ListenableFuture<T> submitListenable(Callable<T> task) {\n\t\t\treturn super.submitListenable(ManagedTaskBuilder.buildManagedTask(task, task.toString()));\n\t\t}\n\t}\n\n\n\t/**\n\t * Delegate that wraps a given Runnable/Callable  with a JSR-236 ManagedTask,\n\t * exposing a long-running hint based on {@link SchedulingAwareRunnable}\n\t * and a given identity name.\n\t */\n\tprotected static class ManagedTaskBuilder {\n\n\t\tpublic static Runnable buildManagedTask(Runnable task, String identityName) {\n\t\t\tMap<String, String> properties;\n\t\t\tif (task instanceof SchedulingAwareRunnable schedulingAwareRunnable) {\n\t\t\t\tproperties = new HashMap<>(4);\n\t\t\t\tproperties.put(ManagedTask.LONGRUNNING_HINT,\n\t\t\t\t\t\tBoolean.toString(schedulingAwareRunnable.isLongLived()));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tproperties = new HashMap<>(2);\n\t\t\t}\n\t\t\tproperties.put(ManagedTask.IDENTITY_NAME, identityName);\n\t\t\treturn ManagedExecutors.managedTask(task, properties, null);\n\t\t}\n\n\t\tpublic static <T> Callable<T> buildManagedTask(Callable<T> task, String identityName) {\n\t\t\tMap<String, String> properties = new HashMap<>(2);\n\t\t\tproperties.put(ManagedTask.IDENTITY_NAME, identityName);\n\t\t\treturn ManagedExecutors.managedTask(task, properties, null);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.scheduling.concurrent.ConcurrentTaskExecutor#buildManagedTask(task,identityName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "identityName"
    ],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "Callable<T>",
    "signature": "public Callable<T> buildManagedTask(Callable<T> task, String identityName)",
    "source_code": "\t\tpublic static <T> Callable<T> buildManagedTask(Callable<T> task, String identityName) {\n\t\t\tMap<String, String> properties = new HashMap<>(2);\n\t\t\tproperties.put(ManagedTask.IDENTITY_NAME, identityName);\n\t\t\treturn ManagedExecutors.managedTask(task, properties, null);\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ConcurrentTaskExecutor#execute(task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "void",
    "signature": "public void execute(Runnable task)",
    "source_code": "\t\tpublic void execute(Runnable task) {\n\t\t\tsuper.execute(ManagedTaskBuilder.buildManagedTask(task, task.toString()));\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ConcurrentTaskExecutor#execute(task,startTimeout)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "startTimeout"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "void",
    "signature": "public void execute(Runnable task, long startTimeout)",
    "source_code": "\tpublic void execute(Runnable task, long startTimeout) {\n\t\tthis.adaptedExecutor.execute(task, startTimeout);\n\t}"
  },
  "org.springframework.scheduling.concurrent.ConcurrentTaskExecutor#getConcurrentExecutor()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link java.util.concurrent.Executor} that this adapter delegates to.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "Executor",
    "signature": "public Executor getConcurrentExecutor()",
    "source_code": "\tpublic final Executor getConcurrentExecutor() {\n\t\treturn this.concurrentExecutor;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ConcurrentTaskExecutor#setConcurrentExecutor(executor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the {@link java.util.concurrent.Executor} to delegate to.\n\t * <p>Autodetects a JSR-236 {@link jakarta.enterprise.concurrent.ManagedExecutorService}\n\t * in order to expose {@link jakarta.enterprise.concurrent.ManagedTask} adapters for it.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "executor"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "void",
    "signature": "public void setConcurrentExecutor(@Nullable Executor executor)",
    "source_code": "\tpublic final void setConcurrentExecutor(@Nullable Executor executor) {\n\t\tthis.concurrentExecutor = (executor != null ? executor : Executors.newSingleThreadExecutor());\n\t\tthis.adaptedExecutor = getAdaptedExecutor(this.concurrentExecutor);\n\t}"
  },
  "org.springframework.scheduling.concurrent.ConcurrentTaskExecutor#setTaskDecorator(taskDecorator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify a custom {@link TaskDecorator} to be applied to any {@link Runnable}\n\t * about to be executed.\n\t * <p>Note that such a decorator is not necessarily being applied to the\n\t * user-supplied {@code Runnable}/{@code Callable} but rather to the actual\n\t * execution callback (which may be a wrapper around the user-supplied task).\n\t * <p>The primary use case is to set some execution context around the task's\n\t * invocation, or to provide some monitoring/statistics for task execution.\n\t * <p><b>NOTE:</b> Exception handling in {@code TaskDecorator} implementations\n\t * is limited to plain {@code Runnable} execution via {@code execute} calls.\n\t * In case of {@code #submit} calls, the exposed {@code Runnable} will be a\n\t * {@code FutureTask} which does not propagate any exceptions; you might\n\t * have to cast it and call {@code Future#get} to evaluate exceptions.\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "taskDecorator"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "void",
    "signature": "public void setTaskDecorator(TaskDecorator taskDecorator)",
    "source_code": "\tpublic final void setTaskDecorator(TaskDecorator taskDecorator) {\n\t\tthis.adaptedExecutor.setTaskDecorator(taskDecorator);\n\t}"
  },
  "org.springframework.scheduling.concurrent.ConcurrentTaskExecutor#submit(task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "Future<T>",
    "signature": "public Future<T> submit(Callable<T> task)",
    "source_code": "\t\tpublic <T> Future<T> submit(Callable<T> task) {\n\t\t\treturn super.submit(ManagedTaskBuilder.buildManagedTask(task, task.toString()));\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ConcurrentTaskExecutor#submitListenable(task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "ListenableFuture<T>",
    "signature": "public ListenableFuture<T> submitListenable(Callable<T> task)",
    "source_code": "\t\tpublic <T> ListenableFuture<T> submitListenable(Callable<T> task) {\n\t\t\treturn super.submitListenable(ManagedTaskBuilder.buildManagedTask(task, task.toString()));\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Base class for setting up a {@link java.util.concurrent.ExecutorService}\n * (typically a {@link java.util.concurrent.ThreadPoolExecutor} or\n * {@link java.util.concurrent.ScheduledThreadPoolExecutor}).\n * Defines common configuration settings and common lifecycle handling.\n *\n * @author Juergen Hoeller\n * @since 3.0\n * @see java.util.concurrent.ExecutorService\n * @see java.util.concurrent.Executors\n * @see java.util.concurrent.ThreadPoolExecutor\n * @see java.util.concurrent.ScheduledThreadPoolExecutor\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "signature": "public class ExecutorConfigurationSupport",
    "source_code": "public abstract class ExecutorConfigurationSupport extends CustomizableThreadFactory"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Calls {@code initialize()} after the container applied all property values.\n\t * @see #initialize()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tinitialize();\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#cancelRemainingTask(task)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Cancel the given remaining task which never commended execution,\n\t * as returned from {@link ExecutorService#shutdownNow()}.\n\t * @param task the task to cancel (typically a {@link RunnableFuture})\n\t * @since 5.0.5\n\t * @see #shutdown()\n\t * @see RunnableFuture#cancel(boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "void",
    "signature": "protected void cancelRemainingTask(Runnable task)",
    "source_code": "\tprotected void cancelRemainingTask(Runnable task) {\n\t\tif (task instanceof Future<?> future) {\n\t\t\tfuture.cancel(true);\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#destroy()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Calls {@code shutdown} when the BeanFactory destroys\n\t * the task executor instance.\n\t * @see #shutdown()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "void",
    "signature": "public void destroy()",
    "source_code": "\tpublic void destroy() {\n\t\tshutdown();\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#initialize()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set up the ExecutorService.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "void",
    "signature": "public void initialize()",
    "source_code": "\tpublic void initialize() {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Initializing ExecutorService\" + (this.beanName != null ? \" '\" + this.beanName + \"'\" : \"\"));\n\t\t}\n\t\tif (!this.threadNamePrefixSet && this.beanName != null) {\n\t\t\tsetThreadNamePrefix(this.beanName + \"-\");\n\t\t}\n\t\tthis.executor = initializeExecutor(this.threadFactory, this.rejectedExecutionHandler);\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#initializeExecutor(threadFactory,rejectedExecutionHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the target {@link java.util.concurrent.ExecutorService} instance.\n\t * Called by {@code afterPropertiesSet}.\n\t * @param threadFactory the ThreadFactory to use\n\t * @param rejectedExecutionHandler the RejectedExecutionHandler to use\n\t * @return a new ExecutorService instance\n\t * @see #afterPropertiesSet()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "threadFactory",
      "rejectedExecutionHandler"
    ],
    "position": {
      "column": 1,
      "line": 197
    },
    "return": "ExecutorService",
    "signature": "protected ExecutorService initializeExecutor(ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler)",
    "source_code": "\tprotected abstract ExecutorService initializeExecutor("
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#setAwaitTerminationMillis(awaitTerminationMillis)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #setAwaitTerminationSeconds} with millisecond precision.\n\t * @since 5.2.4\n\t * @see #setAwaitTerminationSeconds\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "awaitTerminationMillis"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "void",
    "signature": "public void setAwaitTerminationMillis(long awaitTerminationMillis)",
    "source_code": "\tpublic void setAwaitTerminationMillis(long awaitTerminationMillis) {\n\t\tthis.awaitTerminationMillis = awaitTerminationMillis;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#setAwaitTerminationSeconds(awaitTerminationSeconds)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the maximum number of seconds that this executor is supposed to block\n\t * on shutdown in order to wait for remaining tasks to complete their execution\n\t * before the rest of the container continues to shut down. This is particularly\n\t * useful if your remaining tasks are likely to need access to other resources\n\t * that are also managed by the container.\n\t * <p>By default, this executor won't wait for the termination of tasks at all.\n\t * It will either shut down immediately, interrupting ongoing tasks and clearing\n\t * the remaining task queue - or, if the\n\t * {@link #setWaitForTasksToCompleteOnShutdown \"waitForTasksToCompleteOnShutdown\"}\n\t * flag has been set to {@code true}, it will continue to fully execute all\n\t * ongoing tasks as well as all remaining tasks in the queue, in parallel to\n\t * the rest of the container shutting down.\n\t * <p>In either case, if you specify an await-termination period using this property,\n\t * this executor will wait for the given time (max) for the termination of tasks.\n\t * As a rule of thumb, specify a significantly higher timeout here if you set\n\t * \"waitForTasksToCompleteOnShutdown\" to {@code true} at the same time,\n\t * since all remaining tasks in the queue will still get executed - in contrast\n\t * to the default shutdown behavior where it's just about waiting for currently\n\t * executing tasks that aren't reacting to thread interruption.\n\t * @see #setAwaitTerminationMillis\n\t * @see java.util.concurrent.ExecutorService#shutdown()\n\t * @see java.util.concurrent.ExecutorService#awaitTermination\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "awaitTerminationSeconds"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "public void setAwaitTerminationSeconds(int awaitTerminationSeconds)",
    "source_code": "\tpublic void setAwaitTerminationSeconds(int awaitTerminationSeconds) {\n\t\tthis.awaitTerminationMillis = awaitTerminationSeconds * 1000L;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#setBeanName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "void",
    "signature": "public void setBeanName(String name)",
    "source_code": "\tpublic void setBeanName(String name) {\n\t\tthis.beanName = name;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#setRejectedExecutionHandler(rejectedExecutionHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the RejectedExecutionHandler to use for the ExecutorService.\n\t * Default is the ExecutorService's default abort policy.\n\t * @see java.util.concurrent.ThreadPoolExecutor.AbortPolicy\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rejectedExecutionHandler"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "public void setRejectedExecutionHandler(@Nullable RejectedExecutionHandler rejectedExecutionHandler)",
    "source_code": "\tpublic void setRejectedExecutionHandler(@Nullable RejectedExecutionHandler rejectedExecutionHandler) {\n\t\tthis.rejectedExecutionHandler =\n\t\t\t\t(rejectedExecutionHandler != null ? rejectedExecutionHandler : new ThreadPoolExecutor.AbortPolicy());\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#setThreadFactory(threadFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the ThreadFactory to use for the ExecutorService's thread pool.\n\t * Default is the underlying ExecutorService's default thread factory.\n\t * <p>In a Jakarta EE or other managed environment with JSR-236 support,\n\t * consider specifying a JNDI-located ManagedThreadFactory: by default,\n\t * to be found at \"java:comp/DefaultManagedThreadFactory\".\n\t * Use the \"jee:jndi-lookup\" namespace element in XML or the programmatic\n\t * {@link org.springframework.jndi.JndiLocatorDelegate} for convenient lookup.\n\t * Alternatively, consider using Spring's {@link DefaultManagedAwareThreadFactory}\n\t * with its fallback to local threads in case of no managed thread factory found.\n\t * @see java.util.concurrent.Executors#defaultThreadFactory()\n\t * @see jakarta.enterprise.concurrent.ManagedThreadFactory\n\t * @see DefaultManagedAwareThreadFactory\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "threadFactory"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "void",
    "signature": "public void setThreadFactory(@Nullable ThreadFactory threadFactory)",
    "source_code": "\tpublic void setThreadFactory(@Nullable ThreadFactory threadFactory) {\n\t\tthis.threadFactory = (threadFactory != null ? threadFactory : this);\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#setThreadNamePrefix(threadNamePrefix)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "threadNamePrefix"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "void",
    "signature": "public void setThreadNamePrefix(@Nullable String threadNamePrefix)",
    "source_code": "\tpublic void setThreadNamePrefix(@Nullable String threadNamePrefix) {\n\t\tsuper.setThreadNamePrefix(threadNamePrefix);\n\t\tthis.threadNamePrefixSet = true;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#setWaitForTasksToCompleteOnShutdown(waitForJobsToCompleteOnShutdown)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to wait for scheduled tasks to complete on shutdown,\n\t * not interrupting running tasks and executing all tasks in the queue.\n\t * <p>Default is \"false\", shutting down immediately through interrupting\n\t * ongoing tasks and clearing the queue. Switch this flag to \"true\" if you\n\t * prefer fully completed tasks at the expense of a longer shutdown phase.\n\t * <p>Note that Spring's container shutdown continues while ongoing tasks\n\t * are being completed. If you want this executor to block and wait for the\n\t * termination of tasks before the rest of the container continues to shut\n\t * down - e.g. in order to keep up other resources that your tasks may need -,\n\t * set the {@link #setAwaitTerminationSeconds \"awaitTerminationSeconds\"}\n\t * property instead of or in addition to this property.\n\t * @see java.util.concurrent.ExecutorService#shutdown()\n\t * @see java.util.concurrent.ExecutorService#shutdownNow()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "waitForJobsToCompleteOnShutdown"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "void",
    "signature": "public void setWaitForTasksToCompleteOnShutdown(boolean waitForJobsToCompleteOnShutdown)",
    "source_code": "\tpublic void setWaitForTasksToCompleteOnShutdown(boolean waitForJobsToCompleteOnShutdown) {\n\t\tthis.waitForTasksToCompleteOnShutdown = waitForJobsToCompleteOnShutdown;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#shutdown()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform a shutdown on the underlying ExecutorService.\n\t * @see java.util.concurrent.ExecutorService#shutdown()\n\t * @see java.util.concurrent.ExecutorService#shutdownNow()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "void",
    "signature": "public void shutdown()",
    "source_code": "\tpublic void shutdown() {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Shutting down ExecutorService\" + (this.beanName != null ? \" '\" + this.beanName + \"'\" : \"\"));\n\t\t}\n\t\tif (this.executor != null) {\n\t\t\tif (this.waitForTasksToCompleteOnShutdown) {\n\t\t\t\tthis.executor.shutdown();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (Runnable remainingTask : this.executor.shutdownNow()) {\n\t\t\t\t\tcancelRemainingTask(remainingTask);\n\t\t\t\t}\n\t\t\t}\n\t\t\tawaitTerminationIfNecessary(this.executor);\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ManagedTaskBuilder": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate that wraps a given Runnable/Callable  with a JSR-236 ManagedTask,\n\t * exposing a long-running hint based on {@link SchedulingAwareRunnable}\n\t * and a given identity name.\n\t */",
    "kind": "class",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "signature": "protected class ManagedTaskBuilder",
    "source_code": "\tprotected static class ManagedTaskBuilder {\n\n\t\tpublic static Runnable buildManagedTask(Runnable task, String identityName) {\n\t\t\tMap<String, String> properties;\n\t\t\tif (task instanceof SchedulingAwareRunnable schedulingAwareRunnable) {\n\t\t\t\tproperties = new HashMap<>(4);\n\t\t\t\tproperties.put(ManagedTask.LONGRUNNING_HINT,\n\t\t\t\t\t\tBoolean.toString(schedulingAwareRunnable.isLongLived()));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tproperties = new HashMap<>(2);\n\t\t\t}\n\t\t\tproperties.put(ManagedTask.IDENTITY_NAME, identityName);\n\t\t\treturn ManagedExecutors.managedTask(task, properties, null);\n\t\t}\n\n\t\tpublic static <T> Callable<T> buildManagedTask(Callable<T> task, String identityName) {\n\t\t\tMap<String, String> properties = new HashMap<>(2);\n\t\t\tproperties.put(ManagedTask.IDENTITY_NAME, identityName);\n\t\t\treturn ManagedExecutors.managedTask(task, properties, null);\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link org.springframework.beans.factory.FactoryBean} that sets up\n * a {@link java.util.concurrent.ScheduledExecutorService}\n * (by default: a {@link java.util.concurrent.ScheduledThreadPoolExecutor})\n * and exposes it for bean references.\n *\n * <p>Allows for registration of {@link ScheduledExecutorTask ScheduledExecutorTasks},\n * automatically starting the {@link ScheduledExecutorService} on initialization and\n * canceling it on destruction of the context. In scenarios that only require static\n * registration of tasks at startup, there is no need to access the\n * {@link ScheduledExecutorService} instance itself in application code at all;\n * {@code ScheduledExecutorFactoryBean} is then just being used for lifecycle integration.\n *\n * <p>For an alternative, you may set up a {@link ScheduledThreadPoolExecutor} instance\n * directly using constructor injection, or use a factory method definition that points\n * to the {@link java.util.concurrent.Executors} class.\n * <b>This is strongly recommended in particular for common {@code @Bean} methods in\n * configuration classes, where this {@code FactoryBean} variant would force you to\n * return the {@code FactoryBean} type instead of {@code ScheduledExecutorService}.</b>\n *\n * <p>Note that {@link java.util.concurrent.ScheduledExecutorService}\n * uses a {@link Runnable} instance that is shared between repeated executions,\n * in contrast to Quartz which instantiates a new Job for each execution.\n *\n * <p><b>WARNING:</b> {@link Runnable Runnables} submitted via a native\n * {@link java.util.concurrent.ScheduledExecutorService} are removed from\n * the execution schedule once they throw an exception. If you would prefer\n * to continue execution after such an exception, switch this FactoryBean's\n * {@link #setContinueScheduledExecutionAfterException \"continueScheduledExecutionAfterException\"}\n * property to \"true\".\n *\n * @author Juergen Hoeller\n * @since 2.0\n * @see #setPoolSize\n * @see #setRemoveOnCancelPolicy\n * @see #setThreadFactory\n * @see ScheduledExecutorTask\n * @see java.util.concurrent.ScheduledExecutorService\n * @see java.util.concurrent.ScheduledThreadPoolExecutor\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "signature": "public class ScheduledExecutorFactoryBean",
    "source_code": "public class ScheduledExecutorFactoryBean extends ExecutorConfigurationSupport"
  },
  "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean#createExecutor(poolSize,threadFactory,rejectedExecutionHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link ScheduledExecutorService} instance.\n\t * <p>The default implementation creates a {@link ScheduledThreadPoolExecutor}.\n\t * Can be overridden in subclasses to provide custom {@link ScheduledExecutorService} instances.\n\t * @param poolSize the specified pool size\n\t * @param threadFactory the ThreadFactory to use\n\t * @param rejectedExecutionHandler the RejectedExecutionHandler to use\n\t * @return a new ScheduledExecutorService instance\n\t * @see #afterPropertiesSet()\n\t * @see java.util.concurrent.ScheduledThreadPoolExecutor\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "poolSize",
      "threadFactory",
      "rejectedExecutionHandler"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "ScheduledExecutorService",
    "signature": "protected ScheduledExecutorService createExecutor(int poolSize, ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler)",
    "source_code": "\tprotected ScheduledExecutorService createExecutor("
  },
  "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean#getObject()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "ScheduledExecutorService",
    "signature": "public ScheduledExecutorService getObject()",
    "source_code": "\tpublic ScheduledExecutorService getObject() {\n\t\treturn this.exposedExecutor;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean#getRunnableToSchedule(task)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the actual Runnable to schedule for the given task.\n\t * <p>Wraps the task's Runnable in a\n\t * {@link org.springframework.scheduling.support.DelegatingErrorHandlingRunnable}\n\t * that will catch and log the Exception. If necessary, it will suppress the\n\t * Exception according to the\n\t * {@link #setContinueScheduledExecutionAfterException \"continueScheduledExecutionAfterException\"}\n\t * flag.\n\t * @param task the ScheduledExecutorTask to schedule\n\t * @return the actual Runnable to schedule (may be a decorator)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "Runnable",
    "signature": "protected Runnable getRunnableToSchedule(ScheduledExecutorTask task)",
    "source_code": "\tprotected Runnable getRunnableToSchedule(ScheduledExecutorTask task) {\n\t\treturn (this.continueScheduledExecutionAfterException ?\n\t\t\t\tnew DelegatingErrorHandlingRunnable(task.getRunnable(), TaskUtils.LOG_AND_SUPPRESS_ERROR_HANDLER) :\n\t\t\t\tnew DelegatingErrorHandlingRunnable(task.getRunnable(), TaskUtils.LOG_AND_PROPAGATE_ERROR_HANDLER));\n\t}"
  },
  "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean#initializeExecutor(threadFactory,rejectedExecutionHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "threadFactory",
      "rejectedExecutionHandler"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "ExecutorService",
    "signature": "protected ExecutorService initializeExecutor(ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler)",
    "source_code": "\tprotected ExecutorService initializeExecutor("
  },
  "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean#isSingleton()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "boolean",
    "signature": "public boolean isSingleton()",
    "source_code": "\tpublic boolean isSingleton() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean#registerTasks(tasks,executor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register the specified {@link ScheduledExecutorTask ScheduledExecutorTasks}\n\t * on the given {@link ScheduledExecutorService}.\n\t * @param tasks the specified ScheduledExecutorTasks (never empty)\n\t * @param executor the ScheduledExecutorService to register the tasks on.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "tasks",
      "executor"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "void",
    "signature": "protected void registerTasks(ScheduledExecutorTask[] tasks, ScheduledExecutorService executor)",
    "source_code": "\tprotected void registerTasks(ScheduledExecutorTask[] tasks, ScheduledExecutorService executor) {\n\t\tfor (ScheduledExecutorTask task : tasks) {\n\t\t\tRunnable runnable = getRunnableToSchedule(task);\n\t\t\tif (task.isOneTimeTask()) {\n\t\t\t\texecutor.schedule(runnable, task.getDelay(), task.getTimeUnit());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (task.isFixedRate()) {\n\t\t\t\t\texecutor.scheduleAtFixedRate(runnable, task.getDelay(), task.getPeriod(), task.getTimeUnit());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\texecutor.scheduleWithFixedDelay(runnable, task.getDelay(), task.getPeriod(), task.getTimeUnit());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean#setContinueScheduledExecutionAfterException(continueScheduledExecutionAfterException)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether to continue the execution of a scheduled task\n\t * after it threw an exception.\n\t * <p>Default is \"false\", matching the native behavior of a\n\t * {@link java.util.concurrent.ScheduledExecutorService}.\n\t * Switch this flag to \"true\" for exception-proof execution of each task,\n\t * continuing scheduled execution as in the case of successful execution.\n\t * @see java.util.concurrent.ScheduledExecutorService#scheduleAtFixedRate\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "continueScheduledExecutionAfterException"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "void",
    "signature": "public void setContinueScheduledExecutionAfterException(boolean continueScheduledExecutionAfterException)",
    "source_code": "\tpublic void setContinueScheduledExecutionAfterException(boolean continueScheduledExecutionAfterException) {\n\t\tthis.continueScheduledExecutionAfterException = continueScheduledExecutionAfterException;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean#setExposeUnconfigurableExecutor(exposeUnconfigurableExecutor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether this FactoryBean should expose an unconfigurable\n\t * decorator for the created executor.\n\t * <p>Default is \"false\", exposing the raw executor as bean reference.\n\t * Switch this flag to \"true\" to strictly prevent clients from\n\t * modifying the executor's configuration.\n\t * @see java.util.concurrent.Executors#unconfigurableScheduledExecutorService\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exposeUnconfigurableExecutor"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "void",
    "signature": "public void setExposeUnconfigurableExecutor(boolean exposeUnconfigurableExecutor)",
    "source_code": "\tpublic void setExposeUnconfigurableExecutor(boolean exposeUnconfigurableExecutor) {\n\t\tthis.exposeUnconfigurableExecutor = exposeUnconfigurableExecutor;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean#setPoolSize(poolSize)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the ScheduledExecutorService's pool size.\n\t * Default is 1.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "poolSize"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "public void setPoolSize(int poolSize)",
    "source_code": "\tpublic void setPoolSize(int poolSize) {\n\t\tAssert.isTrue(poolSize > 0, \"'poolSize' must be 1 or higher\");\n\t\tthis.poolSize = poolSize;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean#setRemoveOnCancelPolicy(removeOnCancelPolicy)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the remove-on-cancel mode on {@link ScheduledThreadPoolExecutor}.\n\t * <p>Default is {@code false}. If set to {@code true}, the target executor will be\n\t * switched into remove-on-cancel mode (if possible, with a soft fallback otherwise).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "removeOnCancelPolicy"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "void",
    "signature": "public void setRemoveOnCancelPolicy(boolean removeOnCancelPolicy)",
    "source_code": "\tpublic void setRemoveOnCancelPolicy(boolean removeOnCancelPolicy) {\n\t\tthis.removeOnCancelPolicy = removeOnCancelPolicy;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean#setScheduledExecutorTasks(scheduledExecutorTasks)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a list of ScheduledExecutorTask objects with the ScheduledExecutorService\n\t * that this FactoryBean creates. Depending on each ScheduledExecutorTask's settings,\n\t * it will be registered via one of ScheduledExecutorService's schedule methods.\n\t * @see java.util.concurrent.ScheduledExecutorService#schedule(java.lang.Runnable, long, java.util.concurrent.TimeUnit)\n\t * @see java.util.concurrent.ScheduledExecutorService#scheduleWithFixedDelay(java.lang.Runnable, long, long, java.util.concurrent.TimeUnit)\n\t * @see java.util.concurrent.ScheduledExecutorService#scheduleAtFixedRate(java.lang.Runnable, long, long, java.util.concurrent.TimeUnit)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scheduledExecutorTasks"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "void",
    "signature": "public void setScheduledExecutorTasks(ScheduledExecutorTask... scheduledExecutorTasks)",
    "source_code": "\tpublic void setScheduledExecutorTasks(ScheduledExecutorTask... scheduledExecutorTasks) {\n\t\tthis.scheduledExecutorTasks = scheduledExecutorTasks;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * JavaBean that allows for configuring a {@link java.util.concurrent.ThreadPoolExecutor}\n * in bean style (through its \"corePoolSize\", \"maxPoolSize\", \"keepAliveSeconds\", \"queueCapacity\"\n * properties) and exposing it as a Spring {@link org.springframework.core.task.TaskExecutor}.\n * This class is also well suited for management and monitoring (e.g. through JMX),\n * providing several useful attributes: \"corePoolSize\", \"maxPoolSize\", \"keepAliveSeconds\"\n * (all supporting updates at runtime); \"poolSize\", \"activeCount\" (for introspection only).\n *\n * <p>The default configuration is a core pool size of 1, with unlimited max pool size\n * and unlimited queue capacity. This is roughly equivalent to\n * {@link java.util.concurrent.Executors#newSingleThreadExecutor()}, sharing a single\n * thread for all tasks. Setting {@link #setQueueCapacity \"queueCapacity\"} to 0 mimics\n * {@link java.util.concurrent.Executors#newCachedThreadPool()}, with immediate scaling\n * of threads in the pool to a potentially very high number. Consider also setting a\n * {@link #setMaxPoolSize \"maxPoolSize\"} at that point, as well as possibly a higher\n * {@link #setCorePoolSize \"corePoolSize\"} (see also the\n * {@link #setAllowCoreThreadTimeOut \"allowCoreThreadTimeOut\"} mode of scaling).\n *\n * <p><b>NOTE:</b> This class implements Spring's\n * {@link org.springframework.core.task.TaskExecutor} interface as well as the\n * {@link java.util.concurrent.Executor} interface, with the former being the primary\n * interface, the other just serving as secondary convenience. For this reason, the\n * exception handling follows the TaskExecutor contract rather than the Executor contract,\n * in particular regarding the {@link org.springframework.core.task.TaskRejectedException}.\n *\n * <p>For an alternative, you may set up a ThreadPoolExecutor instance directly using\n * constructor injection, or use a factory method definition that points to the\n * {@link java.util.concurrent.Executors} class. To expose such a raw Executor as a\n * Spring {@link org.springframework.core.task.TaskExecutor}, simply wrap it with a\n * {@link org.springframework.scheduling.concurrent.ConcurrentTaskExecutor} adapter.\n *\n * @author Juergen Hoeller\n * @author R\u00e9my Guihard\n * @author Sam Brannen\n * @since 2.0\n * @see org.springframework.core.task.TaskExecutor\n * @see java.util.concurrent.ThreadPoolExecutor\n * @see ThreadPoolExecutorFactoryBean\n * @see ConcurrentTaskExecutor\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "signature": "public class ThreadPoolTaskExecutor",
    "source_code": "public class ThreadPoolTaskExecutor extends ExecutorConfigurationSupport"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#cancelRemainingTask(task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 422
    },
    "return": "void",
    "signature": "protected void cancelRemainingTask(Runnable task)",
    "source_code": "\tprotected void cancelRemainingTask(Runnable task) {\n\t\tsuper.cancelRemainingTask(task);\n\t\t// Cancel associated user-level Future handle as well\n\t\tObject original = this.decoratedTaskMap.get(task);\n\t\tif (original instanceof Future<?> future) {\n\t\t\tfuture.cancel(true);\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#createQueue(queueCapacity)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the BlockingQueue to use for the ThreadPoolExecutor.\n\t * <p>A LinkedBlockingQueue instance will be created for a positive\n\t * capacity value; a SynchronousQueue else.\n\t * @param queueCapacity the specified queue capacity\n\t * @return the BlockingQueue instance\n\t * @see java.util.concurrent.LinkedBlockingQueue\n\t * @see java.util.concurrent.SynchronousQueue\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "queueCapacity"
    ],
    "position": {
      "column": 1,
      "line": 299
    },
    "return": "BlockingQueue<Runnable>",
    "signature": "protected BlockingQueue<Runnable> createQueue(int queueCapacity)",
    "source_code": "\tprotected BlockingQueue<Runnable> createQueue(int queueCapacity) {\n\t\tif (queueCapacity > 0) {\n\t\t\treturn new LinkedBlockingQueue<>(queueCapacity);\n\t\t}\n\t\telse {\n\t\t\treturn new SynchronousQueue<>();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#execute(command)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "command"
    ],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "void",
    "signature": "public void execute(Runnable command)",
    "source_code": "\t\t\t\tpublic void execute(Runnable command) {\n\t\t\t\t\tRunnable decorated = taskDecorator.decorate(command);\n\t\t\t\t\tif (decorated != command) {\n\t\t\t\t\t\tdecoratedTaskMap.put(decorated, command);\n\t\t\t\t\t}\n\t\t\t\t\tsuper.execute(decorated);\n\t\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#execute(task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 357
    },
    "return": "void",
    "signature": "public void execute(Runnable task)",
    "source_code": "\tpublic void execute(Runnable task) {\n\t\tExecutor executor = getThreadPoolExecutor();\n\t\ttry {\n\t\t\texecutor.execute(task);\n\t\t}\n\t\tcatch (RejectedExecutionException ex) {\n\t\t\tthrow new TaskRejectedException(\"Executor [\" + executor + \"] did not accept task: \" + task, ex);\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#execute(task,startTimeout)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "startTimeout"
    ],
    "position": {
      "column": 1,
      "line": 369
    },
    "return": "void",
    "signature": "public void execute(Runnable task, long startTimeout)",
    "source_code": "\tpublic void execute(Runnable task, long startTimeout) {\n\t\texecute(task);\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#getActiveCount()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the number of currently active threads.\n\t * @see java.util.concurrent.ThreadPoolExecutor#getActiveCount()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "int",
    "signature": "public int getActiveCount()",
    "source_code": "\tpublic int getActiveCount() {\n\t\tif (this.threadPoolExecutor == null) {\n\t\t\t// Not initialized yet: assume no active threads.\n\t\t\treturn 0;\n\t\t}\n\t\treturn this.threadPoolExecutor.getActiveCount();\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#getCorePoolSize()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the ThreadPoolExecutor's core pool size.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "int",
    "signature": "public int getCorePoolSize()",
    "source_code": "\tpublic int getCorePoolSize() {\n\t\tsynchronized (this.poolSizeMonitor) {\n\t\t\treturn this.corePoolSize;\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#getKeepAliveSeconds()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the ThreadPoolExecutor's keep-alive seconds.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "int",
    "signature": "public int getKeepAliveSeconds()",
    "source_code": "\tpublic int getKeepAliveSeconds() {\n\t\tsynchronized (this.poolSizeMonitor) {\n\t\t\treturn this.keepAliveSeconds;\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#getMaxPoolSize()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the ThreadPoolExecutor's maximum pool size.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "int",
    "signature": "public int getMaxPoolSize()",
    "source_code": "\tpublic int getMaxPoolSize() {\n\t\tsynchronized (this.poolSizeMonitor) {\n\t\t\treturn this.maxPoolSize;\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#getPoolSize()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the current pool size.\n\t * @see java.util.concurrent.ThreadPoolExecutor#getPoolSize()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 322
    },
    "return": "int",
    "signature": "public int getPoolSize()",
    "source_code": "\tpublic int getPoolSize() {\n\t\tif (this.threadPoolExecutor == null) {\n\t\t\t// Not initialized yet: assume core pool size.\n\t\t\treturn this.corePoolSize;\n\t\t}\n\t\treturn this.threadPoolExecutor.getPoolSize();\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#getQueueCapacity()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the capacity for the ThreadPoolExecutor's BlockingQueue.\n\t * @since 5.3.21\n\t * @see #setQueueCapacity(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "int",
    "signature": "public int getQueueCapacity()",
    "source_code": "\tpublic int getQueueCapacity() {\n\t\treturn this.queueCapacity;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#getQueueSize()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the current queue size.\n\t * @since 5.3.21\n\t * @see java.util.concurrent.ThreadPoolExecutor#getQueue()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 335
    },
    "return": "int",
    "signature": "public int getQueueSize()",
    "source_code": "\tpublic int getQueueSize() {\n\t\tif (this.threadPoolExecutor == null) {\n\t\t\t// Not initialized yet: assume no queued tasks.\n\t\t\treturn 0;\n\t\t}\n\t\treturn this.threadPoolExecutor.getQueue().size();\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#getThreadPoolExecutor()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the underlying ThreadPoolExecutor for native access.\n\t * @return the underlying ThreadPoolExecutor (never {@code null})\n\t * @throws IllegalStateException if the ThreadPoolTaskExecutor hasn't been initialized yet\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 313
    },
    "return": "ThreadPoolExecutor",
    "signature": "public ThreadPoolExecutor getThreadPoolExecutor()",
    "source_code": "\tpublic ThreadPoolExecutor getThreadPoolExecutor() throws IllegalStateException {\n\t\tAssert.state(this.threadPoolExecutor != null, \"ThreadPoolTaskExecutor not initialized\");\n\t\treturn this.threadPoolExecutor;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#initializeExecutor(threadFactory,rejectedExecutionHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Note: This method exposes an {@link ExecutorService} to its base class\n\t * but stores the actual {@link ThreadPoolExecutor} handle internally.\n\t * Do not override this method for replacing the executor, rather just for\n\t * decorating its {@code ExecutorService} handle or storing custom state.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "threadFactory",
      "rejectedExecutionHandler"
    ],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "ExecutorService",
    "signature": "protected ExecutorService initializeExecutor(ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler)",
    "source_code": "\tprotected ExecutorService initializeExecutor("
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#setAllowCoreThreadTimeOut(allowCoreThreadTimeOut)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether to allow core threads to time out. This enables dynamic\n\t * growing and shrinking even in combination with a non-zero queue (since\n\t * the max pool size will only grow once the queue is full).\n\t * <p>Default is \"false\".\n\t * @see java.util.concurrent.ThreadPoolExecutor#allowCoreThreadTimeOut(boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "allowCoreThreadTimeOut"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "void",
    "signature": "public void setAllowCoreThreadTimeOut(boolean allowCoreThreadTimeOut)",
    "source_code": "\tpublic void setAllowCoreThreadTimeOut(boolean allowCoreThreadTimeOut) {\n\t\tthis.allowCoreThreadTimeOut = allowCoreThreadTimeOut;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#setCorePoolSize(corePoolSize)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the ThreadPoolExecutor's core pool size.\n\t * Default is 1.\n\t * <p><b>This setting can be modified at runtime, for example through JMX.</b>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "corePoolSize"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "void",
    "signature": "public void setCorePoolSize(int corePoolSize)",
    "source_code": "\tpublic void setCorePoolSize(int corePoolSize) {\n\t\tsynchronized (this.poolSizeMonitor) {\n\t\t\tif (this.threadPoolExecutor != null) {\n\t\t\t\tthis.threadPoolExecutor.setCorePoolSize(corePoolSize);\n\t\t\t}\n\t\t\tthis.corePoolSize = corePoolSize;\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#setKeepAliveSeconds(keepAliveSeconds)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the ThreadPoolExecutor's keep-alive seconds.\n\t * <p>Default is 60.\n\t * <p><b>This setting can be modified at runtime, for example through JMX.</b>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "keepAliveSeconds"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "void",
    "signature": "public void setKeepAliveSeconds(int keepAliveSeconds)",
    "source_code": "\tpublic void setKeepAliveSeconds(int keepAliveSeconds) {\n\t\tsynchronized (this.poolSizeMonitor) {\n\t\t\tif (this.threadPoolExecutor != null) {\n\t\t\t\tthis.threadPoolExecutor.setKeepAliveTime(keepAliveSeconds, TimeUnit.SECONDS);\n\t\t\t}\n\t\t\tthis.keepAliveSeconds = keepAliveSeconds;\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#setMaxPoolSize(maxPoolSize)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the ThreadPoolExecutor's maximum pool size.\n\t * Default is {@code Integer.MAX_VALUE}.\n\t * <p><b>This setting can be modified at runtime, for example through JMX.</b>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "maxPoolSize"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "void",
    "signature": "public void setMaxPoolSize(int maxPoolSize)",
    "source_code": "\tpublic void setMaxPoolSize(int maxPoolSize) {\n\t\tsynchronized (this.poolSizeMonitor) {\n\t\t\tif (this.threadPoolExecutor != null) {\n\t\t\t\tthis.threadPoolExecutor.setMaximumPoolSize(maxPoolSize);\n\t\t\t}\n\t\t\tthis.maxPoolSize = maxPoolSize;\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#setPrestartAllCoreThreads(prestartAllCoreThreads)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether to start all core threads, causing them to idly wait for work.\n\t * <p>Default is \"false\".\n\t * @since 5.3.14\n\t * @see java.util.concurrent.ThreadPoolExecutor#prestartAllCoreThreads\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "prestartAllCoreThreads"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "void",
    "signature": "public void setPrestartAllCoreThreads(boolean prestartAllCoreThreads)",
    "source_code": "\tpublic void setPrestartAllCoreThreads(boolean prestartAllCoreThreads) {\n\t\tthis.prestartAllCoreThreads = prestartAllCoreThreads;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#setQueueCapacity(queueCapacity)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the capacity for the ThreadPoolExecutor's BlockingQueue.\n\t * <p>Default is {@code Integer.MAX_VALUE}.\n\t * <p>Any positive value will lead to a LinkedBlockingQueue instance;\n\t * any other value will lead to a SynchronousQueue instance.\n\t * @see java.util.concurrent.LinkedBlockingQueue\n\t * @see java.util.concurrent.SynchronousQueue\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queueCapacity"
    ],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "void",
    "signature": "public void setQueueCapacity(int queueCapacity)",
    "source_code": "\tpublic void setQueueCapacity(int queueCapacity) {\n\t\tthis.queueCapacity = queueCapacity;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#setTaskDecorator(taskDecorator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify a custom {@link TaskDecorator} to be applied to any {@link Runnable}\n\t * about to be executed.\n\t * <p>Note that such a decorator is not necessarily being applied to the\n\t * user-supplied {@code Runnable}/{@code Callable} but rather to the actual\n\t * execution callback (which may be a wrapper around the user-supplied task).\n\t * <p>The primary use case is to set some execution context around the task's\n\t * invocation, or to provide some monitoring/statistics for task execution.\n\t * <p><b>NOTE:</b> Exception handling in {@code TaskDecorator} implementations\n\t * is limited to plain {@code Runnable} execution via {@code execute} calls.\n\t * In case of {@code #submit} calls, the exposed {@code Runnable} will be a\n\t * {@code FutureTask} which does not propagate any exceptions; you might\n\t * have to cast it and call {@code Future#get} to evaluate exceptions.\n\t * See the {@code ThreadPoolExecutor#afterExecute} javadoc for an example\n\t * of how to access exceptions in such a {@code Future} case.\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "taskDecorator"
    ],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "void",
    "signature": "public void setTaskDecorator(TaskDecorator taskDecorator)",
    "source_code": "\tpublic void setTaskDecorator(TaskDecorator taskDecorator) {\n\t\tthis.taskDecorator = taskDecorator;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#submit(task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 385
    },
    "return": "Future<T>",
    "signature": "public Future<T> submit(Callable<T> task)",
    "source_code": "\tpublic <T> Future<T> submit(Callable<T> task) {\n\t\tExecutorService executor = getThreadPoolExecutor();\n\t\ttry {\n\t\t\treturn executor.submit(task);\n\t\t}\n\t\tcatch (RejectedExecutionException ex) {\n\t\t\tthrow new TaskRejectedException(\"Executor [\" + executor + \"] did not accept task: \" + task, ex);\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#submitListenable(task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 409
    },
    "return": "ListenableFuture<T>",
    "signature": "public ListenableFuture<T> submitListenable(Callable<T> task)",
    "source_code": "\tpublic <T> ListenableFuture<T> submitListenable(Callable<T> task) {\n\t\tExecutorService executor = getThreadPoolExecutor();\n\t\ttry {\n\t\t\tListenableFutureTask<T> future = new ListenableFutureTask<>(task);\n\t\t\texecutor.execute(future);\n\t\t\treturn future;\n\t\t}\n\t\tcatch (RejectedExecutionException ex) {\n\t\t\tthrow new TaskRejectedException(\"Executor [\" + executor + \"] did not accept task: \" + task, ex);\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.logger": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.scheduling.quartz.AdaptableJobFactory": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link JobFactory} implementation that supports {@link java.lang.Runnable}\n * objects as well as standard Quartz {@link org.quartz.Job} instances.\n *\n * <p>Compatible with Quartz 2.1.4 and higher, as of Spring 4.1.\n *\n * @author Juergen Hoeller\n * @since 2.0\n * @see DelegatingJob\n * @see #adaptJob(Object)\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "signature": "public class AdaptableJobFactory",
    "source_code": "public class AdaptableJobFactory implements JobFactory {\n\n\t@Override\n\tpublic Job newJob(TriggerFiredBundle bundle, Scheduler scheduler) throws SchedulerException {\n\t\ttry {\n\t\t\tObject jobObject = createJobInstance(bundle);\n\t\t\treturn adaptJob(jobObject);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new SchedulerException(\"Job instantiation failed\", ex);\n\t\t}\n\t}\n\n\t/**\n\t * Create an instance of the specified job class.\n\t * <p>Can be overridden to post-process the job instance.\n\t * @param bundle the TriggerFiredBundle from which the JobDetail\n\t * and other info relating to the trigger firing can be obtained\n\t * @return the job instance\n\t * @throws Exception if job instantiation failed\n\t */\n\tprotected Object createJobInstance(TriggerFiredBundle bundle) throws Exception {\n\t\tClass<?> jobClass = bundle.getJobDetail().getJobClass();\n\t\treturn ReflectionUtils.accessibleConstructor(jobClass).newInstance();\n\t}\n\n\t/**\n\t * Adapt the given job object to the Quartz Job interface.\n\t * <p>The default implementation supports straight Quartz Jobs\n\t * as well as Runnables, which get wrapped in a DelegatingJob.\n\t * @param jobObject the original instance of the specified job class\n\t * @return the adapted Quartz Job instance\n\t * @throws Exception if the given job could not be adapted\n\t * @see DelegatingJob\n\t */\n\tprotected Job adaptJob(Object jobObject) throws Exception {\n\t\tif (jobObject instanceof Job job) {\n\t\t\treturn job;\n\t\t}\n\t\telse if (jobObject instanceof Runnable runnable) {\n\t\t\treturn new DelegatingJob(runnable);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Unable to execute job class [\" + jobObject.getClass().getName() +\n\t\t\t\t\t\"]: only [org.quartz.Job] and [java.lang.Runnable] supported.\");\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.scheduling.quartz.AdaptableJobFactory#adaptJob(jobObject)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Adapt the given job object to the Quartz Job interface.\n\t * <p>The default implementation supports straight Quartz Jobs\n\t * as well as Runnables, which get wrapped in a DelegatingJob.\n\t * @param jobObject the original instance of the specified job class\n\t * @return the adapted Quartz Job instance\n\t * @throws Exception if the given job could not be adapted\n\t * @see DelegatingJob\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "jobObject"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "Job",
    "signature": "protected Job adaptJob(Object jobObject)",
    "source_code": "\tprotected Job adaptJob(Object jobObject) throws Exception {\n\t\tif (jobObject instanceof Job job) {\n\t\t\treturn job;\n\t\t}\n\t\telse if (jobObject instanceof Runnable runnable) {\n\t\t\treturn new DelegatingJob(runnable);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Unable to execute job class [\" + jobObject.getClass().getName() +\n\t\t\t\t\t\"]: only [org.quartz.Job] and [java.lang.Runnable] supported.\");\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.quartz.AdaptableJobFactory#createJobInstance(bundle)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an instance of the specified job class.\n\t * <p>Can be overridden to post-process the job instance.\n\t * @param bundle the TriggerFiredBundle from which the JobDetail\n\t * and other info relating to the trigger firing can be obtained\n\t * @return the job instance\n\t * @throws Exception if job instantiation failed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bundle"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "Object",
    "signature": "protected Object createJobInstance(TriggerFiredBundle bundle)",
    "source_code": "\tprotected Object createJobInstance(TriggerFiredBundle bundle) throws Exception {\n\t\tClass<?> jobClass = bundle.getJobDetail().getJobClass();\n\t\treturn ReflectionUtils.accessibleConstructor(jobClass).newInstance();\n\t}"
  },
  "org.springframework.scheduling.quartz.AdaptableJobFactory#newJob(bundle,scheduler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bundle",
      "scheduler"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "return": "Job",
    "signature": "public Job newJob(TriggerFiredBundle bundle, Scheduler scheduler)",
    "source_code": "\tpublic Job newJob(TriggerFiredBundle bundle, Scheduler scheduler) throws SchedulerException {\n\t\ttry {\n\t\t\tObject jobObject = createJobInstance(bundle);\n\t\t\treturn adaptJob(jobObject);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new SchedulerException(\"Job instantiation failed\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.quartz.MethodInvokingJob": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Quartz Job implementation that invokes a specified method.\n\t * Automatically applied by MethodInvokingJobDetailFactoryBean.\n\t */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 246
    },
    "signature": "public class MethodInvokingJob",
    "source_code": "\tpublic static class MethodInvokingJob extends QuartzJobBean {\n\n\t\tprotected static final Log logger = LogFactory.getLog(MethodInvokingJob.class);\n\n\t\t@Nullable\n\t\tprivate MethodInvoker methodInvoker;\n\n\t\t/**\n\t\t * Set the MethodInvoker to use.\n\t\t */\n\t\tpublic void setMethodInvoker(MethodInvoker methodInvoker) {\n\t\t\tthis.methodInvoker = methodInvoker;\n\t\t}\n\n\t\t/**\n\t\t * Invoke the method via the MethodInvoker.\n\t\t */\n\t\t@Override\n\t\tprotected void executeInternal(JobExecutionContext context) throws JobExecutionException {\n\t\t\tAssert.state(this.methodInvoker != null, \"No MethodInvoker set\");\n\t\t\ttry {\n\t\t\t\tcontext.setResult(this.methodInvoker.invoke());\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tif (ex.getTargetException() instanceof JobExecutionException jobExecutionException) {\n\t\t\t\t\t// -> JobExecutionException, to be logged at info level by Quartz\n\t\t\t\t\tthrow jobExecutionException;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// -> \"unhandled exception\", to be logged at error level by Quartz\n\t\t\t\t\tthrow new JobMethodInvocationFailedException(this.methodInvoker, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\t// -> \"unhandled exception\", to be logged at error level by Quartz\n\t\t\t\tthrow new JobMethodInvocationFailedException(this.methodInvoker, ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link org.springframework.beans.factory.FactoryBean} that exposes a\n * {@link org.quartz.JobDetail} object which delegates job execution to a\n * specified (static or non-static) method. Avoids the need for implementing\n * a one-line Quartz Job that just invokes an existing service method on a\n * Spring-managed target bean.\n *\n * <p>Inherits common configuration properties from the {@link MethodInvoker}\n * base class, such as {@link #setTargetObject \"targetObject\"} and\n * {@link #setTargetMethod \"targetMethod\"}, adding support for lookup of the target\n * bean by name through the {@link #setTargetBeanName \"targetBeanName\"} property\n * (as alternative to specifying a \"targetObject\" directly, allowing for\n * non-singleton target objects).\n *\n * <p>Supports both concurrently running jobs and non-currently running\n * jobs through the \"concurrent\" property. Jobs created by this\n * MethodInvokingJobDetailFactoryBean are by default volatile and durable\n * (according to Quartz terminology).\n *\n * <p><b>NOTE: JobDetails created via this FactoryBean are <i>not</i>\n * serializable and thus not suitable for persistent job stores.</b>\n * You need to implement your own Quartz Job as a thin wrapper for each case\n * where you want a persistent job to delegate to a specific service method.\n *\n * <p>Compatible with Quartz 2.1.4 and higher, as of Spring 4.1.\n *\n * @author Juergen Hoeller\n * @author Alef Arendsen\n * @since 18.02.2004\n * @see #setTargetBeanName\n * @see #setTargetObject\n * @see #setTargetMethod\n * @see #setConcurrent\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "signature": "public class MethodInvokingJobDetailFactoryBean",
    "source_code": "public class MethodInvokingJobDetailFactoryBean extends ArgumentConvertingMethodInvoker"
  },
  "org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() throws ClassNotFoundException, NoSuchMethodException {\n\t\tprepare();\n\n\t\t// Use specific name if given, else fall back to bean name.\n\t\tString name = (this.name != null ? this.name : this.beanName);\n\n\t\t// Consider the concurrent flag to choose between stateful and stateless job.\n\t\tClass<? extends Job> jobClass = (this.concurrent ? MethodInvokingJob.class : StatefulMethodInvokingJob.class);\n\n\t\t// Build JobDetail instance.\n\t\tJobDetailImpl jdi = new JobDetailImpl();\n\t\tjdi.setName(name != null ? name : toString());\n\t\tjdi.setGroup(this.group);\n\t\tjdi.setJobClass(jobClass);\n\t\tjdi.setDurability(true);\n\t\tjdi.getJobDataMap().put(\"methodInvoker\", this);\n\t\tthis.jobDetail = jdi;\n\n\t\tpostProcessJobDetail(this.jobDetail);\n\t}"
  },
  "org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean#executeInternal(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Invoke the method via the MethodInvoker.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "void",
    "signature": "protected void executeInternal(JobExecutionContext context)",
    "source_code": "\t\tprotected void executeInternal(JobExecutionContext context) throws JobExecutionException {\n\t\t\tAssert.state(this.methodInvoker != null, \"No MethodInvoker set\");\n\t\t\ttry {\n\t\t\t\tcontext.setResult(this.methodInvoker.invoke());\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tif (ex.getTargetException() instanceof JobExecutionException jobExecutionException) {\n\t\t\t\t\t// -> JobExecutionException, to be logged at info level by Quartz\n\t\t\t\t\tthrow jobExecutionException;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// -> \"unhandled exception\", to be logged at error level by Quartz\n\t\t\t\t\tthrow new JobMethodInvocationFailedException(this.methodInvoker, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\t// -> \"unhandled exception\", to be logged at error level by Quartz\n\t\t\t\tthrow new JobMethodInvocationFailedException(this.methodInvoker, ex);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean#getObject()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "JobDetail",
    "signature": "public JobDetail getObject()",
    "source_code": "\tpublic JobDetail getObject() {\n\t\treturn this.jobDetail;\n\t}"
  },
  "org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean#getTargetObject()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Overridden to support the {@link #setTargetBeanName \"targetBeanName\"} feature.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "Object",
    "signature": "public Object getTargetObject()",
    "source_code": "\tpublic Object getTargetObject() {\n\t\tObject targetObject = super.getTargetObject();\n\t\tif (targetObject == null && this.targetBeanName != null) {\n\t\t\tAssert.state(this.beanFactory != null, \"BeanFactory must be set when using 'targetBeanName'\");\n\t\t\ttargetObject = this.beanFactory.getBean(this.targetBeanName);\n\t\t}\n\t\treturn targetObject;\n\t}"
  },
  "org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean#isSingleton()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "boolean",
    "signature": "public boolean isSingleton()",
    "source_code": "\tpublic boolean isSingleton() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean#postProcessJobDetail(jobDetail)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Callback for post-processing the JobDetail to be exposed by this FactoryBean.\n\t * <p>The default implementation is empty. Can be overridden in subclasses.\n\t * @param jobDetail the JobDetail prepared by this FactoryBean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "jobDetail"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "void",
    "signature": "protected void postProcessJobDetail(JobDetail jobDetail)",
    "source_code": "\tprotected void postProcessJobDetail(JobDetail jobDetail) {\n\t}"
  },
  "org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean#setBeanClassLoader(classLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "void",
    "signature": "public void setBeanClassLoader(ClassLoader classLoader)",
    "source_code": "\tpublic void setBeanClassLoader(ClassLoader classLoader) {\n\t\tthis.beanClassLoader = classLoader;\n\t}"
  },
  "org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "void",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t}"
  },
  "org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean#setBeanName(beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "void",
    "signature": "public void setBeanName(String beanName)",
    "source_code": "\tpublic void setBeanName(String beanName) {\n\t\tthis.beanName = beanName;\n\t}"
  },
  "org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean#setConcurrent(concurrent)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether multiple jobs should be run in a concurrent fashion.\n\t * The behavior when one does not want concurrent jobs to be executed is\n\t * realized through adding the {@code @PersistJobDataAfterExecution} and\n\t * {@code @DisallowConcurrentExecution} markers.\n\t * More information on stateful versus stateless jobs can be found\n\t * <a href=\"https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/tutorial-lesson-03.html\">here</a>.\n\t * <p>The default setting is to run jobs concurrently.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "concurrent"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "void",
    "signature": "public void setConcurrent(boolean concurrent)",
    "source_code": "\tpublic void setConcurrent(boolean concurrent) {\n\t\tthis.concurrent = concurrent;\n\t}"
  },
  "org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean#setGroup(group)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the group of the job.\n\t * <p>Default is the default group of the Scheduler.\n\t * @see org.quartz.Scheduler#DEFAULT_GROUP\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "group"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "void",
    "signature": "public void setGroup(String group)",
    "source_code": "\tpublic void setGroup(String group) {\n\t\tthis.group = group;\n\t}"
  },
  "org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean#setMethodInvoker(methodInvoker)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Set the MethodInvoker to use.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodInvoker"
    ],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "void",
    "signature": "public void setMethodInvoker(MethodInvoker methodInvoker)",
    "source_code": "\t\tpublic void setMethodInvoker(MethodInvoker methodInvoker) {\n\t\t\tthis.methodInvoker = methodInvoker;\n\t\t}"
  },
  "org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean#setName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of the job.\n\t * <p>Default is the bean name of this FactoryBean.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "void",
    "signature": "public void setName(String name)",
    "source_code": "\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}"
  },
  "org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean#setTargetBeanName(targetBeanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of the target bean in the Spring BeanFactory.\n\t * <p>This is an alternative to specifying {@link #setTargetObject \"targetObject\"},\n\t * allowing for non-singleton beans to be invoked. Note that specified\n\t * \"targetObject\" and {@link #setTargetClass \"targetClass\"} values will\n\t * override the corresponding effect of this \"targetBeanName\" setting\n\t * (i.e. statically pre-define the bean type or even the bean object).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetBeanName"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "void",
    "signature": "public void setTargetBeanName(String targetBeanName)",
    "source_code": "\tpublic void setTargetBeanName(String targetBeanName) {\n\t\tthis.targetBeanName = targetBeanName;\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerAccessor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Common base class for accessing a Quartz Scheduler, i.e. for registering jobs,\n * triggers and listeners on a {@link org.quartz.Scheduler} instance.\n *\n * <p>For concrete usage, check out the {@link SchedulerFactoryBean} and\n * {@link SchedulerAccessorBean} classes.\n *\n * <p>Compatible with Quartz 2.1.4 and higher, as of Spring 4.1.\n *\n * @author Juergen Hoeller\n * @author Stephane Nicoll\n * @since 2.5.6\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "signature": "public class SchedulerAccessor",
    "source_code": "public abstract class SchedulerAccessor implements ResourceLoaderAware {\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\tprivate boolean overwriteExistingJobs = false;\n\n\t@Nullable\n\tprivate String[] jobSchedulingDataLocations;\n\n\t@Nullable\n\tprivate List<JobDetail> jobDetails;\n\n\t@Nullable\n\tprivate Map<String, Calendar> calendars;\n\n\t@Nullable\n\tprivate List<Trigger> triggers;\n\n\t@Nullable\n\tprivate SchedulerListener[] schedulerListeners;\n\n\t@Nullable\n\tprivate JobListener[] globalJobListeners;\n\n\t@Nullable\n\tprivate TriggerListener[] globalTriggerListeners;\n\n\t@Nullable\n\tprivate PlatformTransactionManager transactionManager;\n\n\t@Nullable\n\tprotected ResourceLoader resourceLoader;\n\n\n\t/**\n\t * Set whether any jobs defined on this SchedulerFactoryBean should overwrite\n\t * existing job definitions. Default is \"false\", to not overwrite already\n\t * registered jobs that have been read in from a persistent job store.\n\t */\n\tpublic void setOverwriteExistingJobs(boolean overwriteExistingJobs) {\n\t\tthis.overwriteExistingJobs = overwriteExistingJobs;\n\t}\n\n\t/**\n\t * Set the location of a Quartz job definition XML file that follows the\n\t * \"job_scheduling_data_1_5\" XSD or better. Can be specified to automatically\n\t * register jobs that are defined in such a file, possibly in addition\n\t * to jobs defined directly on this SchedulerFactoryBean.\n\t * @see org.quartz.xml.XMLSchedulingDataProcessor\n\t */\n\tpublic void setJobSchedulingDataLocation(String jobSchedulingDataLocation) {\n\t\tthis.jobSchedulingDataLocations = new String[] {jobSchedulingDataLocation};\n\t}\n\n\t/**\n\t * Set the locations of Quartz job definition XML files that follow the\n\t * \"job_scheduling_data_1_5\" XSD or better. Can be specified to automatically\n\t * register jobs that are defined in such files, possibly in addition\n\t * to jobs defined directly on this SchedulerFactoryBean.\n\t * @see org.quartz.xml.XMLSchedulingDataProcessor\n\t */\n\tpublic void setJobSchedulingDataLocations(String... jobSchedulingDataLocations) {\n\t\tthis.jobSchedulingDataLocations = jobSchedulingDataLocations;\n\t}\n\n\t/**\n\t * Register a list of JobDetail objects with the Scheduler that\n\t * this FactoryBean creates, to be referenced by Triggers.\n\t * <p>This is not necessary when a Trigger determines the JobDetail\n\t * itself: In this case, the JobDetail will be implicitly registered\n\t * in combination with the Trigger.\n\t * @see #setTriggers\n\t * @see org.quartz.JobDetail\n\t */\n\tpublic void setJobDetails(JobDetail... jobDetails) {\n\t\t// Use modifiable ArrayList here, to allow for further adding of\n\t\t// JobDetail objects during autodetection of JobDetail-aware Triggers.\n\t\tthis.jobDetails = new ArrayList<>(Arrays.asList(jobDetails));\n\t}\n\n\t/**\n\t * Register a list of Quartz Calendar objects with the Scheduler\n\t * that this FactoryBean creates, to be referenced by Triggers.\n\t * @param calendars a Map with calendar names as keys as Calendar\n\t * objects as values\n\t * @see org.quartz.Calendar\n\t */\n\tpublic void setCalendars(Map<String, Calendar> calendars) {\n\t\tthis.calendars = calendars;\n\t}\n\n\t/**\n\t * Register a list of Trigger objects with the Scheduler that\n\t * this FactoryBean creates.\n\t * <p>If the Trigger determines the corresponding JobDetail itself,\n\t * the job will be automatically registered with the Scheduler.\n\t * Else, the respective JobDetail needs to be registered via the\n\t * \"jobDetails\" property of this FactoryBean.\n\t * @see #setJobDetails\n\t * @see org.quartz.JobDetail\n\t */\n\tpublic void setTriggers(Trigger... triggers) {\n\t\tthis.triggers = Arrays.asList(triggers);\n\t}\n\n\t/**\n\t * Specify Quartz SchedulerListeners to be registered with the Scheduler.\n\t */\n\tpublic void setSchedulerListeners(SchedulerListener... schedulerListeners) {\n\t\tthis.schedulerListeners = schedulerListeners;\n\t}\n\n\t/**\n\t * Specify global Quartz JobListeners to be registered with the Scheduler.\n\t * Such JobListeners will apply to all Jobs in the Scheduler.\n\t */\n\tpublic void setGlobalJobListeners(JobListener... globalJobListeners) {\n\t\tthis.globalJobListeners = globalJobListeners;\n\t}\n\n\t/**\n\t * Specify global Quartz TriggerListeners to be registered with the Scheduler.\n\t * Such TriggerListeners will apply to all Triggers in the Scheduler.\n\t */\n\tpublic void setGlobalTriggerListeners(TriggerListener... globalTriggerListeners) {\n\t\tthis.globalTriggerListeners = globalTriggerListeners;\n\t}\n\n\t/**\n\t * Set the transaction manager to be used for registering jobs and triggers\n\t * that are defined by this SchedulerFactoryBean. Default is none; setting\n\t * this only makes sense when specifying a DataSource for the Scheduler.\n\t */\n\tpublic void setTransactionManager(PlatformTransactionManager transactionManager) {\n\t\tthis.transactionManager = transactionManager;\n\t}\n\n\t@Override\n\tpublic void setResourceLoader(ResourceLoader resourceLoader) {\n\t\tthis.resourceLoader = resourceLoader;\n\t}\n\n\n\t/**\n\t * Register jobs and triggers (within a transaction, if possible).\n\t */\n\tprotected void registerJobsAndTriggers() throws SchedulerException {\n\t\tTransactionStatus transactionStatus = null;\n\t\tif (this.transactionManager != null) {\n\t\t\ttransactionStatus = this.transactionManager.getTransaction(TransactionDefinition.withDefaults());\n\t\t}\n\n\t\ttry {\n\t\t\tif (this.jobSchedulingDataLocations != null) {\n\t\t\t\tClassLoadHelper clh = new ResourceLoaderClassLoadHelper(this.resourceLoader);\n\t\t\t\tclh.initialize();\n\t\t\t\tXMLSchedulingDataProcessor dataProcessor = new XMLSchedulingDataProcessor(clh);\n\t\t\t\tfor (String location : this.jobSchedulingDataLocations) {\n\t\t\t\t\tdataProcessor.processFileAndScheduleJobs(location, getScheduler());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Register JobDetails.\n\t\t\tif (this.jobDetails != null) {\n\t\t\t\tfor (JobDetail jobDetail : this.jobDetails) {\n\t\t\t\t\taddJobToScheduler(jobDetail);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Create empty list for easier checks when registering triggers.\n\t\t\t\tthis.jobDetails = new ArrayList<>();\n\t\t\t}\n\n\t\t\t// Register Calendars.\n\t\t\tif (this.calendars != null) {\n\t\t\t\tfor (String calendarName : this.calendars.keySet()) {\n\t\t\t\t\tCalendar calendar = this.calendars.get(calendarName);\n\t\t\t\t\tgetScheduler().addCalendar(calendarName, calendar, true, true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Register Triggers.\n\t\t\tif (this.triggers != null) {\n\t\t\t\tfor (Trigger trigger : this.triggers) {\n\t\t\t\t\taddTriggerToScheduler(trigger);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcatch (Throwable ex) {\n\t\t\tif (transactionStatus != null) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.transactionManager.rollback(transactionStatus);\n\t\t\t\t}\n\t\t\t\tcatch (TransactionException tex) {\n\t\t\t\t\tlogger.error(\"Job registration exception overridden by rollback exception\", ex);\n\t\t\t\t\tthrow tex;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ex instanceof SchedulerException schedulerException) {\n\t\t\t\tthrow schedulerException;\n\t\t\t}\n\t\t\tif (ex instanceof Exception) {\n\t\t\t\tthrow new SchedulerException(\"Registration of jobs and triggers failed: \" + ex.getMessage(), ex);\n\t\t\t}\n\t\t\tthrow new SchedulerException(\"Registration of jobs and triggers failed: \" + ex.getMessage());\n\t\t}\n\n\t\tif (transactionStatus != null) {\n\t\t\tthis.transactionManager.commit(transactionStatus);\n\t\t}\n\t}\n\n\t/**\n\t * Add the given job to the Scheduler, if it doesn't already exist.\n\t * Overwrites the job in any case if \"overwriteExistingJobs\" is set.\n\t * @param jobDetail the job to add\n\t * @return {@code true} if the job was actually added,\n\t * {@code false} if it already existed before\n\t * @see #setOverwriteExistingJobs\n\t */\n\tprivate boolean addJobToScheduler(JobDetail jobDetail) throws SchedulerException {\n\t\tif (this.overwriteExistingJobs || getScheduler().getJobDetail(jobDetail.getKey()) == null) {\n\t\t\tgetScheduler().addJob(jobDetail, true);\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Add the given trigger to the Scheduler, if it doesn't already exist.\n\t * Overwrites the trigger in any case if \"overwriteExistingJobs\" is set.\n\t * @param trigger the trigger to add\n\t * @return {@code true} if the trigger was actually added,\n\t * {@code false} if it already existed before\n\t * @see #setOverwriteExistingJobs\n\t */\n\tprivate boolean addTriggerToScheduler(Trigger trigger) throws SchedulerException {\n\t\tboolean triggerExists = (getScheduler().getTrigger(trigger.getKey()) != null);\n\t\tif (triggerExists && !this.overwriteExistingJobs) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if the Trigger is aware of an associated JobDetail.\n\t\tJobDetail jobDetail = (JobDetail) trigger.getJobDataMap().remove(\"jobDetail\");\n\t\tif (triggerExists) {\n\t\t\tif (jobDetail != null && this.jobDetails != null &&\n\t\t\t\t\t!this.jobDetails.contains(jobDetail) && addJobToScheduler(jobDetail)) {\n\t\t\t\tthis.jobDetails.add(jobDetail);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tgetScheduler().rescheduleJob(trigger.getKey(), trigger);\n\t\t\t}\n\t\t\tcatch (ObjectAlreadyExistsException ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Unexpectedly encountered existing trigger on rescheduling, assumably due to \" +\n\t\t\t\t\t\t\t\"cluster race condition: \" + ex.getMessage() + \" - can safely be ignored\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tif (jobDetail != null && this.jobDetails != null && !this.jobDetails.contains(jobDetail) &&\n\t\t\t\t\t\t(this.overwriteExistingJobs || getScheduler().getJobDetail(jobDetail.getKey()) == null)) {\n\t\t\t\t\tgetScheduler().scheduleJob(jobDetail, trigger);\n\t\t\t\t\tthis.jobDetails.add(jobDetail);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgetScheduler().scheduleJob(trigger);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (ObjectAlreadyExistsException ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Unexpectedly encountered existing trigger on job scheduling, assumably due to \" +\n\t\t\t\t\t\t\t\"cluster race condition: \" + ex.getMessage() + \" - can safely be ignored\");\n\t\t\t\t}\n\t\t\t\tif (this.overwriteExistingJobs) {\n\t\t\t\t\tgetScheduler().rescheduleJob(trigger.getKey(), trigger);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Register all specified listeners with the Scheduler.\n\t */\n\tprotected void registerListeners() throws SchedulerException {\n\t\tListenerManager listenerManager = getScheduler().getListenerManager();\n\t\tif (this.schedulerListeners != null) {\n\t\t\tfor (SchedulerListener listener : this.schedulerListeners) {\n\t\t\t\tlistenerManager.addSchedulerListener(listener);\n\t\t\t}\n\t\t}\n\t\tif (this.globalJobListeners != null) {\n\t\t\tfor (JobListener listener : this.globalJobListeners) {\n\t\t\t\tlistenerManager.addJobListener(listener);\n\t\t\t}\n\t\t}\n\t\tif (this.globalTriggerListeners != null) {\n\t\t\tfor (TriggerListener listener : this.globalTriggerListeners) {\n\t\t\t\tlistenerManager.addTriggerListener(listener);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Template method that determines the Scheduler to operate on.\n\t * To be implemented by subclasses.\n\t */\n\tprotected abstract Scheduler getScheduler();\n\n}"
  },
  "org.springframework.scheduling.quartz.SchedulerAccessor#getScheduler()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Template method that determines the Scheduler to operate on.\n\t * To be implemented by subclasses.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 373
    },
    "return": "Scheduler",
    "signature": "protected Scheduler getScheduler()",
    "source_code": "\tprotected abstract Scheduler getScheduler();"
  },
  "org.springframework.scheduling.quartz.SchedulerAccessor#registerJobsAndTriggers()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register jobs and triggers (within a transaction, if possible).\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "void",
    "signature": "protected void registerJobsAndTriggers()",
    "source_code": "\tprotected void registerJobsAndTriggers() throws SchedulerException {\n\t\tTransactionStatus transactionStatus = null;\n\t\tif (this.transactionManager != null) {\n\t\t\ttransactionStatus = this.transactionManager.getTransaction(TransactionDefinition.withDefaults());\n\t\t}\n\n\t\ttry {\n\t\t\tif (this.jobSchedulingDataLocations != null) {\n\t\t\t\tClassLoadHelper clh = new ResourceLoaderClassLoadHelper(this.resourceLoader);\n\t\t\t\tclh.initialize();\n\t\t\t\tXMLSchedulingDataProcessor dataProcessor = new XMLSchedulingDataProcessor(clh);\n\t\t\t\tfor (String location : this.jobSchedulingDataLocations) {\n\t\t\t\t\tdataProcessor.processFileAndScheduleJobs(location, getScheduler());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Register JobDetails.\n\t\t\tif (this.jobDetails != null) {\n\t\t\t\tfor (JobDetail jobDetail : this.jobDetails) {\n\t\t\t\t\taddJobToScheduler(jobDetail);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Create empty list for easier checks when registering triggers.\n\t\t\t\tthis.jobDetails = new ArrayList<>();\n\t\t\t}\n\n\t\t\t// Register Calendars.\n\t\t\tif (this.calendars != null) {\n\t\t\t\tfor (String calendarName : this.calendars.keySet()) {\n\t\t\t\t\tCalendar calendar = this.calendars.get(calendarName);\n\t\t\t\t\tgetScheduler().addCalendar(calendarName, calendar, true, true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Register Triggers.\n\t\t\tif (this.triggers != null) {\n\t\t\t\tfor (Trigger trigger : this.triggers) {\n\t\t\t\t\taddTriggerToScheduler(trigger);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcatch (Throwable ex) {\n\t\t\tif (transactionStatus != null) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.transactionManager.rollback(transactionStatus);\n\t\t\t\t}\n\t\t\t\tcatch (TransactionException tex) {\n\t\t\t\t\tlogger.error(\"Job registration exception overridden by rollback exception\", ex);\n\t\t\t\t\tthrow tex;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ex instanceof SchedulerException schedulerException) {\n\t\t\t\tthrow schedulerException;\n\t\t\t}\n\t\t\tif (ex instanceof Exception) {\n\t\t\t\tthrow new SchedulerException(\"Registration of jobs and triggers failed: \" + ex.getMessage(), ex);\n\t\t\t}\n\t\t\tthrow new SchedulerException(\"Registration of jobs and triggers failed: \" + ex.getMessage());\n\t\t}\n\n\t\tif (transactionStatus != null) {\n\t\t\tthis.transactionManager.commit(transactionStatus);\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerAccessor#registerListeners()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register all specified listeners with the Scheduler.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 349
    },
    "return": "void",
    "signature": "protected void registerListeners()",
    "source_code": "\tprotected void registerListeners() throws SchedulerException {\n\t\tListenerManager listenerManager = getScheduler().getListenerManager();\n\t\tif (this.schedulerListeners != null) {\n\t\t\tfor (SchedulerListener listener : this.schedulerListeners) {\n\t\t\t\tlistenerManager.addSchedulerListener(listener);\n\t\t\t}\n\t\t}\n\t\tif (this.globalJobListeners != null) {\n\t\t\tfor (JobListener listener : this.globalJobListeners) {\n\t\t\t\tlistenerManager.addJobListener(listener);\n\t\t\t}\n\t\t}\n\t\tif (this.globalTriggerListeners != null) {\n\t\t\tfor (TriggerListener listener : this.globalTriggerListeners) {\n\t\t\t\tlistenerManager.addTriggerListener(listener);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerAccessor#setCalendars(Map<String,calendars)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a list of Quartz Calendar objects with the Scheduler\n\t * that this FactoryBean creates, to be referenced by Triggers.\n\t * @param calendars a Map with calendar names as keys as Calendar\n\t * objects as values\n\t * @see org.quartz.Calendar\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "calendars"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "void",
    "signature": "public void setCalendars(Map<String, Calendar> calendars)",
    "source_code": "\tpublic void setCalendars(Map<String, Calendar> calendars) {\n\t\tthis.calendars = calendars;\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerAccessor#setGlobalJobListeners(globalJobListeners)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify global Quartz JobListeners to be registered with the Scheduler.\n\t * Such JobListeners will apply to all Jobs in the Scheduler.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "globalJobListeners"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "void",
    "signature": "public void setGlobalJobListeners(JobListener... globalJobListeners)",
    "source_code": "\tpublic void setGlobalJobListeners(JobListener... globalJobListeners) {\n\t\tthis.globalJobListeners = globalJobListeners;\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerAccessor#setGlobalTriggerListeners(globalTriggerListeners)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify global Quartz TriggerListeners to be registered with the Scheduler.\n\t * Such TriggerListeners will apply to all Triggers in the Scheduler.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "globalTriggerListeners"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "void",
    "signature": "public void setGlobalTriggerListeners(TriggerListener... globalTriggerListeners)",
    "source_code": "\tpublic void setGlobalTriggerListeners(TriggerListener... globalTriggerListeners) {\n\t\tthis.globalTriggerListeners = globalTriggerListeners;\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerAccessor#setJobDetails(jobDetails)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a list of JobDetail objects with the Scheduler that\n\t * this FactoryBean creates, to be referenced by Triggers.\n\t * <p>This is not necessary when a Trigger determines the JobDetail\n\t * itself: In this case, the JobDetail will be implicitly registered\n\t * in combination with the Trigger.\n\t * @see #setTriggers\n\t * @see org.quartz.JobDetail\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "jobDetails"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "void",
    "signature": "public void setJobDetails(JobDetail... jobDetails)",
    "source_code": "\tpublic void setJobDetails(JobDetail... jobDetails) {\n\t\t// Use modifiable ArrayList here, to allow for further adding of\n\t\t// JobDetail objects during autodetection of JobDetail-aware Triggers.\n\t\tthis.jobDetails = new ArrayList<>(Arrays.asList(jobDetails));\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerAccessor#setJobSchedulingDataLocation(jobSchedulingDataLocation)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the location of a Quartz job definition XML file that follows the\n\t * \"job_scheduling_data_1_5\" XSD or better. Can be specified to automatically\n\t * register jobs that are defined in such a file, possibly in addition\n\t * to jobs defined directly on this SchedulerFactoryBean.\n\t * @see org.quartz.xml.XMLSchedulingDataProcessor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "jobSchedulingDataLocation"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "void",
    "signature": "public void setJobSchedulingDataLocation(String jobSchedulingDataLocation)",
    "source_code": "\tpublic void setJobSchedulingDataLocation(String jobSchedulingDataLocation) {\n\t\tthis.jobSchedulingDataLocations = new String[] {jobSchedulingDataLocation};\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerAccessor#setJobSchedulingDataLocations(jobSchedulingDataLocations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the locations of Quartz job definition XML files that follow the\n\t * \"job_scheduling_data_1_5\" XSD or better. Can be specified to automatically\n\t * register jobs that are defined in such files, possibly in addition\n\t * to jobs defined directly on this SchedulerFactoryBean.\n\t * @see org.quartz.xml.XMLSchedulingDataProcessor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "jobSchedulingDataLocations"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "void",
    "signature": "public void setJobSchedulingDataLocations(String... jobSchedulingDataLocations)",
    "source_code": "\tpublic void setJobSchedulingDataLocations(String... jobSchedulingDataLocations) {\n\t\tthis.jobSchedulingDataLocations = jobSchedulingDataLocations;\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerAccessor#setOverwriteExistingJobs(overwriteExistingJobs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether any jobs defined on this SchedulerFactoryBean should overwrite\n\t * existing job definitions. Default is \"false\", to not overwrite already\n\t * registered jobs that have been read in from a persistent job store.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "overwriteExistingJobs"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "void",
    "signature": "public void setOverwriteExistingJobs(boolean overwriteExistingJobs)",
    "source_code": "\tpublic void setOverwriteExistingJobs(boolean overwriteExistingJobs) {\n\t\tthis.overwriteExistingJobs = overwriteExistingJobs;\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerAccessor#setResourceLoader(resourceLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resourceLoader"
    ],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "void",
    "signature": "public void setResourceLoader(ResourceLoader resourceLoader)",
    "source_code": "\tpublic void setResourceLoader(ResourceLoader resourceLoader) {\n\t\tthis.resourceLoader = resourceLoader;\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerAccessor#setSchedulerListeners(schedulerListeners)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify Quartz SchedulerListeners to be registered with the Scheduler.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "schedulerListeners"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "void",
    "signature": "public void setSchedulerListeners(SchedulerListener... schedulerListeners)",
    "source_code": "\tpublic void setSchedulerListeners(SchedulerListener... schedulerListeners) {\n\t\tthis.schedulerListeners = schedulerListeners;\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerAccessor#setTransactionManager(transactionManager)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the transaction manager to be used for registering jobs and triggers\n\t * that are defined by this SchedulerFactoryBean. Default is none; setting\n\t * this only makes sense when specifying a DataSource for the Scheduler.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "transactionManager"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "void",
    "signature": "public void setTransactionManager(PlatformTransactionManager transactionManager)",
    "source_code": "\tpublic void setTransactionManager(PlatformTransactionManager transactionManager) {\n\t\tthis.transactionManager = transactionManager;\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerAccessor#setTriggers(triggers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a list of Trigger objects with the Scheduler that\n\t * this FactoryBean creates.\n\t * <p>If the Trigger determines the corresponding JobDetail itself,\n\t * the job will be automatically registered with the Scheduler.\n\t * Else, the respective JobDetail needs to be registered via the\n\t * \"jobDetails\" property of this FactoryBean.\n\t * @see #setJobDetails\n\t * @see org.quartz.JobDetail\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "triggers"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "void",
    "signature": "public void setTriggers(Trigger... triggers)",
    "source_code": "\tpublic void setTriggers(Trigger... triggers) {\n\t\tthis.triggers = Arrays.asList(triggers);\n\t}"
  },
  "org.springframework.scheduling.quartz.StatefulMethodInvokingJob": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extension of the MethodInvokingJob, implementing the StatefulJob interface.\n\t * Quartz checks whether jobs are stateful and if so,\n\t * won't let jobs interfere with each other.\n\t */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 294
    },
    "signature": "public class StatefulMethodInvokingJob",
    "source_code": "\tpublic static class StatefulMethodInvokingJob extends MethodInvokingJob {\n\n\t\t// No implementation, just an addition of the tag interface StatefulJob\n\t\t// in order to allow stateful method invoking jobs.\n\t}"
  },
  "org.springframework.scheduling.quartz.logger": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 248
    },
    "signature": "protected Log logger",
    "source_code": "\t\tprotected static final Log logger = LogFactory.getLog(MethodInvokingJob.class);",
    "type": "Log"
  },
  "org.springframework.scheduling.quartz.resourceLoader": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "signature": "protected ResourceLoader resourceLoader",
    "source_code": "\tprotected ResourceLoader resourceLoader;",
    "type": "ResourceLoader"
  },
  "org.springframework.scheduling.support.CronTrigger": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link Trigger} implementation for cron expressions.\n * Wraps a {@link CronExpression}.\n *\n * @author Juergen Hoeller\n * @author Arjen Poutsma\n * @since 3.0\n * @see CronExpression\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "signature": "public class CronTrigger",
    "source_code": "public class CronTrigger implements Trigger {\n\n\tprivate final CronExpression expression;\n\n\tprivate final ZoneId zoneId;\n\n\n\t/**\n\t * Build a {@code CronTrigger} from the pattern provided in the default time zone.\n\t * @param expression a space-separated list of time fields, following cron\n\t * expression conventions\n\t */\n\tpublic CronTrigger(String expression) {\n\t\tthis(expression, ZoneId.systemDefault());\n\t}\n\n\t/**\n\t * Build a {@code CronTrigger} from the pattern provided in the given time zone.\n\t * @param expression a space-separated list of time fields, following cron\n\t * expression conventions\n\t * @param timeZone a time zone in which the trigger times will be generated\n\t */\n\tpublic CronTrigger(String expression, TimeZone timeZone) {\n\t\tthis(expression, timeZone.toZoneId());\n\t}\n\n\t/**\n\t * Build a {@code CronTrigger} from the pattern provided in the given time zone.\n\t * @param expression a space-separated list of time fields, following cron\n\t * expression conventions\n\t * @param zoneId a time zone in which the trigger times will be generated\n\t * @since 5.3\n\t * @see CronExpression#parse(String)\n\t */\n\tpublic CronTrigger(String expression, ZoneId zoneId) {\n\t\tAssert.hasLength(expression, \"Expression must not be empty\");\n\t\tAssert.notNull(zoneId, \"ZoneId must not be null\");\n\n\t\tthis.expression = CronExpression.parse(expression);\n\t\tthis.zoneId = zoneId;\n\t}\n\n\n\t/**\n\t * Return the cron pattern that this trigger has been built with.\n\t */\n\tpublic String getExpression() {\n\t\treturn this.expression.toString();\n\t}\n\n\n\t/**\n\t * Determine the next execution time according to the given trigger context.\n\t * <p>Next execution times are calculated based on the\n\t * {@linkplain TriggerContext#lastCompletionTime completion time} of the\n\t * previous execution; therefore, overlapping executions won't occur.\n\t */\n\t@Override\n\tpublic Instant nextExecution(TriggerContext triggerContext) {\n\t\tInstant instant = triggerContext.lastCompletion();\n\t\tif (instant != null) {\n\t\t\tInstant scheduled = triggerContext.lastScheduledExecution();\n\t\t\tif (scheduled != null && instant.isBefore(scheduled)) {\n\t\t\t\t// Previous task apparently executed too early...\n\t\t\t\t// Let's simply use the last calculated execution time then,\n\t\t\t\t// in order to prevent accidental re-fires in the same second.\n\t\t\t\tinstant = scheduled;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tinstant = triggerContext.getClock().instant();\n\t\t}\n\t\tZonedDateTime dateTime = ZonedDateTime.ofInstant(instant, this.zoneId);\n\t\tZonedDateTime next = this.expression.next(dateTime);\n\t\treturn (next != null ? next.toInstant() : null);\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof CronTrigger that && this.expression.equals(that.expression)));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.expression.hashCode();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn this.expression.toString();\n\t}\n\n}"
  },
  "org.springframework.scheduling.support.CronTrigger#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof CronTrigger that && this.expression.equals(that.expression)));\n\t}"
  },
  "org.springframework.scheduling.support.CronTrigger#getExpression()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the cron pattern that this trigger has been built with.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "String",
    "signature": "public String getExpression()",
    "source_code": "\tpublic String getExpression() {\n\t\treturn this.expression.toString();\n\t}"
  },
  "org.springframework.scheduling.support.CronTrigger#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.expression.hashCode();\n\t}"
  },
  "org.springframework.scheduling.support.CronTrigger#nextExecution(triggerContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the next execution time according to the given trigger context.\n\t * <p>Next execution times are calculated based on the\n\t * {@linkplain TriggerContext#lastCompletionTime completion time} of the\n\t * previous execution; therefore, overlapping executions won't occur.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "triggerContext"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "Instant",
    "signature": "public Instant nextExecution(TriggerContext triggerContext)",
    "source_code": "\tpublic Instant nextExecution(TriggerContext triggerContext) {\n\t\tInstant instant = triggerContext.lastCompletion();\n\t\tif (instant != null) {\n\t\t\tInstant scheduled = triggerContext.lastScheduledExecution();\n\t\t\tif (scheduled != null && instant.isBefore(scheduled)) {\n\t\t\t\t// Previous task apparently executed too early...\n\t\t\t\t// Let's simply use the last calculated execution time then,\n\t\t\t\t// in order to prevent accidental re-fires in the same second.\n\t\t\t\tinstant = scheduled;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tinstant = triggerContext.getClock().instant();\n\t\t}\n\t\tZonedDateTime dateTime = ZonedDateTime.ofInstant(instant, this.zoneId);\n\t\tZonedDateTime next = this.expression.next(dateTime);\n\t\treturn (next != null ? next.toInstant() : null);\n\t}"
  },
  "org.springframework.scheduling.support.CronTrigger#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn this.expression.toString();\n\t}"
  },
  "org.springframework.scheduling.support.LOG_AND_PROPAGATE_ERROR_HANDLER": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An ErrorHandler strategy that will log at error level and then\n\t * re-throw the Exception. Note: this will typically prevent subsequent\n\t * execution of a scheduled task.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "signature": "public ErrorHandler LOG_AND_PROPAGATE_ERROR_HANDLER",
    "source_code": "\tpublic static final ErrorHandler LOG_AND_PROPAGATE_ERROR_HANDLER = new PropagatingErrorHandler();",
    "type": "ErrorHandler"
  },
  "org.springframework.scheduling.support.LOG_AND_SUPPRESS_ERROR_HANDLER": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An ErrorHandler strategy that will log the Exception but perform\n\t * no further handling. This will suppress the error so that\n\t * subsequent executions of the task will not be prevented.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "signature": "public ErrorHandler LOG_AND_SUPPRESS_ERROR_HANDLER",
    "source_code": "\tpublic static final ErrorHandler LOG_AND_SUPPRESS_ERROR_HANDLER = new LoggingErrorHandler();",
    "type": "ErrorHandler"
  },
  "org.springframework.scheduling.support.TaskUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Utility methods for decorating tasks with error handling.\n *\n * <p><b>NOTE:</b> This class is intended for internal use by Spring's scheduler\n * implementations. It is only public so that it may be accessed from impl classes\n * within other packages. It is <i>not</i> intended for general use.\n *\n * @author Mark Fisher\n * @author Juergen Hoeller\n * @since 3.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class TaskUtils",
    "source_code": "public abstract class TaskUtils {\n\n\t/**\n\t * An ErrorHandler strategy that will log the Exception but perform\n\t * no further handling. This will suppress the error so that\n\t * subsequent executions of the task will not be prevented.\n\t */\n\tpublic static final ErrorHandler LOG_AND_SUPPRESS_ERROR_HANDLER = new LoggingErrorHandler();\n\n\t/**\n\t * An ErrorHandler strategy that will log at error level and then\n\t * re-throw the Exception. Note: this will typically prevent subsequent\n\t * execution of a scheduled task.\n\t */\n\tpublic static final ErrorHandler LOG_AND_PROPAGATE_ERROR_HANDLER = new PropagatingErrorHandler();\n\n\n\t/**\n\t * Decorate the task for error handling. If the provided {@link ErrorHandler}\n\t * is not {@code null}, it will be used. Otherwise, repeating tasks will have\n\t * errors suppressed by default whereas one-shot tasks will have errors\n\t * propagated by default since those errors may be expected through the\n\t * returned {@link Future}. In both cases, the errors will be logged.\n\t */\n\tpublic static DelegatingErrorHandlingRunnable decorateTaskWithErrorHandler(\n\t\t\tRunnable task, @Nullable ErrorHandler errorHandler, boolean isRepeatingTask) {\n\n\t\tif (task instanceof DelegatingErrorHandlingRunnable dehRunnable) {\n\t\t\treturn dehRunnable;\n\t\t}\n\t\tErrorHandler eh = (errorHandler != null ? errorHandler : getDefaultErrorHandler(isRepeatingTask));\n\t\treturn new DelegatingErrorHandlingRunnable(task, eh);\n\t}\n\n\t/**\n\t * Return the default {@link ErrorHandler} implementation based on the boolean\n\t * value indicating whether the task will be repeating or not. For repeating tasks\n\t * it will suppress errors, but for one-time tasks it will propagate. In both\n\t * cases, the error will be logged.\n\t */\n\tpublic static ErrorHandler getDefaultErrorHandler(boolean isRepeatingTask) {\n\t\treturn (isRepeatingTask ? LOG_AND_SUPPRESS_ERROR_HANDLER : LOG_AND_PROPAGATE_ERROR_HANDLER);\n\t}\n\n\n\t/**\n\t * An {@link ErrorHandler} implementation that logs the Throwable at error\n \t * level. It does not perform any additional error handling. This can be\n \t * useful when suppression of errors is the intended behavior.\n\t */\n\tprivate static class LoggingErrorHandler implements ErrorHandler {\n\n\t\tprivate final Log logger = LogFactory.getLog(LoggingErrorHandler.class);\n\n\t\t@Override\n\t\tpublic void handleError(Throwable t) {\n\t\t\tlogger.error(\"Unexpected error occurred in scheduled task\", t);\n\t\t}\n\t}\n\n\n\t/**\n\t * An {@link ErrorHandler} implementation that logs the Throwable at error\n\t * level and then propagates it.\n\t */\n\tprivate static class PropagatingErrorHandler extends LoggingErrorHandler {\n\n\t\t@Override\n\t\tpublic void handleError(Throwable t) {\n\t\t\tsuper.handleError(t);\n\t\t\tReflectionUtils.rethrowRuntimeException(t);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.scheduling.support.TaskUtils#decorateTaskWithErrorHandler(task,errorHandler,isRepeatingTask)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Decorate the task for error handling. If the provided {@link ErrorHandler}\n\t * is not {@code null}, it will be used. Otherwise, repeating tasks will have\n\t * errors suppressed by default whereas one-shot tasks will have errors\n\t * propagated by default since those errors may be expected through the\n\t * returned {@link Future}. In both cases, the errors will be logged.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "errorHandler",
      "isRepeatingTask"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "DelegatingErrorHandlingRunnable",
    "signature": "public DelegatingErrorHandlingRunnable decorateTaskWithErrorHandler(Runnable task, @Nullable ErrorHandler errorHandler, boolean isRepeatingTask)",
    "source_code": "\tpublic static DelegatingErrorHandlingRunnable decorateTaskWithErrorHandler("
  },
  "org.springframework.scheduling.support.TaskUtils#getDefaultErrorHandler(isRepeatingTask)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the default {@link ErrorHandler} implementation based on the boolean\n\t * value indicating whether the task will be repeating or not. For repeating tasks\n\t * it will suppress errors, but for one-time tasks it will propagate. In both\n\t * cases, the error will be logged.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "isRepeatingTask"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "ErrorHandler",
    "signature": "public ErrorHandler getDefaultErrorHandler(boolean isRepeatingTask)",
    "source_code": "\tpublic static ErrorHandler getDefaultErrorHandler(boolean isRepeatingTask) {\n\t\treturn (isRepeatingTask ? LOG_AND_SUPPRESS_ERROR_HANDLER : LOG_AND_PROPAGATE_ERROR_HANDLER);\n\t}"
  },
  "org.springframework.scheduling.support.TaskUtils#handleError(t)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "t"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "void",
    "signature": "public void handleError(Throwable t)",
    "source_code": "\t\tpublic void handleError(Throwable t) {\n\t\t\tsuper.handleError(t);\n\t\t\tReflectionUtils.rethrowRuntimeException(t);\n\t\t}"
  },
  "org.springframework.scripting.bsh.BshScriptFactory": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link org.springframework.scripting.ScriptFactory} implementation\n * for a BeanShell script.\n *\n * <p>Typically used in combination with a\n * {@link org.springframework.scripting.support.ScriptFactoryPostProcessor};\n * see the latter's javadoc for a configuration example.\n *\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @since 2.0\n * @see BshScriptUtils\n * @see org.springframework.scripting.support.ScriptFactoryPostProcessor\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "signature": "public class BshScriptFactory",
    "source_code": "public class BshScriptFactory implements ScriptFactory, BeanClassLoaderAware {\n\n\tprivate final String scriptSourceLocator;\n\n\t@Nullable\n\tprivate final Class<?>[] scriptInterfaces;\n\n\t@Nullable\n\tprivate ClassLoader beanClassLoader = ClassUtils.getDefaultClassLoader();\n\n\t@Nullable\n\tprivate Class<?> scriptClass;\n\n\tprivate final Object scriptClassMonitor = new Object();\n\n\tprivate boolean wasModifiedForTypeCheck = false;\n\n\n\t/**\n\t * Create a new BshScriptFactory for the given script source.\n\t * <p>With this {@code BshScriptFactory} variant, the script needs to\n\t * declare a full class or return an actual instance of the scripted object.\n\t * @param scriptSourceLocator a locator that points to the source of the script.\n\t * Interpreted by the post-processor that actually creates the script.\n\t */\n\tpublic BshScriptFactory(String scriptSourceLocator) {\n\t\tAssert.hasText(scriptSourceLocator, \"'scriptSourceLocator' must not be empty\");\n\t\tthis.scriptSourceLocator = scriptSourceLocator;\n\t\tthis.scriptInterfaces = null;\n\t}\n\n\t/**\n\t * Create a new BshScriptFactory for the given script source.\n\t * <p>The script may either be a simple script that needs a corresponding proxy\n\t * generated (implementing the specified interfaces), or declare a full class\n\t * or return an actual instance of the scripted object (in which case the\n\t * specified interfaces, if any, need to be implemented by that class/instance).\n\t * @param scriptSourceLocator a locator that points to the source of the script.\n\t * Interpreted by the post-processor that actually creates the script.\n\t * @param scriptInterfaces the Java interfaces that the scripted object\n\t * is supposed to implement (may be {@code null})\n\t */\n\tpublic BshScriptFactory(String scriptSourceLocator, @Nullable Class<?>... scriptInterfaces) {\n\t\tAssert.hasText(scriptSourceLocator, \"'scriptSourceLocator' must not be empty\");\n\t\tthis.scriptSourceLocator = scriptSourceLocator;\n\t\tthis.scriptInterfaces = scriptInterfaces;\n\t}\n\n\n\t@Override\n\tpublic void setBeanClassLoader(ClassLoader classLoader) {\n\t\tthis.beanClassLoader = classLoader;\n\t}\n\n\n\t@Override\n\tpublic String getScriptSourceLocator() {\n\t\treturn this.scriptSourceLocator;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Class<?>[] getScriptInterfaces() {\n\t\treturn this.scriptInterfaces;\n\t}\n\n\t/**\n\t * BeanShell scripts do require a config interface.\n\t */\n\t@Override\n\tpublic boolean requiresConfigInterface() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Load and parse the BeanShell script via {@link BshScriptUtils}.\n\t * @see BshScriptUtils#createBshObject(String, Class[], ClassLoader)\n\t */\n\t@Override\n\t@Nullable\n\tpublic Object getScriptedObject(ScriptSource scriptSource, @Nullable Class<?>... actualInterfaces)\n\t\t\tthrows IOException, ScriptCompilationException {\n\n\t\tClass<?> clazz;\n\n\t\ttry {\n\t\t\tsynchronized (this.scriptClassMonitor) {\n\t\t\t\tboolean requiresScriptEvaluation = (this.wasModifiedForTypeCheck && this.scriptClass == null);\n\t\t\t\tthis.wasModifiedForTypeCheck = false;\n\n\t\t\t\tif (scriptSource.isModified() || requiresScriptEvaluation) {\n\t\t\t\t\t// New script content: Let's check whether it evaluates to a Class.\n\t\t\t\t\tObject result = BshScriptUtils.evaluateBshScript(\n\t\t\t\t\t\t\tscriptSource.getScriptAsString(), actualInterfaces, this.beanClassLoader);\n\t\t\t\t\tif (result instanceof Class<?> type) {\n\t\t\t\t\t\t// A Class: We'll cache the Class here and create an instance\n\t\t\t\t\t\t// outside the synchronized block.\n\t\t\t\t\t\tthis.scriptClass = type;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Not a Class: OK, we'll simply create BeanShell objects\n\t\t\t\t\t\t// through evaluating the script for every call later on.\n\t\t\t\t\t\t// For this first-time check, let's simply return the\n\t\t\t\t\t\t// already evaluated object.\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tclazz = this.scriptClass;\n\t\t\t}\n\t\t}\n\t\tcatch (EvalError ex) {\n\t\t\tthis.scriptClass = null;\n\t\t\tthrow new ScriptCompilationException(scriptSource, ex);\n\t\t}\n\n\t\tif (clazz != null) {\n\t\t\t// A Class: We need to create an instance for every call.\n\t\t\ttry {\n\t\t\t\treturn ReflectionUtils.accessibleConstructor(clazz).newInstance();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\t\tscriptSource, \"Could not instantiate script class: \" + clazz.getName(), ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Not a Class: We need to evaluate the script for every call.\n\t\t\ttry {\n\t\t\t\treturn BshScriptUtils.createBshObject(\n\t\t\t\t\t\tscriptSource.getScriptAsString(), actualInterfaces, this.beanClassLoader);\n\t\t\t}\n\t\t\tcatch (EvalError ex) {\n\t\t\t\tthrow new ScriptCompilationException(scriptSource, ex);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Class<?> getScriptedObjectType(ScriptSource scriptSource)\n\t\t\tthrows IOException, ScriptCompilationException {\n\n\t\tsynchronized (this.scriptClassMonitor) {\n\t\t\ttry {\n\t\t\t\tif (scriptSource.isModified()) {\n\t\t\t\t\t// New script content: Let's check whether it evaluates to a Class.\n\t\t\t\t\tthis.wasModifiedForTypeCheck = true;\n\t\t\t\t\tthis.scriptClass = BshScriptUtils.determineBshObjectType(\n\t\t\t\t\t\t\tscriptSource.getScriptAsString(), this.beanClassLoader);\n\t\t\t\t}\n\t\t\t\treturn this.scriptClass;\n\t\t\t}\n\t\t\tcatch (EvalError ex) {\n\t\t\t\tthis.scriptClass = null;\n\t\t\t\tthrow new ScriptCompilationException(scriptSource, ex);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean requiresScriptedObjectRefresh(ScriptSource scriptSource) {\n\t\tsynchronized (this.scriptClassMonitor) {\n\t\t\treturn (scriptSource.isModified() || this.wasModifiedForTypeCheck);\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"BshScriptFactory: script source locator [\" + this.scriptSourceLocator + \"]\";\n\t}\n\n}"
  },
  "org.springframework.scripting.bsh.BshScriptFactory#getScriptSourceLocator()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "String",
    "signature": "public String getScriptSourceLocator()",
    "source_code": "\tpublic String getScriptSourceLocator() {\n\t\treturn this.scriptSourceLocator;\n\t}"
  },
  "org.springframework.scripting.bsh.BshScriptFactory#getScriptedObject(scriptSource,actualInterfaces)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Load and parse the BeanShell script via {@link BshScriptUtils}.\n\t * @see BshScriptUtils#createBshObject(String, Class[], ClassLoader)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scriptSource",
      "actualInterfaces"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "Object",
    "signature": "public Object getScriptedObject(ScriptSource scriptSource, @Nullable Class<?>... actualInterfaces)",
    "source_code": "\tpublic Object getScriptedObject(ScriptSource scriptSource, @Nullable Class<?>... actualInterfaces)"
  },
  "org.springframework.scripting.bsh.BshScriptFactory#requiresConfigInterface()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * BeanShell scripts do require a config interface.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "boolean",
    "signature": "public boolean requiresConfigInterface()",
    "source_code": "\tpublic boolean requiresConfigInterface() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.scripting.bsh.BshScriptFactory#requiresScriptedObjectRefresh(scriptSource)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scriptSource"
    ],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "boolean",
    "signature": "public boolean requiresScriptedObjectRefresh(ScriptSource scriptSource)",
    "source_code": "\tpublic boolean requiresScriptedObjectRefresh(ScriptSource scriptSource) {\n\t\tsynchronized (this.scriptClassMonitor) {\n\t\t\treturn (scriptSource.isModified() || this.wasModifiedForTypeCheck);\n\t\t}\n\t}"
  },
  "org.springframework.scripting.bsh.BshScriptFactory#setBeanClassLoader(classLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "public void setBeanClassLoader(ClassLoader classLoader)",
    "source_code": "\tpublic void setBeanClassLoader(ClassLoader classLoader) {\n\t\tthis.beanClassLoader = classLoader;\n\t}"
  },
  "org.springframework.scripting.bsh.BshScriptFactory#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn \"BshScriptFactory: script source locator [\" + this.scriptSourceLocator + \"]\";\n\t}"
  },
  "org.springframework.scripting.groovy.GroovyScriptEvaluator": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Groovy-based implementation of Spring's {@link ScriptEvaluator} strategy interface.\n *\n * @author Juergen Hoeller\n * @since 4.0\n * @see GroovyShell#evaluate(String, String)\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public class GroovyScriptEvaluator",
    "source_code": "public class GroovyScriptEvaluator implements ScriptEvaluator, BeanClassLoaderAware {\n\n\t@Nullable\n\tprivate ClassLoader classLoader;\n\n\tprivate CompilerConfiguration compilerConfiguration = new CompilerConfiguration();\n\n\n\t/**\n\t * Construct a new GroovyScriptEvaluator.\n\t */\n\tpublic GroovyScriptEvaluator() {\n\t}\n\n\t/**\n\t * Construct a new GroovyScriptEvaluator.\n\t * @param classLoader the ClassLoader to use as a parent for the {@link GroovyShell}\n\t */\n\tpublic GroovyScriptEvaluator(@Nullable ClassLoader classLoader) {\n\t\tthis.classLoader = classLoader;\n\t}\n\n\n\t/**\n\t * Set a custom compiler configuration for this evaluator.\n\t * @since 4.3.3\n\t * @see #setCompilationCustomizers\n\t */\n\tpublic void setCompilerConfiguration(@Nullable CompilerConfiguration compilerConfiguration) {\n\t\tthis.compilerConfiguration =\n\t\t\t\t(compilerConfiguration != null ? compilerConfiguration : new CompilerConfiguration());\n\t}\n\n\t/**\n\t * Return this evaluator's compiler configuration (never {@code null}).\n\t * @since 4.3.3\n\t * @see #setCompilerConfiguration\n\t */\n\tpublic CompilerConfiguration getCompilerConfiguration() {\n\t\treturn this.compilerConfiguration;\n\t}\n\n\t/**\n\t * Set one or more customizers to be applied to this evaluator's compiler configuration.\n\t * <p>Note that this modifies the shared compiler configuration held by this evaluator.\n\t * @since 4.3.3\n\t * @see #setCompilerConfiguration\n\t */\n\tpublic void setCompilationCustomizers(CompilationCustomizer... compilationCustomizers) {\n\t\tthis.compilerConfiguration.addCompilationCustomizers(compilationCustomizers);\n\t}\n\n\t@Override\n\tpublic void setBeanClassLoader(ClassLoader classLoader) {\n\t\tthis.classLoader = classLoader;\n\t}\n\n\n\t@Override\n\t@Nullable\n\tpublic Object evaluate(ScriptSource script) {\n\t\treturn evaluate(script, null);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Object evaluate(ScriptSource script, @Nullable Map<String, Object> arguments) {\n\t\tGroovyShell groovyShell = new GroovyShell(\n\t\t\t\tthis.classLoader, new Binding(arguments), this.compilerConfiguration);\n\t\ttry {\n\t\t\tString filename = (script instanceof ResourceScriptSource resourceScriptSource ?\n\t\t\t\t\tresourceScriptSource.getResource().getFilename() : null);\n\t\t\tif (filename != null) {\n\t\t\t\treturn groovyShell.evaluate(script.getScriptAsString(), filename);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn groovyShell.evaluate(script.getScriptAsString());\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new ScriptCompilationException(script, \"Cannot access Groovy script\", ex);\n\t\t}\n\t\tcatch (GroovyRuntimeException ex) {\n\t\t\tthrow new ScriptCompilationException(script, ex);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.scripting.groovy.GroovyScriptEvaluator#evaluate(script)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "script"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "Object",
    "signature": "public Object evaluate(ScriptSource script)",
    "source_code": "\tpublic Object evaluate(ScriptSource script) {\n\t\treturn evaluate(script, null);\n\t}"
  },
  "org.springframework.scripting.groovy.GroovyScriptEvaluator#evaluate(script,Map<String,arguments)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "script",
      "Map<String",
      "arguments"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "Object",
    "signature": "public Object evaluate(ScriptSource script, @Nullable Map<String, Object> arguments)",
    "source_code": "\tpublic Object evaluate(ScriptSource script, @Nullable Map<String, Object> arguments) {\n\t\tGroovyShell groovyShell = new GroovyShell(\n\t\t\t\tthis.classLoader, new Binding(arguments), this.compilerConfiguration);\n\t\ttry {\n\t\t\tString filename = (script instanceof ResourceScriptSource resourceScriptSource ?\n\t\t\t\t\tresourceScriptSource.getResource().getFilename() : null);\n\t\t\tif (filename != null) {\n\t\t\t\treturn groovyShell.evaluate(script.getScriptAsString(), filename);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn groovyShell.evaluate(script.getScriptAsString());\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new ScriptCompilationException(script, \"Cannot access Groovy script\", ex);\n\t\t}\n\t\tcatch (GroovyRuntimeException ex) {\n\t\t\tthrow new ScriptCompilationException(script, ex);\n\t\t}\n\t}"
  },
  "org.springframework.scripting.groovy.GroovyScriptEvaluator#getCompilerConfiguration()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return this evaluator's compiler configuration (never {@code null}).\n\t * @since 4.3.3\n\t * @see #setCompilerConfiguration\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "CompilerConfiguration",
    "signature": "public CompilerConfiguration getCompilerConfiguration()",
    "source_code": "\tpublic CompilerConfiguration getCompilerConfiguration() {\n\t\treturn this.compilerConfiguration;\n\t}"
  },
  "org.springframework.scripting.groovy.GroovyScriptEvaluator#setBeanClassLoader(classLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "void",
    "signature": "public void setBeanClassLoader(ClassLoader classLoader)",
    "source_code": "\tpublic void setBeanClassLoader(ClassLoader classLoader) {\n\t\tthis.classLoader = classLoader;\n\t}"
  },
  "org.springframework.scripting.groovy.GroovyScriptEvaluator#setCompilationCustomizers(compilationCustomizers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set one or more customizers to be applied to this evaluator's compiler configuration.\n\t * <p>Note that this modifies the shared compiler configuration held by this evaluator.\n\t * @since 4.3.3\n\t * @see #setCompilerConfiguration\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "compilationCustomizers"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "void",
    "signature": "public void setCompilationCustomizers(CompilationCustomizer... compilationCustomizers)",
    "source_code": "\tpublic void setCompilationCustomizers(CompilationCustomizer... compilationCustomizers) {\n\t\tthis.compilerConfiguration.addCompilationCustomizers(compilationCustomizers);\n\t}"
  },
  "org.springframework.scripting.groovy.GroovyScriptEvaluator#setCompilerConfiguration(compilerConfiguration)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a custom compiler configuration for this evaluator.\n\t * @since 4.3.3\n\t * @see #setCompilationCustomizers\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "compilerConfiguration"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "void",
    "signature": "public void setCompilerConfiguration(@Nullable CompilerConfiguration compilerConfiguration)",
    "source_code": "\tpublic void setCompilerConfiguration(@Nullable CompilerConfiguration compilerConfiguration) {\n\t\tthis.compilerConfiguration =\n\t\t\t\t(compilerConfiguration != null ? compilerConfiguration : new CompilerConfiguration());\n\t}"
  },
  "org.springframework.scripting.groovy.GroovyScriptFactory": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link org.springframework.scripting.ScriptFactory} implementation\n * for a Groovy script.\n *\n * <p>Typically used in combination with a\n * {@link org.springframework.scripting.support.ScriptFactoryPostProcessor};\n * see the latter's javadoc for a configuration example.\n *\n * <p>Note: Spring 4.0 supports Groovy 1.8 and higher.\n *\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Rod Johnson\n * @since 2.0\n * @see groovy.lang.GroovyClassLoader\n * @see org.springframework.scripting.support.ScriptFactoryPostProcessor\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "signature": "public class GroovyScriptFactory",
    "source_code": "public class GroovyScriptFactory implements ScriptFactory, BeanFactoryAware, BeanClassLoaderAware {\n\n\tprivate final String scriptSourceLocator;\n\n\t@Nullable\n\tprivate GroovyObjectCustomizer groovyObjectCustomizer;\n\n\t@Nullable\n\tprivate CompilerConfiguration compilerConfiguration;\n\n\t@Nullable\n\tprivate GroovyClassLoader groovyClassLoader;\n\n\t@Nullable\n\tprivate Class<?> scriptClass;\n\n\t@Nullable\n\tprivate Class<?> scriptResultClass;\n\n\t@Nullable\n\tprivate CachedResultHolder cachedResult;\n\n\tprivate final Object scriptClassMonitor = new Object();\n\n\tprivate boolean wasModifiedForTypeCheck = false;\n\n\n\t/**\n\t * Create a new GroovyScriptFactory for the given script source.\n\t * <p>We don't need to specify script interfaces here, since\n\t * a Groovy script defines its Java interfaces itself.\n\t * @param scriptSourceLocator a locator that points to the source of the script.\n\t * Interpreted by the post-processor that actually creates the script.\n\t */\n\tpublic GroovyScriptFactory(String scriptSourceLocator) {\n\t\tAssert.hasText(scriptSourceLocator, \"'scriptSourceLocator' must not be empty\");\n\t\tthis.scriptSourceLocator = scriptSourceLocator;\n\t}\n\n\t/**\n\t * Create a new GroovyScriptFactory for the given script source,\n\t * specifying a strategy interface that can create a custom MetaClass\n\t * to supply missing methods and otherwise change the behavior of the object.\n\t * @param scriptSourceLocator a locator that points to the source of the script.\n\t * Interpreted by the post-processor that actually creates the script.\n\t * @param groovyObjectCustomizer a customizer that can set a custom metaclass\n\t * or make other changes to the GroovyObject created by this factory\n\t * (may be {@code null})\n\t * @see GroovyObjectCustomizer#customize\n\t */\n\tpublic GroovyScriptFactory(String scriptSourceLocator, @Nullable GroovyObjectCustomizer groovyObjectCustomizer) {\n\t\tthis(scriptSourceLocator);\n\t\tthis.groovyObjectCustomizer = groovyObjectCustomizer;\n\t}\n\n\t/**\n\t * Create a new GroovyScriptFactory for the given script source,\n\t * specifying a strategy interface that can create a custom MetaClass\n\t * to supply missing methods and otherwise change the behavior of the object.\n\t * @param scriptSourceLocator a locator that points to the source of the script.\n\t * Interpreted by the post-processor that actually creates the script.\n\t * @param compilerConfiguration a custom compiler configuration to be applied\n\t * to the GroovyClassLoader (may be {@code null})\n\t * @since 4.3.3\n\t * @see GroovyClassLoader#GroovyClassLoader(ClassLoader, CompilerConfiguration)\n\t */\n\tpublic GroovyScriptFactory(String scriptSourceLocator, @Nullable CompilerConfiguration compilerConfiguration) {\n\t\tthis(scriptSourceLocator);\n\t\tthis.compilerConfiguration = compilerConfiguration;\n\t}\n\n\t/**\n\t * Create a new GroovyScriptFactory for the given script source,\n\t * specifying a strategy interface that can customize Groovy's compilation\n\t * process within the underlying GroovyClassLoader.\n\t * @param scriptSourceLocator a locator that points to the source of the script.\n\t * Interpreted by the post-processor that actually creates the script.\n\t * @param compilationCustomizers one or more customizers to be applied to the\n\t * GroovyClassLoader compiler configuration\n\t * @since 4.3.3\n\t * @see CompilerConfiguration#addCompilationCustomizers\n\t * @see org.codehaus.groovy.control.customizers.ImportCustomizer\n\t */\n\tpublic GroovyScriptFactory(String scriptSourceLocator, CompilationCustomizer... compilationCustomizers) {\n\t\tthis(scriptSourceLocator);\n\t\tif (!ObjectUtils.isEmpty(compilationCustomizers)) {\n\t\t\tthis.compilerConfiguration = new CompilerConfiguration();\n\t\t\tthis.compilerConfiguration.addCompilationCustomizers(compilationCustomizers);\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tif (beanFactory instanceof ConfigurableListableBeanFactory clbf) {\n\t\t\tclbf.ignoreDependencyType(MetaClass.class);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setBeanClassLoader(ClassLoader classLoader) {\n\t\tif (classLoader instanceof GroovyClassLoader gcl && (this.compilerConfiguration == null ||\n\t\t\t\tgcl.hasCompatibleConfiguration(this.compilerConfiguration))) {\n\t\t\tthis.groovyClassLoader = gcl;\n\t\t}\n\t\telse {\n\t\t\tthis.groovyClassLoader = buildGroovyClassLoader(classLoader);\n\t\t}\n\t}\n\n\t/**\n\t * Return the GroovyClassLoader used by this script factory.\n\t */\n\tpublic GroovyClassLoader getGroovyClassLoader() {\n\t\tsynchronized (this.scriptClassMonitor) {\n\t\t\tif (this.groovyClassLoader == null) {\n\t\t\t\tthis.groovyClassLoader = buildGroovyClassLoader(ClassUtils.getDefaultClassLoader());\n\t\t\t}\n\t\t\treturn this.groovyClassLoader;\n\t\t}\n\t}\n\n\t/**\n\t * Build a {@link GroovyClassLoader} for the given {@code ClassLoader}.\n\t * @param classLoader the ClassLoader to build a GroovyClassLoader for\n\t * @since 4.3.3\n\t */\n\tprotected GroovyClassLoader buildGroovyClassLoader(@Nullable ClassLoader classLoader) {\n\t\treturn (this.compilerConfiguration != null ?\n\t\t\t\tnew GroovyClassLoader(classLoader, this.compilerConfiguration) : new GroovyClassLoader(classLoader));\n\t}\n\n\n\t@Override\n\tpublic String getScriptSourceLocator() {\n\t\treturn this.scriptSourceLocator;\n\t}\n\n\t/**\n\t * Groovy scripts determine their interfaces themselves,\n\t * hence we don't need to explicitly expose interfaces here.\n\t * @return {@code null} always\n\t */\n\t@Override\n\t@Nullable\n\tpublic Class<?>[] getScriptInterfaces() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Groovy scripts do not need a config interface,\n\t * since they expose their setters as public methods.\n\t */\n\t@Override\n\tpublic boolean requiresConfigInterface() {\n\t\treturn false;\n\t}\n\n\n\t/**\n\t * Loads and parses the Groovy script via the GroovyClassLoader.\n\t * @see groovy.lang.GroovyClassLoader\n\t */\n\t@Override\n\t@Nullable\n\tpublic Object getScriptedObject(ScriptSource scriptSource, @Nullable Class<?>... actualInterfaces)\n\t\t\tthrows IOException, ScriptCompilationException {\n\n\t\tsynchronized (this.scriptClassMonitor) {\n\t\t\ttry {\n\t\t\t\tClass<?> scriptClassToExecute;\n\t\t\t\tthis.wasModifiedForTypeCheck = false;\n\n\t\t\t\tif (this.cachedResult != null) {\n\t\t\t\t\tObject result = this.cachedResult.object;\n\t\t\t\t\tthis.cachedResult = null;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (this.scriptClass == null || scriptSource.isModified()) {\n\t\t\t\t\t// New script content...\n\t\t\t\t\tthis.scriptClass = getGroovyClassLoader().parseClass(\n\t\t\t\t\t\t\tscriptSource.getScriptAsString(), scriptSource.suggestedClassName());\n\n\t\t\t\t\tif (Script.class.isAssignableFrom(this.scriptClass)) {\n\t\t\t\t\t\t// A Groovy script, probably creating an instance: let's execute it.\n\t\t\t\t\t\tObject result = executeScript(scriptSource, this.scriptClass);\n\t\t\t\t\t\tthis.scriptResultClass = (result != null ? result.getClass() : null);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.scriptResultClass = this.scriptClass;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tscriptClassToExecute = this.scriptClass;\n\n\t\t\t\t// Process re-execution outside the synchronized block.\n\t\t\t\treturn executeScript(scriptSource, scriptClassToExecute);\n\t\t\t}\n\t\t\tcatch (CompilationFailedException ex) {\n\t\t\t\tthis.scriptClass = null;\n\t\t\t\tthis.scriptResultClass = null;\n\t\t\t\tthrow new ScriptCompilationException(scriptSource, ex);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Class<?> getScriptedObjectType(ScriptSource scriptSource)\n\t\t\tthrows IOException, ScriptCompilationException {\n\n\t\tsynchronized (this.scriptClassMonitor) {\n\t\t\ttry {\n\t\t\t\tif (this.scriptClass == null || scriptSource.isModified()) {\n\t\t\t\t\t// New script content...\n\t\t\t\t\tthis.wasModifiedForTypeCheck = true;\n\t\t\t\t\tthis.scriptClass = getGroovyClassLoader().parseClass(\n\t\t\t\t\t\t\tscriptSource.getScriptAsString(), scriptSource.suggestedClassName());\n\n\t\t\t\t\tif (Script.class.isAssignableFrom(this.scriptClass)) {\n\t\t\t\t\t\t// A Groovy script, probably creating an instance: let's execute it.\n\t\t\t\t\t\tObject result = executeScript(scriptSource, this.scriptClass);\n\t\t\t\t\t\tthis.scriptResultClass = (result != null ? result.getClass() : null);\n\t\t\t\t\t\tthis.cachedResult = new CachedResultHolder(result);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.scriptResultClass = this.scriptClass;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this.scriptResultClass;\n\t\t\t}\n\t\t\tcatch (CompilationFailedException ex) {\n\t\t\t\tthis.scriptClass = null;\n\t\t\t\tthis.scriptResultClass = null;\n\t\t\t\tthis.cachedResult = null;\n\t\t\t\tthrow new ScriptCompilationException(scriptSource, ex);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean requiresScriptedObjectRefresh(ScriptSource scriptSource) {\n\t\tsynchronized (this.scriptClassMonitor) {\n\t\t\treturn (scriptSource.isModified() || this.wasModifiedForTypeCheck);\n\t\t}\n\t}\n\n\n\t/**\n\t * Instantiate the given Groovy script class and run it if necessary.\n\t * @param scriptSource the source for the underlying script\n\t * @param scriptClass the Groovy script class\n\t * @return the result object (either an instance of the script class\n\t * or the result of running the script instance)\n\t * @throws ScriptCompilationException in case of instantiation failure\n\t */\n\t@Nullable\n\tprotected Object executeScript(ScriptSource scriptSource, Class<?> scriptClass) throws ScriptCompilationException {\n\t\ttry {\n\t\t\tGroovyObject groovyObj = (GroovyObject) ReflectionUtils.accessibleConstructor(scriptClass).newInstance();\n\n\t\t\tif (this.groovyObjectCustomizer != null) {\n\t\t\t\t// Allow metaclass and other customization.\n\t\t\t\tthis.groovyObjectCustomizer.customize(groovyObj);\n\t\t\t}\n\n\t\t\tif (groovyObj instanceof Script script) {\n\t\t\t\t// A Groovy script, probably creating an instance: let's execute it.\n\t\t\t\treturn script.run();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// An instance of the scripted class: let's return it as-is.\n\t\t\t\treturn groovyObj;\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\t\"No default constructor on Groovy script class: \" + scriptClass.getName(), ex);\n\t\t}\n\t\tcatch (InstantiationException ex) {\n\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\tscriptSource, \"Unable to instantiate Groovy script class: \" + scriptClass.getName(), ex);\n\t\t}\n\t\tcatch (IllegalAccessException ex) {\n\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\tscriptSource, \"Could not access Groovy script constructor: \" + scriptClass.getName(), ex);\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\t\"Failed to invoke Groovy script constructor: \" + scriptClass.getName(), ex.getTargetException());\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"GroovyScriptFactory: script source locator [\" + this.scriptSourceLocator + \"]\";\n\t}\n\n\n\t/**\n\t * Wrapper that holds a temporarily cached result object.\n\t */\n\tprivate static class CachedResultHolder {\n\n\t\t@Nullable\n\t\tpublic final Object object;\n\n\t\tpublic CachedResultHolder(@Nullable Object object) {\n\t\t\tthis.object = object;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.scripting.groovy.GroovyScriptFactory#buildGroovyClassLoader(classLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@link GroovyClassLoader} for the given {@code ClassLoader}.\n\t * @param classLoader the ClassLoader to build a GroovyClassLoader for\n\t * @since 4.3.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "GroovyClassLoader",
    "signature": "protected GroovyClassLoader buildGroovyClassLoader(@Nullable ClassLoader classLoader)",
    "source_code": "\tprotected GroovyClassLoader buildGroovyClassLoader(@Nullable ClassLoader classLoader) {\n\t\treturn (this.compilerConfiguration != null ?\n\t\t\t\tnew GroovyClassLoader(classLoader, this.compilerConfiguration) : new GroovyClassLoader(classLoader));\n\t}"
  },
  "org.springframework.scripting.groovy.GroovyScriptFactory#executeScript(scriptSource,scriptClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Instantiate the given Groovy script class and run it if necessary.\n\t * @param scriptSource the source for the underlying script\n\t * @param scriptClass the Groovy script class\n\t * @return the result object (either an instance of the script class\n\t * or the result of running the script instance)\n\t * @throws ScriptCompilationException in case of instantiation failure\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "scriptSource",
      "scriptClass"
    ],
    "position": {
      "column": 1,
      "line": 318
    },
    "return": "Object",
    "signature": "protected Object executeScript(ScriptSource scriptSource, Class<?> scriptClass)",
    "source_code": "\tprotected Object executeScript(ScriptSource scriptSource, Class<?> scriptClass) throws ScriptCompilationException {\n\t\ttry {\n\t\t\tGroovyObject groovyObj = (GroovyObject) ReflectionUtils.accessibleConstructor(scriptClass).newInstance();\n\n\t\t\tif (this.groovyObjectCustomizer != null) {\n\t\t\t\t// Allow metaclass and other customization.\n\t\t\t\tthis.groovyObjectCustomizer.customize(groovyObj);\n\t\t\t}\n\n\t\t\tif (groovyObj instanceof Script script) {\n\t\t\t\t// A Groovy script, probably creating an instance: let's execute it.\n\t\t\t\treturn script.run();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// An instance of the scripted class: let's return it as-is.\n\t\t\t\treturn groovyObj;\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\t\"No default constructor on Groovy script class: \" + scriptClass.getName(), ex);\n\t\t}\n\t\tcatch (InstantiationException ex) {\n\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\tscriptSource, \"Unable to instantiate Groovy script class: \" + scriptClass.getName(), ex);\n\t\t}\n\t\tcatch (IllegalAccessException ex) {\n\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\tscriptSource, \"Could not access Groovy script constructor: \" + scriptClass.getName(), ex);\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\t\"Failed to invoke Groovy script constructor: \" + scriptClass.getName(), ex.getTargetException());\n\t\t}\n\t}"
  },
  "org.springframework.scripting.groovy.GroovyScriptFactory#getGroovyClassLoader()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the GroovyClassLoader used by this script factory.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "GroovyClassLoader",
    "signature": "public GroovyClassLoader getGroovyClassLoader()",
    "source_code": "\tpublic GroovyClassLoader getGroovyClassLoader() {\n\t\tsynchronized (this.scriptClassMonitor) {\n\t\t\tif (this.groovyClassLoader == null) {\n\t\t\t\tthis.groovyClassLoader = buildGroovyClassLoader(ClassUtils.getDefaultClassLoader());\n\t\t\t}\n\t\t\treturn this.groovyClassLoader;\n\t\t}\n\t}"
  },
  "org.springframework.scripting.groovy.GroovyScriptFactory#getScriptSourceLocator()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "String",
    "signature": "public String getScriptSourceLocator()",
    "source_code": "\tpublic String getScriptSourceLocator() {\n\t\treturn this.scriptSourceLocator;\n\t}"
  },
  "org.springframework.scripting.groovy.GroovyScriptFactory#getScriptedObject(scriptSource,actualInterfaces)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Loads and parses the Groovy script via the GroovyClassLoader.\n\t * @see groovy.lang.GroovyClassLoader\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scriptSource",
      "actualInterfaces"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "Object",
    "signature": "public Object getScriptedObject(ScriptSource scriptSource, @Nullable Class<?>... actualInterfaces)",
    "source_code": "\tpublic Object getScriptedObject(ScriptSource scriptSource, @Nullable Class<?>... actualInterfaces)"
  },
  "org.springframework.scripting.groovy.GroovyScriptFactory#requiresConfigInterface()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Groovy scripts do not need a config interface,\n\t * since they expose their setters as public methods.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "boolean",
    "signature": "public boolean requiresConfigInterface()",
    "source_code": "\tpublic boolean requiresConfigInterface() {\n\t\treturn false;\n\t}"
  },
  "org.springframework.scripting.groovy.GroovyScriptFactory#requiresScriptedObjectRefresh(scriptSource)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scriptSource"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "boolean",
    "signature": "public boolean requiresScriptedObjectRefresh(ScriptSource scriptSource)",
    "source_code": "\tpublic boolean requiresScriptedObjectRefresh(ScriptSource scriptSource) {\n\t\tsynchronized (this.scriptClassMonitor) {\n\t\t\treturn (scriptSource.isModified() || this.wasModifiedForTypeCheck);\n\t\t}\n\t}"
  },
  "org.springframework.scripting.groovy.GroovyScriptFactory#setBeanClassLoader(classLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "void",
    "signature": "public void setBeanClassLoader(ClassLoader classLoader)",
    "source_code": "\tpublic void setBeanClassLoader(ClassLoader classLoader) {\n\t\tif (classLoader instanceof GroovyClassLoader gcl && (this.compilerConfiguration == null ||\n\t\t\t\tgcl.hasCompatibleConfiguration(this.compilerConfiguration))) {\n\t\t\tthis.groovyClassLoader = gcl;\n\t\t}\n\t\telse {\n\t\t\tthis.groovyClassLoader = buildGroovyClassLoader(classLoader);\n\t\t}\n\t}"
  },
  "org.springframework.scripting.groovy.GroovyScriptFactory#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "void",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tif (beanFactory instanceof ConfigurableListableBeanFactory clbf) {\n\t\t\tclbf.ignoreDependencyType(MetaClass.class);\n\t\t}\n\t}"
  },
  "org.springframework.scripting.groovy.GroovyScriptFactory#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 356
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn \"GroovyScriptFactory: script source locator [\" + this.scriptSourceLocator + \"]\";\n\t}"
  },
  "org.springframework.scripting.groovy.object": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 367
    },
    "signature": "public Object object",
    "source_code": "\t\tpublic final Object object;",
    "type": "Object"
  },
  "org.springframework.scripting.support.INLINE_SCRIPT_PREFIX": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The {@link org.springframework.core.io.Resource}-style prefix that denotes\n\t * an inline script.\n\t * <p>An inline script is a script that is defined right there in the (typically XML)\n\t * configuration, as opposed to being defined in an external file.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "signature": "public String INLINE_SCRIPT_PREFIX",
    "source_code": "\tpublic static final String INLINE_SCRIPT_PREFIX = \"inline:\";",
    "type": "String"
  },
  "org.springframework.scripting.support.LANGUAGE_ATTRIBUTE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The {@code language} attribute.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "signature": "public String LANGUAGE_ATTRIBUTE",
    "source_code": "\tpublic static final String LANGUAGE_ATTRIBUTE = Conventions.getQualifiedAttributeName(",
    "type": "String"
  },
  "org.springframework.scripting.support.PROXY_TARGET_CLASS_ATTRIBUTE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The {@code proxyTargetClass} attribute.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "signature": "public String PROXY_TARGET_CLASS_ATTRIBUTE",
    "source_code": "\tpublic static final String PROXY_TARGET_CLASS_ATTRIBUTE = Conventions.getQualifiedAttributeName(",
    "type": "String"
  },
  "org.springframework.scripting.support.REFRESH_CHECK_DELAY_ATTRIBUTE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The {@code refreshCheckDelay} attribute.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "signature": "public String REFRESH_CHECK_DELAY_ATTRIBUTE",
    "source_code": "\tpublic static final String REFRESH_CHECK_DELAY_ATTRIBUTE = Conventions.getQualifiedAttributeName(",
    "type": "String"
  },
  "org.springframework.scripting.support.ScriptFactoryPostProcessor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link org.springframework.beans.factory.config.BeanPostProcessor} that\n * handles {@link org.springframework.scripting.ScriptFactory} definitions,\n * replacing each factory with the actual scripted Java object generated by it.\n *\n * <p>This is similar to the\n * {@link org.springframework.beans.factory.FactoryBean} mechanism, but is\n * specifically tailored for scripts and not built into Spring's core\n * container itself but rather implemented as an extension.\n *\n * <p><b>NOTE:</b> The most important characteristic of this post-processor\n * is that constructor arguments are applied to the\n * {@link org.springframework.scripting.ScriptFactory} instance\n * while bean property values are applied to the generated scripted object.\n * Typically, constructor arguments include a script source locator and\n * potentially script interfaces, while bean property values include\n * references and config values to inject into the scripted object itself.\n *\n * <p>The following {@link ScriptFactoryPostProcessor} will automatically\n * be applied to the two\n * {@link org.springframework.scripting.ScriptFactory} definitions below.\n * At runtime, the actual scripted objects will be exposed for\n * \"bshMessenger\" and \"groovyMessenger\", rather than the\n * {@link org.springframework.scripting.ScriptFactory} instances. Both of\n * those are supposed to be castable to the example's {@code Messenger}\n * interfaces here.\n *\n * <pre class=\"code\">&lt;bean class=\"org.springframework.scripting.support.ScriptFactoryPostProcessor\"/&gt;\n *\n * &lt;bean id=\"bshMessenger\" class=\"org.springframework.scripting.bsh.BshScriptFactory\"&gt;\n *   &lt;constructor-arg value=\"classpath:mypackage/Messenger.bsh\"/&gt;\n *   &lt;constructor-arg value=\"mypackage.Messenger\"/&gt;\n *   &lt;property name=\"message\" value=\"Hello World!\"/&gt;\n * &lt;/bean&gt;\n *\n * &lt;bean id=\"groovyMessenger\" class=\"org.springframework.scripting.groovy.GroovyScriptFactory\"&gt;\n *   &lt;constructor-arg value=\"classpath:mypackage/Messenger.groovy\"/&gt;\n *   &lt;property name=\"message\" value=\"Hello World!\"/&gt;\n * &lt;/bean&gt;</pre>\n *\n * <p><b>NOTE:</b> Please note that the above excerpt from a Spring\n * XML bean definition file uses just the &lt;bean/&gt;-style syntax\n * (in an effort to illustrate using the {@link ScriptFactoryPostProcessor} itself).\n * In reality, you would never create a &lt;bean/&gt; definition for a\n * {@link ScriptFactoryPostProcessor} explicitly; rather you would import the\n * tags from the {@code 'lang'} namespace and simply create scripted\n * beans using the tags in that namespace... as part of doing so, a\n * {@link ScriptFactoryPostProcessor} will implicitly be created for you.\n *\n * <p>The Spring reference documentation contains numerous examples of using\n * tags in the {@code 'lang'} namespace; by way of an example, find below\n * a Groovy-backed bean defined using the {@code 'lang:groovy'} tag.\n *\n * <pre class=\"code\">\n * &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n * &lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n *     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n *     xmlns:lang=\"http://www.springframework.org/schema/lang\"&gt;\n *\n *   &lt;!-- this is the bean definition for the Groovy-backed Messenger implementation --&gt;\n *   &lt;lang:groovy id=\"messenger\" script-source=\"classpath:Messenger.groovy\"&gt;\n *     &lt;lang:property name=\"message\" value=\"I Can Do The Frug\" /&gt;\n *   &lt;/lang:groovy&gt;\n *\n *   &lt;!-- an otherwise normal bean that will be injected by the Groovy-backed Messenger --&gt;\n *   &lt;bean id=\"bookingService\" class=\"x.y.DefaultBookingService\"&gt;\n *     &lt;property name=\"messenger\" ref=\"messenger\" /&gt;\n *   &lt;/bean&gt;\n *\n * &lt;/beans&gt;</pre>\n *\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Rick Evans\n * @author Mark Fisher\n * @author Sam Brannen\n * @since 2.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "signature": "public class ScriptFactoryPostProcessor",
    "source_code": "public class ScriptFactoryPostProcessor implements SmartInstantiationAwareBeanPostProcessor,"
  },
  "org.springframework.scripting.support.ScriptFactoryPostProcessor#convertToScriptSource(beanName,scriptSourceLocator,resourceLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given script source locator to a ScriptSource instance.\n\t * <p>By default, supported locators are Spring resource locations\n\t * (such as \"file:C:/myScript.bsh\" or \"classpath:myPackage/myScript.bsh\")\n\t * and inline scripts (\"inline:myScriptText...\").\n\t * @param beanName the name of the scripted bean\n\t * @param scriptSourceLocator the script source locator\n\t * @param resourceLoader the ResourceLoader to use (if necessary)\n\t * @return the ScriptSource instance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "scriptSourceLocator",
      "resourceLoader"
    ],
    "position": {
      "column": 1,
      "line": 478
    },
    "return": "ScriptSource",
    "signature": "protected ScriptSource convertToScriptSource(String beanName, String scriptSourceLocator,\n\t\t\tResourceLoader resourceLoader)",
    "source_code": "\tprotected ScriptSource convertToScriptSource(String beanName, String scriptSourceLocator,"
  },
  "org.springframework.scripting.support.ScriptFactoryPostProcessor#createRefreshableProxy(ts,interfaces,proxyTargetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a refreshable proxy for the given AOP TargetSource.\n\t * @param ts the refreshable TargetSource\n\t * @param interfaces the proxy interfaces (may be {@code null} to\n\t * indicate proxying of all interfaces implemented by the target class)\n\t * @return the generated proxy\n\t * @see RefreshableScriptTargetSource\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ts",
      "interfaces",
      "proxyTargetClass"
    ],
    "position": {
      "column": 1,
      "line": 568
    },
    "return": "Object",
    "signature": "protected Object createRefreshableProxy(TargetSource ts, @Nullable Class<?>[] interfaces, boolean proxyTargetClass)",
    "source_code": "\tprotected Object createRefreshableProxy(TargetSource ts, @Nullable Class<?>[] interfaces, boolean proxyTargetClass) {\n\t\tProxyFactory proxyFactory = new ProxyFactory();\n\t\tproxyFactory.setTargetSource(ts);\n\t\tClassLoader classLoader = this.beanClassLoader;\n\n\t\tif (interfaces != null) {\n\t\t\tproxyFactory.setInterfaces(interfaces);\n\t\t}\n\t\telse {\n\t\t\tClass<?> targetClass = ts.getTargetClass();\n\t\t\tif (targetClass != null) {\n\t\t\t\tproxyFactory.setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, this.beanClassLoader));\n\t\t\t}\n\t\t}\n\n\t\tif (proxyTargetClass) {\n\t\t\tclassLoader = null;  // force use of Class.getClassLoader()\n\t\t\tproxyFactory.setProxyTargetClass(true);\n\t\t}\n\n\t\tDelegatingIntroductionInterceptor introduction = new DelegatingIntroductionInterceptor(ts);\n\t\tintroduction.suppressInterface(TargetSource.class);\n\t\tproxyFactory.addAdvice(introduction);\n\n\t\treturn proxyFactory.getProxy(classLoader);\n\t}"
  },
  "org.springframework.scripting.support.ScriptFactoryPostProcessor#createScriptFactoryBeanDefinition(bd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a ScriptFactory bean definition based on the given script definition,\n\t * extracting only the definition data that is relevant for the ScriptFactory\n\t * (that is, only bean class and constructor arguments).\n\t * @param bd the full script bean definition\n\t * @return the extracted ScriptFactory bean definition\n\t * @see org.springframework.scripting.ScriptFactory\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 448
    },
    "return": "BeanDefinition",
    "signature": "protected BeanDefinition createScriptFactoryBeanDefinition(BeanDefinition bd)",
    "source_code": "\tprotected BeanDefinition createScriptFactoryBeanDefinition(BeanDefinition bd) {\n\t\tGenericBeanDefinition scriptBd = new GenericBeanDefinition();\n\t\tscriptBd.setBeanClassName(bd.getBeanClassName());\n\t\tscriptBd.getConstructorArgumentValues().addArgumentValues(bd.getConstructorArgumentValues());\n\t\treturn scriptBd;\n\t}"
  },
  "org.springframework.scripting.support.ScriptFactoryPostProcessor#createScriptedObjectBeanDefinition(bd,scriptFactoryBeanName,scriptSource,interfaces)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a bean definition for the scripted object, based on the given script\n\t * definition, extracting the definition data that is relevant for the scripted\n\t * object (that is, everything but bean class and constructor arguments).\n\t * @param bd the full script bean definition\n\t * @param scriptFactoryBeanName the name of the internal ScriptFactory bean\n\t * @param scriptSource the ScriptSource for the scripted bean\n\t * @param interfaces the interfaces that the scripted bean is supposed to implement\n\t * @return the extracted ScriptFactory bean definition\n\t * @see org.springframework.scripting.ScriptFactory#getScriptedObject\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bd",
      "scriptFactoryBeanName",
      "scriptSource",
      "interfaces"
    ],
    "position": {
      "column": 1,
      "line": 548
    },
    "return": "BeanDefinition",
    "signature": "protected BeanDefinition createScriptedObjectBeanDefinition(BeanDefinition bd, String scriptFactoryBeanName,\n\t\t\tScriptSource scriptSource, @Nullable Class<?>[] interfaces)",
    "source_code": "\tprotected BeanDefinition createScriptedObjectBeanDefinition(BeanDefinition bd, String scriptFactoryBeanName,"
  },
  "org.springframework.scripting.support.ScriptFactoryPostProcessor#destroy()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Destroy the inner bean factory (used for scripts) on shutdown.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 599
    },
    "return": "void",
    "signature": "public void destroy()",
    "source_code": "\tpublic void destroy() {\n\t\tthis.scriptBeanFactory.destroySingletons();\n\t}"
  },
  "org.springframework.scripting.support.ScriptFactoryPostProcessor#getOrder()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "int",
    "signature": "public int getOrder()",
    "source_code": "\tpublic int getOrder() {\n\t\treturn Integer.MIN_VALUE;\n\t}"
  },
  "org.springframework.scripting.support.ScriptFactoryPostProcessor#getScriptSource(beanName,scriptSourceLocator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a ScriptSource for the given bean, lazily creating it\n\t * if not cached already.\n\t * @param beanName the name of the scripted bean\n\t * @param scriptSourceLocator the script source locator associated with the bean\n\t * @return the corresponding ScriptSource instance\n\t * @see #convertToScriptSource\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "scriptSourceLocator"
    ],
    "position": {
      "column": 1,
      "line": 463
    },
    "return": "ScriptSource",
    "signature": "protected ScriptSource getScriptSource(String beanName, String scriptSourceLocator)",
    "source_code": "\tprotected ScriptSource getScriptSource(String beanName, String scriptSourceLocator) {\n\t\treturn this.scriptSourceCache.computeIfAbsent(beanName, key ->\n\t\t\t\tconvertToScriptSource(beanName, scriptSourceLocator, this.resourceLoader));\n\t}"
  },
  "org.springframework.scripting.support.ScriptFactoryPostProcessor#postProcessBeforeInstantiation(beanClass,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) {\n\t\t// We only apply special treatment to ScriptFactory implementations here.\n\t\tif (!ScriptFactory.class.isAssignableFrom(beanClass)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tAssert.state(this.beanFactory != null, \"No BeanFactory set\");\n\t\tBeanDefinition bd = this.beanFactory.getMergedBeanDefinition(beanName);\n\t\tString scriptFactoryBeanName = SCRIPT_FACTORY_NAME_PREFIX + beanName;\n\t\tString scriptedObjectBeanName = SCRIPTED_OBJECT_NAME_PREFIX + beanName;\n\t\tprepareScriptBeans(bd, scriptFactoryBeanName, scriptedObjectBeanName);\n\n\t\tScriptFactory scriptFactory = this.scriptBeanFactory.getBean(scriptFactoryBeanName, ScriptFactory.class);\n\t\tScriptSource scriptSource = getScriptSource(scriptFactoryBeanName, scriptFactory.getScriptSourceLocator());\n\t\tboolean isFactoryBean = false;\n\t\ttry {\n\t\t\tClass<?> scriptedObjectType = scriptFactory.getScriptedObjectType(scriptSource);\n\t\t\t// Returned type may be null if the factory is unable to determine the type.\n\t\t\tif (scriptedObjectType != null) {\n\t\t\t\tisFactoryBean = FactoryBean.class.isAssignableFrom(scriptedObjectType);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new BeanCreationException(beanName,\n\t\t\t\t\t\"Could not determine scripted object type for \" + scriptFactory, ex);\n\t\t}\n\n\t\tlong refreshCheckDelay = resolveRefreshCheckDelay(bd);\n\t\tif (refreshCheckDelay >= 0) {\n\t\t\tClass<?>[] interfaces = scriptFactory.getScriptInterfaces();\n\t\t\tRefreshableScriptTargetSource ts = new RefreshableScriptTargetSource(this.scriptBeanFactory,\n\t\t\t\t\tscriptedObjectBeanName, scriptFactory, scriptSource, isFactoryBean);\n\t\t\tboolean proxyTargetClass = resolveProxyTargetClass(bd);\n\t\t\tString language = (String) bd.getAttribute(LANGUAGE_ATTRIBUTE);\n\t\t\tif (proxyTargetClass && (language == null || !language.equals(\"groovy\"))) {\n\t\t\t\tthrow new BeanDefinitionValidationException(\n\t\t\t\t\t\t\"Cannot use proxyTargetClass=true with script beans where language is not 'groovy': '\" +\n\t\t\t\t\t\tlanguage + \"'\");\n\t\t\t}\n\t\t\tts.setRefreshCheckDelay(refreshCheckDelay);\n\t\t\treturn createRefreshableProxy(ts, interfaces, proxyTargetClass);\n\t\t}\n\n\t\tif (isFactoryBean) {\n\t\t\tscriptedObjectBeanName = BeanFactory.FACTORY_BEAN_PREFIX + scriptedObjectBeanName;\n\t\t}\n\t\treturn this.scriptBeanFactory.getBean(scriptedObjectBeanName);\n\t}"
  },
  "org.springframework.scripting.support.ScriptFactoryPostProcessor#postProcessProperties(pvs,bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pvs",
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 303
    },
    "return": "PropertyValues",
    "signature": "public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName)",
    "source_code": "\tpublic PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {\n\t\treturn pvs;\n\t}"
  },
  "org.springframework.scripting.support.ScriptFactoryPostProcessor#prepareScriptBeans(bd,scriptFactoryBeanName,scriptedObjectBeanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare the script beans in the internal BeanFactory that this\n\t * post-processor uses. Each original bean definition will be split\n\t * into a ScriptFactory definition and a scripted object definition.\n\t * @param bd the original bean definition in the main BeanFactory\n\t * @param scriptFactoryBeanName the name of the internal ScriptFactory bean\n\t * @param scriptedObjectBeanName the name of the internal scripted object bean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bd",
      "scriptFactoryBeanName",
      "scriptedObjectBeanName"
    ],
    "position": {
      "column": 1,
      "line": 365
    },
    "return": "void",
    "signature": "protected void prepareScriptBeans(BeanDefinition bd, String scriptFactoryBeanName, String scriptedObjectBeanName)",
    "source_code": "\tprotected void prepareScriptBeans(BeanDefinition bd, String scriptFactoryBeanName, String scriptedObjectBeanName) {\n\t\t// Avoid recreation of the script bean definition in case of a prototype.\n\t\tsynchronized (this.scriptBeanFactory) {\n\t\t\tif (!this.scriptBeanFactory.containsBeanDefinition(scriptedObjectBeanName)) {\n\n\t\t\t\tthis.scriptBeanFactory.registerBeanDefinition(\n\t\t\t\t\t\tscriptFactoryBeanName, createScriptFactoryBeanDefinition(bd));\n\t\t\t\tScriptFactory scriptFactory =\n\t\t\t\t\t\tthis.scriptBeanFactory.getBean(scriptFactoryBeanName, ScriptFactory.class);\n\t\t\t\tScriptSource scriptSource =\n\t\t\t\t\t\tgetScriptSource(scriptFactoryBeanName, scriptFactory.getScriptSourceLocator());\n\t\t\t\tClass<?>[] interfaces = scriptFactory.getScriptInterfaces();\n\n\t\t\t\tClass<?>[] scriptedInterfaces = interfaces;\n\t\t\t\tif (scriptFactory.requiresConfigInterface() && !bd.getPropertyValues().isEmpty()) {\n\t\t\t\t\tClass<?> configInterface = createConfigInterface(bd, interfaces);\n\t\t\t\t\tscriptedInterfaces = ObjectUtils.addObjectToArray(interfaces, configInterface);\n\t\t\t\t}\n\n\t\t\t\tBeanDefinition objectBd = createScriptedObjectBeanDefinition(\n\t\t\t\t\t\tbd, scriptFactoryBeanName, scriptSource, scriptedInterfaces);\n\t\t\t\tlong refreshCheckDelay = resolveRefreshCheckDelay(bd);\n\t\t\t\tif (refreshCheckDelay >= 0) {\n\t\t\t\t\tobjectBd.setScope(BeanDefinition.SCOPE_PROTOTYPE);\n\t\t\t\t}\n\n\t\t\t\tthis.scriptBeanFactory.registerBeanDefinition(scriptedObjectBeanName, objectBd);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.scripting.support.ScriptFactoryPostProcessor#resolveProxyTargetClass(beanDefinition)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanDefinition"
    ],
    "position": {
      "column": 1,
      "line": 423
    },
    "return": "boolean",
    "signature": "protected boolean resolveProxyTargetClass(BeanDefinition beanDefinition)",
    "source_code": "\tprotected boolean resolveProxyTargetClass(BeanDefinition beanDefinition) {\n\t\tboolean proxyTargetClass = this.defaultProxyTargetClass;\n\t\tObject attributeValue = beanDefinition.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE);\n\t\tif (attributeValue instanceof Boolean boo) {\n\t\t\tproxyTargetClass = boo;\n\t\t}\n\t\telse if (attributeValue instanceof String text) {\n\t\t\tproxyTargetClass = Boolean.parseBoolean(text);\n\t\t}\n\t\telse if (attributeValue != null) {\n\t\t\tthrow new BeanDefinitionStoreException(\"Invalid proxy target class attribute [\" +\n\t\t\t\t\tPROXY_TARGET_CLASS_ATTRIBUTE + \"] with value '\" + attributeValue +\n\t\t\t\t\t\"': needs to be of type Boolean or String\");\n\t\t}\n\t\treturn proxyTargetClass;\n\t}"
  },
  "org.springframework.scripting.support.ScriptFactoryPostProcessor#resolveRefreshCheckDelay(beanDefinition)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the refresh check delay for the given {@link ScriptFactory} {@link BeanDefinition}.\n\t * If the {@link BeanDefinition} has a\n\t * {@link org.springframework.core.AttributeAccessor metadata attribute}\n\t * under the key {@link #REFRESH_CHECK_DELAY_ATTRIBUTE} which is a valid {@link Number}\n\t * type, then this value is used. Otherwise, the {@link #defaultRefreshCheckDelay}\n\t * value is used.\n\t * @param beanDefinition the BeanDefinition to check\n\t * @return the refresh check delay\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanDefinition"
    ],
    "position": {
      "column": 1,
      "line": 406
    },
    "return": "long",
    "signature": "protected long resolveRefreshCheckDelay(BeanDefinition beanDefinition)",
    "source_code": "\tprotected long resolveRefreshCheckDelay(BeanDefinition beanDefinition) {\n\t\tlong refreshCheckDelay = this.defaultRefreshCheckDelay;\n\t\tObject attributeValue = beanDefinition.getAttribute(REFRESH_CHECK_DELAY_ATTRIBUTE);\n\t\tif (attributeValue instanceof Number number) {\n\t\t\trefreshCheckDelay = number.longValue();\n\t\t}\n\t\telse if (attributeValue instanceof String text) {\n\t\t\trefreshCheckDelay = Long.parseLong(text);\n\t\t}\n\t\telse if (attributeValue != null) {\n\t\t\tthrow new BeanDefinitionStoreException(\"Invalid refresh check delay attribute [\" +\n\t\t\t\t\tREFRESH_CHECK_DELAY_ATTRIBUTE + \"] with value '\" + attributeValue +\n\t\t\t\t\t\"': needs to be of type Number or String\");\n\t\t}\n\t\treturn refreshCheckDelay;\n\t}"
  },
  "org.springframework.scripting.support.ScriptFactoryPostProcessor#setBeanClassLoader(classLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "void",
    "signature": "public void setBeanClassLoader(ClassLoader classLoader)",
    "source_code": "\tpublic void setBeanClassLoader(ClassLoader classLoader) {\n\t\tthis.beanClassLoader = classLoader;\n\t}"
  },
  "org.springframework.scripting.support.ScriptFactoryPostProcessor#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "void",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tif (!(beanFactory instanceof ConfigurableBeanFactory cbf)) {\n\t\t\tthrow new IllegalStateException(\"ScriptFactoryPostProcessor doesn't work with \" +\n\t\t\t\t\t\"non-ConfigurableBeanFactory: \" + beanFactory.getClass());\n\t\t}\n\t\tthis.beanFactory = cbf;\n\n\t\t// Required so that references (up container hierarchies) are correctly resolved.\n\t\tthis.scriptBeanFactory.setParentBeanFactory(this.beanFactory);\n\n\t\t// Required so that all BeanPostProcessors, Scopes, etc become available.\n\t\tthis.scriptBeanFactory.copyConfigurationFrom(this.beanFactory);\n\n\t\t// Filter out BeanPostProcessors that are part of the AOP infrastructure,\n\t\t// since those are only meant to apply to beans defined in the original factory.\n\t\tthis.scriptBeanFactory.getBeanPostProcessors().removeIf(beanPostProcessor ->\n\t\t\t\tbeanPostProcessor instanceof AopInfrastructureBean);\n\t}"
  },
  "org.springframework.scripting.support.ScriptFactoryPostProcessor#setDefaultProxyTargetClass(defaultProxyTargetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Flag to signal that refreshable proxies should be created to proxy the target class not its interfaces.\n\t * @param defaultProxyTargetClass the flag value to set\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultProxyTargetClass"
    ],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "void",
    "signature": "public void setDefaultProxyTargetClass(boolean defaultProxyTargetClass)",
    "source_code": "\tpublic void setDefaultProxyTargetClass(boolean defaultProxyTargetClass) {\n\t\tthis.defaultProxyTargetClass = defaultProxyTargetClass;\n\t}"
  },
  "org.springframework.scripting.support.ScriptFactoryPostProcessor#setDefaultRefreshCheckDelay(defaultRefreshCheckDelay)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the delay between refresh checks, in milliseconds.\n\t * Default is -1, indicating no refresh checks at all.\n\t * <p>Note that an actual refresh will only happen when\n\t * the {@link org.springframework.scripting.ScriptSource} indicates\n\t * that it has been modified.\n\t * @see org.springframework.scripting.ScriptSource#isModified()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultRefreshCheckDelay"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "void",
    "signature": "public void setDefaultRefreshCheckDelay(long defaultRefreshCheckDelay)",
    "source_code": "\tpublic void setDefaultRefreshCheckDelay(long defaultRefreshCheckDelay) {\n\t\tthis.defaultRefreshCheckDelay = defaultRefreshCheckDelay;\n\t}"
  },
  "org.springframework.scripting.support.ScriptFactoryPostProcessor#setResourceLoader(resourceLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resourceLoader"
    ],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "void",
    "signature": "public void setResourceLoader(ResourceLoader resourceLoader)",
    "source_code": "\tpublic void setResourceLoader(ResourceLoader resourceLoader) {\n\t\tthis.resourceLoader = resourceLoader;\n\t}"
  },
  "org.springframework.scripting.support.StandardScriptEvaluator": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code javax.script} (JSR-223) based implementation of Spring's {@link ScriptEvaluator}\n * strategy interface.\n *\n * @author Juergen Hoeller\n * @author Costin Leau\n * @since 4.0\n * @see ScriptEngine#eval(String)\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "signature": "public class StandardScriptEvaluator",
    "source_code": "public class StandardScriptEvaluator implements ScriptEvaluator, BeanClassLoaderAware {\n\n\t@Nullable\n\tprivate String engineName;\n\n\t@Nullable\n\tprivate volatile Bindings globalBindings;\n\n\t@Nullable\n\tprivate volatile ScriptEngineManager scriptEngineManager;\n\n\n\t/**\n\t * Construct a new {@code StandardScriptEvaluator}.\n\t */\n\tpublic StandardScriptEvaluator() {\n\t}\n\n\t/**\n\t * Construct a new {@code StandardScriptEvaluator} for the given class loader.\n\t * @param classLoader the class loader to use for script engine detection\n\t */\n\tpublic StandardScriptEvaluator(ClassLoader classLoader) {\n\t\tthis.scriptEngineManager = new ScriptEngineManager(classLoader);\n\t}\n\n\t/**\n\t * Construct a new {@code StandardScriptEvaluator} for the given JSR-223\n\t * {@link ScriptEngineManager} to obtain script engines from.\n\t * @param scriptEngineManager the ScriptEngineManager (or subclass thereof) to use\n\t * @since 4.2.2\n\t */\n\tpublic StandardScriptEvaluator(ScriptEngineManager scriptEngineManager) {\n\t\tthis.scriptEngineManager = scriptEngineManager;\n\t}\n\n\n\t/**\n\t * Set the name of the language meant for evaluating the scripts (e.g. \"Groovy\").\n\t * <p>This is effectively an alias for {@link #setEngineName \"engineName\"},\n\t * potentially (but not yet) providing common abbreviations for certain languages\n\t * beyond what the JSR-223 script engine factory exposes.\n\t * @see #setEngineName\n\t */\n\tpublic void setLanguage(String language) {\n\t\tthis.engineName = language;\n\t}\n\n\t/**\n\t * Set the name of the script engine for evaluating the scripts (e.g. \"Groovy\"),\n\t * as exposed by the JSR-223 script engine factory.\n\t * @since 4.2.2\n\t * @see #setLanguage\n\t */\n\tpublic void setEngineName(String engineName) {\n\t\tthis.engineName = engineName;\n\t}\n\n\t/**\n\t * Set the globally scoped bindings on the underlying script engine manager,\n\t * shared by all scripts, as an alternative to script argument bindings.\n\t * @since 4.2.2\n\t * @see #evaluate(ScriptSource, Map)\n\t * @see javax.script.ScriptEngineManager#setBindings(Bindings)\n\t * @see javax.script.SimpleBindings\n\t */\n\tpublic void setGlobalBindings(Map<String, Object> globalBindings) {\n\t\tBindings bindings = StandardScriptUtils.getBindings(globalBindings);\n\t\tthis.globalBindings = bindings;\n\t\tScriptEngineManager scriptEngineManager = this.scriptEngineManager;\n\t\tif (scriptEngineManager != null) {\n\t\t\tscriptEngineManager.setBindings(bindings);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setBeanClassLoader(ClassLoader classLoader) {\n\t\tScriptEngineManager scriptEngineManager = this.scriptEngineManager;\n\t\tif (scriptEngineManager == null) {\n\t\t\tscriptEngineManager = new ScriptEngineManager(classLoader);\n\t\t\tthis.scriptEngineManager = scriptEngineManager;\n\t\t\tBindings bindings = this.globalBindings;\n\t\t\tif (bindings != null) {\n\t\t\t\tscriptEngineManager.setBindings(bindings);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t@Override\n\t@Nullable\n\tpublic Object evaluate(ScriptSource script) {\n\t\treturn evaluate(script, null);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Object evaluate(ScriptSource script, @Nullable Map<String, Object> argumentBindings) {\n\t\tScriptEngine engine = getScriptEngine(script);\n\t\ttry {\n\t\t\tif (CollectionUtils.isEmpty(argumentBindings)) {\n\t\t\t\treturn engine.eval(script.getScriptAsString());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tBindings bindings = StandardScriptUtils.getBindings(argumentBindings);\n\t\t\t\treturn engine.eval(script.getScriptAsString(), bindings);\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new ScriptCompilationException(script, \"Cannot access script for ScriptEngine\", ex);\n\t\t}\n\t\tcatch (ScriptException ex) {\n\t\t\tthrow new ScriptCompilationException(script, new StandardScriptEvalException(ex));\n\t\t}\n\t}\n\n\t/**\n\t * Obtain the JSR-223 ScriptEngine to use for the given script.\n\t * @param script the script to evaluate\n\t * @return the ScriptEngine (never {@code null})\n\t */\n\tprotected ScriptEngine getScriptEngine(ScriptSource script) {\n\t\tScriptEngineManager scriptEngineManager = this.scriptEngineManager;\n\t\tif (scriptEngineManager == null) {\n\t\t\tscriptEngineManager = new ScriptEngineManager();\n\t\t\tthis.scriptEngineManager = scriptEngineManager;\n\t\t}\n\n\t\tif (StringUtils.hasText(this.engineName)) {\n\t\t\treturn StandardScriptUtils.retrieveEngineByName(scriptEngineManager, this.engineName);\n\t\t}\n\t\telse if (script instanceof ResourceScriptSource resourceScriptSource) {\n\t\t\tResource resource = resourceScriptSource.getResource();\n\t\t\tString extension = StringUtils.getFilenameExtension(resource.getFilename());\n\t\t\tif (extension == null) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"No script language defined, and no file extension defined for resource: \" + resource);\n\t\t\t}\n\t\t\tScriptEngine engine = scriptEngineManager.getEngineByExtension(extension);\n\t\t\tif (engine == null) {\n\t\t\t\tthrow new IllegalStateException(\"No matching engine found for file extension '\" + extension + \"'\");\n\t\t\t}\n\t\t\treturn engine;\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"No script language defined, and no resource associated with script: \" + script);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.scripting.support.StandardScriptEvaluator#evaluate(script)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "script"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "Object",
    "signature": "public Object evaluate(ScriptSource script)",
    "source_code": "\tpublic Object evaluate(ScriptSource script) {\n\t\treturn evaluate(script, null);\n\t}"
  },
  "org.springframework.scripting.support.StandardScriptEvaluator#evaluate(script,Map<String,argumentBindings)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "script",
      "Map<String",
      "argumentBindings"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "Object",
    "signature": "public Object evaluate(ScriptSource script, @Nullable Map<String, Object> argumentBindings)",
    "source_code": "\tpublic Object evaluate(ScriptSource script, @Nullable Map<String, Object> argumentBindings) {\n\t\tScriptEngine engine = getScriptEngine(script);\n\t\ttry {\n\t\t\tif (CollectionUtils.isEmpty(argumentBindings)) {\n\t\t\t\treturn engine.eval(script.getScriptAsString());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tBindings bindings = StandardScriptUtils.getBindings(argumentBindings);\n\t\t\t\treturn engine.eval(script.getScriptAsString(), bindings);\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new ScriptCompilationException(script, \"Cannot access script for ScriptEngine\", ex);\n\t\t}\n\t\tcatch (ScriptException ex) {\n\t\t\tthrow new ScriptCompilationException(script, new StandardScriptEvalException(ex));\n\t\t}\n\t}"
  },
  "org.springframework.scripting.support.StandardScriptEvaluator#getScriptEngine(script)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain the JSR-223 ScriptEngine to use for the given script.\n\t * @param script the script to evaluate\n\t * @return the ScriptEngine (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "script"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "ScriptEngine",
    "signature": "protected ScriptEngine getScriptEngine(ScriptSource script)",
    "source_code": "\tprotected ScriptEngine getScriptEngine(ScriptSource script) {\n\t\tScriptEngineManager scriptEngineManager = this.scriptEngineManager;\n\t\tif (scriptEngineManager == null) {\n\t\t\tscriptEngineManager = new ScriptEngineManager();\n\t\t\tthis.scriptEngineManager = scriptEngineManager;\n\t\t}\n\n\t\tif (StringUtils.hasText(this.engineName)) {\n\t\t\treturn StandardScriptUtils.retrieveEngineByName(scriptEngineManager, this.engineName);\n\t\t}\n\t\telse if (script instanceof ResourceScriptSource resourceScriptSource) {\n\t\t\tResource resource = resourceScriptSource.getResource();\n\t\t\tString extension = StringUtils.getFilenameExtension(resource.getFilename());\n\t\t\tif (extension == null) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"No script language defined, and no file extension defined for resource: \" + resource);\n\t\t\t}\n\t\t\tScriptEngine engine = scriptEngineManager.getEngineByExtension(extension);\n\t\t\tif (engine == null) {\n\t\t\t\tthrow new IllegalStateException(\"No matching engine found for file extension '\" + extension + \"'\");\n\t\t\t}\n\t\t\treturn engine;\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"No script language defined, and no resource associated with script: \" + script);\n\t\t}\n\t}"
  },
  "org.springframework.scripting.support.StandardScriptEvaluator#setBeanClassLoader(classLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "void",
    "signature": "public void setBeanClassLoader(ClassLoader classLoader)",
    "source_code": "\tpublic void setBeanClassLoader(ClassLoader classLoader) {\n\t\tScriptEngineManager scriptEngineManager = this.scriptEngineManager;\n\t\tif (scriptEngineManager == null) {\n\t\t\tscriptEngineManager = new ScriptEngineManager(classLoader);\n\t\t\tthis.scriptEngineManager = scriptEngineManager;\n\t\t\tBindings bindings = this.globalBindings;\n\t\t\tif (bindings != null) {\n\t\t\t\tscriptEngineManager.setBindings(bindings);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.scripting.support.StandardScriptEvaluator#setEngineName(engineName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of the script engine for evaluating the scripts (e.g. \"Groovy\"),\n\t * as exposed by the JSR-223 script engine factory.\n\t * @since 4.2.2\n\t * @see #setLanguage\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "engineName"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "void",
    "signature": "public void setEngineName(String engineName)",
    "source_code": "\tpublic void setEngineName(String engineName) {\n\t\tthis.engineName = engineName;\n\t}"
  },
  "org.springframework.scripting.support.StandardScriptEvaluator#setGlobalBindings(Map<String,globalBindings)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the globally scoped bindings on the underlying script engine manager,\n\t * shared by all scripts, as an alternative to script argument bindings.\n\t * @since 4.2.2\n\t * @see #evaluate(ScriptSource, Map)\n\t * @see javax.script.ScriptEngineManager#setBindings(Bindings)\n\t * @see javax.script.SimpleBindings\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "globalBindings"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void setGlobalBindings(Map<String, Object> globalBindings)",
    "source_code": "\tpublic void setGlobalBindings(Map<String, Object> globalBindings) {\n\t\tBindings bindings = StandardScriptUtils.getBindings(globalBindings);\n\t\tthis.globalBindings = bindings;\n\t\tScriptEngineManager scriptEngineManager = this.scriptEngineManager;\n\t\tif (scriptEngineManager != null) {\n\t\t\tscriptEngineManager.setBindings(bindings);\n\t\t}\n\t}"
  },
  "org.springframework.scripting.support.StandardScriptEvaluator#setLanguage(language)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of the language meant for evaluating the scripts (e.g. \"Groovy\").\n\t * <p>This is effectively an alias for {@link #setEngineName \"engineName\"},\n\t * potentially (but not yet) providing common abbreviations for certain languages\n\t * beyond what the JSR-223 script engine factory exposes.\n\t * @see #setEngineName\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "language"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "void",
    "signature": "public void setLanguage(String language)",
    "source_code": "\tpublic void setLanguage(String language) {\n\t\tthis.engineName = language;\n\t}"
  },
  "org.springframework.scripting.support.StandardScriptUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Common operations for dealing with a JSR-223 {@link ScriptEngine}.\n *\n * @author Juergen Hoeller\n * @since 4.2.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "signature": "public class StandardScriptUtils",
    "source_code": "public abstract class StandardScriptUtils {\n\n\t/**\n\t * Retrieve a {@link ScriptEngine} from the given {@link ScriptEngineManager}\n\t * by name, delegating to {@link ScriptEngineManager#getEngineByName} but\n\t * throwing a descriptive exception if not found or if initialization failed.\n\t * @param scriptEngineManager the ScriptEngineManager to use\n\t * @param engineName the name of the engine\n\t * @return a corresponding ScriptEngine (never {@code null})\n\t * @throws IllegalArgumentException if no matching engine has been found\n\t * @throws IllegalStateException if the desired engine failed to initialize\n\t */\n\tpublic static ScriptEngine retrieveEngineByName(ScriptEngineManager scriptEngineManager, String engineName) {\n\t\tScriptEngine engine = scriptEngineManager.getEngineByName(engineName);\n\t\tif (engine == null) {\n\t\t\tSet<String> engineNames = new LinkedHashSet<>();\n\t\t\tfor (ScriptEngineFactory engineFactory : scriptEngineManager.getEngineFactories()) {\n\t\t\t\tList<String> factoryNames = engineFactory.getNames();\n\t\t\t\tif (factoryNames.contains(engineName)) {\n\t\t\t\t\t// Special case: getEngineByName returned null but engine is present...\n\t\t\t\t\t// Let's assume it failed to initialize (which ScriptEngineManager silently swallows).\n\t\t\t\t\t// If it happens to initialize fine now, alright, but we really expect an exception.\n\t\t\t\t\ttry {\n\t\t\t\t\t\tengine = engineFactory.getScriptEngine();\n\t\t\t\t\t\tengine.setBindings(scriptEngineManager.getBindings(), ScriptContext.GLOBAL_SCOPE);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"Script engine with name '\" + engineName +\n\t\t\t\t\t\t\t\t\"' failed to initialize\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tengineNames.addAll(factoryNames);\n\t\t\t}\n\t\t\tthrow new IllegalArgumentException(\"Script engine with name '\" + engineName +\n\t\t\t\t\t\"' not found; registered engine names: \" + engineNames);\n\t\t}\n\t\treturn engine;\n\t}\n\n\tstatic Bindings getBindings(Map<String, Object> bindings) {\n\t\treturn (bindings instanceof Bindings b ? b : new SimpleBindings(bindings));\n\t}\n\n}"
  },
  "org.springframework.scripting.support.StandardScriptUtils#retrieveEngineByName(scriptEngineManager,engineName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve a {@link ScriptEngine} from the given {@link ScriptEngineManager}\n\t * by name, delegating to {@link ScriptEngineManager#getEngineByName} but\n\t * throwing a descriptive exception if not found or if initialization failed.\n\t * @param scriptEngineManager the ScriptEngineManager to use\n\t * @param engineName the name of the engine\n\t * @return a corresponding ScriptEngine (never {@code null})\n\t * @throws IllegalArgumentException if no matching engine has been found\n\t * @throws IllegalStateException if the desired engine failed to initialize\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scriptEngineManager",
      "engineName"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "return": "ScriptEngine",
    "signature": "public ScriptEngine retrieveEngineByName(ScriptEngineManager scriptEngineManager, String engineName)",
    "source_code": "\tpublic static ScriptEngine retrieveEngineByName(ScriptEngineManager scriptEngineManager, String engineName) {\n\t\tScriptEngine engine = scriptEngineManager.getEngineByName(engineName);\n\t\tif (engine == null) {\n\t\t\tSet<String> engineNames = new LinkedHashSet<>();\n\t\t\tfor (ScriptEngineFactory engineFactory : scriptEngineManager.getEngineFactories()) {\n\t\t\t\tList<String> factoryNames = engineFactory.getNames();\n\t\t\t\tif (factoryNames.contains(engineName)) {\n\t\t\t\t\t// Special case: getEngineByName returned null but engine is present...\n\t\t\t\t\t// Let's assume it failed to initialize (which ScriptEngineManager silently swallows).\n\t\t\t\t\t// If it happens to initialize fine now, alright, but we really expect an exception.\n\t\t\t\t\ttry {\n\t\t\t\t\t\tengine = engineFactory.getScriptEngine();\n\t\t\t\t\t\tengine.setBindings(scriptEngineManager.getBindings(), ScriptContext.GLOBAL_SCOPE);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"Script engine with name '\" + engineName +\n\t\t\t\t\t\t\t\t\"' failed to initialize\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tengineNames.addAll(factoryNames);\n\t\t\t}\n\t\t\tthrow new IllegalArgumentException(\"Script engine with name '\" + engineName +\n\t\t\t\t\t\"' not found; registered engine names: \" + engineNames);\n\t\t}\n\t\treturn engine;\n\t}"
  },
  "org.springframework.scripting.support.logger": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Logger available to subclasses. */",
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.test.context.jdbc.SqlScriptsTestExecutionListener": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code TestExecutionListener} that provides support for executing SQL\n * {@link Sql#scripts scripts} and inlined {@link Sql#statements statements}\n * configured via the {@link Sql @Sql} annotation.\n *\n * <p>Scripts and inlined statements will be executed {@linkplain #beforeTestMethod(TestContext) before}\n * or {@linkplain #afterTestMethod(TestContext) after} execution of the corresponding\n * {@linkplain java.lang.reflect.Method test method}, depending on the configured\n * value of the {@link Sql#executionPhase executionPhase} flag.\n *\n * <p>Scripts and inlined statements will be executed without a transaction,\n * within an existing Spring-managed transaction, or within an isolated transaction,\n * depending on the configured value of {@link SqlConfig#transactionMode} and the\n * presence of a transaction manager.\n *\n * <h3>Script Resources</h3>\n * <p>For details on default script detection and how script resource locations\n * are interpreted, see {@link Sql#scripts}.\n *\n * <h3>Required Spring Beans</h3>\n * <p>A {@link PlatformTransactionManager} <em>and</em> a {@link DataSource},\n * just a {@link PlatformTransactionManager}, or just a {@link DataSource}\n * must be defined as beans in the Spring {@link ApplicationContext} for the\n * corresponding test. Consult the javadocs for {@link SqlConfig#transactionMode},\n * {@link SqlConfig#transactionManager}, {@link SqlConfig#dataSource},\n * {@link TestContextTransactionUtils#retrieveDataSource}, and\n * {@link TestContextTransactionUtils#retrieveTransactionManager} for details\n * on permissible configuration constellations and on the algorithms used to\n * locate these beans.\n *\n * @author Sam Brannen\n * @author Dmitry Semukhin\n * @since 4.1\n * @see Sql\n * @see SqlConfig\n * @see SqlMergeMode\n * @see SqlGroup\n * @see org.springframework.test.context.transaction.TestContextTransactionUtils\n * @see org.springframework.test.context.transaction.TransactionalTestExecutionListener\n * @see org.springframework.jdbc.datasource.init.ResourceDatabasePopulator\n * @see org.springframework.jdbc.datasource.init.ScriptUtils\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "signature": "public class SqlScriptsTestExecutionListener",
    "source_code": "public class SqlScriptsTestExecutionListener extends AbstractTestExecutionListener implements AotTestExecutionListener {\n\n\tprivate static final String SLASH = \"/\";\n\n\tprivate static final Log logger = LogFactory.getLog(SqlScriptsTestExecutionListener.class);\n\n\tprivate static final MethodFilter sqlMethodFilter = ReflectionUtils.USER_DECLARED_METHODS\n\t\t\t.and(method -> AnnotatedElementUtils.hasAnnotation(method, Sql.class));\n\n\n\t/**\n\t * Returns {@code 5000}.\n\t */\n\t@Override\n\tpublic final int getOrder() {\n\t\treturn 5000;\n\t}\n\n\t/**\n\t * Execute SQL scripts configured via {@link Sql @Sql} for the supplied\n\t * {@link TestContext} <em>before</em> the current test method.\n\t */\n\t@Override\n\tpublic void beforeTestMethod(TestContext testContext) {\n\t\texecuteSqlScripts(testContext, ExecutionPhase.BEFORE_TEST_METHOD);\n\t}\n\n\t/**\n\t * Execute SQL scripts configured via {@link Sql @Sql} for the supplied\n\t * {@link TestContext} <em>after</em> the current test method.\n\t */\n\t@Override\n\tpublic void afterTestMethod(TestContext testContext) {\n\t\texecuteSqlScripts(testContext, ExecutionPhase.AFTER_TEST_METHOD);\n\t}\n\n\t/**\n\t * Process the supplied test class and its methods and register run-time\n\t * hints for any SQL scripts configured or detected as classpath resources\n\t * via {@link Sql @Sql}.\n\t * @since 6.0\n\t */\n\t@Override\n\tpublic void processAheadOfTime(RuntimeHints runtimeHints, Class<?> testClass, ClassLoader classLoader) {\n\t\tgetSqlAnnotationsFor(testClass).forEach(sql ->\n\t\t\tregisterClasspathResources(getScripts(sql, testClass, null, true), runtimeHints, classLoader));\n\t\tgetSqlMethods(testClass).forEach(testMethod ->\n\t\t\tgetSqlAnnotationsFor(testMethod).forEach(sql ->\n\t\t\t\tregisterClasspathResources(getScripts(sql, testClass, testMethod, false), runtimeHints, classLoader)));\n\t}\n\n\t/**\n\t * Execute SQL scripts configured via {@link Sql @Sql} for the supplied\n\t * {@link TestContext} and {@link ExecutionPhase}.\n\t */\n\tprivate void executeSqlScripts(TestContext testContext, ExecutionPhase executionPhase) {\n\t\tMethod testMethod = testContext.getTestMethod();\n\t\tClass<?> testClass = testContext.getTestClass();\n\n\t\tif (mergeSqlAnnotations(testContext)) {\n\t\t\texecuteSqlScripts(getSqlAnnotationsFor(testClass), testContext, executionPhase, true);\n\t\t\texecuteSqlScripts(getSqlAnnotationsFor(testMethod), testContext, executionPhase, false);\n\t\t}\n\t\telse {\n\t\t\tSet<Sql> methodLevelSqlAnnotations = getSqlAnnotationsFor(testMethod);\n\t\t\tif (!methodLevelSqlAnnotations.isEmpty()) {\n\t\t\t\texecuteSqlScripts(methodLevelSqlAnnotations, testContext, executionPhase, false);\n\t\t\t}\n\t\t\telse {\n\t\t\t\texecuteSqlScripts(getSqlAnnotationsFor(testClass), testContext, executionPhase, true);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Determine if method-level {@code @Sql} annotations should be merged with\n\t * class-level {@code @Sql} annotations.\n\t */\n\tprivate boolean mergeSqlAnnotations(TestContext testContext) {\n\t\tSqlMergeMode sqlMergeMode = getSqlMergeModeFor(testContext.getTestMethod());\n\t\tif (sqlMergeMode == null) {\n\t\t\tsqlMergeMode = getSqlMergeModeFor(testContext.getTestClass());\n\t\t}\n\t\treturn (sqlMergeMode != null && sqlMergeMode.value() == MergeMode.MERGE);\n\t}\n\n\t/**\n\t * Get the {@code @SqlMergeMode} annotation declared on the supplied class.\n\t */\n\t@Nullable\n\tprivate SqlMergeMode getSqlMergeModeFor(Class<?> clazz) {\n\t\treturn TestContextAnnotationUtils.findMergedAnnotation(clazz, SqlMergeMode.class);\n\t}\n\n\t/**\n\t * Get the {@code @SqlMergeMode} annotation declared on the supplied method.\n\t */\n\t@Nullable\n\tprivate SqlMergeMode getSqlMergeModeFor(Method method) {\n\t\treturn AnnotatedElementUtils.findMergedAnnotation(method, SqlMergeMode.class);\n\t}\n\n\t/**\n\t * Get the {@code @Sql} annotations declared on the supplied class.\n\t */\n\tprivate Set<Sql> getSqlAnnotationsFor(Class<?> clazz) {\n\t\treturn TestContextAnnotationUtils.getMergedRepeatableAnnotations(clazz, Sql.class);\n\t}\n\n\t/**\n\t * Get the {@code @Sql} annotations declared on the supplied method.\n\t */\n\tprivate Set<Sql> getSqlAnnotationsFor(Method method) {\n\t\treturn AnnotatedElementUtils.getMergedRepeatableAnnotations(method, Sql.class, SqlGroup.class);\n\t}\n\n\t/**\n\t * Execute SQL scripts for the supplied {@link Sql @Sql} annotations.\n\t */\n\tprivate void executeSqlScripts(\n\t\t\tSet<Sql> sqlAnnotations, TestContext testContext, ExecutionPhase executionPhase, boolean classLevel) {\n\n\t\tsqlAnnotations.forEach(sql -> executeSqlScripts(sql, executionPhase, testContext, classLevel));\n\t}\n\n\t/**\n\t * Execute the SQL scripts configured via the supplied {@link Sql @Sql}\n\t * annotation for the given {@link ExecutionPhase} and {@link TestContext}.\n\t * <p>Special care must be taken in order to properly support the configured\n\t * {@link SqlConfig#transactionMode}.\n\t * @param sql the {@code @Sql} annotation to parse\n\t * @param executionPhase the current execution phase\n\t * @param testContext the current {@code TestContext}\n\t * @param classLevel {@code true} if {@link Sql @Sql} was declared at the class level\n\t */\n\tprivate void executeSqlScripts(\n\t\t\tSql sql, ExecutionPhase executionPhase, TestContext testContext, boolean classLevel) {\n\n\t\tif (executionPhase != sql.executionPhase()) {\n\t\t\treturn;\n\t\t}\n\n\t\tMergedSqlConfig mergedSqlConfig = new MergedSqlConfig(sql.config(), testContext.getTestClass());\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Processing %s for execution phase [%s] and test context %s\"\n\t\t\t\t\t.formatted(mergedSqlConfig, executionPhase, testContext));\n\t\t}\n\t\telse if (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Processing merged @SqlConfig attributes for execution phase [%s] and test class [%s]\"\n\t\t\t\t\t.formatted(executionPhase, testContext.getTestClass().getName()));\n\t\t}\n\n\t\tString[] scripts = getScripts(sql, testContext.getTestClass(), testContext.getTestMethod(), classLevel);\n\t\tList<Resource> scriptResources = TestContextResourceUtils.convertToResourceList(\n\t\t\t\ttestContext.getApplicationContext(), scripts);\n\t\tfor (String stmt : sql.statements()) {\n\t\t\tif (StringUtils.hasText(stmt)) {\n\t\t\t\tstmt = stmt.trim();\n\t\t\t\tscriptResources.add(new ByteArrayResource(stmt.getBytes(), \"from inlined SQL statement: \" + stmt));\n\t\t\t}\n\t\t}\n\n\t\tResourceDatabasePopulator populator = createDatabasePopulator(mergedSqlConfig);\n\t\tpopulator.setScripts(scriptResources.toArray(new Resource[0]));\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Executing SQL scripts: \" + scriptResources);\n\t\t}\n\n\t\tString dsName = mergedSqlConfig.getDataSource();\n\t\tString tmName = mergedSqlConfig.getTransactionManager();\n\t\tDataSource dataSource = TestContextTransactionUtils.retrieveDataSource(testContext, dsName);\n\t\tPlatformTransactionManager txMgr = TestContextTransactionUtils.retrieveTransactionManager(testContext, tmName);\n\t\tboolean newTxRequired = (mergedSqlConfig.getTransactionMode() == TransactionMode.ISOLATED);\n\n\t\tif (txMgr == null) {\n\t\t\tAssert.state(!newTxRequired, () -> String.format(\"Failed to execute SQL scripts for test context %s: \" +\n\t\t\t\t\t\"cannot execute SQL scripts using Transaction Mode \" +\n\t\t\t\t\t\"[%s] without a PlatformTransactionManager.\", testContext, TransactionMode.ISOLATED));\n\t\t\tAssert.state(dataSource != null, () -> String.format(\"Failed to execute SQL scripts for test context %s: \" +\n\t\t\t\t\t\"supply at least a DataSource or PlatformTransactionManager.\", testContext));\n\t\t\t// Execute scripts directly against the DataSource\n\t\t\tpopulator.execute(dataSource);\n\t\t}\n\t\telse {\n\t\t\tDataSource dataSourceFromTxMgr = getDataSourceFromTransactionManager(txMgr);\n\t\t\t// Ensure user configured an appropriate DataSource/TransactionManager pair.\n\t\t\tif (dataSource != null && dataSourceFromTxMgr != null && !sameDataSource(dataSource, dataSourceFromTxMgr)) {\n\t\t\t\tthrow new IllegalStateException(String.format(\"Failed to execute SQL scripts for test context %s: \" +\n\t\t\t\t\t\t\"the configured DataSource [%s] (named '%s') is not the one associated with \" +\n\t\t\t\t\t\t\"transaction manager [%s] (named '%s').\", testContext, dataSource.getClass().getName(),\n\t\t\t\t\t\tdsName, txMgr.getClass().getName(), tmName));\n\t\t\t}\n\t\t\tif (dataSource == null) {\n\t\t\t\tdataSource = dataSourceFromTxMgr;\n\t\t\t\tAssert.state(dataSource != null, () -> String.format(\"Failed to execute SQL scripts for \" +\n\t\t\t\t\t\t\"test context %s: could not obtain DataSource from transaction manager [%s] (named '%s').\",\n\t\t\t\t\t\ttestContext, txMgr.getClass().getName(), tmName));\n\t\t\t}\n\t\t\tfinal DataSource finalDataSource = dataSource;\n\t\t\tint propagation = (newTxRequired ? TransactionDefinition.PROPAGATION_REQUIRES_NEW :\n\t\t\t\t\tTransactionDefinition.PROPAGATION_REQUIRED);\n\t\t\tTransactionAttribute txAttr = TestContextTransactionUtils.createDelegatingTransactionAttribute(\n\t\t\t\t\ttestContext, new DefaultTransactionAttribute(propagation));\n\t\t\tnew TransactionTemplate(txMgr, txAttr).executeWithoutResult(s -> populator.execute(finalDataSource));\n\t\t}\n\t}\n\n\t@NonNull\n\tprivate ResourceDatabasePopulator createDatabasePopulator(MergedSqlConfig mergedSqlConfig) {\n\t\tResourceDatabasePopulator populator = new ResourceDatabasePopulator();\n\t\tpopulator.setSqlScriptEncoding(mergedSqlConfig.getEncoding());\n\t\tpopulator.setSeparator(mergedSqlConfig.getSeparator());\n\t\tpopulator.setCommentPrefixes(mergedSqlConfig.getCommentPrefixes());\n\t\tpopulator.setBlockCommentStartDelimiter(mergedSqlConfig.getBlockCommentStartDelimiter());\n\t\tpopulator.setBlockCommentEndDelimiter(mergedSqlConfig.getBlockCommentEndDelimiter());\n\t\tpopulator.setContinueOnError(mergedSqlConfig.getErrorMode() == ErrorMode.CONTINUE_ON_ERROR);\n\t\tpopulator.setIgnoreFailedDrops(mergedSqlConfig.getErrorMode() == ErrorMode.IGNORE_FAILED_DROPS);\n\t\treturn populator;\n\t}\n\n\t/**\n\t * Determine if the two data sources are effectively the same, unwrapping\n\t * proxies as necessary to compare the target instances.\n\t * @since 5.3.4\n\t * @see TransactionSynchronizationUtils#unwrapResourceIfNecessary(Object)\n\t */\n\tprivate static boolean sameDataSource(DataSource ds1, DataSource ds2) {\n\t\treturn TransactionSynchronizationUtils.unwrapResourceIfNecessary(ds1)\n\t\t\t\t\t.equals(TransactionSynchronizationUtils.unwrapResourceIfNecessary(ds2));\n\t}\n\n\t@Nullable\n\tprivate DataSource getDataSourceFromTransactionManager(PlatformTransactionManager transactionManager) {\n\t\ttry {\n\t\t\tMethod getDataSourceMethod = transactionManager.getClass().getMethod(\"getDataSource\");\n\t\t\tObject obj = ReflectionUtils.invokeMethod(getDataSourceMethod, transactionManager);\n\t\t\tif (obj instanceof DataSource dataSource) {\n\t\t\t\treturn dataSource;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\t// ignore\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate String[] getScripts(Sql sql, Class<?> testClass, Method testMethod, boolean classLevel) {\n\t\tString[] scripts = sql.scripts();\n\t\tif (ObjectUtils.isEmpty(scripts) && ObjectUtils.isEmpty(sql.statements())) {\n\t\t\tscripts = new String[] {detectDefaultScript(testClass, testMethod, classLevel)};\n\t\t}\n\t\treturn TestContextResourceUtils.convertToClasspathResourcePaths(testClass, scripts);\n\t}\n\n\t/**\n\t * Detect a default SQL script by implementing the algorithm defined in\n\t * {@link Sql#scripts}.\n\t */\n\tprivate String detectDefaultScript(Class<?> testClass, Method testMethod, boolean classLevel) {\n\t\tString elementType = (classLevel ? \"class\" : \"method\");\n\t\tString elementName = (classLevel ? testClass.getName() : testMethod.toString());\n\n\t\tString resourcePath = ClassUtils.convertClassNameToResourcePath(testClass.getName());\n\t\tif (!classLevel) {\n\t\t\tresourcePath += \".\" + testMethod.getName();\n\t\t}\n\t\tresourcePath += \".sql\";\n\n\t\tString prefixedResourcePath = CLASSPATH_URL_PREFIX + SLASH + resourcePath;\n\t\tClassPathResource classPathResource = new ClassPathResource(resourcePath);\n\n\t\tif (classPathResource.exists()) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Detected default SQL script \\\"%s\\\" for test %s [%s]\"\n\t\t\t\t\t\t.formatted(prefixedResourcePath, elementType, elementName));\n\t\t\t}\n\t\t\treturn prefixedResourcePath;\n\t\t}\n\t\telse {\n\t\t\tString msg = String.format(\"Could not detect default SQL script for test %s [%s]: \" +\n\t\t\t\t\t\"%s does not exist. Either declare statements or scripts via @Sql or make the \" +\n\t\t\t\t\t\"default SQL script available.\", elementType, elementName, classPathResource);\n\t\t\tlogger.error(msg);\n\t\t\tthrow new IllegalStateException(msg);\n\t\t}\n\t}\n\n\tprivate Stream<Method> getSqlMethods(Class<?> testClass) {\n\t\treturn Arrays.stream(ReflectionUtils.getUniqueDeclaredMethods(testClass, sqlMethodFilter));\n\t}\n\n\tprivate void registerClasspathResources(String[] paths, RuntimeHints runtimeHints, ClassLoader classLoader) {\n\t\tDefaultResourceLoader resourceLoader = new DefaultResourceLoader(classLoader);\n\t\tArrays.stream(paths)\n\t\t\t\t.filter(path -> path.startsWith(CLASSPATH_URL_PREFIX))\n\t\t\t\t.map(resourceLoader::getResource)\n\t\t\t\t.forEach(runtimeHints.resources()::registerResource);\n\t}\n\n}"
  },
  "org.springframework.test.context.jdbc.SqlScriptsTestExecutionListener#afterTestMethod(testContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute SQL scripts configured via {@link Sql @Sql} for the supplied\n\t * {@link TestContext} <em>after</em> the current test method.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "void",
    "signature": "public void afterTestMethod(TestContext testContext)",
    "source_code": "\tpublic void afterTestMethod(TestContext testContext) {\n\t\texecuteSqlScripts(testContext, ExecutionPhase.AFTER_TEST_METHOD);\n\t}"
  },
  "org.springframework.test.context.jdbc.SqlScriptsTestExecutionListener#beforeTestMethod(testContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute SQL scripts configured via {@link Sql @Sql} for the supplied\n\t * {@link TestContext} <em>before</em> the current test method.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "void",
    "signature": "public void beforeTestMethod(TestContext testContext)",
    "source_code": "\tpublic void beforeTestMethod(TestContext testContext) {\n\t\texecuteSqlScripts(testContext, ExecutionPhase.BEFORE_TEST_METHOD);\n\t}"
  },
  "org.springframework.test.context.jdbc.SqlScriptsTestExecutionListener#getOrder()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns {@code 5000}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "int",
    "signature": "public int getOrder()",
    "source_code": "\tpublic final int getOrder() {\n\t\treturn 5000;\n\t}"
  },
  "org.springframework.test.context.jdbc.SqlScriptsTestExecutionListener#processAheadOfTime(runtimeHints,testClass,classLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Process the supplied test class and its methods and register run-time\n\t * hints for any SQL scripts configured or detected as classpath resources\n\t * via {@link Sql @Sql}.\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runtimeHints",
      "testClass",
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "void",
    "signature": "public void processAheadOfTime(RuntimeHints runtimeHints, Class<?> testClass, ClassLoader classLoader)",
    "source_code": "\tpublic void processAheadOfTime(RuntimeHints runtimeHints, Class<?> testClass, ClassLoader classLoader) {\n\t\tgetSqlAnnotationsFor(testClass).forEach(sql ->\n\t\t\tregisterClasspathResources(getScripts(sql, testClass, null, true), runtimeHints, classLoader));\n\t\tgetSqlMethods(testClass).forEach(testMethod ->\n\t\t\tgetSqlAnnotationsFor(testMethod).forEach(sql ->\n\t\t\t\tregisterClasspathResources(getScripts(sql, testClass, testMethod, false), runtimeHints, classLoader)));\n\t}"
  },
  "org.springframework.transaction.reactive.<unknown>#transactional(mono)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mono"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> transactional(Mono<T> mono)",
    "source_code": "\tpublic <T> Mono<T> transactional(Mono<T> mono) {\n\t\treturn TransactionContextManager.currentContext().flatMap(context -> {\n\t\t\tMono<ReactiveTransaction> status = this.transactionManager.getReactiveTransaction(this.transactionDefinition);\n\t\t\t// This is an around advice: Invoke the next interceptor in the chain.\n\t\t\t// This will normally result in a target object being invoked.\n\t\t\t// Need re-wrapping of ReactiveTransaction until we get hold of the exception\n\t\t\t// through usingWhen.\n\t\t\treturn status.flatMap(it -> Mono.usingWhen(Mono.just(it), ignore -> mono,\n\t\t\t\t\tthis.transactionManager::commit, (res, err) -> Mono.empty(), this.transactionManager::rollback)\n\t\t\t\t\t.onErrorResume(ex -> rollbackOnException(it, ex).then(Mono.error(ex))));\n\t\t})\n\t\t.contextWrite(TransactionContextManager.getOrCreateContext())\n\t\t.contextWrite(TransactionContextManager.getOrCreateContextHolder());\n\t}"
  },
  "org.springframework.ui.ConcurrentModel": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Implementation of the {@link Model} interface based on a {@link ConcurrentHashMap}\n * for use in concurrent scenarios.\n *\n * <p>Exposed to handler methods by Spring WebFlux, typically via a declaration of the\n * {@link Model} interface. There is typically no need to create it within user code.\n * If necessary a handler method can return a regular {@code java.util.Map},\n * likely a {@code java.util.ConcurrentMap}, for a pre-determined model.\n *\n * @author Rossen Stoyanchev\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 40
    },
    "signature": "public class ConcurrentModel",
    "source_code": "public class ConcurrentModel extends ConcurrentHashMap<String, Object> implements Model {\n\n\t/**\n\t * Construct a new, empty {@code ConcurrentModel}.\n\t */\n\tpublic ConcurrentModel() {\n\t}\n\n\t/**\n\t * Construct a new {@code ModelMap} containing the supplied attribute\n\t * under the supplied name.\n\t * @see #addAttribute(String, Object)\n\t */\n\tpublic ConcurrentModel(String attributeName, Object attributeValue) {\n\t\taddAttribute(attributeName, attributeValue);\n\t}\n\n\t/**\n\t * Construct a new {@code ModelMap} containing the supplied attribute.\n\t * Uses attribute name generation to generate the key for the supplied model\n\t * object.\n\t * @see #addAttribute(Object)\n\t */\n\tpublic ConcurrentModel(Object attributeValue) {\n\t\taddAttribute(attributeValue);\n\t}\n\n\n\t@Override\n\t@Nullable\n\tpublic Object put(String key, @Nullable Object value) {\n\t\tif (value != null) {\n\t\t\treturn super.put(key, value);\n\t\t}\n\t\telse {\n\t\t\treturn remove(key);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void putAll(Map<? extends String, ?> map) {\n\t\tfor (Map.Entry<? extends String, ?> entry : map.entrySet()) {\n\t\t\tput(entry.getKey(), entry.getValue());\n\t\t}\n\t}\n\n\t/**\n\t * Add the supplied attribute under the supplied name.\n\t * @param attributeName the name of the model attribute (never {@code null})\n\t * @param attributeValue the model attribute value (ignored if {@code null},\n\t * just removing an existing entry if any)\n\t */\n\t@Override\n\tpublic ConcurrentModel addAttribute(String attributeName, @Nullable Object attributeValue) {\n\t\tAssert.notNull(attributeName, \"Model attribute name must not be null\");\n\t\tput(attributeName, attributeValue);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add the supplied attribute to this {@code Map} using a\n\t * {@link org.springframework.core.Conventions#getVariableName generated name}.\n\t * <p><i>Note: Empty {@link Collection Collections} are not added to\n\t * the model when using this method because we cannot correctly determine\n\t * the true convention name. View code should check for {@code null} rather\n\t * than for empty collections as is already done by JSTL tags.</i>\n\t * @param attributeValue the model attribute value (never {@code null})\n\t */\n\t@Override\n\tpublic ConcurrentModel addAttribute(Object attributeValue) {\n\t\tAssert.notNull(attributeValue, \"Model attribute value must not be null\");\n\t\tif (attributeValue instanceof Collection<?> collection && collection.isEmpty()) {\n\t\t\treturn this;\n\t\t}\n\t\treturn addAttribute(Conventions.getVariableName(attributeValue), attributeValue);\n\t}\n\n\t/**\n\t * Copy all attributes in the supplied {@code Collection} into this\n\t * {@code Map}, using attribute name generation for each element.\n\t * @see #addAttribute(Object)\n\t */\n\t@Override\n\tpublic ConcurrentModel addAllAttributes(@Nullable Collection<?> attributeValues) {\n\t\tif (attributeValues != null) {\n\t\t\tfor (Object attributeValue : attributeValues) {\n\t\t\t\taddAttribute(attributeValue);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Copy all attributes in the supplied {@code Map} into this {@code Map}.\n\t * @see #addAttribute(String, Object)\n\t */\n\t@Override\n\tpublic ConcurrentModel addAllAttributes(@Nullable Map<String, ?> attributes) {\n\t\tif (attributes != null) {\n\t\t\tputAll(attributes);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Copy all attributes in the supplied {@code Map} into this {@code Map},\n\t * with existing objects of the same name taking precedence (i.e. not getting\n\t * replaced).\n\t */\n\t@Override\n\tpublic ConcurrentModel mergeAttributes(@Nullable Map<String, ?> attributes) {\n\t\tif (attributes != null) {\n\t\t\tattributes.forEach((key, value) -> {\n\t\t\t\tif (!containsKey(key)) {\n\t\t\t\t\tput(key, value);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Does this model contain an attribute of the given name?\n\t * @param attributeName the name of the model attribute (never {@code null})\n\t * @return whether this model contains a corresponding attribute\n\t */\n\t@Override\n\tpublic boolean containsAttribute(String attributeName) {\n\t\treturn containsKey(attributeName);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Object getAttribute(String attributeName) {\n\t\treturn get(attributeName);\n\t}\n\n\t@Override\n\tpublic Map<String, Object> asMap() {\n\t\treturn this;\n\t}\n\n}"
  },
  "org.springframework.ui.ConcurrentModel#addAllAttributes(Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy all attributes in the supplied {@code Map} into this {@code Map}.\n\t * @see #addAttribute(String, Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "ConcurrentModel",
    "signature": "public ConcurrentModel addAllAttributes(@Nullable Map<String, ?> attributes)",
    "source_code": "\tpublic ConcurrentModel addAllAttributes(@Nullable Map<String, ?> attributes) {\n\t\tif (attributes != null) {\n\t\t\tputAll(attributes);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.ui.ConcurrentModel#addAllAttributes(attributeValues)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy all attributes in the supplied {@code Collection} into this\n\t * {@code Map}, using attribute name generation for each element.\n\t * @see #addAttribute(Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeValues"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "ConcurrentModel",
    "signature": "public ConcurrentModel addAllAttributes(@Nullable Collection<?> attributeValues)",
    "source_code": "\tpublic ConcurrentModel addAllAttributes(@Nullable Collection<?> attributeValues) {\n\t\tif (attributeValues != null) {\n\t\t\tfor (Object attributeValue : attributeValues) {\n\t\t\t\taddAttribute(attributeValue);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.ui.ConcurrentModel#addAttribute(attributeName,attributeValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the supplied attribute under the supplied name.\n\t * @param attributeName the name of the model attribute (never {@code null})\n\t * @param attributeValue the model attribute value (ignored if {@code null},\n\t * just removing an existing entry if any)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "attributeValue"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "ConcurrentModel",
    "signature": "public ConcurrentModel addAttribute(String attributeName, @Nullable Object attributeValue)",
    "source_code": "\tpublic ConcurrentModel addAttribute(String attributeName, @Nullable Object attributeValue) {\n\t\tAssert.notNull(attributeName, \"Model attribute name must not be null\");\n\t\tput(attributeName, attributeValue);\n\t\treturn this;\n\t}"
  },
  "org.springframework.ui.ConcurrentModel#addAttribute(attributeValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the supplied attribute to this {@code Map} using a\n\t * {@link org.springframework.core.Conventions#getVariableName generated name}.\n\t * <p><i>Note: Empty {@link Collection Collections} are not added to\n\t * the model when using this method because we cannot correctly determine\n\t * the true convention name. View code should check for {@code null} rather\n\t * than for empty collections as is already done by JSTL tags.</i>\n\t * @param attributeValue the model attribute value (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeValue"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "ConcurrentModel",
    "signature": "public ConcurrentModel addAttribute(Object attributeValue)",
    "source_code": "\tpublic ConcurrentModel addAttribute(Object attributeValue) {\n\t\tAssert.notNull(attributeValue, \"Model attribute value must not be null\");\n\t\tif (attributeValue instanceof Collection<?> collection && collection.isEmpty()) {\n\t\t\treturn this;\n\t\t}\n\t\treturn addAttribute(Conventions.getVariableName(attributeValue), attributeValue);\n\t}"
  },
  "org.springframework.ui.ConcurrentModel#asMap()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "Object>",
    "signature": "public Object> asMap()",
    "source_code": "\tpublic Map<String, Object> asMap() {\n\t\treturn this;\n\t}"
  },
  "org.springframework.ui.ConcurrentModel#containsAttribute(attributeName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Does this model contain an attribute of the given name?\n\t * @param attributeName the name of the model attribute (never {@code null})\n\t * @return whether this model contains a corresponding attribute\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "boolean",
    "signature": "public boolean containsAttribute(String attributeName)",
    "source_code": "\tpublic boolean containsAttribute(String attributeName) {\n\t\treturn containsKey(attributeName);\n\t}"
  },
  "org.springframework.ui.ConcurrentModel#getAttribute(attributeName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "Object",
    "signature": "public Object getAttribute(String attributeName)",
    "source_code": "\tpublic Object getAttribute(String attributeName) {\n\t\treturn get(attributeName);\n\t}"
  },
  "org.springframework.ui.ConcurrentModel#mergeAttributes(Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy all attributes in the supplied {@code Map} into this {@code Map},\n\t * with existing objects of the same name taking precedence (i.e. not getting\n\t * replaced).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "ConcurrentModel",
    "signature": "public ConcurrentModel mergeAttributes(@Nullable Map<String, ?> attributes)",
    "source_code": "\tpublic ConcurrentModel mergeAttributes(@Nullable Map<String, ?> attributes) {\n\t\tif (attributes != null) {\n\t\t\tattributes.forEach((key, value) -> {\n\t\t\t\tif (!containsKey(key)) {\n\t\t\t\t\tput(key, value);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.ui.ConcurrentModel#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "Object",
    "signature": "public Object put(String key, @Nullable Object value)",
    "source_code": "\tpublic Object put(String key, @Nullable Object value) {\n\t\tif (value != null) {\n\t\t\treturn super.put(key, value);\n\t\t}\n\t\telse {\n\t\t\treturn remove(key);\n\t\t}\n\t}"
  },
  "org.springframework.ui.ConcurrentModel#putAll(String,map)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ?> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ?> map) {\n\t\tfor (Map.Entry<? extends String, ?> entry : map.entrySet()) {\n\t\t\tput(entry.getKey(), entry.getValue());\n\t\t}\n\t}"
  },
  "org.springframework.ui.ModelMap": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Implementation of {@link java.util.Map} for use when building model data for use\n * with UI tools. Supports chained calls and generation of model attribute names.\n *\n * <p>This class serves as generic model holder for Servlet MVC but is not tied to it.\n * Check out the {@link Model} interface for an interface variant.\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @since 2.0\n * @see Conventions#getVariableName\n * @see org.springframework.web.servlet.ModelAndView\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "signature": "public class ModelMap",
    "source_code": "public class ModelMap extends LinkedHashMap<String, Object> {\n\n\t/**\n\t * Construct a new, empty {@code ModelMap}.\n\t */\n\tpublic ModelMap() {\n\t}\n\n\t/**\n\t * Construct a new {@code ModelMap} containing the supplied attribute\n\t * under the supplied name.\n\t * @see #addAttribute(String, Object)\n\t */\n\tpublic ModelMap(String attributeName, @Nullable Object attributeValue) {\n\t\taddAttribute(attributeName, attributeValue);\n\t}\n\n\t/**\n\t * Construct a new {@code ModelMap} containing the supplied attribute.\n\t * Uses attribute name generation to generate the key for the supplied model\n\t * object.\n\t * @see #addAttribute(Object)\n\t */\n\tpublic ModelMap(Object attributeValue) {\n\t\taddAttribute(attributeValue);\n\t}\n\n\n\t/**\n\t * Add the supplied attribute under the supplied name.\n\t * @param attributeName the name of the model attribute (never {@code null})\n\t * @param attributeValue the model attribute value (can be {@code null})\n\t */\n\tpublic ModelMap addAttribute(String attributeName, @Nullable Object attributeValue) {\n\t\tAssert.notNull(attributeName, \"Model attribute name must not be null\");\n\t\tput(attributeName, attributeValue);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add the supplied attribute to this {@code Map} using a\n\t * {@link org.springframework.core.Conventions#getVariableName generated name}.\n\t * <p><i>Note: Empty {@link Collection Collections} are not added to\n\t * the model when using this method because we cannot correctly determine\n\t * the true convention name. View code should check for {@code null} rather\n\t * than for empty collections as is already done by JSTL tags.</i>\n\t * @param attributeValue the model attribute value (never {@code null})\n\t */\n\tpublic ModelMap addAttribute(Object attributeValue) {\n\t\tAssert.notNull(attributeValue, \"Model object must not be null\");\n\t\tif (attributeValue instanceof Collection<?> collection && collection.isEmpty()) {\n\t\t\treturn this;\n\t\t}\n\t\treturn addAttribute(Conventions.getVariableName(attributeValue), attributeValue);\n\t}\n\n\t/**\n\t * Copy all attributes in the supplied {@code Collection} into this\n\t * {@code Map}, using attribute name generation for each element.\n\t * @see #addAttribute(Object)\n\t */\n\tpublic ModelMap addAllAttributes(@Nullable Collection<?> attributeValues) {\n\t\tif (attributeValues != null) {\n\t\t\tfor (Object attributeValue : attributeValues) {\n\t\t\t\taddAttribute(attributeValue);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Copy all attributes in the supplied {@code Map} into this {@code Map}.\n\t * @see #addAttribute(String, Object)\n\t */\n\tpublic ModelMap addAllAttributes(@Nullable Map<String, ?> attributes) {\n\t\tif (attributes != null) {\n\t\t\tputAll(attributes);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Copy all attributes in the supplied {@code Map} into this {@code Map},\n\t * with existing objects of the same name taking precedence (i.e. not getting\n\t * replaced).\n\t */\n\tpublic ModelMap mergeAttributes(@Nullable Map<String, ?> attributes) {\n\t\tif (attributes != null) {\n\t\t\tattributes.forEach((key, value) -> {\n\t\t\t\tif (!containsKey(key)) {\n\t\t\t\t\tput(key, value);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Does this model contain an attribute of the given name?\n\t * @param attributeName the name of the model attribute (never {@code null})\n\t * @return whether this model contains a corresponding attribute\n\t */\n\tpublic boolean containsAttribute(String attributeName) {\n\t\treturn containsKey(attributeName);\n\t}\n\n\t/**\n\t * Return the attribute value for the given name, if any.\n\t * @param attributeName the name of the model attribute (never {@code null})\n\t * @return the corresponding attribute value, or {@code null} if none\n\t * @since 5.2\n\t */\n\t@Nullable\n\tpublic Object getAttribute(String attributeName) {\n\t\treturn get(attributeName);\n\t}\n\n}"
  },
  "org.springframework.ui.ModelMap#addAllAttributes(Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy all attributes in the supplied {@code Map} into this {@code Map}.\n\t * @see #addAttribute(String, Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "ModelMap",
    "signature": "public ModelMap addAllAttributes(@Nullable Map<String, ?> attributes)",
    "source_code": "\tpublic ModelMap addAllAttributes(@Nullable Map<String, ?> attributes) {\n\t\tif (attributes != null) {\n\t\t\tputAll(attributes);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.ui.ModelMap#addAllAttributes(attributeValues)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy all attributes in the supplied {@code Collection} into this\n\t * {@code Map}, using attribute name generation for each element.\n\t * @see #addAttribute(Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeValues"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "ModelMap",
    "signature": "public ModelMap addAllAttributes(@Nullable Collection<?> attributeValues)",
    "source_code": "\tpublic ModelMap addAllAttributes(@Nullable Collection<?> attributeValues) {\n\t\tif (attributeValues != null) {\n\t\t\tfor (Object attributeValue : attributeValues) {\n\t\t\t\taddAttribute(attributeValue);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.ui.ModelMap#addAttribute(attributeName,attributeValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the supplied attribute under the supplied name.\n\t * @param attributeName the name of the model attribute (never {@code null})\n\t * @param attributeValue the model attribute value (can be {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "attributeValue"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "ModelMap",
    "signature": "public ModelMap addAttribute(String attributeName, @Nullable Object attributeValue)",
    "source_code": "\tpublic ModelMap addAttribute(String attributeName, @Nullable Object attributeValue) {\n\t\tAssert.notNull(attributeName, \"Model attribute name must not be null\");\n\t\tput(attributeName, attributeValue);\n\t\treturn this;\n\t}"
  },
  "org.springframework.ui.ModelMap#addAttribute(attributeValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the supplied attribute to this {@code Map} using a\n\t * {@link org.springframework.core.Conventions#getVariableName generated name}.\n\t * <p><i>Note: Empty {@link Collection Collections} are not added to\n\t * the model when using this method because we cannot correctly determine\n\t * the true convention name. View code should check for {@code null} rather\n\t * than for empty collections as is already done by JSTL tags.</i>\n\t * @param attributeValue the model attribute value (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeValue"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "ModelMap",
    "signature": "public ModelMap addAttribute(Object attributeValue)",
    "source_code": "\tpublic ModelMap addAttribute(Object attributeValue) {\n\t\tAssert.notNull(attributeValue, \"Model object must not be null\");\n\t\tif (attributeValue instanceof Collection<?> collection && collection.isEmpty()) {\n\t\t\treturn this;\n\t\t}\n\t\treturn addAttribute(Conventions.getVariableName(attributeValue), attributeValue);\n\t}"
  },
  "org.springframework.ui.ModelMap#containsAttribute(attributeName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Does this model contain an attribute of the given name?\n\t * @param attributeName the name of the model attribute (never {@code null})\n\t * @return whether this model contains a corresponding attribute\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "boolean",
    "signature": "public boolean containsAttribute(String attributeName)",
    "source_code": "\tpublic boolean containsAttribute(String attributeName) {\n\t\treturn containsKey(attributeName);\n\t}"
  },
  "org.springframework.ui.ModelMap#getAttribute(attributeName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the attribute value for the given name, if any.\n\t * @param attributeName the name of the model attribute (never {@code null})\n\t * @return the corresponding attribute value, or {@code null} if none\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "Object",
    "signature": "public Object getAttribute(String attributeName)",
    "source_code": "\tpublic Object getAttribute(String attributeName) {\n\t\treturn get(attributeName);\n\t}"
  },
  "org.springframework.ui.ModelMap#mergeAttributes(Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy all attributes in the supplied {@code Map} into this {@code Map},\n\t * with existing objects of the same name taking precedence (i.e. not getting\n\t * replaced).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "ModelMap",
    "signature": "public ModelMap mergeAttributes(@Nullable Map<String, ?> attributes)",
    "source_code": "\tpublic ModelMap mergeAttributes(@Nullable Map<String, ?> attributes) {\n\t\tif (attributes != null) {\n\t\t\tattributes.forEach((key, value) -> {\n\t\t\t\tif (!containsKey(key)) {\n\t\t\t\t\tput(key, value);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.util.CollectionUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Miscellaneous collection utility methods.\n * Mainly for internal use within the framework.\n *\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Arjen Poutsma\n * @since 1.1.3\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "signature": "public class CollectionUtils",
    "source_code": "public abstract class CollectionUtils {\n\n\t/**\n\t * Default load factor for {@link HashMap}/{@link LinkedHashMap} variants.\n\t * @see #newHashMap(int)\n\t * @see #newLinkedHashMap(int)\n\t */\n\tstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n\n\t/**\n\t * Return {@code true} if the supplied Collection is {@code null} or empty.\n\t * Otherwise, return {@code false}.\n\t * @param collection the Collection to check\n\t * @return whether the given Collection is empty\n\t */\n\tpublic static boolean isEmpty(@Nullable Collection<?> collection) {\n\t\treturn (collection == null || collection.isEmpty());\n\t}\n\n\t/**\n\t * Return {@code true} if the supplied Map is {@code null} or empty.\n\t * Otherwise, return {@code false}.\n\t * @param map the Map to check\n\t * @return whether the given Map is empty\n\t */\n\tpublic static boolean isEmpty(@Nullable Map<?, ?> map) {\n\t\treturn (map == null || map.isEmpty());\n\t}\n\n\t/**\n\t * Instantiate a new {@link HashMap} with an initial capacity\n\t * that can accommodate the specified number of elements without\n\t * any immediate resize/rehash operations to be expected.\n\t * <p>This differs from the regular {@link HashMap} constructor\n\t * which takes an initial capacity relative to a load factor\n\t * but is effectively aligned with the JDK's\n\t * {@link java.util.concurrent.ConcurrentHashMap#ConcurrentHashMap(int)}.\n\t * @param expectedSize the expected number of elements (with a corresponding\n\t * capacity to be derived so that no resize/rehash operations are needed)\n\t * @since 5.3\n\t * @see #newLinkedHashMap(int)\n\t */\n\tpublic static <K, V> HashMap<K, V> newHashMap(int expectedSize) {\n\t\treturn new HashMap<>(computeMapInitialCapacity(expectedSize), DEFAULT_LOAD_FACTOR);\n\t}\n\n\t/**\n\t * Instantiate a new {@link LinkedHashMap} with an initial capacity\n\t * that can accommodate the specified number of elements without\n\t * any immediate resize/rehash operations to be expected.\n\t * <p>This differs from the regular {@link LinkedHashMap} constructor\n\t * which takes an initial capacity relative to a load factor but is\n\t * aligned with Spring's own {@link LinkedCaseInsensitiveMap} and\n\t * {@link LinkedMultiValueMap} constructor semantics as of 5.3.\n\t * @param expectedSize the expected number of elements (with a corresponding\n\t * capacity to be derived so that no resize/rehash operations are needed)\n\t * @since 5.3\n\t * @see #newHashMap(int)\n\t */\n\tpublic static <K, V> LinkedHashMap<K, V> newLinkedHashMap(int expectedSize) {\n\t\treturn new LinkedHashMap<>(computeMapInitialCapacity(expectedSize), DEFAULT_LOAD_FACTOR);\n\t}\n\n\tprivate static int computeMapInitialCapacity(int expectedSize) {\n\t\treturn (int) Math.ceil(expectedSize / (double) DEFAULT_LOAD_FACTOR);\n\t}\n\n\t/**\n\t * Convert the supplied array into a List. A primitive array gets converted\n\t * into a List of the appropriate wrapper type.\n\t * <p><b>NOTE:</b> Generally prefer the standard {@link Arrays#asList} method.\n\t * This {@code arrayToList} method is just meant to deal with an incoming Object\n\t * value that might be an {@code Object[]} or a primitive array at runtime.\n\t * <p>A {@code null} source value will be converted to an empty List.\n\t * @param source the (potentially primitive) array\n\t * @return the converted List result\n\t * @see ObjectUtils#toObjectArray(Object)\n\t * @see Arrays#asList(Object[])\n\t */\n\tpublic static List<?> arrayToList(@Nullable Object source) {\n\t\treturn Arrays.asList(ObjectUtils.toObjectArray(source));\n\t}\n\n\t/**\n\t * Merge the given array into the given Collection.\n\t * @param array the array to merge (may be {@code null})\n\t * @param collection the target Collection to merge the array into\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <E> void mergeArrayIntoCollection(@Nullable Object array, Collection<E> collection) {\n\t\tObject[] arr = ObjectUtils.toObjectArray(array);\n\t\tCollections.addAll(collection, (E[])arr);\n\t}\n\n\t/**\n\t * Merge the given Properties instance into the given Map,\n\t * copying all properties (key-value pairs) over.\n\t * <p>Uses {@code Properties.propertyNames()} to even catch\n\t * default properties linked into the original Properties instance.\n\t * @param props the Properties instance to merge (may be {@code null})\n\t * @param map the target Map to merge the properties into\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <K, V> void mergePropertiesIntoMap(@Nullable Properties props, Map<K, V> map) {\n\t\tif (props != null) {\n\t\t\tfor (Enumeration<?> en = props.propertyNames(); en.hasMoreElements();) {\n\t\t\t\tString key = (String) en.nextElement();\n\t\t\t\tObject value = props.get(key);\n\t\t\t\tif (value == null) {\n\t\t\t\t\t// Allow for defaults fallback or potentially overridden accessor...\n\t\t\t\t\tvalue = props.getProperty(key);\n\t\t\t\t}\n\t\t\t\tmap.put((K) key, (V) value);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Check whether the given Iterator contains the given element.\n\t * @param iterator the Iterator to check\n\t * @param element the element to look for\n\t * @return {@code true} if found, {@code false} otherwise\n\t */\n\tpublic static boolean contains(@Nullable Iterator<?> iterator, Object element) {\n\t\tif (iterator != null) {\n\t\t\twhile (iterator.hasNext()) {\n\t\t\t\tObject candidate = iterator.next();\n\t\t\t\tif (ObjectUtils.nullSafeEquals(candidate, element)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check whether the given Enumeration contains the given element.\n\t * @param enumeration the Enumeration to check\n\t * @param element the element to look for\n\t * @return {@code true} if found, {@code false} otherwise\n\t */\n\tpublic static boolean contains(@Nullable Enumeration<?> enumeration, Object element) {\n\t\tif (enumeration != null) {\n\t\t\twhile (enumeration.hasMoreElements()) {\n\t\t\t\tObject candidate = enumeration.nextElement();\n\t\t\t\tif (ObjectUtils.nullSafeEquals(candidate, element)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check whether the given Collection contains the given element instance.\n\t * <p>Enforces the given instance to be present, rather than returning\n\t * {@code true} for an equal element as well.\n\t * @param collection the Collection to check\n\t * @param element the element to look for\n\t * @return {@code true} if found, {@code false} otherwise\n\t */\n\tpublic static boolean containsInstance(@Nullable Collection<?> collection, Object element) {\n\t\tif (collection != null) {\n\t\t\tfor (Object candidate : collection) {\n\t\t\t\tif (candidate == element) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Return {@code true} if any element in '{@code candidates}' is\n\t * contained in '{@code source}'; otherwise returns {@code false}.\n\t * @param source the source Collection\n\t * @param candidates the candidates to search for\n\t * @return whether any of the candidates has been found\n\t */\n\tpublic static boolean containsAny(Collection<?> source, Collection<?> candidates) {\n\t\treturn findFirstMatch(source, candidates) != null;\n\t}\n\n\t/**\n\t * Return the first element in '{@code candidates}' that is contained in\n\t * '{@code source}'. If no element in '{@code candidates}' is present in\n\t * '{@code source}' returns {@code null}. Iteration order is\n\t * {@link Collection} implementation specific.\n\t * @param source the source Collection\n\t * @param candidates the candidates to search for\n\t * @return the first present object, or {@code null} if not found\n\t */\n\t@Nullable\n\tpublic static <E> E findFirstMatch(Collection<?> source, Collection<E> candidates) {\n\t\tif (isEmpty(source) || isEmpty(candidates)) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (E candidate : candidates) {\n\t\t\tif (source.contains(candidate)) {\n\t\t\t\treturn candidate;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Find a single value of the given type in the given Collection.\n\t * @param collection the Collection to search\n\t * @param type the type to look for\n\t * @return a value of the given type found if there is a clear match,\n\t * or {@code null} if none or more than one such value found\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\t@Nullable\n\tpublic static <T> T findValueOfType(Collection<?> collection, @Nullable Class<T> type) {\n\t\tif (isEmpty(collection)) {\n\t\t\treturn null;\n\t\t}\n\t\tT value = null;\n\t\tfor (Object element : collection) {\n\t\t\tif (type == null || type.isInstance(element)) {\n\t\t\t\tif (value != null) {\n\t\t\t\t\t// More than one value found... no clear single value.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tvalue = (T) element;\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}\n\n\t/**\n\t * Find a single value of one of the given types in the given Collection:\n\t * searching the Collection for a value of the first type, then\n\t * searching for a value of the second type, etc.\n\t * @param collection the collection to search\n\t * @param types the types to look for, in prioritized order\n\t * @return a value of one of the given types found if there is a clear match,\n\t * or {@code null} if none or more than one such value found\n\t */\n\t@Nullable\n\tpublic static Object findValueOfType(Collection<?> collection, Class<?>[] types) {\n\t\tif (isEmpty(collection) || ObjectUtils.isEmpty(types)) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (Class<?> type : types) {\n\t\t\tObject value = findValueOfType(collection, type);\n\t\t\tif (value != null) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Determine whether the given Collection only contains a single unique object.\n\t * @param collection the Collection to check\n\t * @return {@code true} if the collection contains a single reference or\n\t * multiple references to the same instance, {@code false} otherwise\n\t */\n\tpublic static boolean hasUniqueObject(Collection<?> collection) {\n\t\tif (isEmpty(collection)) {\n\t\t\treturn false;\n\t\t}\n\t\tboolean hasCandidate = false;\n\t\tObject candidate = null;\n\t\tfor (Object elem : collection) {\n\t\t\tif (!hasCandidate) {\n\t\t\t\thasCandidate = true;\n\t\t\t\tcandidate = elem;\n\t\t\t}\n\t\t\telse if (candidate != elem) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Find the common element type of the given Collection, if any.\n\t * @param collection the Collection to check\n\t * @return the common element type, or {@code null} if no clear\n\t * common type has been found (or the collection was empty)\n\t */\n\t@Nullable\n\tpublic static Class<?> findCommonElementType(Collection<?> collection) {\n\t\tif (isEmpty(collection)) {\n\t\t\treturn null;\n\t\t}\n\t\tClass<?> candidate = null;\n\t\tfor (Object val : collection) {\n\t\t\tif (val != null) {\n\t\t\t\tif (candidate == null) {\n\t\t\t\t\tcandidate = val.getClass();\n\t\t\t\t}\n\t\t\t\telse if (candidate != val.getClass()) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn candidate;\n\t}\n\n\t/**\n\t * Retrieve the first element of the given Set, using {@link SortedSet#first()}\n\t * or otherwise using the iterator.\n\t * @param set the Set to check (may be {@code null} or empty)\n\t * @return the first element, or {@code null} if none\n\t * @since 5.2.3\n\t * @see SortedSet\n\t * @see LinkedHashMap#keySet()\n\t * @see java.util.LinkedHashSet\n\t */\n\t@Nullable\n\tpublic static <T> T firstElement(@Nullable Set<T> set) {\n\t\tif (isEmpty(set)) {\n\t\t\treturn null;\n\t\t}\n\t\tif (set instanceof SortedSet<T> sortedSet) {\n\t\t\treturn sortedSet.first();\n\t\t}\n\n\t\tIterator<T> it = set.iterator();\n\t\tT first = null;\n\t\tif (it.hasNext()) {\n\t\t\tfirst = it.next();\n\t\t}\n\t\treturn first;\n\t}\n\n\t/**\n\t * Retrieve the first element of the given List, accessing the zero index.\n\t * @param list the List to check (may be {@code null} or empty)\n\t * @return the first element, or {@code null} if none\n\t * @since 5.2.3\n\t */\n\t@Nullable\n\tpublic static <T> T firstElement(@Nullable List<T> list) {\n\t\tif (isEmpty(list)) {\n\t\t\treturn null;\n\t\t}\n\t\treturn list.get(0);\n\t}\n\n\t/**\n\t * Retrieve the last element of the given Set, using {@link SortedSet#last()}\n\t * or otherwise iterating over all elements (assuming a linked set).\n\t * @param set the Set to check (may be {@code null} or empty)\n\t * @return the last element, or {@code null} if none\n\t * @since 5.0.3\n\t * @see SortedSet\n\t * @see LinkedHashMap#keySet()\n\t * @see java.util.LinkedHashSet\n\t */\n\t@Nullable\n\tpublic static <T> T lastElement(@Nullable Set<T> set) {\n\t\tif (isEmpty(set)) {\n\t\t\treturn null;\n\t\t}\n\t\tif (set instanceof SortedSet<T> sortedSet) {\n\t\t\treturn sortedSet.last();\n\t\t}\n\n\t\t// Full iteration necessary...\n\t\tIterator<T> it = set.iterator();\n\t\tT last = null;\n\t\twhile (it.hasNext()) {\n\t\t\tlast = it.next();\n\t\t}\n\t\treturn last;\n\t}\n\n\t/**\n\t * Retrieve the last element of the given List, accessing the highest index.\n\t * @param list the List to check (may be {@code null} or empty)\n\t * @return the last element, or {@code null} if none\n\t * @since 5.0.3\n\t */\n\t@Nullable\n\tpublic static <T> T lastElement(@Nullable List<T> list) {\n\t\tif (isEmpty(list)) {\n\t\t\treturn null;\n\t\t}\n\t\treturn list.get(list.size() - 1);\n\t}\n\n\t/**\n\t * Marshal the elements from the given enumeration into an array of the given type.\n\t * Enumeration elements must be assignable to the type of the given array. The array\n\t * returned will be a different instance than the array given.\n\t */\n\tpublic static <A, E extends A> A[] toArray(Enumeration<E> enumeration, A[] array) {\n\t\tArrayList<A> elements = new ArrayList<>();\n\t\twhile (enumeration.hasMoreElements()) {\n\t\t\telements.add(enumeration.nextElement());\n\t\t}\n\t\treturn elements.toArray(array);\n\t}\n\n\t/**\n\t * Adapt an {@link Enumeration} to an {@link Iterator}.\n\t * @param enumeration the original {@code Enumeration}\n\t * @return the adapted {@code Iterator}\n\t */\n\tpublic static <E> Iterator<E> toIterator(@Nullable Enumeration<E> enumeration) {\n\t\treturn (enumeration != null ? enumeration.asIterator() : Collections.emptyIterator());\n\t}\n\n\t/**\n\t * Adapt a {@code Map<K, List<V>>} to an {@code MultiValueMap<K, V>}.\n\t * @param targetMap the original map\n\t * @return the adapted multi-value map (wrapping the original map)\n\t * @since 3.1\n\t */\n\tpublic static <K, V> MultiValueMap<K, V> toMultiValueMap(Map<K, List<V>> targetMap) {\n\t\treturn new MultiValueMapAdapter<>(targetMap);\n\t}\n\n\t/**\n\t * Return an unmodifiable view of the specified multi-value map.\n\t * @param targetMap the map for which an unmodifiable view is to be returned.\n\t * @return an unmodifiable view of the specified multi-value map\n\t * @since 3.1\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <K, V> MultiValueMap<K, V> unmodifiableMultiValueMap(\n\t\t\tMultiValueMap<? extends K, ? extends V> targetMap) {\n\n\t\tAssert.notNull(targetMap, \"'targetMap' must not be null\");\n\t\tif (targetMap instanceof UnmodifiableMultiValueMap) {\n\t\t\treturn (MultiValueMap<K, V>) targetMap;\n\t\t}\n\t\treturn new UnmodifiableMultiValueMap<>(targetMap);\n\t}\n\n\n}"
  },
  "org.springframework.util.CollectionUtils#contains(enumeration,element)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given Enumeration contains the given element.\n\t * @param enumeration the Enumeration to check\n\t * @param element the element to look for\n\t * @return {@code true} if found, {@code false} otherwise\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "enumeration",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "boolean",
    "signature": "public boolean contains(@Nullable Enumeration<?> enumeration, Object element)",
    "source_code": "\tpublic static boolean contains(@Nullable Enumeration<?> enumeration, Object element) {\n\t\tif (enumeration != null) {\n\t\t\twhile (enumeration.hasMoreElements()) {\n\t\t\t\tObject candidate = enumeration.nextElement();\n\t\t\t\tif (ObjectUtils.nullSafeEquals(candidate, element)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.util.CollectionUtils#contains(iterator,element)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given Iterator contains the given element.\n\t * @param iterator the Iterator to check\n\t * @param element the element to look for\n\t * @return {@code true} if found, {@code false} otherwise\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "iterator",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "boolean",
    "signature": "public boolean contains(@Nullable Iterator<?> iterator, Object element)",
    "source_code": "\tpublic static boolean contains(@Nullable Iterator<?> iterator, Object element) {\n\t\tif (iterator != null) {\n\t\t\twhile (iterator.hasNext()) {\n\t\t\t\tObject candidate = iterator.next();\n\t\t\t\tif (ObjectUtils.nullSafeEquals(candidate, element)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.util.CollectionUtils#containsAny(source,candidates)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return {@code true} if any element in '{@code candidates}' is\n\t * contained in '{@code source}'; otherwise returns {@code false}.\n\t * @param source the source Collection\n\t * @param candidates the candidates to search for\n\t * @return whether any of the candidates has been found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "candidates"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "boolean",
    "signature": "public boolean containsAny(Collection<?> source, Collection<?> candidates)",
    "source_code": "\tpublic static boolean containsAny(Collection<?> source, Collection<?> candidates) {\n\t\treturn findFirstMatch(source, candidates) != null;\n\t}"
  },
  "org.springframework.util.CollectionUtils#containsInstance(collection,element)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given Collection contains the given element instance.\n\t * <p>Enforces the given instance to be present, rather than returning\n\t * {@code true} for an equal element as well.\n\t * @param collection the Collection to check\n\t * @param element the element to look for\n\t * @return {@code true} if found, {@code false} otherwise\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collection",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "boolean",
    "signature": "public boolean containsInstance(@Nullable Collection<?> collection, Object element)",
    "source_code": "\tpublic static boolean containsInstance(@Nullable Collection<?> collection, Object element) {\n\t\tif (collection != null) {\n\t\t\tfor (Object candidate : collection) {\n\t\t\t\tif (candidate == element) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.util.CollectionUtils#findFirstMatch(source,candidates)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the first element in '{@code candidates}' that is contained in\n\t * '{@code source}'. If no element in '{@code candidates}' is present in\n\t * '{@code source}' returns {@code null}. Iteration order is\n\t * {@link Collection} implementation specific.\n\t * @param source the source Collection\n\t * @param candidates the candidates to search for\n\t * @return the first present object, or {@code null} if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "candidates"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "E",
    "signature": "public E findFirstMatch(Collection<?> source, Collection<E> candidates)",
    "source_code": "\tpublic static <E> E findFirstMatch(Collection<?> source, Collection<E> candidates) {\n\t\tif (isEmpty(source) || isEmpty(candidates)) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (E candidate : candidates) {\n\t\t\tif (source.contains(candidate)) {\n\t\t\t\treturn candidate;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.util.CollectionUtils#findValueOfType(collection,type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a single value of the given type in the given Collection.\n\t * @param collection the Collection to search\n\t * @param type the type to look for\n\t * @return a value of the given type found if there is a clear match,\n\t * or {@code null} if none or more than one such value found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collection",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "T",
    "signature": "public T findValueOfType(Collection<?> collection, @Nullable Class<T> type)",
    "source_code": "\tpublic static <T> T findValueOfType(Collection<?> collection, @Nullable Class<T> type) {\n\t\tif (isEmpty(collection)) {\n\t\t\treturn null;\n\t\t}\n\t\tT value = null;\n\t\tfor (Object element : collection) {\n\t\t\tif (type == null || type.isInstance(element)) {\n\t\t\t\tif (value != null) {\n\t\t\t\t\t// More than one value found... no clear single value.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tvalue = (T) element;\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}"
  },
  "org.springframework.util.CollectionUtils#findValueOfType(collection,types)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a single value of one of the given types in the given Collection:\n\t * searching the Collection for a value of the first type, then\n\t * searching for a value of the second type, etc.\n\t * @param collection the collection to search\n\t * @param types the types to look for, in prioritized order\n\t * @return a value of one of the given types found if there is a clear match,\n\t * or {@code null} if none or more than one such value found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collection",
      "types"
    ],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "Object",
    "signature": "public Object findValueOfType(Collection<?> collection, Class<?>[] types)",
    "source_code": "\tpublic static Object findValueOfType(Collection<?> collection, Class<?>[] types) {\n\t\tif (isEmpty(collection) || ObjectUtils.isEmpty(types)) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (Class<?> type : types) {\n\t\t\tObject value = findValueOfType(collection, type);\n\t\t\tif (value != null) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.util.CollectionUtils#firstElement(list)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the first element of the given List, accessing the zero index.\n\t * @param list the List to check (may be {@code null} or empty)\n\t * @return the first element, or {@code null} if none\n\t * @since 5.2.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "list"
    ],
    "position": {
      "column": 1,
      "line": 383
    },
    "return": "T",
    "signature": "public T firstElement(@Nullable List<T> list)",
    "source_code": "\tpublic static <T> T firstElement(@Nullable List<T> list) {\n\t\tif (isEmpty(list)) {\n\t\t\treturn null;\n\t\t}\n\t\treturn list.get(0);\n\t}"
  },
  "org.springframework.util.CollectionUtils#firstElement(set)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the first element of the given Set, using {@link SortedSet#first()}\n\t * or otherwise using the iterator.\n\t * @param set the Set to check (may be {@code null} or empty)\n\t * @return the first element, or {@code null} if none\n\t * @since 5.2.3\n\t * @see SortedSet\n\t * @see LinkedHashMap#keySet()\n\t * @see java.util.LinkedHashSet\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "set"
    ],
    "position": {
      "column": 1,
      "line": 360
    },
    "return": "T",
    "signature": "public T firstElement(@Nullable Set<T> set)",
    "source_code": "\tpublic static <T> T firstElement(@Nullable Set<T> set) {\n\t\tif (isEmpty(set)) {\n\t\t\treturn null;\n\t\t}\n\t\tif (set instanceof SortedSet<T> sortedSet) {\n\t\t\treturn sortedSet.first();\n\t\t}\n\n\t\tIterator<T> it = set.iterator();\n\t\tT first = null;\n\t\tif (it.hasNext()) {\n\t\t\tfirst = it.next();\n\t\t}\n\t\treturn first;\n\t}"
  },
  "org.springframework.util.CollectionUtils#hasUniqueObject(collection)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given Collection only contains a single unique object.\n\t * @param collection the Collection to check\n\t * @return {@code true} if the collection contains a single reference or\n\t * multiple references to the same instance, {@code false} otherwise\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collection"
    ],
    "position": {
      "column": 1,
      "line": 306
    },
    "return": "boolean",
    "signature": "public boolean hasUniqueObject(Collection<?> collection)",
    "source_code": "\tpublic static boolean hasUniqueObject(Collection<?> collection) {\n\t\tif (isEmpty(collection)) {\n\t\t\treturn false;\n\t\t}\n\t\tboolean hasCandidate = false;\n\t\tObject candidate = null;\n\t\tfor (Object elem : collection) {\n\t\t\tif (!hasCandidate) {\n\t\t\t\thasCandidate = true;\n\t\t\t\tcandidate = elem;\n\t\t\t}\n\t\t\telse if (candidate != elem) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.util.CollectionUtils#isEmpty(Map<?,map)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return {@code true} if the supplied Map is {@code null} or empty.\n\t * Otherwise, return {@code false}.\n\t * @param map the Map to check\n\t * @return whether the given Map is empty\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "boolean",
    "signature": "public boolean isEmpty(@Nullable Map<?, ?> map)",
    "source_code": "\tpublic static boolean isEmpty(@Nullable Map<?, ?> map) {\n\t\treturn (map == null || map.isEmpty());\n\t}"
  },
  "org.springframework.util.CollectionUtils#isEmpty(collection)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return {@code true} if the supplied Collection is {@code null} or empty.\n\t * Otherwise, return {@code false}.\n\t * @param collection the Collection to check\n\t * @return whether the given Collection is empty\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collection"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "boolean",
    "signature": "public boolean isEmpty(@Nullable Collection<?> collection)",
    "source_code": "\tpublic static boolean isEmpty(@Nullable Collection<?> collection) {\n\t\treturn (collection == null || collection.isEmpty());\n\t}"
  },
  "org.springframework.util.CollectionUtils#lastElement(list)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the last element of the given List, accessing the highest index.\n\t * @param list the List to check (may be {@code null} or empty)\n\t * @return the last element, or {@code null} if none\n\t * @since 5.0.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "list"
    ],
    "position": {
      "column": 1,
      "line": 425
    },
    "return": "T",
    "signature": "public T lastElement(@Nullable List<T> list)",
    "source_code": "\tpublic static <T> T lastElement(@Nullable List<T> list) {\n\t\tif (isEmpty(list)) {\n\t\t\treturn null;\n\t\t}\n\t\treturn list.get(list.size() - 1);\n\t}"
  },
  "org.springframework.util.CollectionUtils#lastElement(set)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the last element of the given Set, using {@link SortedSet#last()}\n\t * or otherwise iterating over all elements (assuming a linked set).\n\t * @param set the Set to check (may be {@code null} or empty)\n\t * @return the last element, or {@code null} if none\n\t * @since 5.0.3\n\t * @see SortedSet\n\t * @see LinkedHashMap#keySet()\n\t * @see java.util.LinkedHashSet\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "set"
    ],
    "position": {
      "column": 1,
      "line": 401
    },
    "return": "T",
    "signature": "public T lastElement(@Nullable Set<T> set)",
    "source_code": "\tpublic static <T> T lastElement(@Nullable Set<T> set) {\n\t\tif (isEmpty(set)) {\n\t\t\treturn null;\n\t\t}\n\t\tif (set instanceof SortedSet<T> sortedSet) {\n\t\t\treturn sortedSet.last();\n\t\t}\n\n\t\t// Full iteration necessary...\n\t\tIterator<T> it = set.iterator();\n\t\tT last = null;\n\t\twhile (it.hasNext()) {\n\t\t\tlast = it.next();\n\t\t}\n\t\treturn last;\n\t}"
  },
  "org.springframework.util.CollectionUtils#mergeArrayIntoCollection(array,collection)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Merge the given array into the given Collection.\n\t * @param array the array to merge (may be {@code null})\n\t * @param collection the target Collection to merge the array into\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array",
      "collection"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "void",
    "signature": "public void mergeArrayIntoCollection(@Nullable Object array, Collection<E> collection)",
    "source_code": "\tpublic static <E> void mergeArrayIntoCollection(@Nullable Object array, Collection<E> collection) {\n\t\tObject[] arr = ObjectUtils.toObjectArray(array);\n\t\tCollections.addAll(collection, (E[])arr);\n\t}"
  },
  "org.springframework.util.CollectionUtils#mergePropertiesIntoMap(props,Map<K,map)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Merge the given Properties instance into the given Map,\n\t * copying all properties (key-value pairs) over.\n\t * <p>Uses {@code Properties.propertyNames()} to even catch\n\t * default properties linked into the original Properties instance.\n\t * @param props the Properties instance to merge (may be {@code null})\n\t * @param map the target Map to merge the properties into\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "props",
      "Map<K",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "public void mergePropertiesIntoMap(@Nullable Properties props, Map<K, V> map)",
    "source_code": "\tpublic static <K, V> void mergePropertiesIntoMap(@Nullable Properties props, Map<K, V> map) {\n\t\tif (props != null) {\n\t\t\tfor (Enumeration<?> en = props.propertyNames(); en.hasMoreElements();) {\n\t\t\t\tString key = (String) en.nextElement();\n\t\t\t\tObject value = props.get(key);\n\t\t\t\tif (value == null) {\n\t\t\t\t\t// Allow for defaults fallback or potentially overridden accessor...\n\t\t\t\t\tvalue = props.getProperty(key);\n\t\t\t\t}\n\t\t\t\tmap.put((K) key, (V) value);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.CollectionUtils#newHashMap(expectedSize)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Instantiate a new {@link HashMap} with an initial capacity\n\t * that can accommodate the specified number of elements without\n\t * any immediate resize/rehash operations to be expected.\n\t * <p>This differs from the regular {@link HashMap} constructor\n\t * which takes an initial capacity relative to a load factor\n\t * but is effectively aligned with the JDK's\n\t * {@link java.util.concurrent.ConcurrentHashMap#ConcurrentHashMap(int)}.\n\t * @param expectedSize the expected number of elements (with a corresponding\n\t * capacity to be derived so that no resize/rehash operations are needed)\n\t * @since 5.3\n\t * @see #newLinkedHashMap(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedSize"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "V>",
    "signature": "public V> newHashMap(int expectedSize)",
    "source_code": "\tpublic static <K, V> HashMap<K, V> newHashMap(int expectedSize) {\n\t\treturn new HashMap<>(computeMapInitialCapacity(expectedSize), DEFAULT_LOAD_FACTOR);\n\t}"
  },
  "org.springframework.util.CollectionUtils#newLinkedHashMap(expectedSize)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Instantiate a new {@link LinkedHashMap} with an initial capacity\n\t * that can accommodate the specified number of elements without\n\t * any immediate resize/rehash operations to be expected.\n\t * <p>This differs from the regular {@link LinkedHashMap} constructor\n\t * which takes an initial capacity relative to a load factor but is\n\t * aligned with Spring's own {@link LinkedCaseInsensitiveMap} and\n\t * {@link LinkedMultiValueMap} constructor semantics as of 5.3.\n\t * @param expectedSize the expected number of elements (with a corresponding\n\t * capacity to be derived so that no resize/rehash operations are needed)\n\t * @since 5.3\n\t * @see #newHashMap(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedSize"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "V>",
    "signature": "public V> newLinkedHashMap(int expectedSize)",
    "source_code": "\tpublic static <K, V> LinkedHashMap<K, V> newLinkedHashMap(int expectedSize) {\n\t\treturn new LinkedHashMap<>(computeMapInitialCapacity(expectedSize), DEFAULT_LOAD_FACTOR);\n\t}"
  },
  "org.springframework.util.CollectionUtils#toArray(enumeration,array)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Marshal the elements from the given enumeration into an array of the given type.\n\t * Enumeration elements must be assignable to the type of the given array. The array\n\t * returned will be a different instance than the array given.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "enumeration",
      "array"
    ],
    "position": {
      "column": 1,
      "line": 437
    },
    "return": "A[]",
    "signature": "public A[] toArray(Enumeration<E> enumeration, A[] array)",
    "source_code": "\tpublic static <A, E extends A> A[] toArray(Enumeration<E> enumeration, A[] array) {\n\t\tArrayList<A> elements = new ArrayList<>();\n\t\twhile (enumeration.hasMoreElements()) {\n\t\t\telements.add(enumeration.nextElement());\n\t\t}\n\t\treturn elements.toArray(array);\n\t}"
  },
  "org.springframework.util.CollectionUtils#toIterator(enumeration)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Adapt an {@link Enumeration} to an {@link Iterator}.\n\t * @param enumeration the original {@code Enumeration}\n\t * @return the adapted {@code Iterator}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "enumeration"
    ],
    "position": {
      "column": 1,
      "line": 450
    },
    "return": "Iterator<E>",
    "signature": "public Iterator<E> toIterator(@Nullable Enumeration<E> enumeration)",
    "source_code": "\tpublic static <E> Iterator<E> toIterator(@Nullable Enumeration<E> enumeration) {\n\t\treturn (enumeration != null ? enumeration.asIterator() : Collections.emptyIterator());\n\t}"
  },
  "org.springframework.util.CollectionUtils#toMultiValueMap(Map<K,targetMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Adapt a {@code Map<K, List<V>>} to an {@code MultiValueMap<K, V>}.\n\t * @param targetMap the original map\n\t * @return the adapted multi-value map (wrapping the original map)\n\t * @since 3.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<K",
      "targetMap"
    ],
    "position": {
      "column": 1,
      "line": 460
    },
    "return": "V>",
    "signature": "public V> toMultiValueMap(Map<K, List<V>> targetMap)",
    "source_code": "\tpublic static <K, V> MultiValueMap<K, V> toMultiValueMap(Map<K, List<V>> targetMap) {\n\t\treturn new MultiValueMapAdapter<>(targetMap);\n\t}"
  },
  "org.springframework.util.CollectionUtils#unmodifiableMultiValueMap(K,targetMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return an unmodifiable view of the specified multi-value map.\n\t * @param targetMap the map for which an unmodifiable view is to be returned.\n\t * @return an unmodifiable view of the specified multi-value map\n\t * @since 3.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "K",
      "targetMap"
    ],
    "position": {
      "column": 1,
      "line": 471
    },
    "return": "V>",
    "signature": "public V> unmodifiableMultiValueMap(MultiValueMap<? extends K, ? extends V> targetMap)",
    "source_code": "\tpublic static <K, V> MultiValueMap<K, V> unmodifiableMultiValueMap("
  },
  "org.springframework.util.StringUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Miscellaneous {@link String} utility methods.\n *\n * <p>Mainly for internal use within the framework; consider\n * <a href=\"https://commons.apache.org/proper/commons-lang/\">Apache's Commons Lang</a>\n * for a more comprehensive suite of {@code String} utilities.\n *\n * <p>This class delivers some simple functionality that should really be\n * provided by the core Java {@link String} and {@link StringBuilder}\n * classes. It also provides easy-to-use methods to convert between\n * delimited strings, such as CSV strings, and collections and arrays.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @author Rick Evans\n * @author Arjen Poutsma\n * @author Sam Brannen\n * @author Brian Clozel\n * @since 16 April 2001\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "signature": "public class StringUtils",
    "source_code": "public abstract class StringUtils {\n\n\tprivate static final String[] EMPTY_STRING_ARRAY = {};\n\n\tprivate static final String FOLDER_SEPARATOR = \"/\";\n\n\tprivate static final char FOLDER_SEPARATOR_CHAR = '/';\n\n\tprivate static final String WINDOWS_FOLDER_SEPARATOR = \"\\\\\";\n\n\tprivate static final String TOP_PATH = \"..\";\n\n\tprivate static final String CURRENT_PATH = \".\";\n\n\tprivate static final char EXTENSION_SEPARATOR = '.';\n\n\n\t//---------------------------------------------------------------------\n\t// General convenience methods for working with Strings\n\t//---------------------------------------------------------------------\n\n\t/**\n\t * Check whether the given object (possibly a {@code String}) is empty.\n\t * This is effectively a shortcut for {@code !hasLength(String)}.\n\t * <p>This method accepts any Object as an argument, comparing it to\n\t * {@code null} and the empty String. As a consequence, this method\n\t * will never return {@code true} for a non-null non-String object.\n\t * <p>The Object signature is useful for general attribute handling code\n\t * that commonly deals with Strings but generally has to iterate over\n\t * Objects since attributes may e.g. be primitive value objects as well.\n\t * <p><b>Note: If the object is typed to {@code String} upfront, prefer\n\t * {@link #hasLength(String)} or {@link #hasText(String)} instead.</b>\n\t * @param str the candidate object (possibly a {@code String})\n\t * @since 3.2.1\n\t * @deprecated as of 5.3, in favor of {@link #hasLength(String)} and\n\t * {@link #hasText(String)} (or {@link ObjectUtils#isEmpty(Object)})\n\t */\n\t@Deprecated\n\tpublic static boolean isEmpty(@Nullable Object str) {\n\t\treturn (str == null || \"\".equals(str));\n\t}\n\n\t/**\n\t * Check that the given {@code CharSequence} is neither {@code null} nor\n\t * of length 0.\n\t * <p>Note: this method returns {@code true} for a {@code CharSequence}\n\t * that purely consists of whitespace.\n\t * <p><pre class=\"code\">\n\t * StringUtils.hasLength(null) = false\n\t * StringUtils.hasLength(\"\") = false\n\t * StringUtils.hasLength(\" \") = true\n\t * StringUtils.hasLength(\"Hello\") = true\n\t * </pre>\n\t * @param str the {@code CharSequence} to check (may be {@code null})\n\t * @return {@code true} if the {@code CharSequence} is not {@code null} and has length\n\t * @see #hasLength(String)\n\t * @see #hasText(CharSequence)\n\t */\n\tpublic static boolean hasLength(@Nullable CharSequence str) {\n\t\treturn (str != null && str.length() > 0);\n\t}\n\n\t/**\n\t * Check that the given {@code String} is neither {@code null} nor of length 0.\n\t * <p>Note: this method returns {@code true} for a {@code String} that\n\t * purely consists of whitespace.\n\t * @param str the {@code String} to check (may be {@code null})\n\t * @return {@code true} if the {@code String} is not {@code null} and has length\n\t * @see #hasLength(CharSequence)\n\t * @see #hasText(String)\n\t */\n\tpublic static boolean hasLength(@Nullable String str) {\n\t\treturn (str != null && !str.isEmpty());\n\t}\n\n\t/**\n\t * Check whether the given {@code CharSequence} contains actual <em>text</em>.\n\t * <p>More specifically, this method returns {@code true} if the\n\t * {@code CharSequence} is not {@code null}, its length is greater than\n\t * 0, and it contains at least one non-whitespace character.\n\t * <p><pre class=\"code\">\n\t * StringUtils.hasText(null) = false\n\t * StringUtils.hasText(\"\") = false\n\t * StringUtils.hasText(\" \") = false\n\t * StringUtils.hasText(\"12345\") = true\n\t * StringUtils.hasText(\" 12345 \") = true\n\t * </pre>\n\t * @param str the {@code CharSequence} to check (may be {@code null})\n\t * @return {@code true} if the {@code CharSequence} is not {@code null},\n\t * its length is greater than 0, and it does not contain whitespace only\n\t * @see #hasText(String)\n\t * @see #hasLength(CharSequence)\n\t * @see Character#isWhitespace\n\t */\n\tpublic static boolean hasText(@Nullable CharSequence str) {\n\t\treturn (str != null && str.length() > 0 && containsText(str));\n\t}\n\n\t/**\n\t * Check whether the given {@code String} contains actual <em>text</em>.\n\t * <p>More specifically, this method returns {@code true} if the\n\t * {@code String} is not {@code null}, its length is greater than 0,\n\t * and it contains at least one non-whitespace character.\n\t * @param str the {@code String} to check (may be {@code null})\n\t * @return {@code true} if the {@code String} is not {@code null}, its\n\t * length is greater than 0, and it does not contain whitespace only\n\t * @see #hasText(CharSequence)\n\t * @see #hasLength(String)\n\t * @see Character#isWhitespace\n\t */\n\tpublic static boolean hasText(@Nullable String str) {\n\t\treturn (str != null && !str.isEmpty() && containsText(str));\n\t}\n\n\tprivate static boolean containsText(CharSequence str) {\n\t\tint strLen = str.length();\n\t\tfor (int i = 0; i < strLen; i++) {\n\t\t\tif (!Character.isWhitespace(str.charAt(i))) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check whether the given {@code CharSequence} contains any whitespace characters.\n\t * @param str the {@code CharSequence} to check (may be {@code null})\n\t * @return {@code true} if the {@code CharSequence} is not empty and\n\t * contains at least 1 whitespace character\n\t * @see Character#isWhitespace\n\t */\n\tpublic static boolean containsWhitespace(@Nullable CharSequence str) {\n\t\tif (!hasLength(str)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tint strLen = str.length();\n\t\tfor (int i = 0; i < strLen; i++) {\n\t\t\tif (Character.isWhitespace(str.charAt(i))) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check whether the given {@code String} contains any whitespace characters.\n\t * @param str the {@code String} to check (may be {@code null})\n\t * @return {@code true} if the {@code String} is not empty and\n\t * contains at least 1 whitespace character\n\t * @see #containsWhitespace(CharSequence)\n\t */\n\tpublic static boolean containsWhitespace(@Nullable String str) {\n\t\treturn containsWhitespace((CharSequence) str);\n\t}\n\n\t/**\n\t * Trim leading and trailing whitespace from the given {@code String}.\n\t * @param str the {@code String} to check\n\t * @return the trimmed {@code String}\n\t * @see java.lang.Character#isWhitespace\n\t * @deprecated since 6.0, in favor of {@link String#strip()}\n\t */\n\t@Deprecated(since = \"6.0\")\n\tpublic static String trimWhitespace(String str) {\n\t\tif (!hasLength(str)) {\n\t\t\treturn str;\n\t\t}\n\n\t\treturn str.strip();\n\t}\n\n\t/**\n\t * Trim <em>all</em> whitespace from the given {@code CharSequence}:\n\t * leading, trailing, and in between characters.\n\t * @param text the {@code CharSequence} to check\n\t * @return the trimmed {@code CharSequence}\n\t * @since 5.3.22\n\t * @see #trimAllWhitespace(String)\n\t * @see java.lang.Character#isWhitespace\n\t */\n\tpublic static CharSequence trimAllWhitespace(CharSequence text) {\n\t\tif (!hasLength(text)) {\n\t\t\treturn text;\n\t\t}\n\n\t\tint len = text.length();\n\t\tStringBuilder sb = new StringBuilder(text.length());\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tchar c = text.charAt(i);\n\t\t\tif (!Character.isWhitespace(c)) {\n\t\t\t\tsb.append(c);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\t/**\n\t * Trim <em>all</em> whitespace from the given {@code String}:\n\t * leading, trailing, and in between characters.\n\t * @param str the {@code String} to check\n\t * @return the trimmed {@code String}\n\t * @see #trimAllWhitespace(CharSequence)\n\t * @see java.lang.Character#isWhitespace\n\t */\n\tpublic static String trimAllWhitespace(String str) {\n\t\tif (str == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn trimAllWhitespace((CharSequence) str).toString();\n\t}\n\n\t/**\n\t * Trim leading whitespace from the given {@code String}.\n\t * @param str the {@code String} to check\n\t * @return the trimmed {@code String}\n\t * @see java.lang.Character#isWhitespace\n\t * @deprecated since 6.0, in favor of {@link String#stripLeading()}\n\t */\n\t@Deprecated(since = \"6.0\")\n\tpublic static String trimLeadingWhitespace(String str) {\n\t\tif (!hasLength(str)) {\n\t\t\treturn str;\n\t\t}\n\n\t\treturn str.stripLeading();\n\t}\n\n\t/**\n\t * Trim trailing whitespace from the given {@code String}.\n\t * @param str the {@code String} to check\n\t * @return the trimmed {@code String}\n\t * @see java.lang.Character#isWhitespace\n\t * @deprecated since 6.0, in favor of {@link String#stripTrailing()}\n\t */\n\t@Deprecated(since = \"6.0\")\n\tpublic static String trimTrailingWhitespace(String str) {\n\t\tif (!hasLength(str)) {\n\t\t\treturn str;\n\t\t}\n\n\t\treturn str.stripTrailing();\n\t}\n\n\t/**\n\t * Trim all occurrences of the supplied leading character from the given {@code String}.\n\t * @param str the {@code String} to check\n\t * @param leadingCharacter the leading character to be trimmed\n\t * @return the trimmed {@code String}\n\t */\n\tpublic static String trimLeadingCharacter(String str, char leadingCharacter) {\n\t\tif (!hasLength(str)) {\n\t\t\treturn str;\n\t\t}\n\n\t\tint beginIdx = 0;\n\t\twhile (beginIdx < str.length() && leadingCharacter == str.charAt(beginIdx)) {\n\t\t\tbeginIdx++;\n\t\t}\n\t\treturn str.substring(beginIdx);\n\t}\n\n\t/**\n\t * Trim all occurrences of the supplied trailing character from the given {@code String}.\n\t * @param str the {@code String} to check\n\t * @param trailingCharacter the trailing character to be trimmed\n\t * @return the trimmed {@code String}\n\t */\n\tpublic static String trimTrailingCharacter(String str, char trailingCharacter) {\n\t\tif (!hasLength(str)) {\n\t\t\treturn str;\n\t\t}\n\n\t\tint endIdx = str.length() - 1;\n\t\twhile (endIdx >= 0 && trailingCharacter == str.charAt(endIdx)) {\n\t\t\tendIdx--;\n\t\t}\n\t\treturn str.substring(0, endIdx + 1);\n\t}\n\n\t/**\n\t * Test if the given {@code String} matches the given single character.\n\t * @param str the {@code String} to check\n\t * @param singleCharacter the character to compare to\n\t * @since 5.2.9\n\t */\n\tpublic static boolean matchesCharacter(@Nullable String str, char singleCharacter) {\n\t\treturn (str != null && str.length() == 1 && str.charAt(0) == singleCharacter);\n\t}\n\n\t/**\n\t * Test if the given {@code String} starts with the specified prefix,\n\t * ignoring upper/lower case.\n\t * @param str the {@code String} to check\n\t * @param prefix the prefix to look for\n\t * @see java.lang.String#startsWith\n\t */\n\tpublic static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix) {\n\t\treturn (str != null && prefix != null && str.length() >= prefix.length() &&\n\t\t\t\tstr.regionMatches(true, 0, prefix, 0, prefix.length()));\n\t}\n\n\t/**\n\t * Test if the given {@code String} ends with the specified suffix,\n\t * ignoring upper/lower case.\n\t * @param str the {@code String} to check\n\t * @param suffix the suffix to look for\n\t * @see java.lang.String#endsWith\n\t */\n\tpublic static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix) {\n\t\treturn (str != null && suffix != null && str.length() >= suffix.length() &&\n\t\t\t\tstr.regionMatches(true, str.length() - suffix.length(), suffix, 0, suffix.length()));\n\t}\n\n\t/**\n\t * Test whether the given string matches the given substring\n\t * at the given index.\n\t * @param str the original string (or StringBuilder)\n\t * @param index the index in the original string to start matching against\n\t * @param substring the substring to match at the given index\n\t */\n\tpublic static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n\t\tif (index + substring.length() > str.length()) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < substring.length(); i++) {\n\t\t\tif (str.charAt(index + i) != substring.charAt(i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Count the occurrences of the substring {@code sub} in string {@code str}.\n\t * @param str string to search in\n\t * @param sub string to search for\n\t */\n\tpublic static int countOccurrencesOf(String str, String sub) {\n\t\tif (!hasLength(str) || !hasLength(sub)) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tint count = 0;\n\t\tint pos = 0;\n\t\tint idx;\n\t\twhile ((idx = str.indexOf(sub, pos)) != -1) {\n\t\t\t++count;\n\t\t\tpos = idx + sub.length();\n\t\t}\n\t\treturn count;\n\t}\n\n\t/**\n\t * Replace all occurrences of a substring within a string with another string.\n\t * @param inString {@code String} to examine\n\t * @param oldPattern {@code String} to replace\n\t * @param newPattern {@code String} to insert\n\t * @return a {@code String} with the replacements\n\t */\n\tpublic static String replace(String inString, String oldPattern, @Nullable String newPattern) {\n\t\tif (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {\n\t\t\treturn inString;\n\t\t}\n\t\tint index = inString.indexOf(oldPattern);\n\t\tif (index == -1) {\n\t\t\t// no occurrence -> can return input as-is\n\t\t\treturn inString;\n\t\t}\n\n\t\tint capacity = inString.length();\n\t\tif (newPattern.length() > oldPattern.length()) {\n\t\t\tcapacity += 16;\n\t\t}\n\t\tStringBuilder sb = new StringBuilder(capacity);\n\n\t\tint pos = 0;  // our position in the old string\n\t\tint patLen = oldPattern.length();\n\t\twhile (index >= 0) {\n\t\t\tsb.append(inString, pos, index);\n\t\t\tsb.append(newPattern);\n\t\t\tpos = index + patLen;\n\t\t\tindex = inString.indexOf(oldPattern, pos);\n\t\t}\n\n\t\t// append any characters to the right of a match\n\t\tsb.append(inString, pos, inString.length());\n\t\treturn sb.toString();\n\t}\n\n\t/**\n\t * Delete all occurrences of the given substring.\n\t * @param inString the original {@code String}\n\t * @param pattern the pattern to delete all occurrences of\n\t * @return the resulting {@code String}\n\t */\n\tpublic static String delete(String inString, String pattern) {\n\t\treturn replace(inString, pattern, \"\");\n\t}\n\n\t/**\n\t * Delete any character in a given {@code String}.\n\t * @param inString the original {@code String}\n\t * @param charsToDelete a set of characters to delete.\n\t * E.g. \"az\\n\" will delete 'a's, 'z's and new lines.\n\t * @return the resulting {@code String}\n\t */\n\tpublic static String deleteAny(String inString, @Nullable String charsToDelete) {\n\t\tif (!hasLength(inString) || !hasLength(charsToDelete)) {\n\t\t\treturn inString;\n\t\t}\n\n\t\tint lastCharIndex = 0;\n\t\tchar[] result = new char[inString.length()];\n\t\tfor (int i = 0; i < inString.length(); i++) {\n\t\t\tchar c = inString.charAt(i);\n\t\t\tif (charsToDelete.indexOf(c) == -1) {\n\t\t\t\tresult[lastCharIndex++] = c;\n\t\t\t}\n\t\t}\n\t\tif (lastCharIndex == inString.length()) {\n\t\t\treturn inString;\n\t\t}\n\t\treturn new String(result, 0, lastCharIndex);\n\t}\n\n\t//---------------------------------------------------------------------\n\t// Convenience methods for working with formatted Strings\n\t//---------------------------------------------------------------------\n\n\t/**\n\t * Quote the given {@code String} with single quotes.\n\t * @param str the input {@code String} (e.g. \"myString\")\n\t * @return the quoted {@code String} (e.g. \"'myString'\"),\n\t * or {@code null} if the input was {@code null}\n\t */\n\t@Nullable\n\tpublic static String quote(@Nullable String str) {\n\t\treturn (str != null ? \"'\" + str + \"'\" : null);\n\t}\n\n\t/**\n\t * Turn the given Object into a {@code String} with single quotes\n\t * if it is a {@code String}; keeping the Object as-is else.\n\t * @param obj the input Object (e.g. \"myString\")\n\t * @return the quoted {@code String} (e.g. \"'myString'\"),\n\t * or the input object as-is if not a {@code String}\n\t */\n\t@Nullable\n\tpublic static Object quoteIfString(@Nullable Object obj) {\n\t\treturn (obj instanceof String text ? quote(text) : obj);\n\t}\n\n\t/**\n\t * Unqualify a string qualified by a '.' dot character. For example,\n\t * \"this.name.is.qualified\", returns \"qualified\".\n\t * @param qualifiedName the qualified name\n\t */\n\tpublic static String unqualify(String qualifiedName) {\n\t\treturn unqualify(qualifiedName, '.');\n\t}\n\n\t/**\n\t * Unqualify a string qualified by a separator character. For example,\n\t * \"this:name:is:qualified\" returns \"qualified\" if using a ':' separator.\n\t * @param qualifiedName the qualified name\n\t * @param separator the separator\n\t */\n\tpublic static String unqualify(String qualifiedName, char separator) {\n\t\treturn qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1);\n\t}\n\n\t/**\n\t * Capitalize a {@code String}, changing the first letter to\n\t * upper case as per {@link Character#toUpperCase(char)}.\n\t * No other letters are changed.\n\t * @param str the {@code String} to capitalize\n\t * @return the capitalized {@code String}\n\t */\n\tpublic static String capitalize(String str) {\n\t\treturn changeFirstCharacterCase(str, true);\n\t}\n\n\t/**\n\t * Uncapitalize a {@code String}, changing the first letter to\n\t * lower case as per {@link Character#toLowerCase(char)}.\n\t * No other letters are changed.\n\t * @param str the {@code String} to uncapitalize\n\t * @return the uncapitalized {@code String}\n\t */\n\tpublic static String uncapitalize(String str) {\n\t\treturn changeFirstCharacterCase(str, false);\n\t}\n\n\t/**\n\t * Uncapitalize a {@code String} in JavaBeans property format,\n\t * changing the first letter to lower case as per\n\t * {@link Character#toLowerCase(char)}, unless the initial two\n\t * letters are upper case in direct succession.\n\t * @param str the {@code String} to uncapitalize\n\t * @return the uncapitalized {@code String}\n\t * @since 6.0\n\t * @see java.beans.Introspector#decapitalize(String)\n\t */\n\tpublic static String uncapitalizeAsProperty(String str) {\n\t\tif (!hasLength(str) || (str.length() > 1 && Character.isUpperCase(str.charAt(0)) &&\n\t\t\t\tCharacter.isUpperCase(str.charAt(1)))) {\n\t\t\treturn str;\n\t\t}\n\t\treturn changeFirstCharacterCase(str, false);\n\t}\n\n\tprivate static String changeFirstCharacterCase(String str, boolean capitalize) {\n\t\tif (!hasLength(str)) {\n\t\t\treturn str;\n\t\t}\n\n\t\tchar baseChar = str.charAt(0);\n\t\tchar updatedChar;\n\t\tif (capitalize) {\n\t\t\tupdatedChar = Character.toUpperCase(baseChar);\n\t\t}\n\t\telse {\n\t\t\tupdatedChar = Character.toLowerCase(baseChar);\n\t\t}\n\t\tif (baseChar == updatedChar) {\n\t\t\treturn str;\n\t\t}\n\n\t\tchar[] chars = str.toCharArray();\n\t\tchars[0] = updatedChar;\n\t\treturn new String(chars);\n\t}\n\n\t/**\n\t * Extract the filename from the given Java resource path,\n\t * e.g. {@code \"mypath/myfile.txt\" &rarr; \"myfile.txt\"}.\n\t * @param path the file path (may be {@code null})\n\t * @return the extracted filename, or {@code null} if none\n\t */\n\t@Nullable\n\tpublic static String getFilename(@Nullable String path) {\n\t\tif (path == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tint separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR_CHAR);\n\t\treturn (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path);\n\t}\n\n\t/**\n\t * Extract the filename extension from the given Java resource path,\n\t * e.g. \"mypath/myfile.txt\" &rarr; \"txt\".\n\t * @param path the file path (may be {@code null})\n\t * @return the extracted filename extension, or {@code null} if none\n\t */\n\t@Nullable\n\tpublic static String getFilenameExtension(@Nullable String path) {\n\t\tif (path == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tint extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n\t\tif (extIndex == -1) {\n\t\t\treturn null;\n\t\t}\n\n\t\tint folderIndex = path.lastIndexOf(FOLDER_SEPARATOR_CHAR);\n\t\tif (folderIndex > extIndex) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn path.substring(extIndex + 1);\n\t}\n\n\t/**\n\t * Strip the filename extension from the given Java resource path,\n\t * e.g. \"mypath/myfile.txt\" &rarr; \"mypath/myfile\".\n\t * @param path the file path\n\t * @return the path with stripped filename extension\n\t */\n\tpublic static String stripFilenameExtension(String path) {\n\t\tint extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n\t\tif (extIndex == -1) {\n\t\t\treturn path;\n\t\t}\n\n\t\tint folderIndex = path.lastIndexOf(FOLDER_SEPARATOR_CHAR);\n\t\tif (folderIndex > extIndex) {\n\t\t\treturn path;\n\t\t}\n\n\t\treturn path.substring(0, extIndex);\n\t}\n\n\t/**\n\t * Apply the given relative path to the given Java resource path,\n\t * assuming standard Java folder separation (i.e. \"/\" separators).\n\t * @param path the path to start from (usually a full file path)\n\t * @param relativePath the relative path to apply\n\t * (relative to the full file path above)\n\t * @return the full file path that results from applying the relative path\n\t */\n\tpublic static String applyRelativePath(String path, String relativePath) {\n\t\tint separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR_CHAR);\n\t\tif (separatorIndex != -1) {\n\t\t\tString newPath = path.substring(0, separatorIndex);\n\t\t\tif (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n\t\t\t\tnewPath += FOLDER_SEPARATOR_CHAR;\n\t\t\t}\n\t\t\treturn newPath + relativePath;\n\t\t}\n\t\telse {\n\t\t\treturn relativePath;\n\t\t}\n\t}\n\n\t/**\n\t * Normalize the path by suppressing sequences like \"path/..\" and\n\t * inner simple dots.\n\t * <p>The result is convenient for path comparison. For other uses,\n\t * notice that Windows separators (\"\\\") are replaced by simple slashes.\n\t * <p><strong>NOTE</strong> that {@code cleanPath} should not be depended\n\t * upon in a security context. Other mechanisms should be used to prevent\n\t * path-traversal issues.\n\t * @param path the original path\n\t * @return the normalized path\n\t */\n\tpublic static String cleanPath(String path) {\n\t\tif (!hasLength(path)) {\n\t\t\treturn path;\n\t\t}\n\n\t\tString normalizedPath = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR);\n\t\tString pathToUse = normalizedPath;\n\n\t\t// Shortcut if there is no work to do\n\t\tif (pathToUse.indexOf('.') == -1) {\n\t\t\treturn pathToUse;\n\t\t}\n\n\t\t// Strip prefix from path to analyze, to not treat it as part of the\n\t\t// first path element. This is necessary to correctly parse paths like\n\t\t// \"file:core/../core/io/Resource.class\", where the \"..\" should just\n\t\t// strip the first \"core\" directory while keeping the \"file:\" prefix.\n\t\tint prefixIndex = pathToUse.indexOf(':');\n\t\tString prefix = \"\";\n\t\tif (prefixIndex != -1) {\n\t\t\tprefix = pathToUse.substring(0, prefixIndex + 1);\n\t\t\tif (prefix.contains(FOLDER_SEPARATOR)) {\n\t\t\t\tprefix = \"\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpathToUse = pathToUse.substring(prefixIndex + 1);\n\t\t\t}\n\t\t}\n\t\tif (pathToUse.startsWith(FOLDER_SEPARATOR)) {\n\t\t\tprefix = prefix + FOLDER_SEPARATOR;\n\t\t\tpathToUse = pathToUse.substring(1);\n\t\t}\n\n\t\tString[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR);\n\t\t// we never require more elements than pathArray and in the common case the same number\n\t\tDeque<String> pathElements = new ArrayDeque<>(pathArray.length);\n\t\tint tops = 0;\n\n\t\tfor (int i = pathArray.length - 1; i >= 0; i--) {\n\t\t\tString element = pathArray[i];\n\t\t\tif (CURRENT_PATH.equals(element)) {\n\t\t\t\t// Points to current directory - drop it.\n\t\t\t}\n\t\t\telse if (TOP_PATH.equals(element)) {\n\t\t\t\t// Registering top path found.\n\t\t\t\ttops++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (tops > 0) {\n\t\t\t\t\t// Merging path element with element corresponding to top path.\n\t\t\t\t\ttops--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Normal path element found.\n\t\t\t\t\tpathElements.addFirst(element);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// All path elements stayed the same - shortcut\n\t\tif (pathArray.length == pathElements.size()) {\n\t\t\treturn normalizedPath;\n\t\t}\n\t\t// Remaining top paths need to be retained.\n\t\tfor (int i = 0; i < tops; i++) {\n\t\t\tpathElements.addFirst(TOP_PATH);\n\t\t}\n\t\t// If nothing else left, at least explicitly point to current path.\n\t\tif (pathElements.size() == 1 && pathElements.getLast().isEmpty() && !prefix.endsWith(FOLDER_SEPARATOR)) {\n\t\t\tpathElements.addFirst(CURRENT_PATH);\n\t\t}\n\n\t\tfinal String joined = collectionToDelimitedString(pathElements, FOLDER_SEPARATOR);\n\t\t// avoid string concatenation with empty prefix\n\t\treturn prefix.isEmpty() ? joined : prefix + joined;\n\t}\n\n\t/**\n\t * Compare two paths after normalization of them.\n\t * @param path1 first path for comparison\n\t * @param path2 second path for comparison\n\t * @return whether the two paths are equivalent after normalization\n\t */\n\tpublic static boolean pathEquals(String path1, String path2) {\n\t\treturn cleanPath(path1).equals(cleanPath(path2));\n\t}\n\n\t/**\n\t * Decode the given encoded URI component value. Based on the following rules:\n\t * <ul>\n\t * <li>Alphanumeric characters {@code \"a\"} through {@code \"z\"}, {@code \"A\"} through {@code \"Z\"},\n\t * and {@code \"0\"} through {@code \"9\"} stay the same.</li>\n\t * <li>Special characters {@code \"-\"}, {@code \"_\"}, {@code \".\"}, and {@code \"*\"} stay the same.</li>\n\t * <li>A sequence \"{@code %<i>xy</i>}\" is interpreted as a hexadecimal representation of the character.</li>\n\t * </ul>\n\t * @param source the encoded String\n\t * @param charset the character set\n\t * @return the decoded value\n\t * @throws IllegalArgumentException when the given source contains invalid encoded sequences\n\t * @since 5.0\n\t * @see java.net.URLDecoder#decode(String, String)\n\t */\n\tpublic static String uriDecode(String source, Charset charset) {\n\t\tint length = source.length();\n\t\tif (length == 0) {\n\t\t\treturn source;\n\t\t}\n\t\tAssert.notNull(charset, \"Charset must not be null\");\n\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream(length);\n\t\tboolean changed = false;\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tint ch = source.charAt(i);\n\t\t\tif (ch == '%') {\n\t\t\t\tif (i + 2 < length) {\n\t\t\t\t\tchar hex1 = source.charAt(i + 1);\n\t\t\t\t\tchar hex2 = source.charAt(i + 2);\n\t\t\t\t\tint u = Character.digit(hex1, 16);\n\t\t\t\t\tint l = Character.digit(hex2, 16);\n\t\t\t\t\tif (u == -1 || l == -1) {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid encoded sequence \\\"\" + source.substring(i) + \"\\\"\");\n\t\t\t\t\t}\n\t\t\t\t\tbaos.write((char) ((u << 4) + l));\n\t\t\t\t\ti += 2;\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid encoded sequence \\\"\" + source.substring(i) + \"\\\"\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbaos.write(ch);\n\t\t\t}\n\t\t}\n\t\treturn (changed ? StreamUtils.copyToString(baos, charset) : source);\n\t}\n\n\t/**\n\t * Parse the given {@code String} value into a {@link Locale}, accepting\n\t * the {@link Locale#toString} format as well as BCP 47 language tags as\n\t * specified by {@link Locale#forLanguageTag}.\n\t * @param localeValue the locale value: following either {@code Locale's}\n\t * {@code toString()} format (\"en\", \"en_UK\", etc), also accepting spaces as\n\t * separators (as an alternative to underscores), or BCP 47 (e.g. \"en-UK\")\n\t * @return a corresponding {@code Locale} instance, or {@code null} if none\n\t * @throws IllegalArgumentException in case of an invalid locale specification\n\t * @since 5.0.4\n\t * @see #parseLocaleString\n\t * @see Locale#forLanguageTag\n\t */\n\t@Nullable\n\tpublic static Locale parseLocale(String localeValue) {\n\t\tif (!localeValue.contains(\"_\") && !localeValue.contains(\" \")) {\n\t\t\tvalidateLocalePart(localeValue);\n\t\t\tLocale resolved = Locale.forLanguageTag(localeValue);\n\t\t\tif (resolved.getLanguage().length() > 0) {\n\t\t\t\treturn resolved;\n\t\t\t}\n\t\t}\n\t\treturn parseLocaleString(localeValue);\n\t}\n\n\t/**\n\t * Parse the given {@code String} representation into a {@link Locale}.\n\t * <p>For many parsing scenarios, this is an inverse operation of\n\t * {@link Locale#toString Locale's toString}, in a lenient sense.\n\t * This method does not aim for strict {@code Locale} design compliance;\n\t * it is rather specifically tailored for typical Spring parsing needs.\n\t * <p><b>Note: This delegate does not accept the BCP 47 language tag format.\n\t * Please use {@link #parseLocale} for lenient parsing of both formats.</b>\n\t * @param localeString the locale {@code String}: following {@code Locale's}\n\t * {@code toString()} format (\"en\", \"en_UK\", etc), also accepting spaces as\n\t * separators (as an alternative to underscores)\n\t * @return a corresponding {@code Locale} instance, or {@code null} if none\n\t * @throws IllegalArgumentException in case of an invalid locale specification\n\t */\n\t@Nullable\n\tpublic static Locale parseLocaleString(String localeString) {\n\t\tif (localeString.equals(\"\")) {\n\t\t\treturn null;\n\t\t}\n\t\tString delimiter = \"_\";\n\t\tif (!localeString.contains(\"_\") && localeString.contains(\" \")) {\n\t\t\tdelimiter = \" \";\n\t\t}\n\t\tfinal String[] tokens = localeString.split(delimiter, -1);\n\t\tif (tokens.length == 1) {\n\t\t\tfinal String language = tokens[0];\n\t\t\tvalidateLocalePart(language);\n\t\t\treturn new Locale(language);\n\t\t}\n\t\telse if (tokens.length == 2) {\n\t\t\tfinal String language = tokens[0];\n\t\t\tvalidateLocalePart(language);\n\t\t\tfinal String country = tokens[1];\n\t\t\tvalidateLocalePart(country);\n\t\t\treturn new Locale(language, country);\n\t\t}\n\t\telse if (tokens.length > 2) {\n\t\t\tfinal String language = tokens[0];\n\t\t\tvalidateLocalePart(language);\n\t\t\tfinal String country = tokens[1];\n\t\t\tvalidateLocalePart(country);\n\t\t\tfinal String variant = Arrays.stream(tokens).skip(2).collect(Collectors.joining(delimiter));\n\t\t\treturn new Locale(language, country, variant);\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Invalid locale format: '\" + localeString + \"'\");\n\t}\n\n\tprivate static void validateLocalePart(String localePart) {\n\t\tfor (int i = 0; i < localePart.length(); i++) {\n\t\t\tchar ch = localePart.charAt(i);\n\t\t\tif (ch != ' ' && ch != '_' && ch != '-' && ch != '#' && !Character.isLetterOrDigit(ch)) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Locale part \\\"\" + localePart + \"\\\" contains invalid characters\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Parse the given {@code timeZoneString} value into a {@link TimeZone}.\n\t * @param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}\n\t * but throwing {@link IllegalArgumentException} in case of an invalid time zone specification\n\t * @return a corresponding {@link TimeZone} instance\n\t * @throws IllegalArgumentException in case of an invalid time zone specification\n\t */\n\tpublic static TimeZone parseTimeZoneString(String timeZoneString) {\n\t\tTimeZone timeZone = TimeZone.getTimeZone(timeZoneString);\n\t\tif (\"GMT\".equals(timeZone.getID()) && !timeZoneString.startsWith(\"GMT\")) {\n\t\t\t// We don't want that GMT fallback...\n\t\t\tthrow new IllegalArgumentException(\"Invalid time zone specification '\" + timeZoneString + \"'\");\n\t\t}\n\t\treturn timeZone;\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Convenience methods for working with String arrays\n\t//---------------------------------------------------------------------\n\n\t/**\n\t * Copy the given {@link Collection} into a {@code String} array.\n\t * <p>The {@code Collection} must contain {@code String} elements only.\n\t * @param collection the {@code Collection} to copy\n\t * (potentially {@code null} or empty)\n\t * @return the resulting {@code String} array\n\t */\n\tpublic static String[] toStringArray(@Nullable Collection<String> collection) {\n\t\treturn (!CollectionUtils.isEmpty(collection) ? collection.toArray(EMPTY_STRING_ARRAY) : EMPTY_STRING_ARRAY);\n\t}\n\n\t/**\n\t * Copy the given {@link Enumeration} into a {@code String} array.\n\t * <p>The {@code Enumeration} must contain {@code String} elements only.\n\t * @param enumeration the {@code Enumeration} to copy\n\t * (potentially {@code null} or empty)\n\t * @return the resulting {@code String} array\n\t */\n\tpublic static String[] toStringArray(@Nullable Enumeration<String> enumeration) {\n\t\treturn (enumeration != null ? toStringArray(Collections.list(enumeration)) : EMPTY_STRING_ARRAY);\n\t}\n\n\t/**\n\t * Append the given {@code String} to the given {@code String} array,\n\t * returning a new array consisting of the input array contents plus\n\t * the given {@code String}.\n\t * @param array the array to append to (can be {@code null})\n\t * @param str the {@code String} to append\n\t * @return the new array (never {@code null})\n\t */\n\tpublic static String[] addStringToArray(@Nullable String[] array, String str) {\n\t\tif (ObjectUtils.isEmpty(array)) {\n\t\t\treturn new String[] {str};\n\t\t}\n\n\t\tString[] newArr = new String[array.length + 1];\n\t\tSystem.arraycopy(array, 0, newArr, 0, array.length);\n\t\tnewArr[array.length] = str;\n\t\treturn newArr;\n\t}\n\n\t/**\n\t * Concatenate the given {@code String} arrays into one,\n\t * with overlapping array elements included twice.\n\t * <p>The order of elements in the original arrays is preserved.\n\t * @param array1 the first array (can be {@code null})\n\t * @param array2 the second array (can be {@code null})\n\t * @return the new array ({@code null} if both given arrays were {@code null})\n\t */\n\t@Nullable\n\tpublic static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2) {\n\t\tif (ObjectUtils.isEmpty(array1)) {\n\t\t\treturn array2;\n\t\t}\n\t\tif (ObjectUtils.isEmpty(array2)) {\n\t\t\treturn array1;\n\t\t}\n\n\t\tString[] newArr = new String[array1.length + array2.length];\n\t\tSystem.arraycopy(array1, 0, newArr, 0, array1.length);\n\t\tSystem.arraycopy(array2, 0, newArr, array1.length, array2.length);\n\t\treturn newArr;\n\t}\n\n\t/**\n\t * Sort the given {@code String} array if necessary.\n\t * @param array the original array (potentially empty)\n\t * @return the array in sorted form (never {@code null})\n\t */\n\tpublic static String[] sortStringArray(String[] array) {\n\t\tif (ObjectUtils.isEmpty(array)) {\n\t\t\treturn array;\n\t\t}\n\n\t\tArrays.sort(array);\n\t\treturn array;\n\t}\n\n\t/**\n\t * Trim the elements of the given {@code String} array, calling\n\t * {@code String.trim()} on each non-null element.\n\t * @param array the original {@code String} array (potentially empty)\n\t * @return the resulting array (of the same size) with trimmed elements\n\t */\n\tpublic static String[] trimArrayElements(String[] array) {\n\t\tif (ObjectUtils.isEmpty(array)) {\n\t\t\treturn array;\n\t\t}\n\n\t\tString[] result = new String[array.length];\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tString element = array[i];\n\t\t\tresult[i] = (element != null ? element.trim() : null);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Remove duplicate strings from the given array.\n\t * <p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}.\n\t * @param array the {@code String} array (potentially empty)\n\t * @return an array without duplicates, in natural sort order\n\t */\n\tpublic static String[] removeDuplicateStrings(String[] array) {\n\t\tif (ObjectUtils.isEmpty(array)) {\n\t\t\treturn array;\n\t\t}\n\n\t\tSet<String> set = new LinkedHashSet<>(Arrays.asList(array));\n\t\treturn toStringArray(set);\n\t}\n\n\t/**\n\t * Split a {@code String} at the first occurrence of the delimiter.\n\t * Does not include the delimiter in the result.\n\t * @param toSplit the string to split (potentially {@code null} or empty)\n\t * @param delimiter to split the string up with (potentially {@code null} or empty)\n\t * @return a two element array with index 0 being before the delimiter, and\n\t * index 1 being after the delimiter (neither element includes the delimiter);\n\t * or {@code null} if the delimiter wasn't found in the given input {@code String}\n\t */\n\t@Nullable\n\tpublic static String[] split(@Nullable String toSplit, @Nullable String delimiter) {\n\t\tif (!hasLength(toSplit) || !hasLength(delimiter)) {\n\t\t\treturn null;\n\t\t}\n\t\tint offset = toSplit.indexOf(delimiter);\n\t\tif (offset < 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString beforeDelimiter = toSplit.substring(0, offset);\n\t\tString afterDelimiter = toSplit.substring(offset + delimiter.length());\n\t\treturn new String[] {beforeDelimiter, afterDelimiter};\n\t}\n\n\t/**\n\t * Take an array of strings and split each element based on the given delimiter.\n\t * A {@code Properties} instance is then generated, with the left of the delimiter\n\t * providing the key, and the right of the delimiter providing the value.\n\t * <p>Will trim both the key and value before adding them to the {@code Properties}.\n\t * @param array the array to process\n\t * @param delimiter to split each element using (typically the equals symbol)\n\t * @return a {@code Properties} instance representing the array contents,\n\t * or {@code null} if the array to process was {@code null} or empty\n\t */\n\t@Nullable\n\tpublic static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {\n\t\treturn splitArrayElementsIntoProperties(array, delimiter, null);\n\t}\n\n\t/**\n\t * Take an array of strings and split each element based on the given delimiter.\n\t * A {@code Properties} instance is then generated, with the left of the\n\t * delimiter providing the key, and the right of the delimiter providing the value.\n\t * <p>Will trim both the key and value before adding them to the\n\t * {@code Properties} instance.\n\t * @param array the array to process\n\t * @param delimiter to split each element using (typically the equals symbol)\n\t * @param charsToDelete one or more characters to remove from each element\n\t * prior to attempting the split operation (typically the quotation mark\n\t * symbol), or {@code null} if no removal should occur\n\t * @return a {@code Properties} instance representing the array contents,\n\t * or {@code null} if the array to process was {@code null} or empty\n\t */\n\t@Nullable\n\tpublic static Properties splitArrayElementsIntoProperties(\n\t\t\tString[] array, String delimiter, @Nullable String charsToDelete) {\n\n\t\tif (ObjectUtils.isEmpty(array)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tProperties result = new Properties();\n\t\tfor (String element : array) {\n\t\t\tif (charsToDelete != null) {\n\t\t\t\telement = deleteAny(element, charsToDelete);\n\t\t\t}\n\t\t\tString[] splittedElement = split(element, delimiter);\n\t\t\tif (splittedElement == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tresult.setProperty(splittedElement[0].trim(), splittedElement[1].trim());\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Tokenize the given {@code String} into a {@code String} array via a\n\t * {@link StringTokenizer}.\n\t * <p>Trims tokens and omits empty tokens.\n\t * <p>The given {@code delimiters} string can consist of any number of\n\t * delimiter characters. Each of those characters can be used to separate\n\t * tokens. A delimiter is always a single character; for multi-character\n\t * delimiters, consider using {@link #delimitedListToStringArray}.\n\t * @param str the {@code String} to tokenize (potentially {@code null} or empty)\n\t * @param delimiters the delimiter characters, assembled as a {@code String}\n\t * (each of the characters is individually considered as a delimiter)\n\t * @return an array of the tokens\n\t * @see java.util.StringTokenizer\n\t * @see String#trim()\n\t * @see #delimitedListToStringArray\n\t */\n\tpublic static String[] tokenizeToStringArray(@Nullable String str, String delimiters) {\n\t\treturn tokenizeToStringArray(str, delimiters, true, true);\n\t}\n\n\t/**\n\t * Tokenize the given {@code String} into a {@code String} array via a\n\t * {@link StringTokenizer}.\n\t * <p>The given {@code delimiters} string can consist of any number of\n\t * delimiter characters. Each of those characters can be used to separate\n\t * tokens. A delimiter is always a single character; for multi-character\n\t * delimiters, consider using {@link #delimitedListToStringArray}.\n\t * @param str the {@code String} to tokenize (potentially {@code null} or empty)\n\t * @param delimiters the delimiter characters, assembled as a {@code String}\n\t * (each of the characters is individually considered as a delimiter)\n\t * @param trimTokens trim the tokens via {@link String#trim()}\n\t * @param ignoreEmptyTokens omit empty tokens from the result array\n\t * (only applies to tokens that are empty after trimming; StringTokenizer\n\t * will not consider subsequent delimiters as token in the first place).\n\t * @return an array of the tokens\n\t * @see java.util.StringTokenizer\n\t * @see String#trim()\n\t * @see #delimitedListToStringArray\n\t */\n\tpublic static String[] tokenizeToStringArray(\n\t\t\t@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {\n\n\t\tif (str == null) {\n\t\t\treturn EMPTY_STRING_ARRAY;\n\t\t}\n\n\t\tStringTokenizer st = new StringTokenizer(str, delimiters);\n\t\tList<String> tokens = new ArrayList<>();\n\t\twhile (st.hasMoreTokens()) {\n\t\t\tString token = st.nextToken();\n\t\t\tif (trimTokens) {\n\t\t\t\ttoken = token.trim();\n\t\t\t}\n\t\t\tif (!ignoreEmptyTokens || token.length() > 0) {\n\t\t\t\ttokens.add(token);\n\t\t\t}\n\t\t}\n\t\treturn toStringArray(tokens);\n\t}\n\n\t/**\n\t * Take a {@code String} that is a delimited list and convert it into a\n\t * {@code String} array.\n\t * <p>A single {@code delimiter} may consist of more than one character,\n\t * but it will still be considered as a single delimiter string, rather\n\t * than as a bunch of potential delimiter characters, in contrast to\n\t * {@link #tokenizeToStringArray}.\n\t * @param str the input {@code String} (potentially {@code null} or empty)\n\t * @param delimiter the delimiter between elements (this is a single delimiter,\n\t * rather than a bunch individual delimiter characters)\n\t * @return an array of the tokens in the list\n\t * @see #tokenizeToStringArray\n\t */\n\tpublic static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter) {\n\t\treturn delimitedListToStringArray(str, delimiter, null);\n\t}\n\n\t/**\n\t * Take a {@code String} that is a delimited list and convert it into\n\t * a {@code String} array.\n\t * <p>A single {@code delimiter} may consist of more than one character,\n\t * but it will still be considered as a single delimiter string, rather\n\t * than as a bunch of potential delimiter characters, in contrast to\n\t * {@link #tokenizeToStringArray}.\n\t * @param str the input {@code String} (potentially {@code null} or empty)\n\t * @param delimiter the delimiter between elements (this is a single delimiter,\n\t * rather than a bunch individual delimiter characters)\n\t * @param charsToDelete a set of characters to delete; useful for deleting unwanted\n\t * line breaks: e.g. \"\\r\\n\\f\" will delete all new lines and line feeds in a {@code String}\n\t * @return an array of the tokens in the list\n\t * @see #tokenizeToStringArray\n\t */\n\tpublic static String[] delimitedListToStringArray(\n\t\t\t@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete) {\n\n\t\tif (str == null) {\n\t\t\treturn EMPTY_STRING_ARRAY;\n\t\t}\n\t\tif (delimiter == null) {\n\t\t\treturn new String[] {str};\n\t\t}\n\n\t\tList<String> result = new ArrayList<>();\n\t\tif (delimiter.isEmpty()) {\n\t\t\tfor (int i = 0; i < str.length(); i++) {\n\t\t\t\tresult.add(deleteAny(str.substring(i, i + 1), charsToDelete));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint pos = 0;\n\t\t\tint delPos;\n\t\t\twhile ((delPos = str.indexOf(delimiter, pos)) != -1) {\n\t\t\t\tresult.add(deleteAny(str.substring(pos, delPos), charsToDelete));\n\t\t\t\tpos = delPos + delimiter.length();\n\t\t\t}\n\t\t\tif (str.length() > 0 && pos <= str.length()) {\n\t\t\t\t// Add rest of String, but not in case of empty input.\n\t\t\t\tresult.add(deleteAny(str.substring(pos), charsToDelete));\n\t\t\t}\n\t\t}\n\t\treturn toStringArray(result);\n\t}\n\n\t/**\n\t * Convert a comma delimited list (e.g., a row from a CSV file) into an\n\t * array of strings.\n\t * @param str the input {@code String} (potentially {@code null} or empty)\n\t * @return an array of strings, or the empty array in case of empty input\n\t */\n\tpublic static String[] commaDelimitedListToStringArray(@Nullable String str) {\n\t\treturn delimitedListToStringArray(str, \",\");\n\t}\n\n\t/**\n\t * Convert a comma delimited list (e.g., a row from a CSV file) into a set.\n\t * <p>Note that this will suppress duplicates, and as of 4.2, the elements in\n\t * the returned set will preserve the original order in a {@link LinkedHashSet}.\n\t * @param str the input {@code String} (potentially {@code null} or empty)\n\t * @return a set of {@code String} entries in the list\n\t * @see #removeDuplicateStrings(String[])\n\t */\n\tpublic static Set<String> commaDelimitedListToSet(@Nullable String str) {\n\t\tString[] tokens = commaDelimitedListToStringArray(str);\n\t\treturn new LinkedHashSet<>(Arrays.asList(tokens));\n\t}\n\n\t/**\n\t * Convert a {@link Collection} to a delimited {@code String} (e.g. CSV).\n\t * <p>Useful for {@code toString()} implementations.\n\t * @param coll the {@code Collection} to convert (potentially {@code null} or empty)\n\t * @param delim the delimiter to use (typically a \",\")\n\t * @param prefix the {@code String} to start each element with\n\t * @param suffix the {@code String} to end each element with\n\t * @return the delimited {@code String}\n\t */\n\tpublic static String collectionToDelimitedString(\n\t\t\t@Nullable Collection<?> coll, String delim, String prefix, String suffix) {\n\n\t\tif (CollectionUtils.isEmpty(coll)) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tint totalLength = coll.size() * (prefix.length() + suffix.length()) + (coll.size() - 1) * delim.length();\n\t\tfor (Object element : coll) {\n\t\t\ttotalLength += String.valueOf(element).length();\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder(totalLength);\n\t\tIterator<?> it = coll.iterator();\n\t\twhile (it.hasNext()) {\n\t\t\tsb.append(prefix).append(it.next()).append(suffix);\n\t\t\tif (it.hasNext()) {\n\t\t\t\tsb.append(delim);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\t/**\n\t * Convert a {@code Collection} into a delimited {@code String} (e.g. CSV).\n\t * <p>Useful for {@code toString()} implementations.\n\t * @param coll the {@code Collection} to convert (potentially {@code null} or empty)\n\t * @param delim the delimiter to use (typically a \",\")\n\t * @return the delimited {@code String}\n\t */\n\tpublic static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim) {\n\t\treturn collectionToDelimitedString(coll, delim, \"\", \"\");\n\t}\n\n\t/**\n\t * Convert a {@code Collection} into a delimited {@code String} (e.g., CSV).\n\t * <p>Useful for {@code toString()} implementations.\n\t * @param coll the {@code Collection} to convert (potentially {@code null} or empty)\n\t * @return the delimited {@code String}\n\t */\n\tpublic static String collectionToCommaDelimitedString(@Nullable Collection<?> coll) {\n\t\treturn collectionToDelimitedString(coll, \",\");\n\t}\n\n\t/**\n\t * Convert a {@code String} array into a delimited {@code String} (e.g. CSV).\n\t * <p>Useful for {@code toString()} implementations.\n\t * @param arr the array to display (potentially {@code null} or empty)\n\t * @param delim the delimiter to use (typically a \",\")\n\t * @return the delimited {@code String}\n\t */\n\tpublic static String arrayToDelimitedString(@Nullable Object[] arr, String delim) {\n\t\tif (ObjectUtils.isEmpty(arr)) {\n\t\t\treturn \"\";\n\t\t}\n\t\tif (arr.length == 1) {\n\t\t\treturn ObjectUtils.nullSafeToString(arr[0]);\n\t\t}\n\n\t\tStringJoiner sj = new StringJoiner(delim);\n\t\tfor (Object elem : arr) {\n\t\t\tsj.add(String.valueOf(elem));\n\t\t}\n\t\treturn sj.toString();\n\t}\n\n\t/**\n\t * Convert a {@code String} array into a comma delimited {@code String}\n\t * (i.e., CSV).\n\t * <p>Useful for {@code toString()} implementations.\n\t * @param arr the array to display (potentially {@code null} or empty)\n\t * @return the delimited {@code String}\n\t */\n\tpublic static String arrayToCommaDelimitedString(@Nullable Object[] arr) {\n\t\treturn arrayToDelimitedString(arr, \",\");\n\t}\n\n}"
  },
  "org.springframework.util.StringUtils#addStringToArray(array,str)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Append the given {@code String} to the given {@code String} array,\n\t * returning a new array consisting of the input array contents plus\n\t * the given {@code String}.\n\t * @param array the array to append to (can be {@code null})\n\t * @param str the {@code String} to append\n\t * @return the new array (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array",
      "str"
    ],
    "position": {
      "column": 1,
      "line": 961
    },
    "return": "String[]",
    "signature": "public String[] addStringToArray(@Nullable String[] array, String str)",
    "source_code": "\tpublic static String[] addStringToArray(@Nullable String[] array, String str) {\n\t\tif (ObjectUtils.isEmpty(array)) {\n\t\t\treturn new String[] {str};\n\t\t}\n\n\t\tString[] newArr = new String[array.length + 1];\n\t\tSystem.arraycopy(array, 0, newArr, 0, array.length);\n\t\tnewArr[array.length] = str;\n\t\treturn newArr;\n\t}"
  },
  "org.springframework.util.StringUtils#applyRelativePath(path,relativePath)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the given relative path to the given Java resource path,\n\t * assuming standard Java folder separation (i.e. \"/\" separators).\n\t * @param path the path to start from (usually a full file path)\n\t * @param relativePath the relative path to apply\n\t * (relative to the full file path above)\n\t * @return the full file path that results from applying the relative path\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path",
      "relativePath"
    ],
    "position": {
      "column": 1,
      "line": 666
    },
    "return": "String",
    "signature": "public String applyRelativePath(String path, String relativePath)",
    "source_code": "\tpublic static String applyRelativePath(String path, String relativePath) {\n\t\tint separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR_CHAR);\n\t\tif (separatorIndex != -1) {\n\t\t\tString newPath = path.substring(0, separatorIndex);\n\t\t\tif (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n\t\t\t\tnewPath += FOLDER_SEPARATOR_CHAR;\n\t\t\t}\n\t\t\treturn newPath + relativePath;\n\t\t}\n\t\telse {\n\t\t\treturn relativePath;\n\t\t}\n\t}"
  },
  "org.springframework.util.StringUtils#arrayToCommaDelimitedString(arr)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a {@code String} array into a comma delimited {@code String}\n\t * (i.e., CSV).\n\t * <p>Useful for {@code toString()} implementations.\n\t * @param arr the array to display (potentially {@code null} or empty)\n\t * @return the delimited {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "arr"
    ],
    "position": {
      "column": 1,
      "line": 1346
    },
    "return": "String",
    "signature": "public String arrayToCommaDelimitedString(@Nullable Object[] arr)",
    "source_code": "\tpublic static String arrayToCommaDelimitedString(@Nullable Object[] arr) {\n\t\treturn arrayToDelimitedString(arr, \",\");\n\t}"
  },
  "org.springframework.util.StringUtils#arrayToDelimitedString(arr,delim)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a {@code String} array into a delimited {@code String} (e.g. CSV).\n\t * <p>Useful for {@code toString()} implementations.\n\t * @param arr the array to display (potentially {@code null} or empty)\n\t * @param delim the delimiter to use (typically a \",\")\n\t * @return the delimited {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "arr",
      "delim"
    ],
    "position": {
      "column": 1,
      "line": 1324
    },
    "return": "String",
    "signature": "public String arrayToDelimitedString(@Nullable Object[] arr, String delim)",
    "source_code": "\tpublic static String arrayToDelimitedString(@Nullable Object[] arr, String delim) {\n\t\tif (ObjectUtils.isEmpty(arr)) {\n\t\t\treturn \"\";\n\t\t}\n\t\tif (arr.length == 1) {\n\t\t\treturn ObjectUtils.nullSafeToString(arr[0]);\n\t\t}\n\n\t\tStringJoiner sj = new StringJoiner(delim);\n\t\tfor (Object elem : arr) {\n\t\t\tsj.add(String.valueOf(elem));\n\t\t}\n\t\treturn sj.toString();\n\t}"
  },
  "org.springframework.util.StringUtils#capitalize(str)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Capitalize a {@code String}, changing the first letter to\n\t * upper case as per {@link Character#toUpperCase(char)}.\n\t * No other letters are changed.\n\t * @param str the {@code String} to capitalize\n\t * @return the capitalized {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str"
    ],
    "position": {
      "column": 1,
      "line": 542
    },
    "return": "String",
    "signature": "public String capitalize(String str)",
    "source_code": "\tpublic static String capitalize(String str) {\n\t\treturn changeFirstCharacterCase(str, true);\n\t}"
  },
  "org.springframework.util.StringUtils#cleanPath(path)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Normalize the path by suppressing sequences like \"path/..\" and\n\t * inner simple dots.\n\t * <p>The result is convenient for path comparison. For other uses,\n\t * notice that Windows separators (\"\\\") are replaced by simple slashes.\n\t * <p><strong>NOTE</strong> that {@code cleanPath} should not be depended\n\t * upon in a security context. Other mechanisms should be used to prevent\n\t * path-traversal issues.\n\t * @param path the original path\n\t * @return the normalized path\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path"
    ],
    "position": {
      "column": 1,
      "line": 691
    },
    "return": "String",
    "signature": "public String cleanPath(String path)",
    "source_code": "\tpublic static String cleanPath(String path) {\n\t\tif (!hasLength(path)) {\n\t\t\treturn path;\n\t\t}\n\n\t\tString normalizedPath = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR);\n\t\tString pathToUse = normalizedPath;\n\n\t\t// Shortcut if there is no work to do\n\t\tif (pathToUse.indexOf('.') == -1) {\n\t\t\treturn pathToUse;\n\t\t}\n\n\t\t// Strip prefix from path to analyze, to not treat it as part of the\n\t\t// first path element. This is necessary to correctly parse paths like\n\t\t// \"file:core/../core/io/Resource.class\", where the \"..\" should just\n\t\t// strip the first \"core\" directory while keeping the \"file:\" prefix.\n\t\tint prefixIndex = pathToUse.indexOf(':');\n\t\tString prefix = \"\";\n\t\tif (prefixIndex != -1) {\n\t\t\tprefix = pathToUse.substring(0, prefixIndex + 1);\n\t\t\tif (prefix.contains(FOLDER_SEPARATOR)) {\n\t\t\t\tprefix = \"\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpathToUse = pathToUse.substring(prefixIndex + 1);\n\t\t\t}\n\t\t}\n\t\tif (pathToUse.startsWith(FOLDER_SEPARATOR)) {\n\t\t\tprefix = prefix + FOLDER_SEPARATOR;\n\t\t\tpathToUse = pathToUse.substring(1);\n\t\t}\n\n\t\tString[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR);\n\t\t// we never require more elements than pathArray and in the common case the same number\n\t\tDeque<String> pathElements = new ArrayDeque<>(pathArray.length);\n\t\tint tops = 0;\n\n\t\tfor (int i = pathArray.length - 1; i >= 0; i--) {\n\t\t\tString element = pathArray[i];\n\t\t\tif (CURRENT_PATH.equals(element)) {\n\t\t\t\t// Points to current directory - drop it.\n\t\t\t}\n\t\t\telse if (TOP_PATH.equals(element)) {\n\t\t\t\t// Registering top path found.\n\t\t\t\ttops++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (tops > 0) {\n\t\t\t\t\t// Merging path element with element corresponding to top path.\n\t\t\t\t\ttops--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Normal path element found.\n\t\t\t\t\tpathElements.addFirst(element);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// All path elements stayed the same - shortcut\n\t\tif (pathArray.length == pathElements.size()) {\n\t\t\treturn normalizedPath;\n\t\t}\n\t\t// Remaining top paths need to be retained.\n\t\tfor (int i = 0; i < tops; i++) {\n\t\t\tpathElements.addFirst(TOP_PATH);\n\t\t}\n\t\t// If nothing else left, at least explicitly point to current path.\n\t\tif (pathElements.size() == 1 && pathElements.getLast().isEmpty() && !prefix.endsWith(FOLDER_SEPARATOR)) {\n\t\t\tpathElements.addFirst(CURRENT_PATH);\n\t\t}\n\n\t\tfinal String joined = collectionToDelimitedString(pathElements, FOLDER_SEPARATOR);\n\t\t// avoid string concatenation with empty prefix\n\t\treturn prefix.isEmpty() ? joined : prefix + joined;\n\t}"
  },
  "org.springframework.util.StringUtils#collectionToCommaDelimitedString(coll)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a {@code Collection} into a delimited {@code String} (e.g., CSV).\n\t * <p>Useful for {@code toString()} implementations.\n\t * @param coll the {@code Collection} to convert (potentially {@code null} or empty)\n\t * @return the delimited {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "coll"
    ],
    "position": {
      "column": 1,
      "line": 1313
    },
    "return": "String",
    "signature": "public String collectionToCommaDelimitedString(@Nullable Collection<?> coll)",
    "source_code": "\tpublic static String collectionToCommaDelimitedString(@Nullable Collection<?> coll) {\n\t\treturn collectionToDelimitedString(coll, \",\");\n\t}"
  },
  "org.springframework.util.StringUtils#collectionToDelimitedString(coll,delim)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a {@code Collection} into a delimited {@code String} (e.g. CSV).\n\t * <p>Useful for {@code toString()} implementations.\n\t * @param coll the {@code Collection} to convert (potentially {@code null} or empty)\n\t * @param delim the delimiter to use (typically a \",\")\n\t * @return the delimited {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "coll",
      "delim"
    ],
    "position": {
      "column": 1,
      "line": 1303
    },
    "return": "String",
    "signature": "public String collectionToDelimitedString(@Nullable Collection<?> coll, String delim)",
    "source_code": "\tpublic static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim) {\n\t\treturn collectionToDelimitedString(coll, delim, \"\", \"\");\n\t}"
  },
  "org.springframework.util.StringUtils#collectionToDelimitedString(coll,delim,prefix,suffix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a {@link Collection} to a delimited {@code String} (e.g. CSV).\n\t * <p>Useful for {@code toString()} implementations.\n\t * @param coll the {@code Collection} to convert (potentially {@code null} or empty)\n\t * @param delim the delimiter to use (typically a \",\")\n\t * @param prefix the {@code String} to start each element with\n\t * @param suffix the {@code String} to end each element with\n\t * @return the delimited {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "coll",
      "delim",
      "prefix",
      "suffix"
    ],
    "position": {
      "column": 1,
      "line": 1273
    },
    "return": "String",
    "signature": "public String collectionToDelimitedString(@Nullable Collection<?> coll, String delim, String prefix, String suffix)",
    "source_code": "\tpublic static String collectionToDelimitedString("
  },
  "org.springframework.util.StringUtils#commaDelimitedListToSet(str)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a comma delimited list (e.g., a row from a CSV file) into a set.\n\t * <p>Note that this will suppress duplicates, and as of 4.2, the elements in\n\t * the returned set will preserve the original order in a {@link LinkedHashSet}.\n\t * @param str the input {@code String} (potentially {@code null} or empty)\n\t * @return a set of {@code String} entries in the list\n\t * @see #removeDuplicateStrings(String[])\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str"
    ],
    "position": {
      "column": 1,
      "line": 1259
    },
    "return": "Set<String>",
    "signature": "public Set<String> commaDelimitedListToSet(@Nullable String str)",
    "source_code": "\tpublic static Set<String> commaDelimitedListToSet(@Nullable String str) {\n\t\tString[] tokens = commaDelimitedListToStringArray(str);\n\t\treturn new LinkedHashSet<>(Arrays.asList(tokens));\n\t}"
  },
  "org.springframework.util.StringUtils#commaDelimitedListToStringArray(str)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a comma delimited list (e.g., a row from a CSV file) into an\n\t * array of strings.\n\t * @param str the input {@code String} (potentially {@code null} or empty)\n\t * @return an array of strings, or the empty array in case of empty input\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str"
    ],
    "position": {
      "column": 1,
      "line": 1247
    },
    "return": "String[]",
    "signature": "public String[] commaDelimitedListToStringArray(@Nullable String str)",
    "source_code": "\tpublic static String[] commaDelimitedListToStringArray(@Nullable String str) {\n\t\treturn delimitedListToStringArray(str, \",\");\n\t}"
  },
  "org.springframework.util.StringUtils#concatenateStringArrays(array1,array2)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Concatenate the given {@code String} arrays into one,\n\t * with overlapping array elements included twice.\n\t * <p>The order of elements in the original arrays is preserved.\n\t * @param array1 the first array (can be {@code null})\n\t * @param array2 the second array (can be {@code null})\n\t * @return the new array ({@code null} if both given arrays were {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array1",
      "array2"
    ],
    "position": {
      "column": 1,
      "line": 981
    },
    "return": "String[]",
    "signature": "public String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2)",
    "source_code": "\tpublic static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2) {\n\t\tif (ObjectUtils.isEmpty(array1)) {\n\t\t\treturn array2;\n\t\t}\n\t\tif (ObjectUtils.isEmpty(array2)) {\n\t\t\treturn array1;\n\t\t}\n\n\t\tString[] newArr = new String[array1.length + array2.length];\n\t\tSystem.arraycopy(array1, 0, newArr, 0, array1.length);\n\t\tSystem.arraycopy(array2, 0, newArr, array1.length, array2.length);\n\t\treturn newArr;\n\t}"
  },
  "org.springframework.util.StringUtils#containsWhitespace(str)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given {@code String} contains any whitespace characters.\n\t * @param str the {@code String} to check (may be {@code null})\n\t * @return {@code true} if the {@code String} is not empty and\n\t * contains at least 1 whitespace character\n\t * @see #containsWhitespace(CharSequence)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "boolean",
    "signature": "public boolean containsWhitespace(@Nullable String str)",
    "source_code": "\tpublic static boolean containsWhitespace(@Nullable String str) {\n\t\treturn containsWhitespace((CharSequence) str);\n\t}"
  },
  "org.springframework.util.StringUtils#countOccurrencesOf(str,sub)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Count the occurrences of the substring {@code sub} in string {@code str}.\n\t * @param str string to search in\n\t * @param sub string to search for\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "sub"
    ],
    "position": {
      "column": 1,
      "line": 401
    },
    "return": "int",
    "signature": "public int countOccurrencesOf(String str, String sub)",
    "source_code": "\tpublic static int countOccurrencesOf(String str, String sub) {\n\t\tif (!hasLength(str) || !hasLength(sub)) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tint count = 0;\n\t\tint pos = 0;\n\t\tint idx;\n\t\twhile ((idx = str.indexOf(sub, pos)) != -1) {\n\t\t\t++count;\n\t\t\tpos = idx + sub.length();\n\t\t}\n\t\treturn count;\n\t}"
  },
  "org.springframework.util.StringUtils#delete(inString,pattern)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delete all occurrences of the given substring.\n\t * @param inString the original {@code String}\n\t * @param pattern the pattern to delete all occurrences of\n\t * @return the resulting {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inString",
      "pattern"
    ],
    "position": {
      "column": 1,
      "line": 459
    },
    "return": "String",
    "signature": "public String delete(String inString, String pattern)",
    "source_code": "\tpublic static String delete(String inString, String pattern) {\n\t\treturn replace(inString, pattern, \"\");\n\t}"
  },
  "org.springframework.util.StringUtils#deleteAny(inString,charsToDelete)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delete any character in a given {@code String}.\n\t * @param inString the original {@code String}\n\t * @param charsToDelete a set of characters to delete.\n\t * E.g. \"az\\n\" will delete 'a's, 'z's and new lines.\n\t * @return the resulting {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inString",
      "charsToDelete"
    ],
    "position": {
      "column": 1,
      "line": 470
    },
    "return": "String",
    "signature": "public String deleteAny(String inString, @Nullable String charsToDelete)",
    "source_code": "\tpublic static String deleteAny(String inString, @Nullable String charsToDelete) {\n\t\tif (!hasLength(inString) || !hasLength(charsToDelete)) {\n\t\t\treturn inString;\n\t\t}\n\n\t\tint lastCharIndex = 0;\n\t\tchar[] result = new char[inString.length()];\n\t\tfor (int i = 0; i < inString.length(); i++) {\n\t\t\tchar c = inString.charAt(i);\n\t\t\tif (charsToDelete.indexOf(c) == -1) {\n\t\t\t\tresult[lastCharIndex++] = c;\n\t\t\t}\n\t\t}\n\t\tif (lastCharIndex == inString.length()) {\n\t\t\treturn inString;\n\t\t}\n\t\treturn new String(result, 0, lastCharIndex);\n\t}"
  },
  "org.springframework.util.StringUtils#delimitedListToStringArray(str,delimiter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Take a {@code String} that is a delimited list and convert it into a\n\t * {@code String} array.\n\t * <p>A single {@code delimiter} may consist of more than one character,\n\t * but it will still be considered as a single delimiter string, rather\n\t * than as a bunch of potential delimiter characters, in contrast to\n\t * {@link #tokenizeToStringArray}.\n\t * @param str the input {@code String} (potentially {@code null} or empty)\n\t * @param delimiter the delimiter between elements (this is a single delimiter,\n\t * rather than a bunch individual delimiter characters)\n\t * @return an array of the tokens in the list\n\t * @see #tokenizeToStringArray\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "delimiter"
    ],
    "position": {
      "column": 1,
      "line": 1191
    },
    "return": "String[]",
    "signature": "public String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter)",
    "source_code": "\tpublic static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter) {\n\t\treturn delimitedListToStringArray(str, delimiter, null);\n\t}"
  },
  "org.springframework.util.StringUtils#delimitedListToStringArray(str,delimiter,charsToDelete)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Take a {@code String} that is a delimited list and convert it into\n\t * a {@code String} array.\n\t * <p>A single {@code delimiter} may consist of more than one character,\n\t * but it will still be considered as a single delimiter string, rather\n\t * than as a bunch of potential delimiter characters, in contrast to\n\t * {@link #tokenizeToStringArray}.\n\t * @param str the input {@code String} (potentially {@code null} or empty)\n\t * @param delimiter the delimiter between elements (this is a single delimiter,\n\t * rather than a bunch individual delimiter characters)\n\t * @param charsToDelete a set of characters to delete; useful for deleting unwanted\n\t * line breaks: e.g. \"\\r\\n\\f\" will delete all new lines and line feeds in a {@code String}\n\t * @return an array of the tokens in the list\n\t * @see #tokenizeToStringArray\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "delimiter",
      "charsToDelete"
    ],
    "position": {
      "column": 1,
      "line": 1210
    },
    "return": "String[]",
    "signature": "public String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete)",
    "source_code": "\tpublic static String[] delimitedListToStringArray("
  },
  "org.springframework.util.StringUtils#endsWithIgnoreCase(str,suffix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Test if the given {@code String} ends with the specified suffix,\n\t * ignoring upper/lower case.\n\t * @param str the {@code String} to check\n\t * @param suffix the suffix to look for\n\t * @see java.lang.String#endsWith\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "suffix"
    ],
    "position": {
      "column": 1,
      "line": 372
    },
    "return": "boolean",
    "signature": "public boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix)",
    "source_code": "\tpublic static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix) {\n\t\treturn (str != null && suffix != null && str.length() >= suffix.length() &&\n\t\t\t\tstr.regionMatches(true, str.length() - suffix.length(), suffix, 0, suffix.length()));\n\t}"
  },
  "org.springframework.util.StringUtils#getFilename(path)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extract the filename from the given Java resource path,\n\t * e.g. {@code \"mypath/myfile.txt\" &rarr; \"myfile.txt\"}.\n\t * @param path the file path (may be {@code null})\n\t * @return the extracted filename, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path"
    ],
    "position": {
      "column": 1,
      "line": 604
    },
    "return": "String",
    "signature": "public String getFilename(@Nullable String path)",
    "source_code": "\tpublic static String getFilename(@Nullable String path) {\n\t\tif (path == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tint separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR_CHAR);\n\t\treturn (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path);\n\t}"
  },
  "org.springframework.util.StringUtils#getFilenameExtension(path)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extract the filename extension from the given Java resource path,\n\t * e.g. \"mypath/myfile.txt\" &rarr; \"txt\".\n\t * @param path the file path (may be {@code null})\n\t * @return the extracted filename extension, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path"
    ],
    "position": {
      "column": 1,
      "line": 620
    },
    "return": "String",
    "signature": "public String getFilenameExtension(@Nullable String path)",
    "source_code": "\tpublic static String getFilenameExtension(@Nullable String path) {\n\t\tif (path == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tint extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n\t\tif (extIndex == -1) {\n\t\t\treturn null;\n\t\t}\n\n\t\tint folderIndex = path.lastIndexOf(FOLDER_SEPARATOR_CHAR);\n\t\tif (folderIndex > extIndex) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn path.substring(extIndex + 1);\n\t}"
  },
  "org.springframework.util.StringUtils#hasLength(str)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check that the given {@code String} is neither {@code null} nor of length 0.\n\t * <p>Note: this method returns {@code true} for a {@code String} that\n\t * purely consists of whitespace.\n\t * @param str the {@code String} to check (may be {@code null})\n\t * @return {@code true} if the {@code String} is not {@code null} and has length\n\t * @see #hasLength(CharSequence)\n\t * @see #hasText(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "boolean",
    "signature": "public boolean hasLength(@Nullable String str)",
    "source_code": "\tpublic static boolean hasLength(@Nullable String str) {\n\t\treturn (str != null && !str.isEmpty());\n\t}"
  },
  "org.springframework.util.StringUtils#hasText(str)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given {@code String} contains actual <em>text</em>.\n\t * <p>More specifically, this method returns {@code true} if the\n\t * {@code String} is not {@code null}, its length is greater than 0,\n\t * and it contains at least one non-whitespace character.\n\t * @param str the {@code String} to check (may be {@code null})\n\t * @return {@code true} if the {@code String} is not {@code null}, its\n\t * length is greater than 0, and it does not contain whitespace only\n\t * @see #hasText(CharSequence)\n\t * @see #hasLength(String)\n\t * @see Character#isWhitespace\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "boolean",
    "signature": "public boolean hasText(@Nullable String str)",
    "source_code": "\tpublic static boolean hasText(@Nullable String str) {\n\t\treturn (str != null && !str.isEmpty() && containsText(str));\n\t}"
  },
  "org.springframework.util.StringUtils#isEmpty(str)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given object (possibly a {@code String}) is empty.\n\t * This is effectively a shortcut for {@code !hasLength(String)}.\n\t * <p>This method accepts any Object as an argument, comparing it to\n\t * {@code null} and the empty String. As a consequence, this method\n\t * will never return {@code true} for a non-null non-String object.\n\t * <p>The Object signature is useful for general attribute handling code\n\t * that commonly deals with Strings but generally has to iterate over\n\t * Objects since attributes may e.g. be primitive value objects as well.\n\t * <p><b>Note: If the object is typed to {@code String} upfront, prefer\n\t * {@link #hasLength(String)} or {@link #hasText(String)} instead.</b>\n\t * @param str the candidate object (possibly a {@code String})\n\t * @since 3.2.1\n\t * @deprecated as of 5.3, in favor of {@link #hasLength(String)} and\n\t * {@link #hasText(String)} (or {@link ObjectUtils#isEmpty(Object)})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "boolean",
    "signature": "public boolean isEmpty(@Nullable Object str)",
    "source_code": "\tpublic static boolean isEmpty(@Nullable Object str) {\n\t\treturn (str == null || \"\".equals(str));\n\t}"
  },
  "org.springframework.util.StringUtils#matchesCharacter(str,singleCharacter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Test if the given {@code String} matches the given single character.\n\t * @param str the {@code String} to check\n\t * @param singleCharacter the character to compare to\n\t * @since 5.2.9\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "singleCharacter"
    ],
    "position": {
      "column": 1,
      "line": 349
    },
    "return": "boolean",
    "signature": "public boolean matchesCharacter(@Nullable String str, char singleCharacter)",
    "source_code": "\tpublic static boolean matchesCharacter(@Nullable String str, char singleCharacter) {\n\t\treturn (str != null && str.length() == 1 && str.charAt(0) == singleCharacter);\n\t}"
  },
  "org.springframework.util.StringUtils#parseLocale(localeValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the given {@code String} value into a {@link Locale}, accepting\n\t * the {@link Locale#toString} format as well as BCP 47 language tags as\n\t * specified by {@link Locale#forLanguageTag}.\n\t * @param localeValue the locale value: following either {@code Locale's}\n\t * {@code toString()} format (\"en\", \"en_UK\", etc), also accepting spaces as\n\t * separators (as an alternative to underscores), or BCP 47 (e.g. \"en-UK\")\n\t * @return a corresponding {@code Locale} instance, or {@code null} if none\n\t * @throws IllegalArgumentException in case of an invalid locale specification\n\t * @since 5.0.4\n\t * @see #parseLocaleString\n\t * @see Locale#forLanguageTag\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "localeValue"
    ],
    "position": {
      "column": 1,
      "line": 842
    },
    "return": "Locale",
    "signature": "public Locale parseLocale(String localeValue)",
    "source_code": "\tpublic static Locale parseLocale(String localeValue) {\n\t\tif (!localeValue.contains(\"_\") && !localeValue.contains(\" \")) {\n\t\t\tvalidateLocalePart(localeValue);\n\t\t\tLocale resolved = Locale.forLanguageTag(localeValue);\n\t\t\tif (resolved.getLanguage().length() > 0) {\n\t\t\t\treturn resolved;\n\t\t\t}\n\t\t}\n\t\treturn parseLocaleString(localeValue);\n\t}"
  },
  "org.springframework.util.StringUtils#parseLocaleString(localeString)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the given {@code String} representation into a {@link Locale}.\n\t * <p>For many parsing scenarios, this is an inverse operation of\n\t * {@link Locale#toString Locale's toString}, in a lenient sense.\n\t * This method does not aim for strict {@code Locale} design compliance;\n\t * it is rather specifically tailored for typical Spring parsing needs.\n\t * <p><b>Note: This delegate does not accept the BCP 47 language tag format.\n\t * Please use {@link #parseLocale} for lenient parsing of both formats.</b>\n\t * @param localeString the locale {@code String}: following {@code Locale's}\n\t * {@code toString()} format (\"en\", \"en_UK\", etc), also accepting spaces as\n\t * separators (as an alternative to underscores)\n\t * @return a corresponding {@code Locale} instance, or {@code null} if none\n\t * @throws IllegalArgumentException in case of an invalid locale specification\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "localeString"
    ],
    "position": {
      "column": 1,
      "line": 868
    },
    "return": "Locale",
    "signature": "public Locale parseLocaleString(String localeString)",
    "source_code": "\tpublic static Locale parseLocaleString(String localeString) {\n\t\tif (localeString.equals(\"\")) {\n\t\t\treturn null;\n\t\t}\n\t\tString delimiter = \"_\";\n\t\tif (!localeString.contains(\"_\") && localeString.contains(\" \")) {\n\t\t\tdelimiter = \" \";\n\t\t}\n\t\tfinal String[] tokens = localeString.split(delimiter, -1);\n\t\tif (tokens.length == 1) {\n\t\t\tfinal String language = tokens[0];\n\t\t\tvalidateLocalePart(language);\n\t\t\treturn new Locale(language);\n\t\t}\n\t\telse if (tokens.length == 2) {\n\t\t\tfinal String language = tokens[0];\n\t\t\tvalidateLocalePart(language);\n\t\t\tfinal String country = tokens[1];\n\t\t\tvalidateLocalePart(country);\n\t\t\treturn new Locale(language, country);\n\t\t}\n\t\telse if (tokens.length > 2) {\n\t\t\tfinal String language = tokens[0];\n\t\t\tvalidateLocalePart(language);\n\t\t\tfinal String country = tokens[1];\n\t\t\tvalidateLocalePart(country);\n\t\t\tfinal String variant = Arrays.stream(tokens).skip(2).collect(Collectors.joining(delimiter));\n\t\t\treturn new Locale(language, country, variant);\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Invalid locale format: '\" + localeString + \"'\");\n\t}"
  },
  "org.springframework.util.StringUtils#parseTimeZoneString(timeZoneString)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the given {@code timeZoneString} value into a {@link TimeZone}.\n\t * @param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}\n\t * but throwing {@link IllegalArgumentException} in case of an invalid time zone specification\n\t * @return a corresponding {@link TimeZone} instance\n\t * @throws IllegalArgumentException in case of an invalid time zone specification\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeZoneString"
    ],
    "position": {
      "column": 1,
      "line": 917
    },
    "return": "TimeZone",
    "signature": "public TimeZone parseTimeZoneString(String timeZoneString)",
    "source_code": "\tpublic static TimeZone parseTimeZoneString(String timeZoneString) {\n\t\tTimeZone timeZone = TimeZone.getTimeZone(timeZoneString);\n\t\tif (\"GMT\".equals(timeZone.getID()) && !timeZoneString.startsWith(\"GMT\")) {\n\t\t\t// We don't want that GMT fallback...\n\t\t\tthrow new IllegalArgumentException(\"Invalid time zone specification '\" + timeZoneString + \"'\");\n\t\t}\n\t\treturn timeZone;\n\t}"
  },
  "org.springframework.util.StringUtils#pathEquals(path1,path2)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Compare two paths after normalization of them.\n\t * @param path1 first path for comparison\n\t * @param path2 second path for comparison\n\t * @return whether the two paths are equivalent after normalization\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path1",
      "path2"
    ],
    "position": {
      "column": 1,
      "line": 774
    },
    "return": "boolean",
    "signature": "public boolean pathEquals(String path1, String path2)",
    "source_code": "\tpublic static boolean pathEquals(String path1, String path2) {\n\t\treturn cleanPath(path1).equals(cleanPath(path2));\n\t}"
  },
  "org.springframework.util.StringUtils#quote(str)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Quote the given {@code String} with single quotes.\n\t * @param str the input {@code String} (e.g. \"myString\")\n\t * @return the quoted {@code String} (e.g. \"'myString'\"),\n\t * or {@code null} if the input was {@code null}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str"
    ],
    "position": {
      "column": 1,
      "line": 500
    },
    "return": "String",
    "signature": "public String quote(@Nullable String str)",
    "source_code": "\tpublic static String quote(@Nullable String str) {\n\t\treturn (str != null ? \"'\" + str + \"'\" : null);\n\t}"
  },
  "org.springframework.util.StringUtils#quoteIfString(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Turn the given Object into a {@code String} with single quotes\n\t * if it is a {@code String}; keeping the Object as-is else.\n\t * @param obj the input Object (e.g. \"myString\")\n\t * @return the quoted {@code String} (e.g. \"'myString'\"),\n\t * or the input object as-is if not a {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 512
    },
    "return": "Object",
    "signature": "public Object quoteIfString(@Nullable Object obj)",
    "source_code": "\tpublic static Object quoteIfString(@Nullable Object obj) {\n\t\treturn (obj instanceof String text ? quote(text) : obj);\n\t}"
  },
  "org.springframework.util.StringUtils#removeDuplicateStrings(array)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Remove duplicate strings from the given array.\n\t * <p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}.\n\t * @param array the {@code String} array (potentially empty)\n\t * @return an array without duplicates, in natural sort order\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array"
    ],
    "position": {
      "column": 1,
      "line": 1034
    },
    "return": "String[]",
    "signature": "public String[] removeDuplicateStrings(String[] array)",
    "source_code": "\tpublic static String[] removeDuplicateStrings(String[] array) {\n\t\tif (ObjectUtils.isEmpty(array)) {\n\t\t\treturn array;\n\t\t}\n\n\t\tSet<String> set = new LinkedHashSet<>(Arrays.asList(array));\n\t\treturn toStringArray(set);\n\t}"
  },
  "org.springframework.util.StringUtils#replace(inString,oldPattern,newPattern)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Replace all occurrences of a substring within a string with another string.\n\t * @param inString {@code String} to examine\n\t * @param oldPattern {@code String} to replace\n\t * @param newPattern {@code String} to insert\n\t * @return a {@code String} with the replacements\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inString",
      "oldPattern",
      "newPattern"
    ],
    "position": {
      "column": 1,
      "line": 423
    },
    "return": "String",
    "signature": "public String replace(String inString, String oldPattern, @Nullable String newPattern)",
    "source_code": "\tpublic static String replace(String inString, String oldPattern, @Nullable String newPattern) {\n\t\tif (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {\n\t\t\treturn inString;\n\t\t}\n\t\tint index = inString.indexOf(oldPattern);\n\t\tif (index == -1) {\n\t\t\t// no occurrence -> can return input as-is\n\t\t\treturn inString;\n\t\t}\n\n\t\tint capacity = inString.length();\n\t\tif (newPattern.length() > oldPattern.length()) {\n\t\t\tcapacity += 16;\n\t\t}\n\t\tStringBuilder sb = new StringBuilder(capacity);\n\n\t\tint pos = 0;  // our position in the old string\n\t\tint patLen = oldPattern.length();\n\t\twhile (index >= 0) {\n\t\t\tsb.append(inString, pos, index);\n\t\t\tsb.append(newPattern);\n\t\t\tpos = index + patLen;\n\t\t\tindex = inString.indexOf(oldPattern, pos);\n\t\t}\n\n\t\t// append any characters to the right of a match\n\t\tsb.append(inString, pos, inString.length());\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.util.StringUtils#sortStringArray(array)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Sort the given {@code String} array if necessary.\n\t * @param array the original array (potentially empty)\n\t * @return the array in sorted form (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array"
    ],
    "position": {
      "column": 1,
      "line": 1000
    },
    "return": "String[]",
    "signature": "public String[] sortStringArray(String[] array)",
    "source_code": "\tpublic static String[] sortStringArray(String[] array) {\n\t\tif (ObjectUtils.isEmpty(array)) {\n\t\t\treturn array;\n\t\t}\n\n\t\tArrays.sort(array);\n\t\treturn array;\n\t}"
  },
  "org.springframework.util.StringUtils#split(toSplit,delimiter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Split a {@code String} at the first occurrence of the delimiter.\n\t * Does not include the delimiter in the result.\n\t * @param toSplit the string to split (potentially {@code null} or empty)\n\t * @param delimiter to split the string up with (potentially {@code null} or empty)\n\t * @return a two element array with index 0 being before the delimiter, and\n\t * index 1 being after the delimiter (neither element includes the delimiter);\n\t * or {@code null} if the delimiter wasn't found in the given input {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "toSplit",
      "delimiter"
    ],
    "position": {
      "column": 1,
      "line": 1053
    },
    "return": "String[]",
    "signature": "public String[] split(@Nullable String toSplit, @Nullable String delimiter)",
    "source_code": "\tpublic static String[] split(@Nullable String toSplit, @Nullable String delimiter) {\n\t\tif (!hasLength(toSplit) || !hasLength(delimiter)) {\n\t\t\treturn null;\n\t\t}\n\t\tint offset = toSplit.indexOf(delimiter);\n\t\tif (offset < 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString beforeDelimiter = toSplit.substring(0, offset);\n\t\tString afterDelimiter = toSplit.substring(offset + delimiter.length());\n\t\treturn new String[] {beforeDelimiter, afterDelimiter};\n\t}"
  },
  "org.springframework.util.StringUtils#splitArrayElementsIntoProperties(array,delimiter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Take an array of strings and split each element based on the given delimiter.\n\t * A {@code Properties} instance is then generated, with the left of the delimiter\n\t * providing the key, and the right of the delimiter providing the value.\n\t * <p>Will trim both the key and value before adding them to the {@code Properties}.\n\t * @param array the array to process\n\t * @param delimiter to split each element using (typically the equals symbol)\n\t * @return a {@code Properties} instance representing the array contents,\n\t * or {@code null} if the array to process was {@code null} or empty\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array",
      "delimiter"
    ],
    "position": {
      "column": 1,
      "line": 1078
    },
    "return": "Properties",
    "signature": "public Properties splitArrayElementsIntoProperties(String[] array, String delimiter)",
    "source_code": "\tpublic static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {\n\t\treturn splitArrayElementsIntoProperties(array, delimiter, null);\n\t}"
  },
  "org.springframework.util.StringUtils#splitArrayElementsIntoProperties(array,delimiter,charsToDelete)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Take an array of strings and split each element based on the given delimiter.\n\t * A {@code Properties} instance is then generated, with the left of the\n\t * delimiter providing the key, and the right of the delimiter providing the value.\n\t * <p>Will trim both the key and value before adding them to the\n\t * {@code Properties} instance.\n\t * @param array the array to process\n\t * @param delimiter to split each element using (typically the equals symbol)\n\t * @param charsToDelete one or more characters to remove from each element\n\t * prior to attempting the split operation (typically the quotation mark\n\t * symbol), or {@code null} if no removal should occur\n\t * @return a {@code Properties} instance representing the array contents,\n\t * or {@code null} if the array to process was {@code null} or empty\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array",
      "delimiter",
      "charsToDelete"
    ],
    "position": {
      "column": 1,
      "line": 1097
    },
    "return": "Properties",
    "signature": "public Properties splitArrayElementsIntoProperties(String[] array, String delimiter, @Nullable String charsToDelete)",
    "source_code": "\tpublic static Properties splitArrayElementsIntoProperties("
  },
  "org.springframework.util.StringUtils#startsWithIgnoreCase(str,prefix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Test if the given {@code String} starts with the specified prefix,\n\t * ignoring upper/lower case.\n\t * @param str the {@code String} to check\n\t * @param prefix the prefix to look for\n\t * @see java.lang.String#startsWith\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "prefix"
    ],
    "position": {
      "column": 1,
      "line": 360
    },
    "return": "boolean",
    "signature": "public boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix)",
    "source_code": "\tpublic static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix) {\n\t\treturn (str != null && prefix != null && str.length() >= prefix.length() &&\n\t\t\t\tstr.regionMatches(true, 0, prefix, 0, prefix.length()));\n\t}"
  },
  "org.springframework.util.StringUtils#stripFilenameExtension(path)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Strip the filename extension from the given Java resource path,\n\t * e.g. \"mypath/myfile.txt\" &rarr; \"mypath/myfile\".\n\t * @param path the file path\n\t * @return the path with stripped filename extension\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path"
    ],
    "position": {
      "column": 1,
      "line": 644
    },
    "return": "String",
    "signature": "public String stripFilenameExtension(String path)",
    "source_code": "\tpublic static String stripFilenameExtension(String path) {\n\t\tint extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n\t\tif (extIndex == -1) {\n\t\t\treturn path;\n\t\t}\n\n\t\tint folderIndex = path.lastIndexOf(FOLDER_SEPARATOR_CHAR);\n\t\tif (folderIndex > extIndex) {\n\t\t\treturn path;\n\t\t}\n\n\t\treturn path.substring(0, extIndex);\n\t}"
  },
  "org.springframework.util.StringUtils#substringMatch(str,index,substring)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Test whether the given string matches the given substring\n\t * at the given index.\n\t * @param str the original string (or StringBuilder)\n\t * @param index the index in the original string to start matching against\n\t * @param substring the substring to match at the given index\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "index",
      "substring"
    ],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "boolean",
    "signature": "public boolean substringMatch(CharSequence str, int index, CharSequence substring)",
    "source_code": "\tpublic static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n\t\tif (index + substring.length() > str.length()) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < substring.length(); i++) {\n\t\t\tif (str.charAt(index + i) != substring.charAt(i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.util.StringUtils#toStringArray(collection)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy the given {@link Collection} into a {@code String} array.\n\t * <p>The {@code Collection} must contain {@code String} elements only.\n\t * @param collection the {@code Collection} to copy\n\t * (potentially {@code null} or empty)\n\t * @return the resulting {@code String} array\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collection"
    ],
    "position": {
      "column": 1,
      "line": 938
    },
    "return": "String[]",
    "signature": "public String[] toStringArray(@Nullable Collection<String> collection)",
    "source_code": "\tpublic static String[] toStringArray(@Nullable Collection<String> collection) {\n\t\treturn (!CollectionUtils.isEmpty(collection) ? collection.toArray(EMPTY_STRING_ARRAY) : EMPTY_STRING_ARRAY);\n\t}"
  },
  "org.springframework.util.StringUtils#toStringArray(enumeration)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy the given {@link Enumeration} into a {@code String} array.\n\t * <p>The {@code Enumeration} must contain {@code String} elements only.\n\t * @param enumeration the {@code Enumeration} to copy\n\t * (potentially {@code null} or empty)\n\t * @return the resulting {@code String} array\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "enumeration"
    ],
    "position": {
      "column": 1,
      "line": 949
    },
    "return": "String[]",
    "signature": "public String[] toStringArray(@Nullable Enumeration<String> enumeration)",
    "source_code": "\tpublic static String[] toStringArray(@Nullable Enumeration<String> enumeration) {\n\t\treturn (enumeration != null ? toStringArray(Collections.list(enumeration)) : EMPTY_STRING_ARRAY);\n\t}"
  },
  "org.springframework.util.StringUtils#tokenizeToStringArray(str,delimiters)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Tokenize the given {@code String} into a {@code String} array via a\n\t * {@link StringTokenizer}.\n\t * <p>Trims tokens and omits empty tokens.\n\t * <p>The given {@code delimiters} string can consist of any number of\n\t * delimiter characters. Each of those characters can be used to separate\n\t * tokens. A delimiter is always a single character; for multi-character\n\t * delimiters, consider using {@link #delimitedListToStringArray}.\n\t * @param str the {@code String} to tokenize (potentially {@code null} or empty)\n\t * @param delimiters the delimiter characters, assembled as a {@code String}\n\t * (each of the characters is individually considered as a delimiter)\n\t * @return an array of the tokens\n\t * @see java.util.StringTokenizer\n\t * @see String#trim()\n\t * @see #delimitedListToStringArray\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "delimiters"
    ],
    "position": {
      "column": 1,
      "line": 1134
    },
    "return": "String[]",
    "signature": "public String[] tokenizeToStringArray(@Nullable String str, String delimiters)",
    "source_code": "\tpublic static String[] tokenizeToStringArray(@Nullable String str, String delimiters) {\n\t\treturn tokenizeToStringArray(str, delimiters, true, true);\n\t}"
  },
  "org.springframework.util.StringUtils#tokenizeToStringArray(str,delimiters,trimTokens,ignoreEmptyTokens)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Tokenize the given {@code String} into a {@code String} array via a\n\t * {@link StringTokenizer}.\n\t * <p>The given {@code delimiters} string can consist of any number of\n\t * delimiter characters. Each of those characters can be used to separate\n\t * tokens. A delimiter is always a single character; for multi-character\n\t * delimiters, consider using {@link #delimitedListToStringArray}.\n\t * @param str the {@code String} to tokenize (potentially {@code null} or empty)\n\t * @param delimiters the delimiter characters, assembled as a {@code String}\n\t * (each of the characters is individually considered as a delimiter)\n\t * @param trimTokens trim the tokens via {@link String#trim()}\n\t * @param ignoreEmptyTokens omit empty tokens from the result array\n\t * (only applies to tokens that are empty after trimming; StringTokenizer\n\t * will not consider subsequent delimiters as token in the first place).\n\t * @return an array of the tokens\n\t * @see java.util.StringTokenizer\n\t * @see String#trim()\n\t * @see #delimitedListToStringArray\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "delimiters",
      "trimTokens",
      "ignoreEmptyTokens"
    ],
    "position": {
      "column": 1,
      "line": 1157
    },
    "return": "String[]",
    "signature": "public String[] tokenizeToStringArray(@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens)",
    "source_code": "\tpublic static String[] tokenizeToStringArray("
  },
  "org.springframework.util.StringUtils#trimAllWhitespace(str)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Trim <em>all</em> whitespace from the given {@code String}:\n\t * leading, trailing, and in between characters.\n\t * @param str the {@code String} to check\n\t * @return the trimmed {@code String}\n\t * @see #trimAllWhitespace(CharSequence)\n\t * @see java.lang.Character#isWhitespace\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str"
    ],
    "position": {
      "column": 1,
      "line": 268
    },
    "return": "String",
    "signature": "public String trimAllWhitespace(String str)",
    "source_code": "\tpublic static String trimAllWhitespace(String str) {\n\t\tif (str == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn trimAllWhitespace((CharSequence) str).toString();\n\t}"
  },
  "org.springframework.util.StringUtils#trimAllWhitespace(text)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Trim <em>all</em> whitespace from the given {@code CharSequence}:\n\t * leading, trailing, and in between characters.\n\t * @param text the {@code CharSequence} to check\n\t * @return the trimmed {@code CharSequence}\n\t * @since 5.3.22\n\t * @see #trimAllWhitespace(String)\n\t * @see java.lang.Character#isWhitespace\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text"
    ],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "CharSequence",
    "signature": "public CharSequence trimAllWhitespace(CharSequence text)",
    "source_code": "\tpublic static CharSequence trimAllWhitespace(CharSequence text) {\n\t\tif (!hasLength(text)) {\n\t\t\treturn text;\n\t\t}\n\n\t\tint len = text.length();\n\t\tStringBuilder sb = new StringBuilder(text.length());\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tchar c = text.charAt(i);\n\t\t\tif (!Character.isWhitespace(c)) {\n\t\t\t\tsb.append(c);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.util.StringUtils#trimArrayElements(array)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Trim the elements of the given {@code String} array, calling\n\t * {@code String.trim()} on each non-null element.\n\t * @param array the original {@code String} array (potentially empty)\n\t * @return the resulting array (of the same size) with trimmed elements\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array"
    ],
    "position": {
      "column": 1,
      "line": 1015
    },
    "return": "String[]",
    "signature": "public String[] trimArrayElements(String[] array)",
    "source_code": "\tpublic static String[] trimArrayElements(String[] array) {\n\t\tif (ObjectUtils.isEmpty(array)) {\n\t\t\treturn array;\n\t\t}\n\n\t\tString[] result = new String[array.length];\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tString element = array[i];\n\t\t\tresult[i] = (element != null ? element.trim() : null);\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.util.StringUtils#trimLeadingCharacter(str,leadingCharacter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Trim all occurrences of the supplied leading character from the given {@code String}.\n\t * @param str the {@code String} to check\n\t * @param leadingCharacter the leading character to be trimmed\n\t * @return the trimmed {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "leadingCharacter"
    ],
    "position": {
      "column": 1,
      "line": 313
    },
    "return": "String",
    "signature": "public String trimLeadingCharacter(String str, char leadingCharacter)",
    "source_code": "\tpublic static String trimLeadingCharacter(String str, char leadingCharacter) {\n\t\tif (!hasLength(str)) {\n\t\t\treturn str;\n\t\t}\n\n\t\tint beginIdx = 0;\n\t\twhile (beginIdx < str.length() && leadingCharacter == str.charAt(beginIdx)) {\n\t\t\tbeginIdx++;\n\t\t}\n\t\treturn str.substring(beginIdx);\n\t}"
  },
  "org.springframework.util.StringUtils#trimLeadingWhitespace(str)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Trim leading whitespace from the given {@code String}.\n\t * @param str the {@code String} to check\n\t * @return the trimmed {@code String}\n\t * @see java.lang.Character#isWhitespace\n\t * @deprecated since 6.0, in favor of {@link String#stripLeading()}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str"
    ],
    "position": {
      "column": 1,
      "line": 283
    },
    "return": "String",
    "signature": "public String trimLeadingWhitespace(String str)",
    "source_code": "\tpublic static String trimLeadingWhitespace(String str) {\n\t\tif (!hasLength(str)) {\n\t\t\treturn str;\n\t\t}\n\n\t\treturn str.stripLeading();\n\t}"
  },
  "org.springframework.util.StringUtils#trimTrailingCharacter(str,trailingCharacter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Trim all occurrences of the supplied trailing character from the given {@code String}.\n\t * @param str the {@code String} to check\n\t * @param trailingCharacter the trailing character to be trimmed\n\t * @return the trimmed {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "trailingCharacter"
    ],
    "position": {
      "column": 1,
      "line": 331
    },
    "return": "String",
    "signature": "public String trimTrailingCharacter(String str, char trailingCharacter)",
    "source_code": "\tpublic static String trimTrailingCharacter(String str, char trailingCharacter) {\n\t\tif (!hasLength(str)) {\n\t\t\treturn str;\n\t\t}\n\n\t\tint endIdx = str.length() - 1;\n\t\twhile (endIdx >= 0 && trailingCharacter == str.charAt(endIdx)) {\n\t\t\tendIdx--;\n\t\t}\n\t\treturn str.substring(0, endIdx + 1);\n\t}"
  },
  "org.springframework.util.StringUtils#trimTrailingWhitespace(str)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Trim trailing whitespace from the given {@code String}.\n\t * @param str the {@code String} to check\n\t * @return the trimmed {@code String}\n\t * @see java.lang.Character#isWhitespace\n\t * @deprecated since 6.0, in favor of {@link String#stripTrailing()}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str"
    ],
    "position": {
      "column": 1,
      "line": 299
    },
    "return": "String",
    "signature": "public String trimTrailingWhitespace(String str)",
    "source_code": "\tpublic static String trimTrailingWhitespace(String str) {\n\t\tif (!hasLength(str)) {\n\t\t\treturn str;\n\t\t}\n\n\t\treturn str.stripTrailing();\n\t}"
  },
  "org.springframework.util.StringUtils#trimWhitespace(str)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Trim leading and trailing whitespace from the given {@code String}.\n\t * @param str the {@code String} to check\n\t * @return the trimmed {@code String}\n\t * @see java.lang.Character#isWhitespace\n\t * @deprecated since 6.0, in favor of {@link String#strip()}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "String",
    "signature": "public String trimWhitespace(String str)",
    "source_code": "\tpublic static String trimWhitespace(String str) {\n\t\tif (!hasLength(str)) {\n\t\t\treturn str;\n\t\t}\n\n\t\treturn str.strip();\n\t}"
  },
  "org.springframework.util.StringUtils#uncapitalize(str)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Uncapitalize a {@code String}, changing the first letter to\n\t * lower case as per {@link Character#toLowerCase(char)}.\n\t * No other letters are changed.\n\t * @param str the {@code String} to uncapitalize\n\t * @return the uncapitalized {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str"
    ],
    "position": {
      "column": 1,
      "line": 553
    },
    "return": "String",
    "signature": "public String uncapitalize(String str)",
    "source_code": "\tpublic static String uncapitalize(String str) {\n\t\treturn changeFirstCharacterCase(str, false);\n\t}"
  },
  "org.springframework.util.StringUtils#uncapitalizeAsProperty(str)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Uncapitalize a {@code String} in JavaBeans property format,\n\t * changing the first letter to lower case as per\n\t * {@link Character#toLowerCase(char)}, unless the initial two\n\t * letters are upper case in direct succession.\n\t * @param str the {@code String} to uncapitalize\n\t * @return the uncapitalized {@code String}\n\t * @since 6.0\n\t * @see java.beans.Introspector#decapitalize(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str"
    ],
    "position": {
      "column": 1,
      "line": 567
    },
    "return": "String",
    "signature": "public String uncapitalizeAsProperty(String str)",
    "source_code": "\tpublic static String uncapitalizeAsProperty(String str) {\n\t\tif (!hasLength(str) || (str.length() > 1 && Character.isUpperCase(str.charAt(0)) &&\n\t\t\t\tCharacter.isUpperCase(str.charAt(1)))) {\n\t\t\treturn str;\n\t\t}\n\t\treturn changeFirstCharacterCase(str, false);\n\t}"
  },
  "org.springframework.util.StringUtils#unqualify(qualifiedName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Unqualify a string qualified by a '.' dot character. For example,\n\t * \"this.name.is.qualified\", returns \"qualified\".\n\t * @param qualifiedName the qualified name\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "qualifiedName"
    ],
    "position": {
      "column": 1,
      "line": 521
    },
    "return": "String",
    "signature": "public String unqualify(String qualifiedName)",
    "source_code": "\tpublic static String unqualify(String qualifiedName) {\n\t\treturn unqualify(qualifiedName, '.');\n\t}"
  },
  "org.springframework.util.StringUtils#unqualify(qualifiedName,separator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Unqualify a string qualified by a separator character. For example,\n\t * \"this:name:is:qualified\" returns \"qualified\" if using a ':' separator.\n\t * @param qualifiedName the qualified name\n\t * @param separator the separator\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "qualifiedName",
      "separator"
    ],
    "position": {
      "column": 1,
      "line": 531
    },
    "return": "String",
    "signature": "public String unqualify(String qualifiedName, char separator)",
    "source_code": "\tpublic static String unqualify(String qualifiedName, char separator) {\n\t\treturn qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1);\n\t}"
  },
  "org.springframework.util.StringUtils#uriDecode(source,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Decode the given encoded URI component value. Based on the following rules:\n\t * <ul>\n\t * <li>Alphanumeric characters {@code \"a\"} through {@code \"z\"}, {@code \"A\"} through {@code \"Z\"},\n\t * and {@code \"0\"} through {@code \"9\"} stay the same.</li>\n\t * <li>Special characters {@code \"-\"}, {@code \"_\"}, {@code \".\"}, and {@code \"*\"} stay the same.</li>\n\t * <li>A sequence \"{@code %<i>xy</i>}\" is interpreted as a hexadecimal representation of the character.</li>\n\t * </ul>\n\t * @param source the encoded String\n\t * @param charset the character set\n\t * @return the decoded value\n\t * @throws IllegalArgumentException when the given source contains invalid encoded sequences\n\t * @since 5.0\n\t * @see java.net.URLDecoder#decode(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 793
    },
    "return": "String",
    "signature": "public String uriDecode(String source, Charset charset)",
    "source_code": "\tpublic static String uriDecode(String source, Charset charset) {\n\t\tint length = source.length();\n\t\tif (length == 0) {\n\t\t\treturn source;\n\t\t}\n\t\tAssert.notNull(charset, \"Charset must not be null\");\n\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream(length);\n\t\tboolean changed = false;\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tint ch = source.charAt(i);\n\t\t\tif (ch == '%') {\n\t\t\t\tif (i + 2 < length) {\n\t\t\t\t\tchar hex1 = source.charAt(i + 1);\n\t\t\t\t\tchar hex2 = source.charAt(i + 2);\n\t\t\t\t\tint u = Character.digit(hex1, 16);\n\t\t\t\t\tint l = Character.digit(hex2, 16);\n\t\t\t\t\tif (u == -1 || l == -1) {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid encoded sequence \\\"\" + source.substring(i) + \"\\\"\");\n\t\t\t\t\t}\n\t\t\t\t\tbaos.write((char) ((u << 4) + l));\n\t\t\t\t\ti += 2;\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid encoded sequence \\\"\" + source.substring(i) + \"\\\"\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbaos.write(ch);\n\t\t\t}\n\t\t}\n\t\treturn (changed ? StreamUtils.copyToString(baos, charset) : source);\n\t}"
  },
  "org.springframework.util.comparator.BooleanComparator": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A {@link Comparator} for {@link Boolean} objects that can sort either\n * {@code true} or {@code false} first.\n *\n * @author Keith Donald\n * @since 1.2.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 32
    },
    "signature": "public class BooleanComparator",
    "source_code": "public class BooleanComparator implements Comparator<Boolean>, Serializable {\n\n\t/**\n\t * A shared default instance of this comparator,\n\t * treating {@code true} lower than {@code false}.\n\t */\n\tpublic static final BooleanComparator TRUE_LOW = new BooleanComparator(true);\n\n\t/**\n\t * A shared default instance of this comparator,\n\t * treating {@code true} higher than {@code false}.\n\t */\n\tpublic static final BooleanComparator TRUE_HIGH = new BooleanComparator(false);\n\n\n\tprivate final boolean trueLow;\n\n\n\t/**\n\t * Create a BooleanComparator that sorts boolean values based on\n\t * the provided flag.\n\t * <p>Alternatively, you can use the default shared instances:\n\t * {@code BooleanComparator.TRUE_LOW} and\n\t * {@code BooleanComparator.TRUE_HIGH}.\n\t * @param trueLow whether to treat true as lower or higher than false\n\t * @see #TRUE_LOW\n\t * @see #TRUE_HIGH\n\t */\n\tpublic BooleanComparator(boolean trueLow) {\n\t\tthis.trueLow = trueLow;\n\t}\n\n\n\t@Override\n\tpublic int compare(Boolean v1, Boolean v2) {\n\t\treturn (v1 ^ v2) ? ((v1 ^ this.trueLow) ? 1 : -1) : 0;\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof BooleanComparator that && this.trueLow == that.trueLow));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn getClass().hashCode() * (this.trueLow ? -1 : 1);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"BooleanComparator: \" + (this.trueLow ? \"true low\" : \"true high\");\n\t}\n\n}"
  },
  "org.springframework.util.comparator.BooleanComparator#compare(v1,v2)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "v1",
      "v2"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "int",
    "signature": "public int compare(Boolean v1, Boolean v2)",
    "source_code": "\tpublic int compare(Boolean v1, Boolean v2) {\n\t\treturn (v1 ^ v2) ? ((v1 ^ this.trueLow) ? 1 : -1) : 0;\n\t}"
  },
  "org.springframework.util.comparator.BooleanComparator#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof BooleanComparator that && this.trueLow == that.trueLow));\n\t}"
  },
  "org.springframework.util.comparator.BooleanComparator#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn getClass().hashCode() * (this.trueLow ? -1 : 1);\n\t}"
  },
  "org.springframework.util.comparator.BooleanComparator#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn \"BooleanComparator: \" + (this.trueLow ? \"true low\" : \"true high\");\n\t}"
  },
  "org.springframework.util.comparator.TRUE_HIGH": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A shared default instance of this comparator,\n\t * treating {@code true} higher than {@code false}.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "signature": "public BooleanComparator TRUE_HIGH",
    "source_code": "\tpublic static final BooleanComparator TRUE_HIGH = new BooleanComparator(false);",
    "type": "BooleanComparator"
  },
  "org.springframework.util.comparator.TRUE_LOW": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A shared default instance of this comparator,\n\t * treating {@code true} lower than {@code false}.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "signature": "public BooleanComparator TRUE_LOW",
    "source_code": "\tpublic static final BooleanComparator TRUE_LOW = new BooleanComparator(true);",
    "type": "BooleanComparator"
  },
  "org.springframework.web.context.request.async.WEB_ASYNC_MANAGER_ATTRIBUTE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The name attribute containing the {@link WebAsyncManager}.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "signature": "public String WEB_ASYNC_MANAGER_ATTRIBUTE",
    "source_code": "\tpublic static final String WEB_ASYNC_MANAGER_ATTRIBUTE =",
    "type": "String"
  },
  "org.springframework.web.context.request.async.WebAsyncUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Utility methods related to processing asynchronous web requests.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 3.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 33
    },
    "signature": "public class WebAsyncUtils",
    "source_code": "public abstract class WebAsyncUtils {\n\n\t/**\n\t * The name attribute containing the {@link WebAsyncManager}.\n\t */\n\tpublic static final String WEB_ASYNC_MANAGER_ATTRIBUTE =\n\t\t\tWebAsyncManager.class.getName() + \".WEB_ASYNC_MANAGER\";\n\n\n\t/**\n\t * Obtain the {@link WebAsyncManager} for the current request, or if not\n\t * found, create and associate it with the request.\n\t */\n\tpublic static WebAsyncManager getAsyncManager(ServletRequest servletRequest) {\n\t\tWebAsyncManager asyncManager = null;\n\t\tObject asyncManagerAttr = servletRequest.getAttribute(WEB_ASYNC_MANAGER_ATTRIBUTE);\n\t\tif (asyncManagerAttr instanceof WebAsyncManager wam) {\n\t\t\tasyncManager = wam;\n\t\t}\n\t\tif (asyncManager == null) {\n\t\t\tasyncManager = new WebAsyncManager();\n\t\t\tservletRequest.setAttribute(WEB_ASYNC_MANAGER_ATTRIBUTE, asyncManager);\n\t\t}\n\t\treturn asyncManager;\n\t}\n\n\t/**\n\t * Obtain the {@link WebAsyncManager} for the current request, or if not\n\t * found, create and associate it with the request.\n\t */\n\tpublic static WebAsyncManager getAsyncManager(WebRequest webRequest) {\n\t\tint scope = RequestAttributes.SCOPE_REQUEST;\n\t\tWebAsyncManager asyncManager = null;\n\t\tObject asyncManagerAttr = webRequest.getAttribute(WEB_ASYNC_MANAGER_ATTRIBUTE, scope);\n\t\tif (asyncManagerAttr instanceof WebAsyncManager wam) {\n\t\t\tasyncManager = wam;\n\t\t}\n\t\tif (asyncManager == null) {\n\t\t\tasyncManager = new WebAsyncManager();\n\t\t\twebRequest.setAttribute(WEB_ASYNC_MANAGER_ATTRIBUTE, asyncManager, scope);\n\t\t}\n\t\treturn asyncManager;\n\t}\n\n\t/**\n\t * Create an AsyncWebRequest instance. By default, an instance of\n\t * {@link StandardServletAsyncWebRequest} gets created.\n\t * @param request the current request\n\t * @param response the current response\n\t * @return an AsyncWebRequest instance (never {@code null})\n\t */\n\tpublic static AsyncWebRequest createAsyncWebRequest(HttpServletRequest request, HttpServletResponse response) {\n\t\treturn new StandardServletAsyncWebRequest(request, response);\n\t}\n\n}"
  },
  "org.springframework.web.context.request.async.WebAsyncUtils#createAsyncWebRequest(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an AsyncWebRequest instance. By default, an instance of\n\t * {@link StandardServletAsyncWebRequest} gets created.\n\t * @param request the current request\n\t * @param response the current response\n\t * @return an AsyncWebRequest instance (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "AsyncWebRequest",
    "signature": "public AsyncWebRequest createAsyncWebRequest(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tpublic static AsyncWebRequest createAsyncWebRequest(HttpServletRequest request, HttpServletResponse response) {\n\t\treturn new StandardServletAsyncWebRequest(request, response);\n\t}"
  },
  "org.springframework.web.context.request.async.WebAsyncUtils#getAsyncManager(servletRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain the {@link WebAsyncManager} for the current request, or if not\n\t * found, create and associate it with the request.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletRequest"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "return": "WebAsyncManager",
    "signature": "public WebAsyncManager getAsyncManager(ServletRequest servletRequest)",
    "source_code": "\tpublic static WebAsyncManager getAsyncManager(ServletRequest servletRequest) {\n\t\tWebAsyncManager asyncManager = null;\n\t\tObject asyncManagerAttr = servletRequest.getAttribute(WEB_ASYNC_MANAGER_ATTRIBUTE);\n\t\tif (asyncManagerAttr instanceof WebAsyncManager wam) {\n\t\t\tasyncManager = wam;\n\t\t}\n\t\tif (asyncManager == null) {\n\t\t\tasyncManager = new WebAsyncManager();\n\t\t\tservletRequest.setAttribute(WEB_ASYNC_MANAGER_ATTRIBUTE, asyncManager);\n\t\t}\n\t\treturn asyncManager;\n\t}"
  },
  "org.springframework.web.context.request.async.WebAsyncUtils#getAsyncManager(webRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain the {@link WebAsyncManager} for the current request, or if not\n\t * found, create and associate it with the request.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "WebAsyncManager",
    "signature": "public WebAsyncManager getAsyncManager(WebRequest webRequest)",
    "source_code": "\tpublic static WebAsyncManager getAsyncManager(WebRequest webRequest) {\n\t\tint scope = RequestAttributes.SCOPE_REQUEST;\n\t\tWebAsyncManager asyncManager = null;\n\t\tObject asyncManagerAttr = webRequest.getAttribute(WEB_ASYNC_MANAGER_ATTRIBUTE, scope);\n\t\tif (asyncManagerAttr instanceof WebAsyncManager wam) {\n\t\t\tasyncManager = wam;\n\t\t}\n\t\tif (asyncManager == null) {\n\t\t\tasyncManager = new WebAsyncManager();\n\t\t\twebRequest.setAttribute(WEB_ASYNC_MANAGER_ATTRIBUTE, asyncManager, scope);\n\t\t}\n\t\treturn asyncManager;\n\t}"
  },
  "org.springframework.web.multipart.support.DEFAULT_MULTIPART_RESOLVER_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The default name for the multipart resolver bean.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "signature": "public String DEFAULT_MULTIPART_RESOLVER_BEAN_NAME",
    "source_code": "\tpublic static final String DEFAULT_MULTIPART_RESOLVER_BEAN_NAME = \"filterMultipartResolver\";",
    "type": "String"
  },
  "org.springframework.web.multipart.support.MultipartFilter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Servlet Filter that resolves multipart requests via a {@link MultipartResolver}.\n * in the root web application context.\n *\n * <p>Looks up the MultipartResolver in Spring's root web application context.\n * Supports a \"multipartResolverBeanName\" filter init-param in {@code web.xml};\n * the default bean name is \"filterMultipartResolver\".\n *\n * <p>If no MultipartResolver bean is found, this filter falls back to a default\n * MultipartResolver: {@link StandardServletMultipartResolver} for Servlet\n * oontainers, based on a multipart-config section in {@code web.xml}.\n * Note however that at present the Servlet specification only defines how to\n * enable multipart configuration on a Servlet and as a result multipart request\n * processing is likely not possible in a Filter unless the Servlet container\n * provides a workaround such as Tomcat's \"allowCasualMultipartParsing\" property.\n *\n * <p>MultipartResolver lookup is customizable: Override this filter's\n * {@code lookupMultipartResolver} method to use a custom MultipartResolver\n * instance, for example if not using a Spring web application context.\n * Note that the lookup method should not create a new MultipartResolver instance\n * for each call but rather return a reference to a pre-built instance.\n *\n * <p>Note: This filter is an <b>alternative</b> to using DispatcherServlet's\n * MultipartResolver support, for example for web applications with custom web views\n * which do not use Spring's web MVC, or for custom filters applied before a Spring MVC\n * DispatcherServlet (e.g. {@link org.springframework.web.filter.HiddenHttpMethodFilter}).\n * In any case, this filter should not be combined with servlet-specific multipart resolution.\n *\n * @author Juergen Hoeller\n * @since 08.10.2003\n * @see #setMultipartResolverBeanName\n * @see #lookupMultipartResolver\n * @see org.springframework.web.multipart.MultipartResolver\n * @see org.springframework.web.servlet.DispatcherServlet\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "signature": "public class MultipartFilter",
    "source_code": "public class MultipartFilter extends OncePerRequestFilter {\n\n\t/**\n\t * The default name for the multipart resolver bean.\n\t */\n\tpublic static final String DEFAULT_MULTIPART_RESOLVER_BEAN_NAME = \"filterMultipartResolver\";\n\n\tprivate final MultipartResolver defaultMultipartResolver = new StandardServletMultipartResolver();\n\n\tprivate String multipartResolverBeanName = DEFAULT_MULTIPART_RESOLVER_BEAN_NAME;\n\n\n\t/**\n\t * Set the bean name of the MultipartResolver to fetch from Spring's\n\t * root application context. Default is \"filterMultipartResolver\".\n\t */\n\tpublic void setMultipartResolverBeanName(String multipartResolverBeanName) {\n\t\tthis.multipartResolverBeanName = multipartResolverBeanName;\n\t}\n\n\t/**\n\t * Return the bean name of the MultipartResolver to fetch from Spring's\n\t * root application context.\n\t */\n\tprotected String getMultipartResolverBeanName() {\n\t\treturn this.multipartResolverBeanName;\n\t}\n\n\n\t/**\n\t * Check for a multipart request via this filter's MultipartResolver,\n\t * and wrap the original request with a MultipartHttpServletRequest if appropriate.\n\t * <p>All later elements in the filter chain, most importantly servlets, benefit\n\t * from proper parameter extraction in the multipart case, and are able to cast to\n\t * MultipartHttpServletRequest if they need to.\n\t */\n\t@Override\n\tprotected void doFilterInternal(\n\t\t\tHttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n\t\t\tthrows ServletException, IOException {\n\n\t\tMultipartResolver multipartResolver = lookupMultipartResolver(request);\n\n\t\tHttpServletRequest processedRequest = request;\n\t\tif (multipartResolver.isMultipart(processedRequest)) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Resolving multipart request\");\n\t\t\t}\n\t\t\tprocessedRequest = multipartResolver.resolveMultipart(processedRequest);\n\t\t}\n\t\telse {\n\t\t\t// A regular request...\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Not a multipart request\");\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tfilterChain.doFilter(processedRequest, response);\n\t\t}\n\t\tfinally {\n\t\t\tif (processedRequest instanceof MultipartHttpServletRequest multipartRequest) {\n\t\t\t\tmultipartResolver.cleanupMultipart(multipartRequest);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Look up the MultipartResolver that this filter should use,\n\t * taking the current HTTP request as argument.\n\t * <p>The default implementation delegates to the {@code lookupMultipartResolver}\n\t * without arguments.\n\t * @return the MultipartResolver to use\n\t * @see #lookupMultipartResolver()\n\t */\n\tprotected MultipartResolver lookupMultipartResolver(HttpServletRequest request) {\n\t\treturn lookupMultipartResolver();\n\t}\n\n\t/**\n\t * Look for a MultipartResolver bean in the root web application context.\n\t * Supports a \"multipartResolverBeanName\" filter init param; the default\n\t * bean name is \"filterMultipartResolver\".\n\t * <p>This can be overridden to use a custom MultipartResolver instance,\n\t * for example if not using a Spring web application context.\n\t * @return the MultipartResolver instance\n\t */\n\tprotected MultipartResolver lookupMultipartResolver() {\n\t\tWebApplicationContext wac = WebApplicationContextUtils.getWebApplicationContext(getServletContext());\n\t\tString beanName = getMultipartResolverBeanName();\n\t\tif (wac != null && wac.containsBean(beanName)) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Using MultipartResolver '\" + beanName + \"' for MultipartFilter\");\n\t\t\t}\n\t\t\treturn wac.getBean(beanName, MultipartResolver.class);\n\t\t}\n\t\telse {\n\t\t\treturn this.defaultMultipartResolver;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.multipart.support.MultipartFilter#doFilterInternal(request,response,filterChain)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check for a multipart request via this filter's MultipartResolver,\n\t * and wrap the original request with a MultipartHttpServletRequest if appropriate.\n\t * <p>All later elements in the filter chain, most importantly servlets, benefit\n\t * from proper parameter extraction in the multipart case, and are able to cast to\n\t * MultipartHttpServletRequest if they need to.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "filterChain"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "void",
    "signature": "protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)",
    "source_code": "\tprotected void doFilterInternal("
  },
  "org.springframework.web.multipart.support.MultipartFilter#getMultipartResolverBeanName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the bean name of the MultipartResolver to fetch from Spring's\n\t * root application context.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "String",
    "signature": "protected String getMultipartResolverBeanName()",
    "source_code": "\tprotected String getMultipartResolverBeanName() {\n\t\treturn this.multipartResolverBeanName;\n\t}"
  },
  "org.springframework.web.multipart.support.MultipartFilter#lookupMultipartResolver()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Look for a MultipartResolver bean in the root web application context.\n\t * Supports a \"multipartResolverBeanName\" filter init param; the default\n\t * bean name is \"filterMultipartResolver\".\n\t * <p>This can be overridden to use a custom MultipartResolver instance,\n\t * for example if not using a Spring web application context.\n\t * @return the MultipartResolver instance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "MultipartResolver",
    "signature": "protected MultipartResolver lookupMultipartResolver()",
    "source_code": "\tprotected MultipartResolver lookupMultipartResolver() {\n\t\tWebApplicationContext wac = WebApplicationContextUtils.getWebApplicationContext(getServletContext());\n\t\tString beanName = getMultipartResolverBeanName();\n\t\tif (wac != null && wac.containsBean(beanName)) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Using MultipartResolver '\" + beanName + \"' for MultipartFilter\");\n\t\t\t}\n\t\t\treturn wac.getBean(beanName, MultipartResolver.class);\n\t\t}\n\t\telse {\n\t\t\treturn this.defaultMultipartResolver;\n\t\t}\n\t}"
  },
  "org.springframework.web.multipart.support.MultipartFilter#lookupMultipartResolver(request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Look up the MultipartResolver that this filter should use,\n\t * taking the current HTTP request as argument.\n\t * <p>The default implementation delegates to the {@code lookupMultipartResolver}\n\t * without arguments.\n\t * @return the MultipartResolver to use\n\t * @see #lookupMultipartResolver()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "MultipartResolver",
    "signature": "protected MultipartResolver lookupMultipartResolver(HttpServletRequest request)",
    "source_code": "\tprotected MultipartResolver lookupMultipartResolver(HttpServletRequest request) {\n\t\treturn lookupMultipartResolver();\n\t}"
  },
  "org.springframework.web.multipart.support.MultipartFilter#setMultipartResolverBeanName(multipartResolverBeanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the bean name of the MultipartResolver to fetch from Spring's\n\t * root application context. Default is \"filterMultipartResolver\".\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "multipartResolverBeanName"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void setMultipartResolverBeanName(String multipartResolverBeanName)",
    "source_code": "\tpublic void setMultipartResolverBeanName(String multipartResolverBeanName) {\n\t\tthis.multipartResolverBeanName = multipartResolverBeanName;\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#build()": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> build()",
    "source_code": "\tpublic Mono<ServerResponse> build() {\n\t\treturn build((exchange, handlerStrategies) -> exchange.getResponse().setComplete());\n\t}"
  },
  "org.springframework.web.servlet.DispatcherServlet": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Central dispatcher for HTTP request handlers/controllers, e.g. for web UI controllers\n * or HTTP-based remote service exporters. Dispatches to registered handlers for processing\n * a web request, providing convenient mapping and exception handling facilities.\n *\n * <p>This servlet is very flexible: It can be used with just about any workflow, with the\n * installation of the appropriate adapter classes. It offers the following functionality\n * that distinguishes it from other request-driven web MVC frameworks:\n *\n * <ul>\n * <li>It is based around a JavaBeans configuration mechanism.\n *\n * <li>It can use any {@link HandlerMapping} implementation - pre-built or provided as part\n * of an application - to control the routing of requests to handler objects. Default is\n * {@link org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping} and\n * {@link org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping}.\n * HandlerMapping objects can be defined as beans in the servlet's application context,\n * implementing the HandlerMapping interface, overriding the default HandlerMapping if\n * present. HandlerMappings can be given any bean name (they are tested by type).\n *\n * <li>It can use any {@link HandlerAdapter}; this allows for using any handler interface.\n * Default adapters are {@link org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter},\n * {@link org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter}, for Spring's\n * {@link org.springframework.web.HttpRequestHandler} and\n * {@link org.springframework.web.servlet.mvc.Controller} interfaces, respectively. A default\n * {@link org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter}\n * will be registered as well. HandlerAdapter objects can be added as beans in the\n * application context, overriding the default HandlerAdapters. Like HandlerMappings,\n * HandlerAdapters can be given any bean name (they are tested by type).\n *\n * <li>The dispatcher's exception resolution strategy can be specified via a\n * {@link HandlerExceptionResolver}, for example mapping certain exceptions to error pages.\n * Default are\n * {@link org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver},\n * {@link org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver}, and\n * {@link org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver}.\n * These HandlerExceptionResolvers can be overridden through the application context.\n * HandlerExceptionResolver can be given any bean name (they are tested by type).\n *\n * <li>Its view resolution strategy can be specified via a {@link ViewResolver}\n * implementation, resolving symbolic view names into View objects. Default is\n * {@link org.springframework.web.servlet.view.InternalResourceViewResolver}.\n * ViewResolver objects can be added as beans in the application context, overriding the\n * default ViewResolver. ViewResolvers can be given any bean name (they are tested by type).\n *\n * <li>If a {@link View} or view name is not supplied by the user, then the configured\n * {@link RequestToViewNameTranslator} will translate the current request into a view name.\n * The corresponding bean name is \"viewNameTranslator\"; the default is\n * {@link org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator}.\n *\n * <li>The dispatcher's strategy for resolving multipart requests is determined by a\n * {@link org.springframework.web.multipart.MultipartResolver} implementation.\n * An implementation for standard Servlet multipart processing is included.\n * The MultipartResolver bean name is \"multipartResolver\"; default is none.\n *\n * <li>Its locale resolution strategy is determined by a {@link LocaleResolver}.\n * Out-of-the-box implementations work via HTTP accept header, cookie, or session.\n * The LocaleResolver bean name is \"localeResolver\"; default is\n * {@link org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver}.\n *\n * <li>Its theme resolution strategy is determined by a {@link ThemeResolver}.\n * Implementations for a fixed theme and for cookie and session storage are included.\n * The ThemeResolver bean name is \"themeResolver\"; default is\n * {@link org.springframework.web.servlet.theme.FixedThemeResolver}.\n * Theme support is deprecated as of 6.0 with no direct replacement.\n * </ul>\n *\n * <p><b>NOTE: The {@code @RequestMapping} annotation will only be processed if a\n * corresponding {@code HandlerMapping} (for type-level annotations) and/or\n * {@code HandlerAdapter} (for method-level annotations) is present in the dispatcher.</b>\n * This is the case by default. However, if you are defining custom {@code HandlerMappings}\n * or {@code HandlerAdapters}, then you need to make sure that a corresponding custom\n * {@code RequestMappingHandlerMapping} and/or {@code RequestMappingHandlerAdapter}\n * is defined as well - provided that you intend to use {@code @RequestMapping}.\n *\n * <p><b>A web application can define any number of DispatcherServlets.</b>\n * Each servlet will operate in its own namespace, loading its own application context\n * with mappings, handlers, etc. Only the root application context as loaded by\n * {@link org.springframework.web.context.ContextLoaderListener}, if any, will be shared.\n *\n * <p>{@code DispatcherServlet} may be injected with a web application context,\n * rather than creating its own internally. This is useful in Servlet 3.0+\n * environments, which support programmatic registration of servlet instances.\n * See the {@link #DispatcherServlet(WebApplicationContext)} javadoc for details.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Chris Beams\n * @author Rossen Stoyanchev\n * @author Sebastien Deleuze\n * @see org.springframework.web.HttpRequestHandler\n * @see org.springframework.web.servlet.mvc.Controller\n * @see org.springframework.web.context.ContextLoaderListener\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "signature": "public class DispatcherServlet",
    "source_code": "public class DispatcherServlet extends FrameworkServlet {\n\n\t/** Well-known name for the MultipartResolver object in the bean factory for this namespace. */\n\tpublic static final String MULTIPART_RESOLVER_BEAN_NAME = \"multipartResolver\";\n\n\t/** Well-known name for the LocaleResolver object in the bean factory for this namespace. */\n\tpublic static final String LOCALE_RESOLVER_BEAN_NAME = \"localeResolver\";\n\n\t/**\n\t * Well-known name for the ThemeResolver object in the bean factory for this namespace.\n\t * @deprecated as of 6.0, with no direct replacement\n\t */\n\t@Deprecated\n\tpublic static final String THEME_RESOLVER_BEAN_NAME = \"themeResolver\";\n\n\t/**\n\t * Well-known name for the HandlerMapping object in the bean factory for this namespace.\n\t * Only used when \"detectAllHandlerMappings\" is turned off.\n\t * @see #setDetectAllHandlerMappings\n\t */\n\tpublic static final String HANDLER_MAPPING_BEAN_NAME = \"handlerMapping\";\n\n\t/**\n\t * Well-known name for the HandlerAdapter object in the bean factory for this namespace.\n\t * Only used when \"detectAllHandlerAdapters\" is turned off.\n\t * @see #setDetectAllHandlerAdapters\n\t */\n\tpublic static final String HANDLER_ADAPTER_BEAN_NAME = \"handlerAdapter\";\n\n\t/**\n\t * Well-known name for the HandlerExceptionResolver object in the bean factory for this namespace.\n\t * Only used when \"detectAllHandlerExceptionResolvers\" is turned off.\n\t * @see #setDetectAllHandlerExceptionResolvers\n\t */\n\tpublic static final String HANDLER_EXCEPTION_RESOLVER_BEAN_NAME = \"handlerExceptionResolver\";\n\n\t/**\n\t * Well-known name for the RequestToViewNameTranslator object in the bean factory for this namespace.\n\t */\n\tpublic static final String REQUEST_TO_VIEW_NAME_TRANSLATOR_BEAN_NAME = \"viewNameTranslator\";\n\n\t/**\n\t * Well-known name for the ViewResolver object in the bean factory for this namespace.\n\t * Only used when \"detectAllViewResolvers\" is turned off.\n\t * @see #setDetectAllViewResolvers\n\t */\n\tpublic static final String VIEW_RESOLVER_BEAN_NAME = \"viewResolver\";\n\n\t/**\n\t * Well-known name for the FlashMapManager object in the bean factory for this namespace.\n\t */\n\tpublic static final String FLASH_MAP_MANAGER_BEAN_NAME = \"flashMapManager\";\n\n\t/**\n\t * Request attribute to hold the current web application context.\n\t * Otherwise only the global web app context is obtainable by tags etc.\n\t * @see org.springframework.web.servlet.support.RequestContextUtils#findWebApplicationContext\n\t */\n\tpublic static final String WEB_APPLICATION_CONTEXT_ATTRIBUTE = DispatcherServlet.class.getName() + \".CONTEXT\";\n\n\t/**\n\t * Request attribute to hold the current LocaleResolver, retrievable by views.\n\t * @see org.springframework.web.servlet.support.RequestContextUtils#getLocaleResolver\n\t */\n\tpublic static final String LOCALE_RESOLVER_ATTRIBUTE = DispatcherServlet.class.getName() + \".LOCALE_RESOLVER\";\n\n\t/**\n\t * Request attribute to hold the current ThemeResolver, retrievable by views.\n\t * @see org.springframework.web.servlet.support.RequestContextUtils#getThemeResolver\n\t * @deprecated as of 6.0, with no direct replacement\n\t */\n\t@Deprecated\n\tpublic static final String THEME_RESOLVER_ATTRIBUTE = DispatcherServlet.class.getName() + \".THEME_RESOLVER\";\n\n\t/**\n\t * Request attribute to hold the current ThemeSource, retrievable by views.\n\t * @see org.springframework.web.servlet.support.RequestContextUtils#getThemeSource\n\t * @deprecated as of 6.0, with no direct replacement\n\t */\n\t@Deprecated\n\tpublic static final String THEME_SOURCE_ATTRIBUTE = DispatcherServlet.class.getName() + \".THEME_SOURCE\";\n\n\t/**\n\t * Name of request attribute that holds a read-only {@code Map<String,?>}\n\t * with \"input\" flash attributes saved by a previous request, if any.\n\t * @see org.springframework.web.servlet.support.RequestContextUtils#getInputFlashMap(HttpServletRequest)\n\t */\n\tpublic static final String INPUT_FLASH_MAP_ATTRIBUTE = DispatcherServlet.class.getName() + \".INPUT_FLASH_MAP\";\n\n\t/**\n\t * Name of request attribute that holds the \"output\" {@link FlashMap} with\n\t * attributes to save for a subsequent request.\n\t * @see org.springframework.web.servlet.support.RequestContextUtils#getOutputFlashMap(HttpServletRequest)\n\t */\n\tpublic static final String OUTPUT_FLASH_MAP_ATTRIBUTE = DispatcherServlet.class.getName() + \".OUTPUT_FLASH_MAP\";\n\n\t/**\n\t * Name of request attribute that holds the {@link FlashMapManager}.\n\t * @see org.springframework.web.servlet.support.RequestContextUtils#getFlashMapManager(HttpServletRequest)\n\t */\n\tpublic static final String FLASH_MAP_MANAGER_ATTRIBUTE = DispatcherServlet.class.getName() + \".FLASH_MAP_MANAGER\";\n\n\t/**\n\t * Name of request attribute that exposes an Exception resolved with a\n\t * {@link HandlerExceptionResolver} but where no view was rendered\n\t * (e.g. setting the status code).\n\t */\n\tpublic static final String EXCEPTION_ATTRIBUTE = DispatcherServlet.class.getName() + \".EXCEPTION\";\n\n\t/** Log category to use when no mapped handler is found for a request. */\n\tpublic static final String PAGE_NOT_FOUND_LOG_CATEGORY = \"org.springframework.web.servlet.PageNotFound\";\n\n\t/**\n\t * Name of the class path resource (relative to the DispatcherServlet class)\n\t * that defines DispatcherServlet's default strategy names.\n\t */\n\tprivate static final String DEFAULT_STRATEGIES_PATH = \"DispatcherServlet.properties\";\n\n\t/**\n\t * Common prefix that DispatcherServlet's default strategy attributes start with.\n\t */\n\tprivate static final String DEFAULT_STRATEGIES_PREFIX = \"org.springframework.web.servlet\";\n\n\n\t/** Additional logger to use when no mapped handler is found for a request. */\n\tprotected static final Log pageNotFoundLogger = LogFactory.getLog(PAGE_NOT_FOUND_LOG_CATEGORY);\n\n\t/** Store default strategy implementations. */\n\t@Nullable\n\tprivate static Properties defaultStrategies;\n\n\t/** Detect all HandlerMappings or just expect \"handlerMapping\" bean?. */\n\tprivate boolean detectAllHandlerMappings = true;\n\n\t/** Detect all HandlerAdapters or just expect \"handlerAdapter\" bean?. */\n\tprivate boolean detectAllHandlerAdapters = true;\n\n\t/** Detect all HandlerExceptionResolvers or just expect \"handlerExceptionResolver\" bean?. */\n\tprivate boolean detectAllHandlerExceptionResolvers = true;\n\n\t/** Detect all ViewResolvers or just expect \"viewResolver\" bean?. */\n\tprivate boolean detectAllViewResolvers = true;\n\n\t/** Throw a NoHandlerFoundException if no Handler was found to process this request? *.*/\n\tprivate boolean throwExceptionIfNoHandlerFound = false;\n\n\t/** Perform cleanup of request attributes after include request?. */\n\tprivate boolean cleanupAfterInclude = true;\n\n\t/** MultipartResolver used by this servlet. */\n\t@Nullable\n\tprivate MultipartResolver multipartResolver;\n\n\t/** LocaleResolver used by this servlet. */\n\t@Nullable\n\tprivate LocaleResolver localeResolver;\n\n\t/** ThemeResolver used by this servlet. */\n\t@Deprecated\n\t@Nullable\n\tprivate ThemeResolver themeResolver;\n\n\t/** List of HandlerMappings used by this servlet. */\n\t@Nullable\n\tprivate List<HandlerMapping> handlerMappings;\n\n\t/** List of HandlerAdapters used by this servlet. */\n\t@Nullable\n\tprivate List<HandlerAdapter> handlerAdapters;\n\n\t/** List of HandlerExceptionResolvers used by this servlet. */\n\t@Nullable\n\tprivate List<HandlerExceptionResolver> handlerExceptionResolvers;\n\n\t/** RequestToViewNameTranslator used by this servlet. */\n\t@Nullable\n\tprivate RequestToViewNameTranslator viewNameTranslator;\n\n\t/** FlashMapManager used by this servlet. */\n\t@Nullable\n\tprivate FlashMapManager flashMapManager;\n\n\t/** List of ViewResolvers used by this servlet. */\n\t@Nullable\n\tprivate List<ViewResolver> viewResolvers;\n\n\tprivate boolean parseRequestPath;\n\n\n\t/**\n\t * Create a new {@code DispatcherServlet} that will create its own internal web\n\t * application context based on defaults and values provided through servlet\n\t * init-params. Typically used in Servlet 2.5 or earlier environments, where the only\n\t * option for servlet registration is through {@code web.xml} which requires the use\n\t * of a no-arg constructor.\n\t * <p>Calling {@link #setContextConfigLocation} (init-param 'contextConfigLocation')\n\t * will dictate which XML files will be loaded by the\n\t * {@linkplain #DEFAULT_CONTEXT_CLASS default XmlWebApplicationContext}\n\t * <p>Calling {@link #setContextClass} (init-param 'contextClass') overrides the\n\t * default {@code XmlWebApplicationContext} and allows for specifying an alternative class,\n\t * such as {@code AnnotationConfigWebApplicationContext}.\n\t * <p>Calling {@link #setContextInitializerClasses} (init-param 'contextInitializerClasses')\n\t * indicates which {@code ApplicationContextInitializer} classes should be used to\n\t * further configure the internal application context prior to refresh().\n\t * @see #DispatcherServlet(WebApplicationContext)\n\t */\n\tpublic DispatcherServlet() {\n\t\tsuper();\n\t\tsetDispatchOptionsRequest(true);\n\t}\n\n\t/**\n\t * Create a new {@code DispatcherServlet} with the given web application context. This\n\t * constructor is useful in Servlet environments where instance-based registration\n\t * of servlets is possible through the {@link ServletContext#addServlet} API.\n\t * <p>Using this constructor indicates that the following properties / init-params\n\t * will be ignored:\n\t * <ul>\n\t * <li>{@link #setContextClass(Class)} / 'contextClass'</li>\n\t * <li>{@link #setContextConfigLocation(String)} / 'contextConfigLocation'</li>\n\t * <li>{@link #setContextAttribute(String)} / 'contextAttribute'</li>\n\t * <li>{@link #setNamespace(String)} / 'namespace'</li>\n\t * </ul>\n\t * <p>The given web application context may or may not yet be {@linkplain\n\t * ConfigurableApplicationContext#refresh() refreshed}. If it has <strong>not</strong>\n\t * already been refreshed (the recommended approach), then the following will occur:\n\t * <ul>\n\t * <li>If the given context does not already have a {@linkplain\n\t * ConfigurableApplicationContext#setParent parent}, the root application context\n\t * will be set as the parent.</li>\n\t * <li>If the given context has not already been assigned an {@linkplain\n\t * ConfigurableApplicationContext#setId id}, one will be assigned to it</li>\n\t * <li>{@code ServletContext} and {@code ServletConfig} objects will be delegated to\n\t * the application context</li>\n\t * <li>{@link #postProcessWebApplicationContext} will be called</li>\n\t * <li>Any {@code ApplicationContextInitializer}s specified through the\n\t * \"contextInitializerClasses\" init-param or through the {@link\n\t * #setContextInitializers} property will be applied.</li>\n\t * <li>{@link ConfigurableApplicationContext#refresh refresh()} will be called if the\n\t * context implements {@link ConfigurableApplicationContext}</li>\n\t * </ul>\n\t * If the context has already been refreshed, none of the above will occur, under the\n\t * assumption that the user has performed these actions (or not) per their specific\n\t * needs.\n\t * <p>See {@link org.springframework.web.WebApplicationInitializer} for usage examples.\n\t * @param webApplicationContext the context to use\n\t * @see #initWebApplicationContext\n\t * @see #configureAndRefreshWebApplicationContext\n\t * @see org.springframework.web.WebApplicationInitializer\n\t */\n\tpublic DispatcherServlet(WebApplicationContext webApplicationContext) {\n\t\tsuper(webApplicationContext);\n\t\tsetDispatchOptionsRequest(true);\n\t}\n\n\n\t/**\n\t * Set whether to detect all HandlerMapping beans in this servlet's context. Otherwise,\n\t * just a single bean with name \"handlerMapping\" will be expected.\n\t * <p>Default is \"true\". Turn this off if you want this servlet to use a single\n\t * HandlerMapping, despite multiple HandlerMapping beans being defined in the context.\n\t */\n\tpublic void setDetectAllHandlerMappings(boolean detectAllHandlerMappings) {\n\t\tthis.detectAllHandlerMappings = detectAllHandlerMappings;\n\t}\n\n\t/**\n\t * Set whether to detect all HandlerAdapter beans in this servlet's context. Otherwise,\n\t * just a single bean with name \"handlerAdapter\" will be expected.\n\t * <p>Default is \"true\". Turn this off if you want this servlet to use a single\n\t * HandlerAdapter, despite multiple HandlerAdapter beans being defined in the context.\n\t */\n\tpublic void setDetectAllHandlerAdapters(boolean detectAllHandlerAdapters) {\n\t\tthis.detectAllHandlerAdapters = detectAllHandlerAdapters;\n\t}\n\n\t/**\n\t * Set whether to detect all HandlerExceptionResolver beans in this servlet's context. Otherwise,\n\t * just a single bean with name \"handlerExceptionResolver\" will be expected.\n\t * <p>Default is \"true\". Turn this off if you want this servlet to use a single\n\t * HandlerExceptionResolver, despite multiple HandlerExceptionResolver beans being defined in the context.\n\t */\n\tpublic void setDetectAllHandlerExceptionResolvers(boolean detectAllHandlerExceptionResolvers) {\n\t\tthis.detectAllHandlerExceptionResolvers = detectAllHandlerExceptionResolvers;\n\t}\n\n\t/**\n\t * Set whether to detect all ViewResolver beans in this servlet's context. Otherwise,\n\t * just a single bean with name \"viewResolver\" will be expected.\n\t * <p>Default is \"true\". Turn this off if you want this servlet to use a single\n\t * ViewResolver, despite multiple ViewResolver beans being defined in the context.\n\t */\n\tpublic void setDetectAllViewResolvers(boolean detectAllViewResolvers) {\n\t\tthis.detectAllViewResolvers = detectAllViewResolvers;\n\t}\n\n\t/**\n\t * Set whether to throw a NoHandlerFoundException when no Handler was found for this request.\n\t * This exception can then be caught with a HandlerExceptionResolver or an\n\t * {@code @ExceptionHandler} controller method.\n\t * <p>Note that if {@link org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler}\n\t * is used, then requests will always be forwarded to the default servlet and a\n\t * NoHandlerFoundException would never be thrown in that case.\n\t * <p>Default is \"false\", meaning the DispatcherServlet sends a NOT_FOUND error through the\n\t * Servlet response.\n\t * @since 4.0\n\t */\n\tpublic void setThrowExceptionIfNoHandlerFound(boolean throwExceptionIfNoHandlerFound) {\n\t\tthis.throwExceptionIfNoHandlerFound = throwExceptionIfNoHandlerFound;\n\t}\n\n\t/**\n\t * Set whether to perform cleanup of request attributes after an include request, that is,\n\t * whether to reset the original state of all request attributes after the DispatcherServlet\n\t * has processed within an include request. Otherwise, just the DispatcherServlet's own\n\t * request attributes will be reset, but not model attributes for JSPs or special attributes\n\t * set by views (for example, JSTL's).\n\t * <p>Default is \"true\", which is strongly recommended. Views should not rely on request attributes\n\t * having been set by (dynamic) includes. This allows JSP views rendered by an included controller\n\t * to use any model attributes, even with the same names as in the main JSP, without causing side\n\t * effects. Only turn this off for special needs, for example to deliberately allow main JSPs to\n\t * access attributes from JSP views rendered by an included controller.\n\t */\n\tpublic void setCleanupAfterInclude(boolean cleanupAfterInclude) {\n\t\tthis.cleanupAfterInclude = cleanupAfterInclude;\n\t}\n\n\n\t/**\n\t * This implementation calls {@link #initStrategies}.\n\t */\n\t@Override\n\tprotected void onRefresh(ApplicationContext context) {\n\t\tinitStrategies(context);\n\t}\n\n\t/**\n\t * Initialize the strategy objects that this servlet uses.\n\t * <p>May be overridden in subclasses in order to initialize further strategy objects.\n\t */\n\tprotected void initStrategies(ApplicationContext context) {\n\t\tinitMultipartResolver(context);\n\t\tinitLocaleResolver(context);\n\t\tinitThemeResolver(context);\n\t\tinitHandlerMappings(context);\n\t\tinitHandlerAdapters(context);\n\t\tinitHandlerExceptionResolvers(context);\n\t\tinitRequestToViewNameTranslator(context);\n\t\tinitViewResolvers(context);\n\t\tinitFlashMapManager(context);\n\t}\n\n\t/**\n\t * Initialize the MultipartResolver used by this class.\n\t * <p>If no bean is defined with the given name in the BeanFactory for this namespace,\n\t * no multipart handling is provided.\n\t */\n\tprivate void initMultipartResolver(ApplicationContext context) {\n\t\ttry {\n\t\t\tthis.multipartResolver = context.getBean(MULTIPART_RESOLVER_BEAN_NAME, MultipartResolver.class);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Detected \" + this.multipartResolver);\n\t\t\t}\n\t\t\telse if (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Detected \" + this.multipartResolver.getClass().getSimpleName());\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Default is no multipart resolver.\n\t\t\tthis.multipartResolver = null;\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"No MultipartResolver '\" + MULTIPART_RESOLVER_BEAN_NAME + \"' declared\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Initialize the LocaleResolver used by this class.\n\t * <p>If no bean is defined with the given name in the BeanFactory for this namespace,\n\t * we default to AcceptHeaderLocaleResolver.\n\t */\n\tprivate void initLocaleResolver(ApplicationContext context) {\n\t\ttry {\n\t\t\tthis.localeResolver = context.getBean(LOCALE_RESOLVER_BEAN_NAME, LocaleResolver.class);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Detected \" + this.localeResolver);\n\t\t\t}\n\t\t\telse if (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Detected \" + this.localeResolver.getClass().getSimpleName());\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// We need to use the default.\n\t\t\tthis.localeResolver = getDefaultStrategy(context, LocaleResolver.class);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"No LocaleResolver '\" + LOCALE_RESOLVER_BEAN_NAME +\n\t\t\t\t\t\t\"': using default [\" + this.localeResolver.getClass().getSimpleName() + \"]\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Initialize the ThemeResolver used by this class.\n\t * <p>If no bean is defined with the given name in the BeanFactory for this namespace,\n\t * we default to a FixedThemeResolver.\n\t */\n\t@Deprecated\n\tprivate void initThemeResolver(ApplicationContext context) {\n\t\ttry {\n\t\t\tthis.themeResolver = context.getBean(THEME_RESOLVER_BEAN_NAME, ThemeResolver.class);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Detected \" + this.themeResolver);\n\t\t\t}\n\t\t\telse if (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Detected \" + this.themeResolver.getClass().getSimpleName());\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// We need to use the default.\n\t\t\tthis.themeResolver = getDefaultStrategy(context, ThemeResolver.class);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"No ThemeResolver '\" + THEME_RESOLVER_BEAN_NAME +\n\t\t\t\t\t\t\"': using default [\" + this.themeResolver.getClass().getSimpleName() + \"]\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Initialize the HandlerMappings used by this class.\n\t * <p>If no HandlerMapping beans are defined in the BeanFactory for this namespace,\n\t * we default to BeanNameUrlHandlerMapping.\n\t */\n\tprivate void initHandlerMappings(ApplicationContext context) {\n\t\tthis.handlerMappings = null;\n\n\t\tif (this.detectAllHandlerMappings) {\n\t\t\t// Find all HandlerMappings in the ApplicationContext, including ancestor contexts.\n\t\t\tMap<String, HandlerMapping> matchingBeans =\n\t\t\t\t\tBeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false);\n\t\t\tif (!matchingBeans.isEmpty()) {\n\t\t\t\tthis.handlerMappings = new ArrayList<>(matchingBeans.values());\n\t\t\t\t// We keep HandlerMappings in sorted order.\n\t\t\t\tAnnotationAwareOrderComparator.sort(this.handlerMappings);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tHandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);\n\t\t\t\tthis.handlerMappings = Collections.singletonList(hm);\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t// Ignore, we'll add a default HandlerMapping later.\n\t\t\t}\n\t\t}\n\n\t\t// Ensure we have at least one HandlerMapping, by registering\n\t\t// a default HandlerMapping if no other mappings are found.\n\t\tif (this.handlerMappings == null) {\n\t\t\tthis.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"No HandlerMappings declared for servlet '\" + getServletName() +\n\t\t\t\t\t\t\"': using default strategies from DispatcherServlet.properties\");\n\t\t\t}\n\t\t}\n\n\t\tfor (HandlerMapping mapping : this.handlerMappings) {\n\t\t\tif (mapping.usesPathPatterns()) {\n\t\t\t\tthis.parseRequestPath = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Initialize the HandlerAdapters used by this class.\n\t * <p>If no HandlerAdapter beans are defined in the BeanFactory for this namespace,\n\t * we default to SimpleControllerHandlerAdapter.\n\t */\n\tprivate void initHandlerAdapters(ApplicationContext context) {\n\t\tthis.handlerAdapters = null;\n\n\t\tif (this.detectAllHandlerAdapters) {\n\t\t\t// Find all HandlerAdapters in the ApplicationContext, including ancestor contexts.\n\t\t\tMap<String, HandlerAdapter> matchingBeans =\n\t\t\t\t\tBeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, true, false);\n\t\t\tif (!matchingBeans.isEmpty()) {\n\t\t\t\tthis.handlerAdapters = new ArrayList<>(matchingBeans.values());\n\t\t\t\t// We keep HandlerAdapters in sorted order.\n\t\t\t\tAnnotationAwareOrderComparator.sort(this.handlerAdapters);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tHandlerAdapter ha = context.getBean(HANDLER_ADAPTER_BEAN_NAME, HandlerAdapter.class);\n\t\t\t\tthis.handlerAdapters = Collections.singletonList(ha);\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t// Ignore, we'll add a default HandlerAdapter later.\n\t\t\t}\n\t\t}\n\n\t\t// Ensure we have at least some HandlerAdapters, by registering\n\t\t// default HandlerAdapters if no other adapters are found.\n\t\tif (this.handlerAdapters == null) {\n\t\t\tthis.handlerAdapters = getDefaultStrategies(context, HandlerAdapter.class);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"No HandlerAdapters declared for servlet '\" + getServletName() +\n\t\t\t\t\t\t\"': using default strategies from DispatcherServlet.properties\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Initialize the HandlerExceptionResolver used by this class.\n\t * <p>If no bean is defined with the given name in the BeanFactory for this namespace,\n\t * we default to no exception resolver.\n\t */\n\tprivate void initHandlerExceptionResolvers(ApplicationContext context) {\n\t\tthis.handlerExceptionResolvers = null;\n\n\t\tif (this.detectAllHandlerExceptionResolvers) {\n\t\t\t// Find all HandlerExceptionResolvers in the ApplicationContext, including ancestor contexts.\n\t\t\tMap<String, HandlerExceptionResolver> matchingBeans = BeanFactoryUtils\n\t\t\t\t\t.beansOfTypeIncludingAncestors(context, HandlerExceptionResolver.class, true, false);\n\t\t\tif (!matchingBeans.isEmpty()) {\n\t\t\t\tthis.handlerExceptionResolvers = new ArrayList<>(matchingBeans.values());\n\t\t\t\t// We keep HandlerExceptionResolvers in sorted order.\n\t\t\t\tAnnotationAwareOrderComparator.sort(this.handlerExceptionResolvers);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tHandlerExceptionResolver her =\n\t\t\t\t\t\tcontext.getBean(HANDLER_EXCEPTION_RESOLVER_BEAN_NAME, HandlerExceptionResolver.class);\n\t\t\t\tthis.handlerExceptionResolvers = Collections.singletonList(her);\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t// Ignore, no HandlerExceptionResolver is fine too.\n\t\t\t}\n\t\t}\n\n\t\t// Ensure we have at least some HandlerExceptionResolvers, by registering\n\t\t// default HandlerExceptionResolvers if no other resolvers are found.\n\t\tif (this.handlerExceptionResolvers == null) {\n\t\t\tthis.handlerExceptionResolvers = getDefaultStrategies(context, HandlerExceptionResolver.class);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"No HandlerExceptionResolvers declared in servlet '\" + getServletName() +\n\t\t\t\t\t\t\"': using default strategies from DispatcherServlet.properties\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Initialize the RequestToViewNameTranslator used by this servlet instance.\n\t * <p>If no implementation is configured then we default to DefaultRequestToViewNameTranslator.\n\t */\n\tprivate void initRequestToViewNameTranslator(ApplicationContext context) {\n\t\ttry {\n\t\t\tthis.viewNameTranslator =\n\t\t\t\t\tcontext.getBean(REQUEST_TO_VIEW_NAME_TRANSLATOR_BEAN_NAME, RequestToViewNameTranslator.class);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Detected \" + this.viewNameTranslator.getClass().getSimpleName());\n\t\t\t}\n\t\t\telse if (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Detected \" + this.viewNameTranslator);\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// We need to use the default.\n\t\t\tthis.viewNameTranslator = getDefaultStrategy(context, RequestToViewNameTranslator.class);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"No RequestToViewNameTranslator '\" + REQUEST_TO_VIEW_NAME_TRANSLATOR_BEAN_NAME +\n\t\t\t\t\t\t\"': using default [\" + this.viewNameTranslator.getClass().getSimpleName() + \"]\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Initialize the ViewResolvers used by this class.\n\t * <p>If no ViewResolver beans are defined in the BeanFactory for this\n\t * namespace, we default to InternalResourceViewResolver.\n\t */\n\tprivate void initViewResolvers(ApplicationContext context) {\n\t\tthis.viewResolvers = null;\n\n\t\tif (this.detectAllViewResolvers) {\n\t\t\t// Find all ViewResolvers in the ApplicationContext, including ancestor contexts.\n\t\t\tMap<String, ViewResolver> matchingBeans =\n\t\t\t\t\tBeanFactoryUtils.beansOfTypeIncludingAncestors(context, ViewResolver.class, true, false);\n\t\t\tif (!matchingBeans.isEmpty()) {\n\t\t\t\tthis.viewResolvers = new ArrayList<>(matchingBeans.values());\n\t\t\t\t// We keep ViewResolvers in sorted order.\n\t\t\t\tAnnotationAwareOrderComparator.sort(this.viewResolvers);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tViewResolver vr = context.getBean(VIEW_RESOLVER_BEAN_NAME, ViewResolver.class);\n\t\t\t\tthis.viewResolvers = Collections.singletonList(vr);\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t// Ignore, we'll add a default ViewResolver later.\n\t\t\t}\n\t\t}\n\n\t\t// Ensure we have at least one ViewResolver, by registering\n\t\t// a default ViewResolver if no other resolvers are found.\n\t\tif (this.viewResolvers == null) {\n\t\t\tthis.viewResolvers = getDefaultStrategies(context, ViewResolver.class);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"No ViewResolvers declared for servlet '\" + getServletName() +\n\t\t\t\t\t\t\"': using default strategies from DispatcherServlet.properties\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Initialize the {@link FlashMapManager} used by this servlet instance.\n\t * <p>If no implementation is configured then we default to\n\t * {@code org.springframework.web.servlet.support.DefaultFlashMapManager}.\n\t */\n\tprivate void initFlashMapManager(ApplicationContext context) {\n\t\ttry {\n\t\t\tthis.flashMapManager = context.getBean(FLASH_MAP_MANAGER_BEAN_NAME, FlashMapManager.class);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Detected \" + this.flashMapManager.getClass().getSimpleName());\n\t\t\t}\n\t\t\telse if (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Detected \" + this.flashMapManager);\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// We need to use the default.\n\t\t\tthis.flashMapManager = getDefaultStrategy(context, FlashMapManager.class);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"No FlashMapManager '\" + FLASH_MAP_MANAGER_BEAN_NAME +\n\t\t\t\t\t\t\"': using default [\" + this.flashMapManager.getClass().getSimpleName() + \"]\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Return this servlet's ThemeSource, if any; else return {@code null}.\n\t * <p>Default is to return the WebApplicationContext as ThemeSource,\n\t * provided that it implements the ThemeSource interface.\n\t * @return the ThemeSource, if any\n\t * @see #getWebApplicationContext()\n\t */\n\t@Deprecated\n\t@Nullable\n\tpublic final org.springframework.ui.context.ThemeSource getThemeSource() {\n\t\treturn (getWebApplicationContext() instanceof org.springframework.ui.context.ThemeSource themeSource ?\n\t\t\t\tthemeSource : null);\n\t}\n\n\t/**\n\t * Obtain this servlet's MultipartResolver, if any.\n\t * @return the MultipartResolver used by this servlet, or {@code null} if none\n\t * (indicating that no multipart support is available)\n\t */\n\t@Nullable\n\tpublic final MultipartResolver getMultipartResolver() {\n\t\treturn this.multipartResolver;\n\t}\n\n\t/**\n\t * Return the configured {@link HandlerMapping} beans that were detected by\n\t * type in the {@link WebApplicationContext} or initialized based on the\n\t * default set of strategies from {@literal DispatcherServlet.properties}.\n\t * <p><strong>Note:</strong> This method may return {@code null} if invoked\n\t * prior to {@link #onRefresh(ApplicationContext)}.\n\t * @return an immutable list with the configured mappings, or {@code null}\n\t * if not initialized yet\n\t * @since 5.0\n\t */\n\t@Nullable\n\tpublic final List<HandlerMapping> getHandlerMappings() {\n\t\treturn (this.handlerMappings != null ? Collections.unmodifiableList(this.handlerMappings) : null);\n\t}\n\n\t/**\n\t * Return the default strategy object for the given strategy interface.\n\t * <p>The default implementation delegates to {@link #getDefaultStrategies},\n\t * expecting a single object in the list.\n\t * @param context the current WebApplicationContext\n\t * @param strategyInterface the strategy interface\n\t * @return the corresponding strategy object\n\t * @see #getDefaultStrategies\n\t */\n\tprotected <T> T getDefaultStrategy(ApplicationContext context, Class<T> strategyInterface) {\n\t\tList<T> strategies = getDefaultStrategies(context, strategyInterface);\n\t\tif (strategies.size() != 1) {\n\t\t\tthrow new BeanInitializationException(\n\t\t\t\t\t\"DispatcherServlet needs exactly 1 strategy for interface [\" + strategyInterface.getName() + \"]\");\n\t\t}\n\t\treturn strategies.get(0);\n\t}\n\n\t/**\n\t * Create a List of default strategy objects for the given strategy interface.\n\t * <p>The default implementation uses the \"DispatcherServlet.properties\" file (in the same\n\t * package as the DispatcherServlet class) to determine the class names. It instantiates\n\t * the strategy objects through the context's BeanFactory.\n\t * @param context the current WebApplicationContext\n\t * @param strategyInterface the strategy interface\n\t * @return the List of corresponding strategy objects\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprotected <T> List<T> getDefaultStrategies(ApplicationContext context, Class<T> strategyInterface) {\n\t\tif (defaultStrategies == null) {\n\t\t\ttry {\n\t\t\t\t// Load default strategy implementations from properties file.\n\t\t\t\t// This is currently strictly internal and not meant to be customized\n\t\t\t\t// by application developers.\n\t\t\t\tClassPathResource resource = new ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.class);\n\t\t\t\tdefaultStrategies = PropertiesLoaderUtils.loadProperties(resource);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new IllegalStateException(\"Could not load '\" + DEFAULT_STRATEGIES_PATH + \"': \" + ex.getMessage());\n\t\t\t}\n\t\t}\n\n\t\tString key = strategyInterface.getName();\n\t\tString value = defaultStrategies.getProperty(key);\n\t\tif (value != null) {\n\t\t\tString[] classNames = StringUtils.commaDelimitedListToStringArray(value);\n\t\t\tList<T> strategies = new ArrayList<>(classNames.length);\n\t\t\tfor (String className : classNames) {\n\t\t\t\ttry {\n\t\t\t\t\tClass<?> clazz = ClassUtils.forName(className, DispatcherServlet.class.getClassLoader());\n\t\t\t\t\tObject strategy = createDefaultStrategy(context, clazz);\n\t\t\t\t\tstrategies.add((T) strategy);\n\t\t\t\t}\n\t\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\t\tthrow new BeanInitializationException(\n\t\t\t\t\t\t\t\"Could not find DispatcherServlet's default strategy class [\" + className +\n\t\t\t\t\t\t\t\"] for interface [\" + key + \"]\", ex);\n\t\t\t\t}\n\t\t\t\tcatch (LinkageError err) {\n\t\t\t\t\tthrow new BeanInitializationException(\n\t\t\t\t\t\t\t\"Unresolvable class definition for DispatcherServlet's default strategy class [\" +\n\t\t\t\t\t\t\tclassName + \"] for interface [\" + key + \"]\", err);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn strategies;\n\t\t}\n\t\telse {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t}\n\n\t/**\n\t * Create a default strategy.\n\t * <p>The default implementation uses\n\t * {@link org.springframework.beans.factory.config.AutowireCapableBeanFactory#createBean}.\n\t * @param context the current WebApplicationContext\n\t * @param clazz the strategy implementation class to instantiate\n\t * @return the fully configured strategy instance\n\t * @see org.springframework.context.ApplicationContext#getAutowireCapableBeanFactory()\n\t * @see org.springframework.beans.factory.config.AutowireCapableBeanFactory#createBean\n\t */\n\tprotected Object createDefaultStrategy(ApplicationContext context, Class<?> clazz) {\n\t\treturn context.getAutowireCapableBeanFactory().createBean(clazz);\n\t}\n\n\n\t/**\n\t * Exposes the DispatcherServlet-specific request attributes and delegates to {@link #doDispatch}\n\t * for the actual dispatching.\n\t */\n\t@Override\n\tprotected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t\tlogRequest(request);\n\n\t\t// Keep a snapshot of the request attributes in case of an include,\n\t\t// to be able to restore the original attributes after the include.\n\t\tMap<String, Object> attributesSnapshot = null;\n\t\tif (WebUtils.isIncludeRequest(request)) {\n\t\t\tattributesSnapshot = new HashMap<>();\n\t\t\tEnumeration<?> attrNames = request.getAttributeNames();\n\t\t\twhile (attrNames.hasMoreElements()) {\n\t\t\t\tString attrName = (String) attrNames.nextElement();\n\t\t\t\tif (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) {\n\t\t\t\t\tattributesSnapshot.put(attrName, request.getAttribute(attrName));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Make framework objects available to handlers and view objects.\n\t\trequest.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());\n\t\trequest.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);\n\t\trequest.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);\n\t\trequest.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());\n\n\t\tif (this.flashMapManager != null) {\n\t\t\tFlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);\n\t\t\tif (inputFlashMap != null) {\n\t\t\t\trequest.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));\n\t\t\t}\n\t\t\trequest.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());\n\t\t\trequest.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);\n\t\t}\n\n\t\tRequestPath previousRequestPath = null;\n\t\tif (this.parseRequestPath) {\n\t\t\tpreviousRequestPath = (RequestPath) request.getAttribute(ServletRequestPathUtils.PATH_ATTRIBUTE);\n\t\t\tServletRequestPathUtils.parseAndCache(request);\n\t\t}\n\n\t\ttry {\n\t\t\tdoDispatch(request, response);\n\t\t}\n\t\tfinally {\n\t\t\tif (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {\n\t\t\t\t// Restore the original attribute snapshot, in case of an include.\n\t\t\t\tif (attributesSnapshot != null) {\n\t\t\t\t\trestoreAttributesAfterInclude(request, attributesSnapshot);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.parseRequestPath) {\n\t\t\t\tServletRequestPathUtils.setParsedRequestPath(previousRequestPath, request);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void logRequest(HttpServletRequest request) {\n\t\tLogFormatUtils.traceDebug(logger, traceOn -> {\n\t\t\tString params;\n\t\t\tString contentType = request.getContentType();\n\t\t\tif (StringUtils.startsWithIgnoreCase(contentType, \"multipart/\")) {\n\t\t\t\tparams = \"multipart\";\n\t\t\t}\n\t\t\telse if (isEnableLoggingRequestDetails()) {\n\t\t\t\tparams = request.getParameterMap().entrySet().stream()\n\t\t\t\t\t\t.map(entry -> entry.getKey() + \":\" + Arrays.toString(entry.getValue()))\n\t\t\t\t\t\t.collect(Collectors.joining(\", \"));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Avoid request body parsing for form data\n\t\t\t\tparams = (StringUtils.startsWithIgnoreCase(contentType, MediaType.APPLICATION_FORM_URLENCODED_VALUE) ||\n\t\t\t\t\t\t!request.getParameterMap().isEmpty() ? \"masked\" : \"\");\n\t\t\t}\n\n\t\t\tString queryString = request.getQueryString();\n\t\t\tString queryClause = (StringUtils.hasLength(queryString) ? \"?\" + queryString : \"\");\n\t\t\tString dispatchType = (!DispatcherType.REQUEST.equals(request.getDispatcherType()) ?\n\t\t\t\t\t\"\\\"\" + request.getDispatcherType() + \"\\\" dispatch for \" : \"\");\n\t\t\tString message = (dispatchType + request.getMethod() + \" \\\"\" + getRequestUri(request) +\n\t\t\t\t\tqueryClause + \"\\\", parameters={\" + params + \"}\");\n\n\t\t\tif (traceOn) {\n\t\t\t\tList<String> values = Collections.list(request.getHeaderNames());\n\t\t\t\tString headers = values.size() > 0 ? \"masked\" : \"\";\n\t\t\t\tif (isEnableLoggingRequestDetails()) {\n\t\t\t\t\theaders = values.stream().map(name -> name + \":\" + Collections.list(request.getHeaders(name)))\n\t\t\t\t\t\t\t.collect(Collectors.joining(\", \"));\n\t\t\t\t}\n\t\t\t\treturn message + \", headers={\" + headers + \"} in DispatcherServlet '\" + getServletName() + \"'\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn message;\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Process the actual dispatching to the handler.\n\t * <p>The handler will be obtained by applying the servlet's HandlerMappings in order.\n\t * The HandlerAdapter will be obtained by querying the servlet's installed HandlerAdapters\n\t * to find the first that supports the handler class.\n\t * <p>All HTTP methods are handled by this method. It's up to HandlerAdapters or handlers\n\t * themselves to decide which methods are acceptable.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @throws Exception in case of any kind of processing failure\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\tprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t\tHttpServletRequest processedRequest = request;\n\t\tHandlerExecutionChain mappedHandler = null;\n\t\tboolean multipartRequestParsed = false;\n\n\t\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n\t\ttry {\n\t\t\tModelAndView mv = null;\n\t\t\tException dispatchException = null;\n\n\t\t\ttry {\n\t\t\t\tprocessedRequest = checkMultipart(request);\n\t\t\t\tmultipartRequestParsed = (processedRequest != request);\n\n\t\t\t\t// Determine handler for the current request.\n\t\t\t\tmappedHandler = getHandler(processedRequest);\n\t\t\t\tif (mappedHandler == null) {\n\t\t\t\t\tnoHandlerFound(processedRequest, response);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Determine handler adapter for the current request.\n\t\t\t\tHandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n\n\t\t\t\t// Process last-modified header, if supported by the handler.\n\t\t\t\tString method = request.getMethod();\n\t\t\t\tboolean isGet = HttpMethod.GET.matches(method);\n\t\t\t\tif (isGet || HttpMethod.HEAD.matches(method)) {\n\t\t\t\t\tlong lastModified = ha.getLastModified(request, mappedHandler.getHandler());\n\t\t\t\t\tif (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!mappedHandler.applyPreHandle(processedRequest, response)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Actually invoke the handler.\n\t\t\t\tmv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n\n\t\t\t\tif (asyncManager.isConcurrentHandlingStarted()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tapplyDefaultViewName(processedRequest, mv);\n\t\t\t\tmappedHandler.applyPostHandle(processedRequest, response, mv);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tdispatchException = ex;\n\t\t\t}\n\t\t\tcatch (Throwable err) {\n\t\t\t\t// As of 4.3, we're processing Errors thrown from handler methods as well,\n\t\t\t\t// making them available for @ExceptionHandler methods and other scenarios.\n\t\t\t\tdispatchException = new ServletException(\"Handler dispatch failed: \" + err, err);\n\t\t\t}\n\t\t\tprocessDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\ttriggerAfterCompletion(processedRequest, response, mappedHandler, ex);\n\t\t}\n\t\tcatch (Throwable err) {\n\t\t\ttriggerAfterCompletion(processedRequest, response, mappedHandler,\n\t\t\t\t\tnew ServletException(\"Handler processing failed: \" + err, err));\n\t\t}\n\t\tfinally {\n\t\t\tif (asyncManager.isConcurrentHandlingStarted()) {\n\t\t\t\t// Instead of postHandle and afterCompletion\n\t\t\t\tif (mappedHandler != null) {\n\t\t\t\t\tmappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Clean up any resources used by a multipart request.\n\t\t\t\tif (multipartRequestParsed) {\n\t\t\t\t\tcleanupMultipart(processedRequest);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Do we need view name translation?\n\t */\n\tprivate void applyDefaultViewName(HttpServletRequest request, @Nullable ModelAndView mv) throws Exception {\n\t\tif (mv != null && !mv.hasView()) {\n\t\t\tString defaultViewName = getDefaultViewName(request);\n\t\t\tif (defaultViewName != null) {\n\t\t\t\tmv.setViewName(defaultViewName);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Handle the result of handler selection and handler invocation, which is\n\t * either a ModelAndView or an Exception to be resolved to a ModelAndView.\n\t */\n\tprivate void processDispatchResult(HttpServletRequest request, HttpServletResponse response,\n\t\t\t@Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,\n\t\t\t@Nullable Exception exception) throws Exception {\n\n\t\tboolean errorView = false;\n\n\t\tif (exception != null) {\n\t\t\tif (exception instanceof ModelAndViewDefiningException mavDefiningException) {\n\t\t\t\tlogger.debug(\"ModelAndViewDefiningException encountered\", exception);\n\t\t\t\tmv = mavDefiningException.getModelAndView();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tObject handler = (mappedHandler != null ? mappedHandler.getHandler() : null);\n\t\t\t\tmv = processHandlerException(request, response, handler, exception);\n\t\t\t\terrorView = (mv != null);\n\t\t\t}\n\t\t}\n\n\t\t// Did the handler return a view to render?\n\t\tif (mv != null && !mv.wasCleared()) {\n\t\t\trender(mv, request, response);\n\t\t\tif (errorView) {\n\t\t\t\tWebUtils.clearErrorRequestAttributes(request);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"No view rendering, null ModelAndView returned.\");\n\t\t\t}\n\t\t}\n\n\t\tif (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {\n\t\t\t// Concurrent handling started during a forward\n\t\t\treturn;\n\t\t}\n\n\t\tif (mappedHandler != null) {\n\t\t\t// Exception (if any) is already handled..\n\t\t\tmappedHandler.triggerAfterCompletion(request, response, null);\n\t\t}\n\t}\n\n\t/**\n\t * Build a LocaleContext for the given request, exposing the request's primary locale as current locale.\n\t * <p>The default implementation uses the dispatcher's LocaleResolver to obtain the current locale,\n\t * which might change during a request.\n\t * @param request current HTTP request\n\t * @return the corresponding LocaleContext\n\t */\n\t@Override\n\tprotected LocaleContext buildLocaleContext(final HttpServletRequest request) {\n\t\tLocaleResolver lr = this.localeResolver;\n\t\tif (lr instanceof LocaleContextResolver localeContextResolver) {\n\t\t\treturn localeContextResolver.resolveLocaleContext(request);\n\t\t}\n\t\telse {\n\t\t\treturn () -> (lr != null ? lr.resolveLocale(request) : request.getLocale());\n\t\t}\n\t}\n\n\t/**\n\t * Convert the request into a multipart request, and make multipart resolver available.\n\t * <p>If no multipart resolver is set, simply use the existing request.\n\t * @param request current HTTP request\n\t * @return the processed request (multipart wrapper if necessary)\n\t * @see MultipartResolver#resolveMultipart\n\t */\n\tprotected HttpServletRequest checkMultipart(HttpServletRequest request) throws MultipartException {\n\t\tif (this.multipartResolver != null && this.multipartResolver.isMultipart(request)) {\n\t\t\tif (WebUtils.getNativeRequest(request, MultipartHttpServletRequest.class) != null) {\n\t\t\t\tif (DispatcherType.REQUEST.equals(request.getDispatcherType())) {\n\t\t\t\t\tlogger.trace(\"Request already resolved to MultipartHttpServletRequest, e.g. by MultipartFilter\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (hasMultipartException(request)) {\n\t\t\t\tlogger.debug(\"Multipart resolution previously failed for current request - \" +\n\t\t\t\t\t\t\"skipping re-resolution for undisturbed error rendering\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\treturn this.multipartResolver.resolveMultipart(request);\n\t\t\t\t}\n\t\t\t\tcatch (MultipartException ex) {\n\t\t\t\t\tif (request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) != null) {\n\t\t\t\t\t\tlogger.debug(\"Multipart resolution failed for error dispatch\", ex);\n\t\t\t\t\t\t// Keep processing error dispatch with regular request handle below\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// If not returned before: return original request.\n\t\treturn request;\n\t}\n\n\t/**\n\t * Check \"jakarta.servlet.error.exception\" attribute for a multipart exception.\n\t */\n\tprivate boolean hasMultipartException(HttpServletRequest request) {\n\t\tThrowable error = (Throwable) request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE);\n\t\twhile (error != null) {\n\t\t\tif (error instanceof MultipartException) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\terror = error.getCause();\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Clean up any resources used by the given multipart request (if any).\n\t * @param request current HTTP request\n\t * @see MultipartResolver#cleanupMultipart\n\t */\n\tprotected void cleanupMultipart(HttpServletRequest request) {\n\t\tif (this.multipartResolver != null) {\n\t\t\tMultipartHttpServletRequest multipartRequest =\n\t\t\t\t\tWebUtils.getNativeRequest(request, MultipartHttpServletRequest.class);\n\t\t\tif (multipartRequest != null) {\n\t\t\t\tthis.multipartResolver.cleanupMultipart(multipartRequest);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Return the HandlerExecutionChain for this request.\n\t * <p>Tries all handler mappings in order.\n\t * @param request current HTTP request\n\t * @return the HandlerExecutionChain, or {@code null} if no handler could be found\n\t */\n\t@Nullable\n\tprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {\n\t\tif (this.handlerMappings != null) {\n\t\t\tfor (HandlerMapping mapping : this.handlerMappings) {\n\t\t\t\tHandlerExecutionChain handler = mapping.getHandler(request);\n\t\t\t\tif (handler != null) {\n\t\t\t\t\treturn handler;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * No handler found &rarr; set appropriate HTTP response status.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @throws Exception if preparing the response failed\n\t */\n\tprotected void noHandlerFound(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t\tif (pageNotFoundLogger.isWarnEnabled()) {\n\t\t\tpageNotFoundLogger.warn(\"No mapping for \" + request.getMethod() + \" \" + getRequestUri(request));\n\t\t}\n\t\tif (this.throwExceptionIfNoHandlerFound) {\n\t\t\tthrow new NoHandlerFoundException(request.getMethod(), getRequestUri(request),\n\t\t\t\t\tnew ServletServerHttpRequest(request).getHeaders());\n\t\t}\n\t\telse {\n\t\t\tresponse.sendError(HttpServletResponse.SC_NOT_FOUND);\n\t\t}\n\t}\n\n\t/**\n\t * Return the HandlerAdapter for this handler object.\n\t * @param handler the handler object to find an adapter for\n\t * @throws ServletException if no HandlerAdapter can be found for the handler. This is a fatal error.\n\t */\n\tprotected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {\n\t\tif (this.handlerAdapters != null) {\n\t\t\tfor (HandlerAdapter adapter : this.handlerAdapters) {\n\t\t\t\tif (adapter.supports(handler)) {\n\t\t\t\t\treturn adapter;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new ServletException(\"No adapter for handler [\" + handler +\n\t\t\t\t\"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler\");\n\t}\n\n\t/**\n\t * Determine an error ModelAndView via the registered HandlerExceptionResolvers.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen at the time of the exception\n\t * (for example, if multipart resolution failed)\n\t * @param ex the exception that got thrown during handler execution\n\t * @return a corresponding ModelAndView to forward to\n\t * @throws Exception if no error ModelAndView found\n\t */\n\t@Nullable\n\tprotected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,\n\t\t\t@Nullable Object handler, Exception ex) throws Exception {\n\n\t\t// Success and error responses may use different content types\n\t\trequest.removeAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);\n\n\t\t// Check registered HandlerExceptionResolvers...\n\t\tModelAndView exMv = null;\n\t\tif (this.handlerExceptionResolvers != null) {\n\t\t\tfor (HandlerExceptionResolver resolver : this.handlerExceptionResolvers) {\n\t\t\t\texMv = resolver.resolveException(request, response, handler, ex);\n\t\t\t\tif (exMv != null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (exMv != null) {\n\t\t\tif (exMv.isEmpty()) {\n\t\t\t\trequest.setAttribute(EXCEPTION_ATTRIBUTE, ex);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// We might still need view name translation for a plain error model...\n\t\t\tif (!exMv.hasView()) {\n\t\t\t\tString defaultViewName = getDefaultViewName(request);\n\t\t\t\tif (defaultViewName != null) {\n\t\t\t\t\texMv.setViewName(defaultViewName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Using resolved error view: \" + exMv, ex);\n\t\t\t}\n\t\t\telse if (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Using resolved error view: \" + exMv);\n\t\t\t}\n\t\t\tWebUtils.exposeErrorRequestAttributes(request, ex, getServletName());\n\t\t\treturn exMv;\n\t\t}\n\n\t\tthrow ex;\n\t}\n\n\t/**\n\t * Render the given ModelAndView.\n\t * <p>This is the last stage in handling a request. It may involve resolving the view by name.\n\t * @param mv the ModelAndView to render\n\t * @param request current HTTP servlet request\n\t * @param response current HTTP servlet response\n\t * @throws ServletException if view is missing or cannot be resolved\n\t * @throws Exception if there's a problem rendering the view\n\t */\n\tprotected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t\t// Determine locale for request and apply it to the response.\n\t\tLocale locale =\n\t\t\t\t(this.localeResolver != null ? this.localeResolver.resolveLocale(request) : request.getLocale());\n\t\tresponse.setLocale(locale);\n\n\t\tView view;\n\t\tString viewName = mv.getViewName();\n\t\tif (viewName != null) {\n\t\t\t// We need to resolve the view name.\n\t\t\tview = resolveViewName(viewName, mv.getModelInternal(), locale, request);\n\t\t\tif (view == null) {\n\t\t\t\tthrow new ServletException(\"Could not resolve view with name '\" + mv.getViewName() +\n\t\t\t\t\t\t\"' in servlet with name '\" + getServletName() + \"'\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// No need to lookup: the ModelAndView object contains the actual View object.\n\t\t\tview = mv.getView();\n\t\t\tif (view == null) {\n\t\t\t\tthrow new ServletException(\"ModelAndView [\" + mv + \"] neither contains a view name nor a \" +\n\t\t\t\t\t\t\"View object in servlet with name '\" + getServletName() + \"'\");\n\t\t\t}\n\t\t}\n\n\t\t// Delegate to the View object for rendering.\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Rendering view [\" + view + \"] \");\n\t\t}\n\t\ttry {\n\t\t\tif (mv.getStatus() != null) {\n\t\t\t\trequest.setAttribute(View.RESPONSE_STATUS_ATTRIBUTE, mv.getStatus());\n\t\t\t\tresponse.setStatus(mv.getStatus().value());\n\t\t\t}\n\t\t\tview.render(mv.getModelInternal(), request, response);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Error rendering view [\" + view + \"]\", ex);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\t/**\n\t * Translate the supplied request into a default view name.\n\t * @param request current HTTP servlet request\n\t * @return the view name (or {@code null} if no default found)\n\t * @throws Exception if view name translation failed\n\t */\n\t@Nullable\n\tprotected String getDefaultViewName(HttpServletRequest request) throws Exception {\n\t\treturn (this.viewNameTranslator != null ? this.viewNameTranslator.getViewName(request) : null);\n\t}\n\n\t/**\n\t * Resolve the given view name into a View object (to be rendered).\n\t * <p>The default implementations asks all ViewResolvers of this dispatcher.\n\t * Can be overridden for custom resolution strategies, potentially based on\n\t * specific model attributes or request parameters.\n\t * @param viewName the name of the view to resolve\n\t * @param model the model to be passed to the view\n\t * @param locale the current locale\n\t * @param request current HTTP servlet request\n\t * @return the View object, or {@code null} if none found\n\t * @throws Exception if the view cannot be resolved\n\t * (typically in case of problems creating an actual View object)\n\t * @see ViewResolver#resolveViewName\n\t */\n\t@Nullable\n\tprotected View resolveViewName(String viewName, @Nullable Map<String, Object> model,\n\t\t\tLocale locale, HttpServletRequest request) throws Exception {\n\n\t\tif (this.viewResolvers != null) {\n\t\t\tfor (ViewResolver viewResolver : this.viewResolvers) {\n\t\t\t\tView view = viewResolver.resolveViewName(viewName, locale);\n\t\t\t\tif (view != null) {\n\t\t\t\t\treturn view;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response,\n\t\t\t@Nullable HandlerExecutionChain mappedHandler, Exception ex) throws Exception {\n\n\t\tif (mappedHandler != null) {\n\t\t\tmappedHandler.triggerAfterCompletion(request, response, ex);\n\t\t}\n\t\tthrow ex;\n\t}\n\n\t/**\n\t * Restore the request attributes after an include.\n\t * @param request current HTTP request\n\t * @param attributesSnapshot the snapshot of the request attributes before the include\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprivate void restoreAttributesAfterInclude(HttpServletRequest request, Map<?, ?> attributesSnapshot) {\n\t\t// Need to copy into separate Collection here, to avoid side effects\n\t\t// on the Enumeration when removing attributes.\n\t\tSet<String> attrsToCheck = new HashSet<>();\n\t\tEnumeration<?> attrNames = request.getAttributeNames();\n\t\twhile (attrNames.hasMoreElements()) {\n\t\t\tString attrName = (String) attrNames.nextElement();\n\t\t\tif (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) {\n\t\t\t\tattrsToCheck.add(attrName);\n\t\t\t}\n\t\t}\n\n\t\t// Add attributes that may have been removed\n\t\tattrsToCheck.addAll((Set<String>) attributesSnapshot.keySet());\n\n\t\t// Iterate over the attributes to check, restoring the original value\n\t\t// or removing the attribute, respectively, if appropriate.\n\t\tfor (String attrName : attrsToCheck) {\n\t\t\tObject attrValue = attributesSnapshot.get(attrName);\n\t\t\tif (attrValue == null) {\n\t\t\t\trequest.removeAttribute(attrName);\n\t\t\t}\n\t\t\telse if (attrValue != request.getAttribute(attrName)) {\n\t\t\t\trequest.setAttribute(attrName, attrValue);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static String getRequestUri(HttpServletRequest request) {\n\t\tString uri = (String) request.getAttribute(WebUtils.INCLUDE_REQUEST_URI_ATTRIBUTE);\n\t\tif (uri == null) {\n\t\t\turi = request.getRequestURI();\n\t\t}\n\t\treturn uri;\n\t}\n\n}"
  },
  "org.springframework.web.servlet.DispatcherServlet#buildLocaleContext(request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a LocaleContext for the given request, exposing the request's primary locale as current locale.\n\t * <p>The default implementation uses the dispatcher's LocaleResolver to obtain the current locale,\n\t * which might change during a request.\n\t * @param request current HTTP request\n\t * @return the corresponding LocaleContext\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 1189
    },
    "return": "LocaleContext",
    "signature": "protected LocaleContext buildLocaleContext(final HttpServletRequest request)",
    "source_code": "\tprotected LocaleContext buildLocaleContext(final HttpServletRequest request) {\n\t\tLocaleResolver lr = this.localeResolver;\n\t\tif (lr instanceof LocaleContextResolver localeContextResolver) {\n\t\t\treturn localeContextResolver.resolveLocaleContext(request);\n\t\t}\n\t\telse {\n\t\t\treturn () -> (lr != null ? lr.resolveLocale(request) : request.getLocale());\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.DispatcherServlet#checkMultipart(request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the request into a multipart request, and make multipart resolver available.\n\t * <p>If no multipart resolver is set, simply use the existing request.\n\t * @param request current HTTP request\n\t * @return the processed request (multipart wrapper if necessary)\n\t * @see MultipartResolver#resolveMultipart\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 1206
    },
    "return": "HttpServletRequest",
    "signature": "protected HttpServletRequest checkMultipart(HttpServletRequest request)",
    "source_code": "\tprotected HttpServletRequest checkMultipart(HttpServletRequest request) throws MultipartException {\n\t\tif (this.multipartResolver != null && this.multipartResolver.isMultipart(request)) {\n\t\t\tif (WebUtils.getNativeRequest(request, MultipartHttpServletRequest.class) != null) {\n\t\t\t\tif (DispatcherType.REQUEST.equals(request.getDispatcherType())) {\n\t\t\t\t\tlogger.trace(\"Request already resolved to MultipartHttpServletRequest, e.g. by MultipartFilter\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (hasMultipartException(request)) {\n\t\t\t\tlogger.debug(\"Multipart resolution previously failed for current request - \" +\n\t\t\t\t\t\t\"skipping re-resolution for undisturbed error rendering\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\treturn this.multipartResolver.resolveMultipart(request);\n\t\t\t\t}\n\t\t\t\tcatch (MultipartException ex) {\n\t\t\t\t\tif (request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) != null) {\n\t\t\t\t\t\tlogger.debug(\"Multipart resolution failed for error dispatch\", ex);\n\t\t\t\t\t\t// Keep processing error dispatch with regular request handle below\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// If not returned before: return original request.\n\t\treturn request;\n\t}"
  },
  "org.springframework.web.servlet.DispatcherServlet#cleanupMultipart(request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Clean up any resources used by the given multipart request (if any).\n\t * @param request current HTTP request\n\t * @see MultipartResolver#cleanupMultipart\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 1255
    },
    "return": "void",
    "signature": "protected void cleanupMultipart(HttpServletRequest request)",
    "source_code": "\tprotected void cleanupMultipart(HttpServletRequest request) {\n\t\tif (this.multipartResolver != null) {\n\t\t\tMultipartHttpServletRequest multipartRequest =\n\t\t\t\t\tWebUtils.getNativeRequest(request, MultipartHttpServletRequest.class);\n\t\t\tif (multipartRequest != null) {\n\t\t\t\tthis.multipartResolver.cleanupMultipart(multipartRequest);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.DispatcherServlet#createDefaultStrategy(context,clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a default strategy.\n\t * <p>The default implementation uses\n\t * {@link org.springframework.beans.factory.config.AutowireCapableBeanFactory#createBean}.\n\t * @param context the current WebApplicationContext\n\t * @param clazz the strategy implementation class to instantiate\n\t * @return the fully configured strategy instance\n\t * @see org.springframework.context.ApplicationContext#getAutowireCapableBeanFactory()\n\t * @see org.springframework.beans.factory.config.AutowireCapableBeanFactory#createBean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "context",
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 925
    },
    "return": "Object",
    "signature": "protected Object createDefaultStrategy(ApplicationContext context, Class<?> clazz)",
    "source_code": "\tprotected Object createDefaultStrategy(ApplicationContext context, Class<?> clazz) {\n\t\treturn context.getAutowireCapableBeanFactory().createBean(clazz);\n\t}"
  },
  "org.springframework.web.servlet.DispatcherServlet#doDispatch(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Process the actual dispatching to the handler.\n\t * <p>The handler will be obtained by applying the servlet's HandlerMappings in order.\n\t * The HandlerAdapter will be obtained by querying the servlet's installed HandlerAdapters\n\t * to find the first that supports the handler class.\n\t * <p>All HTTP methods are handled by this method. It's up to HandlerAdapters or handlers\n\t * themselves to decide which methods are acceptable.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @throws Exception in case of any kind of processing failure\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 1041
    },
    "return": "void",
    "signature": "protected void doDispatch(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t\tHttpServletRequest processedRequest = request;\n\t\tHandlerExecutionChain mappedHandler = null;\n\t\tboolean multipartRequestParsed = false;\n\n\t\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n\t\ttry {\n\t\t\tModelAndView mv = null;\n\t\t\tException dispatchException = null;\n\n\t\t\ttry {\n\t\t\t\tprocessedRequest = checkMultipart(request);\n\t\t\t\tmultipartRequestParsed = (processedRequest != request);\n\n\t\t\t\t// Determine handler for the current request.\n\t\t\t\tmappedHandler = getHandler(processedRequest);\n\t\t\t\tif (mappedHandler == null) {\n\t\t\t\t\tnoHandlerFound(processedRequest, response);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Determine handler adapter for the current request.\n\t\t\t\tHandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n\n\t\t\t\t// Process last-modified header, if supported by the handler.\n\t\t\t\tString method = request.getMethod();\n\t\t\t\tboolean isGet = HttpMethod.GET.matches(method);\n\t\t\t\tif (isGet || HttpMethod.HEAD.matches(method)) {\n\t\t\t\t\tlong lastModified = ha.getLastModified(request, mappedHandler.getHandler());\n\t\t\t\t\tif (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!mappedHandler.applyPreHandle(processedRequest, response)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Actually invoke the handler.\n\t\t\t\tmv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n\n\t\t\t\tif (asyncManager.isConcurrentHandlingStarted()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tapplyDefaultViewName(processedRequest, mv);\n\t\t\t\tmappedHandler.applyPostHandle(processedRequest, response, mv);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tdispatchException = ex;\n\t\t\t}\n\t\t\tcatch (Throwable err) {\n\t\t\t\t// As of 4.3, we're processing Errors thrown from handler methods as well,\n\t\t\t\t// making them available for @ExceptionHandler methods and other scenarios.\n\t\t\t\tdispatchException = new ServletException(\"Handler dispatch failed: \" + err, err);\n\t\t\t}\n\t\t\tprocessDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\ttriggerAfterCompletion(processedRequest, response, mappedHandler, ex);\n\t\t}\n\t\tcatch (Throwable err) {\n\t\t\ttriggerAfterCompletion(processedRequest, response, mappedHandler,\n\t\t\t\t\tnew ServletException(\"Handler processing failed: \" + err, err));\n\t\t}\n\t\tfinally {\n\t\t\tif (asyncManager.isConcurrentHandlingStarted()) {\n\t\t\t\t// Instead of postHandle and afterCompletion\n\t\t\t\tif (mappedHandler != null) {\n\t\t\t\t\tmappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Clean up any resources used by a multipart request.\n\t\t\t\tif (multipartRequestParsed) {\n\t\t\t\t\tcleanupMultipart(processedRequest);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.DispatcherServlet#doService(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Exposes the DispatcherServlet-specific request attributes and delegates to {@link #doDispatch}\n\t * for the actual dispatching.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 935
    },
    "return": "void",
    "signature": "protected void doService(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t\tlogRequest(request);\n\n\t\t// Keep a snapshot of the request attributes in case of an include,\n\t\t// to be able to restore the original attributes after the include.\n\t\tMap<String, Object> attributesSnapshot = null;\n\t\tif (WebUtils.isIncludeRequest(request)) {\n\t\t\tattributesSnapshot = new HashMap<>();\n\t\t\tEnumeration<?> attrNames = request.getAttributeNames();\n\t\t\twhile (attrNames.hasMoreElements()) {\n\t\t\t\tString attrName = (String) attrNames.nextElement();\n\t\t\t\tif (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) {\n\t\t\t\t\tattributesSnapshot.put(attrName, request.getAttribute(attrName));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Make framework objects available to handlers and view objects.\n\t\trequest.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());\n\t\trequest.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);\n\t\trequest.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);\n\t\trequest.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());\n\n\t\tif (this.flashMapManager != null) {\n\t\t\tFlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);\n\t\t\tif (inputFlashMap != null) {\n\t\t\t\trequest.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));\n\t\t\t}\n\t\t\trequest.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());\n\t\t\trequest.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);\n\t\t}\n\n\t\tRequestPath previousRequestPath = null;\n\t\tif (this.parseRequestPath) {\n\t\t\tpreviousRequestPath = (RequestPath) request.getAttribute(ServletRequestPathUtils.PATH_ATTRIBUTE);\n\t\t\tServletRequestPathUtils.parseAndCache(request);\n\t\t}\n\n\t\ttry {\n\t\t\tdoDispatch(request, response);\n\t\t}\n\t\tfinally {\n\t\t\tif (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {\n\t\t\t\t// Restore the original attribute snapshot, in case of an include.\n\t\t\t\tif (attributesSnapshot != null) {\n\t\t\t\t\trestoreAttributesAfterInclude(request, attributesSnapshot);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.parseRequestPath) {\n\t\t\t\tServletRequestPathUtils.setParsedRequestPath(previousRequestPath, request);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.DispatcherServlet#getDefaultStrategies(context,strategyInterface)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a List of default strategy objects for the given strategy interface.\n\t * <p>The default implementation uses the \"DispatcherServlet.properties\" file (in the same\n\t * package as the DispatcherServlet class) to determine the class names. It instantiates\n\t * the strategy objects through the context's BeanFactory.\n\t * @param context the current WebApplicationContext\n\t * @param strategyInterface the strategy interface\n\t * @return the List of corresponding strategy objects\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "context",
      "strategyInterface"
    ],
    "position": {
      "column": 1,
      "line": 872
    },
    "return": "List<T>",
    "signature": "protected List<T> getDefaultStrategies(ApplicationContext context, Class<T> strategyInterface)",
    "source_code": "\tprotected <T> List<T> getDefaultStrategies(ApplicationContext context, Class<T> strategyInterface) {\n\t\tif (defaultStrategies == null) {\n\t\t\ttry {\n\t\t\t\t// Load default strategy implementations from properties file.\n\t\t\t\t// This is currently strictly internal and not meant to be customized\n\t\t\t\t// by application developers.\n\t\t\t\tClassPathResource resource = new ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.class);\n\t\t\t\tdefaultStrategies = PropertiesLoaderUtils.loadProperties(resource);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new IllegalStateException(\"Could not load '\" + DEFAULT_STRATEGIES_PATH + \"': \" + ex.getMessage());\n\t\t\t}\n\t\t}\n\n\t\tString key = strategyInterface.getName();\n\t\tString value = defaultStrategies.getProperty(key);\n\t\tif (value != null) {\n\t\t\tString[] classNames = StringUtils.commaDelimitedListToStringArray(value);\n\t\t\tList<T> strategies = new ArrayList<>(classNames.length);\n\t\t\tfor (String className : classNames) {\n\t\t\t\ttry {\n\t\t\t\t\tClass<?> clazz = ClassUtils.forName(className, DispatcherServlet.class.getClassLoader());\n\t\t\t\t\tObject strategy = createDefaultStrategy(context, clazz);\n\t\t\t\t\tstrategies.add((T) strategy);\n\t\t\t\t}\n\t\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\t\tthrow new BeanInitializationException(\n\t\t\t\t\t\t\t\"Could not find DispatcherServlet's default strategy class [\" + className +\n\t\t\t\t\t\t\t\"] for interface [\" + key + \"]\", ex);\n\t\t\t\t}\n\t\t\t\tcatch (LinkageError err) {\n\t\t\t\t\tthrow new BeanInitializationException(\n\t\t\t\t\t\t\t\"Unresolvable class definition for DispatcherServlet's default strategy class [\" +\n\t\t\t\t\t\t\tclassName + \"] for interface [\" + key + \"]\", err);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn strategies;\n\t\t}\n\t\telse {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.DispatcherServlet#getDefaultStrategy(context,strategyInterface)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the default strategy object for the given strategy interface.\n\t * <p>The default implementation delegates to {@link #getDefaultStrategies},\n\t * expecting a single object in the list.\n\t * @param context the current WebApplicationContext\n\t * @param strategyInterface the strategy interface\n\t * @return the corresponding strategy object\n\t * @see #getDefaultStrategies\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "context",
      "strategyInterface"
    ],
    "position": {
      "column": 1,
      "line": 853
    },
    "return": "T",
    "signature": "protected T getDefaultStrategy(ApplicationContext context, Class<T> strategyInterface)",
    "source_code": "\tprotected <T> T getDefaultStrategy(ApplicationContext context, Class<T> strategyInterface) {\n\t\tList<T> strategies = getDefaultStrategies(context, strategyInterface);\n\t\tif (strategies.size() != 1) {\n\t\t\tthrow new BeanInitializationException(\n\t\t\t\t\t\"DispatcherServlet needs exactly 1 strategy for interface [\" + strategyInterface.getName() + \"]\");\n\t\t}\n\t\treturn strategies.get(0);\n\t}"
  },
  "org.springframework.web.servlet.DispatcherServlet#getDefaultViewName(request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Translate the supplied request into a default view name.\n\t * @param request current HTTP servlet request\n\t * @return the view name (or {@code null} if no default found)\n\t * @throws Exception if view name translation failed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 1432
    },
    "return": "String",
    "signature": "protected String getDefaultViewName(HttpServletRequest request)",
    "source_code": "\tprotected String getDefaultViewName(HttpServletRequest request) throws Exception {\n\t\treturn (this.viewNameTranslator != null ? this.viewNameTranslator.getViewName(request) : null);\n\t}"
  },
  "org.springframework.web.servlet.DispatcherServlet#getHandler(request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the HandlerExecutionChain for this request.\n\t * <p>Tries all handler mappings in order.\n\t * @param request current HTTP request\n\t * @return the HandlerExecutionChain, or {@code null} if no handler could be found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 1272
    },
    "return": "HandlerExecutionChain",
    "signature": "protected HandlerExecutionChain getHandler(HttpServletRequest request)",
    "source_code": "\tprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {\n\t\tif (this.handlerMappings != null) {\n\t\t\tfor (HandlerMapping mapping : this.handlerMappings) {\n\t\t\t\tHandlerExecutionChain handler = mapping.getHandler(request);\n\t\t\t\tif (handler != null) {\n\t\t\t\t\treturn handler;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.DispatcherServlet#getHandlerAdapter(handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the HandlerAdapter for this handler object.\n\t * @param handler the handler object to find an adapter for\n\t * @throws ServletException if no HandlerAdapter can be found for the handler. This is a fatal error.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 1308
    },
    "return": "HandlerAdapter",
    "signature": "protected HandlerAdapter getHandlerAdapter(Object handler)",
    "source_code": "\tprotected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {\n\t\tif (this.handlerAdapters != null) {\n\t\t\tfor (HandlerAdapter adapter : this.handlerAdapters) {\n\t\t\t\tif (adapter.supports(handler)) {\n\t\t\t\t\treturn adapter;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new ServletException(\"No adapter for handler [\" + handler +\n\t\t\t\t\"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler\");\n\t}"
  },
  "org.springframework.web.servlet.DispatcherServlet#getHandlerMappings()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured {@link HandlerMapping} beans that were detected by\n\t * type in the {@link WebApplicationContext} or initialized based on the\n\t * default set of strategies from {@literal DispatcherServlet.properties}.\n\t * <p><strong>Note:</strong> This method may return {@code null} if invoked\n\t * prior to {@link #onRefresh(ApplicationContext)}.\n\t * @return an immutable list with the configured mappings, or {@code null}\n\t * if not initialized yet\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 840
    },
    "return": "List<HandlerMapping>",
    "signature": "public List<HandlerMapping> getHandlerMappings()",
    "source_code": "\tpublic final List<HandlerMapping> getHandlerMappings() {\n\t\treturn (this.handlerMappings != null ? Collections.unmodifiableList(this.handlerMappings) : null);\n\t}"
  },
  "org.springframework.web.servlet.DispatcherServlet#getMultipartResolver()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain this servlet's MultipartResolver, if any.\n\t * @return the MultipartResolver used by this servlet, or {@code null} if none\n\t * (indicating that no multipart support is available)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 825
    },
    "return": "MultipartResolver",
    "signature": "public MultipartResolver getMultipartResolver()",
    "source_code": "\tpublic final MultipartResolver getMultipartResolver() {\n\t\treturn this.multipartResolver;\n\t}"
  },
  "org.springframework.web.servlet.DispatcherServlet#initStrategies(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the strategy objects that this servlet uses.\n\t * <p>May be overridden in subclasses in order to initialize further strategy objects.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 504
    },
    "return": "void",
    "signature": "protected void initStrategies(ApplicationContext context)",
    "source_code": "\tprotected void initStrategies(ApplicationContext context) {\n\t\tinitMultipartResolver(context);\n\t\tinitLocaleResolver(context);\n\t\tinitThemeResolver(context);\n\t\tinitHandlerMappings(context);\n\t\tinitHandlerAdapters(context);\n\t\tinitHandlerExceptionResolvers(context);\n\t\tinitRequestToViewNameTranslator(context);\n\t\tinitViewResolvers(context);\n\t\tinitFlashMapManager(context);\n\t}"
  },
  "org.springframework.web.servlet.DispatcherServlet#noHandlerFound(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * No handler found &rarr; set appropriate HTTP response status.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @throws Exception if preparing the response failed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 1290
    },
    "return": "void",
    "signature": "protected void noHandlerFound(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void noHandlerFound(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t\tif (pageNotFoundLogger.isWarnEnabled()) {\n\t\t\tpageNotFoundLogger.warn(\"No mapping for \" + request.getMethod() + \" \" + getRequestUri(request));\n\t\t}\n\t\tif (this.throwExceptionIfNoHandlerFound) {\n\t\t\tthrow new NoHandlerFoundException(request.getMethod(), getRequestUri(request),\n\t\t\t\t\tnew ServletServerHttpRequest(request).getHeaders());\n\t\t}\n\t\telse {\n\t\t\tresponse.sendError(HttpServletResponse.SC_NOT_FOUND);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.DispatcherServlet#onRefresh(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation calls {@link #initStrategies}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 496
    },
    "return": "void",
    "signature": "protected void onRefresh(ApplicationContext context)",
    "source_code": "\tprotected void onRefresh(ApplicationContext context) {\n\t\tinitStrategies(context);\n\t}"
  },
  "org.springframework.web.servlet.DispatcherServlet#processHandlerException(request,response,handler,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine an error ModelAndView via the registered HandlerExceptionResolvers.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen at the time of the exception\n\t * (for example, if multipart resolution failed)\n\t * @param ex the exception that got thrown during handler execution\n\t * @return a corresponding ModelAndView to forward to\n\t * @throws Exception if no error ModelAndView found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 1331
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,\n\t\t\t@Nullable Object handler, Exception ex)",
    "source_code": "\tprotected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,"
  },
  "org.springframework.web.servlet.DispatcherServlet#render(mv,request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Render the given ModelAndView.\n\t * <p>This is the last stage in handling a request. It may involve resolving the view by name.\n\t * @param mv the ModelAndView to render\n\t * @param request current HTTP servlet request\n\t * @param response current HTTP servlet response\n\t * @throws ServletException if view is missing or cannot be resolved\n\t * @throws Exception if there's a problem rendering the view\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mv",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 1381
    },
    "return": "void",
    "signature": "protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t\t// Determine locale for request and apply it to the response.\n\t\tLocale locale =\n\t\t\t\t(this.localeResolver != null ? this.localeResolver.resolveLocale(request) : request.getLocale());\n\t\tresponse.setLocale(locale);\n\n\t\tView view;\n\t\tString viewName = mv.getViewName();\n\t\tif (viewName != null) {\n\t\t\t// We need to resolve the view name.\n\t\t\tview = resolveViewName(viewName, mv.getModelInternal(), locale, request);\n\t\t\tif (view == null) {\n\t\t\t\tthrow new ServletException(\"Could not resolve view with name '\" + mv.getViewName() +\n\t\t\t\t\t\t\"' in servlet with name '\" + getServletName() + \"'\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// No need to lookup: the ModelAndView object contains the actual View object.\n\t\t\tview = mv.getView();\n\t\t\tif (view == null) {\n\t\t\t\tthrow new ServletException(\"ModelAndView [\" + mv + \"] neither contains a view name nor a \" +\n\t\t\t\t\t\t\"View object in servlet with name '\" + getServletName() + \"'\");\n\t\t\t}\n\t\t}\n\n\t\t// Delegate to the View object for rendering.\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Rendering view [\" + view + \"] \");\n\t\t}\n\t\ttry {\n\t\t\tif (mv.getStatus() != null) {\n\t\t\t\trequest.setAttribute(View.RESPONSE_STATUS_ATTRIBUTE, mv.getStatus());\n\t\t\t\tresponse.setStatus(mv.getStatus().value());\n\t\t\t}\n\t\t\tview.render(mv.getModelInternal(), request, response);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Error rendering view [\" + view + \"]\", ex);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.DispatcherServlet#resolveViewName(viewName,Map<String,model,locale,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the given view name into a View object (to be rendered).\n\t * <p>The default implementations asks all ViewResolvers of this dispatcher.\n\t * Can be overridden for custom resolution strategies, potentially based on\n\t * specific model attributes or request parameters.\n\t * @param viewName the name of the view to resolve\n\t * @param model the model to be passed to the view\n\t * @param locale the current locale\n\t * @param request current HTTP servlet request\n\t * @return the View object, or {@code null} if none found\n\t * @throws Exception if the view cannot be resolved\n\t * (typically in case of problems creating an actual View object)\n\t * @see ViewResolver#resolveViewName\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "Map<String",
      "model",
      "locale",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 1451
    },
    "return": "View",
    "signature": "protected View resolveViewName(String viewName, @Nullable Map<String, Object> model,\n\t\t\tLocale locale, HttpServletRequest request)",
    "source_code": "\tprotected View resolveViewName(String viewName, @Nullable Map<String, Object> model,"
  },
  "org.springframework.web.servlet.DispatcherServlet#setCleanupAfterInclude(cleanupAfterInclude)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to perform cleanup of request attributes after an include request, that is,\n\t * whether to reset the original state of all request attributes after the DispatcherServlet\n\t * has processed within an include request. Otherwise, just the DispatcherServlet's own\n\t * request attributes will be reset, but not model attributes for JSPs or special attributes\n\t * set by views (for example, JSTL's).\n\t * <p>Default is \"true\", which is strongly recommended. Views should not rely on request attributes\n\t * having been set by (dynamic) includes. This allows JSP views rendered by an included controller\n\t * to use any model attributes, even with the same names as in the main JSP, without causing side\n\t * effects. Only turn this off for special needs, for example to deliberately allow main JSPs to\n\t * access attributes from JSP views rendered by an included controller.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cleanupAfterInclude"
    ],
    "position": {
      "column": 1,
      "line": 487
    },
    "return": "void",
    "signature": "public void setCleanupAfterInclude(boolean cleanupAfterInclude)",
    "source_code": "\tpublic void setCleanupAfterInclude(boolean cleanupAfterInclude) {\n\t\tthis.cleanupAfterInclude = cleanupAfterInclude;\n\t}"
  },
  "org.springframework.web.servlet.DispatcherServlet#setDetectAllHandlerAdapters(detectAllHandlerAdapters)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to detect all HandlerAdapter beans in this servlet's context. Otherwise,\n\t * just a single bean with name \"handlerAdapter\" will be expected.\n\t * <p>Default is \"true\". Turn this off if you want this servlet to use a single\n\t * HandlerAdapter, despite multiple HandlerAdapter beans being defined in the context.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "detectAllHandlerAdapters"
    ],
    "position": {
      "column": 1,
      "line": 436
    },
    "return": "void",
    "signature": "public void setDetectAllHandlerAdapters(boolean detectAllHandlerAdapters)",
    "source_code": "\tpublic void setDetectAllHandlerAdapters(boolean detectAllHandlerAdapters) {\n\t\tthis.detectAllHandlerAdapters = detectAllHandlerAdapters;\n\t}"
  },
  "org.springframework.web.servlet.DispatcherServlet#setDetectAllHandlerExceptionResolvers(detectAllHandlerExceptionResolvers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to detect all HandlerExceptionResolver beans in this servlet's context. Otherwise,\n\t * just a single bean with name \"handlerExceptionResolver\" will be expected.\n\t * <p>Default is \"true\". Turn this off if you want this servlet to use a single\n\t * HandlerExceptionResolver, despite multiple HandlerExceptionResolver beans being defined in the context.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "detectAllHandlerExceptionResolvers"
    ],
    "position": {
      "column": 1,
      "line": 446
    },
    "return": "void",
    "signature": "public void setDetectAllHandlerExceptionResolvers(boolean detectAllHandlerExceptionResolvers)",
    "source_code": "\tpublic void setDetectAllHandlerExceptionResolvers(boolean detectAllHandlerExceptionResolvers) {\n\t\tthis.detectAllHandlerExceptionResolvers = detectAllHandlerExceptionResolvers;\n\t}"
  },
  "org.springframework.web.servlet.DispatcherServlet#setDetectAllHandlerMappings(detectAllHandlerMappings)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to detect all HandlerMapping beans in this servlet's context. Otherwise,\n\t * just a single bean with name \"handlerMapping\" will be expected.\n\t * <p>Default is \"true\". Turn this off if you want this servlet to use a single\n\t * HandlerMapping, despite multiple HandlerMapping beans being defined in the context.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "detectAllHandlerMappings"
    ],
    "position": {
      "column": 1,
      "line": 426
    },
    "return": "void",
    "signature": "public void setDetectAllHandlerMappings(boolean detectAllHandlerMappings)",
    "source_code": "\tpublic void setDetectAllHandlerMappings(boolean detectAllHandlerMappings) {\n\t\tthis.detectAllHandlerMappings = detectAllHandlerMappings;\n\t}"
  },
  "org.springframework.web.servlet.DispatcherServlet#setDetectAllViewResolvers(detectAllViewResolvers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to detect all ViewResolver beans in this servlet's context. Otherwise,\n\t * just a single bean with name \"viewResolver\" will be expected.\n\t * <p>Default is \"true\". Turn this off if you want this servlet to use a single\n\t * ViewResolver, despite multiple ViewResolver beans being defined in the context.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "detectAllViewResolvers"
    ],
    "position": {
      "column": 1,
      "line": 456
    },
    "return": "void",
    "signature": "public void setDetectAllViewResolvers(boolean detectAllViewResolvers)",
    "source_code": "\tpublic void setDetectAllViewResolvers(boolean detectAllViewResolvers) {\n\t\tthis.detectAllViewResolvers = detectAllViewResolvers;\n\t}"
  },
  "org.springframework.web.servlet.DispatcherServlet#setThrowExceptionIfNoHandlerFound(throwExceptionIfNoHandlerFound)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to throw a NoHandlerFoundException when no Handler was found for this request.\n\t * This exception can then be caught with a HandlerExceptionResolver or an\n\t * {@code @ExceptionHandler} controller method.\n\t * <p>Note that if {@link org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler}\n\t * is used, then requests will always be forwarded to the default servlet and a\n\t * NoHandlerFoundException would never be thrown in that case.\n\t * <p>Default is \"false\", meaning the DispatcherServlet sends a NOT_FOUND error through the\n\t * Servlet response.\n\t * @since 4.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "throwExceptionIfNoHandlerFound"
    ],
    "position": {
      "column": 1,
      "line": 471
    },
    "return": "void",
    "signature": "public void setThrowExceptionIfNoHandlerFound(boolean throwExceptionIfNoHandlerFound)",
    "source_code": "\tpublic void setThrowExceptionIfNoHandlerFound(boolean throwExceptionIfNoHandlerFound) {\n\t\tthis.throwExceptionIfNoHandlerFound = throwExceptionIfNoHandlerFound;\n\t}"
  },
  "org.springframework.web.servlet.EXCEPTION_ATTRIBUTE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Name of request attribute that exposes an Exception resolved with a\n\t * {@link HandlerExceptionResolver} but where no view was rendered\n\t * (e.g. setting the status code).\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 271
    },
    "signature": "public String EXCEPTION_ATTRIBUTE",
    "source_code": "\tpublic static final String EXCEPTION_ATTRIBUTE = DispatcherServlet.class.getName() + \".EXCEPTION\";",
    "type": "String"
  },
  "org.springframework.web.servlet.FLASH_MAP_MANAGER_ATTRIBUTE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Name of request attribute that holds the {@link FlashMapManager}.\n\t * @see org.springframework.web.servlet.support.RequestContextUtils#getFlashMapManager(HttpServletRequest)\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 264
    },
    "signature": "public String FLASH_MAP_MANAGER_ATTRIBUTE",
    "source_code": "\tpublic static final String FLASH_MAP_MANAGER_ATTRIBUTE = DispatcherServlet.class.getName() + \".FLASH_MAP_MANAGER\";",
    "type": "String"
  },
  "org.springframework.web.servlet.FLASH_MAP_MANAGER_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Well-known name for the FlashMapManager object in the bean factory for this namespace.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "signature": "public String FLASH_MAP_MANAGER_BEAN_NAME",
    "source_code": "\tpublic static final String FLASH_MAP_MANAGER_BEAN_NAME = \"flashMapManager\";",
    "type": "String"
  },
  "org.springframework.web.servlet.HANDLER_ADAPTER_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Well-known name for the HandlerAdapter object in the bean factory for this namespace.\n\t * Only used when \"detectAllHandlerAdapters\" is turned off.\n\t * @see #setDetectAllHandlerAdapters\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "signature": "public String HANDLER_ADAPTER_BEAN_NAME",
    "source_code": "\tpublic static final String HANDLER_ADAPTER_BEAN_NAME = \"handlerAdapter\";",
    "type": "String"
  },
  "org.springframework.web.servlet.HANDLER_EXCEPTION_RESOLVER_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Well-known name for the HandlerExceptionResolver object in the bean factory for this namespace.\n\t * Only used when \"detectAllHandlerExceptionResolvers\" is turned off.\n\t * @see #setDetectAllHandlerExceptionResolvers\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 198
    },
    "signature": "public String HANDLER_EXCEPTION_RESOLVER_BEAN_NAME",
    "source_code": "\tpublic static final String HANDLER_EXCEPTION_RESOLVER_BEAN_NAME = \"handlerExceptionResolver\";",
    "type": "String"
  },
  "org.springframework.web.servlet.HANDLER_MAPPING_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Well-known name for the HandlerMapping object in the bean factory for this namespace.\n\t * Only used when \"detectAllHandlerMappings\" is turned off.\n\t * @see #setDetectAllHandlerMappings\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "signature": "public String HANDLER_MAPPING_BEAN_NAME",
    "source_code": "\tpublic static final String HANDLER_MAPPING_BEAN_NAME = \"handlerMapping\";",
    "type": "String"
  },
  "org.springframework.web.servlet.INPUT_FLASH_MAP_ATTRIBUTE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Name of request attribute that holds a read-only {@code Map<String,?>}\n\t * with \"input\" flash attributes saved by a previous request, if any.\n\t * @see org.springframework.web.servlet.support.RequestContextUtils#getInputFlashMap(HttpServletRequest)\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "signature": "public String INPUT_FLASH_MAP_ATTRIBUTE",
    "source_code": "\tpublic static final String INPUT_FLASH_MAP_ATTRIBUTE = DispatcherServlet.class.getName() + \".INPUT_FLASH_MAP\";",
    "type": "String"
  },
  "org.springframework.web.servlet.LOCALE_RESOLVER_ATTRIBUTE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Request attribute to hold the current LocaleResolver, retrievable by views.\n\t * @see org.springframework.web.servlet.support.RequestContextUtils#getLocaleResolver\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "signature": "public String LOCALE_RESOLVER_ATTRIBUTE",
    "source_code": "\tpublic static final String LOCALE_RESOLVER_ATTRIBUTE = DispatcherServlet.class.getName() + \".LOCALE_RESOLVER\";",
    "type": "String"
  },
  "org.springframework.web.servlet.LOCALE_RESOLVER_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Well-known name for the LocaleResolver object in the bean factory for this namespace. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 170
    },
    "signature": "public String LOCALE_RESOLVER_BEAN_NAME",
    "source_code": "\tpublic static final String LOCALE_RESOLVER_BEAN_NAME = \"localeResolver\";",
    "type": "String"
  },
  "org.springframework.web.servlet.MULTIPART_RESOLVER_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Well-known name for the MultipartResolver object in the bean factory for this namespace. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "signature": "public String MULTIPART_RESOLVER_BEAN_NAME",
    "source_code": "\tpublic static final String MULTIPART_RESOLVER_BEAN_NAME = \"multipartResolver\";",
    "type": "String"
  },
  "org.springframework.web.servlet.ModelAndView": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Holder for both Model and View in the web MVC framework.\n * Note that these are entirely distinct. This class merely holds\n * both to make it possible for a controller to return both model\n * and view in a single return value.\n *\n * <p>Represents a model and view returned by a handler, to be resolved\n * by a DispatcherServlet. The view can take the form of a String\n * view name which will need to be resolved by a ViewResolver object;\n * alternatively a View object can be specified directly. The model\n * is a Map, allowing the use of multiple objects keyed by name.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Rossen Stoyanchev\n * @see DispatcherServlet\n * @see ViewResolver\n * @see HandlerAdapter#handle\n * @see org.springframework.web.servlet.mvc.Controller#handleRequest\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "signature": "public class ModelAndView",
    "source_code": "public class ModelAndView {\n\n\t/** View instance or view name String. */\n\t@Nullable\n\tprivate Object view;\n\n\t/** Model Map. */\n\t@Nullable\n\tprivate ModelMap model;\n\n\t/** Optional HTTP status for the response. */\n\t@Nullable\n\tprivate HttpStatusCode status;\n\n\t/** Indicates whether this instance has been cleared with a call to {@link #clear()}. */\n\tprivate boolean cleared = false;\n\n\n\t/**\n\t * Default constructor for bean-style usage: populating bean\n\t * properties instead of passing in constructor arguments.\n\t * @see #setView(View)\n\t * @see #setViewName(String)\n\t */\n\tpublic ModelAndView() {\n\t}\n\n\t/**\n\t * Convenient constructor when there is no model data to expose.\n\t * Can also be used in conjunction with {@code addObject}.\n\t * @param viewName name of the View to render, to be resolved\n\t * by the DispatcherServlet's ViewResolver\n\t * @see #addObject\n\t */\n\tpublic ModelAndView(String viewName) {\n\t\tthis.view = viewName;\n\t}\n\n\t/**\n\t * Convenient constructor when there is no model data to expose.\n\t * Can also be used in conjunction with {@code addObject}.\n\t * @param view the View object to render\n\t * @see #addObject\n\t */\n\tpublic ModelAndView(View view) {\n\t\tthis.view = view;\n\t}\n\n\t/**\n\t * Create a new ModelAndView given a view name and a model.\n\t * @param viewName name of the View to render, to be resolved\n\t * by the DispatcherServlet's ViewResolver\n\t * @param model a Map of model names (Strings) to model objects\n\t * (Objects). Model entries may not be {@code null}, but the\n\t * model Map may be {@code null} if there is no model data.\n\t */\n\tpublic ModelAndView(String viewName, @Nullable Map<String, ?> model) {\n\t\tthis.view = viewName;\n\t\tif (model != null) {\n\t\t\tgetModelMap().addAllAttributes(model);\n\t\t}\n\t}\n\n\t/**\n\t * Create a new ModelAndView given a View object and a model.\n\t * <em>Note: the supplied model data is copied into the internal\n\t * storage of this class. You should not consider to modify the supplied\n\t * Map after supplying it to this class</em>\n\t * @param view the View object to render\n\t * @param model a Map of model names (Strings) to model objects\n\t * (Objects). Model entries may not be {@code null}, but the\n\t * model Map may be {@code null} if there is no model data.\n\t */\n\tpublic ModelAndView(View view, @Nullable Map<String, ?> model) {\n\t\tthis.view = view;\n\t\tif (model != null) {\n\t\t\tgetModelMap().addAllAttributes(model);\n\t\t}\n\t}\n\n\t/**\n\t * Create a new ModelAndView given a view name and HTTP status.\n\t * @param viewName name of the View to render, to be resolved\n\t * by the DispatcherServlet's ViewResolver\n\t * @param status an HTTP status code to use for the response\n\t * (to be set just prior to View rendering)\n\t * @since 4.3.8\n\t */\n\tpublic ModelAndView(String viewName, HttpStatusCode status) {\n\t\tthis.view = viewName;\n\t\tthis.status = status;\n\t}\n\n\t/**\n\t * Create a new ModelAndView given a view name, model, and HTTP status.\n\t * @param viewName name of the View to render, to be resolved\n\t * by the DispatcherServlet's ViewResolver\n\t * @param model a Map of model names (Strings) to model objects\n\t * (Objects). Model entries may not be {@code null}, but the\n\t * model Map may be {@code null} if there is no model data.\n\t * @param status an HTTP status code to use for the response\n\t * (to be set just prior to View rendering)\n\t * @since 4.3\n\t */\n\tpublic ModelAndView(@Nullable String viewName, @Nullable Map<String, ?> model, @Nullable HttpStatusCode status) {\n\t\tthis.view = viewName;\n\t\tif (model != null) {\n\t\t\tgetModelMap().addAllAttributes(model);\n\t\t}\n\t\tthis.status = status;\n\t}\n\n\t/**\n\t * Convenient constructor to take a single model object.\n\t * @param viewName name of the View to render, to be resolved\n\t * by the DispatcherServlet's ViewResolver\n\t * @param modelName name of the single entry in the model\n\t * @param modelObject the single model object\n\t */\n\tpublic ModelAndView(String viewName, String modelName, Object modelObject) {\n\t\tthis.view = viewName;\n\t\taddObject(modelName, modelObject);\n\t}\n\n\t/**\n\t * Convenient constructor to take a single model object.\n\t * @param view the View object to render\n\t * @param modelName name of the single entry in the model\n\t * @param modelObject the single model object\n\t */\n\tpublic ModelAndView(View view, String modelName, Object modelObject) {\n\t\tthis.view = view;\n\t\taddObject(modelName, modelObject);\n\t}\n\n\n\t/**\n\t * Set a view name for this ModelAndView, to be resolved by the\n\t * DispatcherServlet via a ViewResolver. Will override any\n\t * pre-existing view name or View.\n\t */\n\tpublic void setViewName(@Nullable String viewName) {\n\t\tthis.view = viewName;\n\t}\n\n\t/**\n\t * Return the view name to be resolved by the DispatcherServlet\n\t * via a ViewResolver, or {@code null} if we are using a View object.\n\t */\n\t@Nullable\n\tpublic String getViewName() {\n\t\treturn (this.view instanceof String name ? name : null);\n\t}\n\n\t/**\n\t * Set a View object for this ModelAndView. Will override any\n\t * pre-existing view name or View.\n\t */\n\tpublic void setView(@Nullable View view) {\n\t\tthis.view = view;\n\t}\n\n\t/**\n\t * Return the View object, or {@code null} if we are using a view name\n\t * to be resolved by the DispatcherServlet via a ViewResolver.\n\t */\n\t@Nullable\n\tpublic View getView() {\n\t\treturn (this.view instanceof View v ? v : null);\n\t}\n\n\t/**\n\t * Indicate whether this {@code ModelAndView} has a view, either\n\t * as a view name or as a direct {@link View} instance.\n\t */\n\tpublic boolean hasView() {\n\t\treturn (this.view != null);\n\t}\n\n\t/**\n\t * Return whether we use a view reference, i.e. {@code true}\n\t * if the view has been specified via a name to be resolved by the\n\t * DispatcherServlet via a ViewResolver.\n\t */\n\tpublic boolean isReference() {\n\t\treturn (this.view instanceof String);\n\t}\n\n\t/**\n\t * Return the model map. May return {@code null}.\n\t * Called by DispatcherServlet for evaluation of the model.\n\t */\n\t@Nullable\n\tprotected Map<String, Object> getModelInternal() {\n\t\treturn this.model;\n\t}\n\n\t/**\n\t * Return the underlying {@code ModelMap} instance (never {@code null}).\n\t */\n\tpublic ModelMap getModelMap() {\n\t\tif (this.model == null) {\n\t\t\tthis.model = new ModelMap();\n\t\t}\n\t\treturn this.model;\n\t}\n\n\t/**\n\t * Return the model map. Never returns {@code null}.\n\t * To be called by application code for modifying the model.\n\t */\n\tpublic Map<String, Object> getModel() {\n\t\treturn getModelMap();\n\t}\n\n\t/**\n\t * Set the HTTP status to use for the response.\n\t * <p>The response status is set just prior to View rendering.\n\t * @since 4.3\n\t */\n\tpublic void setStatus(@Nullable HttpStatusCode status) {\n\t\tthis.status = status;\n\t}\n\n\t/**\n\t * Return the configured HTTP status for the response, if any.\n\t * @since 4.3\n\t */\n\t@Nullable\n\tpublic HttpStatusCode getStatus() {\n\t\treturn this.status;\n\t}\n\n\n\t/**\n\t * Add an attribute to the model.\n\t * @param attributeName name of the object to add to the model (never {@code null})\n\t * @param attributeValue object to add to the model (can be {@code null})\n\t * @see ModelMap#addAttribute(String, Object)\n\t * @see #getModelMap()\n\t */\n\tpublic ModelAndView addObject(String attributeName, @Nullable Object attributeValue) {\n\t\tgetModelMap().addAttribute(attributeName, attributeValue);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add an attribute to the model using parameter name generation.\n\t * @param attributeValue the object to add to the model (never {@code null})\n\t * @see ModelMap#addAttribute(Object)\n\t * @see #getModelMap()\n\t */\n\tpublic ModelAndView addObject(Object attributeValue) {\n\t\tgetModelMap().addAttribute(attributeValue);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add all attributes contained in the provided Map to the model.\n\t * @param modelMap a Map of attributeName &rarr; attributeValue pairs\n\t * @see ModelMap#addAllAttributes(Map)\n\t * @see #getModelMap()\n\t */\n\tpublic ModelAndView addAllObjects(@Nullable Map<String, ?> modelMap) {\n\t\tgetModelMap().addAllAttributes(modelMap);\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Clear the state of this ModelAndView object.\n\t * The object will be empty afterwards.\n\t * <p>Can be used to suppress rendering of a given ModelAndView object\n\t * in the {@code postHandle} method of a HandlerInterceptor.\n\t * @see #isEmpty()\n\t * @see HandlerInterceptor#postHandle\n\t */\n\tpublic void clear() {\n\t\tthis.view = null;\n\t\tthis.model = null;\n\t\tthis.cleared = true;\n\t}\n\n\t/**\n\t * Return whether this ModelAndView object is empty,\n\t * i.e. whether it does not hold any view and does not contain a model.\n\t */\n\tpublic boolean isEmpty() {\n\t\treturn (this.view == null && CollectionUtils.isEmpty(this.model));\n\t}\n\n\t/**\n\t * Return whether this ModelAndView object is empty as a result of a call to {@link #clear}\n\t * i.e. whether it does not hold any view and does not contain a model.\n\t * <p>Returns {@code false} if any additional state was added to the instance\n\t * <strong>after</strong> the call to {@link #clear}.\n\t * @see #clear()\n\t */\n\tpublic boolean wasCleared() {\n\t\treturn (this.cleared && isEmpty());\n\t}\n\n\n\t/**\n\t * Return diagnostic information about this model and view.\n\t */\n\t@Override\n\tpublic String toString() {\n\t\treturn \"ModelAndView [view=\" + formatView() + \"; model=\" + this.model + \"]\";\n\t}\n\n\tprivate String formatView() {\n\t\treturn isReference() ? \"\\\"\" + this.view + \"\\\"\" : \"[\" + this.view + \"]\";\n\t}\n\n}"
  },
  "org.springframework.web.servlet.ModelAndView#addAllObjects(Map<String,modelMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add all attributes contained in the provided Map to the model.\n\t * @param modelMap a Map of attributeName &rarr; attributeValue pairs\n\t * @see ModelMap#addAllAttributes(Map)\n\t * @see #getModelMap()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "modelMap"
    ],
    "position": {
      "column": 1,
      "line": 310
    },
    "return": "ModelAndView",
    "signature": "public ModelAndView addAllObjects(@Nullable Map<String, ?> modelMap)",
    "source_code": "\tpublic ModelAndView addAllObjects(@Nullable Map<String, ?> modelMap) {\n\t\tgetModelMap().addAllAttributes(modelMap);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.servlet.ModelAndView#addObject(attributeName,attributeValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attribute to the model.\n\t * @param attributeName name of the object to add to the model (never {@code null})\n\t * @param attributeValue object to add to the model (can be {@code null})\n\t * @see ModelMap#addAttribute(String, Object)\n\t * @see #getModelMap()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "attributeValue"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "ModelAndView",
    "signature": "public ModelAndView addObject(String attributeName, @Nullable Object attributeValue)",
    "source_code": "\tpublic ModelAndView addObject(String attributeName, @Nullable Object attributeValue) {\n\t\tgetModelMap().addAttribute(attributeName, attributeValue);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.servlet.ModelAndView#addObject(attributeValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attribute to the model using parameter name generation.\n\t * @param attributeValue the object to add to the model (never {@code null})\n\t * @see ModelMap#addAttribute(Object)\n\t * @see #getModelMap()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeValue"
    ],
    "position": {
      "column": 1,
      "line": 299
    },
    "return": "ModelAndView",
    "signature": "public ModelAndView addObject(Object attributeValue)",
    "source_code": "\tpublic ModelAndView addObject(Object attributeValue) {\n\t\tgetModelMap().addAttribute(attributeValue);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.servlet.ModelAndView#clear()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Clear the state of this ModelAndView object.\n\t * The object will be empty afterwards.\n\t * <p>Can be used to suppress rendering of a given ModelAndView object\n\t * in the {@code postHandle} method of a HandlerInterceptor.\n\t * @see #isEmpty()\n\t * @see HandlerInterceptor#postHandle\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 324
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\tpublic void clear() {\n\t\tthis.view = null;\n\t\tthis.model = null;\n\t\tthis.cleared = true;\n\t}"
  },
  "org.springframework.web.servlet.ModelAndView#getModel()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the model map. Never returns {@code null}.\n\t * To be called by application code for modifying the model.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "Object>",
    "signature": "public Object> getModel()",
    "source_code": "\tpublic Map<String, Object> getModel() {\n\t\treturn getModelMap();\n\t}"
  },
  "org.springframework.web.servlet.ModelAndView#getModelInternal()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the model map. May return {@code null}.\n\t * Called by DispatcherServlet for evaluation of the model.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "Object>",
    "signature": "protected Object> getModelInternal()",
    "source_code": "\tprotected Map<String, Object> getModelInternal() {\n\t\treturn this.model;\n\t}"
  },
  "org.springframework.web.servlet.ModelAndView#getModelMap()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the underlying {@code ModelMap} instance (never {@code null}).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 247
    },
    "return": "ModelMap",
    "signature": "public ModelMap getModelMap()",
    "source_code": "\tpublic ModelMap getModelMap() {\n\t\tif (this.model == null) {\n\t\t\tthis.model = new ModelMap();\n\t\t}\n\t\treturn this.model;\n\t}"
  },
  "org.springframework.web.servlet.ModelAndView#getStatus()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured HTTP status for the response, if any.\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "HttpStatusCode",
    "signature": "public HttpStatusCode getStatus()",
    "source_code": "\tpublic HttpStatusCode getStatus() {\n\t\treturn this.status;\n\t}"
  },
  "org.springframework.web.servlet.ModelAndView#getView()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the View object, or {@code null} if we are using a view name\n\t * to be resolved by the DispatcherServlet via a ViewResolver.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "View",
    "signature": "public View getView()",
    "source_code": "\tpublic View getView() {\n\t\treturn (this.view instanceof View v ? v : null);\n\t}"
  },
  "org.springframework.web.servlet.ModelAndView#getViewName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the view name to be resolved by the DispatcherServlet\n\t * via a ViewResolver, or {@code null} if we are using a View object.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 197
    },
    "return": "String",
    "signature": "public String getViewName()",
    "source_code": "\tpublic String getViewName() {\n\t\treturn (this.view instanceof String name ? name : null);\n\t}"
  },
  "org.springframework.web.servlet.ModelAndView#hasView()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Indicate whether this {@code ModelAndView} has a view, either\n\t * as a view name or as a direct {@link View} instance.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "boolean",
    "signature": "public boolean hasView()",
    "source_code": "\tpublic boolean hasView() {\n\t\treturn (this.view != null);\n\t}"
  },
  "org.springframework.web.servlet.ModelAndView#isEmpty()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether this ModelAndView object is empty,\n\t * i.e. whether it does not hold any view and does not contain a model.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "boolean",
    "signature": "public boolean isEmpty()",
    "source_code": "\tpublic boolean isEmpty() {\n\t\treturn (this.view == null && CollectionUtils.isEmpty(this.model));\n\t}"
  },
  "org.springframework.web.servlet.ModelAndView#isReference()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether we use a view reference, i.e. {@code true}\n\t * if the view has been specified via a name to be resolved by the\n\t * DispatcherServlet via a ViewResolver.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 231
    },
    "return": "boolean",
    "signature": "public boolean isReference()",
    "source_code": "\tpublic boolean isReference() {\n\t\treturn (this.view instanceof String);\n\t}"
  },
  "org.springframework.web.servlet.ModelAndView#setStatus(status)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the HTTP status to use for the response.\n\t * <p>The response status is set just prior to View rendering.\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "void",
    "signature": "public void setStatus(@Nullable HttpStatusCode status)",
    "source_code": "\tpublic void setStatus(@Nullable HttpStatusCode status) {\n\t\tthis.status = status;\n\t}"
  },
  "org.springframework.web.servlet.ModelAndView#setView(view)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a View object for this ModelAndView. Will override any\n\t * pre-existing view name or View.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "view"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "void",
    "signature": "public void setView(@Nullable View view)",
    "source_code": "\tpublic void setView(@Nullable View view) {\n\t\tthis.view = view;\n\t}"
  },
  "org.springframework.web.servlet.ModelAndView#setViewName(viewName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a view name for this ModelAndView, to be resolved by the\n\t * DispatcherServlet via a ViewResolver. Will override any\n\t * pre-existing view name or View.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "viewName"
    ],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "void",
    "signature": "public void setViewName(@Nullable String viewName)",
    "source_code": "\tpublic void setViewName(@Nullable String viewName) {\n\t\tthis.view = viewName;\n\t}"
  },
  "org.springframework.web.servlet.ModelAndView#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return diagnostic information about this model and view.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 354
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn \"ModelAndView [view=\" + formatView() + \"; model=\" + this.model + \"]\";\n\t}"
  },
  "org.springframework.web.servlet.ModelAndView#wasCleared()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether this ModelAndView object is empty as a result of a call to {@link #clear}\n\t * i.e. whether it does not hold any view and does not contain a model.\n\t * <p>Returns {@code false} if any additional state was added to the instance\n\t * <strong>after</strong> the call to {@link #clear}.\n\t * @see #clear()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 345
    },
    "return": "boolean",
    "signature": "public boolean wasCleared()",
    "source_code": "\tpublic boolean wasCleared() {\n\t\treturn (this.cleared && isEmpty());\n\t}"
  },
  "org.springframework.web.servlet.OUTPUT_FLASH_MAP_ATTRIBUTE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Name of request attribute that holds the \"output\" {@link FlashMap} with\n\t * attributes to save for a subsequent request.\n\t * @see org.springframework.web.servlet.support.RequestContextUtils#getOutputFlashMap(HttpServletRequest)\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 258
    },
    "signature": "public String OUTPUT_FLASH_MAP_ATTRIBUTE",
    "source_code": "\tpublic static final String OUTPUT_FLASH_MAP_ATTRIBUTE = DispatcherServlet.class.getName() + \".OUTPUT_FLASH_MAP\";",
    "type": "String"
  },
  "org.springframework.web.servlet.PAGE_NOT_FOUND_LOG_CATEGORY": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Log category to use when no mapped handler is found for a request. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 274
    },
    "signature": "public String PAGE_NOT_FOUND_LOG_CATEGORY",
    "source_code": "\tpublic static final String PAGE_NOT_FOUND_LOG_CATEGORY = \"org.springframework.web.servlet.PageNotFound\";",
    "type": "String"
  },
  "org.springframework.web.servlet.REQUEST_TO_VIEW_NAME_TRANSLATOR_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Well-known name for the RequestToViewNameTranslator object in the bean factory for this namespace.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "signature": "public String REQUEST_TO_VIEW_NAME_TRANSLATOR_BEAN_NAME",
    "source_code": "\tpublic static final String REQUEST_TO_VIEW_NAME_TRANSLATOR_BEAN_NAME = \"viewNameTranslator\";",
    "type": "String"
  },
  "org.springframework.web.servlet.THEME_RESOLVER_ATTRIBUTE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Request attribute to hold the current ThemeResolver, retrievable by views.\n\t * @see org.springframework.web.servlet.support.RequestContextUtils#getThemeResolver\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 236
    },
    "signature": "public String THEME_RESOLVER_ATTRIBUTE",
    "source_code": "\tpublic static final String THEME_RESOLVER_ATTRIBUTE = DispatcherServlet.class.getName() + \".THEME_RESOLVER\";",
    "type": "String"
  },
  "org.springframework.web.servlet.THEME_RESOLVER_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Well-known name for the ThemeResolver object in the bean factory for this namespace.\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "signature": "public String THEME_RESOLVER_BEAN_NAME",
    "source_code": "\tpublic static final String THEME_RESOLVER_BEAN_NAME = \"themeResolver\";",
    "type": "String"
  },
  "org.springframework.web.servlet.THEME_SOURCE_ATTRIBUTE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Request attribute to hold the current ThemeSource, retrievable by views.\n\t * @see org.springframework.web.servlet.support.RequestContextUtils#getThemeSource\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 244
    },
    "signature": "public String THEME_SOURCE_ATTRIBUTE",
    "source_code": "\tpublic static final String THEME_SOURCE_ATTRIBUTE = DispatcherServlet.class.getName() + \".THEME_SOURCE\";",
    "type": "String"
  },
  "org.springframework.web.servlet.VIEW_RESOLVER_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Well-known name for the ViewResolver object in the bean factory for this namespace.\n\t * Only used when \"detectAllViewResolvers\" is turned off.\n\t * @see #setDetectAllViewResolvers\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "signature": "public String VIEW_RESOLVER_BEAN_NAME",
    "source_code": "\tpublic static final String VIEW_RESOLVER_BEAN_NAME = \"viewResolver\";",
    "type": "String"
  },
  "org.springframework.web.servlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Request attribute to hold the current web application context.\n\t * Otherwise only the global web app context is obtainable by tags etc.\n\t * @see org.springframework.web.servlet.support.RequestContextUtils#findWebApplicationContext\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 222
    },
    "signature": "public String WEB_APPLICATION_CONTEXT_ATTRIBUTE",
    "source_code": "\tpublic static final String WEB_APPLICATION_CONTEXT_ATTRIBUTE = DispatcherServlet.class.getName() + \".CONTEXT\";",
    "type": "String"
  },
  "org.springframework.web.servlet.config.MvcNamespaceUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Convenience methods for use in MVC namespace BeanDefinitionParsers.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Brian Clozel\n * @author Marten Deinum\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "signature": "public class MvcNamespaceUtils",
    "source_code": "public abstract class MvcNamespaceUtils {\n\n\tprivate static final String BEAN_NAME_URL_HANDLER_MAPPING_BEAN_NAME =\n\t\t\tBeanNameUrlHandlerMapping.class.getName();\n\n\tprivate static final String SIMPLE_CONTROLLER_HANDLER_ADAPTER_BEAN_NAME =\n\t\t\tSimpleControllerHandlerAdapter.class.getName();\n\n\tprivate static final String HTTP_REQUEST_HANDLER_ADAPTER_BEAN_NAME =\n\t\t\tHttpRequestHandlerAdapter.class.getName();\n\n\tprivate static final String URL_PATH_HELPER_BEAN_NAME = \"mvcUrlPathHelper\";\n\n\tprivate static final String PATH_MATCHER_BEAN_NAME = \"mvcPathMatcher\";\n\n\tprivate static final String CORS_CONFIGURATION_BEAN_NAME = \"mvcCorsConfigurations\";\n\n\tprivate static final String HANDLER_MAPPING_INTROSPECTOR_BEAN_NAME = \"mvcHandlerMappingIntrospector\";\n\n\n\tpublic static void registerDefaultComponents(ParserContext context, @Nullable Object source) {\n\t\tregisterBeanNameUrlHandlerMapping(context, source);\n\t\tregisterHttpRequestHandlerAdapter(context, source);\n\t\tregisterSimpleControllerHandlerAdapter(context, source);\n\t\tregisterHandlerMappingIntrospector(context, source);\n\t\tregisterLocaleResolver(context, source);\n\t\tregisterThemeResolver(context, source);\n\t\tregisterViewNameTranslator(context, source);\n\t\tregisterFlashMapManager(context, source);\n\t}\n\n\t/**\n\t * Adds an alias to an existing well-known name or registers a new instance of a {@link UrlPathHelper}\n\t * under that well-known name, unless already registered.\n\t * @return a RuntimeBeanReference to this {@link UrlPathHelper} instance\n\t */\n\tpublic static RuntimeBeanReference registerUrlPathHelper(\n\t\t\t@Nullable RuntimeBeanReference urlPathHelperRef, ParserContext context, @Nullable Object source) {\n\n\t\tif (urlPathHelperRef != null) {\n\t\t\tif (context.getRegistry().isAlias(URL_PATH_HELPER_BEAN_NAME)) {\n\t\t\t\tcontext.getRegistry().removeAlias(URL_PATH_HELPER_BEAN_NAME);\n\t\t\t}\n\t\t\tcontext.getRegistry().registerAlias(urlPathHelperRef.getBeanName(), URL_PATH_HELPER_BEAN_NAME);\n\t\t}\n\t\telse if (!context.getRegistry().isAlias(URL_PATH_HELPER_BEAN_NAME) &&\n\t\t\t\t!context.getRegistry().containsBeanDefinition(URL_PATH_HELPER_BEAN_NAME)) {\n\t\t\tRootBeanDefinition urlPathHelperDef = new RootBeanDefinition(UrlPathHelper.class);\n\t\t\turlPathHelperDef.setSource(source);\n\t\t\turlPathHelperDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\t\tcontext.getRegistry().registerBeanDefinition(URL_PATH_HELPER_BEAN_NAME, urlPathHelperDef);\n\t\t\tcontext.registerComponent(new BeanComponentDefinition(urlPathHelperDef, URL_PATH_HELPER_BEAN_NAME));\n\t\t}\n\t\treturn new RuntimeBeanReference(URL_PATH_HELPER_BEAN_NAME);\n\t}\n\n\t/**\n\t * Adds an alias to an existing well-known name or registers a new instance of a {@link PathMatcher}\n\t * under that well-known name, unless already registered.\n\t * @return a RuntimeBeanReference to this {@link PathMatcher} instance\n\t */\n\tpublic static RuntimeBeanReference registerPathMatcher(@Nullable RuntimeBeanReference pathMatcherRef,\n\t\t\tParserContext context, @Nullable Object source) {\n\n\t\tif (pathMatcherRef != null) {\n\t\t\tif (context.getRegistry().isAlias(PATH_MATCHER_BEAN_NAME)) {\n\t\t\t\tcontext.getRegistry().removeAlias(PATH_MATCHER_BEAN_NAME);\n\t\t\t}\n\t\t\tcontext.getRegistry().registerAlias(pathMatcherRef.getBeanName(), PATH_MATCHER_BEAN_NAME);\n\t\t}\n\t\telse if (!context.getRegistry().isAlias(PATH_MATCHER_BEAN_NAME) &&\n\t\t\t\t!context.getRegistry().containsBeanDefinition(PATH_MATCHER_BEAN_NAME)) {\n\t\t\tRootBeanDefinition pathMatcherDef = new RootBeanDefinition(AntPathMatcher.class);\n\t\t\tpathMatcherDef.setSource(source);\n\t\t\tpathMatcherDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\t\tcontext.getRegistry().registerBeanDefinition(PATH_MATCHER_BEAN_NAME, pathMatcherDef);\n\t\t\tcontext.registerComponent(new BeanComponentDefinition(pathMatcherDef, PATH_MATCHER_BEAN_NAME));\n\t\t}\n\t\treturn new RuntimeBeanReference(PATH_MATCHER_BEAN_NAME);\n\t}\n\n\t/**\n\t * Registers  an {@link HttpRequestHandlerAdapter} under a well-known\n\t * name unless already registered.\n\t */\n\tprivate static void registerBeanNameUrlHandlerMapping(ParserContext context, @Nullable Object source) {\n\t\tif (!context.getRegistry().containsBeanDefinition(BEAN_NAME_URL_HANDLER_MAPPING_BEAN_NAME)) {\n\t\t\tRootBeanDefinition mappingDef = new RootBeanDefinition(BeanNameUrlHandlerMapping.class);\n\t\t\tmappingDef.setSource(source);\n\t\t\tmappingDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\t\tmappingDef.getPropertyValues().add(\"order\", 2);\t// consistent with WebMvcConfigurationSupport\n\t\t\tRuntimeBeanReference corsRef = MvcNamespaceUtils.registerCorsConfigurations(null, context, source);\n\t\t\tmappingDef.getPropertyValues().add(\"corsConfigurations\", corsRef);\n\t\t\tcontext.getRegistry().registerBeanDefinition(BEAN_NAME_URL_HANDLER_MAPPING_BEAN_NAME, mappingDef);\n\t\t\tcontext.registerComponent(new BeanComponentDefinition(mappingDef, BEAN_NAME_URL_HANDLER_MAPPING_BEAN_NAME));\n\t\t}\n\t}\n\n\t/**\n\t * Registers  an {@link HttpRequestHandlerAdapter} under a well-known\n\t * name unless already registered.\n\t */\n\tprivate static void registerHttpRequestHandlerAdapter(ParserContext context, @Nullable Object source) {\n\t\tif (!context.getRegistry().containsBeanDefinition(HTTP_REQUEST_HANDLER_ADAPTER_BEAN_NAME)) {\n\t\t\tRootBeanDefinition adapterDef = new RootBeanDefinition(HttpRequestHandlerAdapter.class);\n\t\t\tadapterDef.setSource(source);\n\t\t\tadapterDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\t\tcontext.getRegistry().registerBeanDefinition(HTTP_REQUEST_HANDLER_ADAPTER_BEAN_NAME, adapterDef);\n\t\t\tcontext.registerComponent(new BeanComponentDefinition(adapterDef, HTTP_REQUEST_HANDLER_ADAPTER_BEAN_NAME));\n\t\t}\n\t}\n\n\t/**\n\t * Registers a {@link SimpleControllerHandlerAdapter} under a well-known\n\t * name unless already registered.\n\t */\n\tprivate static void registerSimpleControllerHandlerAdapter(ParserContext context, @Nullable Object source) {\n\t\tif (!context.getRegistry().containsBeanDefinition(SIMPLE_CONTROLLER_HANDLER_ADAPTER_BEAN_NAME)) {\n\t\t\tRootBeanDefinition beanDef = new RootBeanDefinition(SimpleControllerHandlerAdapter.class);\n\t\t\tbeanDef.setSource(source);\n\t\t\tbeanDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\t\tcontext.getRegistry().registerBeanDefinition(SIMPLE_CONTROLLER_HANDLER_ADAPTER_BEAN_NAME, beanDef);\n\t\t\tcontext.registerComponent(new BeanComponentDefinition(beanDef, SIMPLE_CONTROLLER_HANDLER_ADAPTER_BEAN_NAME));\n\t\t}\n\t}\n\n\t/**\n\t * Registers a {@code Map<String, CorsConfiguration>} (mapped {@code CorsConfiguration}s)\n\t * under a well-known name unless already registered. The bean definition may be updated\n\t * if a non-null CORS configuration is provided.\n\t * @return a RuntimeBeanReference to this {@code Map<String, CorsConfiguration>} instance\n\t */\n\tpublic static RuntimeBeanReference registerCorsConfigurations(\n\t\t\t@Nullable Map<String, CorsConfiguration> corsConfigurations,\n\t\t\tParserContext context, @Nullable Object source) {\n\n\t\tif (!context.getRegistry().containsBeanDefinition(CORS_CONFIGURATION_BEAN_NAME)) {\n\t\t\tRootBeanDefinition corsDef = new RootBeanDefinition(LinkedHashMap.class);\n\t\t\tcorsDef.setSource(source);\n\t\t\tcorsDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\t\tif (corsConfigurations != null) {\n\t\t\t\tcorsDef.getConstructorArgumentValues().addIndexedArgumentValue(0, corsConfigurations);\n\t\t\t}\n\t\t\tcontext.getReaderContext().getRegistry().registerBeanDefinition(CORS_CONFIGURATION_BEAN_NAME, corsDef);\n\t\t\tcontext.registerComponent(new BeanComponentDefinition(corsDef, CORS_CONFIGURATION_BEAN_NAME));\n\t\t}\n\t\telse if (corsConfigurations != null) {\n\t\t\tBeanDefinition corsDef = context.getRegistry().getBeanDefinition(CORS_CONFIGURATION_BEAN_NAME);\n\t\t\tcorsDef.getConstructorArgumentValues().addIndexedArgumentValue(0, corsConfigurations);\n\t\t}\n\t\treturn new RuntimeBeanReference(CORS_CONFIGURATION_BEAN_NAME);\n\t}\n\n\t/**\n\t * Registers  an {@link HandlerMappingIntrospector} under a well-known name\n\t * unless already registered.\n\t */\n\tprivate static void registerHandlerMappingIntrospector(ParserContext context, @Nullable Object source) {\n\t\tif (!context.getRegistry().containsBeanDefinition(HANDLER_MAPPING_INTROSPECTOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition beanDef = new RootBeanDefinition(HandlerMappingIntrospector.class);\n\t\t\tbeanDef.setSource(source);\n\t\t\tbeanDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\t\tbeanDef.setLazyInit(true);\n\t\t\tcontext.getRegistry().registerBeanDefinition(HANDLER_MAPPING_INTROSPECTOR_BEAN_NAME, beanDef);\n\t\t\tcontext.registerComponent(new BeanComponentDefinition(beanDef, HANDLER_MAPPING_INTROSPECTOR_BEAN_NAME));\n\t\t}\n\t}\n\n\t/**\n\t * Registers an {@link AcceptHeaderLocaleResolver} under a well-known name\n\t * unless already registered.\n\t */\n\tprivate static void registerLocaleResolver(ParserContext context, @Nullable Object source) {\n\t\tif (!containsBeanInHierarchy(context, DispatcherServlet.LOCALE_RESOLVER_BEAN_NAME)) {\n\t\t\tRootBeanDefinition beanDef = new RootBeanDefinition(AcceptHeaderLocaleResolver.class);\n\t\t\tbeanDef.setSource(source);\n\t\t\tbeanDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\t\tcontext.getRegistry().registerBeanDefinition(DispatcherServlet.LOCALE_RESOLVER_BEAN_NAME, beanDef);\n\t\t\tcontext.registerComponent(new BeanComponentDefinition(beanDef, DispatcherServlet.LOCALE_RESOLVER_BEAN_NAME));\n\t\t}\n\t}\n\n\t/**\n\t * Registers an {@link org.springframework.web.servlet.theme.FixedThemeResolver}\n\t * under a well-known name unless already registered.\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\tprivate static void registerThemeResolver(ParserContext context, @Nullable Object source) {\n\t\tif (!containsBeanInHierarchy(context, DispatcherServlet.THEME_RESOLVER_BEAN_NAME)) {\n\t\t\tRootBeanDefinition beanDef = new RootBeanDefinition(org.springframework.web.servlet.theme.FixedThemeResolver.class);\n\t\t\tbeanDef.setSource(source);\n\t\t\tbeanDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\t\tcontext.getRegistry().registerBeanDefinition(DispatcherServlet.THEME_RESOLVER_BEAN_NAME, beanDef);\n\t\t\tcontext.registerComponent(new BeanComponentDefinition(beanDef, DispatcherServlet.THEME_RESOLVER_BEAN_NAME));\n\t\t}\n\t}\n\n\t/**\n\t * Registers an {@link DefaultRequestToViewNameTranslator} under a well-known name\n\t * unless already registered.\n\t */\n\tprivate static void registerViewNameTranslator(ParserContext context, @Nullable Object source) {\n\t\tif (!containsBeanInHierarchy(context, DispatcherServlet.REQUEST_TO_VIEW_NAME_TRANSLATOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition beanDef = new RootBeanDefinition(DefaultRequestToViewNameTranslator.class);\n\t\t\tbeanDef.setSource(source);\n\t\t\tbeanDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\t\tcontext.getRegistry().registerBeanDefinition(\n\t\t\t\t\tDispatcherServlet.REQUEST_TO_VIEW_NAME_TRANSLATOR_BEAN_NAME, beanDef);\n\t\t\tcontext.registerComponent(\n\t\t\t\t\tnew BeanComponentDefinition(beanDef, DispatcherServlet.REQUEST_TO_VIEW_NAME_TRANSLATOR_BEAN_NAME));\n\t\t}\n\t}\n\n\t/**\n\t * Registers an {@link SessionFlashMapManager} under a well-known name\n\t * unless already registered.\n\t */\n\tprivate static void registerFlashMapManager(ParserContext context, @Nullable Object source) {\n\t\tif (!containsBeanInHierarchy(context, DispatcherServlet.FLASH_MAP_MANAGER_BEAN_NAME)) {\n\t\t\tRootBeanDefinition beanDef = new RootBeanDefinition(SessionFlashMapManager.class);\n\t\t\tbeanDef.setSource(source);\n\t\t\tbeanDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\t\tcontext.getRegistry().registerBeanDefinition(DispatcherServlet.FLASH_MAP_MANAGER_BEAN_NAME, beanDef);\n\t\t\tcontext.registerComponent(new BeanComponentDefinition(beanDef, DispatcherServlet.FLASH_MAP_MANAGER_BEAN_NAME));\n\t\t}\n\t}\n\n\t/**\n\t * Find the {@code ContentNegotiationManager} bean created by or registered\n\t * with the {@code annotation-driven} element.\n\t * @return a bean definition, bean reference, or {@code null} if none defined\n\t */\n\t@Nullable\n\tpublic static Object getContentNegotiationManager(ParserContext context) {\n\t\tString name = AnnotationDrivenBeanDefinitionParser.HANDLER_MAPPING_BEAN_NAME;\n\t\tif (context.getRegistry().containsBeanDefinition(name)) {\n\t\t\tBeanDefinition handlerMappingBeanDef = context.getRegistry().getBeanDefinition(name);\n\t\t\treturn handlerMappingBeanDef.getPropertyValues().get(\"contentNegotiationManager\");\n\t\t}\n\t\tname = AnnotationDrivenBeanDefinitionParser.CONTENT_NEGOTIATION_MANAGER_BEAN_NAME;\n\t\tif (context.getRegistry().containsBeanDefinition(name)) {\n\t\t\treturn new RuntimeBeanReference(name);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Check for an existing bean of the given name, ideally in the entire\n\t * context hierarchy (through a {@code containsBean} call) since this\n\t * is also what {@code DispatcherServlet} does, or otherwise just in\n\t * the local context (through {@code containsBeanDefinition}).\n\t */\n\tprivate static boolean containsBeanInHierarchy(ParserContext context, String beanName) {\n\t\tBeanDefinitionRegistry registry = context.getRegistry();\n\t\treturn (registry instanceof BeanFactory beanFactory ? beanFactory.containsBean(beanName) :\n\t\t\t\tregistry.containsBeanDefinition(beanName));\n\t}\n\n}"
  },
  "org.springframework.web.servlet.config.MvcNamespaceUtils#getContentNegotiationManager(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the {@code ContentNegotiationManager} bean created by or registered\n\t * with the {@code annotation-driven} element.\n\t * @return a bean definition, bean reference, or {@code null} if none defined\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 285
    },
    "return": "Object",
    "signature": "public Object getContentNegotiationManager(ParserContext context)",
    "source_code": "\tpublic static Object getContentNegotiationManager(ParserContext context) {\n\t\tString name = AnnotationDrivenBeanDefinitionParser.HANDLER_MAPPING_BEAN_NAME;\n\t\tif (context.getRegistry().containsBeanDefinition(name)) {\n\t\t\tBeanDefinition handlerMappingBeanDef = context.getRegistry().getBeanDefinition(name);\n\t\t\treturn handlerMappingBeanDef.getPropertyValues().get(\"contentNegotiationManager\");\n\t\t}\n\t\tname = AnnotationDrivenBeanDefinitionParser.CONTENT_NEGOTIATION_MANAGER_BEAN_NAME;\n\t\tif (context.getRegistry().containsBeanDefinition(name)) {\n\t\t\treturn new RuntimeBeanReference(name);\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.config.MvcNamespaceUtils#registerCorsConfigurations(Map<String,corsConfigurations,context,source)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Registers a {@code Map<String, CorsConfiguration>} (mapped {@code CorsConfiguration}s)\n\t * under a well-known name unless already registered. The bean definition may be updated\n\t * if a non-null CORS configuration is provided.\n\t * @return a RuntimeBeanReference to this {@code Map<String, CorsConfiguration>} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "corsConfigurations",
      "context",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "RuntimeBeanReference",
    "signature": "public RuntimeBeanReference registerCorsConfigurations(@Nullable Map<String, CorsConfiguration> corsConfigurations,\n\t\t\tParserContext context, @Nullable Object source)",
    "source_code": "\tpublic static RuntimeBeanReference registerCorsConfigurations("
  },
  "org.springframework.web.servlet.config.MvcNamespaceUtils#registerDefaultComponents(context,source)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "void",
    "signature": "public void registerDefaultComponents(ParserContext context, @Nullable Object source)",
    "source_code": "\tpublic static void registerDefaultComponents(ParserContext context, @Nullable Object source) {\n\t\tregisterBeanNameUrlHandlerMapping(context, source);\n\t\tregisterHttpRequestHandlerAdapter(context, source);\n\t\tregisterSimpleControllerHandlerAdapter(context, source);\n\t\tregisterHandlerMappingIntrospector(context, source);\n\t\tregisterLocaleResolver(context, source);\n\t\tregisterThemeResolver(context, source);\n\t\tregisterViewNameTranslator(context, source);\n\t\tregisterFlashMapManager(context, source);\n\t}"
  },
  "org.springframework.web.servlet.config.MvcNamespaceUtils#registerPathMatcher(pathMatcherRef,context,source)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Adds an alias to an existing well-known name or registers a new instance of a {@link PathMatcher}\n\t * under that well-known name, unless already registered.\n\t * @return a RuntimeBeanReference to this {@link PathMatcher} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pathMatcherRef",
      "context",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "RuntimeBeanReference",
    "signature": "public RuntimeBeanReference registerPathMatcher(@Nullable RuntimeBeanReference pathMatcherRef,\n\t\t\tParserContext context, @Nullable Object source)",
    "source_code": "\tpublic static RuntimeBeanReference registerPathMatcher(@Nullable RuntimeBeanReference pathMatcherRef,"
  },
  "org.springframework.web.servlet.config.MvcNamespaceUtils#registerUrlPathHelper(urlPathHelperRef,context,source)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Adds an alias to an existing well-known name or registers a new instance of a {@link UrlPathHelper}\n\t * under that well-known name, unless already registered.\n\t * @return a RuntimeBeanReference to this {@link UrlPathHelper} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "urlPathHelperRef",
      "context",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "RuntimeBeanReference",
    "signature": "public RuntimeBeanReference registerUrlPathHelper(@Nullable RuntimeBeanReference urlPathHelperRef, ParserContext context, @Nullable Object source)",
    "source_code": "\tpublic static RuntimeBeanReference registerUrlPathHelper("
  },
  "org.springframework.web.servlet.config.annotation.InterceptorRegistry": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Helps with configuring a list of mapped interceptors.\n *\n * @author Rossen Stoyanchev\n * @author Keith Donald\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 36
    },
    "signature": "public class InterceptorRegistry",
    "source_code": "public class InterceptorRegistry {\n\n\tprivate final List<InterceptorRegistration> registrations = new ArrayList<>();\n\n\n\t/**\n\t * Adds the provided {@link HandlerInterceptor}.\n\t * @param interceptor the interceptor to add\n\t * @return an {@link InterceptorRegistration} that allows you optionally configure the\n\t * registered interceptor further for example adding URL patterns it should apply to.\n\t */\n\tpublic InterceptorRegistration addInterceptor(HandlerInterceptor interceptor) {\n\t\tInterceptorRegistration registration = new InterceptorRegistration(interceptor);\n\t\tthis.registrations.add(registration);\n\t\treturn registration;\n\t}\n\n\t/**\n\t * Adds the provided {@link WebRequestInterceptor}.\n\t * @param interceptor the interceptor to add\n\t * @return an {@link InterceptorRegistration} that allows you optionally configure the\n\t * registered interceptor further for example adding URL patterns it should apply to.\n\t */\n\tpublic InterceptorRegistration addWebRequestInterceptor(WebRequestInterceptor interceptor) {\n\t\tWebRequestHandlerInterceptorAdapter adapted = new WebRequestHandlerInterceptorAdapter(interceptor);\n\t\tInterceptorRegistration registration = new InterceptorRegistration(adapted);\n\t\tthis.registrations.add(registration);\n\t\treturn registration;\n\t}\n\n\t/**\n\t * Return all registered interceptors.\n\t */\n\tprotected List<Object> getInterceptors() {\n\t\treturn this.registrations.stream()\n\t\t\t\t.sorted(INTERCEPTOR_ORDER_COMPARATOR)\n\t\t\t\t.map(InterceptorRegistration::getInterceptor)\n\t\t\t\t.toList();\n\t}\n\n\n\tprivate static final Comparator<Object> INTERCEPTOR_ORDER_COMPARATOR =\n\t\t\tOrderComparator.INSTANCE.withSourceProvider(object -> {\n\t\t\t\tif (object instanceof InterceptorRegistration interceptorRegistration) {\n\t\t\t\t\treturn (Ordered) interceptorRegistration::getOrder;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t});\n\n}"
  },
  "org.springframework.web.servlet.config.annotation.InterceptorRegistry#addInterceptor(interceptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Adds the provided {@link HandlerInterceptor}.\n\t * @param interceptor the interceptor to add\n\t * @return an {@link InterceptorRegistration} that allows you optionally configure the\n\t * registered interceptor further for example adding URL patterns it should apply to.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "interceptor"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "return": "InterceptorRegistration",
    "signature": "public InterceptorRegistration addInterceptor(HandlerInterceptor interceptor)",
    "source_code": "\tpublic InterceptorRegistration addInterceptor(HandlerInterceptor interceptor) {\n\t\tInterceptorRegistration registration = new InterceptorRegistration(interceptor);\n\t\tthis.registrations.add(registration);\n\t\treturn registration;\n\t}"
  },
  "org.springframework.web.servlet.config.annotation.InterceptorRegistry#addWebRequestInterceptor(interceptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Adds the provided {@link WebRequestInterceptor}.\n\t * @param interceptor the interceptor to add\n\t * @return an {@link InterceptorRegistration} that allows you optionally configure the\n\t * registered interceptor further for example adding URL patterns it should apply to.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "interceptor"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "InterceptorRegistration",
    "signature": "public InterceptorRegistration addWebRequestInterceptor(WebRequestInterceptor interceptor)",
    "source_code": "\tpublic InterceptorRegistration addWebRequestInterceptor(WebRequestInterceptor interceptor) {\n\t\tWebRequestHandlerInterceptorAdapter adapted = new WebRequestHandlerInterceptorAdapter(interceptor);\n\t\tInterceptorRegistration registration = new InterceptorRegistration(adapted);\n\t\tthis.registrations.add(registration);\n\t\treturn registration;\n\t}"
  },
  "org.springframework.web.servlet.config.annotation.InterceptorRegistry#getInterceptors()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return all registered interceptors.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "List<Object>",
    "signature": "protected List<Object> getInterceptors()",
    "source_code": "\tprotected List<Object> getInterceptors() {\n\t\treturn this.registrations.stream()\n\t\t\t\t.sorted(INTERCEPTOR_ORDER_COMPARATOR)\n\t\t\t\t.map(InterceptorRegistration::getInterceptor)\n\t\t\t\t.toList();\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#addErrorHandler(predicate,BiFunction<Throwable,ServerRequest,errorHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "predicate",
      "BiFunction<Throwable",
      "ServerRequest",
      "errorHandler"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "return": "void",
    "signature": "protected void addErrorHandler(Predicate<Throwable> predicate,\n\t\t\tBiFunction<Throwable, ServerRequest, T> errorHandler)",
    "source_code": "\tprotected final <T extends ServerResponse> void addErrorHandler(Predicate<Throwable> predicate,"
  },
  "org.springframework.web.servlet.function.<unknown>#apply(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "Optional<Resource>",
    "signature": "public Optional<Resource> apply(ServerRequest request)",
    "source_code": "\tpublic Optional<Resource> apply(ServerRequest request) {\n\t\tPathContainer pathContainer = request.requestPath().pathWithinApplication();\n\t\tif (!this.pattern.matches(pathContainer)) {\n\t\t\treturn Optional.empty();\n\t\t}\n\n\t\tpathContainer = this.pattern.extractPathWithinPattern(pathContainer);\n\t\tString path = processPath(pathContainer.value());\n\t\tif (path.contains(\"%\")) {\n\t\t\tpath = StringUtils.uriDecode(path, StandardCharsets.UTF_8);\n\t\t}\n\t\tif (!StringUtils.hasLength(path) || isInvalidPath(path)) {\n\t\t\treturn Optional.empty();\n\t\t}\n\n\t\ttry {\n\t\t\tResource resource = this.location.createRelative(path);\n\t\t\tif (resource.isReadable() && isResourceUnderLocation(resource)) {\n\t\t\t\treturn Optional.of(resource);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn Optional.empty();\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new UncheckedIOException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#available()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 424
    },
    "return": "int",
    "signature": "public int available()",
    "source_code": "\t\tpublic int available() throws IOException {\n\t\t\treturn this.delegate.available();\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#block()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "ServerResponse",
    "signature": "public ServerResponse block()",
    "source_code": "\tpublic ServerResponse block() {\n\t\ttry {\n\t\t\tif (this.timeout != null) {\n\t\t\t\treturn this.futureResponse.get(this.timeout.toMillis(), TimeUnit.MILLISECONDS);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn this.futureResponse.get();\n\t\t\t}\n\t\t}\n\t\tcatch (InterruptedException | ExecutionException | TimeoutException ex) {\n\t\t\tthrow new IllegalStateException(\"Failed to get future response\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#build()": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "ServerRequest",
    "signature": "public ServerRequest build()",
    "source_code": "\tpublic ServerRequest build() {\n\t\treturn new BuiltServerRequest(this.servletRequest, this.method, this.uri, this.headers, this.cookies,\n\t\t\t\tthis.attributes, this.params, this.remoteAddress, this.body, this.messageConverters);\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#close()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\t\tpublic void close() throws IOException {\n\t\t\tthis.delegate.close();\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#comment(comment)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "comment"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "SseBuilder",
    "signature": "public SseBuilder comment(String comment)",
    "source_code": "\t\tpublic SseBuilder comment(String comment) {\n\t\t\tAssert.hasLength(comment, \"Comment must not be empty\");\n\t\t\tString[] lines = comment.split(\"\\n\");\n\t\t\tfor (String line : lines) {\n\t\t\t\tfield(\"\", line);\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#complete()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "void",
    "signature": "public void complete()",
    "source_code": "\t\tpublic void complete() {\n\t\t\tif (this.sendFailed) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tthis.outputMessage.flush();\n\t\t\t\tthis.deferredResult.setResult(null);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthis.deferredResult.setErrorResult(ex);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#create(obj,timeout)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "AsyncServerResponse",
    "signature": "public AsyncServerResponse create(Object obj, @Nullable Duration timeout)",
    "source_code": "\tpublic static AsyncServerResponse create(Object obj, @Nullable Duration timeout) {\n\t\tAssert.notNull(obj, \"Argument to async must not be null\");\n\n\t\tif (obj instanceof CompletableFuture futureResponse) {\n\t\t\treturn new DefaultAsyncServerResponse(futureResponse, timeout);\n\t\t}\n\t\telse if (reactiveStreamsPresent) {\n\t\t\tReactiveAdapterRegistry registry = ReactiveAdapterRegistry.getSharedInstance();\n\t\t\tReactiveAdapter publisherAdapter = registry.getAdapter(obj.getClass());\n\t\t\tif (publisherAdapter != null) {\n\t\t\t\tPublisher<ServerResponse> publisher = publisherAdapter.toPublisher(obj);\n\t\t\t\tReactiveAdapter futureAdapter = registry.getAdapter(CompletableFuture.class);\n\t\t\t\tif (futureAdapter != null) {\n\t\t\t\t\tCompletableFuture<ServerResponse> futureResponse =\n\t\t\t\t\t\t\t(CompletableFuture<ServerResponse>) futureAdapter.fromPublisher(publisher);\n\t\t\t\t\treturn new DefaultAsyncServerResponse(futureResponse, timeout);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Asynchronous type not supported: \" + obj.getClass());\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#create(sseConsumer,timeout)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sseConsumer",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "ServerResponse",
    "signature": "public ServerResponse create(Consumer<SseBuilder> sseConsumer, @Nullable Duration timeout)",
    "source_code": "\tpublic static ServerResponse create(Consumer<SseBuilder> sseConsumer, @Nullable Duration timeout) {\n\t\tAssert.notNull(sseConsumer, \"SseConsumer must not be null\");\n\n\t\treturn new SseServerResponse(sseConsumer, timeout);\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#data(object)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "void",
    "signature": "public void data(Object object)",
    "source_code": "\t\tpublic void data(Object object) throws IOException {\n\t\t\tAssert.notNull(object, \"Object must not be null\");\n\n\t\t\tif (object instanceof String text) {\n\t\t\t\twriteString(text);\n\t\t\t}\n\t\t\telse {\n\t\t\t\twriteObject(object);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#error(t)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "t"
    ],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "void",
    "signature": "public void error(Throwable t)",
    "source_code": "\t\tpublic void error(Throwable t) {\n\t\t\tif (this.sendFailed) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.deferredResult.setErrorResult(t);\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#errorResponse(t,servletRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "t",
      "servletRequest"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "ServerResponse",
    "signature": "protected ServerResponse errorResponse(Throwable t, HttpServletRequest servletRequest)",
    "source_code": "\tprotected final ServerResponse errorResponse(Throwable t, HttpServletRequest servletRequest) {\n\t\tfor (ErrorHandler<?> errorHandler : this.errorHandlers) {\n\t\t\tif (errorHandler.test(t)) {\n\t\t\t\tServerRequest serverRequest = (ServerRequest)\n\t\t\t\t\t\tservletRequest.getAttribute(RouterFunctions.REQUEST_ATTRIBUTE);\n\t\t\t\treturn errorHandler.handle(t, serverRequest);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#event(eventName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "eventName"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "SseBuilder",
    "signature": "public SseBuilder event(String eventName)",
    "source_code": "\t\tpublic SseBuilder event(String eventName) {\n\t\t\tAssert.hasLength(eventName, \"Name must not be empty\");\n\t\t\treturn field(\"event\", eventName);\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#getBody()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 368
    },
    "return": "InputStream",
    "signature": "public InputStream getBody()",
    "source_code": "\t\t\tpublic InputStream getBody() throws IOException {\n\t\t\t\treturn new BodyInputStream(body);\n\t\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#getHeaders()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 373
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders getHeaders()",
    "source_code": "\t\t\tpublic HttpHeaders getHeaders() {\n\t\t\t\treturn headers;\n\t\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#handle(t,serverRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "t",
      "serverRequest"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "T",
    "signature": "public T handle(Throwable t, ServerRequest serverRequest)",
    "source_code": "\t\tpublic T handle(Throwable t, ServerRequest serverRequest) {\n\t\t\treturn this.responseProvider.apply(t, serverRequest);\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#handleError(t,servletRequest,servletResponse,context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "t",
      "servletRequest",
      "servletResponse",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleError(Throwable t, HttpServletRequest servletRequest,\n\t\t\tHttpServletResponse servletResponse, Context context)",
    "source_code": "\tprotected final ModelAndView handleError(Throwable t, HttpServletRequest servletRequest,"
  },
  "org.springframework.web.servlet.function.<unknown>#id(id)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "id"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "SseBuilder",
    "signature": "public SseBuilder id(String id)",
    "source_code": "\t\tpublic SseBuilder id(String id) {\n\t\t\tAssert.hasLength(id, \"Id must not be empty\");\n\t\t\treturn field(\"id\", id);\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#isFinished()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 389
    },
    "return": "boolean",
    "signature": "public boolean isFinished()",
    "source_code": "\t\tpublic boolean isFinished() {\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#isReady()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 394
    },
    "return": "boolean",
    "signature": "public boolean isReady()",
    "source_code": "\t\tpublic boolean isReady() {\n\t\t\treturn true;\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#mark(readlimit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "readlimit"
    ],
    "position": {
      "column": 1,
      "line": 434
    },
    "return": "void",
    "signature": "public void mark(int readlimit)",
    "source_code": "\t\tpublic synchronized void mark(int readlimit) {\n\t\t\tthis.delegate.mark(readlimit);\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#markSupported()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 444
    },
    "return": "boolean",
    "signature": "public boolean markSupported()",
    "source_code": "\t\tpublic boolean markSupported() {\n\t\t\treturn this.delegate.markSupported();\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#onComplete(onCompletion)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "onCompletion"
    ],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "SseBuilder",
    "signature": "public SseBuilder onComplete(Runnable onCompletion)",
    "source_code": "\t\tpublic SseBuilder onComplete(Runnable onCompletion) {\n\t\t\tthis.deferredResult.onCompletion(onCompletion);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#onError(onError)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "onError"
    ],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "SseBuilder",
    "signature": "public SseBuilder onError(Consumer<Throwable> onError)",
    "source_code": "\t\tpublic SseBuilder onError(Consumer<Throwable> onError) {\n\t\t\tthis.deferredResult.onError(onError);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#onTimeout(onTimeout)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "onTimeout"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "SseBuilder",
    "signature": "public SseBuilder onTimeout(Runnable onTimeout)",
    "source_code": "\t\tpublic SseBuilder onTimeout(Runnable onTimeout) {\n\t\t\tthis.deferredResult.onTimeout(onTimeout);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#rawStatusCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "int",
    "signature": "public int rawStatusCode()",
    "source_code": "\tpublic int rawStatusCode() {\n\t\treturn delegate(ServerResponse::rawStatusCode);\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#read()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 404
    },
    "return": "int",
    "signature": "public int read()",
    "source_code": "\t\tpublic int read() throws IOException {\n\t\t\treturn this.delegate.read();\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#read(b)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b"
    ],
    "position": {
      "column": 1,
      "line": 414
    },
    "return": "int",
    "signature": "public int read(byte[] b)",
    "source_code": "\t\tpublic int read(byte[] b) throws IOException {\n\t\t\treturn this.delegate.read(b);\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#read(b,off,len)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b",
      "off",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 409
    },
    "return": "int",
    "signature": "public int read(byte[] b, int off, int len)",
    "source_code": "\t\tpublic int read(byte[] b, int off, int len) throws IOException {\n\t\t\treturn this.delegate.read(b, off, len);\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#retry(duration)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "duration"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "SseBuilder",
    "signature": "public SseBuilder retry(Duration duration)",
    "source_code": "\t\tpublic SseBuilder retry(Duration duration) {\n\t\t\tAssert.notNull(duration, \"Duration must not be null\");\n\t\t\tString millis = Long.toString(duration.toMillis());\n\t\t\treturn field(\"retry\", millis);\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#send(object)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "void",
    "signature": "public void send(Object object)",
    "source_code": "\t\tpublic void send(Object object) throws IOException {\n\t\t\tdata(object);\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#setReadListener(readListener)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "readListener"
    ],
    "position": {
      "column": 1,
      "line": 399
    },
    "return": "void",
    "signature": "public void setReadListener(ReadListener readListener)",
    "source_code": "\t\tpublic void setReadListener(ReadListener readListener) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#skip(n)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "n"
    ],
    "position": {
      "column": 1,
      "line": 419
    },
    "return": "long",
    "signature": "public long skip(long n)",
    "source_code": "\t\tpublic long skip(long n) throws IOException {\n\t\t\treturn this.delegate.skip(n);\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#statusCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "HttpStatusCode",
    "signature": "public HttpStatusCode statusCode()",
    "source_code": "\tpublic HttpStatusCode statusCode() {\n\t\treturn delegate(ServerResponse::statusCode);\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#test(t)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "t"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "boolean",
    "signature": "public boolean test(Throwable t)",
    "source_code": "\t\tpublic boolean test(Throwable t) {\n\t\t\treturn this.predicate.test(t);\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#writeTo(request,response,context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "ModelAndView",
    "signature": "public ModelAndView writeTo(HttpServletRequest request, HttpServletResponse response, Context context)",
    "source_code": "\tpublic ModelAndView writeTo(HttpServletRequest request, HttpServletResponse response, Context context)"
  },
  "org.springframework.web.servlet.function.HandlerFilterFunction": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Represents a function that filters a {@linkplain HandlerFunction handler function}.\n *\n * @author Arjen Poutsma\n * @since 5.2\n * @param <T> the type of the {@linkplain HandlerFunction handler function} to filter\n * @param <R> the type of the response of the function\n * @see RouterFunction#filter(HandlerFilterFunction)\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 35
    },
    "signature": "public interface HandlerFilterFunction",
    "source_code": "public interface HandlerFilterFunction<T extends ServerResponse, R extends ServerResponse> {\n\n\t/**\n\t * Apply this filter to the given handler function. The given\n\t * {@linkplain HandlerFunction handler function} represents the next entity in the chain,\n\t * and can be {@linkplain HandlerFunction#handle(ServerRequest) invoked} in order to\n\t * proceed to this entity, or not invoked to block the chain.\n\t * @param request the request\n\t * @param next the next handler or filter function in the chain\n\t * @return the filtered response\n\t */\n\tR filter(ServerRequest request, HandlerFunction<T> next) throws Exception;\n\n\t/**\n\t * Return a composed filter function that first applies this filter, and then applies the\n\t * {@code after} filter.\n\t * @param after the filter to apply after this filter is applied\n\t * @return a composed filter that first applies this function and then applies the\n\t * {@code after} function\n\t */\n\tdefault HandlerFilterFunction<T, R> andThen(HandlerFilterFunction<T, T> after) {\n\t\tAssert.notNull(after, \"HandlerFilterFunction must not be null\");\n\t\treturn (request, next) -> {\n\t\t\tHandlerFunction<T> nextHandler = handlerRequest -> after.filter(handlerRequest, next);\n\t\t\treturn filter(request, nextHandler);\n\t\t};\n\t}\n\n\t/**\n\t * Apply this filter to the given handler function, resulting in a filtered handler function.\n\t * @param handler the handler function to filter\n\t * @return the filtered handler function\n\t */\n\tdefault HandlerFunction<R> apply(HandlerFunction<T> handler) {\n\t\tAssert.notNull(handler, \"HandlerFunction must not be null\");\n\t\treturn request -> this.filter(request, handler);\n\t}\n\n\t/**\n\t * Adapt the given request processor function to a filter function that only operates\n\t * on the {@code ServerRequest}.\n\t * @param requestProcessor the request processor\n\t * @return the filter adaptation of the request processor\n\t */\n\tstatic <T extends ServerResponse> HandlerFilterFunction<T, T>\n\tofRequestProcessor(Function<ServerRequest, ServerRequest> requestProcessor) {\n\n\t\tAssert.notNull(requestProcessor, \"Function must not be null\");\n\t\treturn (request, next) -> next.handle(requestProcessor.apply(request));\n\t}\n\n\t/**\n\t * Adapt the given response processor function to a filter function that only operates\n\t * on the {@code ServerResponse}.\n\t * @param responseProcessor the response processor\n\t * @return the filter adaptation of the request processor\n\t */\n\tstatic <T extends ServerResponse, R extends ServerResponse> HandlerFilterFunction<T, R>\n\tofResponseProcessor(BiFunction<ServerRequest, T, R> responseProcessor) {\n\n\t\tAssert.notNull(responseProcessor, \"Function must not be null\");\n\t\treturn (request, next) -> responseProcessor.apply(request, next.handle(request));\n\t}\n\n\t/**\n\t * Adapt the given predicate and response provider function to a filter function that returns\n\t * a {@code ServerResponse} on a given exception.\n\t * @param predicate the predicate to match an exception\n\t * @param errorHandler the response provider\n\t * @return the filter adaption of the error handler\n\t */\n\tstatic <T extends ServerResponse> HandlerFilterFunction<T, T>\n\tofErrorHandler(Predicate<Throwable> predicate, BiFunction<Throwable, ServerRequest, T> errorHandler) {\n\n\t\tAssert.notNull(predicate, \"Predicate must not be null\");\n\t\tAssert.notNull(errorHandler, \"ErrorHandler must not be null\");\n\n\t\treturn (request, next) -> {\n\t\t\ttry {\n\t\t\t\tT t = next.handle(request);\n\t\t\t\tif (t instanceof ErrorHandlingServerResponse response) {\n\t\t\t\t\tresponse.addErrorHandler(predicate, errorHandler);\n\t\t\t\t}\n\t\t\t\treturn t;\n\t\t\t}\n\t\t\tcatch (Throwable throwable) {\n\t\t\t\tif (predicate.test(throwable)) {\n\t\t\t\t\treturn errorHandler.apply(throwable, request);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow throwable;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n}"
  },
  "org.springframework.web.servlet.function.logger": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.web.servlet.function.support.HandlerFunctionAdapter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code HandlerAdapter} implementation that supports {@link HandlerFunction}s.\n *\n * @author Arjen Poutsma\n * @since 5.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public class HandlerFunctionAdapter",
    "source_code": "public class HandlerFunctionAdapter implements HandlerAdapter, Ordered {\n\n\tprivate static final Log logger = LogFactory.getLog(HandlerFunctionAdapter.class);\n\n\tprivate int order = Ordered.LOWEST_PRECEDENCE;\n\n\t@Nullable\n\tprivate Long asyncRequestTimeout;\n\n\t/**\n\t * Specify the order value for this HandlerAdapter bean.\n\t * <p>The default value is {@code Ordered.LOWEST_PRECEDENCE}, meaning non-ordered.\n\t * @see org.springframework.core.Ordered#getOrder()\n\t */\n\tpublic void setOrder(int order) {\n\t\tthis.order = order;\n\t}\n\n\t@Override\n\tpublic int getOrder() {\n\t\treturn this.order;\n\t}\n\n\t/**\n\t * Specify the amount of time, in milliseconds, before concurrent handling\n\t * should time out. In Servlet 3, the timeout begins after the main request\n\t * processing thread has exited and ends when the request is dispatched again\n\t * for further processing of the concurrently produced result.\n\t * <p>If this value is not set, the default timeout of the underlying\n\t * implementation is used.\n\t * <p>A value of 0 or less indicates that the asynchronous operation will never\n\t * time out.\n\t * @param timeout the timeout value in milliseconds\n\t */\n\tpublic void setAsyncRequestTimeout(long timeout) {\n\t\tthis.asyncRequestTimeout = timeout;\n\t}\n\n\t@Override\n\tpublic boolean supports(Object handler) {\n\t\treturn handler instanceof HandlerFunction;\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic ModelAndView handle(HttpServletRequest servletRequest,\n\t\t\tHttpServletResponse servletResponse,\n\t\t\tObject handler) throws Exception {\n\n\t\tWebAsyncManager asyncManager = getWebAsyncManager(servletRequest, servletResponse);\n\n\t\tServerRequest serverRequest = getServerRequest(servletRequest);\n\t\tServerResponse serverResponse;\n\n\t\tif (asyncManager.hasConcurrentResult()) {\n\t\t\tserverResponse = handleAsync(asyncManager);\n\t\t}\n\t\telse {\n\t\t\tHandlerFunction<?> handlerFunction = (HandlerFunction<?>) handler;\n\t\t\tserverResponse = handlerFunction.handle(serverRequest);\n\t\t}\n\n\t\tif (serverResponse != null) {\n\t\t\treturn serverResponse.writeTo(servletRequest, servletResponse, new ServerRequestContext(serverRequest));\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate WebAsyncManager getWebAsyncManager(HttpServletRequest servletRequest, HttpServletResponse servletResponse) {\n\t\tAsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(servletRequest, servletResponse);\n\t\tasyncWebRequest.setTimeout(this.asyncRequestTimeout);\n\n\t\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(servletRequest);\n\t\tasyncManager.setAsyncWebRequest(asyncWebRequest);\n\t\treturn asyncManager;\n\t}\n\n\tprivate ServerRequest getServerRequest(HttpServletRequest servletRequest) {\n\t\tServerRequest serverRequest =\n\t\t\t\t(ServerRequest) servletRequest.getAttribute(RouterFunctions.REQUEST_ATTRIBUTE);\n\t\tAssert.state(serverRequest != null, () -> \"Required attribute '\" +\n\t\t\t\tRouterFunctions.REQUEST_ATTRIBUTE + \"' is missing\");\n\t\treturn serverRequest;\n\t}\n\n\t@Nullable\n\tprivate ServerResponse handleAsync(WebAsyncManager asyncManager) throws Exception {\n\t\tObject result = asyncManager.getConcurrentResult();\n\t\tasyncManager.clearConcurrentResult();\n\t\tLogFormatUtils.traceDebug(logger, traceOn -> {\n\t\t\tString formatted = LogFormatUtils.formatValue(result, !traceOn);\n\t\t\treturn \"Resume with async result [\" + formatted + \"]\";\n\t\t});\n\t\tif (result instanceof ServerResponse response) {\n\t\t\treturn response;\n\t\t}\n\t\telse if (result instanceof Exception exception) {\n\t\t\tthrow exception;\n\t\t}\n\t\telse if (result instanceof Throwable throwable) {\n\t\t\tthrow new ServletException(\"Async processing failed\", throwable);\n\t\t}\n\t\telse if (result == null) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Unknown result from WebAsyncManager: [\" + result + \"]\");\n\t\t}\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"deprecation\")\n\tpublic long getLastModified(HttpServletRequest request, Object handler) {\n\t\treturn -1L;\n\t}\n\n\n\tprivate static class ServerRequestContext implements ServerResponse.Context {\n\n\t\tprivate final ServerRequest serverRequest;\n\n\n\t\tpublic ServerRequestContext(ServerRequest serverRequest) {\n\t\t\tthis.serverRequest = serverRequest;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<HttpMessageConverter<?>> messageConverters() {\n\t\t\treturn this.serverRequest.messageConverters();\n\t\t}\n\t}\n}"
  },
  "org.springframework.web.servlet.function.support.HandlerFunctionAdapter#getLastModified(request,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "long",
    "signature": "public long getLastModified(HttpServletRequest request, Object handler)",
    "source_code": "\tpublic long getLastModified(HttpServletRequest request, Object handler) {\n\t\treturn -1L;\n\t}"
  },
  "org.springframework.web.servlet.function.support.HandlerFunctionAdapter#getOrder()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "int",
    "signature": "public int getOrder()",
    "source_code": "\tpublic int getOrder() {\n\t\treturn this.order;\n\t}"
  },
  "org.springframework.web.servlet.function.support.HandlerFunctionAdapter#handle(servletRequest,servletResponse,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletRequest",
      "servletResponse",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "ModelAndView",
    "signature": "public ModelAndView handle(HttpServletRequest servletRequest,\n\t\t\tHttpServletResponse servletResponse,\n\t\t\tObject handler)",
    "source_code": "\tpublic ModelAndView handle(HttpServletRequest servletRequest,"
  },
  "org.springframework.web.servlet.function.support.HandlerFunctionAdapter#setAsyncRequestTimeout(timeout)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the amount of time, in milliseconds, before concurrent handling\n\t * should time out. In Servlet 3, the timeout begins after the main request\n\t * processing thread has exited and ends when the request is dispatched again\n\t * for further processing of the concurrently produced result.\n\t * <p>If this value is not set, the default timeout of the underlying\n\t * implementation is used.\n\t * <p>A value of 0 or less indicates that the asynchronous operation will never\n\t * time out.\n\t * @param timeout the timeout value in milliseconds\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "void",
    "signature": "public void setAsyncRequestTimeout(long timeout)",
    "source_code": "\tpublic void setAsyncRequestTimeout(long timeout) {\n\t\tthis.asyncRequestTimeout = timeout;\n\t}"
  },
  "org.springframework.web.servlet.function.support.HandlerFunctionAdapter#setOrder(order)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the order value for this HandlerAdapter bean.\n\t * <p>The default value is {@code Ordered.LOWEST_PRECEDENCE}, meaning non-ordered.\n\t * @see org.springframework.core.Ordered#getOrder()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "order"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "void",
    "signature": "public void setOrder(int order)",
    "source_code": "\tpublic void setOrder(int order) {\n\t\tthis.order = order;\n\t}"
  },
  "org.springframework.web.servlet.function.support.HandlerFunctionAdapter#supports(handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "boolean",
    "signature": "public boolean supports(Object handler)",
    "source_code": "\tpublic boolean supports(Object handler) {\n\t\treturn handler instanceof HandlerFunction;\n\t}"
  },
  "org.springframework.web.servlet.handler.HandlerMappingIntrospector": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Helper class to get information from the {@code HandlerMapping} that would\n * serve a specific request.\n *\n * <p>Provides the following methods:\n * <ul>\n * <li>{@link #getMatchableHandlerMapping} &mdash; obtain a {@code HandlerMapping}\n * to check request-matching criteria against.\n * <li>{@link #getCorsConfiguration} &mdash; obtain the CORS configuration for the\n * request.\n * </ul>\n *\n * <p><strong>Note:</strong> This is primarily an SPI to allow Spring Security\n * to align its pattern matching with the same pattern matching that would be\n * used in Spring MVC for a given request, in order to avoid security issues.\n * Use of this introspector should be avoided for other purposes because it\n * incurs the overhead of resolving the handler for a request.\n *\n * @author Rossen Stoyanchev\n * @since 4.3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "signature": "public class HandlerMappingIntrospector",
    "source_code": "public class HandlerMappingIntrospector"
  },
  "org.springframework.web.servlet.handler.HandlerMappingIntrospector#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tif (this.handlerMappings == null) {\n\t\t\tAssert.notNull(this.applicationContext, \"No ApplicationContext\");\n\t\t\tthis.handlerMappings = initHandlerMappings(this.applicationContext);\n\n\t\t\tthis.pathPatternMappings = this.handlerMappings.stream()\n\t\t\t\t\t.filter(m -> m instanceof MatchableHandlerMapping hm && hm.getPatternParser() != null)\n\t\t\t\t\t.map(mapping -> (MatchableHandlerMapping) mapping)\n\t\t\t\t\t.collect(Collectors.toMap(mapping -> mapping, PathPatternMatchableHandlerMapping::new));\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.HandlerMappingIntrospector#getAttribute(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "Object",
    "signature": "public Object getAttribute(String name)",
    "source_code": "\t\tpublic Object getAttribute(String name) {\n\t\t\treturn this.attributes.get(name);\n\t\t}"
  },
  "org.springframework.web.servlet.handler.HandlerMappingIntrospector#getAttributeNames()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "Enumeration<String>",
    "signature": "public Enumeration<String> getAttributeNames()",
    "source_code": "\t\tpublic Enumeration<String> getAttributeNames() {\n\t\t\treturn Collections.enumeration(this.attributes.keySet());\n\t\t}"
  },
  "org.springframework.web.servlet.handler.HandlerMappingIntrospector#getCorsConfiguration(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "CorsConfiguration",
    "signature": "public CorsConfiguration getCorsConfiguration(HttpServletRequest request)",
    "source_code": "\tpublic CorsConfiguration getCorsConfiguration(HttpServletRequest request) {\n\t\tAttributesPreservingRequest wrappedRequest = new AttributesPreservingRequest(request);\n\t\treturn doWithHandlerMappingIgnoringException(wrappedRequest, (handlerMapping, executionChain) -> {\n\t\t\tfor (HandlerInterceptor interceptor : executionChain.getInterceptorList()) {\n\t\t\t\tif (interceptor instanceof CorsConfigurationSource ccs) {\n\t\t\t\t\treturn ccs.getCorsConfiguration(wrappedRequest);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (executionChain.getHandler() instanceof CorsConfigurationSource ccs) {\n\t\t\t\treturn ccs.getCorsConfiguration(wrappedRequest);\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.web.servlet.handler.HandlerMappingIntrospector#getHandler(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 328
    },
    "return": "HandlerExecutionChain",
    "signature": "public HandlerExecutionChain getHandler(HttpServletRequest request)",
    "source_code": "\t\tpublic HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {\n\t\t\treturn this.delegate.getHandler(request);\n\t\t}"
  },
  "org.springframework.web.servlet.handler.HandlerMappingIntrospector#getHandlerMappings()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured or detected {@code HandlerMapping}s.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "List<HandlerMapping>",
    "signature": "public List<HandlerMapping> getHandlerMappings()",
    "source_code": "\tpublic List<HandlerMapping> getHandlerMappings() {\n\t\treturn (this.handlerMappings != null ? this.handlerMappings : Collections.emptyList());\n\t}"
  },
  "org.springframework.web.servlet.handler.HandlerMappingIntrospector#getMatchableHandlerMapping(request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the {@link HandlerMapping} that would handle the given request and\n\t * return a {@link MatchableHandlerMapping} to use for path matching.\n\t * @param request the current request\n\t * @return the resolved {@code MatchableHandlerMapping}, or {@code null}\n\t * @throws IllegalStateException if the matching HandlerMapping is not an\n\t * instance of {@link MatchableHandlerMapping}\n\t * @throws Exception if any of the HandlerMapping's raise an exception\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "MatchableHandlerMapping",
    "signature": "public MatchableHandlerMapping getMatchableHandlerMapping(HttpServletRequest request)",
    "source_code": "\tpublic MatchableHandlerMapping getMatchableHandlerMapping(HttpServletRequest request) throws Exception {\n\t\tHttpServletRequest wrappedRequest = new AttributesPreservingRequest(request);\n\n\t\treturn doWithHandlerMapping(wrappedRequest, false, (mapping, executionChain) -> {\n\t\t\tif (mapping instanceof MatchableHandlerMapping) {\n\t\t\t\tPathPatternMatchableHandlerMapping pathPatternMapping = this.pathPatternMappings.get(mapping);\n\t\t\t\tif (pathPatternMapping != null) {\n\t\t\t\t\tRequestPath requestPath = ServletRequestPathUtils.getParsedRequestPath(wrappedRequest);\n\t\t\t\t\treturn new LookupPathMatchableHandlerMapping(pathPatternMapping, requestPath);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tString lookupPath = (String) wrappedRequest.getAttribute(UrlPathHelper.PATH_ATTRIBUTE);\n\t\t\t\t\treturn new LookupPathMatchableHandlerMapping((MatchableHandlerMapping) mapping, lookupPath);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new IllegalStateException(\"HandlerMapping is not a MatchableHandlerMapping\");\n\t\t});\n\t}"
  },
  "org.springframework.web.servlet.handler.HandlerMappingIntrospector#match(request,pattern)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "pattern"
    ],
    "position": {
      "column": 1,
      "line": 314
    },
    "return": "RequestMatchResult",
    "signature": "public RequestMatchResult match(HttpServletRequest request, String pattern)",
    "source_code": "\t\tpublic RequestMatchResult match(HttpServletRequest request, String pattern) {\n\t\t\tpattern = (StringUtils.hasLength(pattern) && !pattern.startsWith(\"/\") ? \"/\" + pattern : pattern);\n\t\t\tObject previousPath = request.getAttribute(this.pathAttributeName);\n\t\t\trequest.setAttribute(this.pathAttributeName, this.lookupPath);\n\t\t\ttry {\n\t\t\t\treturn this.delegate.match(request, pattern);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\trequest.setAttribute(this.pathAttributeName, previousPath);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.handler.HandlerMappingIntrospector#removeAttribute(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "void",
    "signature": "public void removeAttribute(String name)",
    "source_code": "\t\tpublic void removeAttribute(String name) {\n\t\t\tthis.attributes.remove(name);\n\t\t}"
  },
  "org.springframework.web.servlet.handler.HandlerMappingIntrospector#setApplicationContext(applicationContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "applicationContext"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "void",
    "signature": "public void setApplicationContext(ApplicationContext applicationContext)",
    "source_code": "\tpublic void setApplicationContext(ApplicationContext applicationContext) {\n\t\tthis.applicationContext = applicationContext;\n\t}"
  },
  "org.springframework.web.servlet.handler.HandlerMappingIntrospector#setAttribute(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "void",
    "signature": "public void setAttribute(String name, Object value)",
    "source_code": "\t\tpublic void setAttribute(String name, Object value) {\n\t\t\tthis.attributes.put(name, value);\n\t\t}"
  },
  "org.springframework.web.servlet.handler.SimpleServletPostProcessor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link org.springframework.beans.factory.config.BeanPostProcessor}\n * that applies initialization and destruction callbacks to beans that\n * implement the {@link jakarta.servlet.Servlet} interface.\n *\n * <p>After initialization of the bean instance, the Servlet {@code init}\n * method will be called with a ServletConfig that contains the bean name\n * of the Servlet and the ServletContext that it is running in.\n *\n * <p>Before destruction of the bean instance, the Servlet {@code destroy}\n * will be called.\n *\n * <p><b>Note that this post-processor does not support Servlet initialization\n * parameters.</b> Bean instances that implement the Servlet interface are\n * supposed to be configured like any other Spring bean, that is, through\n * constructor arguments or bean properties.\n *\n * <p>For reuse of a Servlet implementation in a plain Servlet container\n * and as a bean in a Spring context, consider deriving from Spring's\n * {@link org.springframework.web.servlet.HttpServletBean} base class that\n * applies Servlet initialization parameters as bean properties, supporting\n * both the standard Servlet and the Spring bean initialization style.\n *\n * <p><b>Alternatively, consider wrapping a Servlet with Spring's\n * {@link org.springframework.web.servlet.mvc.ServletWrappingController}.</b>\n * This is particularly appropriate for existing Servlet classes,\n * allowing to specify Servlet initialization parameters etc.\n *\n * @author Juergen Hoeller\n * @since 1.1.5\n * @see jakarta.servlet.Servlet#init(jakarta.servlet.ServletConfig)\n * @see jakarta.servlet.Servlet#destroy()\n * @see SimpleServletHandlerAdapter\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "signature": "public class SimpleServletPostProcessor",
    "source_code": "public class SimpleServletPostProcessor implements"
  },
  "org.springframework.web.servlet.handler.SimpleServletPostProcessor#getInitParameter(paramName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "String",
    "signature": "public String getInitParameter(String paramName)",
    "source_code": "\t\tpublic String getInitParameter(String paramName) {\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.web.servlet.handler.SimpleServletPostProcessor#getInitParameterNames()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "Enumeration<String>",
    "signature": "public Enumeration<String> getInitParameterNames()",
    "source_code": "\t\tpublic Enumeration<String> getInitParameterNames() {\n\t\t\treturn Collections.enumeration(Collections.emptySet());\n\t\t}"
  },
  "org.springframework.web.servlet.handler.SimpleServletPostProcessor#getServletContext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "ServletContext",
    "signature": "public ServletContext getServletContext()",
    "source_code": "\t\tpublic ServletContext getServletContext() {\n\t\t\treturn this.servletContext;\n\t\t}"
  },
  "org.springframework.web.servlet.handler.SimpleServletPostProcessor#getServletName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "String",
    "signature": "public String getServletName()",
    "source_code": "\t\tpublic String getServletName() {\n\t\t\treturn this.servletName;\n\t\t}"
  },
  "org.springframework.web.servlet.handler.SimpleServletPostProcessor#postProcessAfterInitialization(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n\t\tif (bean instanceof Servlet servlet) {\n\t\t\tServletConfig config = this.servletConfig;\n\t\t\tif (config == null || !this.useSharedServletConfig) {\n\t\t\t\tconfig = new DelegatingServletConfig(beanName, this.servletContext);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tservlet.init(config);\n\t\t\t}\n\t\t\tcatch (ServletException ex) {\n\t\t\t\tthrow new BeanInitializationException(\"Servlet.init threw exception\", ex);\n\t\t\t}\n\t\t}\n\t\treturn bean;\n\t}"
  },
  "org.springframework.web.servlet.handler.SimpleServletPostProcessor#postProcessBeforeDestruction(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void postProcessBeforeDestruction(Object bean, String beanName)",
    "source_code": "\tpublic void postProcessBeforeDestruction(Object bean, String beanName) throws BeansException {\n\t\tif (bean instanceof Servlet servlet) {\n\t\t\tservlet.destroy();\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.SimpleServletPostProcessor#postProcessBeforeInitialization(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n\t\treturn bean;\n\t}"
  },
  "org.springframework.web.servlet.handler.SimpleServletPostProcessor#requiresDestruction(bean)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "boolean",
    "signature": "public boolean requiresDestruction(Object bean)",
    "source_code": "\tpublic boolean requiresDestruction(Object bean) {\n\t\treturn (bean instanceof Servlet);\n\t}"
  },
  "org.springframework.web.servlet.handler.SimpleServletPostProcessor#setServletConfig(servletConfig)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletConfig"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void setServletConfig(ServletConfig servletConfig)",
    "source_code": "\tpublic void setServletConfig(ServletConfig servletConfig) {\n\t\tthis.servletConfig = servletConfig;\n\t}"
  },
  "org.springframework.web.servlet.handler.SimpleServletPostProcessor#setServletContext(servletContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "void",
    "signature": "public void setServletContext(ServletContext servletContext)",
    "source_code": "\tpublic void setServletContext(ServletContext servletContext) {\n\t\tthis.servletContext = servletContext;\n\t}"
  },
  "org.springframework.web.servlet.handler.SimpleServletPostProcessor#setUseSharedServletConfig(useSharedServletConfig)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to use the shared ServletConfig object passed in\n\t * through {@code setServletConfig}, if available.\n\t * <p>Default is \"true\". Turn this setting to \"false\" to pass in\n\t * a mock ServletConfig object with the bean name as servlet name,\n\t * holding the current ServletContext.\n\t * @see #setServletConfig\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "useSharedServletConfig"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "void",
    "signature": "public void setUseSharedServletConfig(boolean useSharedServletConfig)",
    "source_code": "\tpublic void setUseSharedServletConfig(boolean useSharedServletConfig) {\n\t\tthis.useSharedServletConfig = useSharedServletConfig;\n\t}"
  },
  "org.springframework.web.servlet.handler.SimpleUrlHandlerMapping": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Implementation of the {@link org.springframework.web.servlet.HandlerMapping}\n * interface that maps from URLs to request handler beans. Supports both mapping to bean\n * instances and mapping to bean names; the latter is required for non-singleton handlers.\n *\n * <p>The \"urlMap\" property is suitable for populating the handler map with\n * bean references, e.g. via the map element in XML bean definitions.\n *\n * <p>Mappings to bean names can be set via the \"mappings\" property, in a form\n * accepted by the {@code java.util.Properties} class, as follows:\n *\n * <pre class=\"code\">\n * /welcome.html=ticketController\n * /show.html=ticketController</pre>\n *\n * <p>The syntax is {@code PATH=HANDLER_BEAN_NAME}. If the path doesn't begin\n * with a slash, one is prepended.\n *\n * <p>Supports direct matches (given \"/test\" -&gt; registered \"/test\") and \"*\"\n * matches (given \"/test\" -&gt; registered \"/t*\"). For details on the pattern\n * options, see the {@link org.springframework.web.util.pattern.PathPattern}\n * javadoc.\n\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @see #setMappings\n * @see #setUrlMap\n * @see BeanNameUrlHandlerMapping\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "signature": "public class SimpleUrlHandlerMapping",
    "source_code": "public class SimpleUrlHandlerMapping extends AbstractUrlHandlerMapping {\n\n\tprivate final Map<String, Object> urlMap = new LinkedHashMap<>();\n\n\n\t/**\n\t * Create a {@code SimpleUrlHandlerMapping} with default settings.\n\t */\n\tpublic SimpleUrlHandlerMapping() {\n\t}\n\n\t/**\n\t * Create a {@code SimpleUrlHandlerMapping} using the supplied URL map.\n\t * @param urlMap map with URL paths as keys and handler beans (or handler\n\t * bean names) as values\n\t * @since 5.2\n\t * @see #setUrlMap(Map)\n\t */\n\tpublic SimpleUrlHandlerMapping(Map<String, ?> urlMap) {\n\t\tsetUrlMap(urlMap);\n\t}\n\n\t/**\n\t * Create a {@code SimpleUrlHandlerMapping} using the supplied URL map and order.\n\t * @param urlMap map with URL paths as keys and handler beans (or handler\n\t * bean names) as values\n\t * @param order the order value for this {@code SimpleUrlHandlerMapping}\n\t * @since 5.2\n\t * @see #setUrlMap(Map)\n\t * @see #setOrder(int)\n\t */\n\tpublic SimpleUrlHandlerMapping(Map<String, ?> urlMap, int order) {\n\t\tsetUrlMap(urlMap);\n\t\tsetOrder(order);\n\t}\n\n\n\t/**\n\t * Map URL paths to handler bean names.\n\t * This is the typical way of configuring this HandlerMapping.\n\t * <p>Supports direct URL matches and Ant-style pattern matches. For syntax\n\t * details, see the {@link org.springframework.util.AntPathMatcher} javadoc.\n\t * @param mappings properties with URLs as keys and bean names as values\n\t * @see #setUrlMap\n\t */\n\tpublic void setMappings(Properties mappings) {\n\t\tCollectionUtils.mergePropertiesIntoMap(mappings, this.urlMap);\n\t}\n\n\t/**\n\t * Set a Map with URL paths as keys and handler beans (or handler bean names)\n\t * as values. Convenient for population with bean references.\n\t * <p>Supports direct URL matches and Ant-style pattern matches. For syntax\n\t * details, see the {@link org.springframework.util.AntPathMatcher} javadoc.\n\t * @param urlMap map with URLs as keys and beans as values\n\t * @see #setMappings\n\t */\n\tpublic void setUrlMap(Map<String, ?> urlMap) {\n\t\tthis.urlMap.putAll(urlMap);\n\t}\n\n\t/**\n\t * Allow {@code Map} access to the URL path mappings, with the option to add or\n\t * override specific entries.\n\t * <p>Useful for specifying entries directly, for example via \"urlMap[myKey]\".\n\t * This is particularly useful for adding or overriding entries in child\n\t * bean definitions.\n\t */\n\tpublic Map<String, ?> getUrlMap() {\n\t\treturn this.urlMap;\n\t}\n\n\n\t/**\n\t * Calls the {@link #registerHandlers} method in addition to the\n\t * superclass's initialization.\n\t */\n\t@Override\n\tpublic void initApplicationContext() throws BeansException {\n\t\tsuper.initApplicationContext();\n\t\tregisterHandlers(this.urlMap);\n\t}\n\n\t/**\n\t * Register all handlers specified in the URL map for the corresponding paths.\n\t * @param urlMap a Map with URL paths as keys and handler beans or bean names as values\n\t * @throws BeansException if a handler couldn't be registered\n\t * @throws IllegalStateException if there is a conflicting handler registered\n\t */\n\tprotected void registerHandlers(Map<String, Object> urlMap) throws BeansException {\n\t\tif (urlMap.isEmpty()) {\n\t\t\tlogger.trace(\"No patterns in \" + formatMappingName());\n\t\t}\n\t\telse {\n\t\t\turlMap.forEach((url, handler) -> {\n\t\t\t\t// Prepend with slash if not already present.\n\t\t\t\tif (!url.startsWith(\"/\")) {\n\t\t\t\t\turl = \"/\" + url;\n\t\t\t\t}\n\t\t\t\t// Remove whitespace from handler bean name.\n\t\t\t\tif (handler instanceof String handlerName) {\n\t\t\t\t\thandler = handlerName.trim();\n\t\t\t\t}\n\t\t\t\tregisterHandler(url, handler);\n\t\t\t});\n\t\t\tlogMappings();\n\t\t}\n\t}\n\n\tprivate void logMappings() {\n\t\tif (mappingsLogger.isDebugEnabled()) {\n\t\t\tMap<String, Object> map = new LinkedHashMap<>(getHandlerMap());\n\t\t\tif (getRootHandler() != null) {\n\t\t\t\tmap.put(\"/\", getRootHandler());\n\t\t\t}\n\t\t\tif (getDefaultHandler() != null) {\n\t\t\t\tmap.put(\"/**\", getDefaultHandler());\n\t\t\t}\n\t\t\tmappingsLogger.debug(formatMappingName() + \" \" + map);\n\t\t}\n\t\telse if (logger.isDebugEnabled()) {\n\t\t\tList<String> patterns = new ArrayList<>();\n\t\t\tif (getRootHandler() != null) {\n\t\t\t\tpatterns.add(\"/\");\n\t\t\t}\n\t\t\tif (getDefaultHandler() != null) {\n\t\t\t\tpatterns.add(\"/**\");\n\t\t\t}\n\t\t\tpatterns.addAll(getHandlerMap().keySet());\n\t\t\tlogger.debug(\"Patterns \" + patterns + \" in \" + formatMappingName());\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.servlet.handler.SimpleUrlHandlerMapping#initApplicationContext()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Calls the {@link #registerHandlers} method in addition to the\n\t * superclass's initialization.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "void",
    "signature": "public void initApplicationContext()",
    "source_code": "\tpublic void initApplicationContext() throws BeansException {\n\t\tsuper.initApplicationContext();\n\t\tregisterHandlers(this.urlMap);\n\t}"
  },
  "org.springframework.web.servlet.handler.SimpleUrlHandlerMapping#registerHandlers(Map<String,urlMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register all handlers specified in the URL map for the corresponding paths.\n\t * @param urlMap a Map with URL paths as keys and handler beans or bean names as values\n\t * @throws BeansException if a handler couldn't be registered\n\t * @throws IllegalStateException if there is a conflicting handler registered\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "urlMap"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "void",
    "signature": "protected void registerHandlers(Map<String, Object> urlMap)",
    "source_code": "\tprotected void registerHandlers(Map<String, Object> urlMap) throws BeansException {\n\t\tif (urlMap.isEmpty()) {\n\t\t\tlogger.trace(\"No patterns in \" + formatMappingName());\n\t\t}\n\t\telse {\n\t\t\turlMap.forEach((url, handler) -> {\n\t\t\t\t// Prepend with slash if not already present.\n\t\t\t\tif (!url.startsWith(\"/\")) {\n\t\t\t\t\turl = \"/\" + url;\n\t\t\t\t}\n\t\t\t\t// Remove whitespace from handler bean name.\n\t\t\t\tif (handler instanceof String handlerName) {\n\t\t\t\t\thandler = handlerName.trim();\n\t\t\t\t}\n\t\t\t\tregisterHandler(url, handler);\n\t\t\t});\n\t\t\tlogMappings();\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.SimpleUrlHandlerMapping#setMappings(mappings)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Map URL paths to handler bean names.\n\t * This is the typical way of configuring this HandlerMapping.\n\t * <p>Supports direct URL matches and Ant-style pattern matches. For syntax\n\t * details, see the {@link org.springframework.util.AntPathMatcher} javadoc.\n\t * @param mappings properties with URLs as keys and bean names as values\n\t * @see #setUrlMap\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappings"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "void",
    "signature": "public void setMappings(Properties mappings)",
    "source_code": "\tpublic void setMappings(Properties mappings) {\n\t\tCollectionUtils.mergePropertiesIntoMap(mappings, this.urlMap);\n\t}"
  },
  "org.springframework.web.servlet.handler.SimpleUrlHandlerMapping#setUrlMap(Map<String,urlMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a Map with URL paths as keys and handler beans (or handler bean names)\n\t * as values. Convenient for population with bean references.\n\t * <p>Supports direct URL matches and Ant-style pattern matches. For syntax\n\t * details, see the {@link org.springframework.util.AntPathMatcher} javadoc.\n\t * @param urlMap map with URLs as keys and beans as values\n\t * @see #setMappings\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "urlMap"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "void",
    "signature": "public void setUrlMap(Map<String, ?> urlMap)",
    "source_code": "\tpublic void setUrlMap(Map<String, ?> urlMap) {\n\t\tthis.urlMap.putAll(urlMap);\n\t}"
  },
  "org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Adapter to use the plain {@link org.springframework.web.HttpRequestHandler}\n * interface with the generic {@link org.springframework.web.servlet.DispatcherServlet}.\n * Supports handlers that implement the {@link LastModified} interface.\n *\n * <p>This is an SPI class, not used directly by application code.\n *\n * @author Juergen Hoeller\n * @since 2.0\n * @see org.springframework.web.servlet.DispatcherServlet\n * @see org.springframework.web.HttpRequestHandler\n * @see SimpleControllerHandlerAdapter\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 40
    },
    "signature": "public class HttpRequestHandlerAdapter",
    "source_code": "public class HttpRequestHandlerAdapter implements HandlerAdapter {\n\n\t@Override\n\tpublic boolean supports(Object handler) {\n\t\treturn (handler instanceof HttpRequestHandler);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\n\t\t((HttpRequestHandler) handler).handleRequest(request, response);\n\t\treturn null;\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"deprecation\")\n\tpublic long getLastModified(HttpServletRequest request, Object handler) {\n\t\tif (handler instanceof LastModified lastModified) {\n\t\t\treturn lastModified.getLastModified(request);\n\t\t}\n\t\treturn -1L;\n\t}\n\n}"
  },
  "org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter#getLastModified(request,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "long",
    "signature": "public long getLastModified(HttpServletRequest request, Object handler)",
    "source_code": "\tpublic long getLastModified(HttpServletRequest request, Object handler) {\n\t\tif (handler instanceof LastModified lastModified) {\n\t\t\treturn lastModified.getLastModified(request);\n\t\t}\n\t\treturn -1L;\n\t}"
  },
  "org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter#handle(request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "return": "ModelAndView",
    "signature": "public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "source_code": "\tpublic ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)"
  },
  "org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter#supports(handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "return": "boolean",
    "signature": "public boolean supports(Object handler)",
    "source_code": "\tpublic boolean supports(Object handler) {\n\t\treturn (handler instanceof HttpRequestHandler);\n\t}"
  },
  "org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Adapter to use the plain {@link Controller} workflow interface with\n * the generic {@link org.springframework.web.servlet.DispatcherServlet}.\n * Supports handlers that implement the {@link LastModified} interface.\n *\n * <p>This is an SPI class, not used directly by application code.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @see org.springframework.web.servlet.DispatcherServlet\n * @see Controller\n * @see HttpRequestHandlerAdapter\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class SimpleControllerHandlerAdapter",
    "source_code": "public class SimpleControllerHandlerAdapter implements HandlerAdapter {\n\n\t@Override\n\tpublic boolean supports(Object handler) {\n\t\treturn (handler instanceof Controller);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\n\t\treturn ((Controller) handler).handleRequest(request, response);\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"deprecation\")\n\tpublic long getLastModified(HttpServletRequest request, Object handler) {\n\t\tif (handler instanceof LastModified lastModified) {\n\t\t\treturn lastModified.getLastModified(request);\n\t\t}\n\t\treturn -1L;\n\t}\n\n}"
  },
  "org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter#getLastModified(request,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "long",
    "signature": "public long getLastModified(HttpServletRequest request, Object handler)",
    "source_code": "\tpublic long getLastModified(HttpServletRequest request, Object handler) {\n\t\tif (handler instanceof LastModified lastModified) {\n\t\t\treturn lastModified.getLastModified(request);\n\t\t}\n\t\treturn -1L;\n\t}"
  },
  "org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter#handle(request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "return": "ModelAndView",
    "signature": "public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "source_code": "\tpublic ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)"
  },
  "org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter#supports(handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "return": "boolean",
    "signature": "public boolean supports(Object handler)",
    "source_code": "\tpublic boolean supports(Object handler) {\n\t\treturn (handler instanceof Controller);\n\t}"
  },
  "org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A {@link org.springframework.web.servlet.HandlerExceptionResolver\n * HandlerExceptionResolver} that uses the {@link ResponseStatus @ResponseStatus}\n * annotation to map exceptions to HTTP status codes.\n *\n * <p>This exception resolver is enabled by default in the\n * {@link org.springframework.web.servlet.DispatcherServlet DispatcherServlet}\n * and the MVC Java config and the MVC namespace.\n *\n * <p>As of 4.2 this resolver also looks recursively for {@code @ResponseStatus}\n * present on cause exceptions, and as of 4.2.2 this resolver supports\n * attribute overrides for {@code @ResponseStatus} in custom composed annotations.\n *\n * <p>As of 5.0 this resolver also supports {@link ResponseStatusException}.\n *\n * @author Arjen Poutsma\n * @author Rossen Stoyanchev\n * @author Sam Brannen\n * @since 3.0\n * @see ResponseStatus\n * @see ResponseStatusException\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "signature": "public class ResponseStatusExceptionResolver",
    "source_code": "public class ResponseStatusExceptionResolver extends AbstractHandlerExceptionResolver implements MessageSourceAware {\n\n\t@Nullable\n\tprivate MessageSource messageSource;\n\n\n\t@Override\n\tpublic void setMessageSource(MessageSource messageSource) {\n\t\tthis.messageSource = messageSource;\n\t}\n\n\n\t@Override\n\t@Nullable\n\tprotected ModelAndView doResolveException(\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) {\n\n\t\ttry {\n\t\t\tif (ex instanceof ResponseStatusException rse) {\n\t\t\t\treturn resolveResponseStatusException(rse, request, response, handler);\n\t\t\t}\n\n\t\t\tResponseStatus status = AnnotatedElementUtils.findMergedAnnotation(ex.getClass(), ResponseStatus.class);\n\t\t\tif (status != null) {\n\t\t\t\treturn resolveResponseStatus(status, request, response, handler, ex);\n\t\t\t}\n\n\t\t\tif (ex.getCause() instanceof Exception cause) {\n\t\t\t\treturn doResolveException(request, response, handler, cause);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception resolveEx) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Failure while trying to resolve exception [\" + ex.getClass().getName() + \"]\", resolveEx);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Template method that handles the {@link ResponseStatus @ResponseStatus} annotation.\n\t * <p>The default implementation delegates to {@link #applyStatusAndReason}\n\t * with the status code and reason from the annotation.\n\t * @param responseStatus the {@code @ResponseStatus} annotation\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen at the\n\t * time of the exception, e.g. if multipart resolution failed\n\t * @param ex the exception\n\t * @return an empty ModelAndView, i.e. exception resolved\n\t */\n\tprotected ModelAndView resolveResponseStatus(ResponseStatus responseStatus, HttpServletRequest request,\n\t\t\tHttpServletResponse response, @Nullable Object handler, Exception ex) throws Exception {\n\n\t\tint statusCode = responseStatus.code().value();\n\t\tString reason = responseStatus.reason();\n\t\treturn applyStatusAndReason(statusCode, reason, response);\n\t}\n\n\t/**\n\t * Template method that handles an {@link ResponseStatusException}.\n\t * <p>The default implementation applies the headers from\n\t * {@link ResponseStatusException#getHeaders()} and delegates to\n\t * {@link #applyStatusAndReason} with the status code and reason from the\n\t * exception.\n\t * @param ex the exception\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen at the\n\t * time of the exception, e.g. if multipart resolution failed\n\t * @return an empty ModelAndView, i.e. exception resolved\n\t * @since 5.0\n\t */\n\tprotected ModelAndView resolveResponseStatusException(ResponseStatusException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws Exception {\n\n\t\tex.getHeaders().forEach((name, values) -> values.forEach(value -> response.addHeader(name, value)));\n\t\treturn applyStatusAndReason(ex.getStatusCode().value(), ex.getReason(), response);\n\t}\n\n\t/**\n\t * Apply the resolved status code and reason to the response.\n\t * <p>The default implementation sends a response error using\n\t * {@link HttpServletResponse#sendError(int)} or\n\t * {@link HttpServletResponse#sendError(int, String)} if there is a reason\n\t * and then returns an empty ModelAndView.\n\t * @param statusCode the HTTP status code\n\t * @param reason the associated reason (may be {@code null} or empty)\n\t * @param response current HTTP response\n\t * @since 5.0\n\t */\n\tprotected ModelAndView applyStatusAndReason(int statusCode, @Nullable String reason, HttpServletResponse response)\n\t\t\tthrows IOException {\n\n\t\tif (!StringUtils.hasLength(reason)) {\n\t\t\tresponse.sendError(statusCode);\n\t\t}\n\t\telse {\n\t\t\tString resolvedReason = (this.messageSource != null ?\n\t\t\t\t\tthis.messageSource.getMessage(reason, null, reason, LocaleContextHolder.getLocale()) :\n\t\t\t\t\treason);\n\t\t\tresponse.sendError(statusCode, resolvedReason);\n\t\t}\n\t\treturn new ModelAndView();\n\t}\n\n}"
  },
  "org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver#applyStatusAndReason(statusCode,reason,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the resolved status code and reason to the response.\n\t * <p>The default implementation sends a response error using\n\t * {@link HttpServletResponse#sendError(int)} or\n\t * {@link HttpServletResponse#sendError(int, String)} if there is a reason\n\t * and then returns an empty ModelAndView.\n\t * @param statusCode the HTTP status code\n\t * @param reason the associated reason (may be {@code null} or empty)\n\t * @param response current HTTP response\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "statusCode",
      "reason",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView applyStatusAndReason(int statusCode, @Nullable String reason, HttpServletResponse response)",
    "source_code": "\tprotected ModelAndView applyStatusAndReason(int statusCode, @Nullable String reason, HttpServletResponse response)"
  },
  "org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver#doResolveException(request,response,handler,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView doResolveException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)",
    "source_code": "\tprotected ModelAndView doResolveException("
  },
  "org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver#resolveResponseStatus(responseStatus,request,response,handler,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Template method that handles the {@link ResponseStatus @ResponseStatus} annotation.\n\t * <p>The default implementation delegates to {@link #applyStatusAndReason}\n\t * with the status code and reason from the annotation.\n\t * @param responseStatus the {@code @ResponseStatus} annotation\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen at the\n\t * time of the exception, e.g. if multipart resolution failed\n\t * @param ex the exception\n\t * @return an empty ModelAndView, i.e. exception resolved\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "responseStatus",
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView resolveResponseStatus(ResponseStatus responseStatus, HttpServletRequest request,\n\t\t\tHttpServletResponse response, @Nullable Object handler, Exception ex)",
    "source_code": "\tprotected ModelAndView resolveResponseStatus(ResponseStatus responseStatus, HttpServletRequest request,"
  },
  "org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver#resolveResponseStatusException(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Template method that handles an {@link ResponseStatusException}.\n\t * <p>The default implementation applies the headers from\n\t * {@link ResponseStatusException#getHeaders()} and delegates to\n\t * {@link #applyStatusAndReason} with the status code and reason from the\n\t * exception.\n\t * @param ex the exception\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen at the\n\t * time of the exception, e.g. if multipart resolution failed\n\t * @return an empty ModelAndView, i.e. exception resolved\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView resolveResponseStatusException(ResponseStatusException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView resolveResponseStatusException(ResponseStatusException ex,"
  },
  "org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver#setMessageSource(messageSource)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSource"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "void",
    "signature": "public void setMessageSource(MessageSource messageSource)",
    "source_code": "\tpublic void setMessageSource(MessageSource messageSource) {\n\t\tthis.messageSource = messageSource;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract base class for {@link HandlerAdapter} implementations that support\n * handlers of type {@link HandlerMethod}.\n *\n * @author Arjen Poutsma\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 36
    },
    "signature": "public class AbstractHandlerMethodAdapter",
    "source_code": "public abstract class AbstractHandlerMethodAdapter extends WebContentGenerator implements HandlerAdapter, Ordered {\n\n\tprivate int order = Ordered.LOWEST_PRECEDENCE;\n\n\n\tpublic AbstractHandlerMethodAdapter() {\n\t\t// no restriction of HTTP methods by default\n\t\tsuper(false);\n\t}\n\n\n\t/**\n\t * Specify the order value for this HandlerAdapter bean.\n\t * <p>The default value is {@code Ordered.LOWEST_PRECEDENCE}, meaning non-ordered.\n\t * @see org.springframework.core.Ordered#getOrder()\n\t */\n\tpublic void setOrder(int order) {\n\t\tthis.order = order;\n\t}\n\n\t@Override\n\tpublic int getOrder() {\n\t\treturn this.order;\n\t}\n\n\n\t/**\n\t * This implementation expects the handler to be an {@link HandlerMethod}.\n\t * @param handler the handler instance to check\n\t * @return whether this adapter can adapt the given handler\n\t */\n\t@Override\n\tpublic final boolean supports(Object handler) {\n\t\treturn (handler instanceof HandlerMethod handlerMethod && supportsInternal(handlerMethod));\n\t}\n\n\t/**\n\t * Given a handler method, return whether this adapter can support it.\n\t * @param handlerMethod the handler method to check\n\t * @return whether this adapter can adapt the given method\n\t */\n\tprotected abstract boolean supportsInternal(HandlerMethod handlerMethod);\n\n\t/**\n\t * This implementation expects the handler to be an {@link HandlerMethod}.\n\t */\n\t@Override\n\t@Nullable\n\tpublic final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\n\t\treturn handleInternal(request, response, (HandlerMethod) handler);\n\t}\n\n\t/**\n\t * Use the given handler method to handle the request.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handlerMethod handler method to use. This object must have previously been passed to the\n\t * {@link #supportsInternal(HandlerMethod)} this interface, which must have returned {@code true}.\n\t * @return a ModelAndView object with the name of the view and the required model data,\n\t * or {@code null} if the request has been handled directly\n\t * @throws Exception in case of errors\n\t */\n\t@Nullable\n\tprotected abstract ModelAndView handleInternal(HttpServletRequest request,\n\t\t\tHttpServletResponse response, HandlerMethod handlerMethod) throws Exception;\n\n\t/**\n\t * This implementation expects the handler to be an {@link HandlerMethod}.\n\t */\n\t@Override\n\t@SuppressWarnings(\"deprecation\")\n\tpublic final long getLastModified(HttpServletRequest request, Object handler) {\n\t\treturn getLastModifiedInternal(request, (HandlerMethod) handler);\n\t}\n\n\t/**\n\t * Same contract as for {@link jakarta.servlet.http.HttpServlet#getLastModified(HttpServletRequest)}.\n\t * @param request current HTTP request\n\t * @param handlerMethod handler method to use\n\t * @return the lastModified value for the given handler\n\t * @deprecated as of 5.3.9 along with\n\t * {@link org.springframework.web.servlet.mvc.LastModified}.\n\t */\n\t@Deprecated\n\tprotected abstract long getLastModifiedInternal(HttpServletRequest request, HandlerMethod handlerMethod);\n\n}"
  },
  "org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter#getLastModified(request,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation expects the handler to be an {@link HandlerMethod}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "long",
    "signature": "public long getLastModified(HttpServletRequest request, Object handler)",
    "source_code": "\tpublic final long getLastModified(HttpServletRequest request, Object handler) {\n\t\treturn getLastModifiedInternal(request, (HandlerMethod) handler);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter#getLastModifiedInternal(request,handlerMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Same contract as for {@link jakarta.servlet.http.HttpServlet#getLastModified(HttpServletRequest)}.\n\t * @param request current HTTP request\n\t * @param handlerMethod handler method to use\n\t * @return the lastModified value for the given handler\n\t * @deprecated as of 5.3.9 along with\n\t * {@link org.springframework.web.servlet.mvc.LastModified}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "long",
    "signature": "protected long getLastModifiedInternal(HttpServletRequest request, HandlerMethod handlerMethod)",
    "source_code": "\tprotected abstract long getLastModifiedInternal(HttpServletRequest request, HandlerMethod handlerMethod);"
  },
  "org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter#getOrder()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "int",
    "signature": "public int getOrder()",
    "source_code": "\tpublic int getOrder() {\n\t\treturn this.order;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter#handle(request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation expects the handler to be an {@link HandlerMethod}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "ModelAndView",
    "signature": "public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "source_code": "\tpublic final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)"
  },
  "org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter#handleInternal(request,response,handlerMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Use the given handler method to handle the request.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handlerMethod handler method to use. This object must have previously been passed to the\n\t * {@link #supportsInternal(HandlerMethod)} this interface, which must have returned {@code true}.\n\t * @return a ModelAndView object with the name of the view and the required model data,\n\t * or {@code null} if the request has been handled directly\n\t * @throws Exception in case of errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleInternal(HttpServletRequest request,\n\t\t\tHttpServletResponse response, HandlerMethod handlerMethod)",
    "source_code": "\tprotected abstract ModelAndView handleInternal(HttpServletRequest request,"
  },
  "org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter#setOrder(order)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the order value for this HandlerAdapter bean.\n\t * <p>The default value is {@code Ordered.LOWEST_PRECEDENCE}, meaning non-ordered.\n\t * @see org.springframework.core.Ordered#getOrder()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "order"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "void",
    "signature": "public void setOrder(int order)",
    "source_code": "\tpublic void setOrder(int order) {\n\t\tthis.order = order;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter#supports(handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation expects the handler to be an {@link HandlerMethod}.\n\t * @param handler the handler instance to check\n\t * @return whether this adapter can adapt the given handler\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "boolean",
    "signature": "public boolean supports(Object handler)",
    "source_code": "\tpublic final boolean supports(Object handler) {\n\t\treturn (handler instanceof HandlerMethod handlerMethod && supportsInternal(handlerMethod));\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter#supportsInternal(handlerMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Given a handler method, return whether this adapter can support it.\n\t * @param handlerMethod the handler method to check\n\t * @return whether this adapter can adapt the given method\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "boolean",
    "signature": "protected boolean supportsInternal(HandlerMethod handlerMethod)",
    "source_code": "\tprotected abstract boolean supportsInternal(HandlerMethod handlerMethod);"
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract base class for classes for which {@link RequestMappingInfo} defines\n * the mapping between a request and a handler method.\n *\n * @author Arjen Poutsma\n * @author Rossen Stoyanchev\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "signature": "public class RequestMappingInfoHandlerMapping",
    "source_code": "public abstract class RequestMappingInfoHandlerMapping extends AbstractHandlerMethodMapping<RequestMappingInfo> {\n\n\tprivate static final Method HTTP_OPTIONS_HANDLE_METHOD;\n\n\tstatic {\n\t\ttry {\n\t\t\tHTTP_OPTIONS_HANDLE_METHOD = HttpOptionsHandler.class.getMethod(\"handle\");\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\t// Should never happen\n\t\t\tthrow new IllegalStateException(\"Failed to retrieve internal handler method for HTTP OPTIONS\", ex);\n\t\t}\n\t}\n\n\n\tprotected RequestMappingInfoHandlerMapping() {\n\t\tsetHandlerMethodMappingNamingStrategy(new RequestMappingInfoHandlerMethodMappingNamingStrategy());\n\t}\n\n\n\t/**\n\t * Get the URL path patterns associated with the supplied {@link RequestMappingInfo}.\n\t */\n\t@Override\n\t@SuppressWarnings(\"deprecation\")\n\tprotected Set<String> getMappingPathPatterns(RequestMappingInfo info) {\n\t\treturn info.getPatternValues();\n\t}\n\n\t@Override\n\tprotected Set<String> getDirectPaths(RequestMappingInfo info) {\n\t\treturn info.getDirectPaths();\n\t}\n\n\t/**\n\t * Check if the given RequestMappingInfo matches the current request and\n\t * return a (potentially new) instance with conditions that match the\n\t * current request -- for example with a subset of URL patterns.\n\t * @return an info in case of a match; or {@code null} otherwise.\n\t */\n\t@Override\n\tprotected RequestMappingInfo getMatchingMapping(RequestMappingInfo info, HttpServletRequest request) {\n\t\treturn info.getMatchingCondition(request);\n\t}\n\n\t/**\n\t * Provide a Comparator to sort RequestMappingInfos matched to a request.\n\t */\n\t@Override\n\tprotected Comparator<RequestMappingInfo> getMappingComparator(final HttpServletRequest request) {\n\t\treturn (info1, info2) -> info1.compareTo(info2, request);\n\t}\n\n\t@Override\n\t@Nullable\n\tprotected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception {\n\t\trequest.removeAttribute(PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);\n\t\ttry {\n\t\t\treturn super.getHandlerInternal(request);\n\t\t}\n\t\tfinally {\n\t\t\tProducesRequestCondition.clearMediaTypesAttribute(request);\n\t\t}\n\t}\n\n\t/**\n\t * Expose URI template variables, matrix variables, and producible media types in the request.\n\t * @see HandlerMapping#URI_TEMPLATE_VARIABLES_ATTRIBUTE\n\t * @see HandlerMapping#MATRIX_VARIABLES_ATTRIBUTE\n\t * @see HandlerMapping#PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE\n\t */\n\t@Override\n\tprotected void handleMatch(RequestMappingInfo info, String lookupPath, HttpServletRequest request) {\n\t\tsuper.handleMatch(info, lookupPath, request);\n\n\t\tRequestCondition<?> condition = info.getActivePatternsCondition();\n\t\tif (condition instanceof PathPatternsRequestCondition pprc) {\n\t\t\textractMatchDetails(pprc, lookupPath, request);\n\t\t}\n\t\telse {\n\t\t\textractMatchDetails((PatternsRequestCondition) condition, lookupPath, request);\n\t\t}\n\n\t\tProducesRequestCondition producesCondition = info.getProducesCondition();\n\t\tif (!producesCondition.isEmpty()) {\n\t\t\tSet<MediaType> mediaTypes = producesCondition.getProducibleMediaTypes();\n\t\t\tif (!mediaTypes.isEmpty()) {\n\t\t\t\trequest.setAttribute(PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE, mediaTypes);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void extractMatchDetails(\n\t\t\tPathPatternsRequestCondition condition, String lookupPath, HttpServletRequest request) {\n\n\t\tPathPattern bestPattern;\n\t\tMap<String, String> uriVariables;\n\t\tif (condition.isEmptyPathMapping()) {\n\t\t\tbestPattern = condition.getFirstPattern();\n\t\t\turiVariables = Collections.emptyMap();\n\t\t}\n\t\telse {\n\t\t\tPathContainer path = ServletRequestPathUtils.getParsedRequestPath(request).pathWithinApplication();\n\t\t\tbestPattern = condition.getFirstPattern();\n\t\t\tPathPattern.PathMatchInfo result = bestPattern.matchAndExtract(path);\n\t\t\tAssert.notNull(result, () ->\n\t\t\t\t\t\"Expected bestPattern: \" + bestPattern + \" to match lookupPath \" + path);\n\t\t\turiVariables = result.getUriVariables();\n\t\t\trequest.setAttribute(MATRIX_VARIABLES_ATTRIBUTE, result.getMatrixVariables());\n\t\t}\n\t\trequest.setAttribute(BEST_MATCHING_PATTERN_ATTRIBUTE, bestPattern.getPatternString());\n\t\tServerHttpObservationFilter.findObservationContext(request)\n\t\t\t\t.ifPresent(context -> context.setPathPattern(bestPattern.getPatternString()));\n\t\trequest.setAttribute(URI_TEMPLATE_VARIABLES_ATTRIBUTE, uriVariables);\n\t}\n\n\tprivate void extractMatchDetails(\n\t\t\tPatternsRequestCondition condition, String lookupPath, HttpServletRequest request) {\n\n\t\tString bestPattern;\n\t\tMap<String, String> uriVariables;\n\t\tif (condition.isEmptyPathMapping()) {\n\t\t\tbestPattern = lookupPath;\n\t\t\turiVariables = Collections.emptyMap();\n\t\t}\n\t\telse {\n\t\t\tbestPattern = condition.getPatterns().iterator().next();\n\t\t\turiVariables = getPathMatcher().extractUriTemplateVariables(bestPattern, lookupPath);\n\t\t\tif (!getUrlPathHelper().shouldRemoveSemicolonContent()) {\n\t\t\t\trequest.setAttribute(MATRIX_VARIABLES_ATTRIBUTE, extractMatrixVariables(request, uriVariables));\n\t\t\t}\n\t\t\turiVariables = getUrlPathHelper().decodePathVariables(request, uriVariables);\n\t\t}\n\t\trequest.setAttribute(BEST_MATCHING_PATTERN_ATTRIBUTE, bestPattern);\n\t\tServerHttpObservationFilter.findObservationContext(request)\n\t\t\t\t.ifPresent(context -> context.setPathPattern(bestPattern));\n\t\trequest.setAttribute(URI_TEMPLATE_VARIABLES_ATTRIBUTE, uriVariables);\n\t}\n\n\tprivate Map<String, MultiValueMap<String, String>> extractMatrixVariables(\n\t\t\tHttpServletRequest request, Map<String, String> uriVariables) {\n\n\t\tMap<String, MultiValueMap<String, String>> result = new LinkedHashMap<>();\n\t\turiVariables.forEach((uriVarKey, uriVarValue) -> {\n\n\t\t\tint equalsIndex = uriVarValue.indexOf('=');\n\t\t\tif (equalsIndex == -1) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tint semicolonIndex = uriVarValue.indexOf(';');\n\t\t\tif (semicolonIndex != -1 && semicolonIndex != 0) {\n\t\t\t\turiVariables.put(uriVarKey, uriVarValue.substring(0, semicolonIndex));\n\t\t\t}\n\n\t\t\tString matrixVariables;\n\t\t\tif (semicolonIndex == -1 || semicolonIndex == 0 || equalsIndex < semicolonIndex) {\n\t\t\t\tmatrixVariables = uriVarValue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmatrixVariables = uriVarValue.substring(semicolonIndex + 1);\n\t\t\t}\n\n\t\t\tMultiValueMap<String, String> vars = WebUtils.parseMatrixVariables(matrixVariables);\n\t\t\tresult.put(uriVarKey, getUrlPathHelper().decodeMatrixVariables(request, vars));\n\t\t});\n\t\treturn result;\n\t}\n\n\t/**\n\t * Iterate all RequestMappingInfo's once again, look if any match by URL at\n\t * least and raise exceptions according to what doesn't match.\n\t * @throws HttpRequestMethodNotSupportedException if there are matches by URL\n\t * but not by HTTP method\n\t * @throws HttpMediaTypeNotAcceptableException if there are matches by URL\n\t * but not by consumable/producible media types\n\t */\n\t@Override\n\tprotected HandlerMethod handleNoMatch(\n\t\t\tSet<RequestMappingInfo> infos, String lookupPath, HttpServletRequest request) throws ServletException {\n\n\t\tif (CollectionUtils.isEmpty(infos)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tPartialMatchHelper helper = new PartialMatchHelper(infos, request);\n\t\tif (helper.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (helper.hasMethodsMismatch()) {\n\t\t\tSet<String> methods = helper.getAllowedMethods();\n\t\t\tif (HttpMethod.OPTIONS.matches(request.getMethod())) {\n\t\t\t\tSet<MediaType> mediaTypes = helper.getConsumablePatchMediaTypes();\n\t\t\t\tHttpOptionsHandler handler = new HttpOptionsHandler(methods, mediaTypes);\n\t\t\t\treturn new HandlerMethod(handler, HTTP_OPTIONS_HANDLE_METHOD);\n\t\t\t}\n\t\t\tthrow new HttpRequestMethodNotSupportedException(request.getMethod(), methods);\n\t\t}\n\n\t\tif (helper.hasConsumesMismatch()) {\n\t\t\tSet<MediaType> mediaTypes = helper.getConsumableMediaTypes();\n\t\t\tMediaType contentType = null;\n\t\t\tif (StringUtils.hasLength(request.getContentType())) {\n\t\t\t\ttry {\n\t\t\t\t\tcontentType = MediaType.parseMediaType(request.getContentType());\n\t\t\t\t}\n\t\t\t\tcatch (InvalidMediaTypeException ex) {\n\t\t\t\t\tthrow new HttpMediaTypeNotSupportedException(ex.getMessage(), new ArrayList<>(mediaTypes));\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new HttpMediaTypeNotSupportedException(\n\t\t\t\t\tcontentType, new ArrayList<>(mediaTypes), HttpMethod.valueOf(request.getMethod()));\n\t\t}\n\n\t\tif (helper.hasProducesMismatch()) {\n\t\t\tSet<MediaType> mediaTypes = helper.getProducibleMediaTypes();\n\t\t\tthrow new HttpMediaTypeNotAcceptableException(new ArrayList<>(mediaTypes));\n\t\t}\n\n\t\tif (helper.hasParamsMismatch()) {\n\t\t\tList<String[]> conditions = helper.getParamConditions();\n\t\t\tthrow new UnsatisfiedServletRequestParameterException(conditions, request.getParameterMap());\n\t\t}\n\n\t\treturn null;\n\t}\n\n\n\t/**\n\t * Aggregate all partial matches and expose methods checking across them.\n\t */\n\tprivate static final class PartialMatchHelper {\n\n\t\tprivate final List<PartialMatch> partialMatches = new ArrayList<>();\n\n\t\tPartialMatchHelper(Set<RequestMappingInfo> infos, HttpServletRequest request) {\n\t\t\tfor (RequestMappingInfo info : infos) {\n\t\t\t\tif (info.getActivePatternsCondition().getMatchingCondition(request) != null) {\n\t\t\t\t\tthis.partialMatches.add(new PartialMatch(info, request));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Whether there are any partial matches.\n\t\t */\n\t\tpublic boolean isEmpty() {\n\t\t\treturn this.partialMatches.isEmpty();\n\t\t}\n\n\t\t/**\n\t\t * Any partial matches for \"methods\"?\n\t\t */\n\t\tpublic boolean hasMethodsMismatch() {\n\t\t\tfor (PartialMatch match : this.partialMatches) {\n\t\t\t\tif (match.hasMethodsMatch()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * Any partial matches for \"methods\" and \"consumes\"?\n\t\t */\n\t\tpublic boolean hasConsumesMismatch() {\n\t\t\tfor (PartialMatch match : this.partialMatches) {\n\t\t\t\tif (match.hasConsumesMatch()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * Any partial matches for \"methods\", \"consumes\", and \"produces\"?\n\t\t */\n\t\tpublic boolean hasProducesMismatch() {\n\t\t\tfor (PartialMatch match : this.partialMatches) {\n\t\t\t\tif (match.hasProducesMatch()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * Any partial matches for \"methods\", \"consumes\", \"produces\", and \"params\"?\n\t\t */\n\t\tpublic boolean hasParamsMismatch() {\n\t\t\tfor (PartialMatch match : this.partialMatches) {\n\t\t\t\tif (match.hasParamsMatch()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * Return declared HTTP methods.\n\t\t */\n\t\tpublic Set<String> getAllowedMethods() {\n\t\t\tSet<String> result = new LinkedHashSet<>();\n\t\t\tfor (PartialMatch match : this.partialMatches) {\n\t\t\t\tfor (RequestMethod method : match.getInfo().getMethodsCondition().getMethods()) {\n\t\t\t\t\tresult.add(method.name());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t/**\n\t\t * Return declared \"consumable\" types but only among those that also\n\t\t * match the \"methods\" condition.\n\t\t */\n\t\tpublic Set<MediaType> getConsumableMediaTypes() {\n\t\t\tSet<MediaType> result = new LinkedHashSet<>();\n\t\t\tfor (PartialMatch match : this.partialMatches) {\n\t\t\t\tif (match.hasMethodsMatch()) {\n\t\t\t\t\tresult.addAll(match.getInfo().getConsumesCondition().getConsumableMediaTypes());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t/**\n\t\t * Return declared \"producible\" types but only among those that also\n\t\t * match the \"methods\" and \"consumes\" conditions.\n\t\t */\n\t\tpublic Set<MediaType> getProducibleMediaTypes() {\n\t\t\tSet<MediaType> result = new LinkedHashSet<>();\n\t\t\tfor (PartialMatch match : this.partialMatches) {\n\t\t\t\tif (match.hasConsumesMatch()) {\n\t\t\t\t\tresult.addAll(match.getInfo().getProducesCondition().getProducibleMediaTypes());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t/**\n\t\t * Return declared \"params\" conditions but only among those that also\n\t\t * match the \"methods\", \"consumes\", and \"params\" conditions.\n\t\t */\n\t\tpublic List<String[]> getParamConditions() {\n\t\t\tList<String[]> result = new ArrayList<>();\n\t\t\tfor (PartialMatch match : this.partialMatches) {\n\t\t\t\tif (match.hasProducesMatch()) {\n\t\t\t\t\tSet<NameValueExpression<String>> set = match.getInfo().getParamsCondition().getExpressions();\n\t\t\t\t\tif (!CollectionUtils.isEmpty(set)) {\n\t\t\t\t\t\tint i = 0;\n\t\t\t\t\t\tString[] array = new String[set.size()];\n\t\t\t\t\t\tfor (NameValueExpression<String> expression : set) {\n\t\t\t\t\t\t\tarray[i++] = expression.toString();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult.add(array);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t/**\n\t\t * Return declared \"consumable\" types but only among those that have\n\t\t * PATCH specified, or that have no methods at all.\n\t\t */\n\t\tpublic Set<MediaType> getConsumablePatchMediaTypes() {\n\t\t\tSet<MediaType> result = new LinkedHashSet<>();\n\t\t\tfor (PartialMatch match : this.partialMatches) {\n\t\t\t\tSet<RequestMethod> methods = match.getInfo().getMethodsCondition().getMethods();\n\t\t\t\tif (methods.isEmpty() || methods.contains(RequestMethod.PATCH)) {\n\t\t\t\t\tresult.addAll(match.getInfo().getConsumesCondition().getConsumableMediaTypes());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\n\t\t/**\n\t\t * Container for a RequestMappingInfo that matches the URL path at least.\n\t\t */\n\t\tprivate static class PartialMatch {\n\n\t\t\tprivate final RequestMappingInfo info;\n\n\t\t\tprivate final boolean methodsMatch;\n\n\t\t\tprivate final boolean consumesMatch;\n\n\t\t\tprivate final boolean producesMatch;\n\n\t\t\tprivate final boolean paramsMatch;\n\n\t\t\t/**\n\t\t\t * Create a new {@link PartialMatch} instance.\n\t\t\t * @param info the RequestMappingInfo that matches the URL path.\n\t\t\t * @param request the current request\n\t\t\t */\n\t\t\tpublic PartialMatch(RequestMappingInfo info, HttpServletRequest request) {\n\t\t\t\tthis.info = info;\n\t\t\t\tthis.methodsMatch = (info.getMethodsCondition().getMatchingCondition(request) != null);\n\t\t\t\tthis.consumesMatch = (info.getConsumesCondition().getMatchingCondition(request) != null);\n\t\t\t\tthis.producesMatch = (info.getProducesCondition().getMatchingCondition(request) != null);\n\t\t\t\tthis.paramsMatch = (info.getParamsCondition().getMatchingCondition(request) != null);\n\t\t\t}\n\n\t\t\tpublic RequestMappingInfo getInfo() {\n\t\t\t\treturn this.info;\n\t\t\t}\n\n\t\t\tpublic boolean hasMethodsMatch() {\n\t\t\t\treturn this.methodsMatch;\n\t\t\t}\n\n\t\t\tpublic boolean hasConsumesMatch() {\n\t\t\t\treturn (hasMethodsMatch() && this.consumesMatch);\n\t\t\t}\n\n\t\t\tpublic boolean hasProducesMatch() {\n\t\t\t\treturn (hasConsumesMatch() && this.producesMatch);\n\t\t\t}\n\n\t\t\tpublic boolean hasParamsMatch() {\n\t\t\t\treturn (hasProducesMatch() && this.paramsMatch);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\treturn this.info.toString();\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Default handler for HTTP OPTIONS.\n\t */\n\tprivate static class HttpOptionsHandler {\n\n\t\tprivate final HttpHeaders headers = new HttpHeaders();\n\n\t\tpublic HttpOptionsHandler(Set<String> declaredMethods, Set<MediaType> acceptPatch) {\n\t\t\tthis.headers.setAllow(initAllowedHttpMethods(declaredMethods));\n\t\t\tthis.headers.setAcceptPatch(new ArrayList<>(acceptPatch));\n\t\t}\n\n\t\tprivate static Set<HttpMethod> initAllowedHttpMethods(Set<String> declaredMethods) {\n\t\t\tSet<HttpMethod> result = new LinkedHashSet<>(declaredMethods.size());\n\t\t\tif (declaredMethods.isEmpty()) {\n\t\t\t\tfor (HttpMethod method : HttpMethod.values()) {\n\t\t\t\t\tif (method != HttpMethod.TRACE) {\n\t\t\t\t\t\tresult.add(method);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (String method : declaredMethods) {\n\t\t\t\t\tHttpMethod httpMethod = HttpMethod.valueOf(method);\n\t\t\t\t\tresult.add(httpMethod);\n\t\t\t\t\tif (httpMethod == HttpMethod.GET) {\n\t\t\t\t\t\tresult.add(HttpMethod.HEAD);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult.add(HttpMethod.OPTIONS);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t@SuppressWarnings(\"unused\")\n\t\tpublic HttpHeaders handle() {\n\t\t\treturn this.headers;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping#getAllowedMethods()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return declared HTTP methods.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 370
    },
    "return": "Set<String>",
    "signature": "public Set<String> getAllowedMethods()",
    "source_code": "\t\tpublic Set<String> getAllowedMethods() {\n\t\t\tSet<String> result = new LinkedHashSet<>();\n\t\t\tfor (PartialMatch match : this.partialMatches) {\n\t\t\t\tfor (RequestMethod method : match.getInfo().getMethodsCondition().getMethods()) {\n\t\t\t\t\tresult.add(method.name());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping#getConsumableMediaTypes()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return declared \"consumable\" types but only among those that also\n\t\t * match the \"methods\" condition.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "Set<MediaType>",
    "signature": "public Set<MediaType> getConsumableMediaTypes()",
    "source_code": "\t\tpublic Set<MediaType> getConsumableMediaTypes() {\n\t\t\tSet<MediaType> result = new LinkedHashSet<>();\n\t\t\tfor (PartialMatch match : this.partialMatches) {\n\t\t\t\tif (match.hasMethodsMatch()) {\n\t\t\t\t\tresult.addAll(match.getInfo().getConsumesCondition().getConsumableMediaTypes());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping#getConsumablePatchMediaTypes()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return declared \"consumable\" types but only among those that have\n\t\t * PATCH specified, or that have no methods at all.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 434
    },
    "return": "Set<MediaType>",
    "signature": "public Set<MediaType> getConsumablePatchMediaTypes()",
    "source_code": "\t\tpublic Set<MediaType> getConsumablePatchMediaTypes() {\n\t\t\tSet<MediaType> result = new LinkedHashSet<>();\n\t\t\tfor (PartialMatch match : this.partialMatches) {\n\t\t\t\tSet<RequestMethod> methods = match.getInfo().getMethodsCondition().getMethods();\n\t\t\t\tif (methods.isEmpty() || methods.contains(RequestMethod.PATCH)) {\n\t\t\t\t\tresult.addAll(match.getInfo().getConsumesCondition().getConsumableMediaTypes());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping#getDirectPaths(info)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "info"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "Set<String>",
    "signature": "protected Set<String> getDirectPaths(RequestMappingInfo info)",
    "source_code": "\tprotected Set<String> getDirectPaths(RequestMappingInfo info) {\n\t\treturn info.getDirectPaths();\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping#getHandlerInternal(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "HandlerMethod",
    "signature": "protected HandlerMethod getHandlerInternal(HttpServletRequest request)",
    "source_code": "\tprotected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception {\n\t\trequest.removeAttribute(PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);\n\t\ttry {\n\t\t\treturn super.getHandlerInternal(request);\n\t\t}\n\t\tfinally {\n\t\t\tProducesRequestCondition.clearMediaTypesAttribute(request);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping#getInfo()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 474
    },
    "return": "RequestMappingInfo",
    "signature": "public RequestMappingInfo getInfo()",
    "source_code": "\t\t\tpublic RequestMappingInfo getInfo() {\n\t\t\t\treturn this.info;\n\t\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping#getMappingComparator(request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide a Comparator to sort RequestMappingInfos matched to a request.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "Comparator<RequestMappingInfo>",
    "signature": "protected Comparator<RequestMappingInfo> getMappingComparator(final HttpServletRequest request)",
    "source_code": "\tprotected Comparator<RequestMappingInfo> getMappingComparator(final HttpServletRequest request) {\n\t\treturn (info1, info2) -> info1.compareTo(info2, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping#getMappingPathPatterns(info)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the URL path patterns associated with the supplied {@link RequestMappingInfo}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "info"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "Set<String>",
    "signature": "protected Set<String> getMappingPathPatterns(RequestMappingInfo info)",
    "source_code": "\tprotected Set<String> getMappingPathPatterns(RequestMappingInfo info) {\n\t\treturn info.getPatternValues();\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping#getMatchingMapping(info,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check if the given RequestMappingInfo matches the current request and\n\t * return a (potentially new) instance with conditions that match the\n\t * current request -- for example with a subset of URL patterns.\n\t * @return an info in case of a match; or {@code null} otherwise.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "info",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "RequestMappingInfo",
    "signature": "protected RequestMappingInfo getMatchingMapping(RequestMappingInfo info, HttpServletRequest request)",
    "source_code": "\tprotected RequestMappingInfo getMatchingMapping(RequestMappingInfo info, HttpServletRequest request) {\n\t\treturn info.getMatchingCondition(request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping#getParamConditions()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return declared \"params\" conditions but only among those that also\n\t\t * match the \"methods\", \"consumes\", and \"params\" conditions.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 412
    },
    "return": "List<String[]>",
    "signature": "public List<String[]> getParamConditions()",
    "source_code": "\t\tpublic List<String[]> getParamConditions() {\n\t\t\tList<String[]> result = new ArrayList<>();\n\t\t\tfor (PartialMatch match : this.partialMatches) {\n\t\t\t\tif (match.hasProducesMatch()) {\n\t\t\t\t\tSet<NameValueExpression<String>> set = match.getInfo().getParamsCondition().getExpressions();\n\t\t\t\t\tif (!CollectionUtils.isEmpty(set)) {\n\t\t\t\t\t\tint i = 0;\n\t\t\t\t\t\tString[] array = new String[set.size()];\n\t\t\t\t\t\tfor (NameValueExpression<String> expression : set) {\n\t\t\t\t\t\t\tarray[i++] = expression.toString();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult.add(array);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping#getProducibleMediaTypes()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return declared \"producible\" types but only among those that also\n\t\t * match the \"methods\" and \"consumes\" conditions.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 398
    },
    "return": "Set<MediaType>",
    "signature": "public Set<MediaType> getProducibleMediaTypes()",
    "source_code": "\t\tpublic Set<MediaType> getProducibleMediaTypes() {\n\t\t\tSet<MediaType> result = new LinkedHashSet<>();\n\t\t\tfor (PartialMatch match : this.partialMatches) {\n\t\t\t\tif (match.hasConsumesMatch()) {\n\t\t\t\t\tresult.addAll(match.getInfo().getProducesCondition().getProducibleMediaTypes());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping#handle()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 537
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders handle()",
    "source_code": "\t\tpublic HttpHeaders handle() {\n\t\t\treturn this.headers;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping#handleMatch(info,lookupPath,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Expose URI template variables, matrix variables, and producible media types in the request.\n\t * @see HandlerMapping#URI_TEMPLATE_VARIABLES_ATTRIBUTE\n\t * @see HandlerMapping#MATRIX_VARIABLES_ATTRIBUTE\n\t * @see HandlerMapping#PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "info",
      "lookupPath",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "void",
    "signature": "protected void handleMatch(RequestMappingInfo info, String lookupPath, HttpServletRequest request)",
    "source_code": "\tprotected void handleMatch(RequestMappingInfo info, String lookupPath, HttpServletRequest request) {\n\t\tsuper.handleMatch(info, lookupPath, request);\n\n\t\tRequestCondition<?> condition = info.getActivePatternsCondition();\n\t\tif (condition instanceof PathPatternsRequestCondition pprc) {\n\t\t\textractMatchDetails(pprc, lookupPath, request);\n\t\t}\n\t\telse {\n\t\t\textractMatchDetails((PatternsRequestCondition) condition, lookupPath, request);\n\t\t}\n\n\t\tProducesRequestCondition producesCondition = info.getProducesCondition();\n\t\tif (!producesCondition.isEmpty()) {\n\t\t\tSet<MediaType> mediaTypes = producesCondition.getProducibleMediaTypes();\n\t\t\tif (!mediaTypes.isEmpty()) {\n\t\t\t\trequest.setAttribute(PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE, mediaTypes);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping#handleNoMatch(infos,lookupPath,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Iterate all RequestMappingInfo's once again, look if any match by URL at\n\t * least and raise exceptions according to what doesn't match.\n\t * @throws HttpRequestMethodNotSupportedException if there are matches by URL\n\t * but not by HTTP method\n\t * @throws HttpMediaTypeNotAcceptableException if there are matches by URL\n\t * but not by consumable/producible media types\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "infos",
      "lookupPath",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "HandlerMethod",
    "signature": "protected HandlerMethod handleNoMatch(Set<RequestMappingInfo> infos, String lookupPath, HttpServletRequest request)",
    "source_code": "\tprotected HandlerMethod handleNoMatch("
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping#hasConsumesMatch()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 482
    },
    "return": "boolean",
    "signature": "public boolean hasConsumesMatch()",
    "source_code": "\t\t\tpublic boolean hasConsumesMatch() {\n\t\t\t\treturn (hasMethodsMatch() && this.consumesMatch);\n\t\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping#hasConsumesMismatch()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Any partial matches for \"methods\" and \"consumes\"?\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "boolean",
    "signature": "public boolean hasConsumesMismatch()",
    "source_code": "\t\tpublic boolean hasConsumesMismatch() {\n\t\t\tfor (PartialMatch match : this.partialMatches) {\n\t\t\t\tif (match.hasConsumesMatch()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping#hasMethodsMatch()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 478
    },
    "return": "boolean",
    "signature": "public boolean hasMethodsMatch()",
    "source_code": "\t\t\tpublic boolean hasMethodsMatch() {\n\t\t\t\treturn this.methodsMatch;\n\t\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping#hasMethodsMismatch()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Any partial matches for \"methods\"?\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 322
    },
    "return": "boolean",
    "signature": "public boolean hasMethodsMismatch()",
    "source_code": "\t\tpublic boolean hasMethodsMismatch() {\n\t\t\tfor (PartialMatch match : this.partialMatches) {\n\t\t\t\tif (match.hasMethodsMatch()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping#hasParamsMatch()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 490
    },
    "return": "boolean",
    "signature": "public boolean hasParamsMatch()",
    "source_code": "\t\t\tpublic boolean hasParamsMatch() {\n\t\t\t\treturn (hasProducesMatch() && this.paramsMatch);\n\t\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping#hasParamsMismatch()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Any partial matches for \"methods\", \"consumes\", \"produces\", and \"params\"?\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 358
    },
    "return": "boolean",
    "signature": "public boolean hasParamsMismatch()",
    "source_code": "\t\tpublic boolean hasParamsMismatch() {\n\t\t\tfor (PartialMatch match : this.partialMatches) {\n\t\t\t\tif (match.hasParamsMatch()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping#hasProducesMatch()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 486
    },
    "return": "boolean",
    "signature": "public boolean hasProducesMatch()",
    "source_code": "\t\t\tpublic boolean hasProducesMatch() {\n\t\t\t\treturn (hasConsumesMatch() && this.producesMatch);\n\t\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping#hasProducesMismatch()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Any partial matches for \"methods\", \"consumes\", and \"produces\"?\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 346
    },
    "return": "boolean",
    "signature": "public boolean hasProducesMismatch()",
    "source_code": "\t\tpublic boolean hasProducesMismatch() {\n\t\t\tfor (PartialMatch match : this.partialMatches) {\n\t\t\t\tif (match.hasProducesMatch()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping#isEmpty()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Whether there are any partial matches.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 315
    },
    "return": "boolean",
    "signature": "public boolean isEmpty()",
    "source_code": "\t\tpublic boolean isEmpty() {\n\t\t\treturn this.partialMatches.isEmpty();\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 495
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\t\tpublic String toString() {\n\t\t\t\treturn this.info.toString();\n\t\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.AbstractMappingJacksonResponseBodyAdvice": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A convenient base class for {@code ResponseBodyAdvice} implementations\n * that customize the response before JSON serialization with\n * {@link AbstractJackson2HttpMessageConverter}'s concrete subclasses.\n *\n * @author Rossen Stoyanchev\n * @author Sebastien Deleuze\n * @since 4.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "signature": "public class AbstractMappingJacksonResponseBodyAdvice",
    "source_code": "public abstract class AbstractMappingJacksonResponseBodyAdvice implements ResponseBodyAdvice<Object> {\n\n\t@Override\n\tpublic boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType) {\n\t\treturn AbstractJackson2HttpMessageConverter.class.isAssignableFrom(converterType);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic final Object beforeBodyWrite(@Nullable Object body, MethodParameter returnType,\n\t\t\tMediaType contentType, Class<? extends HttpMessageConverter<?>> converterType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response) {\n\n\t\tif (body == null) {\n\t\t\treturn null;\n\t\t}\n\t\tMappingJacksonValue container = getOrCreateContainer(body);\n\t\tbeforeBodyWriteInternal(container, contentType, returnType, request, response);\n\t\treturn container;\n\t}\n\n\t/**\n\t * Wrap the body in a {@link MappingJacksonValue} value container (for providing\n\t * additional serialization instructions) or simply cast it if already wrapped.\n\t */\n\tprotected MappingJacksonValue getOrCreateContainer(Object body) {\n\t\treturn (body instanceof MappingJacksonValue mjv ? mjv : new MappingJacksonValue(body));\n\t}\n\n\t/**\n\t * Invoked only if the converter type is {@code MappingJackson2HttpMessageConverter}.\n\t */\n\tprotected abstract void beforeBodyWriteInternal(MappingJacksonValue bodyContainer, MediaType contentType,\n\t\t\tMethodParameter returnType, ServerHttpRequest request, ServerHttpResponse response);\n\n}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.AbstractMappingJacksonResponseBodyAdvice#beforeBodyWrite(body,returnType,contentType,converterType,request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "returnType",
      "contentType",
      "converterType",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "return": "Object",
    "signature": "public Object beforeBodyWrite(@Nullable Object body, MethodParameter returnType,\n\t\t\tMediaType contentType, Class<? extends HttpMessageConverter<?>> converterType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tpublic final Object beforeBodyWrite(@Nullable Object body, MethodParameter returnType,"
  },
  "org.springframework.web.servlet.mvc.method.annotation.AbstractMappingJacksonResponseBodyAdvice#beforeBodyWriteInternal(bodyContainer,contentType,returnType,request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked only if the converter type is {@code MappingJackson2HttpMessageConverter}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bodyContainer",
      "contentType",
      "returnType",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "protected void beforeBodyWriteInternal(MappingJacksonValue bodyContainer, MediaType contentType,\n\t\t\tMethodParameter returnType, ServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tprotected abstract void beforeBodyWriteInternal(MappingJacksonValue bodyContainer, MediaType contentType,"
  },
  "org.springframework.web.servlet.mvc.method.annotation.AbstractMappingJacksonResponseBodyAdvice#getOrCreateContainer(body)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Wrap the body in a {@link MappingJacksonValue} value container (for providing\n\t * additional serialization instructions) or simply cast it if already wrapped.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "body"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "MappingJacksonValue",
    "signature": "protected MappingJacksonValue getOrCreateContainer(Object body)",
    "source_code": "\tprotected MappingJacksonValue getOrCreateContainer(Object body) {\n\t\treturn (body instanceof MappingJacksonValue mjv ? mjv : new MappingJacksonValue(body));\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.AbstractMappingJacksonResponseBodyAdvice#supports(returnType,converterType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnType",
      "converterType"
    ],
    "position": {
      "column": 1,
      "line": 40
    },
    "return": "boolean",
    "signature": "public boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType)",
    "source_code": "\tpublic boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType) {\n\t\treturn AbstractJackson2HttpMessageConverter.class.isAssignableFrom(converterType);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A base class for resolving method argument values by reading from the body of\n * a request with {@link HttpMessageConverter HttpMessageConverters}.\n *\n * @author Arjen Poutsma\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "signature": "public class AbstractMessageConverterMethodArgumentResolver",
    "source_code": "public abstract class AbstractMessageConverterMethodArgumentResolver implements HandlerMethodArgumentResolver {\n\n\tprivate static final Set<HttpMethod> SUPPORTED_METHODS = Set.of(HttpMethod.POST, HttpMethod.PUT, HttpMethod.PATCH);\n\n\tprivate static final Object NO_VALUE = new Object();\n\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\tprotected final List<HttpMessageConverter<?>> messageConverters;\n\n\tprivate final RequestResponseBodyAdviceChain advice;\n\n\n\t/**\n\t * Basic constructor with converters only.\n\t */\n\tpublic AbstractMessageConverterMethodArgumentResolver(List<HttpMessageConverter<?>> converters) {\n\t\tthis(converters, null);\n\t}\n\n\t/**\n\t * Constructor with converters and {@code Request~} and {@code ResponseBodyAdvice}.\n\t * @since 4.2\n\t */\n\tpublic AbstractMessageConverterMethodArgumentResolver(List<HttpMessageConverter<?>> converters,\n\t\t\t@Nullable List<Object> requestResponseBodyAdvice) {\n\n\t\tAssert.notEmpty(converters, \"'messageConverters' must not be empty\");\n\t\tthis.messageConverters = converters;\n\t\tthis.advice = new RequestResponseBodyAdviceChain(requestResponseBodyAdvice);\n\t}\n\n\n\t/**\n\t * Return the configured {@link RequestBodyAdvice} and\n\t * {@link RequestBodyAdvice} where each instance may be wrapped as a\n\t * {@link org.springframework.web.method.ControllerAdviceBean ControllerAdviceBean}.\n\t */\n\tRequestResponseBodyAdviceChain getAdvice() {\n\t\treturn this.advice;\n\t}\n\n\t/**\n\t * Create the method argument value of the expected parameter type by\n\t * reading from the given request.\n\t * @param <T> the expected type of the argument value to be created\n\t * @param webRequest the current request\n\t * @param parameter the method parameter descriptor (may be {@code null})\n\t * @param paramType the type of the argument value to be created\n\t * @return the created method argument value\n\t * @throws IOException if the reading from the request fails\n\t * @throws HttpMediaTypeNotSupportedException if no suitable message converter is found\n\t */\n\t@Nullable\n\tprotected <T> Object readWithMessageConverters(NativeWebRequest webRequest, MethodParameter parameter,\n\t\t\tType paramType) throws IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException {\n\n\t\tHttpInputMessage inputMessage = createInputMessage(webRequest);\n\t\treturn readWithMessageConverters(inputMessage, parameter, paramType);\n\t}\n\n\t/**\n\t * Create the method argument value of the expected parameter type by reading\n\t * from the given HttpInputMessage.\n\t * @param <T> the expected type of the argument value to be created\n\t * @param inputMessage the HTTP input message representing the current request\n\t * @param parameter the method parameter descriptor\n\t * @param targetType the target type, not necessarily the same as the method\n\t * parameter type, e.g. for {@code HttpEntity<String>}.\n\t * @return the created method argument value\n\t * @throws IOException if the reading from the request fails\n\t * @throws HttpMediaTypeNotSupportedException if no suitable message converter is found\n\t */\n\t@Nullable\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n\tprotected <T> Object readWithMessageConverters(HttpInputMessage inputMessage, MethodParameter parameter,\n\t\t\tType targetType) throws IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException {\n\n\t\tClass<?> contextClass = parameter.getContainingClass();\n\t\tClass<T> targetClass = (targetType instanceof Class clazz ? clazz : null);\n\t\tif (targetClass == null) {\n\t\t\tResolvableType resolvableType = ResolvableType.forMethodParameter(parameter);\n\t\t\ttargetClass = (Class<T>) resolvableType.resolve();\n\t\t}\n\n\t\tMediaType contentType;\n\t\tboolean noContentType = false;\n\t\ttry {\n\t\t\tcontentType = inputMessage.getHeaders().getContentType();\n\t\t}\n\t\tcatch (InvalidMediaTypeException ex) {\n\t\t\tthrow new HttpMediaTypeNotSupportedException(\n\t\t\t\t\tex.getMessage(), getSupportedMediaTypes(targetClass != null ? targetClass : Object.class));\n\t\t}\n\t\tif (contentType == null) {\n\t\t\tnoContentType = true;\n\t\t\tcontentType = MediaType.APPLICATION_OCTET_STREAM;\n\t\t}\n\n\t\tHttpMethod httpMethod = (inputMessage instanceof HttpRequest httpRequest ? httpRequest.getMethod() : null);\n\t\tObject body = NO_VALUE;\n\n\t\tEmptyBodyCheckingHttpInputMessage message = null;\n\t\ttry {\n\t\t\tmessage = new EmptyBodyCheckingHttpInputMessage(inputMessage);\n\n\t\t\tfor (HttpMessageConverter<?> converter : this.messageConverters) {\n\t\t\t\tClass<HttpMessageConverter<?>> converterType = (Class<HttpMessageConverter<?>>) converter.getClass();\n\t\t\t\tGenericHttpMessageConverter<?> genericConverter =\n\t\t\t\t\t\t(converter instanceof GenericHttpMessageConverter ghmc ? ghmc : null);\n\t\t\t\tif (genericConverter != null ? genericConverter.canRead(targetType, contextClass, contentType) :\n\t\t\t\t\t\t(targetClass != null && converter.canRead(targetClass, contentType))) {\n\t\t\t\t\tif (message.hasBody()) {\n\t\t\t\t\t\tHttpInputMessage msgToUse =\n\t\t\t\t\t\t\t\tgetAdvice().beforeBodyRead(message, parameter, targetType, converterType);\n\t\t\t\t\t\tbody = (genericConverter != null ? genericConverter.read(targetType, contextClass, msgToUse) :\n\t\t\t\t\t\t\t\t((HttpMessageConverter<T>) converter).read(targetClass, msgToUse));\n\t\t\t\t\t\tbody = getAdvice().afterBodyRead(body, msgToUse, parameter, targetType, converterType);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbody = getAdvice().handleEmptyBody(null, message, parameter, targetType, converterType);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new HttpMessageNotReadableException(\"I/O error while reading input message\", ex, inputMessage);\n\t\t}\n\t\tfinally {\n\t\t\tif (message != null && message.hasBody()) {\n\t\t\t\tcloseStreamIfNecessary(message.getBody());\n\t\t\t}\n\t\t}\n\n\t\tif (body == NO_VALUE) {\n\t\t\tif (httpMethod == null || !SUPPORTED_METHODS.contains(httpMethod) ||\n\t\t\t\t\t(noContentType && !message.hasBody())) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthrow new HttpMediaTypeNotSupportedException(contentType,\n\t\t\t\t\tgetSupportedMediaTypes(targetClass != null ? targetClass : Object.class), httpMethod);\n\t\t}\n\n\t\tMediaType selectedContentType = contentType;\n\t\tObject theBody = body;\n\t\tLogFormatUtils.traceDebug(logger, traceOn -> {\n\t\t\tString formatted = LogFormatUtils.formatValue(theBody, !traceOn);\n\t\t\treturn \"Read \\\"\" + selectedContentType + \"\\\" to [\" + formatted + \"]\";\n\t\t});\n\n\t\treturn body;\n\t}\n\n\t/**\n\t * Create a new {@link HttpInputMessage} from the given {@link NativeWebRequest}.\n\t * @param webRequest the web request to create an input message from\n\t * @return the input message\n\t */\n\tprotected ServletServerHttpRequest createInputMessage(NativeWebRequest webRequest) {\n\t\tHttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class);\n\t\tAssert.state(servletRequest != null, \"No HttpServletRequest\");\n\t\treturn new ServletServerHttpRequest(servletRequest);\n\t}\n\n\t/**\n\t * Validate the binding target if applicable.\n\t * <p>The default implementation checks for {@code @jakarta.validation.Valid},\n\t * Spring's {@link org.springframework.validation.annotation.Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param binder the DataBinder to be used\n\t * @param parameter the method parameter descriptor\n\t * @since 4.1.5\n\t * @see #isBindExceptionRequired\n\t */\n\tprotected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter) {\n\t\tAnnotation[] annotations = parameter.getParameterAnnotations();\n\t\tfor (Annotation ann : annotations) {\n\t\t\tObject[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);\n\t\t\tif (validationHints != null) {\n\t\t\t\tbinder.validate(validationHints);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Whether to raise a fatal bind exception on validation errors.\n\t * @param binder the data binder used to perform data binding\n\t * @param parameter the method parameter descriptor\n\t * @return {@code true} if the next method argument is not of type {@link Errors}\n\t * @since 4.1.5\n\t */\n\tprotected boolean isBindExceptionRequired(WebDataBinder binder, MethodParameter parameter) {\n\t\tint i = parameter.getParameterIndex();\n\t\tClass<?>[] paramTypes = parameter.getExecutable().getParameterTypes();\n\t\tboolean hasBindingResult = (paramTypes.length > (i + 1) && Errors.class.isAssignableFrom(paramTypes[i + 1]));\n\t\treturn !hasBindingResult;\n\t}\n\n\t/**\n\t * Return the media types supported by all provided message converters sorted\n\t * by specificity via {@link MimeTypeUtils#sortBySpecificity(List)}.\n\t * @since 5.3.4\n\t */\n\tprotected List<MediaType> getSupportedMediaTypes(Class<?> clazz) {\n\t\tSet<MediaType> mediaTypeSet = new LinkedHashSet<>();\n\t\tfor (HttpMessageConverter<?> converter : this.messageConverters) {\n\t\t\tmediaTypeSet.addAll(converter.getSupportedMediaTypes(clazz));\n\t\t}\n\t\tList<MediaType> result = new ArrayList<>(mediaTypeSet);\n\t\tMimeTypeUtils.sortBySpecificity(result);\n\t\treturn result;\n\t}\n\n\t/**\n\t * Adapt the given argument against the method parameter, if necessary.\n\t * @param arg the resolved argument\n\t * @param parameter the method parameter descriptor\n\t * @return the adapted argument, or the original resolved argument as-is\n\t * @since 4.3.5\n\t */\n\t@Nullable\n\tprotected Object adaptArgumentIfNecessary(@Nullable Object arg, MethodParameter parameter) {\n\t\tif (parameter.getParameterType() == Optional.class) {\n\t\t\tif (arg == null || (arg instanceof Collection<?> collection && collection.isEmpty()) ||\n\t\t\t\t\t(arg instanceof Object[] array && array.length == 0)) {\n\t\t\t\treturn Optional.empty();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn Optional.of(arg);\n\t\t\t}\n\t\t}\n\t\treturn arg;\n\t}\n\n\t/**\n\t * Allow for closing the body stream if necessary,\n\t * e.g. for part streams in a multipart request.\n\t */\n\tvoid closeStreamIfNecessary(InputStream body) {\n\t\t// No-op by default: A standard HttpInputMessage exposes the HTTP request stream\n\t\t// (ServletRequest#getInputStream), with its lifecycle managed by the container.\n\t}\n\n\n\tprivate static class EmptyBodyCheckingHttpInputMessage implements HttpInputMessage {\n\n\t\tprivate final HttpHeaders headers;\n\n\t\t@Nullable\n\t\tprivate final InputStream body;\n\n\t\tpublic EmptyBodyCheckingHttpInputMessage(HttpInputMessage inputMessage) throws IOException {\n\t\t\tthis.headers = inputMessage.getHeaders();\n\t\t\tInputStream inputStream = inputMessage.getBody();\n\t\t\tif (inputStream.markSupported()) {\n\t\t\t\tinputStream.mark(1);\n\t\t\t\tthis.body = (inputStream.read() != -1 ? inputStream : null);\n\t\t\t\tinputStream.reset();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tPushbackInputStream pushbackInputStream = new PushbackInputStream(inputStream);\n\t\t\t\tint b = pushbackInputStream.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tthis.body = null;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.body = pushbackInputStream;\n\t\t\t\t\tpushbackInputStream.unread(b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic HttpHeaders getHeaders() {\n\t\t\treturn this.headers;\n\t\t}\n\n\t\t@Override\n\t\tpublic InputStream getBody() {\n\t\t\treturn (this.body != null ? this.body : InputStream.nullInputStream());\n\t\t}\n\n\t\tpublic boolean hasBody() {\n\t\t\treturn (this.body != null);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver#adaptArgumentIfNecessary(arg,parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Adapt the given argument against the method parameter, if necessary.\n\t * @param arg the resolved argument\n\t * @param parameter the method parameter descriptor\n\t * @return the adapted argument, or the original resolved argument as-is\n\t * @since 4.3.5\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "arg",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "Object",
    "signature": "protected Object adaptArgumentIfNecessary(@Nullable Object arg, MethodParameter parameter)",
    "source_code": "\tprotected Object adaptArgumentIfNecessary(@Nullable Object arg, MethodParameter parameter) {\n\t\tif (parameter.getParameterType() == Optional.class) {\n\t\t\tif (arg == null || (arg instanceof Collection<?> collection && collection.isEmpty()) ||\n\t\t\t\t\t(arg instanceof Object[] array && array.length == 0)) {\n\t\t\t\treturn Optional.empty();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn Optional.of(arg);\n\t\t\t}\n\t\t}\n\t\treturn arg;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver#createInputMessage(webRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link HttpInputMessage} from the given {@link NativeWebRequest}.\n\t * @param webRequest the web request to create an input message from\n\t * @return the input message\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "ServletServerHttpRequest",
    "signature": "protected ServletServerHttpRequest createInputMessage(NativeWebRequest webRequest)",
    "source_code": "\tprotected ServletServerHttpRequest createInputMessage(NativeWebRequest webRequest) {\n\t\tHttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class);\n\t\tAssert.state(servletRequest != null, \"No HttpServletRequest\");\n\t\treturn new ServletServerHttpRequest(servletRequest);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver#getBody()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 348
    },
    "return": "InputStream",
    "signature": "public InputStream getBody()",
    "source_code": "\t\tpublic InputStream getBody() {\n\t\t\treturn (this.body != null ? this.body : InputStream.nullInputStream());\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver#getHeaders()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 343
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders getHeaders()",
    "source_code": "\t\tpublic HttpHeaders getHeaders() {\n\t\t\treturn this.headers;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver#getSupportedMediaTypes(clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the media types supported by all provided message converters sorted\n\t * by specificity via {@link MimeTypeUtils#sortBySpecificity(List)}.\n\t * @since 5.3.4\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "List<MediaType>",
    "signature": "protected List<MediaType> getSupportedMediaTypes(Class<?> clazz)",
    "source_code": "\tprotected List<MediaType> getSupportedMediaTypes(Class<?> clazz) {\n\t\tSet<MediaType> mediaTypeSet = new LinkedHashSet<>();\n\t\tfor (HttpMessageConverter<?> converter : this.messageConverters) {\n\t\t\tmediaTypeSet.addAll(converter.getSupportedMediaTypes(clazz));\n\t\t}\n\t\tList<MediaType> result = new ArrayList<>(mediaTypeSet);\n\t\tMimeTypeUtils.sortBySpecificity(result);\n\t\treturn result;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver#hasBody()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 352
    },
    "return": "boolean",
    "signature": "public boolean hasBody()",
    "source_code": "\t\tpublic boolean hasBody() {\n\t\t\treturn (this.body != null);\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver#isBindExceptionRequired(binder,parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to raise a fatal bind exception on validation errors.\n\t * @param binder the data binder used to perform data binding\n\t * @param parameter the method parameter descriptor\n\t * @return {@code true} if the next method argument is not of type {@link Errors}\n\t * @since 4.1.5\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "boolean",
    "signature": "protected boolean isBindExceptionRequired(WebDataBinder binder, MethodParameter parameter)",
    "source_code": "\tprotected boolean isBindExceptionRequired(WebDataBinder binder, MethodParameter parameter) {\n\t\tint i = parameter.getParameterIndex();\n\t\tClass<?>[] paramTypes = parameter.getExecutable().getParameterTypes();\n\t\tboolean hasBindingResult = (paramTypes.length > (i + 1) && Errors.class.isAssignableFrom(paramTypes[i + 1]));\n\t\treturn !hasBindingResult;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver#readWithMessageConverters(inputMessage,parameter,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the method argument value of the expected parameter type by reading\n\t * from the given HttpInputMessage.\n\t * @param <T> the expected type of the argument value to be created\n\t * @param inputMessage the HTTP input message representing the current request\n\t * @param parameter the method parameter descriptor\n\t * @param targetType the target type, not necessarily the same as the method\n\t * parameter type, e.g. for {@code HttpEntity<String>}.\n\t * @return the created method argument value\n\t * @throws IOException if the reading from the request fails\n\t * @throws HttpMediaTypeNotSupportedException if no suitable message converter is found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "inputMessage",
      "parameter",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "Object",
    "signature": "protected Object readWithMessageConverters(HttpInputMessage inputMessage, MethodParameter parameter,\n\t\t\tType targetType)",
    "source_code": "\tprotected <T> Object readWithMessageConverters(HttpInputMessage inputMessage, MethodParameter parameter,"
  },
  "org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver#readWithMessageConverters(webRequest,parameter,paramType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the method argument value of the expected parameter type by\n\t * reading from the given request.\n\t * @param <T> the expected type of the argument value to be created\n\t * @param webRequest the current request\n\t * @param parameter the method parameter descriptor (may be {@code null})\n\t * @param paramType the type of the argument value to be created\n\t * @return the created method argument value\n\t * @throws IOException if the reading from the request fails\n\t * @throws HttpMediaTypeNotSupportedException if no suitable message converter is found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "webRequest",
      "parameter",
      "paramType"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "Object",
    "signature": "protected Object readWithMessageConverters(NativeWebRequest webRequest, MethodParameter parameter,\n\t\t\tType paramType)",
    "source_code": "\tprotected <T> Object readWithMessageConverters(NativeWebRequest webRequest, MethodParameter parameter,"
  },
  "org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver#validateIfApplicable(binder,parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Validate the binding target if applicable.\n\t * <p>The default implementation checks for {@code @jakarta.validation.Valid},\n\t * Spring's {@link org.springframework.validation.annotation.Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param binder the DataBinder to be used\n\t * @param parameter the method parameter descriptor\n\t * @since 4.1.5\n\t * @see #isBindExceptionRequired\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "void",
    "signature": "protected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter)",
    "source_code": "\tprotected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter) {\n\t\tAnnotation[] annotations = parameter.getParameterAnnotations();\n\t\tfor (Annotation ann : annotations) {\n\t\t\tObject[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);\n\t\t\tif (validationHints != null) {\n\t\t\t\tbinder.validate(validationHints);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Extends {@link AbstractMessageConverterMethodArgumentResolver} with the ability to handle method\n * return values by writing to the response with {@link HttpMessageConverter HttpMessageConverters}.\n *\n * @author Arjen Poutsma\n * @author Rossen Stoyanchev\n * @author Brian Clozel\n * @author Juergen Hoeller\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "signature": "public class AbstractMessageConverterMethodProcessor",
    "source_code": "public abstract class AbstractMessageConverterMethodProcessor extends AbstractMessageConverterMethodArgumentResolver"
  },
  "org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor#createOutputMessage(webRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Creates a new {@link HttpOutputMessage} from the given {@link NativeWebRequest}.\n\t * @param webRequest the web request to create an output message from\n\t * @return the output message\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "ServletServerHttpResponse",
    "signature": "protected ServletServerHttpResponse createOutputMessage(NativeWebRequest webRequest)",
    "source_code": "\tprotected ServletServerHttpResponse createOutputMessage(NativeWebRequest webRequest) {\n\t\tHttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class);\n\t\tAssert.state(response != null, \"No HttpServletResponse\");\n\t\treturn new ServletServerHttpResponse(response);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor#getProducibleMediaTypes(request,valueClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns the media types that can be produced.\n\t * @see #getProducibleMediaTypes(HttpServletRequest, Class, Type)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "valueClass"
    ],
    "position": {
      "column": 1,
      "line": 362
    },
    "return": "List<MediaType>",
    "signature": "protected List<MediaType> getProducibleMediaTypes(HttpServletRequest request, Class<?> valueClass)",
    "source_code": "\tprotected List<MediaType> getProducibleMediaTypes(HttpServletRequest request, Class<?> valueClass) {\n\t\treturn getProducibleMediaTypes(request, valueClass, null);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor#getProducibleMediaTypes(request,valueClass,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns the media types that can be produced. The resulting media types are:\n\t * <ul>\n\t * <li>The producible media types specified in the request mappings, or\n\t * <li>Media types of configured converters that can write the specific return value, or\n\t * <li>{@link MediaType#ALL}\n\t * </ul>\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "valueClass",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 376
    },
    "return": "List<MediaType>",
    "signature": "protected List<MediaType> getProducibleMediaTypes(HttpServletRequest request, Class<?> valueClass, @Nullable Type targetType)",
    "source_code": "\tprotected List<MediaType> getProducibleMediaTypes("
  },
  "org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor#isResourceType(value,returnType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether the returned value or the declared return type extends {@link Resource}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "returnType"
    ],
    "position": {
      "column": 1,
      "line": 339
    },
    "return": "boolean",
    "signature": "protected boolean isResourceType(@Nullable Object value, MethodParameter returnType)",
    "source_code": "\tprotected boolean isResourceType(@Nullable Object value, MethodParameter returnType) {\n\t\tClass<?> clazz = getReturnValueType(value, returnType);\n\t\treturn clazz != InputStreamResource.class && Resource.class.isAssignableFrom(clazz);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor#writeWithMessageConverters(value,returnType,inputMessage,outputMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Writes the given return type to the given output message.\n\t * @param value the value to write to the output message\n\t * @param returnType the type of the value\n\t * @param inputMessage the input messages. Used to inspect the {@code Accept} header.\n\t * @param outputMessage the output message to write to\n\t * @throws IOException thrown in case of I/O errors\n\t * @throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated\n\t * by the {@code Accept} header on the request cannot be met by the message converters\n\t * @throws HttpMessageNotWritableException thrown if a given message cannot\n\t * be written by a converter, or if the content-type chosen by the server\n\t * has no compatible converter.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "returnType",
      "inputMessage",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "void",
    "signature": "protected void writeWithMessageConverters(@Nullable T value, MethodParameter returnType,\n\t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)",
    "source_code": "\tprotected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType,"
  },
  "org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor#writeWithMessageConverters(value,returnType,webRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Writes the given return value to the given web request. Delegates to\n\t * {@link #writeWithMessageConverters(Object, MethodParameter, ServletServerHttpRequest, ServletServerHttpResponse)}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "returnType",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "void",
    "signature": "protected void writeWithMessageConverters(T value, MethodParameter returnType, NativeWebRequest webRequest)",
    "source_code": "\tprotected <T> void writeWithMessageConverters(T value, MethodParameter returnType, NativeWebRequest webRequest)"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * An {@link AbstractHandlerMethodExceptionResolver} that resolves exceptions\n * through {@code @ExceptionHandler} methods.\n *\n * <p>Support for custom argument and return value types can be added via\n * {@link #setCustomArgumentResolvers} and {@link #setCustomReturnValueHandlers}.\n * Or alternatively to re-configure all argument and return value types use\n * {@link #setArgumentResolvers} and {@link #setReturnValueHandlers(List)}.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Sebastien Deleuze\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "signature": "public class ExceptionHandlerExceptionResolver",
    "source_code": "public class ExceptionHandlerExceptionResolver extends AbstractHandlerMethodExceptionResolver"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\t// Do this first, it may add ResponseBodyAdvice beans\n\t\tinitExceptionHandlerAdviceCache();\n\t\tinitMessageConverters();\n\n\t\tif (this.argumentResolvers == null) {\n\t\t\tList<HandlerMethodArgumentResolver> resolvers = getDefaultArgumentResolvers();\n\t\t\tthis.argumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);\n\t\t}\n\t\tif (this.returnValueHandlers == null) {\n\t\t\tList<HandlerMethodReturnValueHandler> handlers = getDefaultReturnValueHandlers();\n\t\t\tthis.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#doResolveHandlerMethodException(request,response,handlerMethod,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find an {@code @ExceptionHandler} method and invoke it to handle the raised exception.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handlerMethod",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 380
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView doResolveHandlerMethodException(HttpServletRequest request,\n\t\t\tHttpServletResponse response, @Nullable HandlerMethod handlerMethod, Exception exception)",
    "source_code": "\tprotected ModelAndView doResolveHandlerMethodException(HttpServletRequest request,"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#getApplicationContext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "ApplicationContext",
    "signature": "public ApplicationContext getApplicationContext()",
    "source_code": "\tpublic ApplicationContext getApplicationContext() {\n\t\treturn this.applicationContext;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#getArgumentResolvers()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured argument resolvers, or possibly {@code null} if\n\t * not initialized yet via {@link #afterPropertiesSet()}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "HandlerMethodArgumentResolverComposite",
    "signature": "public HandlerMethodArgumentResolverComposite getArgumentResolvers()",
    "source_code": "\tpublic HandlerMethodArgumentResolverComposite getArgumentResolvers() {\n\t\treturn this.argumentResolvers;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#getContentNegotiationManager()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured {@link ContentNegotiationManager}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "ContentNegotiationManager",
    "signature": "public ContentNegotiationManager getContentNegotiationManager()",
    "source_code": "\tpublic ContentNegotiationManager getContentNegotiationManager() {\n\t\treturn this.contentNegotiationManager;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#getCustomArgumentResolvers()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the custom argument resolvers, or {@code null}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "List<HandlerMethodArgumentResolver>",
    "signature": "public List<HandlerMethodArgumentResolver> getCustomArgumentResolvers()",
    "source_code": "\tpublic List<HandlerMethodArgumentResolver> getCustomArgumentResolvers() {\n\t\treturn this.customArgumentResolvers;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#getCustomReturnValueHandlers()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the custom return value handlers, or {@code null}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "List<HandlerMethodReturnValueHandler>",
    "signature": "public List<HandlerMethodReturnValueHandler> getCustomReturnValueHandlers()",
    "source_code": "\tpublic List<HandlerMethodReturnValueHandler> getCustomReturnValueHandlers() {\n\t\treturn this.customReturnValueHandlers;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#getDefaultArgumentResolvers()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the list of argument resolvers to use including built-in resolvers\n\t * and custom resolvers provided via {@link #setCustomArgumentResolvers}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 312
    },
    "return": "List<HandlerMethodArgumentResolver>",
    "signature": "protected List<HandlerMethodArgumentResolver> getDefaultArgumentResolvers()",
    "source_code": "\tprotected List<HandlerMethodArgumentResolver> getDefaultArgumentResolvers() {\n\t\tList<HandlerMethodArgumentResolver> resolvers = new ArrayList<>();\n\n\t\t// Annotation-based argument resolution\n\t\tresolvers.add(new SessionAttributeMethodArgumentResolver());\n\t\tresolvers.add(new RequestAttributeMethodArgumentResolver());\n\n\t\t// Type-based argument resolution\n\t\tresolvers.add(new ServletRequestMethodArgumentResolver());\n\t\tresolvers.add(new ServletResponseMethodArgumentResolver());\n\t\tresolvers.add(new RedirectAttributesMethodArgumentResolver());\n\t\tresolvers.add(new ModelMethodProcessor());\n\n\t\t// Custom arguments\n\t\tif (getCustomArgumentResolvers() != null) {\n\t\t\tresolvers.addAll(getCustomArgumentResolvers());\n\t\t}\n\n\t\t// Catch-all\n\t\tresolvers.add(new PrincipalMethodArgumentResolver());\n\n\t\treturn resolvers;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#getDefaultReturnValueHandlers()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the list of return value handlers to use including built-in and\n\t * custom handlers provided via {@link #setReturnValueHandlers}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 340
    },
    "return": "List<HandlerMethodReturnValueHandler>",
    "signature": "protected List<HandlerMethodReturnValueHandler> getDefaultReturnValueHandlers()",
    "source_code": "\tprotected List<HandlerMethodReturnValueHandler> getDefaultReturnValueHandlers() {\n\t\tList<HandlerMethodReturnValueHandler> handlers = new ArrayList<>();\n\n\t\t// Single-purpose return value types\n\t\thandlers.add(new ModelAndViewMethodReturnValueHandler());\n\t\thandlers.add(new ModelMethodProcessor());\n\t\thandlers.add(new ViewMethodReturnValueHandler());\n\t\thandlers.add(new HttpEntityMethodProcessor(\n\t\t\t\tgetMessageConverters(), this.contentNegotiationManager, this.responseBodyAdvice));\n\n\t\t// Annotation-based return value types\n\t\thandlers.add(new ServletModelAttributeMethodProcessor(false));\n\t\thandlers.add(new RequestResponseBodyMethodProcessor(\n\t\t\t\tgetMessageConverters(), this.contentNegotiationManager, this.responseBodyAdvice));\n\n\t\t// Multi-purpose return value types\n\t\thandlers.add(new ViewNameMethodReturnValueHandler());\n\t\thandlers.add(new MapMethodProcessor());\n\n\t\t// Custom return value types\n\t\tif (getCustomReturnValueHandlers() != null) {\n\t\t\thandlers.addAll(getCustomReturnValueHandlers());\n\t\t}\n\n\t\t// Catch-all\n\t\thandlers.add(new ServletModelAttributeMethodProcessor(true));\n\n\t\treturn handlers;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#getExceptionHandlerAdviceCache()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return an unmodifiable Map with the {@link ControllerAdvice @ControllerAdvice}\n\t * beans discovered in the ApplicationContext. The returned map will be empty if\n\t * the method is invoked before the bean has been initialized via\n\t * {@link #afterPropertiesSet()}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "ExceptionHandlerMethodResolver>",
    "signature": "public ExceptionHandlerMethodResolver> getExceptionHandlerAdviceCache()",
    "source_code": "\tpublic Map<ControllerAdviceBean, ExceptionHandlerMethodResolver> getExceptionHandlerAdviceCache() {\n\t\treturn Collections.unmodifiableMap(this.exceptionHandlerAdviceCache);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#getExceptionHandlerMethod(handlerMethod,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find an {@code @ExceptionHandler} method for the given exception. The default\n\t * implementation searches methods in the class hierarchy of the controller first\n\t * and if not found, it continues searching for additional {@code @ExceptionHandler}\n\t * methods assuming some {@linkplain ControllerAdvice @ControllerAdvice}\n\t * Spring-managed beans were detected.\n\t * @param handlerMethod the method where the exception was raised (may be {@code null})\n\t * @param exception the raised exception\n\t * @return a method to handle the exception, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handlerMethod",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 455
    },
    "return": "ServletInvocableHandlerMethod",
    "signature": "protected ServletInvocableHandlerMethod getExceptionHandlerMethod(@Nullable HandlerMethod handlerMethod, Exception exception)",
    "source_code": "\tprotected ServletInvocableHandlerMethod getExceptionHandlerMethod("
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#getReturnValueHandlers()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured handlers, or possibly {@code null} if not\n\t * initialized yet via {@link #afterPropertiesSet()}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "HandlerMethodReturnValueHandlerComposite",
    "signature": "public HandlerMethodReturnValueHandlerComposite getReturnValueHandlers()",
    "source_code": "\tpublic HandlerMethodReturnValueHandlerComposite getReturnValueHandlers() {\n\t\treturn this.returnValueHandlers;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#hasGlobalExceptionHandlers()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 371
    },
    "return": "boolean",
    "signature": "protected boolean hasGlobalExceptionHandlers()",
    "source_code": "\tprotected boolean hasGlobalExceptionHandlers() {\n\t\treturn !this.exceptionHandlerAdviceCache.isEmpty();\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#setApplicationContext(applicationContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "applicationContext"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "void",
    "signature": "public void setApplicationContext(@Nullable ApplicationContext applicationContext)",
    "source_code": "\tpublic void setApplicationContext(@Nullable ApplicationContext applicationContext) {\n\t\tthis.applicationContext = applicationContext;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#setArgumentResolvers(argumentResolvers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the complete list of supported argument types thus overriding\n\t * the resolvers that would otherwise be configured by default.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argumentResolvers"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void setArgumentResolvers(@Nullable List<HandlerMethodArgumentResolver> argumentResolvers)",
    "source_code": "\tpublic void setArgumentResolvers(@Nullable List<HandlerMethodArgumentResolver> argumentResolvers) {\n\t\tif (argumentResolvers == null) {\n\t\t\tthis.argumentResolvers = null;\n\t\t}\n\t\telse {\n\t\t\tthis.argumentResolvers = new HandlerMethodArgumentResolverComposite();\n\t\t\tthis.argumentResolvers.addResolvers(argumentResolvers);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#setContentNegotiationManager(contentNegotiationManager)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link ContentNegotiationManager} to use to determine requested media types.\n\t * If not set, the default constructor is used.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentNegotiationManager"
    ],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "void",
    "signature": "public void setContentNegotiationManager(ContentNegotiationManager contentNegotiationManager)",
    "source_code": "\tpublic void setContentNegotiationManager(ContentNegotiationManager contentNegotiationManager) {\n\t\tthis.contentNegotiationManager = contentNegotiationManager;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#setCustomArgumentResolvers(argumentResolvers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide resolvers for custom argument types. Custom resolvers are ordered\n\t * after built-in ones. To override the built-in support for argument\n\t * resolution use {@link #setArgumentResolvers} instead.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argumentResolvers"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void setCustomArgumentResolvers(@Nullable List<HandlerMethodArgumentResolver> argumentResolvers)",
    "source_code": "\tpublic void setCustomArgumentResolvers(@Nullable List<HandlerMethodArgumentResolver> argumentResolvers) {\n\t\tthis.customArgumentResolvers = argumentResolvers;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#setCustomReturnValueHandlers(returnValueHandlers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide handlers for custom return value types. Custom handlers are\n\t * ordered after built-in ones. To override the built-in support for\n\t * return value handling use {@link #setReturnValueHandlers}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValueHandlers"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "void",
    "signature": "public void setCustomReturnValueHandlers(@Nullable List<HandlerMethodReturnValueHandler> returnValueHandlers)",
    "source_code": "\tpublic void setCustomReturnValueHandlers(@Nullable List<HandlerMethodReturnValueHandler> returnValueHandlers) {\n\t\tthis.customReturnValueHandlers = returnValueHandlers;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#setMessageConverters(messageConverters)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the message body converters to use.\n\t * <p>These converters are used to convert from and to HTTP requests and responses.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageConverters"
    ],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "void",
    "signature": "public void setMessageConverters(List<HttpMessageConverter<?>> messageConverters)",
    "source_code": "\tpublic void setMessageConverters(List<HttpMessageConverter<?>> messageConverters) {\n\t\tthis.messageConverters.clear();\n\t\tthis.messageConverters.addAll(messageConverters);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#setResponseBodyAdvice(responseBodyAdvice)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add one or more components to be invoked after the execution of a controller\n\t * method annotated with {@code @ResponseBody} or returning {@code ResponseEntity}\n\t * but before the body is written to the response with the selected\n\t * {@code HttpMessageConverter}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "responseBodyAdvice"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "void",
    "signature": "public void setResponseBodyAdvice(@Nullable List<ResponseBodyAdvice<?>> responseBodyAdvice)",
    "source_code": "\tpublic void setResponseBodyAdvice(@Nullable List<ResponseBodyAdvice<?>> responseBodyAdvice) {\n\t\tif (responseBodyAdvice != null) {\n\t\t\tthis.responseBodyAdvice.addAll(responseBodyAdvice);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#setReturnValueHandlers(returnValueHandlers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the complete list of supported return value types thus\n\t * overriding handlers that would otherwise be configured by default.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValueHandlers"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "void",
    "signature": "public void setReturnValueHandlers(@Nullable List<HandlerMethodReturnValueHandler> returnValueHandlers)",
    "source_code": "\tpublic void setReturnValueHandlers(@Nullable List<HandlerMethodReturnValueHandler> returnValueHandlers) {\n\t\tif (returnValueHandlers == null) {\n\t\t\tthis.returnValueHandlers = null;\n\t\t}\n\t\telse {\n\t\t\tthis.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite();\n\t\t\tthis.returnValueHandlers.addHandlers(returnValueHandlers);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ModelAndViewMethodReturnValueHandler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Handles return values of type {@link ModelAndView} copying view and model\n * information to the {@link ModelAndViewContainer}.\n *\n * <p>If the return value is {@code null}, the\n * {@link ModelAndViewContainer#setRequestHandled(boolean)} flag is set to\n * {@code true} to indicate the request was handled directly.\n *\n * <p>A {@link ModelAndView} return type has a set purpose. Therefore this\n * handler should be configured ahead of handlers that support any return\n * value type annotated with {@code @ModelAttribute} or {@code @ResponseBody}\n * to ensure they don't take over.\n *\n * @author Rossen Stoyanchev\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "signature": "public class ModelAndViewMethodReturnValueHandler",
    "source_code": "public class ModelAndViewMethodReturnValueHandler implements HandlerMethodReturnValueHandler {\n\n\t@Nullable\n\tprivate String[] redirectPatterns;\n\n\n\t/**\n\t * Configure one more simple patterns (as described in {@link PatternMatchUtils#simpleMatch})\n\t * to use in order to recognize custom redirect prefixes in addition to \"redirect:\".\n\t * <p>Note that simply configuring this property will not make a custom redirect prefix work.\n\t * There must be a custom {@link View} that recognizes the prefix as well.\n\t * @since 4.1\n\t */\n\tpublic void setRedirectPatterns(@Nullable String... redirectPatterns) {\n\t\tthis.redirectPatterns = redirectPatterns;\n\t}\n\n\t/**\n\t * Return the configured redirect patterns, if any.\n\t * @since 4.1\n\t */\n\t@Nullable\n\tpublic String[] getRedirectPatterns() {\n\t\treturn this.redirectPatterns;\n\t}\n\n\n\t@Override\n\tpublic boolean supportsReturnType(MethodParameter returnType) {\n\t\treturn ModelAndView.class.isAssignableFrom(returnType.getParameterType());\n\t}\n\n\t@Override\n\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {\n\n\t\tif (returnValue == null) {\n\t\t\tmavContainer.setRequestHandled(true);\n\t\t\treturn;\n\t\t}\n\n\t\tModelAndView mav = (ModelAndView) returnValue;\n\t\tif (mav.isReference()) {\n\t\t\tString viewName = mav.getViewName();\n\t\t\tmavContainer.setViewName(viewName);\n\t\t\tif (viewName != null && isRedirectViewName(viewName)) {\n\t\t\t\tmavContainer.setRedirectModelScenario(true);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tView view = mav.getView();\n\t\t\tmavContainer.setView(view);\n\t\t\tif (view instanceof SmartView smartView && smartView.isRedirectView()) {\n\t\t\t\tmavContainer.setRedirectModelScenario(true);\n\t\t\t}\n\t\t}\n\t\tmavContainer.setStatus(mav.getStatus());\n\t\tmavContainer.addAllAttributes(mav.getModel());\n\t}\n\n\t/**\n\t * Whether the given view name is a redirect view reference.\n\t * The default implementation checks the configured redirect patterns and\n\t * also if the view name starts with the \"redirect:\" prefix.\n\t * @param viewName the view name to check, never {@code null}\n\t * @return \"true\" if the given view name is recognized as a redirect view\n\t * reference; \"false\" otherwise.\n\t */\n\tprotected boolean isRedirectViewName(String viewName) {\n\t\treturn (PatternMatchUtils.simpleMatch(this.redirectPatterns, viewName) || viewName.startsWith(\"redirect:\"));\n\t}\n\n}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ModelAndViewMethodReturnValueHandler#getRedirectPatterns()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured redirect patterns, if any.\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "String[]",
    "signature": "public String[] getRedirectPatterns()",
    "source_code": "\tpublic String[] getRedirectPatterns() {\n\t\treturn this.redirectPatterns;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ModelAndViewMethodReturnValueHandler#handleReturnValue(returnValue,returnType,mavContainer,webRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "mavContainer",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "void",
    "signature": "public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest)",
    "source_code": "\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ModelAndViewMethodReturnValueHandler#isRedirectViewName(viewName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the given view name is a redirect view reference.\n\t * The default implementation checks the configured redirect patterns and\n\t * also if the view name starts with the \"redirect:\" prefix.\n\t * @param viewName the view name to check, never {@code null}\n\t * @return \"true\" if the given view name is recognized as a redirect view\n\t * reference; \"false\" otherwise.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "boolean",
    "signature": "protected boolean isRedirectViewName(String viewName)",
    "source_code": "\tprotected boolean isRedirectViewName(String viewName) {\n\t\treturn (PatternMatchUtils.simpleMatch(this.redirectPatterns, viewName) || viewName.startsWith(\"redirect:\"));\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ModelAndViewMethodReturnValueHandler#setRedirectPatterns(redirectPatterns)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure one more simple patterns (as described in {@link PatternMatchUtils#simpleMatch})\n\t * to use in order to recognize custom redirect prefixes in addition to \"redirect:\".\n\t * <p>Note that simply configuring this property will not make a custom redirect prefix work.\n\t * There must be a custom {@link View} that recognizes the prefix as well.\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "redirectPatterns"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "void",
    "signature": "public void setRedirectPatterns(@Nullable String... redirectPatterns)",
    "source_code": "\tpublic void setRedirectPatterns(@Nullable String... redirectPatterns) {\n\t\tthis.redirectPatterns = redirectPatterns;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ModelAndViewMethodReturnValueHandler#supportsReturnType(returnType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnType"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "boolean",
    "signature": "public boolean supportsReturnType(MethodParameter returnType)",
    "source_code": "\tpublic boolean supportsReturnType(MethodParameter returnType) {\n\t\treturn ModelAndView.class.isAssignableFrom(returnType.getParameterType());\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.PathVariableMethodArgumentResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Resolves method arguments annotated with an @{@link PathVariable}.\n *\n * <p>An @{@link PathVariable} is a named value that gets resolved from a URI template variable.\n * It is always required and does not have a default value to fall back on. See the base class\n * {@link org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver}\n * for more information on how named values are processed.\n *\n * <p>If the method parameter type is {@link Map}, the name specified in the annotation is used\n * to resolve the URI variable String value. The value is then converted to a {@link Map} via\n * type conversion, assuming a suitable {@link Converter} or {@link PropertyEditor} has been\n * registered.\n *\n * <p>A {@link WebDataBinder} is invoked to apply type conversion to resolved path variable\n * values that don't yet match the method parameter type.\n *\n * @author Rossen Stoyanchev\n * @author Arjen Poutsma\n * @author Juergen Hoeller\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "signature": "public class PathVariableMethodArgumentResolver",
    "source_code": "public class PathVariableMethodArgumentResolver extends AbstractNamedValueMethodArgumentResolver"
  },
  "org.springframework.web.servlet.mvc.method.annotation.PathVariableMethodArgumentResolver#contributeMethodArgument(parameter,value,builder,Map<String,uriVariables,conversionService)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "value",
      "builder",
      "Map<String",
      "uriVariables",
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void contributeMethodArgument(MethodParameter parameter, Object value,\n\t\t\tUriComponentsBuilder builder, Map<String, Object> uriVariables, ConversionService conversionService)",
    "source_code": "\tpublic void contributeMethodArgument(MethodParameter parameter, Object value,"
  },
  "org.springframework.web.servlet.mvc.method.annotation.PathVariableMethodArgumentResolver#createNamedValueInfo(parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "NamedValueInfo",
    "signature": "protected NamedValueInfo createNamedValueInfo(MethodParameter parameter)",
    "source_code": "\tprotected NamedValueInfo createNamedValueInfo(MethodParameter parameter) {\n\t\tPathVariable ann = parameter.getParameterAnnotation(PathVariable.class);\n\t\tAssert.state(ann != null, \"No PathVariable annotation\");\n\t\treturn new PathVariableNamedValueInfo(ann);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.PathVariableMethodArgumentResolver#formatUriValue(cs,sourceType,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "cs",
      "sourceType",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "String",
    "signature": "protected String formatUriValue(@Nullable ConversionService cs, @Nullable TypeDescriptor sourceType, Object value)",
    "source_code": "\tprotected String formatUriValue(@Nullable ConversionService cs, @Nullable TypeDescriptor sourceType, Object value) {\n\t\tif (value instanceof String string) {\n\t\t\treturn string;\n\t\t}\n\t\telse if (cs != null) {\n\t\t\treturn (String) cs.convert(value, sourceType, STRING_TYPE_DESCRIPTOR);\n\t\t}\n\t\telse {\n\t\t\treturn value.toString();\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.PathVariableMethodArgumentResolver#handleMissingValue(name,parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "protected void handleMissingValue(String name, MethodParameter parameter)",
    "source_code": "\tprotected void handleMissingValue(String name, MethodParameter parameter) throws ServletRequestBindingException {\n\t\tthrow new MissingPathVariableException(name, parameter);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.PathVariableMethodArgumentResolver#handleMissingValueAfterConversion(name,parameter,request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "void",
    "signature": "protected void handleMissingValueAfterConversion(String name, MethodParameter parameter, NativeWebRequest request)",
    "source_code": "\tprotected void handleMissingValueAfterConversion("
  },
  "org.springframework.web.servlet.mvc.method.annotation.PathVariableMethodArgumentResolver#handleResolvedValue(arg,name,parameter,mavContainer,request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "arg",
      "name",
      "parameter",
      "mavContainer",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "void",
    "signature": "protected void handleResolvedValue(@Nullable Object arg, String name, MethodParameter parameter,\n\t\t\t@Nullable ModelAndViewContainer mavContainer, NativeWebRequest request)",
    "source_code": "\tprotected void handleResolvedValue(@Nullable Object arg, String name, MethodParameter parameter,"
  },
  "org.springframework.web.servlet.mvc.method.annotation.PathVariableMethodArgumentResolver#resolveName(name,parameter,request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "Object",
    "signature": "protected Object resolveName(String name, MethodParameter parameter, NativeWebRequest request)",
    "source_code": "\tprotected Object resolveName(String name, MethodParameter parameter, NativeWebRequest request) throws Exception {\n\t\tMap<String, String> uriTemplateVars = (Map<String, String>) request.getAttribute(\n\t\t\t\tHandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE, RequestAttributes.SCOPE_REQUEST);\n\t\treturn (uriTemplateVars != null ? uriTemplateVars.get(name) : null);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.PathVariableMethodArgumentResolver#supportsParameter(parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "boolean",
    "signature": "public boolean supportsParameter(MethodParameter parameter)",
    "source_code": "\tpublic boolean supportsParameter(MethodParameter parameter) {\n\t\tif (!parameter.hasParameterAnnotation(PathVariable.class)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (Map.class.isAssignableFrom(parameter.nestedIfOptional().getNestedParameterType())) {\n\t\t\tPathVariable pathVariable = parameter.getParameterAnnotation(PathVariable.class);\n\t\t\treturn (pathVariable != null && StringUtils.hasText(pathVariable.value()));\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Extends {@link InvocableHandlerMethod} with the ability to handle return\n * values through a registered {@link HandlerMethodReturnValueHandler} and\n * also supports setting the response status based on a method-level\n * {@code @ResponseStatus} annotation.\n *\n * <p>A {@code null} return value (including void) may be interpreted as the\n * end of request processing in combination with a {@code @ResponseStatus}\n * annotation, a not-modified check condition\n * (see {@link ServletWebRequest#checkNotModified(long)}), or\n * a method argument that provides access to the response stream.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "signature": "public class ServletInvocableHandlerMethod",
    "source_code": "public class ServletInvocableHandlerMethod extends InvocableHandlerMethod {\n\n\tprivate static final Method CALLABLE_METHOD = ClassUtils.getMethod(Callable.class, \"call\");\n\n\t@Nullable\n\tprivate HandlerMethodReturnValueHandlerComposite returnValueHandlers;\n\n\n\t/**\n\t * Creates an instance from the given handler and method.\n\t */\n\tpublic ServletInvocableHandlerMethod(Object handler, Method method) {\n\t\tsuper(handler, method);\n\t}\n\n\t/**\n\t * Variant of {@link #ServletInvocableHandlerMethod(Object, Method)} that\n\t * also accepts a {@link MessageSource}, e.g. to resolve\n\t * {@code @ResponseStatus} messages with.\n\t * @since 5.3.10\n\t */\n\tpublic ServletInvocableHandlerMethod(Object handler, Method method, @Nullable MessageSource messageSource) {\n\t\tsuper(handler, method, messageSource);\n\t}\n\n\t/**\n\t * Create an instance from a {@code HandlerMethod}.\n\t */\n\tpublic ServletInvocableHandlerMethod(HandlerMethod handlerMethod) {\n\t\tsuper(handlerMethod);\n\t}\n\n\n\t/**\n\t * Register {@link HandlerMethodReturnValueHandler} instances to use to\n\t * handle return values.\n\t */\n\tpublic void setHandlerMethodReturnValueHandlers(HandlerMethodReturnValueHandlerComposite returnValueHandlers) {\n\t\tthis.returnValueHandlers = returnValueHandlers;\n\t}\n\n\n\t/**\n\t * Invoke the method and handle the return value through one of the\n\t * configured {@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers}.\n\t * @param webRequest the current request\n\t * @param mavContainer the ModelAndViewContainer for this request\n\t * @param providedArgs \"given\" arguments matched by type (not resolved)\n\t */\n\tpublic void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,\n\t\t\tObject... providedArgs) throws Exception {\n\n\t\tObject returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);\n\t\tsetResponseStatus(webRequest);\n\n\t\tif (returnValue == null) {\n\t\t\tif (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) {\n\t\t\t\tdisableContentCachingIfNecessary(webRequest);\n\t\t\t\tmavContainer.setRequestHandled(true);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse if (StringUtils.hasText(getResponseStatusReason())) {\n\t\t\tmavContainer.setRequestHandled(true);\n\t\t\treturn;\n\t\t}\n\n\t\tmavContainer.setRequestHandled(false);\n\t\tAssert.state(this.returnValueHandlers != null, \"No return value handlers\");\n\t\ttry {\n\t\t\tthis.returnValueHandlers.handleReturnValue(\n\t\t\t\t\treturnValue, getReturnValueType(returnValue), mavContainer, webRequest);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(formatErrorForReturnValue(returnValue), ex);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\t/**\n\t * Set the response status according to the {@link ResponseStatus} annotation.\n\t */\n\tprivate void setResponseStatus(ServletWebRequest webRequest) throws IOException {\n\t\tHttpStatusCode status = getResponseStatus();\n\t\tif (status == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tHttpServletResponse response = webRequest.getResponse();\n\t\tif (response != null) {\n\t\t\tString reason = getResponseStatusReason();\n\t\t\tif (StringUtils.hasText(reason)) {\n\t\t\t\tresponse.sendError(status.value(), reason);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresponse.setStatus(status.value());\n\t\t\t}\n\t\t}\n\n\t\t// To be picked up by RedirectView\n\t\twebRequest.getRequest().setAttribute(View.RESPONSE_STATUS_ATTRIBUTE, status);\n\t}\n\n\t/**\n\t * Does the given request qualify as \"not modified\"?\n\t * @see ServletWebRequest#checkNotModified(long)\n\t * @see ServletWebRequest#checkNotModified(String)\n\t */\n\tprivate boolean isRequestNotModified(ServletWebRequest webRequest) {\n\t\treturn webRequest.isNotModified();\n\t}\n\n\tprivate void disableContentCachingIfNecessary(ServletWebRequest webRequest) {\n\t\tif (isRequestNotModified(webRequest)) {\n\t\t\tHttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class);\n\t\t\tAssert.notNull(response, \"Expected HttpServletResponse\");\n\t\t\tif (StringUtils.hasText(response.getHeader(HttpHeaders.ETAG))) {\n\t\t\t\tHttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);\n\t\t\t\tAssert.notNull(request, \"Expected HttpServletRequest\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate String formatErrorForReturnValue(@Nullable Object returnValue) {\n\t\treturn \"Error handling return value=[\" + returnValue + \"]\" +\n\t\t\t\t(returnValue != null ? \", type=\" + returnValue.getClass().getName() : \"\") +\n\t\t\t\t\" in \" + toString();\n\t}\n\n\t/**\n\t * Create a nested ServletInvocableHandlerMethod subclass that returns the\n\t * given value (or raises an Exception if the value is one) rather than\n\t * actually invoking the controller method. This is useful when processing\n\t * async return values (e.g. Callable, DeferredResult, ListenableFuture).\n\t */\n\tServletInvocableHandlerMethod wrapConcurrentResult(Object result) {\n\t\treturn new ConcurrentResultHandlerMethod(result, new ConcurrentResultMethodParameter(result));\n\t}\n\n\n\t/**\n\t * A nested subclass of {@code ServletInvocableHandlerMethod} that uses a\n\t * simple {@link Callable} instead of the original controller as the handler in\n\t * order to return the fixed (concurrent) result value given to it. Effectively\n\t * \"resumes\" processing with the asynchronously produced return value.\n\t */\n\tprivate class ConcurrentResultHandlerMethod extends ServletInvocableHandlerMethod {\n\n\t\tprivate final MethodParameter returnType;\n\n\t\tpublic ConcurrentResultHandlerMethod(final Object result, ConcurrentResultMethodParameter returnType) {\n\t\t\tsuper((Callable<Object>) () -> {\n\t\t\t\tif (result instanceof Exception exception) {\n\t\t\t\t\tthrow exception;\n\t\t\t\t}\n\t\t\t\telse if (result instanceof Throwable throwable) {\n\t\t\t\t\tthrow new ServletException(\"Async processing failed: \" + result, throwable);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}, CALLABLE_METHOD);\n\n\t\t\tif (ServletInvocableHandlerMethod.this.returnValueHandlers != null) {\n\t\t\t\tsetHandlerMethodReturnValueHandlers(ServletInvocableHandlerMethod.this.returnValueHandlers);\n\t\t\t}\n\t\t\tthis.returnType = returnType;\n\t\t}\n\n\t\t/**\n\t\t * Bridge to actual controller type-level annotations.\n\t\t */\n\t\t@Override\n\t\tpublic Class<?> getBeanType() {\n\t\t\treturn ServletInvocableHandlerMethod.this.getBeanType();\n\t\t}\n\n\t\t/**\n\t\t * Bridge to actual return value or generic type within the declared\n\t\t * async return type, e.g. Foo instead of {@code DeferredResult<Foo>}.\n\t\t */\n\t\t@Override\n\t\tpublic MethodParameter getReturnValueType(@Nullable Object returnValue) {\n\t\t\treturn this.returnType;\n\t\t}\n\n\t\t/**\n\t\t * Bridge to controller method-level annotations.\n\t\t */\n\t\t@Override\n\t\tpublic <A extends Annotation> A getMethodAnnotation(Class<A> annotationType) {\n\t\t\treturn ServletInvocableHandlerMethod.this.getMethodAnnotation(annotationType);\n\t\t}\n\n\t\t/**\n\t\t * Bridge to controller method-level annotations.\n\t\t */\n\t\t@Override\n\t\tpublic <A extends Annotation> boolean hasMethodAnnotation(Class<A> annotationType) {\n\t\t\treturn ServletInvocableHandlerMethod.this.hasMethodAnnotation(annotationType);\n\t\t}\n\t}\n\n\n\t/**\n\t * MethodParameter subclass based on the actual return value type or if\n\t * that's null falling back on the generic type within the declared async\n\t * return type, e.g. Foo instead of {@code DeferredResult<Foo>}.\n\t */\n\tprivate class ConcurrentResultMethodParameter extends HandlerMethodParameter {\n\n\t\t@Nullable\n\t\tprivate final Object returnValue;\n\n\t\tprivate final ResolvableType returnType;\n\n\t\tpublic ConcurrentResultMethodParameter(Object returnValue) {\n\t\t\tsuper(-1);\n\t\t\tthis.returnValue = returnValue;\n\t\t\tthis.returnType = (returnValue instanceof CollectedValuesList cvList ?\n\t\t\t\t\tcvList.getReturnType() :\n\t\t\t\t\tKotlinDetector.isSuspendingFunction(super.getMethod()) ?\n\t\t\t\t\tResolvableType.forMethodParameter(getReturnType()) :\n\t\t\t\t\tResolvableType.forType(super.getGenericParameterType()).getGeneric());\n\t\t}\n\n\t\tpublic ConcurrentResultMethodParameter(ConcurrentResultMethodParameter original) {\n\t\t\tsuper(original);\n\t\t\tthis.returnValue = original.returnValue;\n\t\t\tthis.returnType = original.returnType;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<?> getParameterType() {\n\t\t\tif (this.returnValue != null) {\n\t\t\t\treturn this.returnValue.getClass();\n\t\t\t}\n\t\t\tif (!ResolvableType.NONE.equals(this.returnType)) {\n\t\t\t\treturn this.returnType.toClass();\n\t\t\t}\n\t\t\treturn super.getParameterType();\n\t\t}\n\n\t\t@Override\n\t\tpublic Type getGenericParameterType() {\n\t\t\treturn this.returnType.getType();\n\t\t}\n\n\t\t@Override\n\t\tpublic <T extends Annotation> boolean hasMethodAnnotation(Class<T> annotationType) {\n\t\t\t// Ensure @ResponseBody-style handling for values collected from a reactive type\n\t\t\t// even if actual return type is ResponseEntity<Flux<T>>\n\t\t\treturn (super.hasMethodAnnotation(annotationType) ||\n\t\t\t\t\t(annotationType == ResponseBody.class &&\n\t\t\t\t\t\t\tthis.returnValue instanceof CollectedValuesList));\n\t\t}\n\n\t\t@Override\n\t\tpublic ConcurrentResultMethodParameter clone() {\n\t\t\treturn new ConcurrentResultMethodParameter(this);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod#clone()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 324
    },
    "return": "ConcurrentResultMethodParameter",
    "signature": "public ConcurrentResultMethodParameter clone()",
    "source_code": "\t\tpublic ConcurrentResultMethodParameter clone() {\n\t\t\treturn new ConcurrentResultMethodParameter(this);\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod#getGenericParameterType()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 310
    },
    "return": "Type",
    "signature": "public Type getGenericParameterType()",
    "source_code": "\t\tpublic Type getGenericParameterType() {\n\t\t\treturn this.returnType.getType();\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod#getMethodAnnotation(annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Bridge to controller method-level annotations.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "A",
    "signature": "public A getMethodAnnotation(Class<A> annotationType)",
    "source_code": "\t\tpublic <A extends Annotation> A getMethodAnnotation(Class<A> annotationType) {\n\t\t\treturn ServletInvocableHandlerMethod.this.getMethodAnnotation(annotationType);\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod#getReturnValueType(returnValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Bridge to actual return value or generic type within the declared\n\t\t * async return type, e.g. Foo instead of {@code DeferredResult<Foo>}.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue"
    ],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter getReturnValueType(@Nullable Object returnValue)",
    "source_code": "\t\tpublic MethodParameter getReturnValueType(@Nullable Object returnValue) {\n\t\t\treturn this.returnType;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod#hasMethodAnnotation(annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 315
    },
    "return": "boolean",
    "signature": "public boolean hasMethodAnnotation(Class<T> annotationType)",
    "source_code": "\t\tpublic <T extends Annotation> boolean hasMethodAnnotation(Class<T> annotationType) {\n\t\t\t// Ensure @ResponseBody-style handling for values collected from a reactive type\n\t\t\t// even if actual return type is ResponseEntity<Flux<T>>\n\t\t\treturn (super.hasMethodAnnotation(annotationType) ||\n\t\t\t\t\t(annotationType == ResponseBody.class &&\n\t\t\t\t\t\t\tthis.returnValue instanceof CollectedValuesList));\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod#invokeAndHandle(webRequest,mavContainer,providedArgs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the method and handle the return value through one of the\n\t * configured {@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers}.\n\t * @param webRequest the current request\n\t * @param mavContainer the ModelAndViewContainer for this request\n\t * @param providedArgs \"given\" arguments matched by type (not resolved)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webRequest",
      "mavContainer",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "void",
    "signature": "public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,\n\t\t\tObject... providedArgs)",
    "source_code": "\tpublic void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod#setHandlerMethodReturnValueHandlers(returnValueHandlers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register {@link HandlerMethodReturnValueHandler} instances to use to\n\t * handle return values.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValueHandlers"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "void",
    "signature": "public void setHandlerMethodReturnValueHandlers(HandlerMethodReturnValueHandlerComposite returnValueHandlers)",
    "source_code": "\tpublic void setHandlerMethodReturnValueHandlers(HandlerMethodReturnValueHandlerComposite returnValueHandlers) {\n\t\tthis.returnValueHandlers = returnValueHandlers;\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * The default implementation of the {@link org.springframework.web.servlet.HandlerExceptionResolver}\n * interface, resolving standard Spring MVC exceptions and translating them to corresponding\n * HTTP status codes.\n *\n * <p>This exception resolver is enabled by default in the common Spring\n * {@link org.springframework.web.servlet.DispatcherServlet}.\n *\n * <table>\n * <caption>Supported Exceptions</caption>\n * <thead>\n * <tr>\n * <th class=\"colFirst\">Exception</th>\n * <th class=\"colLast\">HTTP Status Code</th>\n * </tr>\n * </thead>\n * <tbody>\n * <tr class=\"altColor\">\n * <td><p>HttpRequestMethodNotSupportedException</p></td>\n * <td><p>405 (SC_METHOD_NOT_ALLOWED)</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>HttpMediaTypeNotSupportedException</p></td>\n * <td><p>415 (SC_UNSUPPORTED_MEDIA_TYPE)</p></td>\n * </tr>\n * <tr class=\"altColor\">\n * <td><p>HttpMediaTypeNotAcceptableException</p></td>\n * <td><p>406 (SC_NOT_ACCEPTABLE)</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>MissingPathVariableException</p></td>\n * <td><p>500 (SC_INTERNAL_SERVER_ERROR)</p></td>\n * </tr>\n * <tr class=\"altColor\">\n * <td><p>MissingServletRequestParameterException</p></td>\n * <td><p>400 (SC_BAD_REQUEST)</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>MissingServletRequestPartException</p></td>\n * <td><p>400 (SC_BAD_REQUEST)</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>ServletRequestBindingException</p></td>\n * <td><p>400 (SC_BAD_REQUEST)</p></td>\n * </tr>\n * <tr class=\"altColor\">\n * <td><p>ConversionNotSupportedException</p></td>\n * <td><p>500 (SC_INTERNAL_SERVER_ERROR)</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>TypeMismatchException</p></td>\n * <td><p>400 (SC_BAD_REQUEST)</p></td>\n * </tr>\n * <tr class=\"altColor\">\n * <td><p>HttpMessageNotReadableException</p></td>\n * <td><p>400 (SC_BAD_REQUEST)</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>HttpMessageNotWritableException</p></td>\n * <td><p>500 (SC_INTERNAL_SERVER_ERROR)</p></td>\n * </tr>\n * <tr class=\"altColor\">\n * <td><p>MethodArgumentNotValidException</p></td>\n * <td><p>400 (SC_BAD_REQUEST)</p></td>\n * </tr>\n * <tr class=\"altColor\">\n * <td><p>BindException</p></td>\n * <td><p>400 (SC_BAD_REQUEST)</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>NoHandlerFoundException</p></td>\n * <td><p>404 (SC_NOT_FOUND)</p></td>\n * </tr>\n * <tr class=\"altColor\">\n * <td><p>AsyncRequestTimeoutException</p></td>\n * <td><p>503 (SC_SERVICE_UNAVAILABLE)</p></td>\n * </tr>\n * </tbody>\n * </table>\n *\n * @author Arjen Poutsma\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 3.0\n * @see org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "signature": "public class DefaultHandlerExceptionResolver",
    "source_code": "public class DefaultHandlerExceptionResolver extends AbstractHandlerExceptionResolver {\n\n\t/**\n\t * Log category to use when no mapped handler is found for a request.\n\t * @see #pageNotFoundLogger\n\t */\n\tpublic static final String PAGE_NOT_FOUND_LOG_CATEGORY = \"org.springframework.web.servlet.PageNotFound\";\n\n\t/**\n\t * Additional logger to use when no mapped handler is found for a request.\n\t * @see #PAGE_NOT_FOUND_LOG_CATEGORY\n\t */\n\tprotected static final Log pageNotFoundLogger = LogFactory.getLog(PAGE_NOT_FOUND_LOG_CATEGORY);\n\n\n\t/**\n\t * Sets the {@linkplain #setOrder(int) order} to {@link #LOWEST_PRECEDENCE}.\n\t */\n\tpublic DefaultHandlerExceptionResolver() {\n\t\tsetOrder(Ordered.LOWEST_PRECEDENCE);\n\t\tsetWarnLogCategory(getClass().getName());\n\t}\n\n\n\t@Override\n\t@Nullable\n\tprotected ModelAndView doResolveException(\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) {\n\n\t\ttry {\n\t\t\t// ErrorResponse exceptions that expose HTTP response details\n\t\t\tif (ex instanceof ErrorResponse errorResponse) {\n\t\t\t\tModelAndView mav = null;\n\t\t\t\tif (ex instanceof HttpRequestMethodNotSupportedException theEx) {\n\t\t\t\t\tmav = handleHttpRequestMethodNotSupported(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof HttpMediaTypeNotSupportedException theEx) {\n\t\t\t\t\tmav = handleHttpMediaTypeNotSupported(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof HttpMediaTypeNotAcceptableException theEx) {\n\t\t\t\t\tmav = handleHttpMediaTypeNotAcceptable(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof MissingPathVariableException theEx) {\n\t\t\t\t\tmav = handleMissingPathVariable(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof MissingServletRequestParameterException theEx) {\n\t\t\t\t\tmav = handleMissingServletRequestParameter(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof MissingServletRequestPartException theEx) {\n\t\t\t\t\tmav = handleMissingServletRequestPartException(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof ServletRequestBindingException theEx) {\n\t\t\t\t\tmav = handleServletRequestBindingException(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof MethodArgumentNotValidException theEx) {\n\t\t\t\t\tmav = handleMethodArgumentNotValidException(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof NoHandlerFoundException theEx) {\n\t\t\t\t\tmav = handleNoHandlerFoundException(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof AsyncRequestTimeoutException theEx) {\n\t\t\t\t\tmav = handleAsyncRequestTimeoutException(theEx, request, response, handler);\n\t\t\t\t}\n\n\t\t\t\treturn (mav != null ? mav :\n\t\t\t\t\t\thandleErrorResponse(errorResponse, request, response, handler));\n\t\t\t}\n\n\t\t\t// Other, lower level exceptions\n\n\t\t\tif (ex instanceof ConversionNotSupportedException theEx) {\n\t\t\t\treturn handleConversionNotSupported(theEx, request, response, handler);\n\t\t\t}\n\t\t\telse if (ex instanceof TypeMismatchException theEx) {\n\t\t\t\treturn handleTypeMismatch(theEx, request, response, handler);\n\t\t\t}\n\t\t\telse if (ex instanceof HttpMessageNotReadableException theEx) {\n\t\t\t\treturn handleHttpMessageNotReadable(theEx, request, response, handler);\n\t\t\t}\n\t\t\telse if (ex instanceof HttpMessageNotWritableException theEx) {\n\t\t\t\treturn handleHttpMessageNotWritable(theEx, request, response, handler);\n\t\t\t}\n\t\t\telse if (ex instanceof BindException theEx) {\n\t\t\t\treturn handleBindException(theEx, request, response, handler);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception handlerEx) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Failure while trying to resolve exception [\" + ex.getClass().getName() + \"]\", handlerEx);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Handle the case where no handler was found for the HTTP method.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the HttpRequestMethodNotSupportedException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen\n\t * at the time of the exception (for example, if multipart resolution failed)\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */\n\t@Nullable\n\tprotected ModelAndView handleHttpRequestMethodNotSupported(HttpRequestMethodNotSupportedException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Handle the case where no\n\t * {@linkplain org.springframework.http.converter.HttpMessageConverter message converters}\n\t * were found for PUT or POSTed content.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the HttpMediaTypeNotSupportedException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */\n\t@Nullable\n\tprotected ModelAndView handleHttpMediaTypeNotSupported(HttpMediaTypeNotSupportedException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Handle the case where no\n\t * {@linkplain org.springframework.http.converter.HttpMessageConverter message converters}\n\t * were found that were acceptable for the client (expressed via the {@code Accept} header).\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the HttpMediaTypeNotAcceptableException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */\n\t@Nullable\n\tprotected ModelAndView handleHttpMediaTypeNotAcceptable(HttpMediaTypeNotAcceptableException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Handle the case when a declared path variable does not match any extracted URI variable.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the MissingPathVariableException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @since 4.2\n\t */\n\t@Nullable\n\tprotected ModelAndView handleMissingPathVariable(MissingPathVariableException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Handle the case when a required parameter is missing.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the MissingServletRequestParameterException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */\n\t@Nullable\n\tprotected ModelAndView handleMissingServletRequestParameter(MissingServletRequestParameterException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Handle the case where an {@linkplain RequestPart @RequestPart}, a {@link MultipartFile},\n\t * or a {@code jakarta.servlet.http.Part} argument is required but is missing.\n\t * <p>By default, an HTTP 400 error is sent back to the client.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */\n\t@Nullable\n\tprotected ModelAndView handleMissingServletRequestPartException(MissingServletRequestPartException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Handle the case when an unrecoverable binding exception occurs - e.g.\n\t * required header, required cookie.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the exception to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */\n\t@Nullable\n\tprotected ModelAndView handleServletRequestBindingException(ServletRequestBindingException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Handle the case where an argument annotated with {@code @Valid} such as\n\t * an {@link RequestBody} or {@link RequestPart} argument fails validation.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */\n\t@Nullable\n\tprotected ModelAndView handleMethodArgumentNotValidException(MethodArgumentNotValidException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Handle the case where no handler was found during the dispatch.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the NoHandlerFoundException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen\n\t * at the time of the exception (for example, if multipart resolution failed)\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @since 4.0\n\t */\n\t@Nullable\n\tprotected ModelAndView handleNoHandlerFoundException(NoHandlerFoundException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\tpageNotFoundLogger.warn(ex.getMessage());\n\t\treturn null;\n\t}\n\n\t/**\n\t * Handle the case where an async request timed out.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the {@link AsyncRequestTimeoutException} to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen\n\t * at the time of the exception (for example, if multipart resolution failed)\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @since 4.2.8\n\t */\n\t@Nullable\n\tprotected ModelAndView handleAsyncRequestTimeoutException(AsyncRequestTimeoutException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Handle an {@link ErrorResponse} exception.\n\t * <p>The default implementation sets status and the headers of the response\n\t * to those obtained from the {@code ErrorResponse}. If available, the\n\t * {@link ProblemDetail#getDetail()}  is used as the message for\n\t * {@link HttpServletResponse#sendError(int, String)}.\n\t * @param errorResponse the exception to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @since 6.0\n\t */\n\tprotected ModelAndView handleErrorResponse(ErrorResponse errorResponse,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\tif (!response.isCommitted()) {\n\t\t\tHttpHeaders headers = errorResponse.getHeaders();\n\t\t\theaders.forEach((name, values) -> values.forEach(value -> response.addHeader(name, value)));\n\n\t\t\tint status = errorResponse.getStatusCode().value();\n\t\t\tString message = errorResponse.getBody().getDetail();\n\t\t\tif (message != null) {\n\t\t\t\tresponse.sendError(status, message);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresponse.sendError(status);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlogger.warn(\"Ignoring exception, response committed. : \" + errorResponse);\n\t\t}\n\n\t\treturn new ModelAndView();\n\t}\n\n\t/**\n\t * Handle the case when a {@link org.springframework.web.bind.WebDataBinder} conversion cannot occur.\n\t * <p>The default implementation sends an HTTP 500 error, and returns an empty {@code ModelAndView}.\n\t * Alternatively, a fallback view could be chosen, or the ConversionNotSupportedException could be\n\t * rethrown as-is.\n\t * @param ex the ConversionNotSupportedException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */\n\tprotected ModelAndView handleConversionNotSupported(ConversionNotSupportedException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\tsendServerError(ex, request, response);\n\t\treturn new ModelAndView();\n\t}\n\n\t/**\n\t * Handle the case when a {@link org.springframework.web.bind.WebDataBinder} conversion error occurs.\n\t * <p>The default implementation sends an HTTP 400 error, and returns an empty {@code ModelAndView}.\n\t * Alternatively, a fallback view could be chosen, or the TypeMismatchException could be rethrown as-is.\n\t * @param ex the TypeMismatchException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */\n\tprotected ModelAndView handleTypeMismatch(TypeMismatchException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\tresponse.sendError(HttpServletResponse.SC_BAD_REQUEST);\n\t\treturn new ModelAndView();\n\t}\n\n\t/**\n\t * Handle the case where a {@linkplain org.springframework.http.converter.HttpMessageConverter message converter}\n\t * cannot read from an HTTP request.\n\t * <p>The default implementation sends an HTTP 400 error, and returns an empty {@code ModelAndView}.\n\t * Alternatively, a fallback view could be chosen, or the HttpMessageNotReadableException could be\n\t * rethrown as-is.\n\t * @param ex the HttpMessageNotReadableException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */\n\tprotected ModelAndView handleHttpMessageNotReadable(HttpMessageNotReadableException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\tresponse.sendError(HttpServletResponse.SC_BAD_REQUEST);\n\t\treturn new ModelAndView();\n\t}\n\n\t/**\n\t * Handle the case where a\n\t * {@linkplain org.springframework.http.converter.HttpMessageConverter message converter}\n\t * cannot write to an HTTP request.\n\t * <p>The default implementation sends an HTTP 500 error, and returns an empty {@code ModelAndView}.\n\t * Alternatively, a fallback view could be chosen, or the HttpMessageNotWritableException could\n\t * be rethrown as-is.\n\t * @param ex the HttpMessageNotWritableException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */\n\tprotected ModelAndView handleHttpMessageNotWritable(HttpMessageNotWritableException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\tsendServerError(ex, request, response);\n\t\treturn new ModelAndView();\n\t}\n\n\t/**\n\t * Handle the case where an {@linkplain ModelAttribute @ModelAttribute} method\n\t * argument has binding or validation errors and is not followed by another\n\t * method argument of type {@link BindingResult}.\n\t * <p>By default, an HTTP 400 error is sent back to the client.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @deprecated as of 6.0 since {@link org.springframework.web.method.annotation.ModelAttributeMethodProcessor}\n\t * now raises the {@link MethodArgumentNotValidException} subclass instead.\n\t */\n\t@Deprecated(since = \"6.0\", forRemoval = true)\n\tprotected ModelAndView handleBindException(BindException ex, HttpServletRequest request,\n\t\t\tHttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\tresponse.sendError(HttpServletResponse.SC_BAD_REQUEST);\n\t\treturn new ModelAndView();\n\t}\n\n\t/**\n\t * Invoked to send a server error. Sets the status to 500 and also sets the\n\t * request attribute \"jakarta.servlet.error.exception\" to the Exception.\n\t */\n\tprotected void sendServerError(Exception ex, HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows IOException {\n\n\t\trequest.setAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE, ex);\n\t\tresponse.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n\t}\n\n}"
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#doResolveException(request,response,handler,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView doResolveException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)",
    "source_code": "\tprotected ModelAndView doResolveException("
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#handleAsyncRequestTimeoutException(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where an async request timed out.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the {@link AsyncRequestTimeoutException} to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen\n\t * at the time of the exception (for example, if multipart resolution failed)\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @since 4.2.8\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 431
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleAsyncRequestTimeoutException(AsyncRequestTimeoutException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleAsyncRequestTimeoutException(AsyncRequestTimeoutException ex,"
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#handleBindException(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where an {@linkplain ModelAttribute @ModelAttribute} method\n\t * argument has binding or validation errors and is not followed by another\n\t * method argument of type {@link BindingResult}.\n\t * <p>By default, an HTTP 400 error is sent back to the client.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @deprecated as of 6.0 since {@link org.springframework.web.method.annotation.ModelAttributeMethodProcessor}\n\t * now raises the {@link MethodArgumentNotValidException} subclass instead.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 566
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleBindException(BindException ex, HttpServletRequest request,\n\t\t\tHttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleBindException(BindException ex, HttpServletRequest request,"
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#handleConversionNotSupported(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case when a {@link org.springframework.web.bind.WebDataBinder} conversion cannot occur.\n\t * <p>The default implementation sends an HTTP 500 error, and returns an empty {@code ModelAndView}.\n\t * Alternatively, a fallback view could be chosen, or the ConversionNotSupportedException could be\n\t * rethrown as-is.\n\t * @param ex the ConversionNotSupportedException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 486
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleConversionNotSupported(ConversionNotSupportedException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleConversionNotSupported(ConversionNotSupportedException ex,"
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#handleErrorResponse(errorResponse,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle an {@link ErrorResponse} exception.\n\t * <p>The default implementation sets status and the headers of the response\n\t * to those obtained from the {@code ErrorResponse}. If available, the\n\t * {@link ProblemDetail#getDetail()}  is used as the message for\n\t * {@link HttpServletResponse#sendError(int, String)}.\n\t * @param errorResponse the exception to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "errorResponse",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 451
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleErrorResponse(ErrorResponse errorResponse,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleErrorResponse(ErrorResponse errorResponse,"
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#handleHttpMediaTypeNotAcceptable(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where no\n\t * {@linkplain org.springframework.http.converter.HttpMessageConverter message converters}\n\t * were found that were acceptable for the client (expressed via the {@code Accept} header).\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the HttpMediaTypeNotAcceptableException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleHttpMediaTypeNotAcceptable(HttpMediaTypeNotAcceptableException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleHttpMediaTypeNotAcceptable(HttpMediaTypeNotAcceptableException ex,"
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#handleHttpMediaTypeNotSupported(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where no\n\t * {@linkplain org.springframework.http.converter.HttpMessageConverter message converters}\n\t * were found for PUT or POSTed content.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the HttpMediaTypeNotSupportedException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleHttpMediaTypeNotSupported(HttpMediaTypeNotSupportedException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleHttpMediaTypeNotSupported(HttpMediaTypeNotSupportedException ex,"
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#handleHttpMessageNotReadable(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where a {@linkplain org.springframework.http.converter.HttpMessageConverter message converter}\n\t * cannot read from an HTTP request.\n\t * <p>The default implementation sends an HTTP 400 error, and returns an empty {@code ModelAndView}.\n\t * Alternatively, a fallback view could be chosen, or the HttpMessageNotReadableException could be\n\t * rethrown as-is.\n\t * @param ex the HttpMessageNotReadableException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 524
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleHttpMessageNotReadable(HttpMessageNotReadableException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleHttpMessageNotReadable(HttpMessageNotReadableException ex,"
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#handleHttpMessageNotWritable(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where a\n\t * {@linkplain org.springframework.http.converter.HttpMessageConverter message converter}\n\t * cannot write to an HTTP request.\n\t * <p>The default implementation sends an HTTP 500 error, and returns an empty {@code ModelAndView}.\n\t * Alternatively, a fallback view could be chosen, or the HttpMessageNotWritableException could\n\t * be rethrown as-is.\n\t * @param ex the HttpMessageNotWritableException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 545
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleHttpMessageNotWritable(HttpMessageNotWritableException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleHttpMessageNotWritable(HttpMessageNotWritableException ex,"
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#handleHttpRequestMethodNotSupported(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where no handler was found for the HTTP method.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the HttpRequestMethodNotSupportedException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen\n\t * at the time of the exception (for example, if multipart resolution failed)\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 250
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleHttpRequestMethodNotSupported(HttpRequestMethodNotSupportedException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleHttpRequestMethodNotSupported(HttpRequestMethodNotSupportedException ex,"
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#handleMethodArgumentNotValidException(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where an argument annotated with {@code @Valid} such as\n\t * an {@link RequestBody} or {@link RequestPart} argument fails validation.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 388
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleMethodArgumentNotValidException(MethodArgumentNotValidException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleMethodArgumentNotValidException(MethodArgumentNotValidException ex,"
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#handleMissingPathVariable(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case when a declared path variable does not match any extracted URI variable.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the MissingPathVariableException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 312
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleMissingPathVariable(MissingPathVariableException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleMissingPathVariable(MissingPathVariableException ex,"
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#handleMissingServletRequestParameter(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case when a required parameter is missing.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the MissingServletRequestParameterException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 331
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleMissingServletRequestParameter(MissingServletRequestParameterException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleMissingServletRequestParameter(MissingServletRequestParameterException ex,"
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#handleMissingServletRequestPartException(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where an {@linkplain RequestPart @RequestPart}, a {@link MultipartFile},\n\t * or a {@code jakarta.servlet.http.Part} argument is required but is missing.\n\t * <p>By default, an HTTP 400 error is sent back to the client.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 349
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleMissingServletRequestPartException(MissingServletRequestPartException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleMissingServletRequestPartException(MissingServletRequestPartException ex,"
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#handleNoHandlerFoundException(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where no handler was found during the dispatch.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the NoHandlerFoundException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen\n\t * at the time of the exception (for example, if multipart resolution failed)\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @since 4.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 409
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleNoHandlerFoundException(NoHandlerFoundException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleNoHandlerFoundException(NoHandlerFoundException ex,"
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#handleServletRequestBindingException(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case when an unrecoverable binding exception occurs - e.g.\n\t * required header, required cookie.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the exception to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 369
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleServletRequestBindingException(ServletRequestBindingException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleServletRequestBindingException(ServletRequestBindingException ex,"
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#handleTypeMismatch(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case when a {@link org.springframework.web.bind.WebDataBinder} conversion error occurs.\n\t * <p>The default implementation sends an HTTP 400 error, and returns an empty {@code ModelAndView}.\n\t * Alternatively, a fallback view could be chosen, or the TypeMismatchException could be rethrown as-is.\n\t * @param ex the TypeMismatchException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 504
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleTypeMismatch(TypeMismatchException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleTypeMismatch(TypeMismatchException ex,"
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#sendServerError(ex,request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked to send a server error. Sets the status to 500 and also sets the\n\t * request attribute \"jakarta.servlet.error.exception\" to the Exception.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 577
    },
    "return": "void",
    "signature": "protected void sendServerError(Exception ex, HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void sendServerError(Exception ex, HttpServletRequest request, HttpServletResponse response)"
  },
  "org.springframework.web.servlet.mvc.support.PAGE_NOT_FOUND_LOG_CATEGORY": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Log category to use when no mapped handler is found for a request.\n\t * @see #pageNotFoundLogger\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "signature": "public String PAGE_NOT_FOUND_LOG_CATEGORY",
    "source_code": "\tpublic static final String PAGE_NOT_FOUND_LOG_CATEGORY = \"org.springframework.web.servlet.PageNotFound\";",
    "type": "String"
  },
  "org.springframework.web.servlet.mvc.support.pageNotFoundLogger": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Additional logger to use when no mapped handler is found for a request.\n\t * @see #PAGE_NOT_FOUND_LOG_CATEGORY\n\t */",
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "signature": "protected Log pageNotFoundLogger",
    "source_code": "\tprotected static final Log pageNotFoundLogger = LogFactory.getLog(PAGE_NOT_FOUND_LOG_CATEGORY);",
    "type": "Log"
  },
  "org.springframework.web.servlet.pageNotFoundLogger": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Additional logger to use when no mapped handler is found for a request. */",
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 289
    },
    "signature": "protected Log pageNotFoundLogger",
    "source_code": "\tprotected static final Log pageNotFoundLogger = LogFactory.getLog(PAGE_NOT_FOUND_LOG_CATEGORY);",
    "type": "Log"
  },
  "org.springframework.web.servlet.resource.DEFAULT_CODINGS": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The default content codings.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "signature": "public List<String> DEFAULT_CODINGS",
    "source_code": "\tpublic static final List<String> DEFAULT_CODINGS = Arrays.asList(\"br\", \"gzip\");",
    "type": "List<String>"
  },
  "org.springframework.web.servlet.resource.EncodedResourceResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Resolver that delegates to the chain, and if a resource is found, it then\n * attempts to find an encoded (e.g. gzip, brotli) variant that is acceptable\n * based on the \"Accept-Encoding\" request header.\n *\n * <p>The list of supported {@link #setContentCodings(List) contentCodings} can\n * be configured, in order of preference, and each coding must be associated\n * with {@link #setExtensions(Map) extensions}.\n *\n * <p>Note that this resolver must be ordered ahead of a\n * {@link VersionResourceResolver} with a content-based, version strategy to\n * ensure the version calculation is not impacted by the encoding.\n *\n * @author Rossen Stoyanchev\n * @since 5.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "signature": "public class EncodedResourceResolver",
    "source_code": "public class EncodedResourceResolver extends AbstractResourceResolver {\n\n\t/**\n\t * The default content codings.\n\t */\n\tpublic static final List<String> DEFAULT_CODINGS = Arrays.asList(\"br\", \"gzip\");\n\n\n\tprivate final List<String> contentCodings = new ArrayList<>(DEFAULT_CODINGS);\n\n\tprivate final Map<String, String> extensions = new LinkedHashMap<>();\n\n\n\tpublic EncodedResourceResolver() {\n\t\tthis.extensions.put(\"gzip\", \".gz\");\n\t\tthis.extensions.put(\"br\", \".br\");\n\t}\n\n\n\t/**\n\t * Configure the supported content codings in order of preference. The first\n\t * coding that is present in the {@literal \"Accept-Encoding\"} header for a\n\t * given request, and that has a file present with the associated extension,\n\t * is used.\n\t * <p><strong>Note:</strong> Each coding must be associated with a file\n\t * extension via {@link #registerExtension} or {@link #setExtensions}. Also\n\t * customizations to the list of codings here should be matched by\n\t * customizations to the same list in {@link CachingResourceResolver} to\n\t * ensure encoded variants of a resource are cached under separate keys.\n\t * <p>By default this property is set to {@literal [\"br\", \"gzip\"]}.\n\t * @param codings one or more supported content codings\n\t */\n\tpublic void setContentCodings(List<String> codings) {\n\t\tAssert.notEmpty(codings, \"At least one content coding expected\");\n\t\tthis.contentCodings.clear();\n\t\tthis.contentCodings.addAll(codings);\n\t}\n\n\t/**\n\t * Return a read-only list with the supported content codings.\n\t */\n\tpublic List<String> getContentCodings() {\n\t\treturn Collections.unmodifiableList(this.contentCodings);\n\t}\n\n\t/**\n\t * Configure mappings from content codings to file extensions. A dot \".\"\n\t * will be prepended in front of the extension value if not present.\n\t * <p>By default this is configured with {@literal [\"br\" -> \".br\"]} and\n\t * {@literal [\"gzip\" -> \".gz\"]}.\n\t * @param extensions the extensions to use.\n\t * @see #registerExtension(String, String)\n\t */\n\tpublic void setExtensions(Map<String, String> extensions) {\n\t\textensions.forEach(this::registerExtension);\n\t}\n\n\t/**\n\t * Return a read-only map with coding-to-extension mappings.\n\t */\n\tpublic Map<String, String> getExtensions() {\n\t\treturn Collections.unmodifiableMap(this.extensions);\n\t}\n\n\t/**\n\t * Java config friendly alternative to {@link #setExtensions(Map)}.\n\t * @param coding the content coding\n\t * @param extension the associated file extension\n\t */\n\tpublic void registerExtension(String coding, String extension) {\n\t\tthis.extensions.put(coding, (extension.startsWith(\".\") ? extension : \".\" + extension));\n\t}\n\n\n\t@Override\n\tprotected Resource resolveResourceInternal(@Nullable HttpServletRequest request, String requestPath,\n\t\t\tList<? extends Resource> locations, ResourceResolverChain chain) {\n\n\t\tResource resource = chain.resolveResource(request, requestPath, locations);\n\t\tif (resource == null || request == null) {\n\t\t\treturn resource;\n\t\t}\n\n\t\tString acceptEncoding = getAcceptEncoding(request);\n\t\tif (acceptEncoding == null) {\n\t\t\treturn resource;\n\t\t}\n\n\t\tfor (String coding : this.contentCodings) {\n\t\t\tif (acceptEncoding.contains(coding)) {\n\t\t\t\ttry {\n\t\t\t\t\tString extension = getExtension(coding);\n\t\t\t\t\tResource encoded = new EncodedResource(resource, coding, extension);\n\t\t\t\t\tif (encoded.exists()) {\n\t\t\t\t\t\treturn encoded;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"No \" + coding + \" resource for [\" + resource.getFilename() + \"]\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn resource;\n\t}\n\n\t@Nullable\n\tprivate String getAcceptEncoding(HttpServletRequest request) {\n\t\tString header = request.getHeader(HttpHeaders.ACCEPT_ENCODING);\n\t\treturn (header != null ? header.toLowerCase() : null);\n\t}\n\n\tprivate String getExtension(String coding) {\n\t\tString extension = this.extensions.get(coding);\n\t\tif (extension == null) {\n\t\t\tthrow new IllegalStateException(\"No file extension associated with content coding \" + coding);\n\t\t}\n\t\treturn extension;\n\t}\n\n\t@Override\n\tprotected String resolveUrlPathInternal(String resourceUrlPath,\n\t\t\tList<? extends Resource> locations, ResourceResolverChain chain) {\n\n\t\treturn chain.resolveUrlPath(resourceUrlPath, locations);\n\t}\n\n\n\t/**\n\t * An encoded {@link HttpResource}.\n\t */\n\tstatic final class EncodedResource extends AbstractResource implements HttpResource {\n\n\t\tprivate final Resource original;\n\n\t\tprivate final String coding;\n\n\t\tprivate final Resource encoded;\n\n\t\tEncodedResource(Resource original, String coding, String extension) throws IOException {\n\t\t\tthis.original = original;\n\t\t\tthis.coding = coding;\n\t\t\tthis.encoded = original.createRelative(original.getFilename() + extension);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean exists() {\n\t\t\treturn this.encoded.exists();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isReadable() {\n\t\t\treturn this.encoded.isReadable();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isOpen() {\n\t\t\treturn this.encoded.isOpen();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isFile() {\n\t\t\treturn this.encoded.isFile();\n\t\t}\n\n\t\t@Override\n\t\tpublic URL getURL() throws IOException {\n\t\t\treturn this.encoded.getURL();\n\t\t}\n\n\t\t@Override\n\t\tpublic URI getURI() throws IOException {\n\t\t\treturn this.encoded.getURI();\n\t\t}\n\n\t\t@Override\n\t\tpublic File getFile() throws IOException {\n\t\t\treturn this.encoded.getFile();\n\t\t}\n\n\t\t@Override\n\t\tpublic InputStream getInputStream() throws IOException {\n\t\t\treturn this.encoded.getInputStream();\n\t\t}\n\n\t\t@Override\n\t\tpublic ReadableByteChannel readableChannel() throws IOException {\n\t\t\treturn this.encoded.readableChannel();\n\t\t}\n\n\t\t@Override\n\t\tpublic byte[] getContentAsByteArray() throws IOException {\n\t\t\treturn this.encoded.getContentAsByteArray();\n\t\t}\n\n\t\t@Override\n\t\tpublic String getContentAsString(Charset charset) throws IOException {\n\t\t\treturn this.encoded.getContentAsString(charset);\n\t\t}\n\n\t\t@Override\n\t\tpublic long contentLength() throws IOException {\n\t\t\treturn this.encoded.contentLength();\n\t\t}\n\n\t\t@Override\n\t\tpublic long lastModified() throws IOException {\n\t\t\treturn this.encoded.lastModified();\n\t\t}\n\n\t\t@Override\n\t\tpublic Resource createRelative(String relativePath) throws IOException {\n\t\t\treturn this.encoded.createRelative(relativePath);\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic String getFilename() {\n\t\t\treturn this.original.getFilename();\n\t\t}\n\n\t\t@Override\n\t\tpublic String getDescription() {\n\t\t\treturn this.encoded.getDescription();\n\t\t}\n\n\t\t@Override\n\t\tpublic HttpHeaders getResponseHeaders() {\n\t\t\tHttpHeaders headers;\n\t\t\tif (this.original instanceof HttpResource httpResource) {\n\t\t\t\theaders = httpResource.getResponseHeaders();\n\t\t\t}\n\t\t\telse {\n\t\t\t\theaders = new HttpHeaders();\n\t\t\t}\n\t\t\theaders.add(HttpHeaders.CONTENT_ENCODING, this.coding);\n\t\t\theaders.add(HttpHeaders.VARY, HttpHeaders.ACCEPT_ENCODING);\n\t\t\treturn headers;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.servlet.resource.EncodedResourceResolver#contentLength()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "long",
    "signature": "public long contentLength()",
    "source_code": "\t\tpublic long contentLength() throws IOException {\n\t\t\treturn this.encoded.contentLength();\n\t\t}"
  },
  "org.springframework.web.servlet.resource.EncodedResourceResolver#createRelative(relativePath)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "relativePath"
    ],
    "position": {
      "column": 1,
      "line": 270
    },
    "return": "Resource",
    "signature": "public Resource createRelative(String relativePath)",
    "source_code": "\t\tpublic Resource createRelative(String relativePath) throws IOException {\n\t\t\treturn this.encoded.createRelative(relativePath);\n\t\t}"
  },
  "org.springframework.web.servlet.resource.EncodedResourceResolver#exists()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "boolean",
    "signature": "public boolean exists()",
    "source_code": "\t\tpublic boolean exists() {\n\t\t\treturn this.encoded.exists();\n\t\t}"
  },
  "org.springframework.web.servlet.resource.EncodedResourceResolver#getContentAsByteArray()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 250
    },
    "return": "byte[]",
    "signature": "public byte[] getContentAsByteArray()",
    "source_code": "\t\tpublic byte[] getContentAsByteArray() throws IOException {\n\t\t\treturn this.encoded.getContentAsByteArray();\n\t\t}"
  },
  "org.springframework.web.servlet.resource.EncodedResourceResolver#getContentAsString(charset)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "String",
    "signature": "public String getContentAsString(Charset charset)",
    "source_code": "\t\tpublic String getContentAsString(Charset charset) throws IOException {\n\t\t\treturn this.encoded.getContentAsString(charset);\n\t\t}"
  },
  "org.springframework.web.servlet.resource.EncodedResourceResolver#getContentCodings()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a read-only list with the supported content codings.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "List<String>",
    "signature": "public List<String> getContentCodings()",
    "source_code": "\tpublic List<String> getContentCodings() {\n\t\treturn Collections.unmodifiableList(this.contentCodings);\n\t}"
  },
  "org.springframework.web.servlet.resource.EncodedResourceResolver#getDescription()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "String",
    "signature": "public String getDescription()",
    "source_code": "\t\tpublic String getDescription() {\n\t\t\treturn this.encoded.getDescription();\n\t\t}"
  },
  "org.springframework.web.servlet.resource.EncodedResourceResolver#getExtensions()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a read-only map with coding-to-extension mappings.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "String>",
    "signature": "public String> getExtensions()",
    "source_code": "\tpublic Map<String, String> getExtensions() {\n\t\treturn Collections.unmodifiableMap(this.extensions);\n\t}"
  },
  "org.springframework.web.servlet.resource.EncodedResourceResolver#getFile()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "File",
    "signature": "public File getFile()",
    "source_code": "\t\tpublic File getFile() throws IOException {\n\t\t\treturn this.encoded.getFile();\n\t\t}"
  },
  "org.springframework.web.servlet.resource.EncodedResourceResolver#getFilename()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "String",
    "signature": "public String getFilename()",
    "source_code": "\t\tpublic String getFilename() {\n\t\t\treturn this.original.getFilename();\n\t\t}"
  },
  "org.springframework.web.servlet.resource.EncodedResourceResolver#getInputStream()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "InputStream",
    "signature": "public InputStream getInputStream()",
    "source_code": "\t\tpublic InputStream getInputStream() throws IOException {\n\t\t\treturn this.encoded.getInputStream();\n\t\t}"
  },
  "org.springframework.web.servlet.resource.EncodedResourceResolver#getResponseHeaders()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders getResponseHeaders()",
    "source_code": "\t\tpublic HttpHeaders getResponseHeaders() {\n\t\t\tHttpHeaders headers;\n\t\t\tif (this.original instanceof HttpResource httpResource) {\n\t\t\t\theaders = httpResource.getResponseHeaders();\n\t\t\t}\n\t\t\telse {\n\t\t\t\theaders = new HttpHeaders();\n\t\t\t}\n\t\t\theaders.add(HttpHeaders.CONTENT_ENCODING, this.coding);\n\t\t\theaders.add(HttpHeaders.VARY, HttpHeaders.ACCEPT_ENCODING);\n\t\t\treturn headers;\n\t\t}"
  },
  "org.springframework.web.servlet.resource.EncodedResourceResolver#getURI()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "URI",
    "signature": "public URI getURI()",
    "source_code": "\t\tpublic URI getURI() throws IOException {\n\t\t\treturn this.encoded.getURI();\n\t\t}"
  },
  "org.springframework.web.servlet.resource.EncodedResourceResolver#getURL()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "URL",
    "signature": "public URL getURL()",
    "source_code": "\t\tpublic URL getURL() throws IOException {\n\t\t\treturn this.encoded.getURL();\n\t\t}"
  },
  "org.springframework.web.servlet.resource.EncodedResourceResolver#isFile()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "boolean",
    "signature": "public boolean isFile()",
    "source_code": "\t\tpublic boolean isFile() {\n\t\t\treturn this.encoded.isFile();\n\t\t}"
  },
  "org.springframework.web.servlet.resource.EncodedResourceResolver#isOpen()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "boolean",
    "signature": "public boolean isOpen()",
    "source_code": "\t\tpublic boolean isOpen() {\n\t\t\treturn this.encoded.isOpen();\n\t\t}"
  },
  "org.springframework.web.servlet.resource.EncodedResourceResolver#isReadable()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "boolean",
    "signature": "public boolean isReadable()",
    "source_code": "\t\tpublic boolean isReadable() {\n\t\t\treturn this.encoded.isReadable();\n\t\t}"
  },
  "org.springframework.web.servlet.resource.EncodedResourceResolver#lastModified()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 265
    },
    "return": "long",
    "signature": "public long lastModified()",
    "source_code": "\t\tpublic long lastModified() throws IOException {\n\t\t\treturn this.encoded.lastModified();\n\t\t}"
  },
  "org.springframework.web.servlet.resource.EncodedResourceResolver#readableChannel()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 245
    },
    "return": "ReadableByteChannel",
    "signature": "public ReadableByteChannel readableChannel()",
    "source_code": "\t\tpublic ReadableByteChannel readableChannel() throws IOException {\n\t\t\treturn this.encoded.readableChannel();\n\t\t}"
  },
  "org.springframework.web.servlet.resource.EncodedResourceResolver#registerExtension(coding,extension)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Java config friendly alternative to {@link #setExtensions(Map)}.\n\t * @param coding the content coding\n\t * @param extension the associated file extension\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "coding",
      "extension"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void registerExtension(String coding, String extension)",
    "source_code": "\tpublic void registerExtension(String coding, String extension) {\n\t\tthis.extensions.put(coding, (extension.startsWith(\".\") ? extension : \".\" + extension));\n\t}"
  },
  "org.springframework.web.servlet.resource.EncodedResourceResolver#resolveResourceInternal(request,requestPath,locations,chain)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "requestPath",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "Resource",
    "signature": "protected Resource resolveResourceInternal(@Nullable HttpServletRequest request, String requestPath,\n\t\t\tList<? extends Resource> locations, ResourceResolverChain chain)",
    "source_code": "\tprotected Resource resolveResourceInternal(@Nullable HttpServletRequest request, String requestPath,"
  },
  "org.springframework.web.servlet.resource.EncodedResourceResolver#resolveUrlPathInternal(resourceUrlPath,locations,chain)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourceUrlPath",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "String",
    "signature": "protected String resolveUrlPathInternal(String resourceUrlPath,\n\t\t\tList<? extends Resource> locations, ResourceResolverChain chain)",
    "source_code": "\tprotected String resolveUrlPathInternal(String resourceUrlPath,"
  },
  "org.springframework.web.servlet.resource.EncodedResourceResolver#setContentCodings(codings)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the supported content codings in order of preference. The first\n\t * coding that is present in the {@literal \"Accept-Encoding\"} header for a\n\t * given request, and that has a file present with the associated extension,\n\t * is used.\n\t * <p><strong>Note:</strong> Each coding must be associated with a file\n\t * extension via {@link #registerExtension} or {@link #setExtensions}. Also\n\t * customizations to the list of codings here should be matched by\n\t * customizations to the same list in {@link CachingResourceResolver} to\n\t * ensure encoded variants of a resource are cached under separate keys.\n\t * <p>By default this property is set to {@literal [\"br\", \"gzip\"]}.\n\t * @param codings one or more supported content codings\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "codings"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "void",
    "signature": "public void setContentCodings(List<String> codings)",
    "source_code": "\tpublic void setContentCodings(List<String> codings) {\n\t\tAssert.notEmpty(codings, \"At least one content coding expected\");\n\t\tthis.contentCodings.clear();\n\t\tthis.contentCodings.addAll(codings);\n\t}"
  },
  "org.springframework.web.servlet.resource.EncodedResourceResolver#setExtensions(Map<String,extensions)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure mappings from content codings to file extensions. A dot \".\"\n\t * will be prepended in front of the extension value if not present.\n\t * <p>By default this is configured with {@literal [\"br\" -> \".br\"]} and\n\t * {@literal [\"gzip\" -> \".gz\"]}.\n\t * @param extensions the extensions to use.\n\t * @see #registerExtension(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "extensions"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "void",
    "signature": "public void setExtensions(Map<String, String> extensions)",
    "source_code": "\tpublic void setExtensions(Map<String, String> extensions) {\n\t\textensions.forEach(this::registerExtension);\n\t}"
  },
  "org.springframework.web.servlet.support.DEFAULT_THEME_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Default theme name used if the RequestContext cannot find a ThemeResolver.\n\t * Only applies to non-DispatcherServlet requests.\n\t * <p>Same as AbstractThemeResolver's default, but not linked in here to avoid package interdependencies.\n\t * @see org.springframework.web.servlet.theme.AbstractThemeResolver#ORIGINAL_DEFAULT_THEME_NAME\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "signature": "public String DEFAULT_THEME_NAME",
    "source_code": "\tpublic static final String DEFAULT_THEME_NAME = \"theme\";",
    "type": "String"
  },
  "org.springframework.web.servlet.support.JstlUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Helper class for preparing JSTL views,\n * in particular for exposing a JSTL localization context.\n *\n * @author Juergen Hoeller\n * @since 20.08.2003\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "signature": "public class JstlUtils",
    "source_code": "public abstract class JstlUtils {\n\n\t/**\n\t * Checks JSTL's \"jakarta.servlet.jsp.jstl.fmt.localizationContext\"\n\t * context-param and creates a corresponding child message source,\n\t * with the provided Spring-defined MessageSource as parent.\n\t * @param servletContext the ServletContext we're running in\n\t * (to check JSTL-related context-params in {@code web.xml})\n\t * @param messageSource the MessageSource to expose, typically\n\t * the ApplicationContext of the current DispatcherServlet\n\t * @return the MessageSource to expose to JSTL; first checking the\n\t * JSTL-defined bundle, then the Spring-defined MessageSource\n\t * @see org.springframework.context.ApplicationContext\n\t */\n\tpublic static MessageSource getJstlAwareMessageSource(\n\t\t\t@Nullable ServletContext servletContext, MessageSource messageSource) {\n\n\t\tif (servletContext != null) {\n\t\t\tString jstlInitParam = servletContext.getInitParameter(Config.FMT_LOCALIZATION_CONTEXT);\n\t\t\tif (jstlInitParam != null) {\n\t\t\t\t// Create a ResourceBundleMessageSource for the specified resource bundle\n\t\t\t\t// basename in the JSTL context-param in web.xml, wiring it with the given\n\t\t\t\t// Spring-defined MessageSource as parent.\n\t\t\t\tResourceBundleMessageSource jstlBundleWrapper = new ResourceBundleMessageSource();\n\t\t\t\tjstlBundleWrapper.setBasename(jstlInitParam);\n\t\t\t\tjstlBundleWrapper.setParentMessageSource(messageSource);\n\t\t\t\treturn jstlBundleWrapper;\n\t\t\t}\n\t\t}\n\t\treturn messageSource;\n\t}\n\n\t/**\n\t * Exposes JSTL-specific request attributes specifying locale\n\t * and resource bundle for JSTL's formatting and message tags,\n\t * using Spring's locale and MessageSource.\n\t * @param request the current HTTP request\n\t * @param messageSource the MessageSource to expose,\n\t * typically the current ApplicationContext (may be {@code null})\n\t * @see #exposeLocalizationContext(RequestContext)\n\t */\n\tpublic static void exposeLocalizationContext(HttpServletRequest request, @Nullable MessageSource messageSource) {\n\t\tLocale jstlLocale = RequestContextUtils.getLocale(request);\n\t\tConfig.set(request, Config.FMT_LOCALE, jstlLocale);\n\t\tTimeZone timeZone = RequestContextUtils.getTimeZone(request);\n\t\tif (timeZone != null) {\n\t\t\tConfig.set(request, Config.FMT_TIME_ZONE, timeZone);\n\t\t}\n\t\tif (messageSource != null) {\n\t\t\tLocalizationContext jstlContext = new SpringLocalizationContext(messageSource, request);\n\t\t\tConfig.set(request, Config.FMT_LOCALIZATION_CONTEXT, jstlContext);\n\t\t}\n\t}\n\n\t/**\n\t * Exposes JSTL-specific request attributes specifying locale\n\t * and resource bundle for JSTL's formatting and message tags,\n\t * using Spring's locale and MessageSource.\n\t * @param requestContext the context for the current HTTP request,\n\t * including the ApplicationContext to expose as MessageSource\n\t */\n\tpublic static void exposeLocalizationContext(RequestContext requestContext) {\n\t\tConfig.set(requestContext.getRequest(), Config.FMT_LOCALE, requestContext.getLocale());\n\t\tTimeZone timeZone = requestContext.getTimeZone();\n\t\tif (timeZone != null) {\n\t\t\tConfig.set(requestContext.getRequest(), Config.FMT_TIME_ZONE, timeZone);\n\t\t}\n\t\tMessageSource messageSource = getJstlAwareMessageSource(\n\t\t\t\trequestContext.getServletContext(), requestContext.getMessageSource());\n\t\tLocalizationContext jstlContext = new SpringLocalizationContext(messageSource, requestContext.getRequest());\n\t\tConfig.set(requestContext.getRequest(), Config.FMT_LOCALIZATION_CONTEXT, jstlContext);\n\t}\n\n\n\t/**\n\t * Spring-specific LocalizationContext adapter that merges session-scoped\n\t * JSTL LocalizationContext/Locale attributes with the local Spring request context.\n\t */\n\tprivate static class SpringLocalizationContext extends LocalizationContext {\n\n\t\tprivate final MessageSource messageSource;\n\n\t\tprivate final HttpServletRequest request;\n\n\t\tpublic SpringLocalizationContext(MessageSource messageSource, HttpServletRequest request) {\n\t\t\tthis.messageSource = messageSource;\n\t\t\tthis.request = request;\n\t\t}\n\n\t\t@Override\n\t\tpublic ResourceBundle getResourceBundle() {\n\t\t\tHttpSession session = this.request.getSession(false);\n\t\t\tif (session != null) {\n\t\t\t\tObject lcObject = Config.get(session, Config.FMT_LOCALIZATION_CONTEXT);\n\t\t\t\tif (lcObject instanceof LocalizationContext localizationContext) {\n\t\t\t\t\tResourceBundle lcBundle = localizationContext.getResourceBundle();\n\t\t\t\t\treturn new MessageSourceResourceBundle(this.messageSource, getLocale(), lcBundle);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new MessageSourceResourceBundle(this.messageSource, getLocale());\n\t\t}\n\n\t\t@Override\n\t\tpublic Locale getLocale() {\n\t\t\tHttpSession session = this.request.getSession(false);\n\t\t\tif (session != null) {\n\t\t\t\tObject localeObject = Config.get(session, Config.FMT_LOCALE);\n\t\t\t\tif (localeObject instanceof Locale locale) {\n\t\t\t\t\treturn locale;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn RequestContextUtils.getLocale(this.request);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.servlet.support.JstlUtils#exposeLocalizationContext(request,messageSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Exposes JSTL-specific request attributes specifying locale\n\t * and resource bundle for JSTL's formatting and message tags,\n\t * using Spring's locale and MessageSource.\n\t * @param request the current HTTP request\n\t * @param messageSource the MessageSource to expose,\n\t * typically the current ApplicationContext (may be {@code null})\n\t * @see #exposeLocalizationContext(RequestContext)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "messageSource"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "void",
    "signature": "public void exposeLocalizationContext(HttpServletRequest request, @Nullable MessageSource messageSource)",
    "source_code": "\tpublic static void exposeLocalizationContext(HttpServletRequest request, @Nullable MessageSource messageSource) {\n\t\tLocale jstlLocale = RequestContextUtils.getLocale(request);\n\t\tConfig.set(request, Config.FMT_LOCALE, jstlLocale);\n\t\tTimeZone timeZone = RequestContextUtils.getTimeZone(request);\n\t\tif (timeZone != null) {\n\t\t\tConfig.set(request, Config.FMT_TIME_ZONE, timeZone);\n\t\t}\n\t\tif (messageSource != null) {\n\t\t\tLocalizationContext jstlContext = new SpringLocalizationContext(messageSource, request);\n\t\t\tConfig.set(request, Config.FMT_LOCALIZATION_CONTEXT, jstlContext);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.support.JstlUtils#exposeLocalizationContext(requestContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Exposes JSTL-specific request attributes specifying locale\n\t * and resource bundle for JSTL's formatting and message tags,\n\t * using Spring's locale and MessageSource.\n\t * @param requestContext the context for the current HTTP request,\n\t * including the ApplicationContext to expose as MessageSource\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestContext"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "void",
    "signature": "public void exposeLocalizationContext(RequestContext requestContext)",
    "source_code": "\tpublic static void exposeLocalizationContext(RequestContext requestContext) {\n\t\tConfig.set(requestContext.getRequest(), Config.FMT_LOCALE, requestContext.getLocale());\n\t\tTimeZone timeZone = requestContext.getTimeZone();\n\t\tif (timeZone != null) {\n\t\t\tConfig.set(requestContext.getRequest(), Config.FMT_TIME_ZONE, timeZone);\n\t\t}\n\t\tMessageSource messageSource = getJstlAwareMessageSource(\n\t\t\t\trequestContext.getServletContext(), requestContext.getMessageSource());\n\t\tLocalizationContext jstlContext = new SpringLocalizationContext(messageSource, requestContext.getRequest());\n\t\tConfig.set(requestContext.getRequest(), Config.FMT_LOCALIZATION_CONTEXT, jstlContext);\n\t}"
  },
  "org.springframework.web.servlet.support.JstlUtils#getJstlAwareMessageSource(servletContext,messageSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Checks JSTL's \"jakarta.servlet.jsp.jstl.fmt.localizationContext\"\n\t * context-param and creates a corresponding child message source,\n\t * with the provided Spring-defined MessageSource as parent.\n\t * @param servletContext the ServletContext we're running in\n\t * (to check JSTL-related context-params in {@code web.xml})\n\t * @param messageSource the MessageSource to expose, typically\n\t * the ApplicationContext of the current DispatcherServlet\n\t * @return the MessageSource to expose to JSTL; first checking the\n\t * JSTL-defined bundle, then the Spring-defined MessageSource\n\t * @see org.springframework.context.ApplicationContext\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletContext",
      "messageSource"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "return": "MessageSource",
    "signature": "public MessageSource getJstlAwareMessageSource(@Nullable ServletContext servletContext, MessageSource messageSource)",
    "source_code": "\tpublic static MessageSource getJstlAwareMessageSource("
  },
  "org.springframework.web.servlet.support.JstlUtils#getLocale()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "Locale",
    "signature": "public Locale getLocale()",
    "source_code": "\t\tpublic Locale getLocale() {\n\t\t\tHttpSession session = this.request.getSession(false);\n\t\t\tif (session != null) {\n\t\t\t\tObject localeObject = Config.get(session, Config.FMT_LOCALE);\n\t\t\t\tif (localeObject instanceof Locale locale) {\n\t\t\t\t\treturn locale;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn RequestContextUtils.getLocale(this.request);\n\t\t}"
  },
  "org.springframework.web.servlet.support.JstlUtils#getResourceBundle()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "ResourceBundle",
    "signature": "public ResourceBundle getResourceBundle()",
    "source_code": "\t\tpublic ResourceBundle getResourceBundle() {\n\t\t\tHttpSession session = this.request.getSession(false);\n\t\t\tif (session != null) {\n\t\t\t\tObject lcObject = Config.get(session, Config.FMT_LOCALIZATION_CONTEXT);\n\t\t\t\tif (lcObject instanceof LocalizationContext localizationContext) {\n\t\t\t\t\tResourceBundle lcBundle = localizationContext.getResourceBundle();\n\t\t\t\t\treturn new MessageSourceResourceBundle(this.messageSource, getLocale(), lcBundle);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new MessageSourceResourceBundle(this.messageSource, getLocale());\n\t\t}"
  },
  "org.springframework.web.servlet.support.RequestContext": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Context holder for request-specific state, like current web application context, current locale,\n * current theme, and potential binding errors. Provides easy access to localized messages and\n * Errors instances.\n *\n * <p>Suitable for exposition to views, and usage within JSP's \"useBean\" tag, JSP scriptlets, JSTL EL,\n * etc. Necessary for views that do not have access to the servlet request, like FreeMarker templates.\n *\n * <p>Can be instantiated manually, or automatically exposed to views as model attribute via AbstractView's\n * \"requestContextAttribute\" property.\n *\n * <p>Will also work outside DispatcherServlet requests, accessing the root WebApplicationContext\n * and using an appropriate fallback for the locale (the HttpServletRequest's primary locale).\n *\n * @author Juergen Hoeller\n * @author Rossen Stoyanchev\n * @since 03.03.2003\n * @see org.springframework.web.servlet.DispatcherServlet\n * @see org.springframework.web.servlet.view.AbstractView#setRequestContextAttribute\n * @see org.springframework.web.servlet.view.UrlBasedViewResolver#setRequestContextAttribute\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "signature": "public class RequestContext",
    "source_code": "public class RequestContext {\n\n\t/**\n\t * Default theme name used if the RequestContext cannot find a ThemeResolver.\n\t * Only applies to non-DispatcherServlet requests.\n\t * <p>Same as AbstractThemeResolver's default, but not linked in here to avoid package interdependencies.\n\t * @see org.springframework.web.servlet.theme.AbstractThemeResolver#ORIGINAL_DEFAULT_THEME_NAME\n\t * @deprecated as of 6.0, with no direct replacement\n\t */\n\t@Deprecated(since = \"6.0\")\n\tpublic static final String DEFAULT_THEME_NAME = \"theme\";\n\n\t/**\n\t * Request attribute to hold the current web application context for RequestContext usage.\n\t * By default, the DispatcherServlet's context (or the root context as fallback) is exposed.\n\t */\n\tpublic static final String WEB_APPLICATION_CONTEXT_ATTRIBUTE = RequestContext.class.getName() + \".CONTEXT\";\n\n\n\tprotected static final boolean jstlPresent = ClassUtils.isPresent(\n\t\t\t\"jakarta.servlet.jsp.jstl.core.Config\", RequestContext.class.getClassLoader());\n\n\tprivate final HttpServletRequest request;\n\n\t@Nullable\n\tprivate final HttpServletResponse response;\n\n\t@Nullable\n\tprivate final Map<String, Object> model;\n\n\tprivate final WebApplicationContext webApplicationContext;\n\n\t@Nullable\n\tprivate Locale locale;\n\n\t@Nullable\n\tprivate TimeZone timeZone;\n\n\t@Deprecated\n\t@Nullable\n\tprivate org.springframework.ui.context.Theme theme;\n\n\t@Nullable\n\tprivate Boolean defaultHtmlEscape;\n\n\t@Nullable\n\tprivate final Boolean responseEncodedHtmlEscape;\n\n\tprivate UrlPathHelper urlPathHelper;\n\n\t@Nullable\n\tprivate RequestDataValueProcessor requestDataValueProcessor;\n\n\t@Nullable\n\tprivate Map<String, Errors> errorsMap;\n\n\n\t/**\n\t * Create a new RequestContext for the given request, using the request attributes for Errors retrieval.\n\t * <p>This only works with InternalResourceViews, as Errors instances are part of the model and not\n\t * normally exposed as request attributes. It will typically be used within JSPs or custom tags.\n\t * <p><b>Will only work within a DispatcherServlet request.</b>\n\t * Pass in a ServletContext to be able to fall back to the root WebApplicationContext.\n\t * @param request current HTTP request\n\t * @see org.springframework.web.servlet.DispatcherServlet\n\t * @see #RequestContext(jakarta.servlet.http.HttpServletRequest, jakarta.servlet.ServletContext)\n\t */\n\tpublic RequestContext(HttpServletRequest request) {\n\t\tthis(request, null, null, null);\n\t}\n\n\t/**\n\t * Create a new RequestContext for the given request, using the request attributes for Errors retrieval.\n\t * <p>This only works with InternalResourceViews, as Errors instances are part of the model and not\n\t * normally exposed as request attributes. It will typically be used within JSPs or custom tags.\n\t * <p><b>Will only work within a DispatcherServlet request.</b>\n\t * Pass in a ServletContext to be able to fall back to the root WebApplicationContext.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @see org.springframework.web.servlet.DispatcherServlet\n\t * @see #RequestContext(jakarta.servlet.http.HttpServletRequest, jakarta.servlet.http.HttpServletResponse, jakarta.servlet.ServletContext, Map)\n\t */\n\tpublic RequestContext(HttpServletRequest request, HttpServletResponse response) {\n\t\tthis(request, response, null, null);\n\t}\n\n\t/**\n\t * Create a new RequestContext for the given request, using the request attributes for Errors retrieval.\n\t * <p>This only works with InternalResourceViews, as Errors instances are part of the model and not\n\t * normally exposed as request attributes. It will typically be used within JSPs or custom tags.\n\t * <p>If a ServletContext is specified, the RequestContext will also work with the root\n\t * WebApplicationContext (outside a DispatcherServlet).\n\t * @param request current HTTP request\n\t * @param servletContext the servlet context of the web application (can be {@code null};\n\t * necessary for fallback to root WebApplicationContext)\n\t * @see org.springframework.web.context.WebApplicationContext\n\t * @see org.springframework.web.servlet.DispatcherServlet\n\t */\n\tpublic RequestContext(HttpServletRequest request, @Nullable ServletContext servletContext) {\n\t\tthis(request, null, servletContext, null);\n\t}\n\n\t/**\n\t * Create a new RequestContext for the given request, using the given model attributes for Errors retrieval.\n\t * <p>This works with all View implementations. It will typically be used by View implementations.\n\t * <p><b>Will only work within a DispatcherServlet request.</b>\n\t * Pass in a ServletContext to be able to fall back to the root WebApplicationContext.\n\t * @param request current HTTP request\n\t * @param model the model attributes for the current view (can be {@code null},\n\t * using the request attributes for Errors retrieval)\n\t * @see org.springframework.web.servlet.DispatcherServlet\n\t * @see #RequestContext(jakarta.servlet.http.HttpServletRequest, jakarta.servlet.http.HttpServletResponse, jakarta.servlet.ServletContext, Map)\n\t */\n\tpublic RequestContext(HttpServletRequest request, @Nullable Map<String, Object> model) {\n\t\tthis(request, null, null, model);\n\t}\n\n\t/**\n\t * Create a new RequestContext for the given request, using the given model attributes for Errors retrieval.\n\t * <p>This works with all View implementations. It will typically be used by View implementations.\n\t * <p>If a ServletContext is specified, the RequestContext will also work with a root\n\t * WebApplicationContext (outside a DispatcherServlet).\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param servletContext the servlet context of the web application (can be {@code null}; necessary for\n\t * fallback to root WebApplicationContext)\n\t * @param model the model attributes for the current view (can be {@code null}, using the request attributes\n\t * for Errors retrieval)\n\t * @see org.springframework.web.context.WebApplicationContext\n\t * @see org.springframework.web.servlet.DispatcherServlet\n\t */\n\tpublic RequestContext(HttpServletRequest request, @Nullable HttpServletResponse response,\n\t\t\t@Nullable ServletContext servletContext, @Nullable Map<String, Object> model) {\n\n\t\tthis.request = request;\n\t\tthis.response = response;\n\t\tthis.model = model;\n\n\t\t// Fetch WebApplicationContext, either from DispatcherServlet or the root context.\n\t\t// ServletContext needs to be specified to be able to fall back to the root context!\n\t\tWebApplicationContext wac = (WebApplicationContext) request.getAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE);\n\t\tif (wac == null) {\n\t\t\twac = RequestContextUtils.findWebApplicationContext(request, servletContext);\n\t\t\tif (wac == null) {\n\t\t\t\tthrow new IllegalStateException(\"No WebApplicationContext found: not in a DispatcherServlet \" +\n\t\t\t\t\t\t\"request and no ContextLoaderListener registered?\");\n\t\t\t}\n\t\t}\n\t\tthis.webApplicationContext = wac;\n\n\t\tLocale locale = null;\n\t\tTimeZone timeZone = null;\n\n\t\t// Determine locale to use for this RequestContext.\n\t\tLocaleResolver localeResolver = RequestContextUtils.getLocaleResolver(request);\n\t\tif (localeResolver instanceof LocaleContextResolver localeContextResolver) {\n\t\t\tLocaleContext localeContext = localeContextResolver.resolveLocaleContext(request);\n\t\t\tlocale = localeContext.getLocale();\n\t\t\tif (localeContext instanceof TimeZoneAwareLocaleContext timeZoneAwareLocaleContext) {\n\t\t\t\ttimeZone = timeZoneAwareLocaleContext.getTimeZone();\n\t\t\t}\n\t\t}\n\t\telse if (localeResolver != null) {\n\t\t\t// Try LocaleResolver (we're within a DispatcherServlet request).\n\t\t\tlocale = localeResolver.resolveLocale(request);\n\t\t}\n\n\t\tthis.locale = locale;\n\t\tthis.timeZone = timeZone;\n\n\t\t// Determine default HTML escape setting from the \"defaultHtmlEscape\"\n\t\t// context-param in web.xml, if any.\n\t\tthis.defaultHtmlEscape = WebUtils.getDefaultHtmlEscape(this.webApplicationContext.getServletContext());\n\n\t\t// Determine response-encoded HTML escape setting from the \"responseEncodedHtmlEscape\"\n\t\t// context-param in web.xml, if any.\n\t\tthis.responseEncodedHtmlEscape =\n\t\t\t\tWebUtils.getResponseEncodedHtmlEscape(this.webApplicationContext.getServletContext());\n\n\t\tthis.urlPathHelper = new UrlPathHelper();\n\n\t\tif (this.webApplicationContext.containsBean(RequestContextUtils.REQUEST_DATA_VALUE_PROCESSOR_BEAN_NAME)) {\n\t\t\tthis.requestDataValueProcessor = this.webApplicationContext.getBean(\n\t\t\t\t\tRequestContextUtils.REQUEST_DATA_VALUE_PROCESSOR_BEAN_NAME, RequestDataValueProcessor.class);\n\t\t}\n\t}\n\n\n\t/**\n\t * Return the underlying HttpServletRequest. Only intended for cooperating classes in this package.\n\t */\n\tprotected final HttpServletRequest getRequest() {\n\t\treturn this.request;\n\t}\n\n\t/**\n\t * Return the underlying ServletContext. Only intended for cooperating classes in this package.\n\t */\n\t@Nullable\n\tprotected final ServletContext getServletContext() {\n\t\treturn this.webApplicationContext.getServletContext();\n\t}\n\n\t/**\n\t * Return the current WebApplicationContext.\n\t */\n\tpublic final WebApplicationContext getWebApplicationContext() {\n\t\treturn this.webApplicationContext;\n\t}\n\n\t/**\n\t * Return the current WebApplicationContext as MessageSource.\n\t */\n\tpublic final MessageSource getMessageSource() {\n\t\treturn this.webApplicationContext;\n\t}\n\n\t/**\n\t * Return the model Map that this RequestContext encapsulates, if any.\n\t * @return the populated model Map, or {@code null} if none available\n\t */\n\t@Nullable\n\tpublic final Map<String, Object> getModel() {\n\t\treturn this.model;\n\t}\n\n\t/**\n\t * Return the current Locale (falling back to the request locale; never {@code null}).\n\t * <p>Typically coming from a DispatcherServlet's {@link LocaleResolver}.\n\t * Also includes a fallback check for JSTL's Locale attribute.\n\t * @see RequestContextUtils#getLocale\n\t */\n\tpublic final Locale getLocale() {\n\t\treturn (this.locale != null ? this.locale : getFallbackLocale());\n\t}\n\n\t/**\n\t * Return the current TimeZone (or {@code null} if none derivable from the request).\n\t * <p>Typically coming from a DispatcherServlet's {@link LocaleContextResolver}.\n\t * Also includes a fallback check for JSTL's TimeZone attribute.\n\t * @see RequestContextUtils#getTimeZone\n\t */\n\t@Nullable\n\tpublic TimeZone getTimeZone() {\n\t\treturn (this.timeZone != null ? this.timeZone : getFallbackTimeZone());\n\t}\n\n\t/**\n\t * Determine the fallback locale for this context.\n\t * <p>The default implementation checks for a JSTL locale attribute in request, session\n\t * or application scope; if not found, returns the {@code HttpServletRequest.getLocale()}.\n\t * @return the fallback locale (never {@code null})\n\t * @see jakarta.servlet.http.HttpServletRequest#getLocale()\n\t */\n\tprotected Locale getFallbackLocale() {\n\t\tif (jstlPresent) {\n\t\t\tLocale locale = JstlLocaleResolver.getJstlLocale(getRequest(), getServletContext());\n\t\t\tif (locale != null) {\n\t\t\t\treturn locale;\n\t\t\t}\n\t\t}\n\t\treturn getRequest().getLocale();\n\t}\n\n\t/**\n\t * Determine the fallback time zone for this context.\n\t * <p>The default implementation checks for a JSTL time zone attribute in request,\n\t * session or application scope; returns {@code null} if not found.\n\t * @return the fallback time zone (or {@code null} if none derivable from the request)\n\t */\n\t@Nullable\n\tprotected TimeZone getFallbackTimeZone() {\n\t\tif (jstlPresent) {\n\t\t\tTimeZone timeZone = JstlLocaleResolver.getJstlTimeZone(getRequest(), getServletContext());\n\t\t\tif (timeZone != null) {\n\t\t\t\treturn timeZone;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Change the current locale to the specified one,\n\t * storing the new locale through the configured {@link LocaleResolver}.\n\t * @param locale the new locale\n\t * @see LocaleResolver#setLocale\n\t * @see #changeLocale(java.util.Locale, java.util.TimeZone)\n\t */\n\tpublic void changeLocale(Locale locale) {\n\t\tLocaleResolver localeResolver = RequestContextUtils.getLocaleResolver(this.request);\n\t\tif (localeResolver == null) {\n\t\t\tthrow new IllegalStateException(\"Cannot change locale if no LocaleResolver configured\");\n\t\t}\n\t\tlocaleResolver.setLocale(this.request, this.response, locale);\n\t\tthis.locale = locale;\n\t}\n\n\t/**\n\t * Change the current locale to the specified locale and time zone context,\n\t * storing the new locale context through the configured {@link LocaleResolver}.\n\t * @param locale the new locale\n\t * @param timeZone the new time zone\n\t * @see LocaleContextResolver#setLocaleContext\n\t * @see org.springframework.context.i18n.SimpleTimeZoneAwareLocaleContext\n\t */\n\tpublic void changeLocale(Locale locale, TimeZone timeZone) {\n\t\tLocaleResolver localeResolver = RequestContextUtils.getLocaleResolver(this.request);\n\t\tif (!(localeResolver instanceof LocaleContextResolver localeContextResolver)) {\n\t\t\tthrow new IllegalStateException(\"Cannot change locale context if no LocaleContextResolver configured\");\n\t\t}\n\t\tlocaleContextResolver.setLocaleContext(this.request, this.response,\n\t\t\t\tnew SimpleTimeZoneAwareLocaleContext(locale, timeZone));\n\t\tthis.locale = locale;\n\t\tthis.timeZone = timeZone;\n\t}\n\n\t/**\n\t * Return the current theme (never {@code null}).\n\t * <p>Resolved lazily for more efficiency when theme support is not being used.\n\t * @deprecated as of 6.0, with no direct replacement\n\t */\n\t@Deprecated(since = \"6.0\")\n\tpublic org.springframework.ui.context.Theme getTheme() {\n\t\tif (this.theme == null) {\n\t\t\t// Lazily determine theme to use for this RequestContext.\n\t\t\tthis.theme = RequestContextUtils.getTheme(this.request);\n\t\t\tif (this.theme == null) {\n\t\t\t\t// No ThemeResolver and ThemeSource available -> try fallback.\n\t\t\t\tthis.theme = getFallbackTheme();\n\t\t\t}\n\t\t}\n\t\treturn this.theme;\n\t}\n\n\t/**\n\t * Determine the fallback theme for this context.\n\t * <p>The default implementation returns the default theme (with name \"theme\").\n\t * @return the fallback theme (never {@code null})\n\t * @deprecated as of 6.0, with no direct replacement\n\t */\n\t@Deprecated\n\tprotected org.springframework.ui.context.Theme getFallbackTheme() {\n\t\torg.springframework.ui.context.ThemeSource themeSource = RequestContextUtils.getThemeSource(getRequest());\n\t\tif (themeSource == null) {\n\t\t\tthemeSource = new org.springframework.ui.context.support.ResourceBundleThemeSource();\n\t\t}\n\t\torg.springframework.ui.context.Theme theme = themeSource.getTheme(DEFAULT_THEME_NAME);\n\t\tif (theme == null) {\n\t\t\tthrow new IllegalStateException(\"No theme defined and no fallback theme found\");\n\t\t}\n\t\treturn theme;\n\t}\n\n\t/**\n\t * Change the current theme to the specified one,\n\t * storing the new theme name through the configured\n\t * {@link org.springframework.web.servlet.ThemeResolver ThemeResolver}.\n\t * @param theme the new theme\n\t * @see org.springframework.web.servlet.ThemeResolver#setThemeName\n\t * @deprecated as of 6.0, with no direct replacement\n\t */\n\t@Deprecated(since = \"6.0\")\n\tpublic void changeTheme(@Nullable org.springframework.ui.context.Theme theme) {\n\t\torg.springframework.web.servlet.ThemeResolver themeResolver = RequestContextUtils.getThemeResolver(this.request);\n\t\tif (themeResolver == null) {\n\t\t\tthrow new IllegalStateException(\"Cannot change theme if no ThemeResolver configured\");\n\t\t}\n\t\tthemeResolver.setThemeName(this.request, this.response, (theme != null ? theme.getName() : null));\n\t\tthis.theme = theme;\n\t}\n\n\t/**\n\t * Change the current theme to the specified theme by name,\n\t * storing the new theme name through the configured\n\t * {@link org.springframework.web.servlet.ThemeResolver ThemeResolver}.\n\t * @param themeName the name of the new theme\n\t * @see org.springframework.web.servlet.ThemeResolver#setThemeName\n\t * @deprecated as of 6.0, with no direct replacement\n\t */\n\t@Deprecated\n\tpublic void changeTheme(String themeName) {\n\t\torg.springframework.web.servlet.ThemeResolver themeResolver = RequestContextUtils.getThemeResolver(this.request);\n\t\tif (themeResolver == null) {\n\t\t\tthrow new IllegalStateException(\"Cannot change theme if no ThemeResolver configured\");\n\t\t}\n\t\tthemeResolver.setThemeName(this.request, this.response, themeName);\n\t\t// Ask for re-resolution on next getTheme call.\n\t\tthis.theme = null;\n\t}\n\n\t/**\n\t * (De)activate default HTML escaping for messages and errors, for the scope of this RequestContext.\n\t * <p>The default is the application-wide setting (the \"defaultHtmlEscape\" context-param in web.xml).\n\t * @see org.springframework.web.util.WebUtils#getDefaultHtmlEscape\n\t */\n\tpublic void setDefaultHtmlEscape(boolean defaultHtmlEscape) {\n\t\tthis.defaultHtmlEscape = defaultHtmlEscape;\n\t}\n\n\t/**\n\t * Is default HTML escaping active? Falls back to {@code false} in case of no explicit default given.\n\t */\n\tpublic boolean isDefaultHtmlEscape() {\n\t\treturn (this.defaultHtmlEscape != null && this.defaultHtmlEscape.booleanValue());\n\t}\n\n\t/**\n\t * Return the default HTML escape setting, differentiating between no default specified and an explicit value.\n\t * @return whether default HTML escaping is enabled (null = no explicit default)\n\t */\n\t@Nullable\n\tpublic Boolean getDefaultHtmlEscape() {\n\t\treturn this.defaultHtmlEscape;\n\t}\n\n\t/**\n\t * Is HTML escaping using the response encoding by default?\n\t * If enabled, only XML markup significant characters will be escaped with UTF-* encodings.\n\t * <p>Falls back to {@code true} in case of no explicit default given, as of Spring 4.2.\n\t * @since 4.1.2\n\t */\n\tpublic boolean isResponseEncodedHtmlEscape() {\n\t\treturn (this.responseEncodedHtmlEscape == null || this.responseEncodedHtmlEscape.booleanValue());\n\t}\n\n\t/**\n\t * Return the default setting about use of response encoding for HTML escape setting,\n\t * differentiating between no default specified and an explicit value.\n\t * @return whether default use of response encoding HTML escaping is enabled (null = no explicit default)\n\t * @since 4.1.2\n\t */\n\t@Nullable\n\tpublic Boolean getResponseEncodedHtmlEscape() {\n\t\treturn this.responseEncodedHtmlEscape;\n\t}\n\n\n\t/**\n\t * Set the UrlPathHelper to use for context path and request URI decoding.\n\t * Can be used to pass a shared UrlPathHelper instance in.\n\t * <p>A default UrlPathHelper is always available.\n\t */\n\tpublic void setUrlPathHelper(UrlPathHelper urlPathHelper) {\n\t\tAssert.notNull(urlPathHelper, \"UrlPathHelper must not be null\");\n\t\tthis.urlPathHelper = urlPathHelper;\n\t}\n\n\t/**\n\t * Return the UrlPathHelper used for context path and request URI decoding.\n\t * Can be used to configure the current UrlPathHelper.\n\t * <p>A default UrlPathHelper is always available.\n\t */\n\tpublic UrlPathHelper getUrlPathHelper() {\n\t\treturn this.urlPathHelper;\n\t}\n\n\t/**\n\t * Return the RequestDataValueProcessor instance to use obtained from the\n\t * WebApplicationContext under the name {@code \"requestDataValueProcessor\"}.\n\t * Or {@code null} if no matching bean was found.\n\t */\n\t@Nullable\n\tpublic RequestDataValueProcessor getRequestDataValueProcessor() {\n\t\treturn this.requestDataValueProcessor;\n\t}\n\n\t/**\n\t * Return the context path of the original request, that is, the path that\n\t * indicates the current web application. This is useful for building links\n\t * to other resources within the application.\n\t * <p>Delegates to the UrlPathHelper for decoding.\n\t * @see jakarta.servlet.http.HttpServletRequest#getContextPath\n\t * @see #getUrlPathHelper\n\t */\n\tpublic String getContextPath() {\n\t\treturn this.urlPathHelper.getOriginatingContextPath(this.request);\n\t}\n\n\t/**\n\t * Return a context-aware URl for the given relative URL.\n\t * @param relativeUrl the relative URL part\n\t * @return a URL that points back to the server with an absolute path (also URL-encoded accordingly)\n\t */\n\tpublic String getContextUrl(String relativeUrl) {\n\t\tString url = getContextPath() + relativeUrl;\n\t\tif (this.response != null) {\n\t\t\turl = this.response.encodeURL(url);\n\t\t}\n\t\treturn url;\n\t}\n\n\t/**\n\t * Return a context-aware URl for the given relative URL with placeholders (named keys with braces {@code {}}).\n\t * For example, send in a relative URL {@code foo/{bar}?spam={spam}} and a parameter map\n\t * {@code {bar=baz,spam=nuts}} and the result will be {@code [contextpath]/foo/baz?spam=nuts}.\n\t * @param relativeUrl the relative URL part\n\t * @param params a map of parameters to insert as placeholders in the url\n\t * @return a URL that points back to the server with an absolute path (also URL-encoded accordingly)\n\t */\n\tpublic String getContextUrl(String relativeUrl, Map<String, ?> params) {\n\t\tString url = getContextPath() + relativeUrl;\n\t\turl = UriComponentsBuilder.fromUriString(url).buildAndExpand(params).encode().toUri().toASCIIString();\n\t\tif (this.response != null) {\n\t\t\turl = this.response.encodeURL(url);\n\t\t}\n\t\treturn url;\n\t}\n\n\t/**\n\t * Return the path to URL mappings within the current servlet including the\n\t * context path and the servlet path of the original request. This is useful\n\t * for building links to other resources within the application where a\n\t * servlet mapping of the style {@code \"/main/*\"} is used.\n\t * <p>Delegates to the UrlPathHelper to determine the context and servlet path.\n\t */\n\tpublic String getPathToServlet() {\n\t\tString path = this.urlPathHelper.getOriginatingContextPath(this.request);\n\t\tif (StringUtils.hasText(this.urlPathHelper.getPathWithinServletMapping(this.request))) {\n\t\t\tpath += this.urlPathHelper.getOriginatingServletPath(this.request);\n\t\t}\n\t\treturn path;\n\t}\n\n\t/**\n\t * Return the request URI of the original request, that is, the invoked URL\n\t * without parameters. This is particularly useful as HTML form action target,\n\t * possibly in combination with the original query string.\n\t * <p>Delegates to the UrlPathHelper for decoding.\n\t * @see #getQueryString\n\t * @see org.springframework.web.util.UrlPathHelper#getOriginatingRequestUri\n\t * @see #getUrlPathHelper\n\t */\n\tpublic String getRequestUri() {\n\t\treturn this.urlPathHelper.getOriginatingRequestUri(this.request);\n\t}\n\n\t/**\n\t * Return the query string of the current request, that is, the part after\n\t * the request path. This is particularly useful for building an HTML form\n\t * action target in combination with the original request URI.\n\t * <p>Delegates to the UrlPathHelper for decoding.\n\t * @see #getRequestUri\n\t * @see org.springframework.web.util.UrlPathHelper#getOriginatingQueryString\n\t * @see #getUrlPathHelper\n\t */\n\tpublic String getQueryString() {\n\t\treturn this.urlPathHelper.getOriginatingQueryString(this.request);\n\t}\n\n\t/**\n\t * Retrieve the message for the given code, using the \"defaultHtmlEscape\" setting.\n\t * @param code the code of the message\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t */\n\tpublic String getMessage(String code, String defaultMessage) {\n\t\treturn getMessage(code, null, defaultMessage, isDefaultHtmlEscape());\n\t}\n\n\t/**\n\t * Retrieve the message for the given code, using the \"defaultHtmlEscape\" setting.\n\t * @param code the code of the message\n\t * @param args arguments for the message, or {@code null} if none\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t */\n\tpublic String getMessage(String code, @Nullable Object[] args, String defaultMessage) {\n\t\treturn getMessage(code, args, defaultMessage, isDefaultHtmlEscape());\n\t}\n\n\t/**\n\t * Retrieve the message for the given code, using the \"defaultHtmlEscape\" setting.\n\t * @param code the code of the message\n\t * @param args arguments for the message as a List, or {@code null} if none\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t */\n\tpublic String getMessage(String code, @Nullable List<?> args, String defaultMessage) {\n\t\treturn getMessage(code, (args != null ? args.toArray() : null), defaultMessage, isDefaultHtmlEscape());\n\t}\n\n\t/**\n\t * Retrieve the message for the given code.\n\t * @param code the code of the message\n\t * @param args arguments for the message, or {@code null} if none\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @param htmlEscape if the message should be HTML-escaped\n\t * @return the message\n\t */\n\tpublic String getMessage(String code, @Nullable Object[] args, String defaultMessage, boolean htmlEscape) {\n\t\tString msg = this.webApplicationContext.getMessage(code, args, defaultMessage, getLocale());\n\t\tif (msg == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn (htmlEscape ? HtmlUtils.htmlEscape(msg) : msg);\n\t}\n\n\t/**\n\t * Retrieve the message for the given code, using the \"defaultHtmlEscape\" setting.\n\t * @param code the code of the message\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */\n\tpublic String getMessage(String code) throws NoSuchMessageException {\n\t\treturn getMessage(code, null, isDefaultHtmlEscape());\n\t}\n\n\t/**\n\t * Retrieve the message for the given code, using the \"defaultHtmlEscape\" setting.\n\t * @param code the code of the message\n\t * @param args arguments for the message, or {@code null} if none\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */\n\tpublic String getMessage(String code, @Nullable Object[] args) throws NoSuchMessageException {\n\t\treturn getMessage(code, args, isDefaultHtmlEscape());\n\t}\n\n\t/**\n\t * Retrieve the message for the given code, using the \"defaultHtmlEscape\" setting.\n\t * @param code the code of the message\n\t * @param args arguments for the message as a List, or {@code null} if none\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */\n\tpublic String getMessage(String code, @Nullable List<?> args) throws NoSuchMessageException {\n\t\treturn getMessage(code, (args != null ? args.toArray() : null), isDefaultHtmlEscape());\n\t}\n\n\t/**\n\t * Retrieve the message for the given code.\n\t * @param code the code of the message\n\t * @param args arguments for the message, or {@code null} if none\n\t * @param htmlEscape if the message should be HTML-escaped\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */\n\tpublic String getMessage(String code, @Nullable Object[] args, boolean htmlEscape) throws NoSuchMessageException {\n\t\tString msg = this.webApplicationContext.getMessage(code, args, getLocale());\n\t\treturn (htmlEscape ? HtmlUtils.htmlEscape(msg) : msg);\n\t}\n\n\t/**\n\t * Retrieve the given MessageSourceResolvable (e.g. an ObjectError instance), using the \"defaultHtmlEscape\" setting.\n\t * @param resolvable the MessageSourceResolvable\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */\n\tpublic String getMessage(MessageSourceResolvable resolvable) throws NoSuchMessageException {\n\t\treturn getMessage(resolvable, isDefaultHtmlEscape());\n\t}\n\n\t/**\n\t * Retrieve the given MessageSourceResolvable (e.g. an ObjectError instance).\n\t * @param resolvable the MessageSourceResolvable\n\t * @param htmlEscape if the message should be HTML-escaped\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */\n\tpublic String getMessage(MessageSourceResolvable resolvable, boolean htmlEscape) throws NoSuchMessageException {\n\t\tString msg = this.webApplicationContext.getMessage(resolvable, getLocale());\n\t\treturn (htmlEscape ? HtmlUtils.htmlEscape(msg) : msg);\n\t}\n\n\t/**\n\t * Retrieve the theme message for the given code.\n\t * <p>Note that theme messages are never HTML-escaped, as they typically denote\n\t * theme-specific resource paths and not client-visible messages.\n\t * @param code the code of the message\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t * @deprecated as of 6.0, with no direct replacement\n\t */\n\t@Deprecated\n\tpublic String getThemeMessage(String code, String defaultMessage) {\n\t\tString msg = getTheme().getMessageSource().getMessage(code, null, defaultMessage, getLocale());\n\t\treturn (msg != null ? msg : \"\");\n\t}\n\n\t/**\n\t * Retrieve the theme message for the given code.\n\t * <p>Note that theme messages are never HTML-escaped, as they typically denote\n\t * theme-specific resource paths and not client-visible messages.\n\t * @param code the code of the message\n\t * @param args arguments for the message, or {@code null} if none\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t * @deprecated as of 6.0, with no direct replacement\n\t */\n\t@Deprecated\n\tpublic String getThemeMessage(String code, @Nullable Object[] args, String defaultMessage) {\n\t\tString msg = getTheme().getMessageSource().getMessage(code, args, defaultMessage, getLocale());\n\t\treturn (msg != null ? msg : \"\");\n\t}\n\n\t/**\n\t * Retrieve the theme message for the given code.\n\t * <p>Note that theme messages are never HTML-escaped, as they typically denote\n\t * theme-specific resource paths and not client-visible messages.\n\t * @param code the code of the message\n\t * @param args arguments for the message as a List, or {@code null} if none\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t * @deprecated as of 6.0, with no direct replacement\n\t */\n\t@Deprecated\n\tpublic String getThemeMessage(String code, @Nullable List<?> args, String defaultMessage) {\n\t\tString msg = getTheme().getMessageSource().getMessage(code, (args != null ? args.toArray() : null),\n\t\t\t\tdefaultMessage, getLocale());\n\t\treturn (msg != null ? msg : \"\");\n\t}\n\n\t/**\n\t * Retrieve the theme message for the given code.\n\t * <p>Note that theme messages are never HTML-escaped, as they typically denote\n\t * theme-specific resource paths and not client-visible messages.\n\t * @param code the code of the message\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t * @deprecated as of 6.0, with no direct replacement\n\t */\n\t@Deprecated\n\tpublic String getThemeMessage(String code) throws NoSuchMessageException {\n\t\treturn getTheme().getMessageSource().getMessage(code, null, getLocale());\n\t}\n\n\t/**\n\t * Retrieve the theme message for the given code.\n\t * <p>Note that theme messages are never HTML-escaped, as they typically denote\n\t * theme-specific resource paths and not client-visible messages.\n\t * @param code the code of the message\n\t * @param args arguments for the message, or {@code null} if none\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t * @deprecated as of 6.0, with no direct replacement\n\t */\n\t@Deprecated\n\tpublic String getThemeMessage(String code, @Nullable Object[] args) throws NoSuchMessageException {\n\t\treturn getTheme().getMessageSource().getMessage(code, args, getLocale());\n\t}\n\n\t/**\n\t * Retrieve the theme message for the given code.\n\t * <p>Note that theme messages are never HTML-escaped, as they typically denote\n\t * theme-specific resource paths and not client-visible messages.\n\t * @param code the code of the message\n\t * @param args arguments for the message as a List, or {@code null} if none\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t * @deprecated as of 6.0, with no direct replacement\n\t */\n\t@Deprecated\n\tpublic String getThemeMessage(String code, @Nullable List<?> args) throws NoSuchMessageException {\n\t\treturn getTheme().getMessageSource().getMessage(code, (args != null ? args.toArray() : null), getLocale());\n\t}\n\n\t/**\n\t * Retrieve the given MessageSourceResolvable in the current theme.\n\t * <p>Note that theme messages are never HTML-escaped, as they typically denote\n\t * theme-specific resource paths and not client-visible messages.\n\t * @param resolvable the MessageSourceResolvable\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t * @deprecated as of 6.0, with no direct replacement\n\t */\n\t@Deprecated\n\tpublic String getThemeMessage(MessageSourceResolvable resolvable) throws NoSuchMessageException {\n\t\treturn getTheme().getMessageSource().getMessage(resolvable, getLocale());\n\t}\n\n\t/**\n\t * Retrieve the Errors instance for the given bind object, using the \"defaultHtmlEscape\" setting.\n\t * @param name the name of the bind object\n\t * @return the Errors instance, or {@code null} if not found\n\t */\n\t@Nullable\n\tpublic Errors getErrors(String name) {\n\t\treturn getErrors(name, isDefaultHtmlEscape());\n\t}\n\n\t/**\n\t * Retrieve the Errors instance for the given bind object.\n\t * @param name the name of the bind object\n\t * @param htmlEscape create an Errors instance with automatic HTML escaping?\n\t * @return the Errors instance, or {@code null} if not found\n\t */\n\t@Nullable\n\tpublic Errors getErrors(String name, boolean htmlEscape) {\n\t\tif (this.errorsMap == null) {\n\t\t\tthis.errorsMap = new HashMap<>();\n\t\t}\n\t\tErrors errors = this.errorsMap.get(name);\n\t\tboolean put = false;\n\t\tif (errors == null) {\n\t\t\terrors = (Errors) getModelObject(BindingResult.MODEL_KEY_PREFIX + name);\n\t\t\t// Check old BindException prefix for backwards compatibility.\n\t\t\tif (errors instanceof BindException bindException) {\n\t\t\t\terrors = bindException.getBindingResult();\n\t\t\t}\n\t\t\tif (errors == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tput = true;\n\t\t}\n\t\tif (htmlEscape && !(errors instanceof EscapedErrors)) {\n\t\t\terrors = new EscapedErrors(errors);\n\t\t\tput = true;\n\t\t}\n\t\telse if (!htmlEscape && errors instanceof EscapedErrors escapedErrors) {\n\t\t\terrors = escapedErrors.getSource();\n\t\t\tput = true;\n\t\t}\n\t\tif (put) {\n\t\t\tthis.errorsMap.put(name, errors);\n\t\t}\n\t\treturn errors;\n\t}\n\n\t/**\n\t * Retrieve the model object for the given model name, either from the model\n\t * or from the request attributes.\n\t * @param modelName the name of the model object\n\t * @return the model object\n\t */\n\t@Nullable\n\tprotected Object getModelObject(String modelName) {\n\t\tif (this.model != null) {\n\t\t\treturn this.model.get(modelName);\n\t\t}\n\t\telse {\n\t\t\treturn this.request.getAttribute(modelName);\n\t\t}\n\t}\n\n\t/**\n\t * Create a BindStatus for the given bind object, using the \"defaultHtmlEscape\" setting.\n\t * @param path the bean and property path for which values and errors will be resolved (e.g. \"person.age\")\n\t * @return the new BindStatus instance\n\t * @throws IllegalStateException if no corresponding Errors object found\n\t */\n\tpublic BindStatus getBindStatus(String path) throws IllegalStateException {\n\t\treturn new BindStatus(this, path, isDefaultHtmlEscape());\n\t}\n\n\t/**\n\t * Create a BindStatus for the given bind object, using the \"defaultHtmlEscape\" setting.\n\t * @param path the bean and property path for which values and errors will be resolved (e.g. \"person.age\")\n\t * @param htmlEscape create a BindStatus with automatic HTML escaping?\n\t * @return the new BindStatus instance\n\t * @throws IllegalStateException if no corresponding Errors object found\n\t */\n\tpublic BindStatus getBindStatus(String path, boolean htmlEscape) throws IllegalStateException {\n\t\treturn new BindStatus(this, path, htmlEscape);\n\t}\n\n\n\t/**\n\t * Inner class that isolates the JSTL dependency.\n\t * Just called to resolve the fallback locale if the JSTL API is present.\n\t */\n\tprivate static class JstlLocaleResolver {\n\n\t\t@Nullable\n\t\tpublic static Locale getJstlLocale(HttpServletRequest request, @Nullable ServletContext servletContext) {\n\t\t\tObject localeObject = Config.get(request, Config.FMT_LOCALE);\n\t\t\tif (localeObject == null) {\n\t\t\t\tHttpSession session = request.getSession(false);\n\t\t\t\tif (session != null) {\n\t\t\t\t\tlocaleObject = Config.get(session, Config.FMT_LOCALE);\n\t\t\t\t}\n\t\t\t\tif (localeObject == null && servletContext != null) {\n\t\t\t\t\tlocaleObject = Config.get(servletContext, Config.FMT_LOCALE);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn (localeObject instanceof Locale locale ? locale : null);\n\t\t}\n\n\t\t@Nullable\n\t\tpublic static TimeZone getJstlTimeZone(HttpServletRequest request, @Nullable ServletContext servletContext) {\n\t\t\tObject timeZoneObject = Config.get(request, Config.FMT_TIME_ZONE);\n\t\t\tif (timeZoneObject == null) {\n\t\t\t\tHttpSession session = request.getSession(false);\n\t\t\t\tif (session != null) {\n\t\t\t\t\ttimeZoneObject = Config.get(session, Config.FMT_TIME_ZONE);\n\t\t\t\t}\n\t\t\t\tif (timeZoneObject == null && servletContext != null) {\n\t\t\t\t\ttimeZoneObject = Config.get(servletContext, Config.FMT_TIME_ZONE);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn (timeZoneObject instanceof TimeZone timeZone ? timeZone : null);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.servlet.support.RequestContext#changeLocale(locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Change the current locale to the specified one,\n\t * storing the new locale through the configured {@link LocaleResolver}.\n\t * @param locale the new locale\n\t * @see LocaleResolver#setLocale\n\t * @see #changeLocale(java.util.Locale, java.util.TimeZone)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 362
    },
    "return": "void",
    "signature": "public void changeLocale(Locale locale)",
    "source_code": "\tpublic void changeLocale(Locale locale) {\n\t\tLocaleResolver localeResolver = RequestContextUtils.getLocaleResolver(this.request);\n\t\tif (localeResolver == null) {\n\t\t\tthrow new IllegalStateException(\"Cannot change locale if no LocaleResolver configured\");\n\t\t}\n\t\tlocaleResolver.setLocale(this.request, this.response, locale);\n\t\tthis.locale = locale;\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#changeLocale(locale,timeZone)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Change the current locale to the specified locale and time zone context,\n\t * storing the new locale context through the configured {@link LocaleResolver}.\n\t * @param locale the new locale\n\t * @param timeZone the new time zone\n\t * @see LocaleContextResolver#setLocaleContext\n\t * @see org.springframework.context.i18n.SimpleTimeZoneAwareLocaleContext\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locale",
      "timeZone"
    ],
    "position": {
      "column": 1,
      "line": 379
    },
    "return": "void",
    "signature": "public void changeLocale(Locale locale, TimeZone timeZone)",
    "source_code": "\tpublic void changeLocale(Locale locale, TimeZone timeZone) {\n\t\tLocaleResolver localeResolver = RequestContextUtils.getLocaleResolver(this.request);\n\t\tif (!(localeResolver instanceof LocaleContextResolver localeContextResolver)) {\n\t\t\tthrow new IllegalStateException(\"Cannot change locale context if no LocaleContextResolver configured\");\n\t\t}\n\t\tlocaleContextResolver.setLocaleContext(this.request, this.response,\n\t\t\t\tnew SimpleTimeZoneAwareLocaleContext(locale, timeZone));\n\t\tthis.locale = locale;\n\t\tthis.timeZone = timeZone;\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#changeTheme(theme)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Change the current theme to the specified one,\n\t * storing the new theme name through the configured\n\t * {@link org.springframework.web.servlet.ThemeResolver ThemeResolver}.\n\t * @param theme the new theme\n\t * @see org.springframework.web.servlet.ThemeResolver#setThemeName\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "theme"
    ],
    "position": {
      "column": 1,
      "line": 436
    },
    "return": "void",
    "signature": "public void changeTheme(@Nullable org.springframework.ui.context.Theme theme)",
    "source_code": "\tpublic void changeTheme(@Nullable org.springframework.ui.context.Theme theme) {\n\t\torg.springframework.web.servlet.ThemeResolver themeResolver = RequestContextUtils.getThemeResolver(this.request);\n\t\tif (themeResolver == null) {\n\t\t\tthrow new IllegalStateException(\"Cannot change theme if no ThemeResolver configured\");\n\t\t}\n\t\tthemeResolver.setThemeName(this.request, this.response, (theme != null ? theme.getName() : null));\n\t\tthis.theme = theme;\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#changeTheme(themeName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Change the current theme to the specified theme by name,\n\t * storing the new theme name through the configured\n\t * {@link org.springframework.web.servlet.ThemeResolver ThemeResolver}.\n\t * @param themeName the name of the new theme\n\t * @see org.springframework.web.servlet.ThemeResolver#setThemeName\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "themeName"
    ],
    "position": {
      "column": 1,
      "line": 454
    },
    "return": "void",
    "signature": "public void changeTheme(String themeName)",
    "source_code": "\tpublic void changeTheme(String themeName) {\n\t\torg.springframework.web.servlet.ThemeResolver themeResolver = RequestContextUtils.getThemeResolver(this.request);\n\t\tif (themeResolver == null) {\n\t\t\tthrow new IllegalStateException(\"Cannot change theme if no ThemeResolver configured\");\n\t\t}\n\t\tthemeResolver.setThemeName(this.request, this.response, themeName);\n\t\t// Ask for re-resolution on next getTheme call.\n\t\tthis.theme = null;\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getBindStatus(path)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a BindStatus for the given bind object, using the \"defaultHtmlEscape\" setting.\n\t * @param path the bean and property path for which values and errors will be resolved (e.g. \"person.age\")\n\t * @return the new BindStatus instance\n\t * @throws IllegalStateException if no corresponding Errors object found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path"
    ],
    "position": {
      "column": 1,
      "line": 914
    },
    "return": "BindStatus",
    "signature": "public BindStatus getBindStatus(String path)",
    "source_code": "\tpublic BindStatus getBindStatus(String path) throws IllegalStateException {\n\t\treturn new BindStatus(this, path, isDefaultHtmlEscape());\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getBindStatus(path,htmlEscape)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a BindStatus for the given bind object, using the \"defaultHtmlEscape\" setting.\n\t * @param path the bean and property path for which values and errors will be resolved (e.g. \"person.age\")\n\t * @param htmlEscape create a BindStatus with automatic HTML escaping?\n\t * @return the new BindStatus instance\n\t * @throws IllegalStateException if no corresponding Errors object found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 925
    },
    "return": "BindStatus",
    "signature": "public BindStatus getBindStatus(String path, boolean htmlEscape)",
    "source_code": "\tpublic BindStatus getBindStatus(String path, boolean htmlEscape) throws IllegalStateException {\n\t\treturn new BindStatus(this, path, htmlEscape);\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getContextPath()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the context path of the original request, that is, the path that\n\t * indicates the current web application. This is useful for building links\n\t * to other resources within the application.\n\t * <p>Delegates to the UrlPathHelper for decoding.\n\t * @see jakarta.servlet.http.HttpServletRequest#getContextPath\n\t * @see #getUrlPathHelper\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 548
    },
    "return": "String",
    "signature": "public String getContextPath()",
    "source_code": "\tpublic String getContextPath() {\n\t\treturn this.urlPathHelper.getOriginatingContextPath(this.request);\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getContextUrl(relativeUrl)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a context-aware URl for the given relative URL.\n\t * @param relativeUrl the relative URL part\n\t * @return a URL that points back to the server with an absolute path (also URL-encoded accordingly)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "relativeUrl"
    ],
    "position": {
      "column": 1,
      "line": 557
    },
    "return": "String",
    "signature": "public String getContextUrl(String relativeUrl)",
    "source_code": "\tpublic String getContextUrl(String relativeUrl) {\n\t\tString url = getContextPath() + relativeUrl;\n\t\tif (this.response != null) {\n\t\t\turl = this.response.encodeURL(url);\n\t\t}\n\t\treturn url;\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getContextUrl(relativeUrl,Map<String,params)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a context-aware URl for the given relative URL with placeholders (named keys with braces {@code {}}).\n\t * For example, send in a relative URL {@code foo/{bar}?spam={spam}} and a parameter map\n\t * {@code {bar=baz,spam=nuts}} and the result will be {@code [contextpath]/foo/baz?spam=nuts}.\n\t * @param relativeUrl the relative URL part\n\t * @param params a map of parameters to insert as placeholders in the url\n\t * @return a URL that points back to the server with an absolute path (also URL-encoded accordingly)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "relativeUrl",
      "Map<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 573
    },
    "return": "String",
    "signature": "public String getContextUrl(String relativeUrl, Map<String, ?> params)",
    "source_code": "\tpublic String getContextUrl(String relativeUrl, Map<String, ?> params) {\n\t\tString url = getContextPath() + relativeUrl;\n\t\turl = UriComponentsBuilder.fromUriString(url).buildAndExpand(params).encode().toUri().toASCIIString();\n\t\tif (this.response != null) {\n\t\t\turl = this.response.encodeURL(url);\n\t\t}\n\t\treturn url;\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getDefaultHtmlEscape()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the default HTML escape setting, differentiating between no default specified and an explicit value.\n\t * @return whether default HTML escaping is enabled (null = no explicit default)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 485
    },
    "return": "Boolean",
    "signature": "public Boolean getDefaultHtmlEscape()",
    "source_code": "\tpublic Boolean getDefaultHtmlEscape() {\n\t\treturn this.defaultHtmlEscape;\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getErrors(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the Errors instance for the given bind object, using the \"defaultHtmlEscape\" setting.\n\t * @param name the name of the bind object\n\t * @return the Errors instance, or {@code null} if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 850
    },
    "return": "Errors",
    "signature": "public Errors getErrors(String name)",
    "source_code": "\tpublic Errors getErrors(String name) {\n\t\treturn getErrors(name, isDefaultHtmlEscape());\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getErrors(name,htmlEscape)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the Errors instance for the given bind object.\n\t * @param name the name of the bind object\n\t * @param htmlEscape create an Errors instance with automatic HTML escaping?\n\t * @return the Errors instance, or {@code null} if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 861
    },
    "return": "Errors",
    "signature": "public Errors getErrors(String name, boolean htmlEscape)",
    "source_code": "\tpublic Errors getErrors(String name, boolean htmlEscape) {\n\t\tif (this.errorsMap == null) {\n\t\t\tthis.errorsMap = new HashMap<>();\n\t\t}\n\t\tErrors errors = this.errorsMap.get(name);\n\t\tboolean put = false;\n\t\tif (errors == null) {\n\t\t\terrors = (Errors) getModelObject(BindingResult.MODEL_KEY_PREFIX + name);\n\t\t\t// Check old BindException prefix for backwards compatibility.\n\t\t\tif (errors instanceof BindException bindException) {\n\t\t\t\terrors = bindException.getBindingResult();\n\t\t\t}\n\t\t\tif (errors == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tput = true;\n\t\t}\n\t\tif (htmlEscape && !(errors instanceof EscapedErrors)) {\n\t\t\terrors = new EscapedErrors(errors);\n\t\t\tput = true;\n\t\t}\n\t\telse if (!htmlEscape && errors instanceof EscapedErrors escapedErrors) {\n\t\t\terrors = escapedErrors.getSource();\n\t\t\tput = true;\n\t\t}\n\t\tif (put) {\n\t\t\tthis.errorsMap.put(name, errors);\n\t\t}\n\t\treturn errors;\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getFallbackLocale()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the fallback locale for this context.\n\t * <p>The default implementation checks for a JSTL locale attribute in request, session\n\t * or application scope; if not found, returns the {@code HttpServletRequest.getLocale()}.\n\t * @return the fallback locale (never {@code null})\n\t * @see jakarta.servlet.http.HttpServletRequest#getLocale()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 328
    },
    "return": "Locale",
    "signature": "protected Locale getFallbackLocale()",
    "source_code": "\tprotected Locale getFallbackLocale() {\n\t\tif (jstlPresent) {\n\t\t\tLocale locale = JstlLocaleResolver.getJstlLocale(getRequest(), getServletContext());\n\t\t\tif (locale != null) {\n\t\t\t\treturn locale;\n\t\t\t}\n\t\t}\n\t\treturn getRequest().getLocale();\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getFallbackTimeZone()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the fallback time zone for this context.\n\t * <p>The default implementation checks for a JSTL time zone attribute in request,\n\t * session or application scope; returns {@code null} if not found.\n\t * @return the fallback time zone (or {@code null} if none derivable from the request)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 345
    },
    "return": "TimeZone",
    "signature": "protected TimeZone getFallbackTimeZone()",
    "source_code": "\tprotected TimeZone getFallbackTimeZone() {\n\t\tif (jstlPresent) {\n\t\t\tTimeZone timeZone = JstlLocaleResolver.getJstlTimeZone(getRequest(), getServletContext());\n\t\t\tif (timeZone != null) {\n\t\t\t\treturn timeZone;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getJstlLocale(request,servletContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 937
    },
    "return": "Locale",
    "signature": "public Locale getJstlLocale(HttpServletRequest request, @Nullable ServletContext servletContext)",
    "source_code": "\t\tpublic static Locale getJstlLocale(HttpServletRequest request, @Nullable ServletContext servletContext) {\n\t\t\tObject localeObject = Config.get(request, Config.FMT_LOCALE);\n\t\t\tif (localeObject == null) {\n\t\t\t\tHttpSession session = request.getSession(false);\n\t\t\t\tif (session != null) {\n\t\t\t\t\tlocaleObject = Config.get(session, Config.FMT_LOCALE);\n\t\t\t\t}\n\t\t\t\tif (localeObject == null && servletContext != null) {\n\t\t\t\t\tlocaleObject = Config.get(servletContext, Config.FMT_LOCALE);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn (localeObject instanceof Locale locale ? locale : null);\n\t\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getJstlTimeZone(request,servletContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 952
    },
    "return": "TimeZone",
    "signature": "public TimeZone getJstlTimeZone(HttpServletRequest request, @Nullable ServletContext servletContext)",
    "source_code": "\t\tpublic static TimeZone getJstlTimeZone(HttpServletRequest request, @Nullable ServletContext servletContext) {\n\t\t\tObject timeZoneObject = Config.get(request, Config.FMT_TIME_ZONE);\n\t\t\tif (timeZoneObject == null) {\n\t\t\t\tHttpSession session = request.getSession(false);\n\t\t\t\tif (session != null) {\n\t\t\t\t\ttimeZoneObject = Config.get(session, Config.FMT_TIME_ZONE);\n\t\t\t\t}\n\t\t\t\tif (timeZoneObject == null && servletContext != null) {\n\t\t\t\t\ttimeZoneObject = Config.get(servletContext, Config.FMT_TIME_ZONE);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn (timeZoneObject instanceof TimeZone timeZone ? timeZone : null);\n\t\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getLocale()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the current Locale (falling back to the request locale; never {@code null}).\n\t * <p>Typically coming from a DispatcherServlet's {@link LocaleResolver}.\n\t * Also includes a fallback check for JSTL's Locale attribute.\n\t * @see RequestContextUtils#getLocale\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 306
    },
    "return": "Locale",
    "signature": "public Locale getLocale()",
    "source_code": "\tpublic final Locale getLocale() {\n\t\treturn (this.locale != null ? this.locale : getFallbackLocale());\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getMessage(code)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code, using the \"defaultHtmlEscape\" setting.\n\t * @param code the code of the message\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code"
    ],
    "position": {
      "column": 1,
      "line": 677
    },
    "return": "String",
    "signature": "public String getMessage(String code)",
    "source_code": "\tpublic String getMessage(String code) throws NoSuchMessageException {\n\t\treturn getMessage(code, null, isDefaultHtmlEscape());\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getMessage(code,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code, using the \"defaultHtmlEscape\" setting.\n\t * @param code the code of the message\n\t * @param args arguments for the message as a List, or {@code null} if none\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 699
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable List<?> args)",
    "source_code": "\tpublic String getMessage(String code, @Nullable List<?> args) throws NoSuchMessageException {\n\t\treturn getMessage(code, (args != null ? args.toArray() : null), isDefaultHtmlEscape());\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getMessage(code,args,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code, using the \"defaultHtmlEscape\" setting.\n\t * @param code the code of the message\n\t * @param args arguments for the message as a List, or {@code null} if none\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 651
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable List<?> args, String defaultMessage)",
    "source_code": "\tpublic String getMessage(String code, @Nullable List<?> args, String defaultMessage) {\n\t\treturn getMessage(code, (args != null ? args.toArray() : null), defaultMessage, isDefaultHtmlEscape());\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getMessage(code,args,defaultMessage,htmlEscape)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code.\n\t * @param code the code of the message\n\t * @param args arguments for the message, or {@code null} if none\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @param htmlEscape if the message should be HTML-escaped\n\t * @return the message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "defaultMessage",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 663
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable Object[] args, String defaultMessage, boolean htmlEscape)",
    "source_code": "\tpublic String getMessage(String code, @Nullable Object[] args, String defaultMessage, boolean htmlEscape) {\n\t\tString msg = this.webApplicationContext.getMessage(code, args, defaultMessage, getLocale());\n\t\tif (msg == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn (htmlEscape ? HtmlUtils.htmlEscape(msg) : msg);\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getMessage(code,args,htmlEscape)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code.\n\t * @param code the code of the message\n\t * @param args arguments for the message, or {@code null} if none\n\t * @param htmlEscape if the message should be HTML-escaped\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 711
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable Object[] args, boolean htmlEscape)",
    "source_code": "\tpublic String getMessage(String code, @Nullable Object[] args, boolean htmlEscape) throws NoSuchMessageException {\n\t\tString msg = this.webApplicationContext.getMessage(code, args, getLocale());\n\t\treturn (htmlEscape ? HtmlUtils.htmlEscape(msg) : msg);\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getMessage(code,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code, using the \"defaultHtmlEscape\" setting.\n\t * @param code the code of the message\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 629
    },
    "return": "String",
    "signature": "public String getMessage(String code, String defaultMessage)",
    "source_code": "\tpublic String getMessage(String code, String defaultMessage) {\n\t\treturn getMessage(code, null, defaultMessage, isDefaultHtmlEscape());\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getMessage(resolvable)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the given MessageSourceResolvable (e.g. an ObjectError instance), using the \"defaultHtmlEscape\" setting.\n\t * @param resolvable the MessageSourceResolvable\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolvable"
    ],
    "position": {
      "column": 1,
      "line": 722
    },
    "return": "String",
    "signature": "public String getMessage(MessageSourceResolvable resolvable)",
    "source_code": "\tpublic String getMessage(MessageSourceResolvable resolvable) throws NoSuchMessageException {\n\t\treturn getMessage(resolvable, isDefaultHtmlEscape());\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getMessage(resolvable,htmlEscape)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the given MessageSourceResolvable (e.g. an ObjectError instance).\n\t * @param resolvable the MessageSourceResolvable\n\t * @param htmlEscape if the message should be HTML-escaped\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolvable",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 733
    },
    "return": "String",
    "signature": "public String getMessage(MessageSourceResolvable resolvable, boolean htmlEscape)",
    "source_code": "\tpublic String getMessage(MessageSourceResolvable resolvable, boolean htmlEscape) throws NoSuchMessageException {\n\t\tString msg = this.webApplicationContext.getMessage(resolvable, getLocale());\n\t\treturn (htmlEscape ? HtmlUtils.htmlEscape(msg) : msg);\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getMessageSource()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the current WebApplicationContext as MessageSource.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "MessageSource",
    "signature": "public MessageSource getMessageSource()",
    "source_code": "\tpublic final MessageSource getMessageSource() {\n\t\treturn this.webApplicationContext;\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getModel()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the model Map that this RequestContext encapsulates, if any.\n\t * @return the populated model Map, or {@code null} if none available\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "Object>",
    "signature": "public Object> getModel()",
    "source_code": "\tpublic final Map<String, Object> getModel() {\n\t\treturn this.model;\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getModelObject(modelName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the model object for the given model name, either from the model\n\t * or from the request attributes.\n\t * @param modelName the name of the model object\n\t * @return the model object\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "modelName"
    ],
    "position": {
      "column": 1,
      "line": 899
    },
    "return": "Object",
    "signature": "protected Object getModelObject(String modelName)",
    "source_code": "\tprotected Object getModelObject(String modelName) {\n\t\tif (this.model != null) {\n\t\t\treturn this.model.get(modelName);\n\t\t}\n\t\telse {\n\t\t\treturn this.request.getAttribute(modelName);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getPathToServlet()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the path to URL mappings within the current servlet including the\n\t * context path and the servlet path of the original request. This is useful\n\t * for building links to other resources within the application where a\n\t * servlet mapping of the style {@code \"/main/*\"} is used.\n\t * <p>Delegates to the UrlPathHelper to determine the context and servlet path.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 589
    },
    "return": "String",
    "signature": "public String getPathToServlet()",
    "source_code": "\tpublic String getPathToServlet() {\n\t\tString path = this.urlPathHelper.getOriginatingContextPath(this.request);\n\t\tif (StringUtils.hasText(this.urlPathHelper.getPathWithinServletMapping(this.request))) {\n\t\t\tpath += this.urlPathHelper.getOriginatingServletPath(this.request);\n\t\t}\n\t\treturn path;\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getQueryString()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the query string of the current request, that is, the part after\n\t * the request path. This is particularly useful for building an HTML form\n\t * action target in combination with the original request URI.\n\t * <p>Delegates to the UrlPathHelper for decoding.\n\t * @see #getRequestUri\n\t * @see org.springframework.web.util.UrlPathHelper#getOriginatingQueryString\n\t * @see #getUrlPathHelper\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 619
    },
    "return": "String",
    "signature": "public String getQueryString()",
    "source_code": "\tpublic String getQueryString() {\n\t\treturn this.urlPathHelper.getOriginatingQueryString(this.request);\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getRequest()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the underlying HttpServletRequest. Only intended for cooperating classes in this package.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 265
    },
    "return": "HttpServletRequest",
    "signature": "protected HttpServletRequest getRequest()",
    "source_code": "\tprotected final HttpServletRequest getRequest() {\n\t\treturn this.request;\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getRequestDataValueProcessor()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the RequestDataValueProcessor instance to use obtained from the\n\t * WebApplicationContext under the name {@code \"requestDataValueProcessor\"}.\n\t * Or {@code null} if no matching bean was found.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 536
    },
    "return": "RequestDataValueProcessor",
    "signature": "public RequestDataValueProcessor getRequestDataValueProcessor()",
    "source_code": "\tpublic RequestDataValueProcessor getRequestDataValueProcessor() {\n\t\treturn this.requestDataValueProcessor;\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getRequestUri()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the request URI of the original request, that is, the invoked URL\n\t * without parameters. This is particularly useful as HTML form action target,\n\t * possibly in combination with the original query string.\n\t * <p>Delegates to the UrlPathHelper for decoding.\n\t * @see #getQueryString\n\t * @see org.springframework.web.util.UrlPathHelper#getOriginatingRequestUri\n\t * @see #getUrlPathHelper\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 606
    },
    "return": "String",
    "signature": "public String getRequestUri()",
    "source_code": "\tpublic String getRequestUri() {\n\t\treturn this.urlPathHelper.getOriginatingRequestUri(this.request);\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getResponseEncodedHtmlEscape()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the default setting about use of response encoding for HTML escape setting,\n\t * differentiating between no default specified and an explicit value.\n\t * @return whether default use of response encoding HTML escaping is enabled (null = no explicit default)\n\t * @since 4.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 506
    },
    "return": "Boolean",
    "signature": "public Boolean getResponseEncodedHtmlEscape()",
    "source_code": "\tpublic Boolean getResponseEncodedHtmlEscape() {\n\t\treturn this.responseEncodedHtmlEscape;\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getServletContext()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the underlying ServletContext. Only intended for cooperating classes in this package.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "ServletContext",
    "signature": "protected ServletContext getServletContext()",
    "source_code": "\tprotected final ServletContext getServletContext() {\n\t\treturn this.webApplicationContext.getServletContext();\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getThemeMessage(code)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the theme message for the given code.\n\t * <p>Note that theme messages are never HTML-escaped, as they typically denote\n\t * theme-specific resource paths and not client-visible messages.\n\t * @param code the code of the message\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code"
    ],
    "position": {
      "column": 1,
      "line": 796
    },
    "return": "String",
    "signature": "public String getThemeMessage(String code)",
    "source_code": "\tpublic String getThemeMessage(String code) throws NoSuchMessageException {\n\t\treturn getTheme().getMessageSource().getMessage(code, null, getLocale());\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getThemeMessage(code,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the theme message for the given code.\n\t * <p>Note that theme messages are never HTML-escaped, as they typically denote\n\t * theme-specific resource paths and not client-visible messages.\n\t * @param code the code of the message\n\t * @param args arguments for the message as a List, or {@code null} if none\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 826
    },
    "return": "String",
    "signature": "public String getThemeMessage(String code, @Nullable List<?> args)",
    "source_code": "\tpublic String getThemeMessage(String code, @Nullable List<?> args) throws NoSuchMessageException {\n\t\treturn getTheme().getMessageSource().getMessage(code, (args != null ? args.toArray() : null), getLocale());\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getThemeMessage(code,args,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the theme message for the given code.\n\t * <p>Note that theme messages are never HTML-escaped, as they typically denote\n\t * theme-specific resource paths and not client-visible messages.\n\t * @param code the code of the message\n\t * @param args arguments for the message as a List, or {@code null} if none\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 780
    },
    "return": "String",
    "signature": "public String getThemeMessage(String code, @Nullable List<?> args, String defaultMessage)",
    "source_code": "\tpublic String getThemeMessage(String code, @Nullable List<?> args, String defaultMessage) {\n\t\tString msg = getTheme().getMessageSource().getMessage(code, (args != null ? args.toArray() : null),\n\t\t\t\tdefaultMessage, getLocale());\n\t\treturn (msg != null ? msg : \"\");\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getThemeMessage(code,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the theme message for the given code.\n\t * <p>Note that theme messages are never HTML-escaped, as they typically denote\n\t * theme-specific resource paths and not client-visible messages.\n\t * @param code the code of the message\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 748
    },
    "return": "String",
    "signature": "public String getThemeMessage(String code, String defaultMessage)",
    "source_code": "\tpublic String getThemeMessage(String code, String defaultMessage) {\n\t\tString msg = getTheme().getMessageSource().getMessage(code, null, defaultMessage, getLocale());\n\t\treturn (msg != null ? msg : \"\");\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getThemeMessage(resolvable)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the given MessageSourceResolvable in the current theme.\n\t * <p>Note that theme messages are never HTML-escaped, as they typically denote\n\t * theme-specific resource paths and not client-visible messages.\n\t * @param resolvable the MessageSourceResolvable\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolvable"
    ],
    "position": {
      "column": 1,
      "line": 840
    },
    "return": "String",
    "signature": "public String getThemeMessage(MessageSourceResolvable resolvable)",
    "source_code": "\tpublic String getThemeMessage(MessageSourceResolvable resolvable) throws NoSuchMessageException {\n\t\treturn getTheme().getMessageSource().getMessage(resolvable, getLocale());\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getTimeZone()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the current TimeZone (or {@code null} if none derivable from the request).\n\t * <p>Typically coming from a DispatcherServlet's {@link LocaleContextResolver}.\n\t * Also includes a fallback check for JSTL's TimeZone attribute.\n\t * @see RequestContextUtils#getTimeZone\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 317
    },
    "return": "TimeZone",
    "signature": "public TimeZone getTimeZone()",
    "source_code": "\tpublic TimeZone getTimeZone() {\n\t\treturn (this.timeZone != null ? this.timeZone : getFallbackTimeZone());\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getUrlPathHelper()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the UrlPathHelper used for context path and request URI decoding.\n\t * Can be used to configure the current UrlPathHelper.\n\t * <p>A default UrlPathHelper is always available.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 526
    },
    "return": "UrlPathHelper",
    "signature": "public UrlPathHelper getUrlPathHelper()",
    "source_code": "\tpublic UrlPathHelper getUrlPathHelper() {\n\t\treturn this.urlPathHelper;\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getWebApplicationContext()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the current WebApplicationContext.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "WebApplicationContext",
    "signature": "public WebApplicationContext getWebApplicationContext()",
    "source_code": "\tpublic final WebApplicationContext getWebApplicationContext() {\n\t\treturn this.webApplicationContext;\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#isDefaultHtmlEscape()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Is default HTML escaping active? Falls back to {@code false} in case of no explicit default given.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 476
    },
    "return": "boolean",
    "signature": "public boolean isDefaultHtmlEscape()",
    "source_code": "\tpublic boolean isDefaultHtmlEscape() {\n\t\treturn (this.defaultHtmlEscape != null && this.defaultHtmlEscape.booleanValue());\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#isResponseEncodedHtmlEscape()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Is HTML escaping using the response encoding by default?\n\t * If enabled, only XML markup significant characters will be escaped with UTF-* encodings.\n\t * <p>Falls back to {@code true} in case of no explicit default given, as of Spring 4.2.\n\t * @since 4.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 495
    },
    "return": "boolean",
    "signature": "public boolean isResponseEncodedHtmlEscape()",
    "source_code": "\tpublic boolean isResponseEncodedHtmlEscape() {\n\t\treturn (this.responseEncodedHtmlEscape == null || this.responseEncodedHtmlEscape.booleanValue());\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#setDefaultHtmlEscape(defaultHtmlEscape)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * (De)activate default HTML escaping for messages and errors, for the scope of this RequestContext.\n\t * <p>The default is the application-wide setting (the \"defaultHtmlEscape\" context-param in web.xml).\n\t * @see org.springframework.web.util.WebUtils#getDefaultHtmlEscape\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultHtmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 469
    },
    "return": "void",
    "signature": "public void setDefaultHtmlEscape(boolean defaultHtmlEscape)",
    "source_code": "\tpublic void setDefaultHtmlEscape(boolean defaultHtmlEscape) {\n\t\tthis.defaultHtmlEscape = defaultHtmlEscape;\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#setUrlPathHelper(urlPathHelper)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the UrlPathHelper to use for context path and request URI decoding.\n\t * Can be used to pass a shared UrlPathHelper instance in.\n\t * <p>A default UrlPathHelper is always available.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "urlPathHelper"
    ],
    "position": {
      "column": 1,
      "line": 516
    },
    "return": "void",
    "signature": "public void setUrlPathHelper(UrlPathHelper urlPathHelper)",
    "source_code": "\tpublic void setUrlPathHelper(UrlPathHelper urlPathHelper) {\n\t\tAssert.notNull(urlPathHelper, \"UrlPathHelper must not be null\");\n\t\tthis.urlPathHelper = urlPathHelper;\n\t}"
  },
  "org.springframework.web.servlet.support.WEB_APPLICATION_CONTEXT_ATTRIBUTE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Request attribute to hold the current web application context for RequestContext usage.\n\t * By default, the DispatcherServlet's context (or the root context as fallback) is exposed.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "signature": "public String WEB_APPLICATION_CONTEXT_ATTRIBUTE",
    "source_code": "\tpublic static final String WEB_APPLICATION_CONTEXT_ATTRIBUTE = RequestContext.class.getName() + \".CONTEXT\";",
    "type": "String"
  },
  "org.springframework.web.servlet.support.jstlPresent": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "signature": "protected boolean jstlPresent",
    "source_code": "\tprotected static final boolean jstlPresent = ClassUtils.isPresent(",
    "type": "boolean"
  },
  "org.springframework.web.servlet.tags.DEFAULT_ARGUMENT_SEPARATOR": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Default separator for splitting an arguments String: a comma (\",\").\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "signature": "public String DEFAULT_ARGUMENT_SEPARATOR",
    "source_code": "\tpublic static final String DEFAULT_ARGUMENT_SEPARATOR = \",\";",
    "type": "String"
  },
  "org.springframework.web.servlet.tags.MessageTag": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * The {@code <message>} tag looks up a message in the scope of this page.\n * Messages are resolved using the ApplicationContext and thus support\n * internationalization.\n *\n * <p>Detects an HTML escaping setting, either on this tag instance, the page level,\n * or the {@code web.xml} level. Can also apply JavaScript escaping.\n *\n * <p>If \"code\" isn't set or cannot be resolved, \"text\" will be used as default\n * message. Thus, this tag can also be used for HTML escaping of any texts.\n *\n * <p>Message arguments can be specified via the {@link #setArguments(Object) arguments}\n * attribute or by using nested {@code <spring:argument>} tags.\n *\n * <table>\n * <caption>Attribute Summary</caption>\n * <thead>\n * <tr>\n * <th>Attribute</th>\n * <th>Required?</th>\n * <th>Runtime Expression?</th>\n * <th>Description</th>\n * </tr>\n * </thead>\n * <tbody>\n * <tr>\n * <td>arguments</td>\n * <td>false</td>\n * <td>true</td>\n * <td>Set optional message arguments for this tag, as a (comma-)delimited\n * String (each String argument can contain JSP EL), an Object array (used as\n * argument array), or a single Object (used as single argument).</td>\n * </tr>\n * <tr>\n * <td>argumentSeparator</td>\n * <td>false</td>\n * <td>true</td>\n * <td>The separator character to be used for splitting the arguments string\n * value; defaults to a 'comma' (',').</td>\n * </tr>\n * <tr>\n * <td>code</td>\n * <td>false</td>\n * <td>true</td>\n * <td>The code (key) to use when looking up the message.\n * If code is not provided, the text attribute will be used.</td>\n * </tr>\n * <tr>\n * <td>htmlEscape</td>\n * <td>false</td>\n * <td>true</td>\n * <td>Set HTML escaping for this tag, as boolean value.\n * Overrides the default HTML escaping setting for the current page.</td>\n * </tr>\n * <tr>\n * <td>javaScriptEscape</td>\n * <td>false</td>\n * <td>true</td>\n * <td>Set JavaScript escaping for this tag, as boolean value.\n * Default is {@code false}.</td>\n * </tr>\n * <tr>\n * <td>message</td>\n * <td>false</td>\n * <td>true</td>\n * <td>A MessageSourceResolvable argument (direct or through JSP EL).\n * Fits nicely when used in conjunction with Spring\u2019s own validation error\n * classes which all implement the MessageSourceResolvable interface.\n * For example, this allows you to iterate over all of the errors in a form,\n * passing each error (using a runtime expression) as the value of this\n * 'message' attribute, thus effecting the easy display of such error\n * messages.</td>\n * </tr>\n * <tr>\n * <td>scope</td>\n * <td>false</td>\n * <td>true</td>\n * <td>The scope to use when exporting the result to a variable. This attribute\n * is only used when var is also set. Possible values are page, request, session\n * and application.</td>\n * </tr>\n * <tr>\n * <td>text</td>\n * <td>false</td>\n * <td>true</td>\n * <td>Default text to output when a message for the given code could not be\n * found. If both text and code are not set, the tag will output null.</td>\n * </tr>\n * <tr>\n * <td>var</td>\n * <td>false</td>\n * <td>true</td>\n * <td>The string to use when binding the result to the page, request, session\n * or application scope. If not specified, the result gets outputted to the writer\n * (i.e. typically directly to the JSP).</td>\n * </tr>\n * </tbody>\n * </table>\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Nicholas Williams\n * @see #setCode\n * @see #setText\n * @see #setHtmlEscape\n * @see #setJavaScriptEscape\n * @see HtmlEscapeTag#setDefaultHtmlEscape\n * @see org.springframework.web.util.WebUtils#HTML_ESCAPE_CONTEXT_PARAM\n * @see ArgumentTag\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "signature": "public class MessageTag",
    "source_code": "public class MessageTag extends HtmlEscapingAwareTag implements ArgumentAware {\n\n\t/**\n\t * Default separator for splitting an arguments String: a comma (\",\").\n\t */\n\tpublic static final String DEFAULT_ARGUMENT_SEPARATOR = \",\";\n\n\n\t@Nullable\n\tprivate MessageSourceResolvable message;\n\n\t@Nullable\n\tprivate String code;\n\n\t@Nullable\n\tprivate Object arguments;\n\n\tprivate String argumentSeparator = DEFAULT_ARGUMENT_SEPARATOR;\n\n\tprivate List<Object> nestedArguments = Collections.emptyList();\n\n\t@Nullable\n\tprivate String text;\n\n\t@Nullable\n\tprivate String var;\n\n\tprivate String scope = TagUtils.SCOPE_PAGE;\n\n\tprivate boolean javaScriptEscape = false;\n\n\n\t/**\n\t * Set the MessageSourceResolvable for this tag.\n\t * <p>If a MessageSourceResolvable is specified, it effectively overrides\n\t * any code, arguments or text specified on this tag.\n\t */\n\tpublic void setMessage(MessageSourceResolvable message) {\n\t\tthis.message = message;\n\t}\n\n\t/**\n\t * Set the message code for this tag.\n\t */\n\tpublic void setCode(String code) {\n\t\tthis.code = code;\n\t}\n\n\t/**\n\t * Set optional message arguments for this tag, as a comma-delimited\n\t * String (each String argument can contain JSP EL), an Object array\n\t * (used as argument array), or a single Object (used as single argument).\n\t */\n\tpublic void setArguments(Object arguments) {\n\t\tthis.arguments = arguments;\n\t}\n\n\t/**\n\t * Set the separator to use for splitting an arguments String.\n\t * Default is a comma (\",\").\n\t * @see #setArguments\n\t */\n\tpublic void setArgumentSeparator(String argumentSeparator) {\n\t\tthis.argumentSeparator = argumentSeparator;\n\t}\n\n\t@Override\n\tpublic void addArgument(@Nullable Object argument) throws JspTagException {\n\t\tthis.nestedArguments.add(argument);\n\t}\n\n\t/**\n\t * Set the message text for this tag.\n\t */\n\tpublic void setText(String text) {\n\t\tthis.text = text;\n\t}\n\n\t/**\n\t * Set PageContext attribute name under which to expose\n\t * a variable that contains the resolved message.\n\t * @see #setScope\n\t * @see jakarta.servlet.jsp.PageContext#setAttribute\n\t */\n\tpublic void setVar(String var) {\n\t\tthis.var = var;\n\t}\n\n\t/**\n\t * Set the scope to export the variable to.\n\t * Default is SCOPE_PAGE (\"page\").\n\t * @see #setVar\n\t * @see org.springframework.web.util.TagUtils#SCOPE_PAGE\n\t * @see jakarta.servlet.jsp.PageContext#setAttribute\n\t */\n\tpublic void setScope(String scope) {\n\t\tthis.scope = scope;\n\t}\n\n\t/**\n\t * Set JavaScript escaping for this tag, as boolean value.\n\t * Default is \"false\".\n\t */\n\tpublic void setJavaScriptEscape(boolean javaScriptEscape) throws JspException {\n\t\tthis.javaScriptEscape = javaScriptEscape;\n\t}\n\n\n\t@Override\n\tprotected final int doStartTagInternal() throws JspException, IOException {\n\t\tthis.nestedArguments = new ArrayList<>();\n\t\treturn EVAL_BODY_INCLUDE;\n\t}\n\n\t/**\n\t * Resolves the message, escapes it if demanded,\n\t * and writes it to the page (or exposes it as variable).\n\t * @see #resolveMessage()\n\t * @see org.springframework.web.util.HtmlUtils#htmlEscape(String)\n\t * @see org.springframework.web.util.JavaScriptUtils#javaScriptEscape(String)\n\t * @see #writeMessage(String)\n\t */\n\t@Override\n\tpublic int doEndTag() throws JspException {\n\t\ttry {\n\t\t\t// Resolve the unescaped message.\n\t\t\tString msg = resolveMessage();\n\n\t\t\t// HTML and/or JavaScript escape, if demanded.\n\t\t\tmsg = htmlEscape(msg);\n\t\t\tmsg = this.javaScriptEscape ? JavaScriptUtils.javaScriptEscape(msg) : msg;\n\n\t\t\t// Expose as variable, if demanded, else write to the page.\n\t\t\tif (this.var != null) {\n\t\t\t\tthis.pageContext.setAttribute(this.var, msg, TagUtils.getScope(this.scope));\n\t\t\t}\n\t\t\telse {\n\t\t\t\twriteMessage(msg);\n\t\t\t}\n\n\t\t\treturn EVAL_PAGE;\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new JspTagException(ex.getMessage(), ex);\n\t\t}\n\t\tcatch (NoSuchMessageException ex) {\n\t\t\tthrow new JspTagException(getNoSuchMessageExceptionDescription(ex));\n\t\t}\n\t}\n\n\t@Override\n\tpublic void release() {\n\t\tsuper.release();\n\t\tthis.arguments = null;\n\t}\n\n\n\t/**\n\t * Resolve the specified message into a concrete message String.\n\t * The returned message String should be unescaped.\n\t */\n\tprotected String resolveMessage() throws JspException, NoSuchMessageException {\n\t\tMessageSource messageSource = getMessageSource();\n\n\t\t// Evaluate the specified MessageSourceResolvable, if any.\n\t\tif (this.message != null) {\n\t\t\t// We have a given MessageSourceResolvable.\n\t\t\treturn messageSource.getMessage(this.message, getRequestContext().getLocale());\n\t\t}\n\n\t\tif (this.code != null || this.text != null) {\n\t\t\t// We have a code or default text that we need to resolve.\n\t\t\tObject[] argumentsArray = resolveArguments(this.arguments);\n\t\t\tif (!this.nestedArguments.isEmpty()) {\n\t\t\t\targumentsArray = appendArguments(argumentsArray, this.nestedArguments.toArray());\n\t\t\t}\n\n\t\t\tif (this.text != null) {\n\t\t\t\t// We have a fallback text to consider.\n\t\t\t\tString msg = messageSource.getMessage(\n\t\t\t\t\t\tthis.code, argumentsArray, this.text, getRequestContext().getLocale());\n\t\t\t\treturn (msg != null ? msg : \"\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We have no fallback text to consider.\n\t\t\t\treturn messageSource.getMessage(\n\t\t\t\t\t\tthis.code, argumentsArray, getRequestContext().getLocale());\n\t\t\t}\n\t\t}\n\n\t\tthrow new JspTagException(\"No resolvable message\");\n\t}\n\n\tprivate Object[] appendArguments(@Nullable Object[] sourceArguments, Object[] additionalArguments) {\n\t\tif (ObjectUtils.isEmpty(sourceArguments)) {\n\t\t\treturn additionalArguments;\n\t\t}\n\t\tObject[] arguments = new Object[sourceArguments.length + additionalArguments.length];\n\t\tSystem.arraycopy(sourceArguments, 0, arguments, 0, sourceArguments.length);\n\t\tSystem.arraycopy(additionalArguments, 0, arguments, sourceArguments.length, additionalArguments.length);\n\t\treturn arguments;\n\t}\n\n\t/**\n\t * Resolve the given arguments Object into an arguments array.\n\t * @param arguments the specified arguments Object\n\t * @return the resolved arguments as array\n\t * @throws JspException if argument conversion failed\n\t * @see #setArguments\n\t */\n\t@Nullable\n\tprotected Object[] resolveArguments(@Nullable Object arguments) throws JspException {\n\t\tif (arguments instanceof String string) {\n\t\t\treturn StringUtils.delimitedListToStringArray(string, this.argumentSeparator);\n\t\t}\n\t\telse if (arguments instanceof Object[] array) {\n\t\t\treturn array;\n\t\t}\n\t\telse if (arguments instanceof Collection<?> collection) {\n\t\t\treturn collection.toArray();\n\t\t}\n\t\telse if (arguments != null) {\n\t\t\t// Assume a single argument object.\n\t\t\treturn new Object[] {arguments};\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Write the message to the page.\n\t * <p>Can be overridden in subclasses, e.g. for testing purposes.\n\t * @param msg the message to write\n\t * @throws IOException if writing failed\n\t */\n\tprotected void writeMessage(String msg) throws IOException {\n\t\tthis.pageContext.getOut().write(msg);\n\t}\n\n\t/**\n\t * Use the current RequestContext's application context as MessageSource.\n\t */\n\tprotected MessageSource getMessageSource() {\n\t\treturn getRequestContext().getMessageSource();\n\t}\n\n\t/**\n\t * Return default exception message.\n\t */\n\tprotected String getNoSuchMessageExceptionDescription(NoSuchMessageException ex) {\n\t\treturn ex.getMessage();\n\t}\n\n}"
  },
  "org.springframework.web.servlet.tags.MessageTag#addArgument(argument)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argument"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "void",
    "signature": "public void addArgument(@Nullable Object argument)",
    "source_code": "\tpublic void addArgument(@Nullable Object argument) throws JspTagException {\n\t\tthis.nestedArguments.add(argument);\n\t}"
  },
  "org.springframework.web.servlet.tags.MessageTag#doEndTag()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolves the message, escapes it if demanded,\n\t * and writes it to the page (or exposes it as variable).\n\t * @see #resolveMessage()\n\t * @see org.springframework.web.util.HtmlUtils#htmlEscape(String)\n\t * @see org.springframework.web.util.JavaScriptUtils#javaScriptEscape(String)\n\t * @see #writeMessage(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "int",
    "signature": "public int doEndTag()",
    "source_code": "\tpublic int doEndTag() throws JspException {\n\t\ttry {\n\t\t\t// Resolve the unescaped message.\n\t\t\tString msg = resolveMessage();\n\n\t\t\t// HTML and/or JavaScript escape, if demanded.\n\t\t\tmsg = htmlEscape(msg);\n\t\t\tmsg = this.javaScriptEscape ? JavaScriptUtils.javaScriptEscape(msg) : msg;\n\n\t\t\t// Expose as variable, if demanded, else write to the page.\n\t\t\tif (this.var != null) {\n\t\t\t\tthis.pageContext.setAttribute(this.var, msg, TagUtils.getScope(this.scope));\n\t\t\t}\n\t\t\telse {\n\t\t\t\twriteMessage(msg);\n\t\t\t}\n\n\t\t\treturn EVAL_PAGE;\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new JspTagException(ex.getMessage(), ex);\n\t\t}\n\t\tcatch (NoSuchMessageException ex) {\n\t\t\tthrow new JspTagException(getNoSuchMessageExceptionDescription(ex));\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.tags.MessageTag#doStartTagInternal()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 257
    },
    "return": "int",
    "signature": "protected int doStartTagInternal()",
    "source_code": "\tprotected final int doStartTagInternal() throws JspException, IOException {\n\t\tthis.nestedArguments = new ArrayList<>();\n\t\treturn EVAL_BODY_INCLUDE;\n\t}"
  },
  "org.springframework.web.servlet.tags.MessageTag#getMessageSource()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Use the current RequestContext's application context as MessageSource.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 391
    },
    "return": "MessageSource",
    "signature": "protected MessageSource getMessageSource()",
    "source_code": "\tprotected MessageSource getMessageSource() {\n\t\treturn getRequestContext().getMessageSource();\n\t}"
  },
  "org.springframework.web.servlet.tags.MessageTag#getNoSuchMessageExceptionDescription(ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return default exception message.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 398
    },
    "return": "String",
    "signature": "protected String getNoSuchMessageExceptionDescription(NoSuchMessageException ex)",
    "source_code": "\tprotected String getNoSuchMessageExceptionDescription(NoSuchMessageException ex) {\n\t\treturn ex.getMessage();\n\t}"
  },
  "org.springframework.web.servlet.tags.MessageTag#release()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 299
    },
    "return": "void",
    "signature": "public void release()",
    "source_code": "\tpublic void release() {\n\t\tsuper.release();\n\t\tthis.arguments = null;\n\t}"
  },
  "org.springframework.web.servlet.tags.MessageTag#resolveArguments(arguments)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the given arguments Object into an arguments array.\n\t * @param arguments the specified arguments Object\n\t * @return the resolved arguments as array\n\t * @throws JspException if argument conversion failed\n\t * @see #setArguments\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "arguments"
    ],
    "position": {
      "column": 1,
      "line": 359
    },
    "return": "Object[]",
    "signature": "protected Object[] resolveArguments(@Nullable Object arguments)",
    "source_code": "\tprotected Object[] resolveArguments(@Nullable Object arguments) throws JspException {\n\t\tif (arguments instanceof String string) {\n\t\t\treturn StringUtils.delimitedListToStringArray(string, this.argumentSeparator);\n\t\t}\n\t\telse if (arguments instanceof Object[] array) {\n\t\t\treturn array;\n\t\t}\n\t\telse if (arguments instanceof Collection<?> collection) {\n\t\t\treturn collection.toArray();\n\t\t}\n\t\telse if (arguments != null) {\n\t\t\t// Assume a single argument object.\n\t\t\treturn new Object[] {arguments};\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.tags.MessageTag#resolveMessage()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the specified message into a concrete message String.\n\t * The returned message String should be unescaped.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "String",
    "signature": "protected String resolveMessage()",
    "source_code": "\tprotected String resolveMessage() throws JspException, NoSuchMessageException {\n\t\tMessageSource messageSource = getMessageSource();\n\n\t\t// Evaluate the specified MessageSourceResolvable, if any.\n\t\tif (this.message != null) {\n\t\t\t// We have a given MessageSourceResolvable.\n\t\t\treturn messageSource.getMessage(this.message, getRequestContext().getLocale());\n\t\t}\n\n\t\tif (this.code != null || this.text != null) {\n\t\t\t// We have a code or default text that we need to resolve.\n\t\t\tObject[] argumentsArray = resolveArguments(this.arguments);\n\t\t\tif (!this.nestedArguments.isEmpty()) {\n\t\t\t\targumentsArray = appendArguments(argumentsArray, this.nestedArguments.toArray());\n\t\t\t}\n\n\t\t\tif (this.text != null) {\n\t\t\t\t// We have a fallback text to consider.\n\t\t\t\tString msg = messageSource.getMessage(\n\t\t\t\t\t\tthis.code, argumentsArray, this.text, getRequestContext().getLocale());\n\t\t\t\treturn (msg != null ? msg : \"\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We have no fallback text to consider.\n\t\t\t\treturn messageSource.getMessage(\n\t\t\t\t\t\tthis.code, argumentsArray, getRequestContext().getLocale());\n\t\t\t}\n\t\t}\n\n\t\tthrow new JspTagException(\"No resolvable message\");\n\t}"
  },
  "org.springframework.web.servlet.tags.MessageTag#setArgumentSeparator(argumentSeparator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the separator to use for splitting an arguments String.\n\t * Default is a comma (\",\").\n\t * @see #setArguments\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argumentSeparator"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "void",
    "signature": "public void setArgumentSeparator(String argumentSeparator)",
    "source_code": "\tpublic void setArgumentSeparator(String argumentSeparator) {\n\t\tthis.argumentSeparator = argumentSeparator;\n\t}"
  },
  "org.springframework.web.servlet.tags.MessageTag#setArguments(arguments)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set optional message arguments for this tag, as a comma-delimited\n\t * String (each String argument can contain JSP EL), an Object array\n\t * (used as argument array), or a single Object (used as single argument).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "arguments"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "void",
    "signature": "public void setArguments(Object arguments)",
    "source_code": "\tpublic void setArguments(Object arguments) {\n\t\tthis.arguments = arguments;\n\t}"
  },
  "org.springframework.web.servlet.tags.MessageTag#setCode(code)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the message code for this tag.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "void",
    "signature": "public void setCode(String code)",
    "source_code": "\tpublic void setCode(String code) {\n\t\tthis.code = code;\n\t}"
  },
  "org.springframework.web.servlet.tags.MessageTag#setJavaScriptEscape(javaScriptEscape)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set JavaScript escaping for this tag, as boolean value.\n\t * Default is \"false\".\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "javaScriptEscape"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "void",
    "signature": "public void setJavaScriptEscape(boolean javaScriptEscape)",
    "source_code": "\tpublic void setJavaScriptEscape(boolean javaScriptEscape) throws JspException {\n\t\tthis.javaScriptEscape = javaScriptEscape;\n\t}"
  },
  "org.springframework.web.servlet.tags.MessageTag#setMessage(message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the MessageSourceResolvable for this tag.\n\t * <p>If a MessageSourceResolvable is specified, it effectively overrides\n\t * any code, arguments or text specified on this tag.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "void",
    "signature": "public void setMessage(MessageSourceResolvable message)",
    "source_code": "\tpublic void setMessage(MessageSourceResolvable message) {\n\t\tthis.message = message;\n\t}"
  },
  "org.springframework.web.servlet.tags.MessageTag#setScope(scope)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the scope to export the variable to.\n\t * Default is SCOPE_PAGE (\"page\").\n\t * @see #setVar\n\t * @see org.springframework.web.util.TagUtils#SCOPE_PAGE\n\t * @see jakarta.servlet.jsp.PageContext#setAttribute\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "void",
    "signature": "public void setScope(String scope)",
    "source_code": "\tpublic void setScope(String scope) {\n\t\tthis.scope = scope;\n\t}"
  },
  "org.springframework.web.servlet.tags.MessageTag#setText(text)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the message text for this tag.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text"
    ],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "void",
    "signature": "public void setText(String text)",
    "source_code": "\tpublic void setText(String text) {\n\t\tthis.text = text;\n\t}"
  },
  "org.springframework.web.servlet.tags.MessageTag#setVar(var)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set PageContext attribute name under which to expose\n\t * a variable that contains the resolved message.\n\t * @see #setScope\n\t * @see jakarta.servlet.jsp.PageContext#setAttribute\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "var"
    ],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "void",
    "signature": "public void setVar(String var)",
    "source_code": "\tpublic void setVar(String var) {\n\t\tthis.var = var;\n\t}"
  },
  "org.springframework.web.servlet.tags.MessageTag#writeMessage(msg)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Write the message to the page.\n\t * <p>Can be overridden in subclasses, e.g. for testing purposes.\n\t * @param msg the message to write\n\t * @throws IOException if writing failed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "msg"
    ],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "void",
    "signature": "protected void writeMessage(String msg)",
    "source_code": "\tprotected void writeMessage(String msg) throws IOException {\n\t\tthis.pageContext.getOut().write(msg);\n\t}"
  },
  "org.springframework.web.servlet.tags.UrlTag": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * The {@code <url>} tag creates URLs. Modeled after the JSTL {@code c:url} tag with\n * backwards compatibility in mind.\n *\n * <p>Enhancements to the JSTL functionality include:\n * <ul>\n * <li>URL encoded template URI variables</li>\n * <li>HTML/XML escaping of URLs</li>\n * <li>JavaScript escaping of URLs</li>\n * </ul>\n *\n * <p>Template URI variables are indicated in the {@link #setValue(String) 'value'}\n * attribute and marked by braces '{variableName}'. The braces and attribute name are\n * replaced by the URL encoded value of a parameter defined with the spring:param tag\n * in the body of the url tag. If no parameter is available the literal value is\n * passed through. Params matched to template variables will not be added to the query\n * string.\n *\n * <p>Use of the spring:param tag for URI template variables is strongly recommended\n * over direct EL substitution as the values are URL encoded.  Failure to properly\n * encode URL can leave an application vulnerable to XSS and other injection attacks.\n *\n * <p>URLs can be HTML/XML escaped by setting the {@link #setHtmlEscape(boolean)\n * 'htmlEscape'} attribute to 'true'.  Detects an HTML escaping setting, either on\n * this tag instance, the page level, or the {@code web.xml} level. The default\n * is 'false'.  When setting the URL value into a variable, escaping is not recommended.\n *\n * <p>Example usage:\n * <pre class=\"code\">&lt;spring:url value=\"/url/path/{variableName}\"&gt;\n *   &lt;spring:param name=\"variableName\" value=\"more than JSTL c:url\" /&gt;\n * &lt;/spring:url&gt;</pre>\n *\n * <p>The above results in:\n * {@code /currentApplicationContext/url/path/more%20than%20JSTL%20c%3Aurl}\n *\n * <table>\n * <caption>Attribute Summary</caption>\n * <thead>\n * <tr>\n * <th>Attribute</th>\n * <th>Required?</th>\n * <th>Runtime Expression?</th>\n * <th>Description</th>\n * </tr>\n * </thead>\n * <tbody>\n * <tr>\n * <td>value</td>\n * <td>true</td>\n * <td>true</td>\n * <td>The URL to build. This value can include template {placeholders} that are\n * replaced with the URL encoded value of the named parameter. Parameters\n * must be defined using the param tag inside the body of this tag.</td>\n * </tr>\n * <tr>\n * <td>context</td>\n * <td>false</td>\n * <td>true</td>\n * <td>Specifies a remote application context path.\n * The default is the current application context path.</td>\n * </tr>\n * <tr>\n * <td>var</td>\n * <td>false</td>\n * <td>true</td>\n * <td>The name of the variable to export the URL value to.\n * If not specified the URL is written as output.</td>\n * </tr>\n * <tr>\n * <td>scope</td>\n * <td>false</td>\n * <td>true</td>\n * <td>The scope for the var. 'application', 'session', 'request' and 'page'\n * scopes are supported. Defaults to page scope. This attribute has no\n * effect unless the var attribute is also defined.</td>\n * </tr>\n * <tr>\n * <td>htmlEscape</td>\n * <td>false</td>\n * <td>true</td>\n * <td>Set HTML escaping for this tag, as a boolean value. Overrides the\n * default HTML escaping setting for the current page.</td>\n * </tr>\n * <tr>\n * <td>javaScriptEscape</td>\n * <td>false</td>\n * <td>true</td>\n * <td>Set JavaScript escaping for this tag, as a boolean value.\n * Default is {@code false}.</td>\n * </tr>\n * </tbody>\n * </table>\n *\n * @author Scott Andrews\n * @since 3.0\n * @see ParamTag\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "signature": "public class UrlTag",
    "source_code": "public class UrlTag extends HtmlEscapingAwareTag implements ParamAware {\n\n\tprivate static final String URL_TEMPLATE_DELIMITER_PREFIX = \"{\";\n\n\tprivate static final String URL_TEMPLATE_DELIMITER_SUFFIX = \"}\";\n\n\tprivate static final String URL_TYPE_ABSOLUTE = \"://\";\n\n\n\tprivate List<Param> params = Collections.emptyList();\n\n\tprivate Set<String> templateParams = Collections.emptySet();\n\n\t@Nullable\n\tprivate UrlType type;\n\n\t@Nullable\n\tprivate String value;\n\n\t@Nullable\n\tprivate String context;\n\n\t@Nullable\n\tprivate String var;\n\n\tprivate int scope = PageContext.PAGE_SCOPE;\n\n\tprivate boolean javaScriptEscape = false;\n\n\n\t/**\n\t * Set the value of the URL.\n\t */\n\tpublic void setValue(String value) {\n\t\tif (value.contains(URL_TYPE_ABSOLUTE)) {\n\t\t\tthis.type = UrlType.ABSOLUTE;\n\t\t\tthis.value = value;\n\t\t}\n\t\telse if (value.startsWith(\"/\")) {\n\t\t\tthis.type = UrlType.CONTEXT_RELATIVE;\n\t\t\tthis.value = value;\n\t\t}\n\t\telse {\n\t\t\tthis.type = UrlType.RELATIVE;\n\t\t\tthis.value = value;\n\t\t}\n\t}\n\n\t/**\n\t * Set the context path for the URL.\n\t * Defaults to the current context.\n\t */\n\tpublic void setContext(String context) {\n\t\tif (context.startsWith(\"/\")) {\n\t\t\tthis.context = context;\n\t\t}\n\t\telse {\n\t\t\tthis.context = \"/\" + context;\n\t\t}\n\t}\n\n\t/**\n\t * Set the variable name to expose the URL under. Defaults to rendering the\n\t * URL to the current JspWriter\n\t */\n\tpublic void setVar(String var) {\n\t\tthis.var = var;\n\t}\n\n\t/**\n\t * Set the scope to export the URL variable to. This attribute has no\n\t * meaning unless var is also defined.\n\t */\n\tpublic void setScope(String scope) {\n\t\tthis.scope = TagUtils.getScope(scope);\n\t}\n\n\t/**\n\t * Set JavaScript escaping for this tag, as boolean value.\n\t * Default is \"false\".\n\t */\n\tpublic void setJavaScriptEscape(boolean javaScriptEscape) throws JspException {\n\t\tthis.javaScriptEscape = javaScriptEscape;\n\t}\n\n\t@Override\n\tpublic void addParam(Param param) {\n\t\tthis.params.add(param);\n\t}\n\n\n\t@Override\n\tpublic int doStartTagInternal() throws JspException {\n\t\tthis.params = new ArrayList<>();\n\t\tthis.templateParams = new HashSet<>();\n\t\treturn EVAL_BODY_INCLUDE;\n\t}\n\n\t@Override\n\tpublic int doEndTag() throws JspException {\n\t\tString url = createUrl();\n\n\t\tRequestDataValueProcessor processor = getRequestContext().getRequestDataValueProcessor();\n\t\tServletRequest request = this.pageContext.getRequest();\n\t\tif ((processor != null) && (request instanceof HttpServletRequest httpServletRequest)) {\n\t\t\turl = processor.processUrl(httpServletRequest, url);\n\t\t}\n\n\t\tif (this.var == null) {\n\t\t\t// print the url to the writer\n\t\t\ttry {\n\t\t\t\tthis.pageContext.getOut().print(url);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new JspException(ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// store the url as a variable\n\t\t\tthis.pageContext.setAttribute(this.var, url, this.scope);\n\t\t}\n\t\treturn EVAL_PAGE;\n\t}\n\n\n\t/**\n\t * Build the URL for the tag from the tag attributes and parameters.\n\t * @return the URL value as a String\n\t */\n\tString createUrl() throws JspException {\n\t\tAssert.state(this.value != null, \"No value set\");\n\t\tHttpServletRequest request = (HttpServletRequest) this.pageContext.getRequest();\n\t\tHttpServletResponse response = (HttpServletResponse) this.pageContext.getResponse();\n\n\t\tStringBuilder url = new StringBuilder();\n\t\tif (this.type == UrlType.CONTEXT_RELATIVE) {\n\t\t\t// add application context to url\n\t\t\tif (this.context == null) {\n\t\t\t\turl.append(request.getContextPath());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (this.context.endsWith(\"/\")) {\n\t\t\t\t\turl.append(this.context, 0, this.context.length() - 1);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\turl.append(this.context);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.type != UrlType.RELATIVE && this.type != UrlType.ABSOLUTE && !this.value.startsWith(\"/\")) {\n\t\t\turl.append('/');\n\t\t}\n\t\turl.append(replaceUriTemplateParams(this.value, this.params, this.templateParams));\n\t\turl.append(createQueryString(this.params, this.templateParams, (url.indexOf(\"?\") == -1)));\n\n\t\tString urlStr = url.toString();\n\t\tif (this.type != UrlType.ABSOLUTE) {\n\t\t\t// Add the session identifier if needed\n\t\t\t// (Do not embed the session identifier in a remote link!)\n\t\t\turlStr = response.encodeURL(urlStr);\n\t\t}\n\n\t\t// HTML and/or JavaScript escape, if demanded.\n\t\turlStr = htmlEscape(urlStr);\n\t\turlStr = (this.javaScriptEscape ? JavaScriptUtils.javaScriptEscape(urlStr) : urlStr);\n\n\t\treturn urlStr;\n\t}\n\n\t/**\n\t * Build the query string from available parameters that have not already\n\t * been applied as template params.\n\t * <p>The names and values of parameters are URL encoded.\n\t * @param params the parameters to build the query string from\n\t * @param usedParams set of parameter names that have been applied as\n\t * template params\n\t * @param includeQueryStringDelimiter true if the query string should start\n\t * with a '?' instead of '&amp;'\n\t * @return the query string\n\t */\n\tprotected String createQueryString(List<Param> params, Set<String> usedParams, boolean includeQueryStringDelimiter)\n\t\t\tthrows JspException {\n\n\t\tString encoding = this.pageContext.getResponse().getCharacterEncoding();\n\t\tStringBuilder qs = new StringBuilder();\n\t\tfor (Param param : params) {\n\t\t\tif (!usedParams.contains(param.getName()) && StringUtils.hasLength(param.getName())) {\n\t\t\t\tif (includeQueryStringDelimiter && qs.length() == 0) {\n\t\t\t\t\tqs.append('?');\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tqs.append('&');\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tqs.append(UriUtils.encodeQueryParam(param.getName(), encoding));\n\t\t\t\t\tif (param.getValue() != null) {\n\t\t\t\t\t\tqs.append('=');\n\t\t\t\t\t\tqs.append(UriUtils.encodeQueryParam(param.getValue(), encoding));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (UnsupportedCharsetException ex) {\n\t\t\t\t\tthrow new JspException(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn qs.toString();\n\t}\n\n\t/**\n\t * Replace template markers in the URL matching available parameters. The\n\t * name of matched parameters are added to the used parameters set.\n\t * <p>Parameter values are URL encoded.\n\t * @param uri the URL with template parameters to replace\n\t * @param params parameters used to replace template markers\n\t * @param usedParams set of template parameter names that have been replaced\n\t * @return the URL with template parameters replaced\n\t */\n\tprotected String replaceUriTemplateParams(String uri, List<Param> params, Set<String> usedParams)\n\t\t\tthrows JspException {\n\n\t\tString encoding = this.pageContext.getResponse().getCharacterEncoding();\n\t\tfor (Param param : params) {\n\t\t\tString template = URL_TEMPLATE_DELIMITER_PREFIX + param.getName() + URL_TEMPLATE_DELIMITER_SUFFIX;\n\t\t\tif (uri.contains(template)) {\n\t\t\t\tusedParams.add(param.getName());\n\t\t\t\tString value = param.getValue();\n\t\t\t\ttry {\n\t\t\t\t\turi = StringUtils.replace(uri, template,\n\t\t\t\t\t\t\t(value != null ? UriUtils.encodePath(value, encoding) : \"\"));\n\t\t\t\t}\n\t\t\t\tcatch (UnsupportedCharsetException ex) {\n\t\t\t\t\tthrow new JspException(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttemplate = URL_TEMPLATE_DELIMITER_PREFIX + '/' + param.getName() + URL_TEMPLATE_DELIMITER_SUFFIX;\n\t\t\t\tif (uri.contains(template)) {\n\t\t\t\t\tusedParams.add(param.getName());\n\t\t\t\t\tString value = param.getValue();\n\t\t\t\t\ttry {\n\t\t\t\t\t\turi = StringUtils.replace(uri, template,\n\t\t\t\t\t\t\t\t(value != null ? UriUtils.encodePathSegment(value, encoding) : \"\"));\n\t\t\t\t\t}\n\t\t\t\t\tcatch (UnsupportedCharsetException ex) {\n\t\t\t\t\t\tthrow new JspException(ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn uri;\n\t}\n\n\n\t/**\n\t * Internal enum that classifies URLs by type.\n\t */\n\tprivate enum UrlType {\n\n\t\tCONTEXT_RELATIVE, RELATIVE, ABSOLUTE\n\t}\n\n}"
  },
  "org.springframework.web.servlet.tags.UrlTag#addParam(param)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "param"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "void",
    "signature": "public void addParam(Param param)",
    "source_code": "\tpublic void addParam(Param param) {\n\t\tthis.params.add(param);\n\t}"
  },
  "org.springframework.web.servlet.tags.UrlTag#createQueryString(params,usedParams,includeQueryStringDelimiter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build the query string from available parameters that have not already\n\t * been applied as template params.\n\t * <p>The names and values of parameters are URL encoded.\n\t * @param params the parameters to build the query string from\n\t * @param usedParams set of parameter names that have been applied as\n\t * template params\n\t * @param includeQueryStringDelimiter true if the query string should start\n\t * with a '?' instead of '&amp;'\n\t * @return the query string\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "params",
      "usedParams",
      "includeQueryStringDelimiter"
    ],
    "position": {
      "column": 1,
      "line": 319
    },
    "return": "String",
    "signature": "protected String createQueryString(List<Param> params, Set<String> usedParams, boolean includeQueryStringDelimiter)",
    "source_code": "\tprotected String createQueryString(List<Param> params, Set<String> usedParams, boolean includeQueryStringDelimiter)"
  },
  "org.springframework.web.servlet.tags.UrlTag#doEndTag()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "int",
    "signature": "public int doEndTag()",
    "source_code": "\tpublic int doEndTag() throws JspException {\n\t\tString url = createUrl();\n\n\t\tRequestDataValueProcessor processor = getRequestContext().getRequestDataValueProcessor();\n\t\tServletRequest request = this.pageContext.getRequest();\n\t\tif ((processor != null) && (request instanceof HttpServletRequest httpServletRequest)) {\n\t\t\turl = processor.processUrl(httpServletRequest, url);\n\t\t}\n\n\t\tif (this.var == null) {\n\t\t\t// print the url to the writer\n\t\t\ttry {\n\t\t\t\tthis.pageContext.getOut().print(url);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new JspException(ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// store the url as a variable\n\t\t\tthis.pageContext.setAttribute(this.var, url, this.scope);\n\t\t}\n\t\treturn EVAL_PAGE;\n\t}"
  },
  "org.springframework.web.servlet.tags.UrlTag#doStartTagInternal()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 231
    },
    "return": "int",
    "signature": "public int doStartTagInternal()",
    "source_code": "\tpublic int doStartTagInternal() throws JspException {\n\t\tthis.params = new ArrayList<>();\n\t\tthis.templateParams = new HashSet<>();\n\t\treturn EVAL_BODY_INCLUDE;\n\t}"
  },
  "org.springframework.web.servlet.tags.UrlTag#replaceUriTemplateParams(uri,params,usedParams)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Replace template markers in the URL matching available parameters. The\n\t * name of matched parameters are added to the used parameters set.\n\t * <p>Parameter values are URL encoded.\n\t * @param uri the URL with template parameters to replace\n\t * @param params parameters used to replace template markers\n\t * @param usedParams set of template parameter names that have been replaced\n\t * @return the URL with template parameters replaced\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "uri",
      "params",
      "usedParams"
    ],
    "position": {
      "column": 1,
      "line": 356
    },
    "return": "String",
    "signature": "protected String replaceUriTemplateParams(String uri, List<Param> params, Set<String> usedParams)",
    "source_code": "\tprotected String replaceUriTemplateParams(String uri, List<Param> params, Set<String> usedParams)"
  },
  "org.springframework.web.servlet.tags.UrlTag#setContext(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the context path for the URL.\n\t * Defaults to the current context.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "void",
    "signature": "public void setContext(String context)",
    "source_code": "\tpublic void setContext(String context) {\n\t\tif (context.startsWith(\"/\")) {\n\t\t\tthis.context = context;\n\t\t}\n\t\telse {\n\t\t\tthis.context = \"/\" + context;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.tags.UrlTag#setJavaScriptEscape(javaScriptEscape)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set JavaScript escaping for this tag, as boolean value.\n\t * Default is \"false\".\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "javaScriptEscape"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "void",
    "signature": "public void setJavaScriptEscape(boolean javaScriptEscape)",
    "source_code": "\tpublic void setJavaScriptEscape(boolean javaScriptEscape) throws JspException {\n\t\tthis.javaScriptEscape = javaScriptEscape;\n\t}"
  },
  "org.springframework.web.servlet.tags.UrlTag#setScope(scope)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the scope to export the URL variable to. This attribute has no\n\t * meaning unless var is also defined.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 212
    },
    "return": "void",
    "signature": "public void setScope(String scope)",
    "source_code": "\tpublic void setScope(String scope) {\n\t\tthis.scope = TagUtils.getScope(scope);\n\t}"
  },
  "org.springframework.web.servlet.tags.UrlTag#setValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value of the URL.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "void",
    "signature": "public void setValue(String value)",
    "source_code": "\tpublic void setValue(String value) {\n\t\tif (value.contains(URL_TYPE_ABSOLUTE)) {\n\t\t\tthis.type = UrlType.ABSOLUTE;\n\t\t\tthis.value = value;\n\t\t}\n\t\telse if (value.startsWith(\"/\")) {\n\t\t\tthis.type = UrlType.CONTEXT_RELATIVE;\n\t\t\tthis.value = value;\n\t\t}\n\t\telse {\n\t\t\tthis.type = UrlType.RELATIVE;\n\t\t\tthis.value = value;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.tags.UrlTag#setVar(var)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the variable name to expose the URL under. Defaults to rendering the\n\t * URL to the current JspWriter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "var"
    ],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "void",
    "signature": "public void setVar(String var)",
    "source_code": "\tpublic void setVar(String var) {\n\t\tthis.var = var;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.<unknown>#isOptionDisabled()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the option fields should be disabled.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 275
    },
    "return": "boolean",
    "signature": "protected boolean isOptionDisabled()",
    "source_code": "\tprotected boolean isOptionDisabled() throws JspException {\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.<unknown>#processOptionValue(resolvedValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Process the option value before it is written.\n\t * <p>The default implementation simply returns the same value unchanged.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resolvedValue"
    ],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "String",
    "signature": "protected String processOptionValue(String resolvedValue)",
    "source_code": "\tprotected String processOptionValue(String resolvedValue) {\n\t\treturn resolvedValue;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.<unknown>#writeCommonAttributes(tagWriter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Write default attributes configured to the supplied {@link TagWriter}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "tagWriter"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "void",
    "signature": "protected void writeCommonAttributes(TagWriter tagWriter)",
    "source_code": "\tprotected void writeCommonAttributes(TagWriter tagWriter) throws JspException {\n\t}"
  },
  "org.springframework.web.servlet.tags.form.<unknown>#writeOptions(tagWriter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Write the '{@code option}' tags for the configured {@link #optionSource} to\n\t * the supplied {@link TagWriter}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "tagWriter"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "void",
    "signature": "public void writeOptions(TagWriter tagWriter)",
    "source_code": "\tpublic void writeOptions(TagWriter tagWriter) throws JspException {\n\t\tif (this.optionSource.getClass().isArray()) {\n\t\t\trenderFromArray(tagWriter);\n\t\t}\n\t\telse if (this.optionSource instanceof Collection) {\n\t\t\trenderFromCollection(tagWriter);\n\t\t}\n\t\telse if (this.optionSource instanceof Map) {\n\t\t\trenderFromMap(tagWriter);\n\t\t}\n\t\telse if (this.optionSource instanceof Class<?> clazz && clazz.isEnum()) {\n\t\t\trenderFromEnum(tagWriter);\n\t\t}\n\t\telse {\n\t\t\tthrow new JspException(\n\t\t\t\t\t\"Type [\" + this.optionSource.getClass().getName() + \"] is not valid for option items\");\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.tags.form.AbstractDataBoundFormElementTag": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Base tag for all data-binding aware JSP form tags.\n *\n * <p>Provides the common {@link #setPath path} and {@link #setId id} properties.\n * Provides subclasses with utility methods for accessing the {@link BindStatus}\n * of their bound value and also for {@link #writeOptionalAttribute interacting}\n * with the {@link TagWriter}.\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @since 2.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "signature": "public class AbstractDataBoundFormElementTag",
    "source_code": "public abstract class AbstractDataBoundFormElementTag extends AbstractFormTag implements EditorAwareTag {\n\n\t/**\n\t * Name of the exposed path variable within the scope of this tag: \"nestedPath\".\n\t * Same value as {@link org.springframework.web.servlet.tags.NestedPathTag#NESTED_PATH_VARIABLE_NAME}.\n\t */\n\tprotected static final String NESTED_PATH_VARIABLE_NAME = NestedPathTag.NESTED_PATH_VARIABLE_NAME;\n\n\n\t/**\n\t * The property path from the {@link FormTag#setModelAttribute form object}.\n\t */\n\t@Nullable\n\tprivate String path;\n\n\t/**\n\t * The value of the '{@code id}' attribute.\n\t */\n\t@Nullable\n\tprivate String id;\n\n\t/**\n\t * The {@link BindStatus} of this tag.\n\t */\n\t@Nullable\n\tprivate BindStatus bindStatus;\n\n\n\t/**\n\t * Set the property path from the {@link FormTag#setModelAttribute form object}.\n\t * May be a runtime expression.\n\t */\n\tpublic void setPath(String path) {\n\t\tthis.path = path;\n\t}\n\n\t/**\n\t * Get the {@link #evaluate resolved} property path for the\n\t * {@link FormTag#setModelAttribute form object}.\n\t */\n\tprotected final String getPath() throws JspException {\n\t\tString resolvedPath = (String) evaluate(\"path\", this.path);\n\t\treturn (resolvedPath != null ? resolvedPath : \"\");\n\t}\n\n\t/**\n\t * Set the value of the '{@code id}' attribute.\n\t * <p>May be a runtime expression; defaults to the value of {@link #getName()}.\n\t * Note that the default value may not be valid for certain tags.\n\t */\n\t@Override\n\tpublic void setId(@Nullable String id) {\n\t\tthis.id = id;\n\t}\n\n\t/**\n\t * Get the value of the '{@code id}' attribute.\n\t */\n\t@Override\n\t@Nullable\n\tpublic String getId() {\n\t\treturn this.id;\n\t}\n\n\n\t/**\n\t * Writes the default set of attributes to the supplied {@link TagWriter}.\n\t * Further, abstract subclasses should override this method to add in\n\t * any additional default attributes but <strong>must</strong> remember\n\t * to call the {@code super} method.\n\t * <p>Concrete subclasses should call this method when/if they want\n\t * to render default attributes.\n\t * @param tagWriter the {@link TagWriter} to which any attributes are to be written\n\t */\n\tprotected void writeDefaultAttributes(TagWriter tagWriter) throws JspException {\n\t\twriteOptionalAttribute(tagWriter, \"id\", resolveId());\n\t\twriteOptionalAttribute(tagWriter, \"name\", getName());\n\t}\n\n\t/**\n\t * Determine the '{@code id}' attribute value for this tag,\n\t * autogenerating one if none specified.\n\t * @see #getId()\n\t * @see #autogenerateId()\n\t */\n\t@Nullable\n\tprotected String resolveId() throws JspException {\n\t\tObject id = evaluate(\"id\", getId());\n\t\tif (id != null) {\n\t\t\tString idString = id.toString();\n\t\t\treturn (StringUtils.hasText(idString) ? idString : null);\n\t\t}\n\t\treturn autogenerateId();\n\t}\n\n\t/**\n\t * Autogenerate the '{@code id}' attribute value for this tag.\n\t * <p>The default implementation simply delegates to {@link #getName()},\n\t * deleting invalid characters (such as \"[\" or \"]\").\n\t */\n\t@Nullable\n\tprotected String autogenerateId() throws JspException {\n\t\tString name = getName();\n\t\treturn (name != null ? StringUtils.deleteAny(name, \"[]\") : null);\n\t}\n\n\t/**\n\t * Get the value for the HTML '{@code name}' attribute.\n\t * <p>The default implementation simply delegates to\n\t * {@link #getPropertyPath()} to use the property path as the name.\n\t * For the most part this is desirable as it links with the server-side\n\t * expectation for data binding. However, some subclasses may wish to change\n\t * the value of the '{@code name}' attribute without changing the bind path.\n\t * @return the value for the HTML '{@code name}' attribute\n\t */\n\t@Nullable\n\tprotected String getName() throws JspException {\n\t\treturn getPropertyPath();\n\t}\n\n\t/**\n\t * Get the {@link BindStatus} for this tag.\n\t */\n\tprotected BindStatus getBindStatus() throws JspException {\n\t\tif (this.bindStatus == null) {\n\t\t\t// HTML escaping in tags is performed by the ValueFormatter class.\n\t\t\tString nestedPath = getNestedPath();\n\t\t\tString pathToUse = (nestedPath != null ? nestedPath + getPath() : getPath());\n\t\t\tif (pathToUse.endsWith(PropertyAccessor.NESTED_PROPERTY_SEPARATOR)) {\n\t\t\t\tpathToUse = pathToUse.substring(0, pathToUse.length() - 1);\n\t\t\t}\n\t\t\tthis.bindStatus = new BindStatus(getRequestContext(), pathToUse, false);\n\t\t}\n\t\treturn this.bindStatus;\n\t}\n\n\t/**\n\t * Get the value of the nested path that may have been exposed by the\n\t * {@link NestedPathTag}.\n\t */\n\t@Nullable\n\tprotected String getNestedPath() {\n\t\treturn (String) this.pageContext.getAttribute(NESTED_PATH_VARIABLE_NAME, PageContext.REQUEST_SCOPE);\n\t}\n\n\t/**\n\t * Build the property path for this tag, including the nested path\n\t * but <i>not</i> prefixed with the name of the form attribute.\n\t * @see #getNestedPath()\n\t * @see #getPath()\n\t */\n\tprotected String getPropertyPath() throws JspException {\n\t\tString expression = getBindStatus().getExpression();\n\t\treturn (expression != null ? expression : \"\");\n\t}\n\n\t/**\n\t * Get the bound value.\n\t * @see #getBindStatus()\n\t */\n\t@Nullable\n\tprotected final Object getBoundValue() throws JspException {\n\t\treturn getBindStatus().getValue();\n\t}\n\n\t/**\n\t * Get the {@link PropertyEditor}, if any, in use for value bound to this tag.\n\t */\n\t@Nullable\n\tprotected PropertyEditor getPropertyEditor() throws JspException {\n\t\treturn getBindStatus().getEditor();\n\t}\n\n\t/**\n\t * Exposes the {@link PropertyEditor} for {@link EditorAwareTag}.\n\t * <p>Use {@link #getPropertyEditor()} for internal rendering purposes.\n\t */\n\t@Override\n\t@Nullable\n\tpublic final PropertyEditor getEditor() throws JspException {\n\t\treturn getPropertyEditor();\n\t}\n\n\t/**\n\t * Get a display String for the given value, converted by a PropertyEditor\n\t * that the BindStatus may have registered for the value's Class.\n\t */\n\tprotected String convertToDisplayString(@Nullable Object value) throws JspException {\n\t\tPropertyEditor editor = (value != null ? getBindStatus().findEditor(value.getClass()) : null);\n\t\treturn getDisplayString(value, editor);\n\t}\n\n\t/**\n\t * Process the given form field through a {@link RequestDataValueProcessor}\n\t * instance if one is configured or otherwise returns the same value.\n\t */\n\tprotected final String processFieldValue(@Nullable String name, String value, String type) {\n\t\tRequestDataValueProcessor processor = getRequestContext().getRequestDataValueProcessor();\n\t\tServletRequest request = this.pageContext.getRequest();\n\t\tif (processor != null && request instanceof HttpServletRequest httpServletRequest) {\n\t\t\tvalue = processor.processFormFieldValue(httpServletRequest, name, value, type);\n\t\t}\n\t\treturn value;\n\t}\n\n\t/**\n\t * Disposes of the {@link BindStatus} instance.\n\t */\n\t@Override\n\tpublic void doFinally() {\n\t\tsuper.doFinally();\n\t\tthis.bindStatus = null;\n\t}\n\n}"
  },
  "org.springframework.web.servlet.tags.form.AbstractDataBoundFormElementTag#autogenerateId()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Autogenerate the '{@code id}' attribute value for this tag.\n\t * <p>The default implementation simply delegates to {@link #getName()},\n\t * deleting invalid characters (such as \"[\" or \"]\").\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "String",
    "signature": "protected String autogenerateId()",
    "source_code": "\tprotected String autogenerateId() throws JspException {\n\t\tString name = getName();\n\t\treturn (name != null ? StringUtils.deleteAny(name, \"[]\") : null);\n\t}"
  },
  "org.springframework.web.servlet.tags.form.AbstractDataBoundFormElementTag#convertToDisplayString(value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get a display String for the given value, converted by a PropertyEditor\n\t * that the BindStatus may have registered for the value's Class.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 234
    },
    "return": "String",
    "signature": "protected String convertToDisplayString(@Nullable Object value)",
    "source_code": "\tprotected String convertToDisplayString(@Nullable Object value) throws JspException {\n\t\tPropertyEditor editor = (value != null ? getBindStatus().findEditor(value.getClass()) : null);\n\t\treturn getDisplayString(value, editor);\n\t}"
  },
  "org.springframework.web.servlet.tags.form.AbstractDataBoundFormElementTag#doFinally()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Disposes of the {@link BindStatus} instance.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "void",
    "signature": "public void doFinally()",
    "source_code": "\tpublic void doFinally() {\n\t\tsuper.doFinally();\n\t\tthis.bindStatus = null;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.AbstractDataBoundFormElementTag#getBindStatus()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the {@link BindStatus} for this tag.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "BindStatus",
    "signature": "protected BindStatus getBindStatus()",
    "source_code": "\tprotected BindStatus getBindStatus() throws JspException {\n\t\tif (this.bindStatus == null) {\n\t\t\t// HTML escaping in tags is performed by the ValueFormatter class.\n\t\t\tString nestedPath = getNestedPath();\n\t\t\tString pathToUse = (nestedPath != null ? nestedPath + getPath() : getPath());\n\t\t\tif (pathToUse.endsWith(PropertyAccessor.NESTED_PROPERTY_SEPARATOR)) {\n\t\t\t\tpathToUse = pathToUse.substring(0, pathToUse.length() - 1);\n\t\t\t}\n\t\t\tthis.bindStatus = new BindStatus(getRequestContext(), pathToUse, false);\n\t\t}\n\t\treturn this.bindStatus;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.AbstractDataBoundFormElementTag#getBoundValue()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the bound value.\n\t * @see #getBindStatus()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "Object",
    "signature": "protected Object getBoundValue()",
    "source_code": "\tprotected final Object getBoundValue() throws JspException {\n\t\treturn getBindStatus().getValue();\n\t}"
  },
  "org.springframework.web.servlet.tags.form.AbstractDataBoundFormElementTag#getEditor()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Exposes the {@link PropertyEditor} for {@link EditorAwareTag}.\n\t * <p>Use {@link #getPropertyEditor()} for internal rendering purposes.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 226
    },
    "return": "PropertyEditor",
    "signature": "public PropertyEditor getEditor()",
    "source_code": "\tpublic final PropertyEditor getEditor() throws JspException {\n\t\treturn getPropertyEditor();\n\t}"
  },
  "org.springframework.web.servlet.tags.form.AbstractDataBoundFormElementTag#getId()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the value of the '{@code id}' attribute.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "String",
    "signature": "public String getId()",
    "source_code": "\tpublic String getId() {\n\t\treturn this.id;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.AbstractDataBoundFormElementTag#getName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the value for the HTML '{@code name}' attribute.\n\t * <p>The default implementation simply delegates to\n\t * {@link #getPropertyPath()} to use the property path as the name.\n\t * For the most part this is desirable as it links with the server-side\n\t * expectation for data binding. However, some subclasses may wish to change\n\t * the value of the '{@code name}' attribute without changing the bind path.\n\t * @return the value for the HTML '{@code name}' attribute\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "String",
    "signature": "protected String getName()",
    "source_code": "\tprotected String getName() throws JspException {\n\t\treturn getPropertyPath();\n\t}"
  },
  "org.springframework.web.servlet.tags.form.AbstractDataBoundFormElementTag#getNestedPath()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the value of the nested path that may have been exposed by the\n\t * {@link NestedPathTag}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "String",
    "signature": "protected String getNestedPath()",
    "source_code": "\tprotected String getNestedPath() {\n\t\treturn (String) this.pageContext.getAttribute(NESTED_PATH_VARIABLE_NAME, PageContext.REQUEST_SCOPE);\n\t}"
  },
  "org.springframework.web.servlet.tags.form.AbstractDataBoundFormElementTag#getPath()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the {@link #evaluate resolved} property path for the\n\t * {@link FormTag#setModelAttribute form object}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "String",
    "signature": "protected String getPath()",
    "source_code": "\tprotected final String getPath() throws JspException {\n\t\tString resolvedPath = (String) evaluate(\"path\", this.path);\n\t\treturn (resolvedPath != null ? resolvedPath : \"\");\n\t}"
  },
  "org.springframework.web.servlet.tags.form.AbstractDataBoundFormElementTag#getPropertyEditor()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the {@link PropertyEditor}, if any, in use for value bound to this tag.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "PropertyEditor",
    "signature": "protected PropertyEditor getPropertyEditor()",
    "source_code": "\tprotected PropertyEditor getPropertyEditor() throws JspException {\n\t\treturn getBindStatus().getEditor();\n\t}"
  },
  "org.springframework.web.servlet.tags.form.AbstractDataBoundFormElementTag#getPropertyPath()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build the property path for this tag, including the nested path\n\t * but <i>not</i> prefixed with the name of the form attribute.\n\t * @see #getNestedPath()\n\t * @see #getPath()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "String",
    "signature": "protected String getPropertyPath()",
    "source_code": "\tprotected String getPropertyPath() throws JspException {\n\t\tString expression = getBindStatus().getExpression();\n\t\treturn (expression != null ? expression : \"\");\n\t}"
  },
  "org.springframework.web.servlet.tags.form.AbstractDataBoundFormElementTag#processFieldValue(name,value,type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Process the given form field through a {@link RequestDataValueProcessor}\n\t * instance if one is configured or otherwise returns the same value.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "value",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "String",
    "signature": "protected String processFieldValue(@Nullable String name, String value, String type)",
    "source_code": "\tprotected final String processFieldValue(@Nullable String name, String value, String type) {\n\t\tRequestDataValueProcessor processor = getRequestContext().getRequestDataValueProcessor();\n\t\tServletRequest request = this.pageContext.getRequest();\n\t\tif (processor != null && request instanceof HttpServletRequest httpServletRequest) {\n\t\t\tvalue = processor.processFormFieldValue(httpServletRequest, name, value, type);\n\t\t}\n\t\treturn value;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.AbstractDataBoundFormElementTag#resolveId()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the '{@code id}' attribute value for this tag,\n\t * autogenerating one if none specified.\n\t * @see #getId()\n\t * @see #autogenerateId()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "String",
    "signature": "protected String resolveId()",
    "source_code": "\tprotected String resolveId() throws JspException {\n\t\tObject id = evaluate(\"id\", getId());\n\t\tif (id != null) {\n\t\t\tString idString = id.toString();\n\t\t\treturn (StringUtils.hasText(idString) ? idString : null);\n\t\t}\n\t\treturn autogenerateId();\n\t}"
  },
  "org.springframework.web.servlet.tags.form.AbstractDataBoundFormElementTag#setId(id)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value of the '{@code id}' attribute.\n\t * <p>May be a runtime expression; defaults to the value of {@link #getName()}.\n\t * Note that the default value may not be valid for certain tags.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "id"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void setId(@Nullable String id)",
    "source_code": "\tpublic void setId(@Nullable String id) {\n\t\tthis.id = id;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.AbstractDataBoundFormElementTag#setPath(path)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the property path from the {@link FormTag#setModelAttribute form object}.\n\t * May be a runtime expression.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "public void setPath(String path)",
    "source_code": "\tpublic void setPath(String path) {\n\t\tthis.path = path;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.AbstractDataBoundFormElementTag#writeDefaultAttributes(tagWriter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Writes the default set of attributes to the supplied {@link TagWriter}.\n\t * Further, abstract subclasses should override this method to add in\n\t * any additional default attributes but <strong>must</strong> remember\n\t * to call the {@code super} method.\n\t * <p>Concrete subclasses should call this method when/if they want\n\t * to render default attributes.\n\t * @param tagWriter the {@link TagWriter} to which any attributes are to be written\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "tagWriter"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "void",
    "signature": "protected void writeDefaultAttributes(TagWriter tagWriter)",
    "source_code": "\tprotected void writeDefaultAttributes(TagWriter tagWriter) throws JspException {\n\t\twriteOptionalAttribute(tagWriter, \"id\", resolveId());\n\t\twriteOptionalAttribute(tagWriter, \"name\", getName());\n\t}"
  },
  "org.springframework.web.servlet.tags.form.CheckboxTag": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * The {@code <checkbox>} tag renders an HTML 'input' tag with type 'checkbox'.\n * May be used in one of three different approaches depending on the\n * type of the {@link #getValue bound value}.\n *\n * <h3>Approach One</h3>\n * When the bound value is of type {@link Boolean} then the '{@code input(checkbox)}'\n * is marked as 'checked' if the bound value is {@code true}. The '{@code value}'\n * attribute corresponds to the resolved value of the {@link #setValue(Object) value} property.\n * <h3>Approach Two</h3>\n * When the bound value is of type {@link Collection} then the '{@code input(checkbox)}'\n * is marked as 'checked' if the configured {@link #setValue(Object) value} is present in\n * the bound {@link Collection}.\n * <h3>Approach Three</h3>\n * For any other bound value type, the '{@code input(checkbox)}' is marked as 'checked'\n * if the configured {@link #setValue(Object) value} is equal to the bound value.\n *\n * <p>\n * <table>\n * <caption>Attribute Summary</caption>\n * <thead>\n * <tr>\n * <th class=\"colFirst\">Attribute</th>\n * <th class=\"colOne\">Required?</th>\n * <th class=\"colOne\">Runtime Expression?</th>\n * <th class=\"colLast\">Description</th>\n * </tr>\n * </thead>\n * <tbody>\n * <tr class=\"altColor\">\n * <td><p>accesskey</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Standard Attribute</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>cssClass</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Optional Attribute</p></td>\n * </tr>\n * <tr class=\"altColor\">\n * <td><p>cssErrorClass</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Optional Attribute. Used when the bound field has errors.</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>cssStyle</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Optional Attribute</p></td>\n * </tr>\n * <tr class=\"altColor\">\n * <td><p>dir</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Standard Attribute</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>disabled</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Optional Attribute. Setting the value of this attribute to 'true'\n * will disable the HTML element.</p></td>\n * </tr>\n * <tr class=\"altColor\">\n * <td><p>htmlEscape</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>Enable/disable HTML escaping of rendered values.</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>id</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Standard Attribute</p></td>\n * </tr>\n * <tr class=\"altColor\">\n * <td><p>label</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>Value to be displayed as part of the tag</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>lang</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Standard Attribute</p></td>\n * </tr>\n * <tr class=\"altColor\">\n * <td><p>onblur</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Event Attribute</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>onchange</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Event Attribute</p></td>\n * </tr>\n * <tr class=\"altColor\">\n * <td><p>onclick</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Event Attribute</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>ondblclick</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Event Attribute</p></td>\n * </tr>\n * <tr class=\"altColor\">\n * <td><p>onfocus</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Event Attribute</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>onkeydown</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Event Attribute</p></td>\n * </tr>\n * <tr class=\"altColor\">\n * <td><p>onkeypress</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Event Attribute</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>onkeyup</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Event Attribute</p></td>\n * </tr>\n * <tr class=\"altColor\">\n * <td><p>onmousedown</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Event Attribute</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>onmousemove</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Event Attribute</p></td>\n * </tr>\n * <tr class=\"altColor\">\n * <td><p>onmouseout</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Event Attribute</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>onmouseover</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Event Attribute</p></td>\n * </tr>\n * <tr class=\"altColor\">\n * <td><p>onmouseup</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Event Attribute</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>path</p></td>\n * <td><p>true</p></td>\n * <td><p>true</p></td>\n * <td><p>Path to property for data binding</p></td>\n * </tr>\n * <tr class=\"altColor\">\n * <td><p>tabindex</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Standard Attribute</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>title</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Standard Attribute</p></td>\n * </tr>\n * <tr class=\"altColor\">\n * <td><p>value</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Optional Attribute</p></td>\n * </tr>\n * </tbody>\n * </table>\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @since 2.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "signature": "public class CheckboxTag",
    "source_code": "public class CheckboxTag extends AbstractSingleCheckedElementTag {\n\n\t@Override\n\tprotected int writeTagContent(TagWriter tagWriter) throws JspException {\n\t\tsuper.writeTagContent(tagWriter);\n\n\t\tif (!isDisabled()) {\n\t\t\t// Write out the 'field was present' marker.\n\t\t\ttagWriter.startTag(\"input\");\n\t\t\ttagWriter.writeAttribute(\"type\", \"hidden\");\n\t\t\tString name = WebDataBinder.DEFAULT_FIELD_MARKER_PREFIX + getName();\n\t\t\ttagWriter.writeAttribute(\"name\", name);\n\t\t\ttagWriter.writeAttribute(\"value\", processFieldValue(name, \"on\", \"hidden\"));\n\t\t\ttagWriter.endTag();\n\t\t}\n\n\t\treturn SKIP_BODY;\n\t}\n\n\t@Override\n\tprotected void writeTagDetails(TagWriter tagWriter) throws JspException {\n\t\ttagWriter.writeAttribute(\"type\", getInputType());\n\n\t\tObject boundValue = getBoundValue();\n\t\tClass<?> valueType = getBindStatus().getValueType();\n\n\t\tif (Boolean.class == valueType || boolean.class == valueType) {\n\t\t\t// the concrete type may not be a Boolean - can be String\n\t\t\tif (boundValue instanceof String string) {\n\t\t\t\tboundValue = Boolean.valueOf(string);\n\t\t\t}\n\t\t\tBoolean booleanValue = (boundValue != null ? (Boolean) boundValue : Boolean.FALSE);\n\t\t\trenderFromBoolean(booleanValue, tagWriter);\n\t\t}\n\n\t\telse {\n\t\t\tObject value = getValue();\n\t\t\tif (value == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"Attribute 'value' is required when binding to non-boolean values\");\n\t\t\t}\n\t\t\tObject resolvedValue = (value instanceof String ? evaluate(\"value\", value) : value);\n\t\t\trenderFromValue(resolvedValue, tagWriter);\n\t\t}\n\t}\n\n\t@Override\n\tprotected String getInputType() {\n\t\treturn \"checkbox\";\n\t}\n\n}"
  },
  "org.springframework.web.servlet.tags.form.CheckboxTag#getInputType()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "String",
    "signature": "protected String getInputType()",
    "source_code": "\tprotected String getInputType() {\n\t\treturn \"checkbox\";\n\t}"
  },
  "org.springframework.web.servlet.tags.form.CheckboxTag#writeTagContent(tagWriter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "tagWriter"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "int",
    "signature": "protected int writeTagContent(TagWriter tagWriter)",
    "source_code": "\tprotected int writeTagContent(TagWriter tagWriter) throws JspException {\n\t\tsuper.writeTagContent(tagWriter);\n\n\t\tif (!isDisabled()) {\n\t\t\t// Write out the 'field was present' marker.\n\t\t\ttagWriter.startTag(\"input\");\n\t\t\ttagWriter.writeAttribute(\"type\", \"hidden\");\n\t\t\tString name = WebDataBinder.DEFAULT_FIELD_MARKER_PREFIX + getName();\n\t\t\ttagWriter.writeAttribute(\"name\", name);\n\t\t\ttagWriter.writeAttribute(\"value\", processFieldValue(name, \"on\", \"hidden\"));\n\t\t\ttagWriter.endTag();\n\t\t}\n\n\t\treturn SKIP_BODY;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.CheckboxTag#writeTagDetails(tagWriter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "tagWriter"
    ],
    "position": {
      "column": 1,
      "line": 245
    },
    "return": "void",
    "signature": "protected void writeTagDetails(TagWriter tagWriter)",
    "source_code": "\tprotected void writeTagDetails(TagWriter tagWriter) throws JspException {\n\t\ttagWriter.writeAttribute(\"type\", getInputType());\n\n\t\tObject boundValue = getBoundValue();\n\t\tClass<?> valueType = getBindStatus().getValueType();\n\n\t\tif (Boolean.class == valueType || boolean.class == valueType) {\n\t\t\t// the concrete type may not be a Boolean - can be String\n\t\t\tif (boundValue instanceof String string) {\n\t\t\t\tboundValue = Boolean.valueOf(string);\n\t\t\t}\n\t\t\tBoolean booleanValue = (boundValue != null ? (Boolean) boundValue : Boolean.FALSE);\n\t\t\trenderFromBoolean(booleanValue, tagWriter);\n\t\t}\n\n\t\telse {\n\t\t\tObject value = getValue();\n\t\t\tif (value == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"Attribute 'value' is required when binding to non-boolean values\");\n\t\t\t}\n\t\t\tObject resolvedValue = (value instanceof String ? evaluate(\"value\", value) : value);\n\t\t\trenderFromValue(resolvedValue, tagWriter);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.tags.form.DEFAULT_COMMAND_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** The default attribute name: &quot;command&quot;. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 252
    },
    "signature": "public String DEFAULT_COMMAND_NAME",
    "source_code": "\tpublic static final String DEFAULT_COMMAND_NAME = \"command\";",
    "type": "String"
  },
  "org.springframework.web.servlet.tags.form.FormTag": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * The {@code <form>} tag renders an HTML 'form' tag and exposes a binding path to\n * inner tags for binding.\n *\n * <p>Users should place the form object into the\n * {@link org.springframework.web.servlet.ModelAndView ModelAndView} when\n * populating the data for their view. The name of this form object can be\n * configured using the {@link #setModelAttribute \"modelAttribute\"} property.\n *\n * <p>\n * <table>\n * <caption>Attribute Summary</caption>\n * <thead>\n * <tr>\n * <th class=\"colFirst\">Attribute</th>\n * <th class=\"colOne\">Required?</th>\n * <th class=\"colOne\">Runtime Expression?</th>\n * <th class=\"colLast\">Description</th>\n * </tr>\n * </thead>\n * <tbody>\n * <tr class=\"altColor\">\n * <td><p>acceptCharset</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>Specifies the list of character encodings for input data that is accepted\n * by the server processing this form. The value is a space- and/or comma-delimited\n * list of charset values. The client must interpret this list as an exclusive-or\n * list, i.e., the server is able to accept any single character encoding per\n * entity received.</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>action</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Required Attribute</p></td>\n * </tr>\n * <tr class=\"altColor\">\n * <td><p>cssClass</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Optional Attribute</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>cssStyle</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Optional Attribute</p></td>\n * </tr>\n * <tr class=\"altColor\">\n * <td><p>dir</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Standard Attribute</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>enctype</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Optional Attribute</p></td>\n * </tr>\n * <tr class=\"altColor\">\n * <td><p>htmlEscape</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>Enable/disable HTML escaping of rendered values.</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>id</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Standard Attribute</p></td>\n * </tr>\n * <tr class=\"altColor\">\n * <td><p>lang</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Standard Attribute</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>method</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Optional Attribute</p></td>\n * </tr>\n * <tr class=\"altColor\">\n * <td><p>methodParam</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>The parameter name used for HTTP methods other then GET and POST.\n * Default is '_method'.</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>modelAttribute</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>Name of the model attribute under which the form object is exposed.\n * Defaults to 'command'.</p></td>\n * </tr>\n * <tr class=\"altColor\">\n * <td><p>name</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Standard Attribute - added for backwards compatibility cases</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>onclick</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Event Attribute</p></td>\n * </tr>\n * <tr class=\"altColor\">\n * <td><p>ondblclick</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Event Attribute</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>onkeydown</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Event Attribute</p></td>\n * </tr>\n * <tr class=\"altColor\">\n * <td><p>onkeypress</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Event Attribute</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>onkeyup</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Event Attribute</p></td>\n * </tr>\n * <tr class=\"altColor\">\n * <td><p>onmousedown</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Event Attribute</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>onmousemove</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Event Attribute</p></td>\n * </tr>\n * <tr class=\"altColor\">\n * <td><p>onmouseout</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Event Attribute</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>onmouseover</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Event Attribute</p></td>\n * </tr>\n * <tr class=\"altColor\">\n * <td><p>onmouseup</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Event Attribute</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>onreset</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Event Attribute</p></td>\n * </tr>\n * <tr class=\"altColor\">\n * <td><p>onsubmit</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Event Attribute</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>servletRelativeAction</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>Action reference to be appended to the current servlet path</p></td>\n * </tr>\n * <tr class=\"altColor\">\n * <td><p>target</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Optional Attribute</p></td>\n * </tr>\n * <tr class=\"rowColor\">\n * <td><p>title</p></td>\n * <td><p>false</p></td>\n * <td><p>true</p></td>\n * <td><p>HTML Standard Attribute</p></td>\n * </tr>\n * </tbody>\n * </table>\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @author Scott Andrews\n * @author Rossen Stoyanchev\n * @since 2.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 246
    },
    "signature": "public class FormTag",
    "source_code": "public class FormTag extends AbstractHtmlElementTag {\n\n\t/** The default HTTP method using which form values are sent to the server: \"post\". */\n\tprivate static final String DEFAULT_METHOD = \"post\";\n\n\t/** The default attribute name: &quot;command&quot;. */\n\tpublic static final String DEFAULT_COMMAND_NAME = \"command\";\n\n\t/** The name of the '{@code modelAttribute}' setting. */\n\tprivate static final String MODEL_ATTRIBUTE = \"modelAttribute\";\n\n\t/**\n\t * The name of the {@link jakarta.servlet.jsp.PageContext} attribute under which the\n\t * form object name is exposed.\n\t */\n\tpublic static final String MODEL_ATTRIBUTE_VARIABLE_NAME =\n\t\t\tConventions.getQualifiedAttributeName(AbstractFormTag.class, MODEL_ATTRIBUTE);\n\n\t/** Default method parameter, i.e. {@code _method}. */\n\tprivate static final String DEFAULT_METHOD_PARAM = \"_method\";\n\n\tprivate static final String FORM_TAG = \"form\";\n\n\tprivate static final String INPUT_TAG = \"input\";\n\n\tprivate static final String ACTION_ATTRIBUTE = \"action\";\n\n\tprivate static final String METHOD_ATTRIBUTE = \"method\";\n\n\tprivate static final String TARGET_ATTRIBUTE = \"target\";\n\n\tprivate static final String ENCTYPE_ATTRIBUTE = \"enctype\";\n\n\tprivate static final String ACCEPT_CHARSET_ATTRIBUTE = \"accept-charset\";\n\n\tprivate static final String ONSUBMIT_ATTRIBUTE = \"onsubmit\";\n\n\tprivate static final String ONRESET_ATTRIBUTE = \"onreset\";\n\n\tprivate static final String AUTOCOMPLETE_ATTRIBUTE = \"autocomplete\";\n\n\tprivate static final String NAME_ATTRIBUTE = \"name\";\n\n\tprivate static final String VALUE_ATTRIBUTE = \"value\";\n\n\tprivate static final String TYPE_ATTRIBUTE = \"type\";\n\n\n\t@Nullable\n\tprivate TagWriter tagWriter;\n\n\tprivate String modelAttribute = DEFAULT_COMMAND_NAME;\n\n\t@Nullable\n\tprivate String name;\n\n\t@Nullable\n\tprivate String action;\n\n\t@Nullable\n\tprivate String servletRelativeAction;\n\n\tprivate String method = DEFAULT_METHOD;\n\n\t@Nullable\n\tprivate String target;\n\n\t@Nullable\n\tprivate String enctype;\n\n\t@Nullable\n\tprivate String acceptCharset;\n\n\t@Nullable\n\tprivate String onsubmit;\n\n\t@Nullable\n\tprivate String onreset;\n\n\t@Nullable\n\tprivate String autocomplete;\n\n\tprivate String methodParam = DEFAULT_METHOD_PARAM;\n\n\t/** Caching a previous nested path, so that it may be reset. */\n\t@Nullable\n\tprivate String previousNestedPath;\n\n\n\t/**\n\t * Set the name of the form attribute in the model.\n\t * <p>May be a runtime expression.\n\t */\n\tpublic void setModelAttribute(String modelAttribute) {\n\t\tthis.modelAttribute = modelAttribute;\n\t}\n\n\t/**\n\t * Get the name of the form attribute in the model.\n\t */\n\tprotected String getModelAttribute() {\n\t\treturn this.modelAttribute;\n\t}\n\n\t/**\n\t * Set the value of the '{@code name}' attribute.\n\t * <p>May be a runtime expression.\n\t * <p>Name is not a valid attribute for form on XHTML 1.0. However,\n\t * it is sometimes needed for backward compatibility.\n\t */\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\t/**\n\t * Get the value of the '{@code name}' attribute.\n\t */\n\t@Override\n\t@Nullable\n\tprotected String getName() throws JspException {\n\t\treturn this.name;\n\t}\n\n\t/**\n\t * Set the value of the '{@code action}' attribute.\n\t * <p>May be a runtime expression.\n\t */\n\tpublic void setAction(@Nullable String action) {\n\t\tthis.action = (action != null ? action : \"\");\n\t}\n\n\t/**\n\t * Get the value of the '{@code action}' attribute.\n\t */\n\t@Nullable\n\tprotected String getAction() {\n\t\treturn this.action;\n\t}\n\n\t/**\n\t * Set the value of the '{@code action}' attribute through a value\n\t * that is to be appended to the current servlet path.\n\t * <p>May be a runtime expression.\n\t * @since 3.2.3\n\t */\n\tpublic void setServletRelativeAction(@Nullable String servletRelativeAction) {\n\t\tthis.servletRelativeAction = servletRelativeAction;\n\t}\n\n\t/**\n\t * Get the servlet-relative value of the '{@code action}' attribute.\n\t * @since 3.2.3\n\t */\n\t@Nullable\n\tprotected String getServletRelativeAction() {\n\t\treturn this.servletRelativeAction;\n\t}\n\n\t/**\n\t * Set the value of the '{@code method}' attribute.\n\t * <p>May be a runtime expression.\n\t */\n\tpublic void setMethod(String method) {\n\t\tthis.method = method;\n\t}\n\n\t/**\n\t * Get the value of the '{@code method}' attribute.\n\t */\n\tprotected String getMethod() {\n\t\treturn this.method;\n\t}\n\n\t/**\n\t * Set the value of the '{@code target}' attribute.\n\t * <p>May be a runtime expression.\n\t */\n\tpublic void setTarget(String target) {\n\t\tthis.target = target;\n\t}\n\n\t/**\n\t * Get the value of the '{@code target}' attribute.\n\t */\n\t@Nullable\n\tpublic String getTarget() {\n\t\treturn this.target;\n\t}\n\n\t/**\n\t * Set the value of the '{@code enctype}' attribute.\n\t * <p>May be a runtime expression.\n\t */\n\tpublic void setEnctype(String enctype) {\n\t\tthis.enctype = enctype;\n\t}\n\n\t/**\n\t * Get the value of the '{@code enctype}' attribute.\n\t */\n\t@Nullable\n\tprotected String getEnctype() {\n\t\treturn this.enctype;\n\t}\n\n\t/**\n\t * Set the value of the '{@code acceptCharset}' attribute.\n\t * <p>May be a runtime expression.\n\t */\n\tpublic void setAcceptCharset(String acceptCharset) {\n\t\tthis.acceptCharset = acceptCharset;\n\t}\n\n\t/**\n\t * Get the value of the '{@code acceptCharset}' attribute.\n\t */\n\t@Nullable\n\tprotected String getAcceptCharset() {\n\t\treturn this.acceptCharset;\n\t}\n\n\t/**\n\t * Set the value of the '{@code onsubmit}' attribute.\n\t * <p>May be a runtime expression.\n\t */\n\tpublic void setOnsubmit(String onsubmit) {\n\t\tthis.onsubmit = onsubmit;\n\t}\n\n\t/**\n\t * Get the value of the '{@code onsubmit}' attribute.\n\t */\n\t@Nullable\n\tprotected String getOnsubmit() {\n\t\treturn this.onsubmit;\n\t}\n\n\t/**\n\t * Set the value of the '{@code onreset}' attribute.\n\t * <p>May be a runtime expression.\n\t */\n\tpublic void setOnreset(String onreset) {\n\t\tthis.onreset = onreset;\n\t}\n\n\t/**\n\t * Get the value of the '{@code onreset}' attribute.\n\t */\n\t@Nullable\n\tprotected String getOnreset() {\n\t\treturn this.onreset;\n\t}\n\n\t/**\n\t * Set the value of the '{@code autocomplete}' attribute.\n\t * May be a runtime expression.\n\t */\n\tpublic void setAutocomplete(String autocomplete) {\n\t\tthis.autocomplete = autocomplete;\n\t}\n\n\t/**\n\t * Get the value of the '{@code autocomplete}' attribute.\n\t */\n\t@Nullable\n\tprotected String getAutocomplete() {\n\t\treturn this.autocomplete;\n\t}\n\n\t/**\n\t * Set the name of the request param for non-browser supported HTTP methods.\n\t */\n\tpublic void setMethodParam(String methodParam) {\n\t\tthis.methodParam = methodParam;\n\t}\n\n\t/**\n\t * Get the name of the request param for non-browser supported HTTP methods.\n\t * @since 4.2.3\n\t */\n\tprotected String getMethodParam() {\n\t\treturn this.methodParam;\n\t}\n\n\t/**\n\t * Determine if the HTTP method is supported by browsers (i.e. GET or POST).\n\t */\n\tprotected boolean isMethodBrowserSupported(String method) {\n\t\treturn (\"get\".equalsIgnoreCase(method) || \"post\".equalsIgnoreCase(method));\n\t}\n\n\n\t/**\n\t * Writes the opening part of the block\t'{@code form}' tag and exposes\n\t * the form object name in the {@link jakarta.servlet.jsp.PageContext}.\n\t * @param tagWriter the {@link TagWriter} to which the form content is to be written\n\t * @return {@link jakarta.servlet.jsp.tagext.Tag#EVAL_BODY_INCLUDE}\n\t */\n\t@Override\n\tprotected int writeTagContent(TagWriter tagWriter) throws JspException {\n\t\tthis.tagWriter = tagWriter;\n\n\t\ttagWriter.startTag(FORM_TAG);\n\t\twriteDefaultAttributes(tagWriter);\n\t\ttagWriter.writeAttribute(ACTION_ATTRIBUTE, resolveAction());\n\t\twriteOptionalAttribute(tagWriter, METHOD_ATTRIBUTE, getHttpMethod());\n\t\twriteOptionalAttribute(tagWriter, TARGET_ATTRIBUTE, getTarget());\n\t\twriteOptionalAttribute(tagWriter, ENCTYPE_ATTRIBUTE, getEnctype());\n\t\twriteOptionalAttribute(tagWriter, ACCEPT_CHARSET_ATTRIBUTE, getAcceptCharset());\n\t\twriteOptionalAttribute(tagWriter, ONSUBMIT_ATTRIBUTE, getOnsubmit());\n\t\twriteOptionalAttribute(tagWriter, ONRESET_ATTRIBUTE, getOnreset());\n\t\twriteOptionalAttribute(tagWriter, AUTOCOMPLETE_ATTRIBUTE, getAutocomplete());\n\n\t\ttagWriter.forceBlock();\n\n\t\tif (!isMethodBrowserSupported(getMethod())) {\n\t\t\tassertHttpMethod(getMethod());\n\t\t\tString inputName = getMethodParam();\n\t\t\tString inputType = \"hidden\";\n\t\t\ttagWriter.startTag(INPUT_TAG);\n\t\t\twriteOptionalAttribute(tagWriter, TYPE_ATTRIBUTE, inputType);\n\t\t\twriteOptionalAttribute(tagWriter, NAME_ATTRIBUTE, inputName);\n\t\t\twriteOptionalAttribute(tagWriter, VALUE_ATTRIBUTE, processFieldValue(inputName, getMethod(), inputType));\n\t\t\ttagWriter.endTag();\n\t\t}\n\n\t\t// Expose the form object name for nested tags...\n\t\tString modelAttribute = resolveModelAttribute();\n\t\tthis.pageContext.setAttribute(MODEL_ATTRIBUTE_VARIABLE_NAME, modelAttribute, PageContext.REQUEST_SCOPE);\n\n\t\t// Save previous nestedPath value, build and expose current nestedPath value.\n\t\t// Use request scope to expose nestedPath to included pages too.\n\t\tthis.previousNestedPath =\n\t\t\t\t(String) this.pageContext.getAttribute(NESTED_PATH_VARIABLE_NAME, PageContext.REQUEST_SCOPE);\n\t\tthis.pageContext.setAttribute(NESTED_PATH_VARIABLE_NAME,\n\t\t\t\tmodelAttribute + PropertyAccessor.NESTED_PROPERTY_SEPARATOR, PageContext.REQUEST_SCOPE);\n\n\t\treturn EVAL_BODY_INCLUDE;\n\t}\n\n\tprivate String getHttpMethod() {\n\t\treturn (isMethodBrowserSupported(getMethod()) ? getMethod() : DEFAULT_METHOD);\n\t}\n\n\tprivate void assertHttpMethod(String method) {\n\t\tfor (HttpMethod httpMethod : HttpMethod.values()) {\n\t\t\tif (httpMethod.name().equalsIgnoreCase(method)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Invalid HTTP method: \" + method);\n\t}\n\n\t/**\n\t * Autogenerated IDs correspond to the form object name.\n\t */\n\t@Override\n\tprotected String autogenerateId() throws JspException {\n\t\treturn resolveModelAttribute();\n\t}\n\n\t/**\n\t * {@link #evaluate Resolves} and returns the name of the form object.\n\t * @throws IllegalArgumentException if the form object resolves to {@code null}\n\t */\n\tprotected String resolveModelAttribute() throws JspException {\n\t\tObject resolvedModelAttribute = evaluate(MODEL_ATTRIBUTE, getModelAttribute());\n\t\tif (resolvedModelAttribute == null) {\n\t\t\tthrow new IllegalArgumentException(MODEL_ATTRIBUTE + \" must not be null\");\n\t\t}\n\t\treturn (String) resolvedModelAttribute;\n\t}\n\n\t/**\n\t * Resolve the value of the '{@code action}' attribute.\n\t * <p>If the user configured an '{@code action}' value then the result of\n\t * evaluating this value is used. If the user configured an\n\t * '{@code servletRelativeAction}' value then the value is prepended\n\t * with the context and servlet paths, and the result is used. Otherwise, the\n\t * {@link org.springframework.web.servlet.support.RequestContext#getRequestUri()\n\t * originating URI} is used.\n\t * @return the value that is to be used for the '{@code action}' attribute\n\t */\n\tprotected String resolveAction() throws JspException {\n\t\tString action = getAction();\n\t\tString servletRelativeAction = getServletRelativeAction();\n\t\tif (StringUtils.hasText(action)) {\n\t\t\taction = getDisplayString(evaluate(ACTION_ATTRIBUTE, action));\n\t\t\treturn processAction(action);\n\t\t}\n\t\telse if (StringUtils.hasText(servletRelativeAction)) {\n\t\t\tString pathToServlet = getRequestContext().getPathToServlet();\n\t\t\tif (servletRelativeAction.startsWith(\"/\") &&\n\t\t\t\t\t!servletRelativeAction.startsWith(getRequestContext().getContextPath())) {\n\t\t\t\tservletRelativeAction = pathToServlet + servletRelativeAction;\n\t\t\t}\n\t\t\tservletRelativeAction = getDisplayString(evaluate(ACTION_ATTRIBUTE, servletRelativeAction));\n\t\t\treturn processAction(servletRelativeAction);\n\t\t}\n\t\telse {\n\t\t\tString requestUri = getRequestContext().getRequestUri();\n\t\t\tString encoding = this.pageContext.getResponse().getCharacterEncoding();\n\t\t\ttry {\n\t\t\t\trequestUri = UriUtils.encodePath(requestUri, encoding);\n\t\t\t}\n\t\t\tcatch (UnsupportedCharsetException ex) {\n\t\t\t\t// shouldn't happen - if it does, proceed with requestUri as-is\n\t\t\t}\n\t\t\tServletResponse response = this.pageContext.getResponse();\n\t\t\tif (response instanceof HttpServletResponse httpServletResponse) {\n\t\t\t\trequestUri = httpServletResponse.encodeURL(requestUri);\n\t\t\t\tString queryString = getRequestContext().getQueryString();\n\t\t\t\tif (StringUtils.hasText(queryString)) {\n\t\t\t\t\trequestUri += \"?\" + HtmlUtils.htmlEscape(queryString);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (StringUtils.hasText(requestUri)) {\n\t\t\t\treturn processAction(requestUri);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"Attribute 'action' is required. \" +\n\t\t\t\t\t\t\"Attempted to resolve against current request URI but request URI was null.\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Process the action through a {@link RequestDataValueProcessor} instance\n\t * if one is configured or otherwise returns the action unmodified.\n\t */\n\tprivate String processAction(String action) {\n\t\tRequestDataValueProcessor processor = getRequestContext().getRequestDataValueProcessor();\n\t\tServletRequest request = this.pageContext.getRequest();\n\t\tif (processor != null && request instanceof HttpServletRequest httpServletRequest) {\n\t\t\taction = processor.processAction(httpServletRequest, action, getHttpMethod());\n\t\t}\n\t\treturn action;\n\t}\n\n\t/**\n\t * Closes the '{@code form}' block tag and removes the form object name\n\t * from the {@link jakarta.servlet.jsp.PageContext}.\n\t */\n\t@Override\n\tpublic int doEndTag() throws JspException {\n\t\tRequestDataValueProcessor processor = getRequestContext().getRequestDataValueProcessor();\n\t\tServletRequest request = this.pageContext.getRequest();\n\t\tif (processor != null && request instanceof HttpServletRequest httpServletRequest) {\n\t\t\twriteHiddenFields(processor.getExtraHiddenFields(httpServletRequest));\n\t\t}\n\t\tAssert.state(this.tagWriter != null, \"No TagWriter set\");\n\t\tthis.tagWriter.endTag();\n\t\treturn EVAL_PAGE;\n\t}\n\n\t/**\n\t * Writes the given values as hidden fields.\n\t */\n\tprivate void writeHiddenFields(@Nullable Map<String, String> hiddenFields) throws JspException {\n\t\tif (!CollectionUtils.isEmpty(hiddenFields)) {\n\t\t\tAssert.state(this.tagWriter != null, \"No TagWriter set\");\n\t\t\tthis.tagWriter.appendValue(\"<div>\\n\");\n\t\t\tfor (Map.Entry<String, String> entry : hiddenFields.entrySet()) {\n\t\t\t\tthis.tagWriter.appendValue(\"<input type=\\\"hidden\\\" \");\n\t\t\t\tthis.tagWriter.appendValue(\"name=\\\"\" + entry.getKey() + \"\\\" value=\\\"\" + entry.getValue() + \"\\\" \");\n\t\t\t\tthis.tagWriter.appendValue(\"/>\\n\");\n\t\t\t}\n\t\t\tthis.tagWriter.appendValue(\"</div>\");\n\t\t}\n\t}\n\n\t/**\n\t * Clears the stored {@link TagWriter}.\n\t */\n\t@Override\n\tpublic void doFinally() {\n\t\tsuper.doFinally();\n\n\t\tthis.pageContext.removeAttribute(MODEL_ATTRIBUTE_VARIABLE_NAME, PageContext.REQUEST_SCOPE);\n\t\tif (this.previousNestedPath != null) {\n\t\t\t// Expose previous nestedPath value.\n\t\t\tthis.pageContext.setAttribute(NESTED_PATH_VARIABLE_NAME, this.previousNestedPath, PageContext.REQUEST_SCOPE);\n\t\t}\n\t\telse {\n\t\t\t// Remove exposed nestedPath value.\n\t\t\tthis.pageContext.removeAttribute(NESTED_PATH_VARIABLE_NAME, PageContext.REQUEST_SCOPE);\n\t\t}\n\t\tthis.tagWriter = null;\n\t\tthis.previousNestedPath = null;\n\t}\n\n\n\t/**\n\t * Override resolve CSS class since error class is not supported.\n\t */\n\t@Override\n\tprotected String resolveCssClass() throws JspException {\n\t\treturn ObjectUtils.getDisplayString(evaluate(\"cssClass\", getCssClass()));\n\t}\n\n\t/**\n\t * Unsupported for forms.\n\t * @throws UnsupportedOperationException always\n\t */\n\t@Override\n\tpublic void setPath(String path) {\n\t\tthrow new UnsupportedOperationException(\"The 'path' attribute is not supported for forms\");\n\t}\n\n\t/**\n\t * Unsupported for forms.\n\t * @throws UnsupportedOperationException always\n\t */\n\t@Override\n\tpublic void setCssErrorClass(String cssErrorClass) {\n\t\tthrow new UnsupportedOperationException(\"The 'cssErrorClass' attribute is not supported for forms\");\n\t}\n\n}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#autogenerateId()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Autogenerated IDs correspond to the form object name.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 603
    },
    "return": "String",
    "signature": "protected String autogenerateId()",
    "source_code": "\tprotected String autogenerateId() throws JspException {\n\t\treturn resolveModelAttribute();\n\t}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#doEndTag()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Closes the '{@code form}' block tag and removes the form object name\n\t * from the {@link jakarta.servlet.jsp.PageContext}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 690
    },
    "return": "int",
    "signature": "public int doEndTag()",
    "source_code": "\tpublic int doEndTag() throws JspException {\n\t\tRequestDataValueProcessor processor = getRequestContext().getRequestDataValueProcessor();\n\t\tServletRequest request = this.pageContext.getRequest();\n\t\tif (processor != null && request instanceof HttpServletRequest httpServletRequest) {\n\t\t\twriteHiddenFields(processor.getExtraHiddenFields(httpServletRequest));\n\t\t}\n\t\tAssert.state(this.tagWriter != null, \"No TagWriter set\");\n\t\tthis.tagWriter.endTag();\n\t\treturn EVAL_PAGE;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#doFinally()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Clears the stored {@link TagWriter}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 721
    },
    "return": "void",
    "signature": "public void doFinally()",
    "source_code": "\tpublic void doFinally() {\n\t\tsuper.doFinally();\n\n\t\tthis.pageContext.removeAttribute(MODEL_ATTRIBUTE_VARIABLE_NAME, PageContext.REQUEST_SCOPE);\n\t\tif (this.previousNestedPath != null) {\n\t\t\t// Expose previous nestedPath value.\n\t\t\tthis.pageContext.setAttribute(NESTED_PATH_VARIABLE_NAME, this.previousNestedPath, PageContext.REQUEST_SCOPE);\n\t\t}\n\t\telse {\n\t\t\t// Remove exposed nestedPath value.\n\t\t\tthis.pageContext.removeAttribute(NESTED_PATH_VARIABLE_NAME, PageContext.REQUEST_SCOPE);\n\t\t}\n\t\tthis.tagWriter = null;\n\t\tthis.previousNestedPath = null;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#getAcceptCharset()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the value of the '{@code acceptCharset}' attribute.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 463
    },
    "return": "String",
    "signature": "protected String getAcceptCharset()",
    "source_code": "\tprotected String getAcceptCharset() {\n\t\treturn this.acceptCharset;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#getAction()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the value of the '{@code action}' attribute.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 381
    },
    "return": "String",
    "signature": "protected String getAction()",
    "source_code": "\tprotected String getAction() {\n\t\treturn this.action;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#getAutocomplete()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the value of the '{@code autocomplete}' attribute.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 511
    },
    "return": "String",
    "signature": "protected String getAutocomplete()",
    "source_code": "\tprotected String getAutocomplete() {\n\t\treturn this.autocomplete;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#getEnctype()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the value of the '{@code enctype}' attribute.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 447
    },
    "return": "String",
    "signature": "protected String getEnctype()",
    "source_code": "\tprotected String getEnctype() {\n\t\treturn this.enctype;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#getMethod()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the value of the '{@code method}' attribute.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 415
    },
    "return": "String",
    "signature": "protected String getMethod()",
    "source_code": "\tprotected String getMethod() {\n\t\treturn this.method;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#getMethodParam()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the name of the request param for non-browser supported HTTP methods.\n\t * @since 4.2.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 526
    },
    "return": "String",
    "signature": "protected String getMethodParam()",
    "source_code": "\tprotected String getMethodParam() {\n\t\treturn this.methodParam;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#getModelAttribute()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the name of the form attribute in the model.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 346
    },
    "return": "String",
    "signature": "protected String getModelAttribute()",
    "source_code": "\tprotected String getModelAttribute() {\n\t\treturn this.modelAttribute;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#getName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the value of the '{@code name}' attribute.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 365
    },
    "return": "String",
    "signature": "protected String getName()",
    "source_code": "\tprotected String getName() throws JspException {\n\t\treturn this.name;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#getOnreset()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the value of the '{@code onreset}' attribute.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 495
    },
    "return": "String",
    "signature": "protected String getOnreset()",
    "source_code": "\tprotected String getOnreset() {\n\t\treturn this.onreset;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#getOnsubmit()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the value of the '{@code onsubmit}' attribute.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 479
    },
    "return": "String",
    "signature": "protected String getOnsubmit()",
    "source_code": "\tprotected String getOnsubmit() {\n\t\treturn this.onsubmit;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#getServletRelativeAction()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the servlet-relative value of the '{@code action}' attribute.\n\t * @since 3.2.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 400
    },
    "return": "String",
    "signature": "protected String getServletRelativeAction()",
    "source_code": "\tprotected String getServletRelativeAction() {\n\t\treturn this.servletRelativeAction;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#getTarget()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the value of the '{@code target}' attribute.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 431
    },
    "return": "String",
    "signature": "public String getTarget()",
    "source_code": "\tpublic String getTarget() {\n\t\treturn this.target;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#isMethodBrowserSupported(method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the HTTP method is supported by browsers (i.e. GET or POST).\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 533
    },
    "return": "boolean",
    "signature": "protected boolean isMethodBrowserSupported(String method)",
    "source_code": "\tprotected boolean isMethodBrowserSupported(String method) {\n\t\treturn (\"get\".equalsIgnoreCase(method) || \"post\".equalsIgnoreCase(method));\n\t}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#resolveAction()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the value of the '{@code action}' attribute.\n\t * <p>If the user configured an '{@code action}' value then the result of\n\t * evaluating this value is used. If the user configured an\n\t * '{@code servletRelativeAction}' value then the value is prepended\n\t * with the context and servlet paths, and the result is used. Otherwise, the\n\t * {@link org.springframework.web.servlet.support.RequestContext#getRequestUri()\n\t * originating URI} is used.\n\t * @return the value that is to be used for the '{@code action}' attribute\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 629
    },
    "return": "String",
    "signature": "protected String resolveAction()",
    "source_code": "\tprotected String resolveAction() throws JspException {\n\t\tString action = getAction();\n\t\tString servletRelativeAction = getServletRelativeAction();\n\t\tif (StringUtils.hasText(action)) {\n\t\t\taction = getDisplayString(evaluate(ACTION_ATTRIBUTE, action));\n\t\t\treturn processAction(action);\n\t\t}\n\t\telse if (StringUtils.hasText(servletRelativeAction)) {\n\t\t\tString pathToServlet = getRequestContext().getPathToServlet();\n\t\t\tif (servletRelativeAction.startsWith(\"/\") &&\n\t\t\t\t\t!servletRelativeAction.startsWith(getRequestContext().getContextPath())) {\n\t\t\t\tservletRelativeAction = pathToServlet + servletRelativeAction;\n\t\t\t}\n\t\t\tservletRelativeAction = getDisplayString(evaluate(ACTION_ATTRIBUTE, servletRelativeAction));\n\t\t\treturn processAction(servletRelativeAction);\n\t\t}\n\t\telse {\n\t\t\tString requestUri = getRequestContext().getRequestUri();\n\t\t\tString encoding = this.pageContext.getResponse().getCharacterEncoding();\n\t\t\ttry {\n\t\t\t\trequestUri = UriUtils.encodePath(requestUri, encoding);\n\t\t\t}\n\t\t\tcatch (UnsupportedCharsetException ex) {\n\t\t\t\t// shouldn't happen - if it does, proceed with requestUri as-is\n\t\t\t}\n\t\t\tServletResponse response = this.pageContext.getResponse();\n\t\t\tif (response instanceof HttpServletResponse httpServletResponse) {\n\t\t\t\trequestUri = httpServletResponse.encodeURL(requestUri);\n\t\t\t\tString queryString = getRequestContext().getQueryString();\n\t\t\t\tif (StringUtils.hasText(queryString)) {\n\t\t\t\t\trequestUri += \"?\" + HtmlUtils.htmlEscape(queryString);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (StringUtils.hasText(requestUri)) {\n\t\t\t\treturn processAction(requestUri);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"Attribute 'action' is required. \" +\n\t\t\t\t\t\t\"Attempted to resolve against current request URI but request URI was null.\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#resolveCssClass()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Override resolve CSS class since error class is not supported.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 742
    },
    "return": "String",
    "signature": "protected String resolveCssClass()",
    "source_code": "\tprotected String resolveCssClass() throws JspException {\n\t\treturn ObjectUtils.getDisplayString(evaluate(\"cssClass\", getCssClass()));\n\t}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#resolveModelAttribute()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@link #evaluate Resolves} and returns the name of the form object.\n\t * @throws IllegalArgumentException if the form object resolves to {@code null}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 611
    },
    "return": "String",
    "signature": "protected String resolveModelAttribute()",
    "source_code": "\tprotected String resolveModelAttribute() throws JspException {\n\t\tObject resolvedModelAttribute = evaluate(MODEL_ATTRIBUTE, getModelAttribute());\n\t\tif (resolvedModelAttribute == null) {\n\t\t\tthrow new IllegalArgumentException(MODEL_ATTRIBUTE + \" must not be null\");\n\t\t}\n\t\treturn (String) resolvedModelAttribute;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#setAcceptCharset(acceptCharset)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value of the '{@code acceptCharset}' attribute.\n\t * <p>May be a runtime expression.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "acceptCharset"
    ],
    "position": {
      "column": 1,
      "line": 455
    },
    "return": "void",
    "signature": "public void setAcceptCharset(String acceptCharset)",
    "source_code": "\tpublic void setAcceptCharset(String acceptCharset) {\n\t\tthis.acceptCharset = acceptCharset;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#setAction(action)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value of the '{@code action}' attribute.\n\t * <p>May be a runtime expression.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "action"
    ],
    "position": {
      "column": 1,
      "line": 373
    },
    "return": "void",
    "signature": "public void setAction(@Nullable String action)",
    "source_code": "\tpublic void setAction(@Nullable String action) {\n\t\tthis.action = (action != null ? action : \"\");\n\t}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#setAutocomplete(autocomplete)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value of the '{@code autocomplete}' attribute.\n\t * May be a runtime expression.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "autocomplete"
    ],
    "position": {
      "column": 1,
      "line": 503
    },
    "return": "void",
    "signature": "public void setAutocomplete(String autocomplete)",
    "source_code": "\tpublic void setAutocomplete(String autocomplete) {\n\t\tthis.autocomplete = autocomplete;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#setCssErrorClass(cssErrorClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Unsupported for forms.\n\t * @throws UnsupportedOperationException always\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cssErrorClass"
    ],
    "position": {
      "column": 1,
      "line": 760
    },
    "return": "void",
    "signature": "public void setCssErrorClass(String cssErrorClass)",
    "source_code": "\tpublic void setCssErrorClass(String cssErrorClass) {\n\t\tthrow new UnsupportedOperationException(\"The 'cssErrorClass' attribute is not supported for forms\");\n\t}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#setEnctype(enctype)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value of the '{@code enctype}' attribute.\n\t * <p>May be a runtime expression.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "enctype"
    ],
    "position": {
      "column": 1,
      "line": 439
    },
    "return": "void",
    "signature": "public void setEnctype(String enctype)",
    "source_code": "\tpublic void setEnctype(String enctype) {\n\t\tthis.enctype = enctype;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#setMethod(method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value of the '{@code method}' attribute.\n\t * <p>May be a runtime expression.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 408
    },
    "return": "void",
    "signature": "public void setMethod(String method)",
    "source_code": "\tpublic void setMethod(String method) {\n\t\tthis.method = method;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#setMethodParam(methodParam)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of the request param for non-browser supported HTTP methods.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodParam"
    ],
    "position": {
      "column": 1,
      "line": 518
    },
    "return": "void",
    "signature": "public void setMethodParam(String methodParam)",
    "source_code": "\tpublic void setMethodParam(String methodParam) {\n\t\tthis.methodParam = methodParam;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#setModelAttribute(modelAttribute)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of the form attribute in the model.\n\t * <p>May be a runtime expression.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "modelAttribute"
    ],
    "position": {
      "column": 1,
      "line": 339
    },
    "return": "void",
    "signature": "public void setModelAttribute(String modelAttribute)",
    "source_code": "\tpublic void setModelAttribute(String modelAttribute) {\n\t\tthis.modelAttribute = modelAttribute;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#setName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value of the '{@code name}' attribute.\n\t * <p>May be a runtime expression.\n\t * <p>Name is not a valid attribute for form on XHTML 1.0. However,\n\t * it is sometimes needed for backward compatibility.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 356
    },
    "return": "void",
    "signature": "public void setName(String name)",
    "source_code": "\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#setOnreset(onreset)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value of the '{@code onreset}' attribute.\n\t * <p>May be a runtime expression.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "onreset"
    ],
    "position": {
      "column": 1,
      "line": 487
    },
    "return": "void",
    "signature": "public void setOnreset(String onreset)",
    "source_code": "\tpublic void setOnreset(String onreset) {\n\t\tthis.onreset = onreset;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#setOnsubmit(onsubmit)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value of the '{@code onsubmit}' attribute.\n\t * <p>May be a runtime expression.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "onsubmit"
    ],
    "position": {
      "column": 1,
      "line": 471
    },
    "return": "void",
    "signature": "public void setOnsubmit(String onsubmit)",
    "source_code": "\tpublic void setOnsubmit(String onsubmit) {\n\t\tthis.onsubmit = onsubmit;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#setPath(path)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Unsupported for forms.\n\t * @throws UnsupportedOperationException always\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path"
    ],
    "position": {
      "column": 1,
      "line": 751
    },
    "return": "void",
    "signature": "public void setPath(String path)",
    "source_code": "\tpublic void setPath(String path) {\n\t\tthrow new UnsupportedOperationException(\"The 'path' attribute is not supported for forms\");\n\t}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#setServletRelativeAction(servletRelativeAction)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value of the '{@code action}' attribute through a value\n\t * that is to be appended to the current servlet path.\n\t * <p>May be a runtime expression.\n\t * @since 3.2.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletRelativeAction"
    ],
    "position": {
      "column": 1,
      "line": 391
    },
    "return": "void",
    "signature": "public void setServletRelativeAction(@Nullable String servletRelativeAction)",
    "source_code": "\tpublic void setServletRelativeAction(@Nullable String servletRelativeAction) {\n\t\tthis.servletRelativeAction = servletRelativeAction;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#setTarget(target)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value of the '{@code target}' attribute.\n\t * <p>May be a runtime expression.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target"
    ],
    "position": {
      "column": 1,
      "line": 423
    },
    "return": "void",
    "signature": "public void setTarget(String target)",
    "source_code": "\tpublic void setTarget(String target) {\n\t\tthis.target = target;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.FormTag#writeTagContent(tagWriter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Writes the opening part of the block\t'{@code form}' tag and exposes\n\t * the form object name in the {@link jakarta.servlet.jsp.PageContext}.\n\t * @param tagWriter the {@link TagWriter} to which the form content is to be written\n\t * @return {@link jakarta.servlet.jsp.tagext.Tag#EVAL_BODY_INCLUDE}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "tagWriter"
    ],
    "position": {
      "column": 1,
      "line": 545
    },
    "return": "int",
    "signature": "protected int writeTagContent(TagWriter tagWriter)",
    "source_code": "\tprotected int writeTagContent(TagWriter tagWriter) throws JspException {\n\t\tthis.tagWriter = tagWriter;\n\n\t\ttagWriter.startTag(FORM_TAG);\n\t\twriteDefaultAttributes(tagWriter);\n\t\ttagWriter.writeAttribute(ACTION_ATTRIBUTE, resolveAction());\n\t\twriteOptionalAttribute(tagWriter, METHOD_ATTRIBUTE, getHttpMethod());\n\t\twriteOptionalAttribute(tagWriter, TARGET_ATTRIBUTE, getTarget());\n\t\twriteOptionalAttribute(tagWriter, ENCTYPE_ATTRIBUTE, getEnctype());\n\t\twriteOptionalAttribute(tagWriter, ACCEPT_CHARSET_ATTRIBUTE, getAcceptCharset());\n\t\twriteOptionalAttribute(tagWriter, ONSUBMIT_ATTRIBUTE, getOnsubmit());\n\t\twriteOptionalAttribute(tagWriter, ONRESET_ATTRIBUTE, getOnreset());\n\t\twriteOptionalAttribute(tagWriter, AUTOCOMPLETE_ATTRIBUTE, getAutocomplete());\n\n\t\ttagWriter.forceBlock();\n\n\t\tif (!isMethodBrowserSupported(getMethod())) {\n\t\t\tassertHttpMethod(getMethod());\n\t\t\tString inputName = getMethodParam();\n\t\t\tString inputType = \"hidden\";\n\t\t\ttagWriter.startTag(INPUT_TAG);\n\t\t\twriteOptionalAttribute(tagWriter, TYPE_ATTRIBUTE, inputType);\n\t\t\twriteOptionalAttribute(tagWriter, NAME_ATTRIBUTE, inputName);\n\t\t\twriteOptionalAttribute(tagWriter, VALUE_ATTRIBUTE, processFieldValue(inputName, getMethod(), inputType));\n\t\t\ttagWriter.endTag();\n\t\t}\n\n\t\t// Expose the form object name for nested tags...\n\t\tString modelAttribute = resolveModelAttribute();\n\t\tthis.pageContext.setAttribute(MODEL_ATTRIBUTE_VARIABLE_NAME, modelAttribute, PageContext.REQUEST_SCOPE);\n\n\t\t// Save previous nestedPath value, build and expose current nestedPath value.\n\t\t// Use request scope to expose nestedPath to included pages too.\n\t\tthis.previousNestedPath =\n\t\t\t\t(String) this.pageContext.getAttribute(NESTED_PATH_VARIABLE_NAME, PageContext.REQUEST_SCOPE);\n\t\tthis.pageContext.setAttribute(NESTED_PATH_VARIABLE_NAME,\n\t\t\t\tmodelAttribute + PropertyAccessor.NESTED_PROPERTY_SEPARATOR, PageContext.REQUEST_SCOPE);\n\n\t\treturn EVAL_BODY_INCLUDE;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.MODEL_ATTRIBUTE_VARIABLE_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The name of the {@link jakarta.servlet.jsp.PageContext} attribute under which the\n\t * form object name is exposed.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "signature": "public String MODEL_ATTRIBUTE_VARIABLE_NAME",
    "source_code": "\tpublic static final String MODEL_ATTRIBUTE_VARIABLE_NAME =",
    "type": "String"
  },
  "org.springframework.web.servlet.tags.form.NESTED_PATH_VARIABLE_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Name of the exposed path variable within the scope of this tag: \"nestedPath\".\n\t * Same value as {@link org.springframework.web.servlet.tags.NestedPathTag#NESTED_PATH_VARIABLE_NAME}.\n\t */",
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "signature": "protected String NESTED_PATH_VARIABLE_NAME",
    "source_code": "\tprotected static final String NESTED_PATH_VARIABLE_NAME = NestedPathTag.NESTED_PATH_VARIABLE_NAME;",
    "type": "String"
  },
  "org.springframework.web.servlet.view.FORWARD_URL_PREFIX": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Prefix for special view names that specify a forward URL (usually\n\t * to a controller after a form has been submitted and processed).\n\t * Such view names will not be resolved in the configured default\n\t * way but rather be treated as special shortcut.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "signature": "public String FORWARD_URL_PREFIX",
    "source_code": "\tpublic static final String FORWARD_URL_PREFIX = \"forward:\";",
    "type": "String"
  },
  "org.springframework.web.servlet.view.REDIRECT_URL_PREFIX": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Prefix for special view names that specify a redirect URL (usually\n\t * to a controller after a form has been submitted and processed).\n\t * Such view names will not be resolved in the configured default\n\t * way but rather be treated as special shortcut.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "signature": "public String REDIRECT_URL_PREFIX",
    "source_code": "\tpublic static final String REDIRECT_URL_PREFIX = \"redirect:\";",
    "type": "String"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Simple implementation of the {@link org.springframework.web.servlet.ViewResolver}\n * interface, allowing for direct resolution of symbolic view names to URLs,\n * without explicit mapping definitions. This is useful if your symbolic names\n * match the names of your view resources in a straightforward manner\n * (i.e. the symbolic name is the unique part of the resource's filename),\n * without the need for a dedicated mapping to be defined for each view.\n *\n * <p>Supports {@link AbstractUrlBasedView} subclasses like {@link InternalResourceView}\n * and {@link org.springframework.web.servlet.view.freemarker.FreeMarkerView}.\n * The view class for all views generated by this resolver can be specified\n * via the \"viewClass\" property.\n *\n * <p>View names can either be resource URLs themselves, or get augmented by a\n * specified prefix and/or suffix. Exporting an attribute that holds the\n * RequestContext to all views is explicitly supported.\n *\n * <p>Example: prefix=\"/WEB-INF/jsp/\", suffix=\".jsp\", viewname=\"test\" &rarr;\n * \"/WEB-INF/jsp/test.jsp\"\n *\n * <p>As a special feature, redirect URLs can be specified via the \"redirect:\"\n * prefix. E.g.: \"redirect:myAction\" will trigger a redirect to the given\n * URL, rather than resolution as standard view name. This is typically used\n * for redirecting to a controller URL after finishing a form workflow.\n *\n * <p>Furthermore, forward URLs can be specified via the \"forward:\" prefix.\n * E.g.: \"forward:myAction\" will trigger a forward to the given URL, rather than\n * resolution as standard view name. This is typically used for controller URLs;\n * it is not supposed to be used for JSP URLs - use logical view names there.\n *\n * <p>Note: This class does not support localized resolution, i.e. resolving\n * a symbolic view name to different resources depending on the current locale.\n *\n * <p><b>Note:</b> When chaining ViewResolvers, a UrlBasedViewResolver will check whether\n * the {@linkplain AbstractUrlBasedView#checkResource specified resource actually exists}.\n * However, with {@link InternalResourceView}, it is not generally possible to\n * determine the existence of the target resource upfront. In such a scenario,\n * a UrlBasedViewResolver will always return a View for any given view name;\n * as a consequence, it should be configured as the last ViewResolver in the chain.\n *\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Sam Brannen\n * @since 13.12.2003\n * @see #setViewClass\n * @see #setPrefix\n * @see #setSuffix\n * @see #setRequestContextAttribute\n * @see #REDIRECT_URL_PREFIX\n * @see AbstractUrlBasedView\n * @see InternalResourceView\n * @see org.springframework.web.servlet.view.freemarker.FreeMarkerView\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "signature": "public class UrlBasedViewResolver",
    "source_code": "public class UrlBasedViewResolver extends AbstractCachingViewResolver implements Ordered {\n\n\t/**\n\t * Prefix for special view names that specify a redirect URL (usually\n\t * to a controller after a form has been submitted and processed).\n\t * Such view names will not be resolved in the configured default\n\t * way but rather be treated as special shortcut.\n\t */\n\tpublic static final String REDIRECT_URL_PREFIX = \"redirect:\";\n\n\t/**\n\t * Prefix for special view names that specify a forward URL (usually\n\t * to a controller after a form has been submitted and processed).\n\t * Such view names will not be resolved in the configured default\n\t * way but rather be treated as special shortcut.\n\t */\n\tpublic static final String FORWARD_URL_PREFIX = \"forward:\";\n\n\n\t@Nullable\n\tprivate Class<?> viewClass;\n\n\tprivate String prefix = \"\";\n\n\tprivate String suffix = \"\";\n\n\t@Nullable\n\tprivate String contentType;\n\n\tprivate boolean redirectContextRelative = true;\n\n\tprivate boolean redirectHttp10Compatible = true;\n\n\t@Nullable\n\tprivate String[] redirectHosts;\n\n\t@Nullable\n\tprivate String requestContextAttribute;\n\n\t/** Map of static attributes, keyed by attribute name (String). */\n\tprivate final Map<String, Object> staticAttributes = new HashMap<>();\n\n\t@Nullable\n\tprivate Boolean exposePathVariables;\n\n\t@Nullable\n\tprivate Boolean exposeContextBeansAsAttributes;\n\n\t@Nullable\n\tprivate String[] exposedContextBeanNames;\n\n\t@Nullable\n\tprivate String[] viewNames;\n\n\tprivate int order = Ordered.LOWEST_PRECEDENCE;\n\n\n\t/**\n\t * Set the view class that should be used to create views.\n\t * @param viewClass a class that is assignable to the required view class\n\t * (by default: AbstractUrlBasedView)\n\t * @see #requiredViewClass()\n\t * @see #instantiateView()\n\t * @see AbstractUrlBasedView\n\t */\n\tpublic void setViewClass(@Nullable Class<?> viewClass) {\n\t\tif (viewClass != null && !requiredViewClass().isAssignableFrom(viewClass)) {\n\t\t\tthrow new IllegalArgumentException(\"Given view class [\" + viewClass.getName() +\n\t\t\t\t\t\"] is not of type [\" + requiredViewClass().getName() + \"]\");\n\t\t}\n\t\tthis.viewClass = viewClass;\n\t}\n\n\t/**\n\t * Return the view class to be used to create views.\n\t * @see #setViewClass\n\t */\n\t@Nullable\n\tprotected Class<?> getViewClass() {\n\t\treturn this.viewClass;\n\t}\n\n\t/**\n\t * Set the prefix that gets prepended to view names when building a URL.\n\t */\n\tpublic void setPrefix(@Nullable String prefix) {\n\t\tthis.prefix = (prefix != null ? prefix : \"\");\n\t}\n\n\t/**\n\t * Return the prefix that gets prepended to view names when building a URL.\n\t */\n\tprotected String getPrefix() {\n\t\treturn this.prefix;\n\t}\n\n\t/**\n\t * Set the suffix that gets appended to view names when building a URL.\n\t */\n\tpublic void setSuffix(@Nullable String suffix) {\n\t\tthis.suffix = (suffix != null ? suffix : \"\");\n\t}\n\n\t/**\n\t * Return the suffix that gets appended to view names when building a URL.\n\t */\n\tprotected String getSuffix() {\n\t\treturn this.suffix;\n\t}\n\n\t/**\n\t * Set the content type for all views.\n\t * <p>May be ignored by view classes if the view itself is assumed\n\t * to set the content type, e.g. in case of JSPs.\n\t */\n\tpublic void setContentType(@Nullable String contentType) {\n\t\tthis.contentType = contentType;\n\t}\n\n\t/**\n\t * Return the content type for all views, if any.\n\t */\n\t@Nullable\n\tprotected String getContentType() {\n\t\treturn this.contentType;\n\t}\n\n\t/**\n\t * Set whether to interpret a given redirect URL that starts with a\n\t * slash (\"/\") as relative to the current ServletContext, i.e. as\n\t * relative to the web application root.\n\t * <p>Default is \"true\": A redirect URL that starts with a slash will be\n\t * interpreted as relative to the web application root, i.e. the context\n\t * path will be prepended to the URL.\n\t * <p><b>Redirect URLs can be specified via the \"redirect:\" prefix.</b>\n\t * E.g.: \"redirect:myAction\"\n\t * @see RedirectView#setContextRelative\n\t * @see #REDIRECT_URL_PREFIX\n\t */\n\tpublic void setRedirectContextRelative(boolean redirectContextRelative) {\n\t\tthis.redirectContextRelative = redirectContextRelative;\n\t}\n\n\t/**\n\t * Return whether to interpret a given redirect URL that starts with a\n\t * slash (\"/\") as relative to the current ServletContext, i.e. as\n\t * relative to the web application root.\n\t */\n\tprotected boolean isRedirectContextRelative() {\n\t\treturn this.redirectContextRelative;\n\t}\n\n\t/**\n\t * Set whether redirects should stay compatible with HTTP 1.0 clients.\n\t * <p>In the default implementation, this will enforce HTTP status code 302\n\t * in any case, i.e. delegate to {@code HttpServletResponse.sendRedirect}.\n\t * Turning this off will send HTTP status code 303, which is the correct\n\t * code for HTTP 1.1 clients, but not understood by HTTP 1.0 clients.\n\t * <p>Many HTTP 1.1 clients treat 302 just like 303, not making any\n\t * difference. However, some clients depend on 303 when redirecting\n\t * after a POST request; turn this flag off in such a scenario.\n\t * <p><b>Redirect URLs can be specified via the \"redirect:\" prefix.</b>\n\t * E.g.: \"redirect:myAction\"\n\t * @see RedirectView#setHttp10Compatible\n\t * @see #REDIRECT_URL_PREFIX\n\t */\n\tpublic void setRedirectHttp10Compatible(boolean redirectHttp10Compatible) {\n\t\tthis.redirectHttp10Compatible = redirectHttp10Compatible;\n\t}\n\n\t/**\n\t * Return whether redirects should stay compatible with HTTP 1.0 clients.\n\t */\n\tprotected boolean isRedirectHttp10Compatible() {\n\t\treturn this.redirectHttp10Compatible;\n\t}\n\n\t/**\n\t * Configure one or more hosts associated with the application.\n\t * All other hosts will be considered external hosts.\n\t * <p>In effect, this property provides a way turn off encoding on redirect\n\t * via {@link HttpServletResponse#encodeRedirectURL} for URLs that have a\n\t * host and that host is not listed as a known host.\n\t * <p>If not set (the default) all URLs are encoded through the response.\n\t * @param redirectHosts one or more application hosts\n\t * @since 4.3\n\t */\n\tpublic void setRedirectHosts(@Nullable String... redirectHosts) {\n\t\tthis.redirectHosts = redirectHosts;\n\t}\n\n\t/**\n\t * Return the configured application hosts for redirect purposes.\n\t * @since 4.3\n\t */\n\t@Nullable\n\tpublic String[] getRedirectHosts() {\n\t\treturn this.redirectHosts;\n\t}\n\n\t/**\n\t * Set the name of the RequestContext attribute for all views.\n\t * @param requestContextAttribute name of the RequestContext attribute\n\t * @see AbstractView#setRequestContextAttribute\n\t */\n\tpublic void setRequestContextAttribute(@Nullable String requestContextAttribute) {\n\t\tthis.requestContextAttribute = requestContextAttribute;\n\t}\n\n\t/**\n\t * Return the name of the RequestContext attribute for all views, if any.\n\t */\n\t@Nullable\n\tprotected String getRequestContextAttribute() {\n\t\treturn this.requestContextAttribute;\n\t}\n\n\t/**\n\t * Set static attributes from a {@code java.util.Properties} object,\n\t * for all views returned by this resolver.\n\t * <p>This is the most convenient way to set static attributes. Note that\n\t * static attributes can be overridden by dynamic attributes, if a value\n\t * with the same name is included in the model.\n\t * <p>Can be populated with a String \"value\" (parsed via PropertiesEditor)\n\t * or a \"props\" element in XML bean definitions.\n\t * @see org.springframework.beans.propertyeditors.PropertiesEditor\n\t * @see AbstractView#setAttributes\n\t */\n\tpublic void setAttributes(Properties props) {\n\t\tCollectionUtils.mergePropertiesIntoMap(props, this.staticAttributes);\n\t}\n\n\t/**\n\t * Set static attributes from a Map, for all views returned by this resolver.\n\t * This allows to set any kind of attribute values, for example bean references.\n\t * <p>Can be populated with a \"map\" or \"props\" element in XML bean definitions.\n\t * @param attributes a Map with name Strings as keys and attribute objects as values\n\t * @see AbstractView#setAttributesMap\n\t */\n\tpublic void setAttributesMap(@Nullable Map<String, ?> attributes) {\n\t\tif (attributes != null) {\n\t\t\tthis.staticAttributes.putAll(attributes);\n\t\t}\n\t}\n\n\t/**\n\t * Allow {@code Map} access to the static attributes for views returned by\n\t * this resolver, with the option to add or override specific entries.\n\t * <p>Useful for specifying entries directly, for example via\n\t * {@code attributesMap[myKey]}. This is particularly useful for\n\t * adding or overriding entries in child view definitions.\n\t */\n\tpublic Map<String, Object> getAttributesMap() {\n\t\treturn this.staticAttributes;\n\t}\n\n\t/**\n\t * Specify whether views resolved by this resolver should add path\n\t * variables to the model or not.\n\t * <p>The default setting is to let each View decide\n\t * (see {@link AbstractView#setExposePathVariables}). However, you\n\t * can use this property to override that.\n\t * @param exposePathVariables\n\t * <ul>\n\t * <li>{@code true} - all Views resolved by this resolver will expose path variables\n\t * <li>{@code false} - no Views resolved by this resolver will expose path variables\n\t * <li>{@code null} - individual Views can decide for themselves (this is used by default)\n\t * </ul>\n\t * @see AbstractView#setExposePathVariables\n\t */\n\tpublic void setExposePathVariables(@Nullable Boolean exposePathVariables) {\n\t\tthis.exposePathVariables = exposePathVariables;\n\t}\n\n\t/**\n\t * Return whether views resolved by this resolver should add path variables to the model or not.\n\t */\n\t@Nullable\n\tprotected Boolean getExposePathVariables() {\n\t\treturn this.exposePathVariables;\n\t}\n\n\t/**\n\t * Set whether to make all Spring beans in the application context accessible\n\t * as request attributes, through lazy checking once an attribute gets accessed.\n\t * <p>This will make all such beans accessible in plain {@code ${...}}\n\t * expressions in a JSP 2.0 page, as well as in JSTL's {@code c:out}\n\t * value expressions.\n\t * <p>Default is \"false\".\n\t * @see AbstractView#setExposeContextBeansAsAttributes\n\t */\n\tpublic void setExposeContextBeansAsAttributes(boolean exposeContextBeansAsAttributes) {\n\t\tthis.exposeContextBeansAsAttributes = exposeContextBeansAsAttributes;\n\t}\n\n\t@Nullable\n\tprotected Boolean getExposeContextBeansAsAttributes() {\n\t\treturn this.exposeContextBeansAsAttributes;\n\t}\n\n\t/**\n\t * Specify the names of beans in the context which are supposed to be exposed.\n\t * If this is non-null, only the specified beans are eligible for exposure as\n\t * attributes.\n\t * @see AbstractView#setExposedContextBeanNames\n\t */\n\tpublic void setExposedContextBeanNames(@Nullable String... exposedContextBeanNames) {\n\t\tthis.exposedContextBeanNames = exposedContextBeanNames;\n\t}\n\n\t@Nullable\n\tprotected String[] getExposedContextBeanNames() {\n\t\treturn this.exposedContextBeanNames;\n\t}\n\n\t/**\n\t * Set the view names (or name patterns) that can be handled by this\n\t * {@link org.springframework.web.servlet.ViewResolver}. View names can contain\n\t * simple wildcards such that 'my*', '*Report' and '*Repo*' will all match the\n\t * view name 'myReport'.\n\t * @see #canHandle\n\t */\n\tpublic void setViewNames(@Nullable String... viewNames) {\n\t\tthis.viewNames = viewNames;\n\t}\n\n\t/**\n\t * Return the view names (or name patterns) that can be handled by this\n\t * {@link org.springframework.web.servlet.ViewResolver}.\n\t */\n\t@Nullable\n\tprotected String[] getViewNames() {\n\t\treturn this.viewNames;\n\t}\n\n\t/**\n\t * Specify the order value for this ViewResolver bean.\n\t * <p>The default value is {@code Ordered.LOWEST_PRECEDENCE}, meaning non-ordered.\n\t * @see org.springframework.core.Ordered#getOrder()\n\t */\n\tpublic void setOrder(int order) {\n\t\tthis.order = order;\n\t}\n\n\t@Override\n\tpublic int getOrder() {\n\t\treturn this.order;\n\t}\n\n\t@Override\n\tprotected void initApplicationContext() {\n\t\tsuper.initApplicationContext();\n\t\tif (getViewClass() == null) {\n\t\t\tthrow new IllegalArgumentException(\"Property 'viewClass' is required\");\n\t\t}\n\t}\n\n\n\t/**\n\t * This implementation returns just the view name,\n\t * as this ViewResolver doesn't support localized resolution.\n\t */\n\t@Override\n\tprotected Object getCacheKey(String viewName, Locale locale) {\n\t\treturn viewName;\n\t}\n\n\t/**\n\t * Overridden to implement check for \"redirect:\" prefix.\n\t * <p>Not possible in {@code loadView}, since overridden\n\t * {@code loadView} versions in subclasses might rely on the\n\t * superclass always creating instances of the required view class.\n\t * @see #loadView\n\t * @see #requiredViewClass\n\t */\n\t@Override\n\tprotected View createView(String viewName, Locale locale) throws Exception {\n\t\t// If this resolver is not supposed to handle the given view,\n\t\t// return null to pass on to the next resolver in the chain.\n\t\tif (!canHandle(viewName, locale)) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Check for special \"redirect:\" prefix.\n\t\tif (viewName.startsWith(REDIRECT_URL_PREFIX)) {\n\t\t\tString redirectUrl = viewName.substring(REDIRECT_URL_PREFIX.length());\n\t\t\tRedirectView view = new RedirectView(redirectUrl,\n\t\t\t\t\tisRedirectContextRelative(), isRedirectHttp10Compatible());\n\t\t\tString[] hosts = getRedirectHosts();\n\t\t\tif (hosts != null) {\n\t\t\t\tview.setHosts(hosts);\n\t\t\t}\n\t\t\treturn applyLifecycleMethods(REDIRECT_URL_PREFIX, view);\n\t\t}\n\n\t\t// Check for special \"forward:\" prefix.\n\t\tif (viewName.startsWith(FORWARD_URL_PREFIX)) {\n\t\t\tString forwardUrl = viewName.substring(FORWARD_URL_PREFIX.length());\n\t\t\tInternalResourceView view = new InternalResourceView(forwardUrl);\n\t\t\treturn applyLifecycleMethods(FORWARD_URL_PREFIX, view);\n\t\t}\n\n\t\t// Else fall back to superclass implementation: calling loadView.\n\t\treturn super.createView(viewName, locale);\n\t}\n\n\t/**\n\t * Indicates whether this {@link org.springframework.web.servlet.ViewResolver} can\n\t * handle the supplied view name. If not, {@link #createView(String, java.util.Locale)} will\n\t * return {@code null}. The default implementation checks against the configured\n\t * {@link #setViewNames view names}.\n\t * @param viewName the name of the view to retrieve\n\t * @param locale the Locale to retrieve the view for\n\t * @return whether this resolver applies to the specified view\n\t * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)\n\t */\n\tprotected boolean canHandle(String viewName, Locale locale) {\n\t\tString[] viewNames = getViewNames();\n\t\treturn (viewNames == null || PatternMatchUtils.simpleMatch(viewNames, viewName));\n\t}\n\n\t/**\n\t * Return the required type of view for this resolver.\n\t * This implementation returns {@link AbstractUrlBasedView}.\n\t * @see #instantiateView()\n\t * @see AbstractUrlBasedView\n\t */\n\tprotected Class<?> requiredViewClass() {\n\t\treturn AbstractUrlBasedView.class;\n\t}\n\n\t/**\n\t * Instantiate the specified view class.\n\t * <p>The default implementation uses reflection to instantiate the class.\n\t * @return a new instance of the view class\n\t * @since 5.3\n\t * @see #setViewClass\n\t */\n\tprotected AbstractUrlBasedView instantiateView() {\n\t\tClass<?> viewClass = getViewClass();\n\t\tAssert.state(viewClass != null, \"No view class\");\n\t\treturn (AbstractUrlBasedView) BeanUtils.instantiateClass(viewClass);\n\t}\n\n\t/**\n\t * Delegates to {@code buildView} for creating a new instance of the\n\t * specified view class. Applies the following Spring lifecycle methods\n\t * (as supported by the generic Spring bean factory):\n\t * <ul>\n\t * <li>ApplicationContextAware's {@code setApplicationContext}\n\t * <li>InitializingBean's {@code afterPropertiesSet}\n\t * </ul>\n\t * @param viewName the name of the view to retrieve\n\t * @return the View instance\n\t * @throws Exception if the view couldn't be resolved\n\t * @see #buildView(String)\n\t * @see org.springframework.context.ApplicationContextAware#setApplicationContext\n\t * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet\n\t */\n\t@Override\n\tprotected View loadView(String viewName, Locale locale) throws Exception {\n\t\tAbstractUrlBasedView view = buildView(viewName);\n\t\tView result = applyLifecycleMethods(viewName, view);\n\t\treturn (view.checkResource(locale) ? result : null);\n\t}\n\n\t/**\n\t * Creates a new View instance of the specified view class and configures it.\n\t * Does <i>not</i> perform any lookup for pre-defined View instances.\n\t * <p>Spring lifecycle methods as defined by the bean container do not have to\n\t * be called here; those will be applied by the {@code loadView} method\n\t * after this method returns.\n\t * <p>Subclasses will typically call {@code super.buildView(viewName)}\n\t * first, before setting further properties themselves. {@code loadView}\n\t * will then apply Spring lifecycle methods at the end of this process.\n\t * @param viewName the name of the view to build\n\t * @return the View instance\n\t * @throws Exception if the view couldn't be resolved\n\t * @see #loadView(String, java.util.Locale)\n\t */\n\tprotected AbstractUrlBasedView buildView(String viewName) throws Exception {\n\t\tAbstractUrlBasedView view = instantiateView();\n\t\tview.setUrl(getPrefix() + viewName + getSuffix());\n\t\tview.setAttributesMap(getAttributesMap());\n\n\t\tString contentType = getContentType();\n\t\tif (contentType != null) {\n\t\t\tview.setContentType(contentType);\n\t\t}\n\n\t\tString requestContextAttribute = getRequestContextAttribute();\n\t\tif (requestContextAttribute != null) {\n\t\t\tview.setRequestContextAttribute(requestContextAttribute);\n\t\t}\n\n\t\tBoolean exposePathVariables = getExposePathVariables();\n\t\tif (exposePathVariables != null) {\n\t\t\tview.setExposePathVariables(exposePathVariables);\n\t\t}\n\t\tBoolean exposeContextBeansAsAttributes = getExposeContextBeansAsAttributes();\n\t\tif (exposeContextBeansAsAttributes != null) {\n\t\t\tview.setExposeContextBeansAsAttributes(exposeContextBeansAsAttributes);\n\t\t}\n\t\tString[] exposedContextBeanNames = getExposedContextBeanNames();\n\t\tif (exposedContextBeanNames != null) {\n\t\t\tview.setExposedContextBeanNames(exposedContextBeanNames);\n\t\t}\n\n\t\treturn view;\n\t}\n\n\t/**\n\t * Apply the containing {@link ApplicationContext}'s lifecycle methods\n\t * to the given {@link View} instance, if such a context is available.\n\t * @param viewName the name of the view\n\t * @param view the freshly created View instance, pre-configured with\n\t * {@link AbstractUrlBasedView}'s properties\n\t * @return the {@link View} instance to use (either the original one\n\t * or a decorated variant)\n\t * @since 5.0\n\t * @see #getApplicationContext()\n\t * @see ApplicationContext#getAutowireCapableBeanFactory()\n\t * @see org.springframework.beans.factory.config.AutowireCapableBeanFactory#initializeBean\n\t */\n\tprotected View applyLifecycleMethods(String viewName, AbstractUrlBasedView view) {\n\t\tApplicationContext context = getApplicationContext();\n\t\tif (context != null) {\n\t\t\tObject initialized = context.getAutowireCapableBeanFactory().initializeBean(view, viewName);\n\t\t\tif (initialized instanceof View initializedView) {\n\t\t\t\treturn initializedView;\n\t\t\t}\n\t\t}\n\t\treturn view;\n\t}\n\n}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#applyLifecycleMethods(viewName,view)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the containing {@link ApplicationContext}'s lifecycle methods\n\t * to the given {@link View} instance, if such a context is available.\n\t * @param viewName the name of the view\n\t * @param view the freshly created View instance, pre-configured with\n\t * {@link AbstractUrlBasedView}'s properties\n\t * @return the {@link View} instance to use (either the original one\n\t * or a decorated variant)\n\t * @since 5.0\n\t * @see #getApplicationContext()\n\t * @see ApplicationContext#getAutowireCapableBeanFactory()\n\t * @see org.springframework.beans.factory.config.AutowireCapableBeanFactory#initializeBean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "view"
    ],
    "position": {
      "column": 1,
      "line": 612
    },
    "return": "View",
    "signature": "protected View applyLifecycleMethods(String viewName, AbstractUrlBasedView view)",
    "source_code": "\tprotected View applyLifecycleMethods(String viewName, AbstractUrlBasedView view) {\n\t\tApplicationContext context = getApplicationContext();\n\t\tif (context != null) {\n\t\t\tObject initialized = context.getAutowireCapableBeanFactory().initializeBean(view, viewName);\n\t\t\tif (initialized instanceof View initializedView) {\n\t\t\t\treturn initializedView;\n\t\t\t}\n\t\t}\n\t\treturn view;\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#buildView(viewName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Creates a new View instance of the specified view class and configures it.\n\t * Does <i>not</i> perform any lookup for pre-defined View instances.\n\t * <p>Spring lifecycle methods as defined by the bean container do not have to\n\t * be called here; those will be applied by the {@code loadView} method\n\t * after this method returns.\n\t * <p>Subclasses will typically call {@code super.buildView(viewName)}\n\t * first, before setting further properties themselves. {@code loadView}\n\t * will then apply Spring lifecycle methods at the end of this process.\n\t * @param viewName the name of the view to build\n\t * @return the View instance\n\t * @throws Exception if the view couldn't be resolved\n\t * @see #loadView(String, java.util.Locale)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName"
    ],
    "position": {
      "column": 1,
      "line": 568
    },
    "return": "AbstractUrlBasedView",
    "signature": "protected AbstractUrlBasedView buildView(String viewName)",
    "source_code": "\tprotected AbstractUrlBasedView buildView(String viewName) throws Exception {\n\t\tAbstractUrlBasedView view = instantiateView();\n\t\tview.setUrl(getPrefix() + viewName + getSuffix());\n\t\tview.setAttributesMap(getAttributesMap());\n\n\t\tString contentType = getContentType();\n\t\tif (contentType != null) {\n\t\t\tview.setContentType(contentType);\n\t\t}\n\n\t\tString requestContextAttribute = getRequestContextAttribute();\n\t\tif (requestContextAttribute != null) {\n\t\t\tview.setRequestContextAttribute(requestContextAttribute);\n\t\t}\n\n\t\tBoolean exposePathVariables = getExposePathVariables();\n\t\tif (exposePathVariables != null) {\n\t\t\tview.setExposePathVariables(exposePathVariables);\n\t\t}\n\t\tBoolean exposeContextBeansAsAttributes = getExposeContextBeansAsAttributes();\n\t\tif (exposeContextBeansAsAttributes != null) {\n\t\t\tview.setExposeContextBeansAsAttributes(exposeContextBeansAsAttributes);\n\t\t}\n\t\tString[] exposedContextBeanNames = getExposedContextBeanNames();\n\t\tif (exposedContextBeanNames != null) {\n\t\t\tview.setExposedContextBeanNames(exposedContextBeanNames);\n\t\t}\n\n\t\treturn view;\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#canHandle(viewName,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Indicates whether this {@link org.springframework.web.servlet.ViewResolver} can\n\t * handle the supplied view name. If not, {@link #createView(String, java.util.Locale)} will\n\t * return {@code null}. The default implementation checks against the configured\n\t * {@link #setViewNames view names}.\n\t * @param viewName the name of the view to retrieve\n\t * @param locale the Locale to retrieve the view for\n\t * @return whether this resolver applies to the specified view\n\t * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 504
    },
    "return": "boolean",
    "signature": "protected boolean canHandle(String viewName, Locale locale)",
    "source_code": "\tprotected boolean canHandle(String viewName, Locale locale) {\n\t\tString[] viewNames = getViewNames();\n\t\treturn (viewNames == null || PatternMatchUtils.simpleMatch(viewNames, viewName));\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#createView(viewName,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Overridden to implement check for \"redirect:\" prefix.\n\t * <p>Not possible in {@code loadView}, since overridden\n\t * {@code loadView} versions in subclasses might rely on the\n\t * superclass always creating instances of the required view class.\n\t * @see #loadView\n\t * @see #requiredViewClass\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 464
    },
    "return": "View",
    "signature": "protected View createView(String viewName, Locale locale)",
    "source_code": "\tprotected View createView(String viewName, Locale locale) throws Exception {\n\t\t// If this resolver is not supposed to handle the given view,\n\t\t// return null to pass on to the next resolver in the chain.\n\t\tif (!canHandle(viewName, locale)) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Check for special \"redirect:\" prefix.\n\t\tif (viewName.startsWith(REDIRECT_URL_PREFIX)) {\n\t\t\tString redirectUrl = viewName.substring(REDIRECT_URL_PREFIX.length());\n\t\t\tRedirectView view = new RedirectView(redirectUrl,\n\t\t\t\t\tisRedirectContextRelative(), isRedirectHttp10Compatible());\n\t\t\tString[] hosts = getRedirectHosts();\n\t\t\tif (hosts != null) {\n\t\t\t\tview.setHosts(hosts);\n\t\t\t}\n\t\t\treturn applyLifecycleMethods(REDIRECT_URL_PREFIX, view);\n\t\t}\n\n\t\t// Check for special \"forward:\" prefix.\n\t\tif (viewName.startsWith(FORWARD_URL_PREFIX)) {\n\t\t\tString forwardUrl = viewName.substring(FORWARD_URL_PREFIX.length());\n\t\t\tInternalResourceView view = new InternalResourceView(forwardUrl);\n\t\t\treturn applyLifecycleMethods(FORWARD_URL_PREFIX, view);\n\t\t}\n\n\t\t// Else fall back to superclass implementation: calling loadView.\n\t\treturn super.createView(viewName, locale);\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#getAttributesMap()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Allow {@code Map} access to the static attributes for views returned by\n\t * this resolver, with the option to add or override specific entries.\n\t * <p>Useful for specifying entries directly, for example via\n\t * {@code attributesMap[myKey]}. This is particularly useful for\n\t * adding or overriding entries in child view definitions.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 340
    },
    "return": "Object>",
    "signature": "public Object> getAttributesMap()",
    "source_code": "\tpublic Map<String, Object> getAttributesMap() {\n\t\treturn this.staticAttributes;\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#getCacheKey(viewName,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns just the view name,\n\t * as this ViewResolver doesn't support localized resolution.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 451
    },
    "return": "Object",
    "signature": "protected Object getCacheKey(String viewName, Locale locale)",
    "source_code": "\tprotected Object getCacheKey(String viewName, Locale locale) {\n\t\treturn viewName;\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#getContentType()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the content type for all views, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "String",
    "signature": "protected String getContentType()",
    "source_code": "\tprotected String getContentType() {\n\t\treturn this.contentType;\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#getExposeContextBeansAsAttributes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "Boolean",
    "signature": "protected Boolean getExposeContextBeansAsAttributes()",
    "source_code": "\tprotected Boolean getExposeContextBeansAsAttributes() {\n\t\treturn this.exposeContextBeansAsAttributes;\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#getExposePathVariables()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether views resolved by this resolver should add path variables to the model or not.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 366
    },
    "return": "Boolean",
    "signature": "protected Boolean getExposePathVariables()",
    "source_code": "\tprotected Boolean getExposePathVariables() {\n\t\treturn this.exposePathVariables;\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#getExposedContextBeanNames()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 399
    },
    "return": "String[]",
    "signature": "protected String[] getExposedContextBeanNames()",
    "source_code": "\tprotected String[] getExposedContextBeanNames() {\n\t\treturn this.exposedContextBeanNames;\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#getOrder()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 433
    },
    "return": "int",
    "signature": "public int getOrder()",
    "source_code": "\tpublic int getOrder() {\n\t\treturn this.order;\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#getPrefix()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the prefix that gets prepended to view names when building a URL.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "String",
    "signature": "protected String getPrefix()",
    "source_code": "\tprotected String getPrefix() {\n\t\treturn this.prefix;\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#getRedirectHosts()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured application hosts for redirect purposes.\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "String[]",
    "signature": "public String[] getRedirectHosts()",
    "source_code": "\tpublic String[] getRedirectHosts() {\n\t\treturn this.redirectHosts;\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#getRequestContextAttribute()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the name of the RequestContext attribute for all views, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 301
    },
    "return": "String",
    "signature": "protected String getRequestContextAttribute()",
    "source_code": "\tprotected String getRequestContextAttribute() {\n\t\treturn this.requestContextAttribute;\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#getSuffix()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the suffix that gets appended to view names when building a URL.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "String",
    "signature": "protected String getSuffix()",
    "source_code": "\tprotected String getSuffix() {\n\t\treturn this.suffix;\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#getViewNames()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the view names (or name patterns) that can be handled by this\n\t * {@link org.springframework.web.servlet.ViewResolver}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 419
    },
    "return": "String[]",
    "signature": "protected String[] getViewNames()",
    "source_code": "\tprotected String[] getViewNames() {\n\t\treturn this.viewNames;\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#initApplicationContext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 438
    },
    "return": "void",
    "signature": "protected void initApplicationContext()",
    "source_code": "\tprotected void initApplicationContext() {\n\t\tsuper.initApplicationContext();\n\t\tif (getViewClass() == null) {\n\t\t\tthrow new IllegalArgumentException(\"Property 'viewClass' is required\");\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#instantiateView()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Instantiate the specified view class.\n\t * <p>The default implementation uses reflection to instantiate the class.\n\t * @return a new instance of the view class\n\t * @since 5.3\n\t * @see #setViewClass\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 526
    },
    "return": "AbstractUrlBasedView",
    "signature": "protected AbstractUrlBasedView instantiateView()",
    "source_code": "\tprotected AbstractUrlBasedView instantiateView() {\n\t\tClass<?> viewClass = getViewClass();\n\t\tAssert.state(viewClass != null, \"No view class\");\n\t\treturn (AbstractUrlBasedView) BeanUtils.instantiateClass(viewClass);\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#isRedirectContextRelative()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether to interpret a given redirect URL that starts with a\n\t * slash (\"/\") as relative to the current ServletContext, i.e. as\n\t * relative to the web application root.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "boolean",
    "signature": "protected boolean isRedirectContextRelative()",
    "source_code": "\tprotected boolean isRedirectContextRelative() {\n\t\treturn this.redirectContextRelative;\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#isRedirectHttp10Compatible()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether redirects should stay compatible with HTTP 1.0 clients.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "boolean",
    "signature": "protected boolean isRedirectHttp10Compatible()",
    "source_code": "\tprotected boolean isRedirectHttp10Compatible() {\n\t\treturn this.redirectHttp10Compatible;\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#loadView(viewName,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@code buildView} for creating a new instance of the\n\t * specified view class. Applies the following Spring lifecycle methods\n\t * (as supported by the generic Spring bean factory):\n\t * <ul>\n\t * <li>ApplicationContextAware's {@code setApplicationContext}\n\t * <li>InitializingBean's {@code afterPropertiesSet}\n\t * </ul>\n\t * @param viewName the name of the view to retrieve\n\t * @return the View instance\n\t * @throws Exception if the view couldn't be resolved\n\t * @see #buildView(String)\n\t * @see org.springframework.context.ApplicationContextAware#setApplicationContext\n\t * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 548
    },
    "return": "View",
    "signature": "protected View loadView(String viewName, Locale locale)",
    "source_code": "\tprotected View loadView(String viewName, Locale locale) throws Exception {\n\t\tAbstractUrlBasedView view = buildView(viewName);\n\t\tView result = applyLifecycleMethods(viewName, view);\n\t\treturn (view.checkResource(locale) ? result : null);\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#setAttributes(props)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set static attributes from a {@code java.util.Properties} object,\n\t * for all views returned by this resolver.\n\t * <p>This is the most convenient way to set static attributes. Note that\n\t * static attributes can be overridden by dynamic attributes, if a value\n\t * with the same name is included in the model.\n\t * <p>Can be populated with a String \"value\" (parsed via PropertiesEditor)\n\t * or a \"props\" element in XML bean definitions.\n\t * @see org.springframework.beans.propertyeditors.PropertiesEditor\n\t * @see AbstractView#setAttributes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "props"
    ],
    "position": {
      "column": 1,
      "line": 316
    },
    "return": "void",
    "signature": "public void setAttributes(Properties props)",
    "source_code": "\tpublic void setAttributes(Properties props) {\n\t\tCollectionUtils.mergePropertiesIntoMap(props, this.staticAttributes);\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#setAttributesMap(Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set static attributes from a Map, for all views returned by this resolver.\n\t * This allows to set any kind of attribute values, for example bean references.\n\t * <p>Can be populated with a \"map\" or \"props\" element in XML bean definitions.\n\t * @param attributes a Map with name Strings as keys and attribute objects as values\n\t * @see AbstractView#setAttributesMap\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 327
    },
    "return": "void",
    "signature": "public void setAttributesMap(@Nullable Map<String, ?> attributes)",
    "source_code": "\tpublic void setAttributesMap(@Nullable Map<String, ?> attributes) {\n\t\tif (attributes != null) {\n\t\t\tthis.staticAttributes.putAll(attributes);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#setContentType(contentType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the content type for all views.\n\t * <p>May be ignored by view classes if the view itself is assumed\n\t * to set the content type, e.g. in case of JSPs.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "void",
    "signature": "public void setContentType(@Nullable String contentType)",
    "source_code": "\tpublic void setContentType(@Nullable String contentType) {\n\t\tthis.contentType = contentType;\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#setExposeContextBeansAsAttributes(exposeContextBeansAsAttributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to make all Spring beans in the application context accessible\n\t * as request attributes, through lazy checking once an attribute gets accessed.\n\t * <p>This will make all such beans accessible in plain {@code ${...}}\n\t * expressions in a JSP 2.0 page, as well as in JSTL's {@code c:out}\n\t * value expressions.\n\t * <p>Default is \"false\".\n\t * @see AbstractView#setExposeContextBeansAsAttributes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exposeContextBeansAsAttributes"
    ],
    "position": {
      "column": 1,
      "line": 379
    },
    "return": "void",
    "signature": "public void setExposeContextBeansAsAttributes(boolean exposeContextBeansAsAttributes)",
    "source_code": "\tpublic void setExposeContextBeansAsAttributes(boolean exposeContextBeansAsAttributes) {\n\t\tthis.exposeContextBeansAsAttributes = exposeContextBeansAsAttributes;\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#setExposePathVariables(exposePathVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether views resolved by this resolver should add path\n\t * variables to the model or not.\n\t * <p>The default setting is to let each View decide\n\t * (see {@link AbstractView#setExposePathVariables}). However, you\n\t * can use this property to override that.\n\t * @param exposePathVariables\n\t * <ul>\n\t * <li>{@code true} - all Views resolved by this resolver will expose path variables\n\t * <li>{@code false} - no Views resolved by this resolver will expose path variables\n\t * <li>{@code null} - individual Views can decide for themselves (this is used by default)\n\t * </ul>\n\t * @see AbstractView#setExposePathVariables\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exposePathVariables"
    ],
    "position": {
      "column": 1,
      "line": 358
    },
    "return": "void",
    "signature": "public void setExposePathVariables(@Nullable Boolean exposePathVariables)",
    "source_code": "\tpublic void setExposePathVariables(@Nullable Boolean exposePathVariables) {\n\t\tthis.exposePathVariables = exposePathVariables;\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#setExposedContextBeanNames(exposedContextBeanNames)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the names of beans in the context which are supposed to be exposed.\n\t * If this is non-null, only the specified beans are eligible for exposure as\n\t * attributes.\n\t * @see AbstractView#setExposedContextBeanNames\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exposedContextBeanNames"
    ],
    "position": {
      "column": 1,
      "line": 394
    },
    "return": "void",
    "signature": "public void setExposedContextBeanNames(@Nullable String... exposedContextBeanNames)",
    "source_code": "\tpublic void setExposedContextBeanNames(@Nullable String... exposedContextBeanNames) {\n\t\tthis.exposedContextBeanNames = exposedContextBeanNames;\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#setOrder(order)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the order value for this ViewResolver bean.\n\t * <p>The default value is {@code Ordered.LOWEST_PRECEDENCE}, meaning non-ordered.\n\t * @see org.springframework.core.Ordered#getOrder()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "order"
    ],
    "position": {
      "column": 1,
      "line": 428
    },
    "return": "void",
    "signature": "public void setOrder(int order)",
    "source_code": "\tpublic void setOrder(int order) {\n\t\tthis.order = order;\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#setPrefix(prefix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the prefix that gets prepended to view names when building a URL.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "prefix"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "void",
    "signature": "public void setPrefix(@Nullable String prefix)",
    "source_code": "\tpublic void setPrefix(@Nullable String prefix) {\n\t\tthis.prefix = (prefix != null ? prefix : \"\");\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#setRedirectContextRelative(redirectContextRelative)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to interpret a given redirect URL that starts with a\n\t * slash (\"/\") as relative to the current ServletContext, i.e. as\n\t * relative to the web application root.\n\t * <p>Default is \"true\": A redirect URL that starts with a slash will be\n\t * interpreted as relative to the web application root, i.e. the context\n\t * path will be prepended to the URL.\n\t * <p><b>Redirect URLs can be specified via the \"redirect:\" prefix.</b>\n\t * E.g.: \"redirect:myAction\"\n\t * @see RedirectView#setContextRelative\n\t * @see #REDIRECT_URL_PREFIX\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "redirectContextRelative"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "void",
    "signature": "public void setRedirectContextRelative(boolean redirectContextRelative)",
    "source_code": "\tpublic void setRedirectContextRelative(boolean redirectContextRelative) {\n\t\tthis.redirectContextRelative = redirectContextRelative;\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#setRedirectHosts(redirectHosts)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure one or more hosts associated with the application.\n\t * All other hosts will be considered external hosts.\n\t * <p>In effect, this property provides a way turn off encoding on redirect\n\t * via {@link HttpServletResponse#encodeRedirectURL} for URLs that have a\n\t * host and that host is not listed as a known host.\n\t * <p>If not set (the default) all URLs are encoded through the response.\n\t * @param redirectHosts one or more application hosts\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "redirectHosts"
    ],
    "position": {
      "column": 1,
      "line": 275
    },
    "return": "void",
    "signature": "public void setRedirectHosts(@Nullable String... redirectHosts)",
    "source_code": "\tpublic void setRedirectHosts(@Nullable String... redirectHosts) {\n\t\tthis.redirectHosts = redirectHosts;\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#setRedirectHttp10Compatible(redirectHttp10Compatible)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether redirects should stay compatible with HTTP 1.0 clients.\n\t * <p>In the default implementation, this will enforce HTTP status code 302\n\t * in any case, i.e. delegate to {@code HttpServletResponse.sendRedirect}.\n\t * Turning this off will send HTTP status code 303, which is the correct\n\t * code for HTTP 1.1 clients, but not understood by HTTP 1.0 clients.\n\t * <p>Many HTTP 1.1 clients treat 302 just like 303, not making any\n\t * difference. However, some clients depend on 303 when redirecting\n\t * after a POST request; turn this flag off in such a scenario.\n\t * <p><b>Redirect URLs can be specified via the \"redirect:\" prefix.</b>\n\t * E.g.: \"redirect:myAction\"\n\t * @see RedirectView#setHttp10Compatible\n\t * @see #REDIRECT_URL_PREFIX\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "redirectHttp10Compatible"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "void",
    "signature": "public void setRedirectHttp10Compatible(boolean redirectHttp10Compatible)",
    "source_code": "\tpublic void setRedirectHttp10Compatible(boolean redirectHttp10Compatible) {\n\t\tthis.redirectHttp10Compatible = redirectHttp10Compatible;\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#setRequestContextAttribute(requestContextAttribute)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of the RequestContext attribute for all views.\n\t * @param requestContextAttribute name of the RequestContext attribute\n\t * @see AbstractView#setRequestContextAttribute\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestContextAttribute"
    ],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "void",
    "signature": "public void setRequestContextAttribute(@Nullable String requestContextAttribute)",
    "source_code": "\tpublic void setRequestContextAttribute(@Nullable String requestContextAttribute) {\n\t\tthis.requestContextAttribute = requestContextAttribute;\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#setSuffix(suffix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the suffix that gets appended to view names when building a URL.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "suffix"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "void",
    "signature": "public void setSuffix(@Nullable String suffix)",
    "source_code": "\tpublic void setSuffix(@Nullable String suffix) {\n\t\tthis.suffix = (suffix != null ? suffix : \"\");\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#setViewClass(viewClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the view class that should be used to create views.\n\t * @param viewClass a class that is assignable to the required view class\n\t * (by default: AbstractUrlBasedView)\n\t * @see #requiredViewClass()\n\t * @see #instantiateView()\n\t * @see AbstractUrlBasedView\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "viewClass"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "void",
    "signature": "public void setViewClass(@Nullable Class<?> viewClass)",
    "source_code": "\tpublic void setViewClass(@Nullable Class<?> viewClass) {\n\t\tif (viewClass != null && !requiredViewClass().isAssignableFrom(viewClass)) {\n\t\t\tthrow new IllegalArgumentException(\"Given view class [\" + viewClass.getName() +\n\t\t\t\t\t\"] is not of type [\" + requiredViewClass().getName() + \"]\");\n\t\t}\n\t\tthis.viewClass = viewClass;\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#setViewNames(viewNames)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the view names (or name patterns) that can be handled by this\n\t * {@link org.springframework.web.servlet.ViewResolver}. View names can contain\n\t * simple wildcards such that 'my*', '*Report' and '*Repo*' will all match the\n\t * view name 'myReport'.\n\t * @see #canHandle\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "viewNames"
    ],
    "position": {
      "column": 1,
      "line": 410
    },
    "return": "void",
    "signature": "public void setViewNames(@Nullable String... viewNames)",
    "source_code": "\tpublic void setViewNames(@Nullable String... viewNames) {\n\t\tthis.viewNames = viewNames;\n\t}"
  },
  "org.springframework.web.servlet.view.xml.DEFAULT_CONTENT_TYPE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Default content type. Overridable as bean property.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "signature": "public String DEFAULT_CONTENT_TYPE",
    "source_code": "\tpublic static final String DEFAULT_CONTENT_TYPE = \"application/xml\";",
    "type": "String"
  },
  "org.springframework.web.servlet.view.xml.MarshallingView": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Spring-MVC {@link View} that allows for response context to be rendered as the result\n * of marshalling by a {@link Marshaller}.\n *\n * <p>The Object to be marshalled is supplied as a parameter in the model and then\n * {@linkplain #locateToBeMarshalled(Map) detected} during response rendering. Users can\n * either specify a specific entry in the model via the {@link #setModelKey(String) sourceKey}\n * property or have Spring locate the Source object.\n *\n * @author Arjen Poutsma\n * @author Juergen Hoeller\n * @since 3.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public class MarshallingView",
    "source_code": "public class MarshallingView extends AbstractView {\n\n\t/**\n\t * Default content type. Overridable as bean property.\n\t */\n\tpublic static final String DEFAULT_CONTENT_TYPE = \"application/xml\";\n\n\n\t@Nullable\n\tprivate Marshaller marshaller;\n\n\t@Nullable\n\tprivate String modelKey;\n\n\n\t/**\n\t * Construct a new {@code MarshallingView} with no {@link Marshaller} set.\n\t * The marshaller must be set after construction by invoking {@link #setMarshaller}.\n\t */\n\tpublic MarshallingView() {\n\t\tsetContentType(DEFAULT_CONTENT_TYPE);\n\t\tsetExposePathVariables(false);\n\t}\n\n\t/**\n\t * Constructs a new {@code MarshallingView} with the given {@link Marshaller} set.\n\t */\n\tpublic MarshallingView(Marshaller marshaller) {\n\t\tthis();\n\t\tAssert.notNull(marshaller, \"Marshaller must not be null\");\n\t\tthis.marshaller = marshaller;\n\t}\n\n\n\t/**\n\t * Set the {@link Marshaller} to be used by this view.\n\t */\n\tpublic void setMarshaller(Marshaller marshaller) {\n\t\tthis.marshaller = marshaller;\n\t}\n\n\t/**\n\t * Set the name of the model key that represents the object to be marshalled.\n\t * If not specified, the model map will be searched for a supported value type.\n\t * @see Marshaller#supports(Class)\n\t */\n\tpublic void setModelKey(String modelKey) {\n\t\tthis.modelKey = modelKey;\n\t}\n\n\t@Override\n\tprotected void initApplicationContext() {\n\t\tAssert.state(this.marshaller != null, \"Property 'marshaller' is required\");\n\t}\n\n\n\t@Override\n\tprotected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,\n\t\t\tHttpServletResponse response) throws Exception {\n\n\t\tObject toBeMarshalled = locateToBeMarshalled(model);\n\t\tif (toBeMarshalled == null) {\n\t\t\tthrow new IllegalStateException(\"Unable to locate object to be marshalled in model: \" + model);\n\t\t}\n\n\t\tAssert.state(this.marshaller != null, \"No Marshaller set\");\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream(1024);\n\t\tthis.marshaller.marshal(toBeMarshalled, new StreamResult(baos));\n\n\t\tsetResponseContentType(request, response);\n\t\tresponse.setContentLength(baos.size());\n\t\tbaos.writeTo(response.getOutputStream());\n\t}\n\n\t/**\n\t * Locate the object to be marshalled.\n\t * <p>The default implementation first attempts to look under the configured\n\t * {@linkplain #setModelKey(String) model key}, if any, before attempting to\n\t * locate an object of {@linkplain Marshaller#supports(Class) supported type}.\n\t * @param model the model Map\n\t * @return the Object to be marshalled (or {@code null} if none found)\n\t * @throws IllegalStateException if the model object specified by the\n\t * {@linkplain #setModelKey(String) model key} is not supported by the marshaller\n\t * @see #setModelKey(String)\n\t */\n\t@Nullable\n\tprotected Object locateToBeMarshalled(Map<String, Object> model) throws IllegalStateException {\n\t\tif (this.modelKey != null) {\n\t\t\tObject value = model.get(this.modelKey);\n\t\t\tif (value == null) {\n\t\t\t\tthrow new IllegalStateException(\"Model contains no object with key [\" + this.modelKey + \"]\");\n\t\t\t}\n\t\t\tif (!isEligibleForMarshalling(this.modelKey, value)) {\n\t\t\t\tthrow new IllegalStateException(\"Model object [\" + value + \"] retrieved via key [\" +\n\t\t\t\t\t\tthis.modelKey + \"] is not supported by the Marshaller\");\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t\tfor (Map.Entry<String, Object> entry : model.entrySet()) {\n\t\t\tObject value = entry.getValue();\n\t\t\tif (value != null && (model.size() == 1 || !(value instanceof BindingResult)) &&\n\t\t\t\t\tisEligibleForMarshalling(entry.getKey(), value)) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Check whether the given value from the current view's model is eligible\n\t * for marshalling through the configured {@link Marshaller}.\n\t * <p>The default implementation calls {@link Marshaller#supports(Class)},\n\t * unwrapping a given {@link JAXBElement} first if applicable.\n\t * @param modelKey the value's key in the model (never {@code null})\n\t * @param value the value to check (never {@code null})\n\t * @return whether the given value is to be considered as eligible\n\t * @see Marshaller#supports(Class)\n\t */\n\tprotected boolean isEligibleForMarshalling(String modelKey, Object value) {\n\t\tAssert.state(this.marshaller != null, \"No Marshaller set\");\n\t\tClass<?> classToCheck = value.getClass();\n\t\tif (value instanceof JAXBElement<?> jaxbElement) {\n\t\t\tclassToCheck = jaxbElement.getDeclaredType();\n\t\t}\n\t\treturn this.marshaller.supports(classToCheck);\n\t}\n\n}"
  },
  "org.springframework.web.servlet.view.xml.MarshallingView#initApplicationContext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "void",
    "signature": "protected void initApplicationContext()",
    "source_code": "\tprotected void initApplicationContext() {\n\t\tAssert.state(this.marshaller != null, \"Property 'marshaller' is required\");\n\t}"
  },
  "org.springframework.web.servlet.view.xml.MarshallingView#isEligibleForMarshalling(modelKey,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given value from the current view's model is eligible\n\t * for marshalling through the configured {@link Marshaller}.\n\t * <p>The default implementation calls {@link Marshaller#supports(Class)},\n\t * unwrapping a given {@link JAXBElement} first if applicable.\n\t * @param modelKey the value's key in the model (never {@code null})\n\t * @param value the value to check (never {@code null})\n\t * @return whether the given value is to be considered as eligible\n\t * @see Marshaller#supports(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "modelKey",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "boolean",
    "signature": "protected boolean isEligibleForMarshalling(String modelKey, Object value)",
    "source_code": "\tprotected boolean isEligibleForMarshalling(String modelKey, Object value) {\n\t\tAssert.state(this.marshaller != null, \"No Marshaller set\");\n\t\tClass<?> classToCheck = value.getClass();\n\t\tif (value instanceof JAXBElement<?> jaxbElement) {\n\t\t\tclassToCheck = jaxbElement.getDeclaredType();\n\t\t}\n\t\treturn this.marshaller.supports(classToCheck);\n\t}"
  },
  "org.springframework.web.servlet.view.xml.MarshallingView#locateToBeMarshalled(Map<String,model)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Locate the object to be marshalled.\n\t * <p>The default implementation first attempts to look under the configured\n\t * {@linkplain #setModelKey(String) model key}, if any, before attempting to\n\t * locate an object of {@linkplain Marshaller#supports(Class) supported type}.\n\t * @param model the model Map\n\t * @return the Object to be marshalled (or {@code null} if none found)\n\t * @throws IllegalStateException if the model object specified by the\n\t * {@linkplain #setModelKey(String) model key} is not supported by the marshaller\n\t * @see #setModelKey(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "Object",
    "signature": "protected Object locateToBeMarshalled(Map<String, Object> model)",
    "source_code": "\tprotected Object locateToBeMarshalled(Map<String, Object> model) throws IllegalStateException {\n\t\tif (this.modelKey != null) {\n\t\t\tObject value = model.get(this.modelKey);\n\t\t\tif (value == null) {\n\t\t\t\tthrow new IllegalStateException(\"Model contains no object with key [\" + this.modelKey + \"]\");\n\t\t\t}\n\t\t\tif (!isEligibleForMarshalling(this.modelKey, value)) {\n\t\t\t\tthrow new IllegalStateException(\"Model object [\" + value + \"] retrieved via key [\" +\n\t\t\t\t\t\tthis.modelKey + \"] is not supported by the Marshaller\");\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t\tfor (Map.Entry<String, Object> entry : model.entrySet()) {\n\t\t\tObject value = entry.getValue();\n\t\t\tif (value != null && (model.size() == 1 || !(value instanceof BindingResult)) &&\n\t\t\t\t\tisEligibleForMarshalling(entry.getKey(), value)) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.view.xml.MarshallingView#renderMergedOutputModel(Map<String,model,request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "void",
    "signature": "protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,\n\t\t\tHttpServletResponse response)",
    "source_code": "\tprotected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,"
  },
  "org.springframework.web.servlet.view.xml.MarshallingView#setMarshaller(marshaller)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link Marshaller} to be used by this view.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "marshaller"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "void",
    "signature": "public void setMarshaller(Marshaller marshaller)",
    "source_code": "\tpublic void setMarshaller(Marshaller marshaller) {\n\t\tthis.marshaller = marshaller;\n\t}"
  },
  "org.springframework.web.servlet.view.xml.MarshallingView#setModelKey(modelKey)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of the model key that represents the object to be marshalled.\n\t * If not specified, the model map will be searched for a supported value type.\n\t * @see Marshaller#supports(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "modelKey"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "void",
    "signature": "public void setModelKey(String modelKey)",
    "source_code": "\tpublic void setModelKey(String modelKey) {\n\t\tthis.modelKey = modelKey;\n\t}"
  },
  "org.springframework.web.socket.adapter.AbstractWebSocketSession": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * An abstract base class for implementations of {@link WebSocketSession}.\n *\n * @author Rossen Stoyanchev\n * @since 4.0\n * @param <T> the native session type\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "signature": "public class AbstractWebSocketSession",
    "source_code": "public abstract class AbstractWebSocketSession<T> implements NativeWebSocketSession {\n\n\tprotected static final IdGenerator idGenerator = new AlternativeJdkIdGenerator();\n\n\tprotected static final Log logger = LogFactory.getLog(NativeWebSocketSession.class);\n\n\n\tprivate final Map<String, Object> attributes = new ConcurrentHashMap<>();\n\n\t@Nullable\n\tprivate T nativeSession;\n\n\n\t/**\n\t * Create a new instance and associate the given attributes with it.\n\t * @param attributes the attributes from the HTTP handshake to associate with the WebSocket\n\t * session; the provided attributes are copied, the original map is not used.\n\t */\n\tpublic AbstractWebSocketSession(@Nullable Map<String, Object> attributes) {\n\t\tif (attributes != null) {\n\t\t\tattributes.entrySet().stream()\n\t\t\t\t\t.filter(entry -> (entry.getKey() != null && entry.getValue() != null))\n\t\t\t\t\t.forEach(entry -> this.attributes.put(entry.getKey(), entry.getValue()));\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic Map<String, Object> getAttributes() {\n\t\treturn this.attributes;\n\t}\n\n\t@Override\n\tpublic T getNativeSession() {\n\t\tAssert.state(this.nativeSession != null, \"WebSocket session not yet initialized\");\n\t\treturn this.nativeSession;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\t@Nullable\n\tpublic <R> R getNativeSession(@Nullable Class<R> requiredType) {\n\t\treturn (requiredType == null || requiredType.isInstance(this.nativeSession) ? (R) this.nativeSession : null);\n\t}\n\n\tpublic void initializeNativeSession(T session) {\n\t\tAssert.notNull(session, \"WebSocket session must not be null\");\n\t\tthis.nativeSession = session;\n\t}\n\n\tprotected final void checkNativeSessionInitialized() {\n\t\tAssert.state(this.nativeSession != null, \"WebSocket session is not yet initialized\");\n\t}\n\n\t@Override\n\tpublic final void sendMessage(WebSocketMessage<?> message) throws IOException {\n\t\tcheckNativeSessionInitialized();\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Sending \" + message + \", \" + this);\n\t\t}\n\n\t\tif (message instanceof TextMessage textMessage) {\n\t\t\tsendTextMessage(textMessage);\n\t\t}\n\t\telse if (message instanceof BinaryMessage binaryMessage) {\n\t\t\tsendBinaryMessage(binaryMessage);\n\t\t}\n\t\telse if (message instanceof PingMessage pingMessage) {\n\t\t\tsendPingMessage(pingMessage);\n\t\t}\n\t\telse if (message instanceof PongMessage pongMessage) {\n\t\t\tsendPongMessage(pongMessage);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\"Unexpected WebSocketMessage type: \" + message);\n\t\t}\n\t}\n\n\tprotected abstract void sendTextMessage(TextMessage message) throws IOException;\n\n\tprotected abstract void sendBinaryMessage(BinaryMessage message) throws IOException;\n\n\tprotected abstract void sendPingMessage(PingMessage message) throws IOException;\n\n\tprotected abstract void sendPongMessage(PongMessage message) throws IOException;\n\n\n\t@Override\n\tpublic final void close() throws IOException {\n\t\tclose(CloseStatus.NORMAL);\n\t}\n\n\t@Override\n\tpublic final void close(CloseStatus status) throws IOException {\n\t\tcheckNativeSessionInitialized();\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Closing \" + this);\n\t\t}\n\t\tcloseInternal(status);\n\t}\n\n\tprotected abstract void closeInternal(CloseStatus status) throws IOException;\n\n\n\t@Override\n\tpublic String toString() {\n\t\tif (this.nativeSession != null) {\n\t\t\treturn getClass().getSimpleName() + \"[id=\" + getId() + \", uri=\" + getUri() + \"]\";\n\t\t}\n\t\telse {\n\t\t\treturn getClass().getSimpleName() + \"[nativeSession=null]\";\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.socket.adapter.AbstractWebSocketSession#checkNativeSessionInitialized()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "void",
    "signature": "protected void checkNativeSessionInitialized()",
    "source_code": "\tprotected final void checkNativeSessionInitialized() {\n\t\tAssert.state(this.nativeSession != null, \"WebSocket session is not yet initialized\");\n\t}"
  },
  "org.springframework.web.socket.adapter.AbstractWebSocketSession#close()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\tpublic final void close() throws IOException {\n\t\tclose(CloseStatus.NORMAL);\n\t}"
  },
  "org.springframework.web.socket.adapter.AbstractWebSocketSession#close(status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "void",
    "signature": "public void close(CloseStatus status)",
    "source_code": "\tpublic final void close(CloseStatus status) throws IOException {\n\t\tcheckNativeSessionInitialized();\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Closing \" + this);\n\t\t}\n\t\tcloseInternal(status);\n\t}"
  },
  "org.springframework.web.socket.adapter.AbstractWebSocketSession#closeInternal(status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "void",
    "signature": "protected void closeInternal(CloseStatus status)",
    "source_code": "\tprotected abstract void closeInternal(CloseStatus status) throws IOException;"
  },
  "org.springframework.web.socket.adapter.AbstractWebSocketSession#getAttributes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "Object>",
    "signature": "public Object> getAttributes()",
    "source_code": "\tpublic Map<String, Object> getAttributes() {\n\t\treturn this.attributes;\n\t}"
  },
  "org.springframework.web.socket.adapter.AbstractWebSocketSession#getNativeSession()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "T",
    "signature": "public T getNativeSession()",
    "source_code": "\tpublic T getNativeSession() {\n\t\tAssert.state(this.nativeSession != null, \"WebSocket session not yet initialized\");\n\t\treturn this.nativeSession;\n\t}"
  },
  "org.springframework.web.socket.adapter.AbstractWebSocketSession#getNativeSession(requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "R",
    "signature": "public R getNativeSession(@Nullable Class<R> requiredType)",
    "source_code": "\tpublic <R> R getNativeSession(@Nullable Class<R> requiredType) {\n\t\treturn (requiredType == null || requiredType.isInstance(this.nativeSession) ? (R) this.nativeSession : null);\n\t}"
  },
  "org.springframework.web.socket.adapter.AbstractWebSocketSession#initializeNativeSession(session)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "void",
    "signature": "public void initializeNativeSession(T session)",
    "source_code": "\tpublic void initializeNativeSession(T session) {\n\t\tAssert.notNull(session, \"WebSocket session must not be null\");\n\t\tthis.nativeSession = session;\n\t}"
  },
  "org.springframework.web.socket.adapter.AbstractWebSocketSession#sendBinaryMessage(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "protected void sendBinaryMessage(BinaryMessage message)",
    "source_code": "\tprotected abstract void sendBinaryMessage(BinaryMessage message) throws IOException;"
  },
  "org.springframework.web.socket.adapter.AbstractWebSocketSession#sendMessage(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "public void sendMessage(WebSocketMessage<?> message)",
    "source_code": "\tpublic final void sendMessage(WebSocketMessage<?> message) throws IOException {\n\t\tcheckNativeSessionInitialized();\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Sending \" + message + \", \" + this);\n\t\t}\n\n\t\tif (message instanceof TextMessage textMessage) {\n\t\t\tsendTextMessage(textMessage);\n\t\t}\n\t\telse if (message instanceof BinaryMessage binaryMessage) {\n\t\t\tsendBinaryMessage(binaryMessage);\n\t\t}\n\t\telse if (message instanceof PingMessage pingMessage) {\n\t\t\tsendPingMessage(pingMessage);\n\t\t}\n\t\telse if (message instanceof PongMessage pongMessage) {\n\t\t\tsendPongMessage(pongMessage);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\"Unexpected WebSocketMessage type: \" + message);\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.adapter.AbstractWebSocketSession#sendPingMessage(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "void",
    "signature": "protected void sendPingMessage(PingMessage message)",
    "source_code": "\tprotected abstract void sendPingMessage(PingMessage message) throws IOException;"
  },
  "org.springframework.web.socket.adapter.AbstractWebSocketSession#sendPongMessage(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "void",
    "signature": "protected void sendPongMessage(PongMessage message)",
    "source_code": "\tprotected abstract void sendPongMessage(PongMessage message) throws IOException;"
  },
  "org.springframework.web.socket.adapter.AbstractWebSocketSession#sendTextMessage(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "void",
    "signature": "protected void sendTextMessage(TextMessage message)",
    "source_code": "\tprotected abstract void sendTextMessage(TextMessage message) throws IOException;"
  },
  "org.springframework.web.socket.adapter.AbstractWebSocketSession#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\tif (this.nativeSession != null) {\n\t\t\treturn getClass().getSimpleName() + \"[id=\" + getId() + \", uri=\" + getUri() + \"]\";\n\t\t}\n\t\telse {\n\t\t\treturn getClass().getSimpleName() + \"[nativeSession=null]\";\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.adapter.idGenerator": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "signature": "protected IdGenerator idGenerator",
    "source_code": "\tprotected static final IdGenerator idGenerator = new AlternativeJdkIdGenerator();",
    "type": "IdGenerator"
  },
  "org.springframework.web.socket.adapter.logger": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected static final Log logger = LogFactory.getLog(NativeWebSocketSession.class);",
    "type": "Log"
  },
  "org.springframework.web.socket.adapter.standard.BinaryDecoder": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A binary {@link jakarta.websocket.Encoder.Binary jakarta.websocket.Encoder} that delegates\n\t * to Spring's conversion service. See {@link ConvertingEncoderDecoderSupport} for details.\n\t * @param <T> the type that this Decoder can convert from\n\t */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "signature": "public class BinaryDecoder",
    "source_code": "\tpublic abstract static class BinaryDecoder<T> extends ConvertingEncoderDecoderSupport<T, ByteBuffer>"
  },
  "org.springframework.web.socket.adapter.standard.BinaryEncoder": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A binary {@link jakarta.websocket.Encoder.Binary jakarta.websocket.Encoder} that delegates\n\t * to Spring's conversion service. See {@link ConvertingEncoderDecoderSupport} for details.\n\t * @param <T> the type that this Encoder can convert to\n\t */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 213
    },
    "signature": "public class BinaryEncoder",
    "source_code": "\tpublic abstract static class BinaryEncoder<T> extends ConvertingEncoderDecoderSupport<T, ByteBuffer>"
  },
  "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupport": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Base class that can be used to implement a standard {@link jakarta.websocket.Encoder}\n * and/or {@link jakarta.websocket.Decoder}. It provides encode and decode method\n * implementations that delegate to a Spring {@link ConversionService}.\n *\n * <p>By default, this class looks up a {@link ConversionService} registered in the\n * {@link #getApplicationContext() active ApplicationContext} under\n * the name {@code 'webSocketConversionService'}. This works fine for both client\n * and server endpoints, in a Servlet container environment. If not running in a\n * Servlet container, subclasses will need to override the\n * {@link #getConversionService()} method to provide an alternative lookup strategy.\n *\n * <p>Subclasses can extend this class and should also implement one or\n * both of {@link jakarta.websocket.Encoder} and {@link jakarta.websocket.Decoder}.\n * For convenience {@link ConvertingEncoderDecoderSupport.BinaryEncoder},\n * {@link ConvertingEncoderDecoderSupport.BinaryDecoder},\n * {@link ConvertingEncoderDecoderSupport.TextEncoder} and\n * {@link ConvertingEncoderDecoderSupport.TextDecoder} subclasses are provided.\n *\n * <p>Since JSR-356 only allows Encoder/Decoder to be registered by type, instances\n * of this class are therefore managed by the WebSocket runtime, and do not need to\n * be registered as Spring Beans. They can, however, by injected with Spring-managed\n * dependencies via {@link Autowired @Autowire}.\n *\n * <p>Converters to convert between the {@link #getType() type} and {@code String} or\n * {@code ByteBuffer} should be registered.\n *\n * @author Phillip Webb\n * @since 4.0\n * @param <T> the type being converted to (for Encoder) or from (for Decoder)\n * @param <M> the WebSocket message type ({@link String} or {@link ByteBuffer})\n * @see ConvertingEncoderDecoderSupport.BinaryEncoder\n * @see ConvertingEncoderDecoderSupport.BinaryDecoder\n * @see ConvertingEncoderDecoderSupport.TextEncoder\n * @see ConvertingEncoderDecoderSupport.TextDecoder\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "signature": "public class ConvertingEncoderDecoderSupport",
    "source_code": "public abstract class ConvertingEncoderDecoderSupport<T, M> {\n\n\tprivate static final String CONVERSION_SERVICE_BEAN_NAME = \"webSocketConversionService\";\n\n\n\t/**\n\t * Called to initialize the encoder/decoder.\n\t * @see jakarta.websocket.Encoder#init(EndpointConfig)\n\t * @see jakarta.websocket.Decoder#init(EndpointConfig)\n\t */\n\tpublic void init(EndpointConfig config) {\n\t\tif (getApplicationContext() instanceof ConfigurableApplicationContext cac) {\n\t\t\tConfigurableListableBeanFactory beanFactory = cac.getBeanFactory();\n\t\t\tbeanFactory.autowireBean(this);\n\t\t}\n\t}\n\n\t/**\n\t * Called to destroy the encoder/decoder.\n\t * @see jakarta.websocket.Encoder#destroy()\n\t * @see jakarta.websocket.Decoder#destroy()\n\t */\n\tpublic void destroy() {\n\t}\n\n\t/**\n\t * Strategy method used to obtain the {@link ConversionService}. By default, this\n\t * method expects a bean named {@code 'webSocketConversionService'} in the\n\t * {@link #getApplicationContext() active ApplicationContext}.\n\t * @return the {@link ConversionService} (never null)\n\t */\n\tprotected ConversionService getConversionService() {\n\t\tApplicationContext applicationContext = getApplicationContext();\n\t\tAssert.state(applicationContext != null, \"Unable to locate the Spring ApplicationContext\");\n\t\ttry {\n\t\t\treturn applicationContext.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class);\n\t\t}\n\t\tcatch (BeansException ex) {\n\t\t\tthrow new IllegalStateException(\"Unable to find ConversionService: please configure a '\" +\n\t\t\t\t\tCONVERSION_SERVICE_BEAN_NAME + \"' or override the getConversionService() method\", ex);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the active {@link ApplicationContext}. By default, this method obtains\n\t * the context via {@link ContextLoader#getCurrentWebApplicationContext()}, which\n\t * finds the ApplicationContext loaded via {@link ContextLoader} typically in a\n\t * Servlet container environment. When not running in a Servlet container and\n\t * not using {@link ContextLoader}, this method should be overridden.\n\t * @return the {@link ApplicationContext} or {@code null}\n\t */\n\t@Nullable\n\tprotected ApplicationContext getApplicationContext() {\n\t\treturn ContextLoader.getCurrentWebApplicationContext();\n\t}\n\n\t/**\n\t * Returns the type being converted. By default, the type is resolved using\n\t * the generic arguments of the class.\n\t */\n\tprotected TypeDescriptor getType() {\n\t\treturn TypeDescriptor.valueOf(resolveTypeArguments()[0]);\n\t}\n\n\t/**\n\t * Returns the websocket message type. By default, the type is resolved using\n\t * the generic arguments of the class.\n\t */\n\tprotected TypeDescriptor getMessageType() {\n\t\treturn TypeDescriptor.valueOf(resolveTypeArguments()[1]);\n\t}\n\n\tprivate Class<?>[] resolveTypeArguments() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(getClass(), ConvertingEncoderDecoderSupport.class);\n\t\tif (resolved == null) {\n\t\t\tthrow new IllegalStateException(\"ConvertingEncoderDecoderSupport's generic types T and M \" +\n\t\t\t\t\t\"need to be substituted in subclass: \" + getClass());\n\t\t}\n\t\treturn resolved;\n\t}\n\n\t/**\n\t * Encode an object to a message.\n\t * @see jakarta.websocket.Encoder.Text#encode(Object)\n\t * @see jakarta.websocket.Encoder.Binary#encode(Object)\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\t@Nullable\n\tpublic M encode(T object) throws EncodeException {\n\t\ttry {\n\t\t\treturn (M) getConversionService().convert(object, getType(), getMessageType());\n\t\t}\n\t\tcatch (ConversionException ex) {\n\t\t\tthrow new EncodeException(object, \"Unable to encode websocket message using ConversionService\", ex);\n\t\t}\n\t}\n\n\t/**\n\t * Determine if a given message can be decoded.\n\t * @see #decode(Object)\n\t * @see jakarta.websocket.Decoder.Text#willDecode(String)\n\t * @see jakarta.websocket.Decoder.Binary#willDecode(ByteBuffer)\n\t */\n\tpublic boolean willDecode(M bytes) {\n\t\treturn getConversionService().canConvert(getType(), getMessageType());\n\t}\n\n\t/**\n\t * Decode the message into an object.\n\t * @see jakarta.websocket.Decoder.Text#decode(String)\n\t * @see jakarta.websocket.Decoder.Binary#decode(ByteBuffer)\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\t@Nullable\n\tpublic T decode(M message) throws DecodeException {\n\t\ttry {\n\t\t\treturn (T) getConversionService().convert(message, getMessageType(), getType());\n\t\t}\n\t\tcatch (ConversionException ex) {\n\t\t\tif (message instanceof String string) {\n\t\t\t\tthrow new DecodeException(string,\n\t\t\t\t\t\t\"Unable to decode websocket message using ConversionService\", ex);\n\t\t\t}\n\t\t\tif (message instanceof ByteBuffer byteBuffer) {\n\t\t\t\tthrow new DecodeException(byteBuffer,\n\t\t\t\t\t\t\"Unable to decode websocket message using ConversionService\", ex);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\n\t/**\n\t * A binary {@link jakarta.websocket.Encoder.Binary jakarta.websocket.Encoder} that delegates\n\t * to Spring's conversion service. See {@link ConvertingEncoderDecoderSupport} for details.\n\t * @param <T> the type that this Encoder can convert to\n\t */\n\tpublic abstract static class BinaryEncoder<T> extends ConvertingEncoderDecoderSupport<T, ByteBuffer>\n\t\t\timplements Encoder.Binary<T> {\n\t}\n\n\n\t/**\n\t * A binary {@link jakarta.websocket.Encoder.Binary jakarta.websocket.Encoder} that delegates\n\t * to Spring's conversion service. See {@link ConvertingEncoderDecoderSupport} for details.\n\t * @param <T> the type that this Decoder can convert from\n\t */\n\tpublic abstract static class BinaryDecoder<T> extends ConvertingEncoderDecoderSupport<T, ByteBuffer>\n\t\t\timplements Decoder.Binary<T> {\n\t}\n\n\n\t/**\n\t * A text {@link jakarta.websocket.Encoder.Text jakarta.websocket.Encoder} that delegates\n\t * to Spring's conversion service. See {@link ConvertingEncoderDecoderSupport} for\n\t * details.\n\t * @param <T> the type that this Encoder can convert to\n\t */\n\tpublic abstract static class TextEncoder<T> extends ConvertingEncoderDecoderSupport<T, String>\n\t\t\timplements Encoder.Text<T> {\n\t}\n\n\n\t/**\n\t * A Text {@link jakarta.websocket.Encoder.Text jakarta.websocket.Encoder} that delegates\n\t * to Spring's conversion service. See {@link ConvertingEncoderDecoderSupport} for details.\n\t * @param <T> the type that this Decoder can convert from\n\t */\n\tpublic abstract static class TextDecoder<T> extends ConvertingEncoderDecoderSupport<T, String>\n\t\t\timplements Decoder.Text<T> {\n\t}\n\n}"
  },
  "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupport#decode(message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Decode the message into an object.\n\t * @see jakarta.websocket.Decoder.Text#decode(String)\n\t * @see jakarta.websocket.Decoder.Binary#decode(ByteBuffer)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "T",
    "signature": "public T decode(M message)",
    "source_code": "\tpublic T decode(M message) throws DecodeException {\n\t\ttry {\n\t\t\treturn (T) getConversionService().convert(message, getMessageType(), getType());\n\t\t}\n\t\tcatch (ConversionException ex) {\n\t\t\tif (message instanceof String string) {\n\t\t\t\tthrow new DecodeException(string,\n\t\t\t\t\t\t\"Unable to decode websocket message using ConversionService\", ex);\n\t\t\t}\n\t\t\tif (message instanceof ByteBuffer byteBuffer) {\n\t\t\t\tthrow new DecodeException(byteBuffer,\n\t\t\t\t\t\t\"Unable to decode websocket message using ConversionService\", ex);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupport#destroy()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Called to destroy the encoder/decoder.\n\t * @see jakarta.websocket.Encoder#destroy()\n\t * @see jakarta.websocket.Decoder#destroy()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void destroy()",
    "source_code": "\tpublic void destroy() {\n\t}"
  },
  "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupport#encode(object)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode an object to a message.\n\t * @see jakarta.websocket.Encoder.Text#encode(Object)\n\t * @see jakarta.websocket.Encoder.Binary#encode(Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "M",
    "signature": "public M encode(T object)",
    "source_code": "\tpublic M encode(T object) throws EncodeException {\n\t\ttry {\n\t\t\treturn (M) getConversionService().convert(object, getType(), getMessageType());\n\t\t}\n\t\tcatch (ConversionException ex) {\n\t\t\tthrow new EncodeException(object, \"Unable to encode websocket message using ConversionService\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupport#getApplicationContext()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns the active {@link ApplicationContext}. By default, this method obtains\n\t * the context via {@link ContextLoader#getCurrentWebApplicationContext()}, which\n\t * finds the ApplicationContext loaded via {@link ContextLoader} typically in a\n\t * Servlet container environment. When not running in a Servlet container and\n\t * not using {@link ContextLoader}, this method should be overridden.\n\t * @return the {@link ApplicationContext} or {@code null}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "ApplicationContext",
    "signature": "protected ApplicationContext getApplicationContext()",
    "source_code": "\tprotected ApplicationContext getApplicationContext() {\n\t\treturn ContextLoader.getCurrentWebApplicationContext();\n\t}"
  },
  "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupport#getConversionService()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Strategy method used to obtain the {@link ConversionService}. By default, this\n\t * method expects a bean named {@code 'webSocketConversionService'} in the\n\t * {@link #getApplicationContext() active ApplicationContext}.\n\t * @return the {@link ConversionService} (never null)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "ConversionService",
    "signature": "protected ConversionService getConversionService()",
    "source_code": "\tprotected ConversionService getConversionService() {\n\t\tApplicationContext applicationContext = getApplicationContext();\n\t\tAssert.state(applicationContext != null, \"Unable to locate the Spring ApplicationContext\");\n\t\ttry {\n\t\t\treturn applicationContext.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class);\n\t\t}\n\t\tcatch (BeansException ex) {\n\t\t\tthrow new IllegalStateException(\"Unable to find ConversionService: please configure a '\" +\n\t\t\t\t\tCONVERSION_SERVICE_BEAN_NAME + \"' or override the getConversionService() method\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupport#getMessageType()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns the websocket message type. By default, the type is resolved using\n\t * the generic arguments of the class.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "TypeDescriptor",
    "signature": "protected TypeDescriptor getMessageType()",
    "source_code": "\tprotected TypeDescriptor getMessageType() {\n\t\treturn TypeDescriptor.valueOf(resolveTypeArguments()[1]);\n\t}"
  },
  "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupport#getType()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns the type being converted. By default, the type is resolved using\n\t * the generic arguments of the class.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "TypeDescriptor",
    "signature": "protected TypeDescriptor getType()",
    "source_code": "\tprotected TypeDescriptor getType() {\n\t\treturn TypeDescriptor.valueOf(resolveTypeArguments()[0]);\n\t}"
  },
  "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupport#init(config)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Called to initialize the encoder/decoder.\n\t * @see jakarta.websocket.Encoder#init(EndpointConfig)\n\t * @see jakarta.websocket.Decoder#init(EndpointConfig)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "config"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "void",
    "signature": "public void init(EndpointConfig config)",
    "source_code": "\tpublic void init(EndpointConfig config) {\n\t\tif (getApplicationContext() instanceof ConfigurableApplicationContext cac) {\n\t\t\tConfigurableListableBeanFactory beanFactory = cac.getBeanFactory();\n\t\t\tbeanFactory.autowireBean(this);\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupport#willDecode(bytes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if a given message can be decoded.\n\t * @see #decode(Object)\n\t * @see jakarta.websocket.Decoder.Text#willDecode(String)\n\t * @see jakarta.websocket.Decoder.Binary#willDecode(ByteBuffer)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bytes"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "boolean",
    "signature": "public boolean willDecode(M bytes)",
    "source_code": "\tpublic boolean willDecode(M bytes) {\n\t\treturn getConversionService().canConvert(getType(), getMessageType());\n\t}"
  },
  "org.springframework.web.socket.adapter.standard.TextDecoder": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A Text {@link jakarta.websocket.Encoder.Text jakarta.websocket.Encoder} that delegates\n\t * to Spring's conversion service. See {@link ConvertingEncoderDecoderSupport} for details.\n\t * @param <T> the type that this Decoder can convert from\n\t */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 244
    },
    "signature": "public class TextDecoder",
    "source_code": "\tpublic abstract static class TextDecoder<T> extends ConvertingEncoderDecoderSupport<T, String>"
  },
  "org.springframework.web.socket.adapter.standard.TextEncoder": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A text {@link jakarta.websocket.Encoder.Text jakarta.websocket.Encoder} that delegates\n\t * to Spring's conversion service. See {@link ConvertingEncoderDecoderSupport} for\n\t * details.\n\t * @param <T> the type that this Encoder can convert to\n\t */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 234
    },
    "signature": "public class TextEncoder",
    "source_code": "\tpublic abstract static class TextEncoder<T> extends ConvertingEncoderDecoderSupport<T, String>"
  },
  "org.springframework.web.socket.config.WebSocketMessageBrokerStats": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A central class for aggregating information about internal state and counters\n * from key infrastructure components of the setup that comes with\n * {@code @EnableWebSocketMessageBroker} for Java config and\n * {@code <websocket:message-broker>} for XML.\n *\n * <p>By default aggregated information is logged every 30 minutes at INFO level.\n * The frequency of logging can be changed via {@link #setLoggingPeriod(long)}.\n *\n * <p>This class is declared as a Spring bean by the above configuration with the\n * name \"webSocketMessageBrokerStats\" and can be easily exported to JMX, e.g. with\n * the {@link org.springframework.jmx.export.MBeanExporter MBeanExporter}.\n *\n * @author Rossen Stoyanchev\n * @author Sam Brannen\n * @since 4.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "signature": "public class WebSocketMessageBrokerStats",
    "source_code": "public class WebSocketMessageBrokerStats {\n\n\tprivate static final Log logger = LogFactory.getLog(WebSocketMessageBrokerStats.class);\n\n\n\t@Nullable\n\tprivate SubProtocolWebSocketHandler webSocketHandler;\n\n\t@Nullable\n\tprivate StompSubProtocolHandler stompSubProtocolHandler;\n\n\t@Nullable\n\tprivate StompBrokerRelayMessageHandler stompBrokerRelay;\n\n\t@Nullable\n\tprivate TaskExecutor inboundChannelExecutor;\n\n\t@Nullable\n\tprivate TaskExecutor outboundChannelExecutor;\n\n\t@Nullable\n\tprivate TaskScheduler sockJsTaskScheduler;\n\n\t@Nullable\n\tprivate ScheduledFuture<?> loggingTask;\n\n\tprivate long loggingPeriod = TimeUnit.MINUTES.toMillis(30);\n\n\n\tpublic void setSubProtocolWebSocketHandler(SubProtocolWebSocketHandler webSocketHandler) {\n\t\tthis.webSocketHandler = webSocketHandler;\n\t\tthis.stompSubProtocolHandler = initStompSubProtocolHandler();\n\t}\n\n\t@Nullable\n\tprivate StompSubProtocolHandler initStompSubProtocolHandler() {\n\t\tif (this.webSocketHandler == null) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (SubProtocolHandler handler : this.webSocketHandler.getProtocolHandlers()) {\n\t\t\tif (handler instanceof StompSubProtocolHandler stompHandler) {\n\t\t\t\treturn stompHandler;\n\t\t\t}\n\t\t}\n\t\tSubProtocolHandler defaultHandler = this.webSocketHandler.getDefaultProtocolHandler();\n\t\tif (defaultHandler instanceof StompSubProtocolHandler stompHandler) {\n\t\t\treturn stompHandler;\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic void setStompBrokerRelay(StompBrokerRelayMessageHandler stompBrokerRelay) {\n\t\tthis.stompBrokerRelay = stompBrokerRelay;\n\t}\n\n\tpublic void setInboundChannelExecutor(TaskExecutor inboundChannelExecutor) {\n\t\tthis.inboundChannelExecutor = inboundChannelExecutor;\n\t}\n\n\tpublic void setOutboundChannelExecutor(TaskExecutor outboundChannelExecutor) {\n\t\tthis.outboundChannelExecutor = outboundChannelExecutor;\n\t}\n\n\tpublic void setSockJsTaskScheduler(TaskScheduler sockJsTaskScheduler) {\n\t\tthis.sockJsTaskScheduler = sockJsTaskScheduler;\n\t\tthis.loggingTask = initLoggingTask(TimeUnit.MINUTES.toMillis(1));\n\t}\n\n\t@Nullable\n\tprivate ScheduledFuture<?> initLoggingTask(long initialDelay) {\n\t\tif (this.sockJsTaskScheduler != null && this.loggingPeriod > 0 && logger.isInfoEnabled()) {\n\t\t\treturn this.sockJsTaskScheduler.scheduleWithFixedDelay(\n\t\t\t\t\t() -> logger.info(WebSocketMessageBrokerStats.this.toString()),\n\t\t\t\t\tInstant.now().plusMillis(initialDelay), Duration.ofMillis(this.loggingPeriod));\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Set the frequency for logging information at INFO level in milliseconds.\n\t * If set 0 or less than 0, the logging task is cancelled.\n\t * <p>By default this property is set to 30 minutes (30 * 60 * 1000).\n\t */\n\tpublic void setLoggingPeriod(long period) {\n\t\tif (this.loggingTask != null) {\n\t\t\tthis.loggingTask.cancel(true);\n\t\t}\n\t\tthis.loggingPeriod = period;\n\t\tthis.loggingTask = initLoggingTask(0);\n\t}\n\n\t/**\n\t * Return the configured logging period frequency in milliseconds.\n\t */\n\tpublic long getLoggingPeriod() {\n\t\treturn this.loggingPeriod;\n\t}\n\n\t/**\n\t * Get stats about WebSocket sessions.\n\t */\n\tpublic String getWebSocketSessionStatsInfo() {\n\t\treturn (this.webSocketHandler != null ? this.webSocketHandler.getStatsInfo() : \"null\");\n\t}\n\n\t/**\n\t * Get stats about STOMP-related WebSocket message processing.\n\t */\n\tpublic String getStompSubProtocolStatsInfo() {\n\t\treturn (this.stompSubProtocolHandler != null ? this.stompSubProtocolHandler.getStatsInfo() : \"null\");\n\t}\n\n\t/**\n\t * Get stats about STOMP broker relay (when using a full-featured STOMP broker).\n\t */\n\tpublic String getStompBrokerRelayStatsInfo() {\n\t\treturn (this.stompBrokerRelay != null ? this.stompBrokerRelay.getStatsInfo() : \"null\");\n\t}\n\n\t/**\n\t * Get stats about the executor processing incoming messages from WebSocket clients.\n\t */\n\tpublic String getClientInboundExecutorStatsInfo() {\n\t\treturn getExecutorStatsInfo(this.inboundChannelExecutor);\n\t}\n\n\t/**\n\t * Get stats about the executor processing outgoing messages to WebSocket clients.\n\t */\n\tpublic String getClientOutboundExecutorStatsInfo() {\n\t\treturn getExecutorStatsInfo(this.outboundChannelExecutor);\n\t}\n\n\t/**\n\t * Get stats about the SockJS task scheduler.\n\t */\n\tpublic String getSockJsTaskSchedulerStatsInfo() {\n\t\tif (this.sockJsTaskScheduler == null) {\n\t\t\treturn \"null\";\n\t\t}\n\t\tif (this.sockJsTaskScheduler instanceof ThreadPoolTaskScheduler threadPoolTaskScheduler) {\n\t\t\treturn getExecutorStatsInfo(threadPoolTaskScheduler.getScheduledThreadPoolExecutor());\n\t\t}\n\t\treturn \"unknown\";\n\t}\n\n\tprivate String getExecutorStatsInfo(@Nullable Executor executor) {\n\t\tif (executor == null) {\n\t\t\treturn \"null\";\n\t\t}\n\n\t\tif (executor instanceof ThreadPoolTaskExecutor threadPoolTaskScheduler) {\n\t\t\texecutor = threadPoolTaskScheduler.getThreadPoolExecutor();\n\t\t}\n\n\t\tif (executor instanceof ThreadPoolExecutor) {\n\t\t\t// It is assumed that the implementation of toString() in ThreadPoolExecutor\n\t\t\t// generates text that ends similar to the following:\n\t\t\t// pool size = #, active threads = #, queued tasks = #, completed tasks = #]\n\t\t\tString str = executor.toString();\n\t\t\tint indexOfPool = str.indexOf(\"pool\");\n\t\t\tif (indexOfPool != -1) {\n\t\t\t\t// (length - 1) omits the trailing \"]\"\n\t\t\t\treturn str.substring(indexOfPool, str.length() - 1);\n\t\t\t}\n\t\t}\n\n\t\treturn \"unknown\";\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"WebSocketSession[\" + getWebSocketSessionStatsInfo() + \"]\" +\n\t\t\t\t\", stompSubProtocol[\" + getStompSubProtocolStatsInfo() + \"]\" +\n\t\t\t\t\", stompBrokerRelay[\" + getStompBrokerRelayStatsInfo() + \"]\" +\n\t\t\t\t\", inboundChannel[\" + getClientInboundExecutorStatsInfo() + \"]\" +\n\t\t\t\t\", outboundChannel[\" + getClientOutboundExecutorStatsInfo() + \"]\" +\n\t\t\t\t\", sockJsScheduler[\" + getSockJsTaskSchedulerStatsInfo() + \"]\";\n\t}\n\n}"
  },
  "org.springframework.web.socket.config.WebSocketMessageBrokerStats#getClientInboundExecutorStatsInfo()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get stats about the executor processing incoming messages from WebSocket clients.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "String",
    "signature": "public String getClientInboundExecutorStatsInfo()",
    "source_code": "\tpublic String getClientInboundExecutorStatsInfo() {\n\t\treturn getExecutorStatsInfo(this.inboundChannelExecutor);\n\t}"
  },
  "org.springframework.web.socket.config.WebSocketMessageBrokerStats#getClientOutboundExecutorStatsInfo()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get stats about the executor processing outgoing messages to WebSocket clients.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "String",
    "signature": "public String getClientOutboundExecutorStatsInfo()",
    "source_code": "\tpublic String getClientOutboundExecutorStatsInfo() {\n\t\treturn getExecutorStatsInfo(this.outboundChannelExecutor);\n\t}"
  },
  "org.springframework.web.socket.config.WebSocketMessageBrokerStats#getLoggingPeriod()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured logging period frequency in milliseconds.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "long",
    "signature": "public long getLoggingPeriod()",
    "source_code": "\tpublic long getLoggingPeriod() {\n\t\treturn this.loggingPeriod;\n\t}"
  },
  "org.springframework.web.socket.config.WebSocketMessageBrokerStats#getSockJsTaskSchedulerStatsInfo()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get stats about the SockJS task scheduler.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "String",
    "signature": "public String getSockJsTaskSchedulerStatsInfo()",
    "source_code": "\tpublic String getSockJsTaskSchedulerStatsInfo() {\n\t\tif (this.sockJsTaskScheduler == null) {\n\t\t\treturn \"null\";\n\t\t}\n\t\tif (this.sockJsTaskScheduler instanceof ThreadPoolTaskScheduler threadPoolTaskScheduler) {\n\t\t\treturn getExecutorStatsInfo(threadPoolTaskScheduler.getScheduledThreadPoolExecutor());\n\t\t}\n\t\treturn \"unknown\";\n\t}"
  },
  "org.springframework.web.socket.config.WebSocketMessageBrokerStats#getStompBrokerRelayStatsInfo()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get stats about STOMP broker relay (when using a full-featured STOMP broker).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "String",
    "signature": "public String getStompBrokerRelayStatsInfo()",
    "source_code": "\tpublic String getStompBrokerRelayStatsInfo() {\n\t\treturn (this.stompBrokerRelay != null ? this.stompBrokerRelay.getStatsInfo() : \"null\");\n\t}"
  },
  "org.springframework.web.socket.config.WebSocketMessageBrokerStats#getStompSubProtocolStatsInfo()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get stats about STOMP-related WebSocket message processing.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "String",
    "signature": "public String getStompSubProtocolStatsInfo()",
    "source_code": "\tpublic String getStompSubProtocolStatsInfo() {\n\t\treturn (this.stompSubProtocolHandler != null ? this.stompSubProtocolHandler.getStatsInfo() : \"null\");\n\t}"
  },
  "org.springframework.web.socket.config.WebSocketMessageBrokerStats#getWebSocketSessionStatsInfo()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get stats about WebSocket sessions.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "String",
    "signature": "public String getWebSocketSessionStatsInfo()",
    "source_code": "\tpublic String getWebSocketSessionStatsInfo() {\n\t\treturn (this.webSocketHandler != null ? this.webSocketHandler.getStatsInfo() : \"null\");\n\t}"
  },
  "org.springframework.web.socket.config.WebSocketMessageBrokerStats#setInboundChannelExecutor(inboundChannelExecutor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inboundChannelExecutor"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void setInboundChannelExecutor(TaskExecutor inboundChannelExecutor)",
    "source_code": "\tpublic void setInboundChannelExecutor(TaskExecutor inboundChannelExecutor) {\n\t\tthis.inboundChannelExecutor = inboundChannelExecutor;\n\t}"
  },
  "org.springframework.web.socket.config.WebSocketMessageBrokerStats#setLoggingPeriod(period)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the frequency for logging information at INFO level in milliseconds.\n\t * If set 0 or less than 0, the logging task is cancelled.\n\t * <p>By default this property is set to 30 minutes (30 * 60 * 1000).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "period"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "void",
    "signature": "public void setLoggingPeriod(long period)",
    "source_code": "\tpublic void setLoggingPeriod(long period) {\n\t\tif (this.loggingTask != null) {\n\t\t\tthis.loggingTask.cancel(true);\n\t\t}\n\t\tthis.loggingPeriod = period;\n\t\tthis.loggingTask = initLoggingTask(0);\n\t}"
  },
  "org.springframework.web.socket.config.WebSocketMessageBrokerStats#setOutboundChannelExecutor(outboundChannelExecutor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outboundChannelExecutor"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "void",
    "signature": "public void setOutboundChannelExecutor(TaskExecutor outboundChannelExecutor)",
    "source_code": "\tpublic void setOutboundChannelExecutor(TaskExecutor outboundChannelExecutor) {\n\t\tthis.outboundChannelExecutor = outboundChannelExecutor;\n\t}"
  },
  "org.springframework.web.socket.config.WebSocketMessageBrokerStats#setSockJsTaskScheduler(sockJsTaskScheduler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sockJsTaskScheduler"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "void",
    "signature": "public void setSockJsTaskScheduler(TaskScheduler sockJsTaskScheduler)",
    "source_code": "\tpublic void setSockJsTaskScheduler(TaskScheduler sockJsTaskScheduler) {\n\t\tthis.sockJsTaskScheduler = sockJsTaskScheduler;\n\t\tthis.loggingTask = initLoggingTask(TimeUnit.MINUTES.toMillis(1));\n\t}"
  },
  "org.springframework.web.socket.config.WebSocketMessageBrokerStats#setStompBrokerRelay(stompBrokerRelay)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "stompBrokerRelay"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "void",
    "signature": "public void setStompBrokerRelay(StompBrokerRelayMessageHandler stompBrokerRelay)",
    "source_code": "\tpublic void setStompBrokerRelay(StompBrokerRelayMessageHandler stompBrokerRelay) {\n\t\tthis.stompBrokerRelay = stompBrokerRelay;\n\t}"
  },
  "org.springframework.web.socket.config.WebSocketMessageBrokerStats#setSubProtocolWebSocketHandler(webSocketHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webSocketHandler"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "void",
    "signature": "public void setSubProtocolWebSocketHandler(SubProtocolWebSocketHandler webSocketHandler)",
    "source_code": "\tpublic void setSubProtocolWebSocketHandler(SubProtocolWebSocketHandler webSocketHandler) {\n\t\tthis.webSocketHandler = webSocketHandler;\n\t\tthis.stompSubProtocolHandler = initStompSubProtocolHandler();\n\t}"
  },
  "org.springframework.web.socket.config.WebSocketMessageBrokerStats#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn \"WebSocketSession[\" + getWebSocketSessionStatsInfo() + \"]\" +\n\t\t\t\t\", stompSubProtocol[\" + getStompSubProtocolStatsInfo() + \"]\" +\n\t\t\t\t\", stompBrokerRelay[\" + getStompBrokerRelayStatsInfo() + \"]\" +\n\t\t\t\t\", inboundChannel[\" + getClientInboundExecutorStatsInfo() + \"]\" +\n\t\t\t\t\", outboundChannel[\" + getClientOutboundExecutorStatsInfo() + \"]\" +\n\t\t\t\t\", sockJsScheduler[\" + getSockJsTaskSchedulerStatsInfo() + \"]\";\n\t}"
  },
  "org.springframework.web.socket.config.annotation.WebMvcStompEndpointRegistry": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A registry for STOMP over WebSocket endpoints that maps the endpoints with a\n * {@link org.springframework.web.servlet.HandlerMapping} for use in Spring MVC.\n *\n * @author Rossen Stoyanchev\n * @author Artem Bilan\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "signature": "public class WebMvcStompEndpointRegistry",
    "source_code": "public class WebMvcStompEndpointRegistry implements StompEndpointRegistry {\n\n\tprivate final WebSocketHandler webSocketHandler;\n\n\tprivate final TaskScheduler sockJsScheduler;\n\n\tprivate int order = 1;\n\n\t@Nullable\n\tprivate UrlPathHelper urlPathHelper;\n\n\tprivate final SubProtocolWebSocketHandler subProtocolWebSocketHandler;\n\n\tprivate final StompSubProtocolHandler stompHandler;\n\n\tprivate final List<WebMvcStompWebSocketEndpointRegistration> registrations = new ArrayList<>();\n\n\n\tpublic WebMvcStompEndpointRegistry(WebSocketHandler webSocketHandler,\n\t\t\tWebSocketTransportRegistration transportRegistration, TaskScheduler defaultSockJsTaskScheduler) {\n\n\t\tAssert.notNull(webSocketHandler, \"WebSocketHandler is required \");\n\t\tAssert.notNull(transportRegistration, \"WebSocketTransportRegistration is required\");\n\n\t\tthis.webSocketHandler = webSocketHandler;\n\t\tthis.subProtocolWebSocketHandler = unwrapSubProtocolWebSocketHandler(webSocketHandler);\n\n\t\tif (transportRegistration.getSendTimeLimit() != null) {\n\t\t\tthis.subProtocolWebSocketHandler.setSendTimeLimit(transportRegistration.getSendTimeLimit());\n\t\t}\n\t\tif (transportRegistration.getSendBufferSizeLimit() != null) {\n\t\t\tthis.subProtocolWebSocketHandler.setSendBufferSizeLimit(transportRegistration.getSendBufferSizeLimit());\n\t\t}\n\t\tif (transportRegistration.getTimeToFirstMessage() != null) {\n\t\t\tthis.subProtocolWebSocketHandler.setTimeToFirstMessage(transportRegistration.getTimeToFirstMessage());\n\t\t}\n\n\t\tthis.stompHandler = new StompSubProtocolHandler();\n\t\tif (transportRegistration.getMessageSizeLimit() != null) {\n\t\t\tthis.stompHandler.setMessageSizeLimit(transportRegistration.getMessageSizeLimit());\n\t\t}\n\n\t\tthis.sockJsScheduler = defaultSockJsTaskScheduler;\n\t}\n\n\tprivate static SubProtocolWebSocketHandler unwrapSubProtocolWebSocketHandler(WebSocketHandler handler) {\n\t\tWebSocketHandler actual = WebSocketHandlerDecorator.unwrap(handler);\n\t\tif (!(actual instanceof SubProtocolWebSocketHandler subProtocolWebSocketHandler)) {\n\t\t\tthrow new IllegalArgumentException(\"No SubProtocolWebSocketHandler in \" + handler);\n\t\t}\n\t\treturn subProtocolWebSocketHandler;\n\t}\n\n\n\t@Override\n\tpublic StompWebSocketEndpointRegistration addEndpoint(String... paths) {\n\t\tthis.subProtocolWebSocketHandler.addProtocolHandler(this.stompHandler);\n\t\tWebMvcStompWebSocketEndpointRegistration registration =\n\t\t\t\tnew WebMvcStompWebSocketEndpointRegistration(paths, this.webSocketHandler, this.sockJsScheduler);\n\t\tthis.registrations.add(registration);\n\t\treturn registration;\n\t}\n\n\t/**\n\t * Set the order for the resulting\n\t * {@link org.springframework.web.servlet.HandlerMapping}\n\t * relative to other handler mappings configured in Spring MVC.\n\t * <p>The default value is 1.\n\t */\n\t@Override\n\tpublic void setOrder(int order) {\n\t\tthis.order = order;\n\t}\n\n\tprotected int getOrder() {\n\t\treturn this.order;\n\t}\n\n\t/**\n\t * Set the UrlPathHelper to configure on the {@code HandlerMapping}\n\t * used to map handshake requests.\n\t */\n\t@Override\n\tpublic void setUrlPathHelper(@Nullable UrlPathHelper urlPathHelper) {\n\t\tthis.urlPathHelper = urlPathHelper;\n\t}\n\n\t@Nullable\n\tprotected UrlPathHelper getUrlPathHelper() {\n\t\treturn this.urlPathHelper;\n\t}\n\n\t@Override\n\tpublic WebMvcStompEndpointRegistry setErrorHandler(StompSubProtocolErrorHandler errorHandler) {\n\t\tthis.stompHandler.setErrorHandler(errorHandler);\n\t\treturn this;\n\t}\n\n\tprotected void setApplicationContext(ApplicationContext applicationContext) {\n\t\tthis.stompHandler.setApplicationEventPublisher(applicationContext);\n\t}\n\n\t/**\n\t * Return a handler mapping with the mapped ViewControllers.\n\t */\n\tpublic AbstractHandlerMapping getHandlerMapping() {\n\t\tMap<String, Object> urlMap = new LinkedHashMap<>();\n\t\tfor (WebMvcStompWebSocketEndpointRegistration registration : this.registrations) {\n\t\t\tMultiValueMap<HttpRequestHandler, String> mappings = registration.getMappings();\n\t\t\tmappings.forEach((httpHandler, patterns) -> {\n\t\t\t\tfor (String pattern : patterns) {\n\t\t\t\t\turlMap.put(pattern, httpHandler);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tWebSocketHandlerMapping hm = new WebSocketHandlerMapping();\n\t\thm.setUrlMap(urlMap);\n\t\thm.setOrder(this.order);\n\t\tif (this.urlPathHelper != null) {\n\t\t\thm.setUrlPathHelper(this.urlPathHelper);\n\t\t}\n\t\treturn hm;\n\t}\n\n}"
  },
  "org.springframework.web.socket.config.annotation.WebMvcStompEndpointRegistry#addEndpoint(paths)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paths"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "StompWebSocketEndpointRegistration",
    "signature": "public StompWebSocketEndpointRegistration addEndpoint(String... paths)",
    "source_code": "\tpublic StompWebSocketEndpointRegistration addEndpoint(String... paths) {\n\t\tthis.subProtocolWebSocketHandler.addProtocolHandler(this.stompHandler);\n\t\tWebMvcStompWebSocketEndpointRegistration registration =\n\t\t\t\tnew WebMvcStompWebSocketEndpointRegistration(paths, this.webSocketHandler, this.sockJsScheduler);\n\t\tthis.registrations.add(registration);\n\t\treturn registration;\n\t}"
  },
  "org.springframework.web.socket.config.annotation.WebMvcStompEndpointRegistry#getHandlerMapping()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a handler mapping with the mapped ViewControllers.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "AbstractHandlerMapping",
    "signature": "public AbstractHandlerMapping getHandlerMapping()",
    "source_code": "\tpublic AbstractHandlerMapping getHandlerMapping() {\n\t\tMap<String, Object> urlMap = new LinkedHashMap<>();\n\t\tfor (WebMvcStompWebSocketEndpointRegistration registration : this.registrations) {\n\t\t\tMultiValueMap<HttpRequestHandler, String> mappings = registration.getMappings();\n\t\t\tmappings.forEach((httpHandler, patterns) -> {\n\t\t\t\tfor (String pattern : patterns) {\n\t\t\t\t\turlMap.put(pattern, httpHandler);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tWebSocketHandlerMapping hm = new WebSocketHandlerMapping();\n\t\thm.setUrlMap(urlMap);\n\t\thm.setOrder(this.order);\n\t\tif (this.urlPathHelper != null) {\n\t\t\thm.setUrlPathHelper(this.urlPathHelper);\n\t\t}\n\t\treturn hm;\n\t}"
  },
  "org.springframework.web.socket.config.annotation.WebMvcStompEndpointRegistry#getOrder()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "int",
    "signature": "protected int getOrder()",
    "source_code": "\tprotected int getOrder() {\n\t\treturn this.order;\n\t}"
  },
  "org.springframework.web.socket.config.annotation.WebMvcStompEndpointRegistry#getUrlPathHelper()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "UrlPathHelper",
    "signature": "protected UrlPathHelper getUrlPathHelper()",
    "source_code": "\tprotected UrlPathHelper getUrlPathHelper() {\n\t\treturn this.urlPathHelper;\n\t}"
  },
  "org.springframework.web.socket.config.annotation.WebMvcStompEndpointRegistry#setApplicationContext(applicationContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "applicationContext"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "void",
    "signature": "protected void setApplicationContext(ApplicationContext applicationContext)",
    "source_code": "\tprotected void setApplicationContext(ApplicationContext applicationContext) {\n\t\tthis.stompHandler.setApplicationEventPublisher(applicationContext);\n\t}"
  },
  "org.springframework.web.socket.config.annotation.WebMvcStompEndpointRegistry#setErrorHandler(errorHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorHandler"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "WebMvcStompEndpointRegistry",
    "signature": "public WebMvcStompEndpointRegistry setErrorHandler(StompSubProtocolErrorHandler errorHandler)",
    "source_code": "\tpublic WebMvcStompEndpointRegistry setErrorHandler(StompSubProtocolErrorHandler errorHandler) {\n\t\tthis.stompHandler.setErrorHandler(errorHandler);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.socket.config.annotation.WebMvcStompEndpointRegistry#setOrder(order)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the order for the resulting\n\t * {@link org.springframework.web.servlet.HandlerMapping}\n\t * relative to other handler mappings configured in Spring MVC.\n\t * <p>The default value is 1.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "order"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "void",
    "signature": "public void setOrder(int order)",
    "source_code": "\tpublic void setOrder(int order) {\n\t\tthis.order = order;\n\t}"
  },
  "org.springframework.web.socket.config.annotation.WebMvcStompEndpointRegistry#setUrlPathHelper(urlPathHelper)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the UrlPathHelper to configure on the {@code HandlerMapping}\n\t * used to map handshake requests.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "urlPathHelper"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "void",
    "signature": "public void setUrlPathHelper(@Nullable UrlPathHelper urlPathHelper)",
    "source_code": "\tpublic void setUrlPathHelper(@Nullable UrlPathHelper urlPathHelper) {\n\t\tthis.urlPathHelper = urlPathHelper;\n\t}"
  },
  "org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Extends {@link AbstractMessageBrokerConfiguration} and adds configuration for\n * receiving and responding to STOMP messages from WebSocket clients.\n *\n * <p>Typically used in conjunction with\n * {@link EnableWebSocketMessageBroker @EnableWebSocketMessageBroker} but can\n * also be extended directly.\n *\n * @author Rossen Stoyanchev\n * @author Artem Bilan\n * @author Sebastien Deleuze\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "signature": "public class WebSocketMessageBrokerConfigurationSupport",
    "source_code": "public abstract class WebSocketMessageBrokerConfigurationSupport extends AbstractMessageBrokerConfiguration {\n\n\t@Nullable\n\tprivate WebSocketTransportRegistration transportRegistration;\n\n\n\t@Override\n\tprotected SimpAnnotationMethodMessageHandler createAnnotationMethodMessageHandler(\n\t\t\tAbstractSubscribableChannel clientInboundChannel,AbstractSubscribableChannel clientOutboundChannel,\n\t\t\tSimpMessagingTemplate brokerMessagingTemplate) {\n\n\t\treturn new WebSocketAnnotationMethodMessageHandler(\n\t\t\t\tclientInboundChannel, clientOutboundChannel, brokerMessagingTemplate);\n\t}\n\n\t@Override\n\tprotected SimpUserRegistry createLocalUserRegistry(@Nullable Integer order) {\n\t\tDefaultSimpUserRegistry registry = new DefaultSimpUserRegistry();\n\t\tif (order != null) {\n\t\t\tregistry.setOrder(order);\n\t\t}\n\t\treturn registry;\n\t}\n\n\t@Bean\n\tpublic HandlerMapping stompWebSocketHandlerMapping(\n\t\t\tWebSocketHandler subProtocolWebSocketHandler, TaskScheduler messageBrokerTaskScheduler) {\n\n\t\tWebSocketHandler handler = decorateWebSocketHandler(subProtocolWebSocketHandler);\n\t\tWebMvcStompEndpointRegistry registry =\n\t\t\t\tnew WebMvcStompEndpointRegistry(handler, getTransportRegistration(), messageBrokerTaskScheduler);\n\t\tApplicationContext applicationContext = getApplicationContext();\n\t\tif (applicationContext != null) {\n\t\t\tregistry.setApplicationContext(applicationContext);\n\t\t}\n\t\tregisterStompEndpoints(registry);\n\t\treturn registry.getHandlerMapping();\n\t}\n\n\t@Bean\n\tpublic WebSocketHandler subProtocolWebSocketHandler(\n\t\t\tAbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel) {\n\n\t\treturn new SubProtocolWebSocketHandler(clientInboundChannel, clientOutboundChannel);\n\t}\n\n\tprotected WebSocketHandler decorateWebSocketHandler(WebSocketHandler handler) {\n\t\tfor (WebSocketHandlerDecoratorFactory factory : getTransportRegistration().getDecoratorFactories()) {\n\t\t\thandler = factory.decorate(handler);\n\t\t}\n\t\treturn handler;\n\t}\n\n\tprotected final WebSocketTransportRegistration getTransportRegistration() {\n\t\tif (this.transportRegistration == null) {\n\t\t\tthis.transportRegistration = new WebSocketTransportRegistration();\n\t\t\tconfigureWebSocketTransport(this.transportRegistration);\n\t\t}\n\t\treturn this.transportRegistration;\n\t}\n\n\tprotected void configureWebSocketTransport(WebSocketTransportRegistration registry) {\n\t}\n\n\tprotected abstract void registerStompEndpoints(StompEndpointRegistry registry);\n\n\t@Bean\n\tpublic static CustomScopeConfigurer webSocketScopeConfigurer() {\n\t\tCustomScopeConfigurer configurer = new CustomScopeConfigurer();\n\t\tconfigurer.addScope(\"websocket\", new SimpSessionScope());\n\t\treturn configurer;\n\t}\n\n\t@Bean\n\tpublic WebSocketMessageBrokerStats webSocketMessageBrokerStats(\n\t\t\t@Nullable AbstractBrokerMessageHandler stompBrokerRelayMessageHandler,\n\t\t\tWebSocketHandler subProtocolWebSocketHandler,\n\t\t\t@Qualifier(\"clientInboundChannelExecutor\") TaskExecutor inboundExecutor,\n\t\t\t@Qualifier(\"clientOutboundChannelExecutor\") TaskExecutor outboundExecutor,\n\t\t\t@Qualifier(\"messageBrokerTaskScheduler\") TaskScheduler scheduler) {\n\n\t\tWebSocketMessageBrokerStats stats = new WebSocketMessageBrokerStats();\n\t\tstats.setSubProtocolWebSocketHandler((SubProtocolWebSocketHandler) subProtocolWebSocketHandler);\n\t\tif (stompBrokerRelayMessageHandler instanceof StompBrokerRelayMessageHandler sbrmh) {\n\t\t\tstats.setStompBrokerRelay(sbrmh);\n\t\t}\n\t\tstats.setInboundChannelExecutor(inboundExecutor);\n\t\tstats.setOutboundChannelExecutor(outboundExecutor);\n\t\tstats.setSockJsTaskScheduler(scheduler);\n\t\treturn stats;\n\t}\n\n\t@Override\n\tprotected MappingJackson2MessageConverter createJacksonConverter() {\n\t\tMappingJackson2MessageConverter messageConverter = super.createJacksonConverter();\n\t\t// Use Jackson builder in order to have JSR-310 and Joda-Time modules registered automatically\n\t\tJackson2ObjectMapperBuilder builder = Jackson2ObjectMapperBuilder.json();\n\t\tApplicationContext applicationContext = getApplicationContext();\n\t\tif (applicationContext != null) {\n\t\t\tbuilder.applicationContext(applicationContext);\n\t\t}\n\t\tmessageConverter.setObjectMapper(builder.build());\n\t\treturn messageConverter;\n\t}\n\n}"
  },
  "org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport#configureWebSocketTransport(registry)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "void",
    "signature": "protected void configureWebSocketTransport(WebSocketTransportRegistration registry)",
    "source_code": "\tprotected void configureWebSocketTransport(WebSocketTransportRegistration registry) {\n\t}"
  },
  "org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport#createAnnotationMethodMessageHandler(clientInboundChannel,clientOutboundChannel,brokerMessagingTemplate)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel",
      "brokerMessagingTemplate"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "SimpAnnotationMethodMessageHandler",
    "signature": "protected SimpAnnotationMethodMessageHandler createAnnotationMethodMessageHandler(AbstractSubscribableChannel clientInboundChannel,AbstractSubscribableChannel clientOutboundChannel,\n\t\t\tSimpMessagingTemplate brokerMessagingTemplate)",
    "source_code": "\tprotected SimpAnnotationMethodMessageHandler createAnnotationMethodMessageHandler("
  },
  "org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport#createJacksonConverter()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "MappingJackson2MessageConverter",
    "signature": "protected MappingJackson2MessageConverter createJacksonConverter()",
    "source_code": "\tprotected MappingJackson2MessageConverter createJacksonConverter() {\n\t\tMappingJackson2MessageConverter messageConverter = super.createJacksonConverter();\n\t\t// Use Jackson builder in order to have JSR-310 and Joda-Time modules registered automatically\n\t\tJackson2ObjectMapperBuilder builder = Jackson2ObjectMapperBuilder.json();\n\t\tApplicationContext applicationContext = getApplicationContext();\n\t\tif (applicationContext != null) {\n\t\t\tbuilder.applicationContext(applicationContext);\n\t\t}\n\t\tmessageConverter.setObjectMapper(builder.build());\n\t\treturn messageConverter;\n\t}"
  },
  "org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport#createLocalUserRegistry(order)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "order"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "SimpUserRegistry",
    "signature": "protected SimpUserRegistry createLocalUserRegistry(@Nullable Integer order)",
    "source_code": "\tprotected SimpUserRegistry createLocalUserRegistry(@Nullable Integer order) {\n\t\tDefaultSimpUserRegistry registry = new DefaultSimpUserRegistry();\n\t\tif (order != null) {\n\t\t\tregistry.setOrder(order);\n\t\t}\n\t\treturn registry;\n\t}"
  },
  "org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport#decorateWebSocketHandler(handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "WebSocketHandler",
    "signature": "protected WebSocketHandler decorateWebSocketHandler(WebSocketHandler handler)",
    "source_code": "\tprotected WebSocketHandler decorateWebSocketHandler(WebSocketHandler handler) {\n\t\tfor (WebSocketHandlerDecoratorFactory factory : getTransportRegistration().getDecoratorFactories()) {\n\t\t\thandler = factory.decorate(handler);\n\t\t}\n\t\treturn handler;\n\t}"
  },
  "org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport#getTransportRegistration()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "WebSocketTransportRegistration",
    "signature": "protected WebSocketTransportRegistration getTransportRegistration()",
    "source_code": "\tprotected final WebSocketTransportRegistration getTransportRegistration() {\n\t\tif (this.transportRegistration == null) {\n\t\t\tthis.transportRegistration = new WebSocketTransportRegistration();\n\t\t\tconfigureWebSocketTransport(this.transportRegistration);\n\t\t}\n\t\treturn this.transportRegistration;\n\t}"
  },
  "org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport#registerStompEndpoints(registry)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "void",
    "signature": "protected void registerStompEndpoints(StompEndpointRegistry registry)",
    "source_code": "\tprotected abstract void registerStompEndpoints(StompEndpointRegistry registry);"
  },
  "org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport#stompWebSocketHandlerMapping(subProtocolWebSocketHandler,messageBrokerTaskScheduler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "subProtocolWebSocketHandler",
      "messageBrokerTaskScheduler"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "HandlerMapping",
    "signature": "public HandlerMapping stompWebSocketHandlerMapping(WebSocketHandler subProtocolWebSocketHandler, TaskScheduler messageBrokerTaskScheduler)",
    "source_code": "\tpublic HandlerMapping stompWebSocketHandlerMapping("
  },
  "org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport#subProtocolWebSocketHandler(clientInboundChannel,clientOutboundChannel)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "WebSocketHandler",
    "signature": "public WebSocketHandler subProtocolWebSocketHandler(AbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel)",
    "source_code": "\tpublic WebSocketHandler subProtocolWebSocketHandler("
  },
  "org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport#webSocketMessageBrokerStats(stompBrokerRelayMessageHandler,subProtocolWebSocketHandler,@Qualifier(\"clientInboundChannelExecutor\")": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "stompBrokerRelayMessageHandler",
      "subProtocolWebSocketHandler",
      "@Qualifier(\"clientInboundChannelExecutor\""
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "WebSocketMessageBrokerStats",
    "signature": "public WebSocketMessageBrokerStats webSocketMessageBrokerStats(@Nullable AbstractBrokerMessageHandler stompBrokerRelayMessageHandler,\n\t\t\tWebSocketHandler subProtocolWebSocketHandler,\n\t\t\t@Qualifier(\"clientInboundChannelExecutor\")",
    "source_code": "\tpublic WebSocketMessageBrokerStats webSocketMessageBrokerStats("
  },
  "org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport#webSocketScopeConfigurer()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "CustomScopeConfigurer",
    "signature": "public CustomScopeConfigurer webSocketScopeConfigurer()",
    "source_code": "\tpublic static CustomScopeConfigurer webSocketScopeConfigurer() {\n\t\tCustomScopeConfigurer configurer = new CustomScopeConfigurer();\n\t\tconfigurer.addScope(\"websocket\", new SimpSessionScope());\n\t\treturn configurer;\n\t}"
  },
  "org.springframework.web.socket.handler.AbstractWebSocketHandler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A convenient base class for {@link WebSocketHandler} implementation with empty methods.\n *\n * @author Rossen Stoyanchev\n * @author Phillip Webb\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 34
    },
    "signature": "public class AbstractWebSocketHandler",
    "source_code": "public abstract class AbstractWebSocketHandler implements WebSocketHandler {\n\n\t@Override\n\tpublic void afterConnectionEstablished(WebSocketSession session) throws Exception {\n\t}\n\n\t@Override\n\tpublic void handleMessage(WebSocketSession session, WebSocketMessage<?> message) throws Exception {\n\t\tif (message instanceof TextMessage textMessage) {\n\t\t\thandleTextMessage(session, textMessage);\n\t\t}\n\t\telse if (message instanceof BinaryMessage binaryMessage) {\n\t\t\thandleBinaryMessage(session, binaryMessage);\n\t\t}\n\t\telse if (message instanceof PongMessage pongMessage) {\n\t\t\thandlePongMessage(session, pongMessage);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\"Unexpected WebSocket message type: \" + message);\n\t\t}\n\t}\n\n\tprotected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {\n\t}\n\n\tprotected void handleBinaryMessage(WebSocketSession session, BinaryMessage message) throws Exception {\n\t}\n\n\tprotected void handlePongMessage(WebSocketSession session, PongMessage message) throws Exception {\n\t}\n\n\t@Override\n\tpublic void handleTransportError(WebSocketSession session, Throwable exception) throws Exception {\n\t}\n\n\t@Override\n\tpublic void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {\n\t}\n\n\t@Override\n\tpublic boolean supportsPartialMessages() {\n\t\treturn false;\n\t}\n\n}"
  },
  "org.springframework.web.socket.handler.AbstractWebSocketHandler#afterConnectionClosed(session,status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "status"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "void",
    "signature": "public void afterConnectionClosed(WebSocketSession session, CloseStatus status)",
    "source_code": "\tpublic void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {\n\t}"
  },
  "org.springframework.web.socket.handler.AbstractWebSocketHandler#afterConnectionEstablished(session)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "return": "void",
    "signature": "public void afterConnectionEstablished(WebSocketSession session)",
    "source_code": "\tpublic void afterConnectionEstablished(WebSocketSession session) throws Exception {\n\t}"
  },
  "org.springframework.web.socket.handler.AbstractWebSocketHandler#handleBinaryMessage(session,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "void",
    "signature": "protected void handleBinaryMessage(WebSocketSession session, BinaryMessage message)",
    "source_code": "\tprotected void handleBinaryMessage(WebSocketSession session, BinaryMessage message) throws Exception {\n\t}"
  },
  "org.springframework.web.socket.handler.AbstractWebSocketHandler#handleMessage(session,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "return": "void",
    "signature": "public void handleMessage(WebSocketSession session, WebSocketMessage<?> message)",
    "source_code": "\tpublic void handleMessage(WebSocketSession session, WebSocketMessage<?> message) throws Exception {\n\t\tif (message instanceof TextMessage textMessage) {\n\t\t\thandleTextMessage(session, textMessage);\n\t\t}\n\t\telse if (message instanceof BinaryMessage binaryMessage) {\n\t\t\thandleBinaryMessage(session, binaryMessage);\n\t\t}\n\t\telse if (message instanceof PongMessage pongMessage) {\n\t\t\thandlePongMessage(session, pongMessage);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\"Unexpected WebSocket message type: \" + message);\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.handler.AbstractWebSocketHandler#handlePongMessage(session,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "void",
    "signature": "protected void handlePongMessage(WebSocketSession session, PongMessage message)",
    "source_code": "\tprotected void handlePongMessage(WebSocketSession session, PongMessage message) throws Exception {\n\t}"
  },
  "org.springframework.web.socket.handler.AbstractWebSocketHandler#handleTextMessage(session,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "void",
    "signature": "protected void handleTextMessage(WebSocketSession session, TextMessage message)",
    "source_code": "\tprotected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {\n\t}"
  },
  "org.springframework.web.socket.handler.AbstractWebSocketHandler#handleTransportError(session,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "void",
    "signature": "public void handleTransportError(WebSocketSession session, Throwable exception)",
    "source_code": "\tpublic void handleTransportError(WebSocketSession session, Throwable exception) throws Exception {\n\t}"
  },
  "org.springframework.web.socket.handler.AbstractWebSocketHandler#supportsPartialMessages()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "boolean",
    "signature": "public boolean supportsPartialMessages()",
    "source_code": "\tpublic boolean supportsPartialMessages() {\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.socket.handler.BeanCreatingHandlerProvider": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Instantiates a target handler through a Spring {@link BeanFactory} and also provides\n * an equivalent destroy method. Mainly for internal use to assist with initializing and\n * destroying handlers with per-connection lifecycle.\n *\n * @author Rossen Stoyanchev\n * @since 4.0\n * @param <T> the handler type\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 35
    },
    "signature": "public class BeanCreatingHandlerProvider",
    "source_code": "public class BeanCreatingHandlerProvider<T> implements BeanFactoryAware {\n\n\tprivate final Class<? extends T> handlerType;\n\n\t@Nullable\n\tprivate AutowireCapableBeanFactory beanFactory;\n\n\n\tpublic BeanCreatingHandlerProvider(Class<? extends T> handlerType) {\n\t\tAssert.notNull(handlerType, \"handlerType must not be null\");\n\t\tthis.handlerType = handlerType;\n\t}\n\n\n\t@Override\n\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tif (beanFactory instanceof AutowireCapableBeanFactory autowireCapableBeanFactory) {\n\t\t\tthis.beanFactory = autowireCapableBeanFactory;\n\t\t}\n\t}\n\n\tpublic void destroy(T handler) {\n\t\tif (this.beanFactory != null) {\n\t\t\tthis.beanFactory.destroyBean(handler);\n\t\t}\n\t}\n\n\n\tpublic Class<? extends T> getHandlerType() {\n\t\treturn this.handlerType;\n\t}\n\n\tpublic T getHandler() {\n\t\tif (this.beanFactory != null) {\n\t\t\treturn this.beanFactory.createBean(this.handlerType);\n\t\t}\n\t\telse {\n\t\t\treturn BeanUtils.instantiateClass(this.handlerType);\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"BeanCreatingHandlerProvider[handlerType=\" + this.handlerType + \"]\";\n\t}\n\n}"
  },
  "org.springframework.web.socket.handler.BeanCreatingHandlerProvider#destroy(handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "void",
    "signature": "public void destroy(T handler)",
    "source_code": "\tpublic void destroy(T handler) {\n\t\tif (this.beanFactory != null) {\n\t\t\tthis.beanFactory.destroyBean(handler);\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.handler.BeanCreatingHandlerProvider#getHandler()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "T",
    "signature": "public T getHandler()",
    "source_code": "\tpublic T getHandler() {\n\t\tif (this.beanFactory != null) {\n\t\t\treturn this.beanFactory.createBean(this.handlerType);\n\t\t}\n\t\telse {\n\t\t\treturn BeanUtils.instantiateClass(this.handlerType);\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.handler.BeanCreatingHandlerProvider#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "return": "void",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tif (beanFactory instanceof AutowireCapableBeanFactory autowireCapableBeanFactory) {\n\t\t\tthis.beanFactory = autowireCapableBeanFactory;\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.handler.BeanCreatingHandlerProvider#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn \"BeanCreatingHandlerProvider[handlerType=\" + this.handlerType + \"]\";\n\t}"
  },
  "org.springframework.web.socket.handler.WebSocketHandlerDecorator": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Wraps another {@link org.springframework.web.socket.WebSocketHandler}\n * instance and delegates to it.\n *\n * <p>Also provides a {@link #getDelegate()} method to return the decorated\n * handler as well as a {@link #getLastHandler()} method to go through all nested\n * delegates and return the \"last\" handler.\n *\n * @author Rossen Stoyanchev\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 36
    },
    "signature": "public class WebSocketHandlerDecorator",
    "source_code": "public class WebSocketHandlerDecorator implements WebSocketHandler {\n\n\tprivate final WebSocketHandler delegate;\n\n\n\tpublic WebSocketHandlerDecorator(WebSocketHandler delegate) {\n\t\tAssert.notNull(delegate, \"Delegate must not be null\");\n\t\tthis.delegate = delegate;\n\t}\n\n\n\tpublic WebSocketHandler getDelegate() {\n\t\treturn this.delegate;\n\t}\n\n\tpublic WebSocketHandler getLastHandler() {\n\t\tWebSocketHandler result = this.delegate;\n\t\twhile (result instanceof WebSocketHandlerDecorator webSocketHandlerDecorator) {\n\t\t\tresult = webSocketHandlerDecorator.getDelegate();\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static WebSocketHandler unwrap(WebSocketHandler handler) {\n\t\tif (handler instanceof WebSocketHandlerDecorator webSocketHandlerDecorator) {\n\t\t\treturn webSocketHandlerDecorator.getLastHandler();\n\t\t}\n\t\telse {\n\t\t\treturn handler;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void afterConnectionEstablished(WebSocketSession session) throws Exception {\n\t\tthis.delegate.afterConnectionEstablished(session);\n\t}\n\n\t@Override\n\tpublic void handleMessage(WebSocketSession session, WebSocketMessage<?> message) throws Exception {\n\t\tthis.delegate.handleMessage(session, message);\n\t}\n\n\t@Override\n\tpublic void handleTransportError(WebSocketSession session, Throwable exception) throws Exception {\n\t\tthis.delegate.handleTransportError(session, exception);\n\t}\n\n\t@Override\n\tpublic void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) throws Exception {\n\t\tthis.delegate.afterConnectionClosed(session, closeStatus);\n\t}\n\n\t@Override\n\tpublic boolean supportsPartialMessages() {\n\t\treturn this.delegate.supportsPartialMessages();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \" [delegate=\" + this.delegate + \"]\";\n\t}\n\n}"
  },
  "org.springframework.web.socket.handler.WebSocketHandlerDecorator#afterConnectionClosed(session,closeStatus)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "closeStatus"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "void",
    "signature": "public void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus)",
    "source_code": "\tpublic void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) throws Exception {\n\t\tthis.delegate.afterConnectionClosed(session, closeStatus);\n\t}"
  },
  "org.springframework.web.socket.handler.WebSocketHandlerDecorator#afterConnectionEstablished(session)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "public void afterConnectionEstablished(WebSocketSession session)",
    "source_code": "\tpublic void afterConnectionEstablished(WebSocketSession session) throws Exception {\n\t\tthis.delegate.afterConnectionEstablished(session);\n\t}"
  },
  "org.springframework.web.socket.handler.WebSocketHandlerDecorator#getDelegate()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 47
    },
    "return": "WebSocketHandler",
    "signature": "public WebSocketHandler getDelegate()",
    "source_code": "\tpublic WebSocketHandler getDelegate() {\n\t\treturn this.delegate;\n\t}"
  },
  "org.springframework.web.socket.handler.WebSocketHandlerDecorator#getLastHandler()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 51
    },
    "return": "WebSocketHandler",
    "signature": "public WebSocketHandler getLastHandler()",
    "source_code": "\tpublic WebSocketHandler getLastHandler() {\n\t\tWebSocketHandler result = this.delegate;\n\t\twhile (result instanceof WebSocketHandlerDecorator webSocketHandlerDecorator) {\n\t\t\tresult = webSocketHandlerDecorator.getDelegate();\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.web.socket.handler.WebSocketHandlerDecorator#handleMessage(session,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "public void handleMessage(WebSocketSession session, WebSocketMessage<?> message)",
    "source_code": "\tpublic void handleMessage(WebSocketSession session, WebSocketMessage<?> message) throws Exception {\n\t\tthis.delegate.handleMessage(session, message);\n\t}"
  },
  "org.springframework.web.socket.handler.WebSocketHandlerDecorator#handleTransportError(session,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "public void handleTransportError(WebSocketSession session, Throwable exception)",
    "source_code": "\tpublic void handleTransportError(WebSocketSession session, Throwable exception) throws Exception {\n\t\tthis.delegate.handleTransportError(session, exception);\n\t}"
  },
  "org.springframework.web.socket.handler.WebSocketHandlerDecorator#supportsPartialMessages()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "boolean",
    "signature": "public boolean supportsPartialMessages()",
    "source_code": "\tpublic boolean supportsPartialMessages() {\n\t\treturn this.delegate.supportsPartialMessages();\n\t}"
  },
  "org.springframework.web.socket.handler.WebSocketHandlerDecorator#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \" [delegate=\" + this.delegate + \"]\";\n\t}"
  },
  "org.springframework.web.socket.handler.WebSocketHandlerDecorator#unwrap(handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "WebSocketHandler",
    "signature": "public WebSocketHandler unwrap(WebSocketHandler handler)",
    "source_code": "\tpublic static WebSocketHandler unwrap(WebSocketHandler handler) {\n\t\tif (handler instanceof WebSocketHandlerDecorator webSocketHandlerDecorator) {\n\t\t\treturn webSocketHandlerDecorator.getLastHandler();\n\t\t}\n\t\telse {\n\t\t\treturn handler;\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.handler.WebSocketSessionDecorator": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Wraps another {@link org.springframework.web.socket.WebSocketSession} instance\n * and delegates to it.\n *\n * <p>Also provides a {@link #getDelegate()} method to return the decorated session\n * as well as a {@link #getLastSession()} method to go through all nested delegates\n * and return the \"last\" session.\n *\n * @author Rossen Stoyanchev\n * @since 4.0.3\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "signature": "public class WebSocketSessionDecorator",
    "source_code": "public class WebSocketSessionDecorator implements WebSocketSession {\n\n\tprivate final WebSocketSession delegate;\n\n\n\tpublic WebSocketSessionDecorator(WebSocketSession session) {\n\t\tAssert.notNull(session, \"Delegate WebSocketSessionSession is required\");\n\t\tthis.delegate = session;\n\t}\n\n\n\tpublic WebSocketSession getDelegate() {\n\t\treturn this.delegate;\n\t}\n\n\tpublic WebSocketSession getLastSession() {\n\t\tWebSocketSession result = this.delegate;\n\t\twhile (result instanceof WebSocketSessionDecorator webSocketSessionDecorator) {\n\t\t\tresult = webSocketSessionDecorator.getDelegate();\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static WebSocketSession unwrap(WebSocketSession session) {\n\t\tif (session instanceof WebSocketSessionDecorator webSocketSessionDecorator) {\n\t\t\treturn webSocketSessionDecorator.getLastSession();\n\t\t}\n\t\telse {\n\t\t\treturn session;\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getId() {\n\t\treturn this.delegate.getId();\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic URI getUri() {\n\t\treturn this.delegate.getUri();\n\t}\n\n\t@Override\n\tpublic HttpHeaders getHandshakeHeaders() {\n\t\treturn this.delegate.getHandshakeHeaders();\n\t}\n\n\t@Override\n\tpublic Map<String, Object> getAttributes() {\n\t\treturn this.delegate.getAttributes();\n\t}\n\n\t@Override\n\tpublic Principal getPrincipal() {\n\t\treturn this.delegate.getPrincipal();\n\t}\n\n\t@Override\n\tpublic InetSocketAddress getLocalAddress() {\n\t\treturn this.delegate.getLocalAddress();\n\t}\n\n\t@Override\n\tpublic InetSocketAddress getRemoteAddress() {\n\t\treturn this.delegate.getRemoteAddress();\n\t}\n\n\t@Override\n\tpublic String getAcceptedProtocol() {\n\t\treturn this.delegate.getAcceptedProtocol();\n\t}\n\n\t@Override\n\tpublic List<WebSocketExtension> getExtensions() {\n\t\treturn this.delegate.getExtensions();\n\t}\n\n\t@Override\n\tpublic void setTextMessageSizeLimit(int messageSizeLimit) {\n\t\tthis.delegate.setTextMessageSizeLimit(messageSizeLimit);\n\t}\n\n\t@Override\n\tpublic int getTextMessageSizeLimit() {\n\t\treturn this.delegate.getTextMessageSizeLimit();\n\t}\n\n\t@Override\n\tpublic void setBinaryMessageSizeLimit(int messageSizeLimit) {\n\t\tthis.delegate.setBinaryMessageSizeLimit(messageSizeLimit);\n\t}\n\n\t@Override\n\tpublic int getBinaryMessageSizeLimit() {\n\t\treturn this.delegate.getBinaryMessageSizeLimit();\n\t}\n\n\t@Override\n\tpublic boolean isOpen() {\n\t\treturn this.delegate.isOpen();\n\t}\n\n\t@Override\n\tpublic void sendMessage(WebSocketMessage<?> message) throws IOException {\n\t\tthis.delegate.sendMessage(message);\n\t}\n\n\t@Override\n\tpublic void close() throws IOException {\n\t\tthis.delegate.close();\n\t}\n\n\t@Override\n\tpublic void close(CloseStatus status) throws IOException {\n\t\tthis.delegate.close(status);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \" [delegate=\" + this.delegate + \"]\";\n\t}\n\n}"
  },
  "org.springframework.web.socket.handler.WebSocketSessionDecorator#close()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\tpublic void close() throws IOException {\n\t\tthis.delegate.close();\n\t}"
  },
  "org.springframework.web.socket.handler.WebSocketSessionDecorator#close(status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "void",
    "signature": "public void close(CloseStatus status)",
    "source_code": "\tpublic void close(CloseStatus status) throws IOException {\n\t\tthis.delegate.close(status);\n\t}"
  },
  "org.springframework.web.socket.handler.WebSocketSessionDecorator#getAcceptedProtocol()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "String",
    "signature": "public String getAcceptedProtocol()",
    "source_code": "\tpublic String getAcceptedProtocol() {\n\t\treturn this.delegate.getAcceptedProtocol();\n\t}"
  },
  "org.springframework.web.socket.handler.WebSocketSessionDecorator#getAttributes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "Object>",
    "signature": "public Object> getAttributes()",
    "source_code": "\tpublic Map<String, Object> getAttributes() {\n\t\treturn this.delegate.getAttributes();\n\t}"
  },
  "org.springframework.web.socket.handler.WebSocketSessionDecorator#getBinaryMessageSizeLimit()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "int",
    "signature": "public int getBinaryMessageSizeLimit()",
    "source_code": "\tpublic int getBinaryMessageSizeLimit() {\n\t\treturn this.delegate.getBinaryMessageSizeLimit();\n\t}"
  },
  "org.springframework.web.socket.handler.WebSocketSessionDecorator#getDelegate()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "WebSocketSession",
    "signature": "public WebSocketSession getDelegate()",
    "source_code": "\tpublic WebSocketSession getDelegate() {\n\t\treturn this.delegate;\n\t}"
  },
  "org.springframework.web.socket.handler.WebSocketSessionDecorator#getExtensions()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "List<WebSocketExtension>",
    "signature": "public List<WebSocketExtension> getExtensions()",
    "source_code": "\tpublic List<WebSocketExtension> getExtensions() {\n\t\treturn this.delegate.getExtensions();\n\t}"
  },
  "org.springframework.web.socket.handler.WebSocketSessionDecorator#getHandshakeHeaders()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders getHandshakeHeaders()",
    "source_code": "\tpublic HttpHeaders getHandshakeHeaders() {\n\t\treturn this.delegate.getHandshakeHeaders();\n\t}"
  },
  "org.springframework.web.socket.handler.WebSocketSessionDecorator#getId()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "String",
    "signature": "public String getId()",
    "source_code": "\tpublic String getId() {\n\t\treturn this.delegate.getId();\n\t}"
  },
  "org.springframework.web.socket.handler.WebSocketSessionDecorator#getLastSession()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "WebSocketSession",
    "signature": "public WebSocketSession getLastSession()",
    "source_code": "\tpublic WebSocketSession getLastSession() {\n\t\tWebSocketSession result = this.delegate;\n\t\twhile (result instanceof WebSocketSessionDecorator webSocketSessionDecorator) {\n\t\t\tresult = webSocketSessionDecorator.getDelegate();\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.web.socket.handler.WebSocketSessionDecorator#getLocalAddress()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "InetSocketAddress",
    "signature": "public InetSocketAddress getLocalAddress()",
    "source_code": "\tpublic InetSocketAddress getLocalAddress() {\n\t\treturn this.delegate.getLocalAddress();\n\t}"
  },
  "org.springframework.web.socket.handler.WebSocketSessionDecorator#getPrincipal()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "Principal",
    "signature": "public Principal getPrincipal()",
    "source_code": "\tpublic Principal getPrincipal() {\n\t\treturn this.delegate.getPrincipal();\n\t}"
  },
  "org.springframework.web.socket.handler.WebSocketSessionDecorator#getRemoteAddress()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "InetSocketAddress",
    "signature": "public InetSocketAddress getRemoteAddress()",
    "source_code": "\tpublic InetSocketAddress getRemoteAddress() {\n\t\treturn this.delegate.getRemoteAddress();\n\t}"
  },
  "org.springframework.web.socket.handler.WebSocketSessionDecorator#getTextMessageSizeLimit()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "int",
    "signature": "public int getTextMessageSizeLimit()",
    "source_code": "\tpublic int getTextMessageSizeLimit() {\n\t\treturn this.delegate.getTextMessageSizeLimit();\n\t}"
  },
  "org.springframework.web.socket.handler.WebSocketSessionDecorator#getUri()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "URI",
    "signature": "public URI getUri()",
    "source_code": "\tpublic URI getUri() {\n\t\treturn this.delegate.getUri();\n\t}"
  },
  "org.springframework.web.socket.handler.WebSocketSessionDecorator#isOpen()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "boolean",
    "signature": "public boolean isOpen()",
    "source_code": "\tpublic boolean isOpen() {\n\t\treturn this.delegate.isOpen();\n\t}"
  },
  "org.springframework.web.socket.handler.WebSocketSessionDecorator#sendMessage(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "void",
    "signature": "public void sendMessage(WebSocketMessage<?> message)",
    "source_code": "\tpublic void sendMessage(WebSocketMessage<?> message) throws IOException {\n\t\tthis.delegate.sendMessage(message);\n\t}"
  },
  "org.springframework.web.socket.handler.WebSocketSessionDecorator#setBinaryMessageSizeLimit(messageSizeLimit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSizeLimit"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "void",
    "signature": "public void setBinaryMessageSizeLimit(int messageSizeLimit)",
    "source_code": "\tpublic void setBinaryMessageSizeLimit(int messageSizeLimit) {\n\t\tthis.delegate.setBinaryMessageSizeLimit(messageSizeLimit);\n\t}"
  },
  "org.springframework.web.socket.handler.WebSocketSessionDecorator#setTextMessageSizeLimit(messageSizeLimit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSizeLimit"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "void",
    "signature": "public void setTextMessageSizeLimit(int messageSizeLimit)",
    "source_code": "\tpublic void setTextMessageSizeLimit(int messageSizeLimit) {\n\t\tthis.delegate.setTextMessageSizeLimit(messageSizeLimit);\n\t}"
  },
  "org.springframework.web.socket.handler.WebSocketSessionDecorator#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \" [delegate=\" + this.delegate + \"]\";\n\t}"
  },
  "org.springframework.web.socket.handler.WebSocketSessionDecorator#unwrap(session)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "WebSocketSession",
    "signature": "public WebSocketSession unwrap(WebSocketSession session)",
    "source_code": "\tpublic static WebSocketSession unwrap(WebSocketSession session) {\n\t\tif (session instanceof WebSocketSessionDecorator webSocketSessionDecorator) {\n\t\t\treturn webSocketSessionDecorator.getLastSession();\n\t\t}\n\t\telse {\n\t\t\treturn session;\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A STOMP over WebSocket client that connects using an implementation of\n * {@link org.springframework.web.socket.client.WebSocketClient WebSocketClient}\n * including {@link org.springframework.web.socket.sockjs.client.SockJsClient\n * SockJsClient}.\n *\n * @author Rossen Stoyanchev\n * @since 4.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "signature": "public class WebSocketStompClient",
    "source_code": "public class WebSocketStompClient extends StompClientSupport implements SmartLifecycle {\n\n\tprivate static final Log logger = LogFactory.getLog(WebSocketStompClient.class);\n\n\tprivate final WebSocketClient webSocketClient;\n\n\tprivate int inboundMessageSizeLimit = 64 * 1024;\n\n\tprivate boolean autoStartup = true;\n\n\tprivate int phase = DEFAULT_PHASE;\n\n\tprivate volatile boolean running;\n\n\n\t/**\n\t * Class constructor. Sets {@link #setDefaultHeartbeat} to \"0,0\" but will\n\t * reset it back to the preferred \"10000,10000\" when a\n\t * {@link #setTaskScheduler} is configured.\n\t * @param webSocketClient the WebSocket client to connect with\n\t */\n\tpublic WebSocketStompClient(WebSocketClient webSocketClient) {\n\t\tAssert.notNull(webSocketClient, \"WebSocketClient is required\");\n\t\tthis.webSocketClient = webSocketClient;\n\t\tsetDefaultHeartbeat(new long[] {0, 0});\n\t}\n\n\n\t/**\n\t * Return the configured WebSocketClient.\n\t */\n\tpublic WebSocketClient getWebSocketClient() {\n\t\treturn this.webSocketClient;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t * <p>Also automatically sets the {@link #setDefaultHeartbeat defaultHeartbeat}\n\t * property to \"10000,10000\" if it is currently set to \"0,0\".\n\t */\n\t@Override\n\tpublic void setTaskScheduler(@Nullable TaskScheduler taskScheduler) {\n\t\tif (!isDefaultHeartbeatEnabled()) {\n\t\t\tsetDefaultHeartbeat(new long[] {10000, 10000});\n\t\t}\n\t\tsuper.setTaskScheduler(taskScheduler);\n\t}\n\n\t/**\n\t * Configure the maximum size allowed for inbound STOMP message.\n\t * Since a STOMP message can be received in multiple WebSocket messages,\n\t * buffering may be required and this property determines the maximum buffer\n\t * size per message.\n\t * <p>By default this is set to 64 * 1024 (64K).\n\t */\n\tpublic void setInboundMessageSizeLimit(int inboundMessageSizeLimit) {\n\t\tthis.inboundMessageSizeLimit = inboundMessageSizeLimit;\n\t}\n\n\t/**\n\t * Get the configured inbound message buffer size in bytes.\n\t */\n\tpublic int getInboundMessageSizeLimit() {\n\t\treturn this.inboundMessageSizeLimit;\n\t}\n\n\t/**\n\t * Set whether to auto-start the contained WebSocketClient when the Spring\n\t * context has been refreshed.\n\t * <p>Default is \"true\".\n\t */\n\tpublic void setAutoStartup(boolean autoStartup) {\n\t\tthis.autoStartup = autoStartup;\n\t}\n\n\t/**\n\t * Return the value for the 'autoStartup' property. If \"true\", this client\n\t * will automatically start and stop the contained WebSocketClient.\n\t */\n\t@Override\n\tpublic boolean isAutoStartup() {\n\t\treturn this.autoStartup;\n\t}\n\n\t/**\n\t * Specify the phase in which the WebSocket client should be started and\n\t * subsequently closed. The startup order proceeds from lowest to highest,\n\t * and the shutdown order is the reverse of that.\n\t * <p>By default this is Integer.MAX_VALUE meaning that the WebSocket client\n\t * is started as late as possible and stopped as soon as possible.\n\t */\n\tpublic void setPhase(int phase) {\n\t\tthis.phase = phase;\n\t}\n\n\t/**\n\t * Return the configured phase.\n\t */\n\t@Override\n\tpublic int getPhase() {\n\t\treturn this.phase;\n\t}\n\n\n\t@Override\n\tpublic void start() {\n\t\tif (!isRunning()) {\n\t\t\tthis.running = true;\n\t\t\tif (getWebSocketClient() instanceof Lifecycle lifecycle) {\n\t\t\t\tlifecycle.start();\n\t\t\t}\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic void stop() {\n\t\tif (isRunning()) {\n\t\t\tthis.running = false;\n\t\t\tif (getWebSocketClient() instanceof Lifecycle lifecycle) {\n\t\t\t\tlifecycle.stop();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isRunning() {\n\t\treturn this.running;\n\t}\n\n\n\t/**\n\t * Connect to the given WebSocket URL and notify the given\n\t * {@link org.springframework.messaging.simp.stomp.StompSessionHandler}\n\t * when connected on the STOMP level after the CONNECTED frame is received.\n\t * @param url the url to connect to\n\t * @param handler the session handler\n\t * @param uriVars the URI variables to expand into the URL\n\t * @return a {@code ListenableFuture} for access to the session when ready for use\n\t * @deprecated as of 6.0, in favor of {@link #connectAsync(String, StompSessionHandler, Object...)}\n\t */\n\t@Deprecated(since = \"6.0\")\n\tpublic org.springframework.util.concurrent.ListenableFuture<StompSession> connect(\n\t\t\tString url, StompSessionHandler handler, Object... uriVars) {\n\n\t\treturn new org.springframework.util.concurrent.CompletableToListenableFutureAdapter<>(\n\t\t\t\tconnectAsync(url, handler, uriVars));\n\t}\n\n\t/**\n\t * Connect to the given WebSocket URL and notify the given\n\t * {@link org.springframework.messaging.simp.stomp.StompSessionHandler}\n\t * when connected on the STOMP level after the CONNECTED frame is received.\n\t * @param url the url to connect to\n\t * @param handler the session handler\n\t * @param uriVars the URI variables to expand into the URL\n\t * @return a CompletableFuture for access to the session when ready for use\n\t * @since 6.0\n\t */\n\tpublic CompletableFuture<StompSession> connectAsync(String url, StompSessionHandler handler, Object... uriVars) {\n\t\treturn connectAsync(url, null, handler, uriVars);\n\t}\n\n\t/**\n\t * An overloaded version of\n\t * {@link #connect(String, StompSessionHandler, Object...)} that also\n\t * accepts {@link WebSocketHttpHeaders} to use for the WebSocket handshake.\n\t * @param url the url to connect to\n\t * @param handshakeHeaders the headers for the WebSocket handshake\n\t * @param handler the session handler\n\t * @param uriVariables the URI variables to expand into the URL\n\t * @return a {@code ListenableFuture} for access to the session when ready for use\n\t * @deprecated as of 6.0, in favor of {@link #connectAsync(String, WebSocketHttpHeaders, StompSessionHandler, Object...)}\n\t */\n\t@Deprecated(since = \"6.0\")\n\tpublic org.springframework.util.concurrent.ListenableFuture<StompSession> connect(\n\t\t\tString url, @Nullable WebSocketHttpHeaders handshakeHeaders,\n\t\t\tStompSessionHandler handler, Object... uriVariables) {\n\n\t\treturn new org.springframework.util.concurrent.CompletableToListenableFutureAdapter<>(\n\t\t\t\tconnectAsync(url, handshakeHeaders, null, handler, uriVariables));\n\t}\n\n\t/**\n\t * An overloaded version of\n\t * {@link #connect(String, StompSessionHandler, Object...)} that also\n\t * accepts {@link WebSocketHttpHeaders} to use for the WebSocket handshake.\n\t * @param url the url to connect to\n\t * @param handshakeHeaders the headers for the WebSocket handshake\n\t * @param handler the session handler\n\t * @param uriVariables the URI variables to expand into the URL\n\t * @return a {@code ListenableFuture} for access to the session when ready for use\n\t * @since 6.0\n\t */\n\tpublic CompletableFuture<StompSession> connectAsync(String url, @Nullable WebSocketHttpHeaders handshakeHeaders,\n\t\t\tStompSessionHandler handler, Object... uriVariables) {\n\n\t\treturn connectAsync(url, handshakeHeaders, null, handler, uriVariables);\n\t}\n\n\t/**\n\t * An overloaded version of\n\t * {@link #connect(String, StompSessionHandler, Object...)} that also accepts\n\t * {@link WebSocketHttpHeaders} to use for the WebSocket handshake and\n\t * {@link StompHeaders} for the STOMP CONNECT frame.\n\t * @param url the url to connect to\n\t * @param handshakeHeaders headers for the WebSocket handshake\n\t * @param connectHeaders headers for the STOMP CONNECT frame\n\t * @param handler the session handler\n\t * @param uriVariables the URI variables to expand into the URL\n\t * @return a {@code ListenableFuture} for access to the session when ready for use\n\t * @deprecated as of 6.0, in favor of {@link #connectAsync(String, WebSocketHttpHeaders, StompHeaders, StompSessionHandler, Object...)}\n\t */\n\t@Deprecated(since = \"6.0\")\n\tpublic org.springframework.util.concurrent.ListenableFuture<StompSession> connect(\n\t\t\tString url, @Nullable WebSocketHttpHeaders handshakeHeaders,\n\t\t\t@Nullable StompHeaders connectHeaders, StompSessionHandler handler, Object... uriVariables) {\n\n\t\treturn new org.springframework.util.concurrent.CompletableToListenableFutureAdapter<>(\n\t\t\t\tconnectAsync(url, handshakeHeaders, connectHeaders, handler, uriVariables));\n\t}\n\n\t/**\n\t * An overloaded version of\n\t * {@link #connect(String, StompSessionHandler, Object...)} that also accepts\n\t * {@link WebSocketHttpHeaders} to use for the WebSocket handshake and\n\t * {@link StompHeaders} for the STOMP CONNECT frame.\n\t * @param url the url to connect to\n\t * @param handshakeHeaders headers for the WebSocket handshake\n\t * @param connectHeaders headers for the STOMP CONNECT frame\n\t * @param handler the session handler\n\t * @param uriVariables the URI variables to expand into the URL\n\t * @return a CompletableFuture for access to the session when ready for use\n\t * @since 6.0\n\t */\n\tpublic CompletableFuture<StompSession> connectAsync(String url, @Nullable WebSocketHttpHeaders handshakeHeaders,\n\t\t\t@Nullable StompHeaders connectHeaders, StompSessionHandler handler, Object... uriVariables) {\n\n\t\tAssert.notNull(url, \"'url' must not be null\");\n\t\tURI uri = UriComponentsBuilder.fromUriString(url).buildAndExpand(uriVariables).encode().toUri();\n\t\treturn connectAsync(uri, handshakeHeaders, connectHeaders, handler);\n\t}\n\n\t/**\n\t * An overloaded version of\n\t * {@link #connect(String, WebSocketHttpHeaders, StompSessionHandler, Object...)}\n\t * that accepts a fully prepared {@link java.net.URI}.\n\t * @param url the url to connect to\n\t * @param handshakeHeaders the headers for the WebSocket handshake\n\t * @param connectHeaders headers for the STOMP CONNECT frame\n\t * @param sessionHandler the STOMP session handler\n\t * @return a {@code ListenableFuture} for access to the session when ready for use\n\t * @deprecated as of 6.0, in favor of {@link #connectAsync(URI, WebSocketHttpHeaders, StompHeaders, StompSessionHandler)}\n\t */\n\t@Deprecated(since = \"6.0\")\n\tpublic org.springframework.util.concurrent.ListenableFuture<StompSession> connect(\n\t\t\tURI url, @Nullable WebSocketHttpHeaders handshakeHeaders,\n\t\t\t@Nullable StompHeaders connectHeaders, StompSessionHandler sessionHandler) {\n\n\t\treturn new org.springframework.util.concurrent.CompletableToListenableFutureAdapter<>(\n\t\t\t\tconnectAsync(url, handshakeHeaders, connectHeaders, sessionHandler));\n\t}\n\n\t/**\n\t * An overloaded version of\n\t * {@link #connect(String, WebSocketHttpHeaders, StompSessionHandler, Object...)}\n\t * that accepts a fully prepared {@link java.net.URI}.\n\t * @param url the url to connect to\n\t * @param handshakeHeaders the headers for the WebSocket handshake\n\t * @param connectHeaders headers for the STOMP CONNECT frame\n\t * @param sessionHandler the STOMP session handler\n\t * @return a CompletableFuture for access to the session when ready for use\n\t * @since 6.0\n\t */\n\tpublic CompletableFuture<StompSession> connectAsync(URI url, @Nullable WebSocketHttpHeaders handshakeHeaders,\n\t\t\t@Nullable StompHeaders connectHeaders, StompSessionHandler sessionHandler) {\n\n\t\tAssert.notNull(url, \"'url' must not be null\");\n\t\tConnectionHandlingStompSession session = createSession(connectHeaders, sessionHandler);\n\t\tWebSocketTcpConnectionHandlerAdapter adapter = new WebSocketTcpConnectionHandlerAdapter(session);\n\t\tgetWebSocketClient()\n\t\t\t\t.execute(new LoggingWebSocketHandlerDecorator(adapter), handshakeHeaders, url)\n\t\t\t\t.whenComplete(adapter);\n\t\treturn session.getSession();\n\t}\n\n\t@Override\n\tprotected StompHeaders processConnectHeaders(@Nullable StompHeaders connectHeaders) {\n\t\tconnectHeaders = super.processConnectHeaders(connectHeaders);\n\t\tif (connectHeaders.isHeartbeatEnabled()) {\n\t\t\tAssert.state(getTaskScheduler() != null, \"TaskScheduler must be set if heartbeats are enabled\");\n\t\t}\n\t\treturn connectHeaders;\n\t}\n\n\n\t/**\n\t * Adapt WebSocket to the TcpConnectionHandler and TcpConnection contracts.\n\t */\n\tprivate class WebSocketTcpConnectionHandlerAdapter implements BiConsumer<WebSocketSession, Throwable>,\n\t\t\tWebSocketHandler, TcpConnection<byte[]> {\n\n\t\tprivate final TcpConnectionHandler<byte[]> connectionHandler;\n\n\t\tprivate final StompWebSocketMessageCodec codec = new StompWebSocketMessageCodec(getInboundMessageSizeLimit());\n\n\t\t@Nullable\n\t\tprivate volatile WebSocketSession session;\n\n\t\tprivate volatile long lastReadTime = -1;\n\n\t\tprivate volatile long lastWriteTime = -1;\n\n\t\tprivate final List<ScheduledFuture<?>> inactivityTasks = new ArrayList<>(2);\n\n\t\tpublic WebSocketTcpConnectionHandlerAdapter(TcpConnectionHandler<byte[]> connectionHandler) {\n\t\t\tAssert.notNull(connectionHandler, \"TcpConnectionHandler must not be null\");\n\t\t\tthis.connectionHandler = connectionHandler;\n\t\t}\n\n\t\t// CompletableFuture callback implementation: handshake outcome\n\n\t\t@Override\n\t\tpublic void accept(@Nullable WebSocketSession webSocketSession, @Nullable Throwable throwable) {\n\t\t\tif (throwable != null) {\n\t\t\t\tthis.connectionHandler.afterConnectFailure(throwable);\n\t\t\t}\n\t\t}\n\n\t\t// WebSocketHandler implementation\n\n\t\t@Override\n\t\tpublic void afterConnectionEstablished(WebSocketSession session) {\n\t\t\tthis.session = session;\n\t\t\tthis.connectionHandler.afterConnected(this);\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleMessage(WebSocketSession session, WebSocketMessage<?> webSocketMessage) {\n\t\t\tthis.lastReadTime = (this.lastReadTime != -1 ? System.currentTimeMillis() : -1);\n\t\t\tList<Message<byte[]>> messages;\n\t\t\ttry {\n\t\t\t\tmessages = this.codec.decode(webSocketMessage);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthis.connectionHandler.handleFailure(ex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (Message<byte[]> message : messages) {\n\t\t\t\tthis.connectionHandler.handleMessage(message);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleTransportError(WebSocketSession session, Throwable ex) throws Exception {\n\t\t\tthis.connectionHandler.handleFailure(ex);\n\t\t}\n\n\t\t@Override\n\t\tpublic void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) throws Exception {\n\t\t\tcancelInactivityTasks();\n\t\t\tthis.connectionHandler.afterConnectionClosed();\n\t\t}\n\n\t\tprivate void cancelInactivityTasks() {\n\t\t\tfor (ScheduledFuture<?> task : this.inactivityTasks) {\n\t\t\t\ttry {\n\t\t\t\t\ttask.cancel(true);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t// Ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.lastReadTime = -1;\n\t\t\tthis.lastWriteTime = -1;\n\t\t\tthis.inactivityTasks.clear();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean supportsPartialMessages() {\n\t\t\treturn false;\n\t\t}\n\n\t\t// TcpConnection implementation\n\n\t\t@Override\n\t\tpublic CompletableFuture<Void> sendAsync(Message<byte[]> message) {\n\t\t\tupdateLastWriteTime();\n\t\t\tCompletableFuture<Void> future = new CompletableFuture<>();\n\t\t\ttry {\n\t\t\t\tWebSocketSession session = this.session;\n\t\t\t\tAssert.state(session != null, \"No WebSocketSession available\");\n\t\t\t\tsession.sendMessage(this.codec.encode(message, session.getClass()));\n\t\t\t\tfuture.complete(null);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tfuture.completeExceptionally(ex);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tupdateLastWriteTime();\n\t\t\t}\n\t\t\treturn future;\n\t\t}\n\n\t\tprivate void updateLastWriteTime() {\n\t\t\tlong lastWriteTime = this.lastWriteTime;\n\t\t\tif (lastWriteTime != -1) {\n\t\t\t\tthis.lastWriteTime = System.currentTimeMillis();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void onReadInactivity(final Runnable runnable, final long duration) {\n\t\t\tAssert.state(getTaskScheduler() != null, \"No TaskScheduler configured\");\n\t\t\tthis.lastReadTime = System.currentTimeMillis();\n\t\t\tDuration delay = Duration.ofMillis(duration / 2);\n\t\t\tthis.inactivityTasks.add(getTaskScheduler().scheduleWithFixedDelay(() -> {\n\t\t\t\tif (System.currentTimeMillis() - this.lastReadTime > duration) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\trunnable.run();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"ReadInactivityTask failure\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, delay));\n\t\t}\n\n\t\t@Override\n\t\tpublic void onWriteInactivity(final Runnable runnable, final long duration) {\n\t\t\tAssert.state(getTaskScheduler() != null, \"No TaskScheduler configured\");\n\t\t\tthis.lastWriteTime = System.currentTimeMillis();\n\t\t\tDuration delay = Duration.ofMillis(duration / 2);\n\t\t\tthis.inactivityTasks.add(getTaskScheduler().scheduleWithFixedDelay(() -> {\n\t\t\t\tif (System.currentTimeMillis() - this.lastWriteTime > duration) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\trunnable.run();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"WriteInactivityTask failure\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, delay));\n\t\t}\n\n\t\t@Override\n\t\tpublic void close() {\n\t\t\tWebSocketSession session = this.session;\n\t\t\tif (session != null) {\n\t\t\t\ttry {\n\t\t\t\t\tsession.close();\n\t\t\t\t}\n\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Failed to close session: \" + session.getId(), ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Encode and decode STOMP WebSocket messages.\n\t */\n\tprivate static class StompWebSocketMessageCodec {\n\n\t\tprivate static final StompEncoder ENCODER = new StompEncoder();\n\n\t\tprivate static final StompDecoder DECODER = new StompDecoder();\n\n\t\tprivate final BufferingStompDecoder bufferingDecoder;\n\n\t\tpublic StompWebSocketMessageCodec(int messageSizeLimit) {\n\t\t\tthis.bufferingDecoder = new BufferingStompDecoder(DECODER, messageSizeLimit);\n\t\t}\n\n\t\tpublic List<Message<byte[]>> decode(WebSocketMessage<?> webSocketMessage) {\n\t\t\tList<Message<byte[]>> result = Collections.emptyList();\n\t\t\tByteBuffer byteBuffer;\n\t\t\tif (webSocketMessage instanceof TextMessage textMessage) {\n\t\t\t\tbyteBuffer = ByteBuffer.wrap(textMessage.asBytes());\n\t\t\t}\n\t\t\telse if (webSocketMessage instanceof BinaryMessage binaryMessage) {\n\t\t\t\tbyteBuffer = binaryMessage.getPayload();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tresult = this.bufferingDecoder.decode(byteBuffer);\n\t\t\tif (result.isEmpty()) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Incomplete STOMP frame content received, bufferSize=\" +\n\t\t\t\t\t\t\tthis.bufferingDecoder.getBufferSize() + \", bufferSizeLimit=\" +\n\t\t\t\t\t\t\tthis.bufferingDecoder.getBufferSizeLimit() + \".\");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic WebSocketMessage<?> encode(Message<byte[]> message, Class<? extends WebSocketSession> sessionType) {\n\t\t\tStompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);\n\t\t\tAssert.notNull(accessor, \"No StompHeaderAccessor available\");\n\t\t\tbyte[] payload = message.getPayload();\n\t\t\tbyte[] bytes = ENCODER.encode(accessor.getMessageHeaders(), payload);\n\n\t\t\tboolean useBinary = (payload.length > 0  &&\n\t\t\t\t\t!(SockJsSession.class.isAssignableFrom(sessionType)) &&\n\t\t\t\t\tMimeTypeUtils.APPLICATION_OCTET_STREAM.isCompatibleWith(accessor.getContentType()));\n\n\t\t\treturn (useBinary ? new BinaryMessage(bytes) : new TextMessage(bytes));\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#accept(webSocketSession,throwable)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webSocketSession",
      "throwable"
    ],
    "position": {
      "column": 1,
      "line": 396
    },
    "return": "void",
    "signature": "public void accept(@Nullable WebSocketSession webSocketSession, @Nullable Throwable throwable)",
    "source_code": "\t\tpublic void accept(@Nullable WebSocketSession webSocketSession, @Nullable Throwable throwable) {\n\t\t\tif (throwable != null) {\n\t\t\t\tthis.connectionHandler.afterConnectFailure(throwable);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#afterConnectionClosed(session,closeStatus)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "closeStatus"
    ],
    "position": {
      "column": 1,
      "line": 432
    },
    "return": "void",
    "signature": "public void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus)",
    "source_code": "\t\tpublic void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) throws Exception {\n\t\t\tcancelInactivityTasks();\n\t\t\tthis.connectionHandler.afterConnectionClosed();\n\t\t}"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#afterConnectionEstablished(session)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 405
    },
    "return": "void",
    "signature": "public void afterConnectionEstablished(WebSocketSession session)",
    "source_code": "\t\tpublic void afterConnectionEstablished(WebSocketSession session) {\n\t\t\tthis.session = session;\n\t\t\tthis.connectionHandler.afterConnected(this);\n\t\t}"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#close()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 523
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\t\tpublic void close() {\n\t\t\tWebSocketSession session = this.session;\n\t\t\tif (session != null) {\n\t\t\t\ttry {\n\t\t\t\t\tsession.close();\n\t\t\t\t}\n\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Failed to close session: \" + session.getId(), ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#connectAsync(url,handler,uriVars)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Connect to the given WebSocket URL and notify the given\n\t * {@link org.springframework.messaging.simp.stomp.StompSessionHandler}\n\t * when connected on the STOMP level after the CONNECTED frame is received.\n\t * @param url the url to connect to\n\t * @param handler the session handler\n\t * @param uriVars the URI variables to expand into the URL\n\t * @return a CompletableFuture for access to the session when ready for use\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "handler",
      "uriVars"
    ],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "CompletableFuture<StompSession>",
    "signature": "public CompletableFuture<StompSession> connectAsync(String url, StompSessionHandler handler, Object... uriVars)",
    "source_code": "\tpublic CompletableFuture<StompSession> connectAsync(String url, StompSessionHandler handler, Object... uriVars) {\n\t\treturn connectAsync(url, null, handler, uriVars);\n\t}"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#connectAsync(url,handshakeHeaders,connectHeaders,handler,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An overloaded version of\n\t * {@link #connect(String, StompSessionHandler, Object...)} that also accepts\n\t * {@link WebSocketHttpHeaders} to use for the WebSocket handshake and\n\t * {@link StompHeaders} for the STOMP CONNECT frame.\n\t * @param url the url to connect to\n\t * @param handshakeHeaders headers for the WebSocket handshake\n\t * @param connectHeaders headers for the STOMP CONNECT frame\n\t * @param handler the session handler\n\t * @param uriVariables the URI variables to expand into the URL\n\t * @return a CompletableFuture for access to the session when ready for use\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "handshakeHeaders",
      "connectHeaders",
      "handler",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "CompletableFuture<StompSession>",
    "signature": "public CompletableFuture<StompSession> connectAsync(String url, @Nullable WebSocketHttpHeaders handshakeHeaders,\n\t\t\t@Nullable StompHeaders connectHeaders, StompSessionHandler handler, Object... uriVariables)",
    "source_code": "\tpublic CompletableFuture<StompSession> connectAsync(String url, @Nullable WebSocketHttpHeaders handshakeHeaders,"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#connectAsync(url,handshakeHeaders,connectHeaders,sessionHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An overloaded version of\n\t * {@link #connect(String, WebSocketHttpHeaders, StompSessionHandler, Object...)}\n\t * that accepts a fully prepared {@link java.net.URI}.\n\t * @param url the url to connect to\n\t * @param handshakeHeaders the headers for the WebSocket handshake\n\t * @param connectHeaders headers for the STOMP CONNECT frame\n\t * @param sessionHandler the STOMP session handler\n\t * @return a CompletableFuture for access to the session when ready for use\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "handshakeHeaders",
      "connectHeaders",
      "sessionHandler"
    ],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "CompletableFuture<StompSession>",
    "signature": "public CompletableFuture<StompSession> connectAsync(URI url, @Nullable WebSocketHttpHeaders handshakeHeaders,\n\t\t\t@Nullable StompHeaders connectHeaders, StompSessionHandler sessionHandler)",
    "source_code": "\tpublic CompletableFuture<StompSession> connectAsync(URI url, @Nullable WebSocketHttpHeaders handshakeHeaders,"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#connectAsync(url,handshakeHeaders,handler,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An overloaded version of\n\t * {@link #connect(String, StompSessionHandler, Object...)} that also\n\t * accepts {@link WebSocketHttpHeaders} to use for the WebSocket handshake.\n\t * @param url the url to connect to\n\t * @param handshakeHeaders the headers for the WebSocket handshake\n\t * @param handler the session handler\n\t * @param uriVariables the URI variables to expand into the URL\n\t * @return a {@code ListenableFuture} for access to the session when ready for use\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "handshakeHeaders",
      "handler",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "CompletableFuture<StompSession>",
    "signature": "public CompletableFuture<StompSession> connectAsync(String url, @Nullable WebSocketHttpHeaders handshakeHeaders,\n\t\t\tStompSessionHandler handler, Object... uriVariables)",
    "source_code": "\tpublic CompletableFuture<StompSession> connectAsync(String url, @Nullable WebSocketHttpHeaders handshakeHeaders,"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#decode(webSocketMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webSocketMessage"
    ],
    "position": {
      "column": 1,
      "line": 554
    },
    "return": "List<Message<byte[]>>",
    "signature": "public List<Message<byte[]>> decode(WebSocketMessage<?> webSocketMessage)",
    "source_code": "\t\tpublic List<Message<byte[]>> decode(WebSocketMessage<?> webSocketMessage) {\n\t\t\tList<Message<byte[]>> result = Collections.emptyList();\n\t\t\tByteBuffer byteBuffer;\n\t\t\tif (webSocketMessage instanceof TextMessage textMessage) {\n\t\t\t\tbyteBuffer = ByteBuffer.wrap(textMessage.asBytes());\n\t\t\t}\n\t\t\telse if (webSocketMessage instanceof BinaryMessage binaryMessage) {\n\t\t\t\tbyteBuffer = binaryMessage.getPayload();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tresult = this.bufferingDecoder.decode(byteBuffer);\n\t\t\tif (result.isEmpty()) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Incomplete STOMP frame content received, bufferSize=\" +\n\t\t\t\t\t\t\tthis.bufferingDecoder.getBufferSize() + \", bufferSizeLimit=\" +\n\t\t\t\t\t\t\tthis.bufferingDecoder.getBufferSizeLimit() + \".\");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#getInboundMessageSizeLimit()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the configured inbound message buffer size in bytes.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "int",
    "signature": "public int getInboundMessageSizeLimit()",
    "source_code": "\tpublic int getInboundMessageSizeLimit() {\n\t\treturn this.inboundMessageSizeLimit;\n\t}"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#getPhase()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured phase.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "int",
    "signature": "public int getPhase()",
    "source_code": "\tpublic int getPhase() {\n\t\treturn this.phase;\n\t}"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#getWebSocketClient()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured WebSocketClient.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "WebSocketClient",
    "signature": "public WebSocketClient getWebSocketClient()",
    "source_code": "\tpublic WebSocketClient getWebSocketClient() {\n\t\treturn this.webSocketClient;\n\t}"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#handleMessage(session,webSocketMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "webSocketMessage"
    ],
    "position": {
      "column": 1,
      "line": 411
    },
    "return": "void",
    "signature": "public void handleMessage(WebSocketSession session, WebSocketMessage<?> webSocketMessage)",
    "source_code": "\t\tpublic void handleMessage(WebSocketSession session, WebSocketMessage<?> webSocketMessage) {\n\t\t\tthis.lastReadTime = (this.lastReadTime != -1 ? System.currentTimeMillis() : -1);\n\t\t\tList<Message<byte[]>> messages;\n\t\t\ttry {\n\t\t\t\tmessages = this.codec.decode(webSocketMessage);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthis.connectionHandler.handleFailure(ex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (Message<byte[]> message : messages) {\n\t\t\t\tthis.connectionHandler.handleMessage(message);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#handleTransportError(session,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 427
    },
    "return": "void",
    "signature": "public void handleTransportError(WebSocketSession session, Throwable ex)",
    "source_code": "\t\tpublic void handleTransportError(WebSocketSession session, Throwable ex) throws Exception {\n\t\t\tthis.connectionHandler.handleFailure(ex);\n\t\t}"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#isAutoStartup()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the value for the 'autoStartup' property. If \"true\", this client\n\t * will automatically start and stop the contained WebSocketClient.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "boolean",
    "signature": "public boolean isAutoStartup()",
    "source_code": "\tpublic boolean isAutoStartup() {\n\t\treturn this.autoStartup;\n\t}"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#isRunning()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "boolean",
    "signature": "public boolean isRunning()",
    "source_code": "\tpublic boolean isRunning() {\n\t\treturn this.running;\n\t}"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#onReadInactivity(runnable,duration)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runnable",
      "duration"
    ],
    "position": {
      "column": 1,
      "line": 485
    },
    "return": "void",
    "signature": "public void onReadInactivity(final Runnable runnable, final long duration)",
    "source_code": "\t\tpublic void onReadInactivity(final Runnable runnable, final long duration) {\n\t\t\tAssert.state(getTaskScheduler() != null, \"No TaskScheduler configured\");\n\t\t\tthis.lastReadTime = System.currentTimeMillis();\n\t\t\tDuration delay = Duration.ofMillis(duration / 2);\n\t\t\tthis.inactivityTasks.add(getTaskScheduler().scheduleWithFixedDelay(() -> {\n\t\t\t\tif (System.currentTimeMillis() - this.lastReadTime > duration) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\trunnable.run();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"ReadInactivityTask failure\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, delay));\n\t\t}"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#onWriteInactivity(runnable,duration)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runnable",
      "duration"
    ],
    "position": {
      "column": 1,
      "line": 504
    },
    "return": "void",
    "signature": "public void onWriteInactivity(final Runnable runnable, final long duration)",
    "source_code": "\t\tpublic void onWriteInactivity(final Runnable runnable, final long duration) {\n\t\t\tAssert.state(getTaskScheduler() != null, \"No TaskScheduler configured\");\n\t\t\tthis.lastWriteTime = System.currentTimeMillis();\n\t\t\tDuration delay = Duration.ofMillis(duration / 2);\n\t\t\tthis.inactivityTasks.add(getTaskScheduler().scheduleWithFixedDelay(() -> {\n\t\t\t\tif (System.currentTimeMillis() - this.lastWriteTime > duration) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\trunnable.run();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"WriteInactivityTask failure\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, delay));\n\t\t}"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#processConnectHeaders(connectHeaders)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "connectHeaders"
    ],
    "position": {
      "column": 1,
      "line": 360
    },
    "return": "StompHeaders",
    "signature": "protected StompHeaders processConnectHeaders(@Nullable StompHeaders connectHeaders)",
    "source_code": "\tprotected StompHeaders processConnectHeaders(@Nullable StompHeaders connectHeaders) {\n\t\tconnectHeaders = super.processConnectHeaders(connectHeaders);\n\t\tif (connectHeaders.isHeartbeatEnabled()) {\n\t\t\tAssert.state(getTaskScheduler() != null, \"TaskScheduler must be set if heartbeats are enabled\");\n\t\t}\n\t\treturn connectHeaders;\n\t}"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#sendAsync(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 459
    },
    "return": "CompletableFuture<Void>",
    "signature": "public CompletableFuture<Void> sendAsync(Message<byte[]> message)",
    "source_code": "\t\tpublic CompletableFuture<Void> sendAsync(Message<byte[]> message) {\n\t\t\tupdateLastWriteTime();\n\t\t\tCompletableFuture<Void> future = new CompletableFuture<>();\n\t\t\ttry {\n\t\t\t\tWebSocketSession session = this.session;\n\t\t\t\tAssert.state(session != null, \"No WebSocketSession available\");\n\t\t\t\tsession.sendMessage(this.codec.encode(message, session.getClass()));\n\t\t\t\tfuture.complete(null);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tfuture.completeExceptionally(ex);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tupdateLastWriteTime();\n\t\t\t}\n\t\t\treturn future;\n\t\t}"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#setAutoStartup(autoStartup)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to auto-start the contained WebSocketClient when the Spring\n\t * context has been refreshed.\n\t * <p>Default is \"true\".\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "autoStartup"
    ],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "void",
    "signature": "public void setAutoStartup(boolean autoStartup)",
    "source_code": "\tpublic void setAutoStartup(boolean autoStartup) {\n\t\tthis.autoStartup = autoStartup;\n\t}"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#setInboundMessageSizeLimit(inboundMessageSizeLimit)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the maximum size allowed for inbound STOMP message.\n\t * Since a STOMP message can be received in multiple WebSocket messages,\n\t * buffering may be required and this property determines the maximum buffer\n\t * size per message.\n\t * <p>By default this is set to 64 * 1024 (64K).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inboundMessageSizeLimit"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "void",
    "signature": "public void setInboundMessageSizeLimit(int inboundMessageSizeLimit)",
    "source_code": "\tpublic void setInboundMessageSizeLimit(int inboundMessageSizeLimit) {\n\t\tthis.inboundMessageSizeLimit = inboundMessageSizeLimit;\n\t}"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#setPhase(phase)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the phase in which the WebSocket client should be started and\n\t * subsequently closed. The startup order proceeds from lowest to highest,\n\t * and the shutdown order is the reverse of that.\n\t * <p>By default this is Integer.MAX_VALUE meaning that the WebSocket client\n\t * is started as late as possible and stopped as soon as possible.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "phase"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "void",
    "signature": "public void setPhase(int phase)",
    "source_code": "\tpublic void setPhase(int phase) {\n\t\tthis.phase = phase;\n\t}"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#setTaskScheduler(taskScheduler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p>Also automatically sets the {@link #setDefaultHeartbeat defaultHeartbeat}\n\t * property to \"10000,10000\" if it is currently set to \"0,0\".\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "taskScheduler"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "void",
    "signature": "public void setTaskScheduler(@Nullable TaskScheduler taskScheduler)",
    "source_code": "\tpublic void setTaskScheduler(@Nullable TaskScheduler taskScheduler) {\n\t\tif (!isDefaultHeartbeatEnabled()) {\n\t\t\tsetDefaultHeartbeat(new long[] {10000, 10000});\n\t\t}\n\t\tsuper.setTaskScheduler(taskScheduler);\n\t}"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#start()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "void",
    "signature": "public void start()",
    "source_code": "\tpublic void start() {\n\t\tif (!isRunning()) {\n\t\t\tthis.running = true;\n\t\t\tif (getWebSocketClient() instanceof Lifecycle lifecycle) {\n\t\t\t\tlifecycle.start();\n\t\t\t}\n\t\t}\n\n\t}"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#stop()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "void",
    "signature": "public void stop()",
    "source_code": "\tpublic void stop() {\n\t\tif (isRunning()) {\n\t\t\tthis.running = false;\n\t\t\tif (getWebSocketClient() instanceof Lifecycle lifecycle) {\n\t\t\t\tlifecycle.stop();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.messaging.WebSocketStompClient#supportsPartialMessages()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 452
    },
    "return": "boolean",
    "signature": "public boolean supportsPartialMessages()",
    "source_code": "\t\tpublic boolean supportsPartialMessages() {\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.web.socket.server.standard.WebLogicRequestUpgradeStrategy": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A WebSocket {@code RequestUpgradeStrategy} for Oracle's WebLogic.\n * Supports 12.1.3 as well as 12.2.1, as of Spring Framework 4.2.3.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 4.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "public class WebLogicRequestUpgradeStrategy",
    "source_code": "public class WebLogicRequestUpgradeStrategy extends AbstractTyrusRequestUpgradeStrategy {\n\n\tprivate static final TyrusMuxableWebSocketHelper webSocketHelper = new TyrusMuxableWebSocketHelper();\n\n\tprivate static final WebLogicServletWriterHelper servletWriterHelper = new WebLogicServletWriterHelper();\n\n\tprivate static final Connection.CloseListener noOpCloseListener = (reason -> {});\n\n\n\t@Override\n\tprotected void handleSuccess(HttpServletRequest request, HttpServletResponse response,\n\t\t\tUpgradeInfo upgradeInfo, TyrusUpgradeResponse upgradeResponse) throws IOException, ServletException {\n\n\t\tresponse.setStatus(upgradeResponse.getStatus());\n\t\tupgradeResponse.getHeaders().forEach((key, value) -> response.addHeader(key, Utils.getHeaderFromList(value)));\n\n\t\tAsyncContext asyncContext = request.startAsync();\n\t\tasyncContext.setTimeout(-1L);\n\n\t\tObject nativeRequest = getNativeRequest(request);\n\t\tBeanWrapper beanWrapper = new BeanWrapperImpl(nativeRequest);\n\t\tObject httpSocket = beanWrapper.getPropertyValue(\"connection.connectionHandler.rawConnection\");\n\t\tObject webSocket = webSocketHelper.newInstance(request, httpSocket);\n\t\twebSocketHelper.upgrade(webSocket, httpSocket, request.getServletContext());\n\n\t\tresponse.flushBuffer();\n\n\t\tboolean isProtected = request.getUserPrincipal() != null;\n\t\tWriter servletWriter = servletWriterHelper.newInstance(webSocket, isProtected);\n\t\tConnection connection = upgradeInfo.createConnection(servletWriter, noOpCloseListener);\n\t\tnew BeanWrapperImpl(webSocket).setPropertyValue(\"connection\", connection);\n\t\tnew BeanWrapperImpl(servletWriter).setPropertyValue(\"connection\", connection);\n\t\twebSocketHelper.registerForReadEvent(webSocket);\n\t}\n\n\n\tprivate static Class<?> type(String className) throws ClassNotFoundException {\n\t\treturn WebLogicRequestUpgradeStrategy.class.getClassLoader().loadClass(className);\n\t}\n\n\tprivate static Method method(String className, String method, Class<?>... paramTypes)\n\t\t\tthrows ClassNotFoundException, NoSuchMethodException {\n\n\t\treturn type(className).getDeclaredMethod(method, paramTypes);\n\t}\n\n\tprivate static Object getNativeRequest(ServletRequest request) {\n\t\twhile (request instanceof ServletRequestWrapper wrapper) {\n\t\t\trequest = wrapper.getRequest();\n\t\t}\n\t\treturn request;\n\t}\n\n\n\t/**\n\t * Helps to create and invoke {@code weblogic.servlet.internal.MuxableSocketHTTP}.\n\t */\n\tprivate static class TyrusMuxableWebSocketHelper {\n\n\t\tprivate static final Class<?> type;\n\n\t\tprivate static final Constructor<?> constructor;\n\n\t\tprivate static final SubjectHelper subjectHelper;\n\n\t\tprivate static final Method upgradeMethod;\n\n\t\tprivate static final Method readEventMethod;\n\n\t\tstatic {\n\t\t\ttry {\n\t\t\t\ttype = type(\"weblogic.websocket.tyrus.TyrusMuxableWebSocket\");\n\n\t\t\t\tconstructor = type.getDeclaredConstructor(\n\t\t\t\t\t\ttype(\"weblogic.servlet.internal.MuxableSocketHTTP\"),\n\t\t\t\t\t\ttype(\"weblogic.websocket.tyrus.CoherenceServletFilterService\"),\n\t\t\t\t\t\ttype(\"weblogic.servlet.spi.SubjectHandle\"));\n\t\t\t\tsubjectHelper = new SubjectHelper();\n\n\t\t\t\tupgradeMethod = type.getMethod(\"upgrade\", type(\"weblogic.socket.MuxableSocket\"), ServletContext.class);\n\t\t\t\treadEventMethod = type.getMethod(\"registerForReadEvent\");\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new IllegalStateException(\"No compatible WebSocket version found\", ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate Object newInstance(HttpServletRequest request, @Nullable Object httpSocket) {\n\t\t\ttry {\n\t\t\t\tObject[] args = new Object[] {httpSocket, null, subjectHelper.getSubject(request)};\n\t\t\t\treturn constructor.newInstance(args);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new HandshakeFailureException(\"Failed to create TyrusMuxableWebSocket\", ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate void upgrade(Object webSocket, @Nullable Object httpSocket, ServletContext servletContext) {\n\t\t\ttry {\n\t\t\t\tupgradeMethod.invoke(webSocket, httpSocket, servletContext);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new HandshakeFailureException(\"Failed to upgrade TyrusMuxableWebSocket\", ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate void registerForReadEvent(Object webSocket) {\n\t\t\ttry {\n\t\t\t\treadEventMethod.invoke(webSocket);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new HandshakeFailureException(\"Failed to register WebSocket for read event\", ex);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate static class SubjectHelper {\n\n\t\tprivate final Method securityContextMethod;\n\n\t\tprivate final Method currentUserMethod;\n\n\t\tprivate final Method providerMethod;\n\n\t\tprivate final Method anonymousSubjectMethod;\n\n\t\tpublic SubjectHelper() {\n\t\t\ttry {\n\t\t\t\tString className = \"weblogic.servlet.internal.WebAppServletContext\";\n\t\t\t\tthis.securityContextMethod = method(className, \"getSecurityContext\");\n\n\t\t\t\tclassName = \"weblogic.servlet.security.internal.SecurityModule\";\n\t\t\t\tthis.currentUserMethod = method(className, \"getCurrentUser\",\n\t\t\t\t\t\ttype(\"weblogic.servlet.security.internal.ServletSecurityContext\"),\n\t\t\t\t\t\tHttpServletRequest.class);\n\n\t\t\t\tclassName = \"weblogic.servlet.security.internal.WebAppSecurity\";\n\t\t\t\tthis.providerMethod = method(className, \"getProvider\");\n\t\t\t\tthis.anonymousSubjectMethod = this.providerMethod.getReturnType().getDeclaredMethod(\"getAnonymousSubject\");\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new IllegalStateException(\"No compatible WebSocket version found\", ex);\n\t\t\t}\n\t\t}\n\n\t\tpublic Object getSubject(HttpServletRequest request) {\n\t\t\ttry {\n\t\t\t\tServletContext servletContext = request.getServletContext();\n\t\t\t\tObject securityContext = this.securityContextMethod.invoke(servletContext);\n\t\t\t\tObject subject = this.currentUserMethod.invoke(null, securityContext, request);\n\t\t\t\tif (subject == null) {\n\t\t\t\t\tObject securityProvider = this.providerMethod.invoke(null);\n\t\t\t\t\tsubject = this.anonymousSubjectMethod.invoke(securityProvider);\n\t\t\t\t}\n\t\t\t\treturn subject;\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new HandshakeFailureException(\"Failed to obtain SubjectHandle\", ex);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Helps to create and invoke {@code weblogic.websocket.tyrus.TyrusServletWriter}.\n\t */\n\tprivate static class WebLogicServletWriterHelper {\n\n\t\tprivate static final Constructor<?> constructor;\n\n\t\tstatic {\n\t\t\ttry {\n\t\t\t\tClass<?> writerType = type(\"weblogic.websocket.tyrus.TyrusServletWriter\");\n\t\t\t\tClass<?> listenerType = type(\"weblogic.websocket.tyrus.TyrusServletWriter$CloseListener\");\n\t\t\t\tClass<?> webSocketType = TyrusMuxableWebSocketHelper.type;\n\t\t\t\tconstructor = writerType.getDeclaredConstructor(webSocketType, listenerType, boolean.class);\n\t\t\t\tReflectionUtils.makeAccessible(constructor);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new IllegalStateException(\"No compatible WebSocket version found\", ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate Writer newInstance(Object webSocket, boolean isProtected) {\n\t\t\ttry {\n\t\t\t\treturn (Writer) constructor.newInstance(webSocket, null, isProtected);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new HandshakeFailureException(\"Failed to create TyrusServletWriter\", ex);\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.socket.server.standard.WebLogicRequestUpgradeStrategy#getSubject(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "Object",
    "signature": "public Object getSubject(HttpServletRequest request)",
    "source_code": "\t\tpublic Object getSubject(HttpServletRequest request) {\n\t\t\ttry {\n\t\t\t\tServletContext servletContext = request.getServletContext();\n\t\t\t\tObject securityContext = this.securityContextMethod.invoke(servletContext);\n\t\t\t\tObject subject = this.currentUserMethod.invoke(null, securityContext, request);\n\t\t\t\tif (subject == null) {\n\t\t\t\t\tObject securityProvider = this.providerMethod.invoke(null);\n\t\t\t\t\tsubject = this.anonymousSubjectMethod.invoke(securityProvider);\n\t\t\t\t}\n\t\t\t\treturn subject;\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new HandshakeFailureException(\"Failed to obtain SubjectHandle\", ex);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.socket.server.standard.WebLogicRequestUpgradeStrategy#handleSuccess(request,response,upgradeInfo,upgradeResponse)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "upgradeInfo",
      "upgradeResponse"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "void",
    "signature": "protected void handleSuccess(HttpServletRequest request, HttpServletResponse response,\n\t\t\tUpgradeInfo upgradeInfo, TyrusUpgradeResponse upgradeResponse)",
    "source_code": "\tprotected void handleSuccess(HttpServletRequest request, HttpServletResponse response,"
  },
  "org.springframework.web.socket.server.support.AbstractHandshakeHandler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A base class for {@link HandshakeHandler} implementations, independent of the Servlet API.\n *\n * <p>Performs initial validation of the WebSocket handshake request - possibly rejecting it\n * through the appropriate HTTP status code - while also allowing its subclasses to override\n * various parts of the negotiation process (e.g. origin validation, sub-protocol negotiation,\n * extensions negotiation, etc).\n *\n * <p>If the negotiation succeeds, the actual upgrade is delegated to a server-specific\n * {@link org.springframework.web.socket.server.RequestUpgradeStrategy}, which will update\n * the response as necessary and initialize the WebSocket. Currently, supported servers are\n * Jetty 9.0-9.3, Tomcat 7.0.47+ and 8.x, Undertow 1.0-1.3, GlassFish 4.1+, WebLogic 12.1.3+.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 4.2\n * @see org.springframework.web.socket.server.jetty.JettyRequestUpgradeStrategy\n * @see org.springframework.web.socket.server.standard.TomcatRequestUpgradeStrategy\n * @see org.springframework.web.socket.server.standard.UndertowRequestUpgradeStrategy\n * @see org.springframework.web.socket.server.standard.GlassFishRequestUpgradeStrategy\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "signature": "public class AbstractHandshakeHandler",
    "source_code": "public abstract class AbstractHandshakeHandler implements HandshakeHandler, Lifecycle {\n\n\tprivate static final boolean tomcatWsPresent;\n\n\tprivate static final boolean jettyWsPresent;\n\n\tprivate static final boolean undertowWsPresent;\n\n\tprivate static final boolean glassfishWsPresent;\n\n\tprivate static final boolean weblogicWsPresent;\n\n\tprivate static final boolean websphereWsPresent;\n\n\tstatic {\n\t\tClassLoader classLoader = AbstractHandshakeHandler.class.getClassLoader();\n\t\ttomcatWsPresent = ClassUtils.isPresent(\n\t\t\t\t\"org.apache.tomcat.websocket.server.WsHttpUpgradeHandler\", classLoader);\n\t\tjettyWsPresent = ClassUtils.isPresent(\n\t\t\t\t\"org.eclipse.jetty.websocket.server.JettyWebSocketServerContainer\", classLoader);\n\t\tundertowWsPresent = ClassUtils.isPresent(\n\t\t\t\t\"io.undertow.websockets.jsr.ServerWebSocketContainer\", classLoader);\n\t\tglassfishWsPresent = ClassUtils.isPresent(\n\t\t\t\t\"org.glassfish.tyrus.servlet.TyrusHttpUpgradeHandler\", classLoader);\n\t\tweblogicWsPresent = ClassUtils.isPresent(\n\t\t\t\t\"weblogic.websocket.tyrus.TyrusServletWriter\", classLoader);\n\t\twebsphereWsPresent = ClassUtils.isPresent(\n\t\t\t\t\"com.ibm.websphere.wsoc.WsWsocServerContainer\", classLoader);\n\t}\n\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\tprivate final RequestUpgradeStrategy requestUpgradeStrategy;\n\n\tprivate final List<String> supportedProtocols = new ArrayList<>();\n\n\tprivate volatile boolean running;\n\n\n\t/**\n\t * Default constructor that auto-detects and instantiates a\n\t * {@link RequestUpgradeStrategy} suitable for the runtime container.\n\t * @throws IllegalStateException if no {@link RequestUpgradeStrategy} can be found.\n\t */\n\tprotected AbstractHandshakeHandler() {\n\t\tthis(initRequestUpgradeStrategy());\n\t}\n\n\t/**\n\t * A constructor that accepts a runtime-specific {@link RequestUpgradeStrategy}.\n\t * @param requestUpgradeStrategy the upgrade strategy to use\n\t */\n\tprotected AbstractHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy) {\n\t\tAssert.notNull(requestUpgradeStrategy, \"RequestUpgradeStrategy must not be null\");\n\t\tthis.requestUpgradeStrategy = requestUpgradeStrategy;\n\t}\n\n\n\t/**\n\t * Return the {@link RequestUpgradeStrategy} for WebSocket requests.\n\t */\n\tpublic RequestUpgradeStrategy getRequestUpgradeStrategy() {\n\t\treturn this.requestUpgradeStrategy;\n\t}\n\n\t/**\n\t * Use this property to configure the list of supported sub-protocols.\n\t * The first configured sub-protocol that matches a client-requested sub-protocol\n\t * is accepted. If there are no matches the response will not contain a\n\t * {@literal Sec-WebSocket-Protocol} header.\n\t * <p>Note that if the WebSocketHandler passed in at runtime is an instance of\n\t * {@link SubProtocolCapable} then there is no need to explicitly configure\n\t * this property. That is certainly the case with the built-in STOMP over\n\t * WebSocket support. Therefore, this property should be configured explicitly\n\t * only if the WebSocketHandler does not implement {@code SubProtocolCapable}.\n\t */\n\tpublic void setSupportedProtocols(String... protocols) {\n\t\tthis.supportedProtocols.clear();\n\t\tfor (String protocol : protocols) {\n\t\t\tthis.supportedProtocols.add(protocol.toLowerCase());\n\t\t}\n\t}\n\n\t/**\n\t * Return the list of supported sub-protocols.\n\t */\n\tpublic String[] getSupportedProtocols() {\n\t\treturn StringUtils.toStringArray(this.supportedProtocols);\n\t}\n\n\n\t@Override\n\tpublic void start() {\n\t\tif (!isRunning()) {\n\t\t\tthis.running = true;\n\t\t\tdoStart();\n\t\t}\n\t}\n\n\tprotected void doStart() {\n\t\tif (this.requestUpgradeStrategy instanceof Lifecycle lifecycle) {\n\t\t\tlifecycle.start();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void stop() {\n\t\tif (isRunning()) {\n\t\t\tthis.running = false;\n\t\t\tdoStop();\n\t\t}\n\t}\n\n\tprotected void doStop() {\n\t\tif (this.requestUpgradeStrategy instanceof Lifecycle lifecycle) {\n\t\t\tlifecycle.stop();\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isRunning() {\n\t\treturn this.running;\n\t}\n\n\n\t@Override\n\tpublic final boolean doHandshake(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, Map<String, Object> attributes) throws HandshakeFailureException {\n\n\t\tWebSocketHttpHeaders headers = new WebSocketHttpHeaders(request.getHeaders());\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Processing request \" + request.getURI() + \" with headers=\" + headers);\n\t\t}\n\t\ttry {\n\t\t\tif (HttpMethod.GET != request.getMethod()) {\n\t\t\t\tresponse.setStatusCode(HttpStatus.METHOD_NOT_ALLOWED);\n\t\t\t\tresponse.getHeaders().setAllow(Collections.singleton(HttpMethod.GET));\n\t\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\t\tlogger.error(\"Handshake failed due to unexpected HTTP method: \" + request.getMethod());\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!\"WebSocket\".equalsIgnoreCase(headers.getUpgrade())) {\n\t\t\t\thandleInvalidUpgradeHeader(request, response);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!headers.getConnection().contains(\"Upgrade\") && !headers.getConnection().contains(\"upgrade\")) {\n\t\t\t\thandleInvalidConnectHeader(request, response);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!isWebSocketVersionSupported(headers)) {\n\t\t\t\thandleWebSocketVersionNotSupported(request, response);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!isValidOrigin(request)) {\n\t\t\t\tresponse.setStatusCode(HttpStatus.FORBIDDEN);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tString wsKey = headers.getSecWebSocketKey();\n\t\t\tif (wsKey == null) {\n\t\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\t\tlogger.error(\"Missing \\\"Sec-WebSocket-Key\\\" header\");\n\t\t\t\t}\n\t\t\t\tresponse.setStatusCode(HttpStatus.BAD_REQUEST);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new HandshakeFailureException(\n\t\t\t\t\t\"Response update failed during upgrade to WebSocket: \" + request.getURI(), ex);\n\t\t}\n\n\t\tString subProtocol = selectProtocol(headers.getSecWebSocketProtocol(), wsHandler);\n\t\tList<WebSocketExtension> requested = headers.getSecWebSocketExtensions();\n\t\tList<WebSocketExtension> supported = this.requestUpgradeStrategy.getSupportedExtensions(request);\n\t\tList<WebSocketExtension> extensions = filterRequestedExtensions(request, requested, supported);\n\t\tPrincipal user = determineUser(request, wsHandler, attributes);\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Upgrading to WebSocket, subProtocol=\" + subProtocol + \", extensions=\" + extensions);\n\t\t}\n\t\tthis.requestUpgradeStrategy.upgrade(request, response, subProtocol, extensions, user, wsHandler, attributes);\n\t\treturn true;\n\t}\n\n\tprotected void handleInvalidUpgradeHeader(ServerHttpRequest request, ServerHttpResponse response) throws IOException {\n\t\tif (logger.isErrorEnabled()) {\n\t\t\tlogger.error(LogFormatUtils.formatValue(\n\t\t\t\t\t\"Handshake failed due to invalid Upgrade header: \" + request.getHeaders().getUpgrade(), -1, true));\n\t\t}\n\t\tresponse.setStatusCode(HttpStatus.BAD_REQUEST);\n\t\tresponse.getBody().write(\"Can \\\"Upgrade\\\" only to \\\"WebSocket\\\".\".getBytes(StandardCharsets.UTF_8));\n\t}\n\n\tprotected void handleInvalidConnectHeader(ServerHttpRequest request, ServerHttpResponse response) throws IOException {\n\t\tif (logger.isErrorEnabled()) {\n\t\t\tlogger.error(LogFormatUtils.formatValue(\n\t\t\t\t\t\"Handshake failed due to invalid Connection header\" + request.getHeaders().getConnection(), -1, true));\n\t\t}\n\t\tresponse.setStatusCode(HttpStatus.BAD_REQUEST);\n\t\tresponse.getBody().write(\"\\\"Connection\\\" must be \\\"upgrade\\\".\".getBytes(StandardCharsets.UTF_8));\n\t}\n\n\tprotected boolean isWebSocketVersionSupported(WebSocketHttpHeaders httpHeaders) {\n\t\tString version = httpHeaders.getSecWebSocketVersion();\n\t\tString[] supportedVersions = getSupportedVersions();\n\t\tfor (String supportedVersion : supportedVersions) {\n\t\t\tif (supportedVersion.trim().equals(version)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprotected String[] getSupportedVersions() {\n\t\treturn this.requestUpgradeStrategy.getSupportedVersions();\n\t}\n\n\tprotected void handleWebSocketVersionNotSupported(ServerHttpRequest request, ServerHttpResponse response) {\n\t\tif (logger.isErrorEnabled()) {\n\t\t\tString version = request.getHeaders().getFirst(\"Sec-WebSocket-Version\");\n\t\t\tlogger.error(LogFormatUtils.formatValue(\n\t\t\t\t\t\"Handshake failed due to unsupported WebSocket version: \" + version +\n\t\t\t\t\t\t\t\". Supported versions: \" + Arrays.toString(getSupportedVersions()), -1, true));\n\t\t}\n\t\tresponse.setStatusCode(HttpStatus.UPGRADE_REQUIRED);\n\t\tresponse.getHeaders().set(WebSocketHttpHeaders.SEC_WEBSOCKET_VERSION,\n\t\t\t\tStringUtils.arrayToCommaDelimitedString(getSupportedVersions()));\n\t}\n\n\t/**\n\t * Return whether the request {@code Origin} header value is valid or not.\n\t * By default, all origins as considered as valid. Consider using an\n\t * {@link OriginHandshakeInterceptor} for filtering origins if needed.\n\t */\n\tprotected boolean isValidOrigin(ServerHttpRequest request) {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Perform the sub-protocol negotiation based on requested and supported sub-protocols.\n\t * For the list of supported sub-protocols, this method first checks if the target\n\t * WebSocketHandler is a {@link SubProtocolCapable} and then also checks if any\n\t * sub-protocols have been explicitly configured with\n\t * {@link #setSupportedProtocols(String...)}.\n\t * @param requestedProtocols the requested sub-protocols\n\t * @param webSocketHandler the WebSocketHandler that will be used\n\t * @return the selected protocols or {@code null}\n\t * @see #determineHandlerSupportedProtocols(WebSocketHandler)\n\t */\n\t@Nullable\n\tprotected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler) {\n\t\tList<String> handlerProtocols = determineHandlerSupportedProtocols(webSocketHandler);\n\t\tfor (String protocol : requestedProtocols) {\n\t\t\tif (handlerProtocols.contains(protocol.toLowerCase())) {\n\t\t\t\treturn protocol;\n\t\t\t}\n\t\t\tif (this.supportedProtocols.contains(protocol.toLowerCase())) {\n\t\t\t\treturn protocol;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Determine the sub-protocols supported by the given WebSocketHandler by\n\t * checking whether it is an instance of {@link SubProtocolCapable}.\n\t * @param handler the handler to check\n\t * @return a list of supported protocols, or an empty list if none available\n\t */\n\tprotected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler) {\n\t\tWebSocketHandler handlerToCheck = WebSocketHandlerDecorator.unwrap(handler);\n\t\tList<String> subProtocols = null;\n\t\tif (handlerToCheck instanceof SubProtocolCapable subProtocolCapable) {\n\t\t\tsubProtocols = subProtocolCapable.getSubProtocols();\n\t\t}\n\t\treturn (subProtocols != null ? subProtocols : Collections.emptyList());\n\t}\n\n\t/**\n\t * Filter the list of requested WebSocket extensions.\n\t * <p>As of 4.1, the default implementation of this method filters the list to\n\t * leave only extensions that are both requested and supported.\n\t * @param request the current request\n\t * @param requestedExtensions the list of extensions requested by the client\n\t * @param supportedExtensions the list of extensions supported by the server\n\t * @return the selected extensions or an empty list\n\t */\n\tprotected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,\n\t\t\tList<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions) {\n\n\t\tList<WebSocketExtension> result = new ArrayList<>(requestedExtensions.size());\n\t\tfor (WebSocketExtension extension : requestedExtensions) {\n\t\t\tif (supportedExtensions.contains(extension)) {\n\t\t\t\tresult.add(extension);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A method that can be used to associate a user with the WebSocket session\n\t * in the process of being established. The default implementation calls\n\t * {@link ServerHttpRequest#getPrincipal()}\n\t * <p>Subclasses can provide custom logic for associating a user with a session,\n\t * for example for assigning a name to anonymous users (i.e. not fully authenticated).\n\t * @param request the handshake request\n\t * @param wsHandler the WebSocket handler that will handle messages\n\t * @param attributes handshake attributes to pass to the WebSocket session\n\t * @return the user for the WebSocket session, or {@code null} if not available\n\t */\n\t@Nullable\n\tprotected Principal determineUser(\n\t\t\tServerHttpRequest request, WebSocketHandler wsHandler, Map<String, Object> attributes) {\n\n\t\treturn request.getPrincipal();\n\t}\n\n\n\tprivate static RequestUpgradeStrategy initRequestUpgradeStrategy() {\n\t\tif (tomcatWsPresent) {\n\t\t\treturn new TomcatRequestUpgradeStrategy();\n\t\t}\n\t\telse if (jettyWsPresent) {\n\t\t\treturn new JettyRequestUpgradeStrategy();\n\t\t}\n\t\telse if (undertowWsPresent) {\n\t\t\treturn new UndertowRequestUpgradeStrategy();\n\t\t}\n\t\telse if (glassfishWsPresent) {\n\t\t\treturn TyrusStrategyDelegate.forGlassFish();\n\t\t}\n\t\telse if (weblogicWsPresent) {\n\t\t\treturn TyrusStrategyDelegate.forWebLogic();\n\t\t}\n\t\telse if (websphereWsPresent) {\n\t\t\treturn new WebSphereRequestUpgradeStrategy();\n\t\t}\n\t\telse {\n\t\t\t// Let's assume Jakarta WebSocket API 2.1+\n\t\t\treturn new StandardWebSocketUpgradeStrategy();\n\t\t}\n\t}\n\n\n\t/**\n\t * Inner class to avoid a reachable dependency on Tyrus API.\n\t */\n\tprivate static class TyrusStrategyDelegate {\n\n\t\tpublic static RequestUpgradeStrategy forGlassFish() {\n\t\t\treturn new GlassFishRequestUpgradeStrategy();\n\t\t}\n\n\t\tpublic static RequestUpgradeStrategy forWebLogic() {\n\t\t\treturn new WebLogicRequestUpgradeStrategy();\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.socket.server.support.AbstractHandshakeHandler#determineHandlerSupportedProtocols(handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the sub-protocols supported by the given WebSocketHandler by\n\t * checking whether it is an instance of {@link SubProtocolCapable}.\n\t * @param handler the handler to check\n\t * @return a list of supported protocols, or an empty list if none available\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 349
    },
    "return": "List<String>",
    "signature": "protected List<String> determineHandlerSupportedProtocols(WebSocketHandler handler)",
    "source_code": "\tprotected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler) {\n\t\tWebSocketHandler handlerToCheck = WebSocketHandlerDecorator.unwrap(handler);\n\t\tList<String> subProtocols = null;\n\t\tif (handlerToCheck instanceof SubProtocolCapable subProtocolCapable) {\n\t\t\tsubProtocols = subProtocolCapable.getSubProtocols();\n\t\t}\n\t\treturn (subProtocols != null ? subProtocols : Collections.emptyList());\n\t}"
  },
  "org.springframework.web.socket.server.support.AbstractHandshakeHandler#determineUser(request,wsHandler,Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A method that can be used to associate a user with the WebSocket session\n\t * in the process of being established. The default implementation calls\n\t * {@link ServerHttpRequest#getPrincipal()}\n\t * <p>Subclasses can provide custom logic for associating a user with a session,\n\t * for example for assigning a name to anonymous users (i.e. not fully authenticated).\n\t * @param request the handshake request\n\t * @param wsHandler the WebSocket handler that will handle messages\n\t * @param attributes handshake attributes to pass to the WebSocket session\n\t * @return the user for the WebSocket session, or {@code null} if not available\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "wsHandler",
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 391
    },
    "return": "Principal",
    "signature": "protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler, Map<String, Object> attributes)",
    "source_code": "\tprotected Principal determineUser("
  },
  "org.springframework.web.socket.server.support.AbstractHandshakeHandler#doHandshake(request,response,wsHandler,Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "wsHandler",
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "boolean",
    "signature": "public boolean doHandshake(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, Map<String, Object> attributes)",
    "source_code": "\tpublic final boolean doHandshake(ServerHttpRequest request, ServerHttpResponse response,"
  },
  "org.springframework.web.socket.server.support.AbstractHandshakeHandler#doStart()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "void",
    "signature": "protected void doStart()",
    "source_code": "\tprotected void doStart() {\n\t\tif (this.requestUpgradeStrategy instanceof Lifecycle lifecycle) {\n\t\t\tlifecycle.start();\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.server.support.AbstractHandshakeHandler#doStop()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "void",
    "signature": "protected void doStop()",
    "source_code": "\tprotected void doStop() {\n\t\tif (this.requestUpgradeStrategy instanceof Lifecycle lifecycle) {\n\t\t\tlifecycle.stop();\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.server.support.AbstractHandshakeHandler#filterRequestedExtensions(request,requestedExtensions,supportedExtensions)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Filter the list of requested WebSocket extensions.\n\t * <p>As of 4.1, the default implementation of this method filters the list to\n\t * leave only extensions that are both requested and supported.\n\t * @param request the current request\n\t * @param requestedExtensions the list of extensions requested by the client\n\t * @param supportedExtensions the list of extensions supported by the server\n\t * @return the selected extensions or an empty list\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "requestedExtensions",
      "supportedExtensions"
    ],
    "position": {
      "column": 1,
      "line": 367
    },
    "return": "List<WebSocketExtension>",
    "signature": "protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,\n\t\t\tList<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions)",
    "source_code": "\tprotected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,"
  },
  "org.springframework.web.socket.server.support.AbstractHandshakeHandler#forGlassFish()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "RequestUpgradeStrategy",
    "signature": "public RequestUpgradeStrategy forGlassFish()",
    "source_code": "\t\tpublic static RequestUpgradeStrategy forGlassFish() {\n\t\t\treturn new GlassFishRequestUpgradeStrategy();\n\t\t}"
  },
  "org.springframework.web.socket.server.support.AbstractHandshakeHandler#forWebLogic()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 433
    },
    "return": "RequestUpgradeStrategy",
    "signature": "public RequestUpgradeStrategy forWebLogic()",
    "source_code": "\t\tpublic static RequestUpgradeStrategy forWebLogic() {\n\t\t\treturn new WebLogicRequestUpgradeStrategy();\n\t\t}"
  },
  "org.springframework.web.socket.server.support.AbstractHandshakeHandler#getRequestUpgradeStrategy()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link RequestUpgradeStrategy} for WebSocket requests.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "RequestUpgradeStrategy",
    "signature": "public RequestUpgradeStrategy getRequestUpgradeStrategy()",
    "source_code": "\tpublic RequestUpgradeStrategy getRequestUpgradeStrategy() {\n\t\treturn this.requestUpgradeStrategy;\n\t}"
  },
  "org.springframework.web.socket.server.support.AbstractHandshakeHandler#getSupportedProtocols()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the list of supported sub-protocols.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "String[]",
    "signature": "public String[] getSupportedProtocols()",
    "source_code": "\tpublic String[] getSupportedProtocols() {\n\t\treturn StringUtils.toStringArray(this.supportedProtocols);\n\t}"
  },
  "org.springframework.web.socket.server.support.AbstractHandshakeHandler#getSupportedVersions()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "String[]",
    "signature": "protected String[] getSupportedVersions()",
    "source_code": "\tprotected String[] getSupportedVersions() {\n\t\treturn this.requestUpgradeStrategy.getSupportedVersions();\n\t}"
  },
  "org.springframework.web.socket.server.support.AbstractHandshakeHandler#handleInvalidConnectHeader(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "void",
    "signature": "protected void handleInvalidConnectHeader(ServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tprotected void handleInvalidConnectHeader(ServerHttpRequest request, ServerHttpResponse response) throws IOException {\n\t\tif (logger.isErrorEnabled()) {\n\t\t\tlogger.error(LogFormatUtils.formatValue(\n\t\t\t\t\t\"Handshake failed due to invalid Connection header\" + request.getHeaders().getConnection(), -1, true));\n\t\t}\n\t\tresponse.setStatusCode(HttpStatus.BAD_REQUEST);\n\t\tresponse.getBody().write(\"\\\"Connection\\\" must be \\\"upgrade\\\".\".getBytes(StandardCharsets.UTF_8));\n\t}"
  },
  "org.springframework.web.socket.server.support.AbstractHandshakeHandler#handleInvalidUpgradeHeader(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "void",
    "signature": "protected void handleInvalidUpgradeHeader(ServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tprotected void handleInvalidUpgradeHeader(ServerHttpRequest request, ServerHttpResponse response) throws IOException {\n\t\tif (logger.isErrorEnabled()) {\n\t\t\tlogger.error(LogFormatUtils.formatValue(\n\t\t\t\t\t\"Handshake failed due to invalid Upgrade header: \" + request.getHeaders().getUpgrade(), -1, true));\n\t\t}\n\t\tresponse.setStatusCode(HttpStatus.BAD_REQUEST);\n\t\tresponse.getBody().write(\"Can \\\"Upgrade\\\" only to \\\"WebSocket\\\".\".getBytes(StandardCharsets.UTF_8));\n\t}"
  },
  "org.springframework.web.socket.server.support.AbstractHandshakeHandler#handleWebSocketVersionNotSupported(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "void",
    "signature": "protected void handleWebSocketVersionNotSupported(ServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tprotected void handleWebSocketVersionNotSupported(ServerHttpRequest request, ServerHttpResponse response) {\n\t\tif (logger.isErrorEnabled()) {\n\t\t\tString version = request.getHeaders().getFirst(\"Sec-WebSocket-Version\");\n\t\t\tlogger.error(LogFormatUtils.formatValue(\n\t\t\t\t\t\"Handshake failed due to unsupported WebSocket version: \" + version +\n\t\t\t\t\t\t\t\". Supported versions: \" + Arrays.toString(getSupportedVersions()), -1, true));\n\t\t}\n\t\tresponse.setStatusCode(HttpStatus.UPGRADE_REQUIRED);\n\t\tresponse.getHeaders().set(WebSocketHttpHeaders.SEC_WEBSOCKET_VERSION,\n\t\t\t\tStringUtils.arrayToCommaDelimitedString(getSupportedVersions()));\n\t}"
  },
  "org.springframework.web.socket.server.support.AbstractHandshakeHandler#isRunning()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "boolean",
    "signature": "public boolean isRunning()",
    "source_code": "\tpublic boolean isRunning() {\n\t\treturn this.running;\n\t}"
  },
  "org.springframework.web.socket.server.support.AbstractHandshakeHandler#isValidOrigin(request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether the request {@code Origin} header value is valid or not.\n\t * By default, all origins as considered as valid. Consider using an\n\t * {@link OriginHandshakeInterceptor} for filtering origins if needed.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 314
    },
    "return": "boolean",
    "signature": "protected boolean isValidOrigin(ServerHttpRequest request)",
    "source_code": "\tprotected boolean isValidOrigin(ServerHttpRequest request) {\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.socket.server.support.AbstractHandshakeHandler#isWebSocketVersionSupported(httpHeaders)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "httpHeaders"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "boolean",
    "signature": "protected boolean isWebSocketVersionSupported(WebSocketHttpHeaders httpHeaders)",
    "source_code": "\tprotected boolean isWebSocketVersionSupported(WebSocketHttpHeaders httpHeaders) {\n\t\tString version = httpHeaders.getSecWebSocketVersion();\n\t\tString[] supportedVersions = getSupportedVersions();\n\t\tfor (String supportedVersion : supportedVersions) {\n\t\t\tif (supportedVersion.trim().equals(version)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.socket.server.support.AbstractHandshakeHandler#selectProtocol(requestedProtocols,webSocketHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform the sub-protocol negotiation based on requested and supported sub-protocols.\n\t * For the list of supported sub-protocols, this method first checks if the target\n\t * WebSocketHandler is a {@link SubProtocolCapable} and then also checks if any\n\t * sub-protocols have been explicitly configured with\n\t * {@link #setSupportedProtocols(String...)}.\n\t * @param requestedProtocols the requested sub-protocols\n\t * @param webSocketHandler the WebSocketHandler that will be used\n\t * @return the selected protocols or {@code null}\n\t * @see #determineHandlerSupportedProtocols(WebSocketHandler)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "requestedProtocols",
      "webSocketHandler"
    ],
    "position": {
      "column": 1,
      "line": 330
    },
    "return": "String",
    "signature": "protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler)",
    "source_code": "\tprotected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler) {\n\t\tList<String> handlerProtocols = determineHandlerSupportedProtocols(webSocketHandler);\n\t\tfor (String protocol : requestedProtocols) {\n\t\t\tif (handlerProtocols.contains(protocol.toLowerCase())) {\n\t\t\t\treturn protocol;\n\t\t\t}\n\t\t\tif (this.supportedProtocols.contains(protocol.toLowerCase())) {\n\t\t\t\treturn protocol;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.socket.server.support.AbstractHandshakeHandler#setSupportedProtocols(protocols)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Use this property to configure the list of supported sub-protocols.\n\t * The first configured sub-protocol that matches a client-requested sub-protocol\n\t * is accepted. If there are no matches the response will not contain a\n\t * {@literal Sec-WebSocket-Protocol} header.\n\t * <p>Note that if the WebSocketHandler passed in at runtime is an instance of\n\t * {@link SubProtocolCapable} then there is no need to explicitly configure\n\t * this property. That is certainly the case with the built-in STOMP over\n\t * WebSocket support. Therefore, this property should be configured explicitly\n\t * only if the WebSocketHandler does not implement {@code SubProtocolCapable}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "protocols"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "void",
    "signature": "public void setSupportedProtocols(String... protocols)",
    "source_code": "\tpublic void setSupportedProtocols(String... protocols) {\n\t\tthis.supportedProtocols.clear();\n\t\tfor (String protocol : protocols) {\n\t\t\tthis.supportedProtocols.add(protocol.toLowerCase());\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.server.support.AbstractHandshakeHandler#start()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "void",
    "signature": "public void start()",
    "source_code": "\tpublic void start() {\n\t\tif (!isRunning()) {\n\t\t\tthis.running = true;\n\t\t\tdoStart();\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.server.support.AbstractHandshakeHandler#stop()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "void",
    "signature": "public void stop()",
    "source_code": "\tpublic void stop() {\n\t\tif (isRunning()) {\n\t\t\tthis.running = false;\n\t\t\tdoStop();\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.server.support.DefaultHandshakeHandler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A default {@link org.springframework.web.socket.server.HandshakeHandler} implementation,\n * extending {@link AbstractHandshakeHandler} with Servlet-specific initialization support.\n * See {@link AbstractHandshakeHandler}'s javadoc for details on supported servers etc.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 33
    },
    "signature": "public class DefaultHandshakeHandler",
    "source_code": "public class DefaultHandshakeHandler extends AbstractHandshakeHandler implements ServletContextAware {\n\n\tpublic DefaultHandshakeHandler() {\n\t}\n\n\tpublic DefaultHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy) {\n\t\tsuper(requestUpgradeStrategy);\n\t}\n\n\n\t@Override\n\tpublic void setServletContext(ServletContext servletContext) {\n\t\tRequestUpgradeStrategy strategy = getRequestUpgradeStrategy();\n\t\tif (strategy instanceof ServletContextAware servletContextAware) {\n\t\t\tservletContextAware.setServletContext(servletContext);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.socket.server.support.DefaultHandshakeHandler#setServletContext(servletContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "return": "void",
    "signature": "public void setServletContext(ServletContext servletContext)",
    "source_code": "\tpublic void setServletContext(ServletContext servletContext) {\n\t\tRequestUpgradeStrategy strategy = getRequestUpgradeStrategy();\n\t\tif (strategy instanceof ServletContextAware servletContextAware) {\n\t\t\tservletContextAware.setServletContext(servletContext);\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.server.support.WebSocketHandlerMapping": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Extension of {@link SimpleUrlHandlerMapping} with support for more\n * precise mapping of WebSocket handshake requests to handlers of type\n * {@link WebSocketHttpRequestHandler}. Also delegates {@link Lifecycle}\n * methods to handlers in the {@link #getUrlMap()} that implement it.\n *\n * @author Rossen Stoyanchev\n * @since 4.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class WebSocketHandlerMapping",
    "source_code": "public class WebSocketHandlerMapping extends SimpleUrlHandlerMapping implements SmartLifecycle {\n\n\tprivate boolean webSocketUpgradeMatch;\n\n\tprivate volatile boolean running;\n\n\n\t/**\n\t * When this is set, if the matched handler is\n\t * {@link WebSocketHttpRequestHandler}, ensure the request is a WebSocket\n\t * handshake, i.e. HTTP GET with the header {@code \"Upgrade:websocket\"},\n\t * or otherwise suppress the match and return {@code null} allowing another\n\t * {@link org.springframework.web.servlet.HandlerMapping} to match for the\n\t * same URL path.\n\t * @param match whether to enable matching on {@code \"Upgrade: websocket\"}\n\t * @since 5.3.5\n\t */\n\tpublic void setWebSocketUpgradeMatch(boolean match) {\n\t\tthis.webSocketUpgradeMatch = match;\n\t}\n\n\n\t@Override\n\tprotected void initServletContext(ServletContext servletContext) {\n\t\tfor (Object handler : getUrlMap().values()) {\n\t\t\tif (handler instanceof ServletContextAware servletContextAware) {\n\t\t\t\tservletContextAware.setServletContext(servletContext);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic void start() {\n\t\tif (!isRunning()) {\n\t\t\tthis.running = true;\n\t\t\tfor (Object handler : getUrlMap().values()) {\n\t\t\t\tif (handler instanceof Lifecycle lifecycle) {\n\t\t\t\t\tlifecycle.start();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void stop() {\n\t\tif (isRunning()) {\n\t\t\tthis.running = false;\n\t\t\tfor (Object handler : getUrlMap().values()) {\n\t\t\t\tif (handler instanceof Lifecycle lifecycle) {\n\t\t\t\t\tlifecycle.stop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isRunning() {\n\t\treturn this.running;\n\t}\n\n\n\t@Override\n\t@Nullable\n\tprotected Object getHandlerInternal(HttpServletRequest request) throws Exception {\n\t\tObject handler = super.getHandlerInternal(request);\n\t\treturn (matchWebSocketUpgrade(handler, request) ? handler : null);\n\t}\n\n\tprivate boolean matchWebSocketUpgrade(@Nullable Object handler, HttpServletRequest request) {\n\t\thandler = (handler instanceof HandlerExecutionChain chain ? chain.getHandler() : handler);\n\t\tif (this.webSocketUpgradeMatch && handler instanceof WebSocketHttpRequestHandler) {\n\t\t\tString header = request.getHeader(HttpHeaders.UPGRADE);\n\t\t\treturn (request.getMethod().equals(\"GET\") &&\n\t\t\t\t\theader != null && header.equalsIgnoreCase(\"websocket\"));\n\t\t}\n\t\treturn true;\n\t}\n\n}"
  },
  "org.springframework.web.socket.server.support.WebSocketHandlerMapping#getHandlerInternal(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "Object",
    "signature": "protected Object getHandlerInternal(HttpServletRequest request)",
    "source_code": "\tprotected Object getHandlerInternal(HttpServletRequest request) throws Exception {\n\t\tObject handler = super.getHandlerInternal(request);\n\t\treturn (matchWebSocketUpgrade(handler, request) ? handler : null);\n\t}"
  },
  "org.springframework.web.socket.server.support.WebSocketHandlerMapping#initServletContext(servletContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "void",
    "signature": "protected void initServletContext(ServletContext servletContext)",
    "source_code": "\tprotected void initServletContext(ServletContext servletContext) {\n\t\tfor (Object handler : getUrlMap().values()) {\n\t\t\tif (handler instanceof ServletContextAware servletContextAware) {\n\t\t\t\tservletContextAware.setServletContext(servletContext);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.server.support.WebSocketHandlerMapping#isRunning()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "boolean",
    "signature": "public boolean isRunning()",
    "source_code": "\tpublic boolean isRunning() {\n\t\treturn this.running;\n\t}"
  },
  "org.springframework.web.socket.server.support.WebSocketHandlerMapping#setWebSocketUpgradeMatch(match)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * When this is set, if the matched handler is\n\t * {@link WebSocketHttpRequestHandler}, ensure the request is a WebSocket\n\t * handshake, i.e. HTTP GET with the header {@code \"Upgrade:websocket\"},\n\t * or otherwise suppress the match and return {@code null} allowing another\n\t * {@link org.springframework.web.servlet.HandlerMapping} to match for the\n\t * same URL path.\n\t * @param match whether to enable matching on {@code \"Upgrade: websocket\"}\n\t * @since 5.3.5\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "match"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "void",
    "signature": "public void setWebSocketUpgradeMatch(boolean match)",
    "source_code": "\tpublic void setWebSocketUpgradeMatch(boolean match) {\n\t\tthis.webSocketUpgradeMatch = match;\n\t}"
  },
  "org.springframework.web.socket.server.support.WebSocketHandlerMapping#start()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "void",
    "signature": "public void start()",
    "source_code": "\tpublic void start() {\n\t\tif (!isRunning()) {\n\t\t\tthis.running = true;\n\t\t\tfor (Object handler : getUrlMap().values()) {\n\t\t\t\tif (handler instanceof Lifecycle lifecycle) {\n\t\t\t\t\tlifecycle.start();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.server.support.WebSocketHandlerMapping#stop()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "void",
    "signature": "public void stop()",
    "source_code": "\tpublic void stop() {\n\t\tif (isRunning()) {\n\t\t\tthis.running = false;\n\t\t\tfor (Object handler : getUrlMap().values()) {\n\t\t\t\tif (handler instanceof Lifecycle lifecycle) {\n\t\t\t\t\tlifecycle.stop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.server.support.WebSocketHttpRequestHandler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A {@link HttpRequestHandler} for processing WebSocket handshake requests.\n *\n * <p>This is the main class to use when configuring a server WebSocket at a specific URL.\n * It is a very thin wrapper around a {@link WebSocketHandler} and a {@link HandshakeHandler},\n * also adapting the {@link HttpServletRequest} and {@link HttpServletResponse} to\n * {@link ServerHttpRequest} and {@link ServerHttpResponse}, respectively.\n *\n * @author Rossen Stoyanchev\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "signature": "public class WebSocketHttpRequestHandler",
    "source_code": "public class WebSocketHttpRequestHandler implements HttpRequestHandler, Lifecycle, ServletContextAware {\n\n\tprivate static final Log logger = LogFactory.getLog(WebSocketHttpRequestHandler.class);\n\n\tprivate final WebSocketHandler wsHandler;\n\n\tprivate final HandshakeHandler handshakeHandler;\n\n\tprivate final List<HandshakeInterceptor> interceptors = new ArrayList<>();\n\n\tprivate volatile boolean running;\n\n\n\tpublic WebSocketHttpRequestHandler(WebSocketHandler wsHandler) {\n\t\tthis(wsHandler, new DefaultHandshakeHandler());\n\t}\n\n\tpublic WebSocketHttpRequestHandler(WebSocketHandler wsHandler, HandshakeHandler handshakeHandler) {\n\t\tAssert.notNull(wsHandler, \"wsHandler must not be null\");\n\t\tAssert.notNull(handshakeHandler, \"handshakeHandler must not be null\");\n\t\tthis.wsHandler = decorate(wsHandler);\n\t\tthis.handshakeHandler = handshakeHandler;\n\t}\n\n\t/**\n\t * Decorate the {@code WebSocketHandler} passed into the constructor.\n\t * <p>By default, {@link LoggingWebSocketHandlerDecorator} and\n\t * {@link ExceptionWebSocketHandlerDecorator} are added.\n\t * @since 5.2.2\n\t */\n\tprotected WebSocketHandler decorate(WebSocketHandler handler) {\n\t\treturn new ExceptionWebSocketHandlerDecorator(new LoggingWebSocketHandlerDecorator(handler));\n\t}\n\n\n\t/**\n\t * Return the WebSocketHandler.\n\t */\n\tpublic WebSocketHandler getWebSocketHandler() {\n\t\treturn this.wsHandler;\n\t}\n\n\t/**\n\t * Return the HandshakeHandler.\n\t */\n\tpublic HandshakeHandler getHandshakeHandler() {\n\t\treturn this.handshakeHandler;\n\t}\n\n\t/**\n\t * Configure one or more WebSocket handshake request interceptors.\n\t */\n\tpublic void setHandshakeInterceptors(@Nullable List<HandshakeInterceptor> interceptors) {\n\t\tthis.interceptors.clear();\n\t\tif (interceptors != null) {\n\t\t\tthis.interceptors.addAll(interceptors);\n\t\t}\n\t}\n\n\t/**\n\t * Return the configured WebSocket handshake request interceptors.\n\t */\n\tpublic List<HandshakeInterceptor> getHandshakeInterceptors() {\n\t\treturn this.interceptors;\n\t}\n\n\t@Override\n\tpublic void setServletContext(ServletContext servletContext) {\n\t\tif (this.handshakeHandler instanceof ServletContextAware servletContextAware) {\n\t\t\tservletContextAware.setServletContext(servletContext);\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic void start() {\n\t\tif (!isRunning()) {\n\t\t\tthis.running = true;\n\t\t\tif (this.handshakeHandler instanceof Lifecycle lifecycle) {\n\t\t\t\tlifecycle.start();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void stop() {\n\t\tif (isRunning()) {\n\t\t\tthis.running = false;\n\t\t\tif (this.handshakeHandler instanceof Lifecycle lifecycle) {\n\t\t\t\tlifecycle.stop();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isRunning() {\n\t\treturn this.running;\n\t}\n\n\n\t@Override\n\tpublic void handleRequest(HttpServletRequest servletRequest, HttpServletResponse servletResponse)\n\t\t\tthrows ServletException, IOException {\n\n\t\tServerHttpRequest request = new ServletServerHttpRequest(servletRequest);\n\t\tServerHttpResponse response = new ServletServerHttpResponse(servletResponse);\n\n\t\tHandshakeInterceptorChain chain = new HandshakeInterceptorChain(this.interceptors, this.wsHandler);\n\t\tHandshakeFailureException failure = null;\n\n\t\ttry {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(servletRequest.getMethod() + \" \" + servletRequest.getRequestURI());\n\t\t\t}\n\t\t\tMap<String, Object> attributes = new HashMap<>();\n\t\t\tif (!chain.applyBeforeHandshake(request, response, attributes)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.handshakeHandler.doHandshake(request, response, this.wsHandler, attributes);\n\t\t\tchain.applyAfterHandshake(request, response, null);\n\t\t}\n\t\tcatch (HandshakeFailureException ex) {\n\t\t\tfailure = ex;\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tfailure = new HandshakeFailureException(\n\t\t\t\t\t\"Uncaught failure for request \" + request.getURI() + \" - \" + ex.getMessage(), ex);\n\t\t}\n\t\tfinally {\n\t\t\tif (failure != null) {\n\t\t\t\tchain.applyAfterHandshake(request, response, failure);\n\t\t\t\tresponse.close();\n\t\t\t\tthrow failure;\n\t\t\t}\n\t\t\tresponse.close();\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.socket.server.support.WebSocketHttpRequestHandler#decorate(handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Decorate the {@code WebSocketHandler} passed into the constructor.\n\t * <p>By default, {@link LoggingWebSocketHandlerDecorator} and\n\t * {@link ExceptionWebSocketHandlerDecorator} are added.\n\t * @since 5.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "WebSocketHandler",
    "signature": "protected WebSocketHandler decorate(WebSocketHandler handler)",
    "source_code": "\tprotected WebSocketHandler decorate(WebSocketHandler handler) {\n\t\treturn new ExceptionWebSocketHandlerDecorator(new LoggingWebSocketHandlerDecorator(handler));\n\t}"
  },
  "org.springframework.web.socket.server.support.WebSocketHttpRequestHandler#getHandshakeHandler()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the HandshakeHandler.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "HandshakeHandler",
    "signature": "public HandshakeHandler getHandshakeHandler()",
    "source_code": "\tpublic HandshakeHandler getHandshakeHandler() {\n\t\treturn this.handshakeHandler;\n\t}"
  },
  "org.springframework.web.socket.server.support.WebSocketHttpRequestHandler#getHandshakeInterceptors()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured WebSocket handshake request interceptors.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "List<HandshakeInterceptor>",
    "signature": "public List<HandshakeInterceptor> getHandshakeInterceptors()",
    "source_code": "\tpublic List<HandshakeInterceptor> getHandshakeInterceptors() {\n\t\treturn this.interceptors;\n\t}"
  },
  "org.springframework.web.socket.server.support.WebSocketHttpRequestHandler#getWebSocketHandler()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the WebSocketHandler.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "WebSocketHandler",
    "signature": "public WebSocketHandler getWebSocketHandler()",
    "source_code": "\tpublic WebSocketHandler getWebSocketHandler() {\n\t\treturn this.wsHandler;\n\t}"
  },
  "org.springframework.web.socket.server.support.WebSocketHttpRequestHandler#handleRequest(servletRequest,servletResponse)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletRequest",
      "servletResponse"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "void",
    "signature": "public void handleRequest(HttpServletRequest servletRequest, HttpServletResponse servletResponse)",
    "source_code": "\tpublic void handleRequest(HttpServletRequest servletRequest, HttpServletResponse servletResponse)"
  },
  "org.springframework.web.socket.server.support.WebSocketHttpRequestHandler#isRunning()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "boolean",
    "signature": "public boolean isRunning()",
    "source_code": "\tpublic boolean isRunning() {\n\t\treturn this.running;\n\t}"
  },
  "org.springframework.web.socket.server.support.WebSocketHttpRequestHandler#setHandshakeInterceptors(interceptors)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure one or more WebSocket handshake request interceptors.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "interceptors"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void setHandshakeInterceptors(@Nullable List<HandshakeInterceptor> interceptors)",
    "source_code": "\tpublic void setHandshakeInterceptors(@Nullable List<HandshakeInterceptor> interceptors) {\n\t\tthis.interceptors.clear();\n\t\tif (interceptors != null) {\n\t\t\tthis.interceptors.addAll(interceptors);\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.server.support.WebSocketHttpRequestHandler#setServletContext(servletContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void setServletContext(ServletContext servletContext)",
    "source_code": "\tpublic void setServletContext(ServletContext servletContext) {\n\t\tif (this.handshakeHandler instanceof ServletContextAware servletContextAware) {\n\t\t\tservletContextAware.setServletContext(servletContext);\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.server.support.WebSocketHttpRequestHandler#start()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "void",
    "signature": "public void start()",
    "source_code": "\tpublic void start() {\n\t\tif (!isRunning()) {\n\t\t\tthis.running = true;\n\t\t\tif (this.handshakeHandler instanceof Lifecycle lifecycle) {\n\t\t\t\tlifecycle.start();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.server.support.WebSocketHttpRequestHandler#stop()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "void",
    "signature": "public void stop()",
    "source_code": "\tpublic void stop() {\n\t\tif (isRunning()) {\n\t\t\tthis.running = false;\n\t\t\tif (this.handshakeHandler instanceof Lifecycle lifecycle) {\n\t\t\t\tlifecycle.stop();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.server.support.logger": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.web.socket.sockjs.client.RestTemplateXhrTransport": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * An {@code XhrTransport} implementation that uses a\n * {@link org.springframework.web.client.RestTemplate RestTemplate}.\n *\n * @author Rossen Stoyanchev\n * @since 4.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "signature": "public class RestTemplateXhrTransport",
    "source_code": "public class RestTemplateXhrTransport extends AbstractXhrTransport {\n\n\tprivate final RestOperations restTemplate;\n\n\tprivate TaskExecutor taskExecutor = new SimpleAsyncTaskExecutor();\n\n\n\tpublic RestTemplateXhrTransport() {\n\t\tthis(new RestTemplate());\n\t}\n\n\tpublic RestTemplateXhrTransport(RestOperations restTemplate) {\n\t\tAssert.notNull(restTemplate, \"'restTemplate' is required\");\n\t\tthis.restTemplate = restTemplate;\n\t}\n\n\n\t/**\n\t * Return the configured {@code RestTemplate}.\n\t */\n\tpublic RestOperations getRestTemplate() {\n\t\treturn this.restTemplate;\n\t}\n\n\t/**\n\t * Configure the {@code TaskExecutor} to use to execute XHR receive requests.\n\t * <p>By default {@link org.springframework.core.task.SimpleAsyncTaskExecutor\n\t * SimpleAsyncTaskExecutor} is configured which creates a new thread every\n\t * time the transports connects.\n\t */\n\tpublic void setTaskExecutor(TaskExecutor taskExecutor) {\n\t\tAssert.notNull(taskExecutor, \"TaskExecutor must not be null\");\n\t\tthis.taskExecutor = taskExecutor;\n\t}\n\n\t/**\n\t * Return the configured {@code TaskExecutor}.\n\t */\n\tpublic TaskExecutor getTaskExecutor() {\n\t\treturn this.taskExecutor;\n\t}\n\n\n\t@Override\n\tprotected void connectInternal(final TransportRequest transportRequest, final WebSocketHandler handler,\n\t\t\tfinal URI receiveUrl, final HttpHeaders handshakeHeaders, final XhrClientSockJsSession session,\n\t\t\tfinal CompletableFuture<WebSocketSession> connectFuture) {\n\n\t\tgetTaskExecutor().execute(() -> {\n\t\t\tHttpHeaders httpHeaders = transportRequest.getHttpRequestHeaders();\n\t\t\tXhrRequestCallback requestCallback = new XhrRequestCallback(handshakeHeaders);\n\t\t\tXhrRequestCallback requestCallbackAfterHandshake = new XhrRequestCallback(httpHeaders);\n\t\t\tXhrReceiveExtractor responseExtractor = new XhrReceiveExtractor(session);\n\t\t\twhile (true) {\n\t\t\t\tif (session.isDisconnected()) {\n\t\t\t\t\tsession.afterTransportClosed(null);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Starting XHR receive request, url=\" + receiveUrl);\n\t\t\t\t\t}\n\t\t\t\t\tgetRestTemplate().execute(receiveUrl, HttpMethod.POST, requestCallback, responseExtractor);\n\t\t\t\t\trequestCallback = requestCallbackAfterHandshake;\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tif (!connectFuture.isDone()) {\n\t\t\t\t\t\tconnectFuture.completeExceptionally(ex);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsession.handleTransportError(ex);\n\t\t\t\t\t\tsession.afterTransportClosed(new CloseStatus(1006, ex.getMessage()));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t@Override\n\tprotected ResponseEntity<String> executeInfoRequestInternal(URI infoUrl, HttpHeaders headers) {\n\t\tRequestCallback requestCallback = new XhrRequestCallback(headers);\n\t\treturn nonNull(this.restTemplate.execute(infoUrl, HttpMethod.GET, requestCallback, textResponseExtractor));\n\t}\n\n\t@Override\n\tpublic ResponseEntity<String> executeSendRequestInternal(URI url, HttpHeaders headers, TextMessage message) {\n\t\tRequestCallback requestCallback = new XhrRequestCallback(headers, message.getPayload());\n\t\treturn nonNull(this.restTemplate.execute(url, HttpMethod.POST, requestCallback, textResponseExtractor));\n\t}\n\n\tprivate static <T> T nonNull(@Nullable T result) {\n\t\tAssert.state(result != null, \"No result\");\n\t\treturn result;\n\t}\n\n\n\t/**\n\t * A simple ResponseExtractor that reads the body into a String.\n\t */\n\tprivate static final ResponseExtractor<ResponseEntity<String>> textResponseExtractor =\n\t\t\tresponse -> {\n\t\t\t\tString body = StreamUtils.copyToString(response.getBody(), SockJsFrame.CHARSET);\n\t\t\t\treturn ResponseEntity.status(response.getStatusCode()).headers(response.getHeaders()).body(body);\n\t\t\t};\n\n\n\t/**\n\t * A RequestCallback to add the headers and (optionally) String content.\n\t */\n\tprivate static class XhrRequestCallback implements RequestCallback {\n\n\t\tprivate final HttpHeaders headers;\n\n\t\t@Nullable\n\t\tprivate final String body;\n\n\t\tpublic XhrRequestCallback(HttpHeaders headers) {\n\t\t\tthis(headers, null);\n\t\t}\n\n\t\tpublic XhrRequestCallback(HttpHeaders headers, @Nullable String body) {\n\t\t\tthis.headers = headers;\n\t\t\tthis.body = body;\n\t\t}\n\n\t\t@Override\n\t\tpublic void doWithRequest(ClientHttpRequest request) throws IOException {\n\t\t\trequest.getHeaders().putAll(this.headers);\n\t\t\tif (this.body != null) {\n\t\t\t\tif (request instanceof StreamingHttpOutputMessage streamingOutputMessage) {\n\t\t\t\t\tstreamingOutputMessage.setBody(outputStream ->\n\t\t\t\t\t\t\tStreamUtils.copy(this.body, SockJsFrame.CHARSET, outputStream));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tStreamUtils.copy(this.body, SockJsFrame.CHARSET, request.getBody());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Splits the body of an HTTP response into SockJS frames and delegates those\n\t * to an {@link XhrClientSockJsSession}.\n\t */\n\tprivate class XhrReceiveExtractor implements ResponseExtractor<Object> {\n\n\t\tprivate final XhrClientSockJsSession sockJsSession;\n\n\t\tpublic XhrReceiveExtractor(XhrClientSockJsSession sockJsSession) {\n\t\t\tthis.sockJsSession = sockJsSession;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object extractData(ClientHttpResponse response) throws IOException {\n\t\t\tHttpStatusCode httpStatus = response.getStatusCode();\n\t\t\tif (httpStatus != HttpStatus.OK) {\n\t\t\t\tthrow new HttpServerErrorException(\n\t\t\t\t\t\thttpStatus, response.getStatusText(), response.getHeaders(), null, null);\n\t\t\t}\n\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"XHR receive headers: \" + response.getHeaders());\n\t\t\t}\n\t\t\tInputStream is = response.getBody();\n\t\t\tByteArrayOutputStream os = new ByteArrayOutputStream();\n\n\t\t\twhile (true) {\n\t\t\t\tif (this.sockJsSession.isDisconnected()) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"SockJS sockJsSession closed, closing response.\");\n\t\t\t\t\t}\n\t\t\t\t\tresponse.close();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tif (os.size() > 0) {\n\t\t\t\t\t\thandleFrame(os);\n\t\t\t\t\t}\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"XHR receive completed\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (b == '\\n') {\n\t\t\t\t\thandleFrame(os);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tos.write(b);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tprivate void handleFrame(ByteArrayOutputStream os) {\n\t\t\tString content = os.toString(SockJsFrame.CHARSET);\n\t\t\tos.reset();\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"XHR receive content: \" + content);\n\t\t\t}\n\t\t\tif (!PRELUDE.equals(content)) {\n\t\t\t\tthis.sockJsSession.handleFrame(content);\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.socket.sockjs.client.RestTemplateXhrTransport#connectInternal(transportRequest,handler,receiveUrl,handshakeHeaders,session,connectFuture)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transportRequest",
      "handler",
      "receiveUrl",
      "handshakeHeaders",
      "session",
      "connectFuture"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "protected void connectInternal(final TransportRequest transportRequest, final WebSocketHandler handler,\n\t\t\tfinal URI receiveUrl, final HttpHeaders handshakeHeaders, final XhrClientSockJsSession session,\n\t\t\tfinal CompletableFuture<WebSocketSession> connectFuture)",
    "source_code": "\tprotected void connectInternal(final TransportRequest transportRequest, final WebSocketHandler handler,"
  },
  "org.springframework.web.socket.sockjs.client.RestTemplateXhrTransport#doWithRequest(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "void",
    "signature": "public void doWithRequest(ClientHttpRequest request)",
    "source_code": "\t\tpublic void doWithRequest(ClientHttpRequest request) throws IOException {\n\t\t\trequest.getHeaders().putAll(this.headers);\n\t\t\tif (this.body != null) {\n\t\t\t\tif (request instanceof StreamingHttpOutputMessage streamingOutputMessage) {\n\t\t\t\t\tstreamingOutputMessage.setBody(outputStream ->\n\t\t\t\t\t\t\tStreamUtils.copy(this.body, SockJsFrame.CHARSET, outputStream));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tStreamUtils.copy(this.body, SockJsFrame.CHARSET, request.getBody());\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.socket.sockjs.client.RestTemplateXhrTransport#executeInfoRequestInternal(infoUrl,headers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "infoUrl",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "ResponseEntity<String>",
    "signature": "protected ResponseEntity<String> executeInfoRequestInternal(URI infoUrl, HttpHeaders headers)",
    "source_code": "\tprotected ResponseEntity<String> executeInfoRequestInternal(URI infoUrl, HttpHeaders headers) {\n\t\tRequestCallback requestCallback = new XhrRequestCallback(headers);\n\t\treturn nonNull(this.restTemplate.execute(infoUrl, HttpMethod.GET, requestCallback, textResponseExtractor));\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.RestTemplateXhrTransport#executeSendRequestInternal(url,headers,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "headers",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "ResponseEntity<String>",
    "signature": "public ResponseEntity<String> executeSendRequestInternal(URI url, HttpHeaders headers, TextMessage message)",
    "source_code": "\tpublic ResponseEntity<String> executeSendRequestInternal(URI url, HttpHeaders headers, TextMessage message) {\n\t\tRequestCallback requestCallback = new XhrRequestCallback(headers, message.getPayload());\n\t\treturn nonNull(this.restTemplate.execute(url, HttpMethod.POST, requestCallback, textResponseExtractor));\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.RestTemplateXhrTransport#extractData(response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "response"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "Object",
    "signature": "public Object extractData(ClientHttpResponse response)",
    "source_code": "\t\tpublic Object extractData(ClientHttpResponse response) throws IOException {\n\t\t\tHttpStatusCode httpStatus = response.getStatusCode();\n\t\t\tif (httpStatus != HttpStatus.OK) {\n\t\t\t\tthrow new HttpServerErrorException(\n\t\t\t\t\t\thttpStatus, response.getStatusText(), response.getHeaders(), null, null);\n\t\t\t}\n\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"XHR receive headers: \" + response.getHeaders());\n\t\t\t}\n\t\t\tInputStream is = response.getBody();\n\t\t\tByteArrayOutputStream os = new ByteArrayOutputStream();\n\n\t\t\twhile (true) {\n\t\t\t\tif (this.sockJsSession.isDisconnected()) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"SockJS sockJsSession closed, closing response.\");\n\t\t\t\t\t}\n\t\t\t\t\tresponse.close();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tif (os.size() > 0) {\n\t\t\t\t\t\thandleFrame(os);\n\t\t\t\t\t}\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"XHR receive completed\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (b == '\\n') {\n\t\t\t\t\thandleFrame(os);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tos.write(b);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.web.socket.sockjs.client.RestTemplateXhrTransport#getRestTemplate()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured {@code RestTemplate}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "RestOperations",
    "signature": "public RestOperations getRestTemplate()",
    "source_code": "\tpublic RestOperations getRestTemplate() {\n\t\treturn this.restTemplate;\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.RestTemplateXhrTransport#getTaskExecutor()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured {@code TaskExecutor}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "TaskExecutor",
    "signature": "public TaskExecutor getTaskExecutor()",
    "source_code": "\tpublic TaskExecutor getTaskExecutor() {\n\t\treturn this.taskExecutor;\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.RestTemplateXhrTransport#setTaskExecutor(taskExecutor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@code TaskExecutor} to use to execute XHR receive requests.\n\t * <p>By default {@link org.springframework.core.task.SimpleAsyncTaskExecutor\n\t * SimpleAsyncTaskExecutor} is configured which creates a new thread every\n\t * time the transports connects.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "taskExecutor"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "void",
    "signature": "public void setTaskExecutor(TaskExecutor taskExecutor)",
    "source_code": "\tpublic void setTaskExecutor(TaskExecutor taskExecutor) {\n\t\tAssert.notNull(taskExecutor, \"TaskExecutor must not be null\");\n\t\tthis.taskExecutor = taskExecutor;\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.WebSocketTransport": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A SockJS {@link Transport} that uses a\n * {@link org.springframework.web.socket.client.WebSocketClient WebSocketClient}.\n *\n * @author Rossen Stoyanchev\n * @since 4.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "signature": "public class WebSocketTransport",
    "source_code": "public class WebSocketTransport implements Transport, Lifecycle {\n\n\tprivate static final Log logger = LogFactory.getLog(WebSocketTransport.class);\n\n\tprivate final WebSocketClient webSocketClient;\n\n\tprivate volatile boolean running;\n\n\n\tpublic WebSocketTransport(WebSocketClient webSocketClient) {\n\t\tAssert.notNull(webSocketClient, \"WebSocketClient is required\");\n\t\tthis.webSocketClient = webSocketClient;\n\t}\n\n\n\t/**\n\t * Return the configured {@code WebSocketClient}.\n\t */\n\tpublic WebSocketClient getWebSocketClient() {\n\t\treturn this.webSocketClient;\n\t}\n\n\t@Override\n\tpublic List<TransportType> getTransportTypes() {\n\t\treturn Collections.singletonList(TransportType.WEBSOCKET);\n\t}\n\n\n\t@Override\n\tpublic CompletableFuture<WebSocketSession> connectAsync(TransportRequest request,\n\t\t\tWebSocketHandler handler) {\n\t\tCompletableFuture<WebSocketSession> future = new CompletableFuture<>();\n\t\tWebSocketClientSockJsSession session = new WebSocketClientSockJsSession(request, handler, future);\n\t\thandler = new ClientSockJsWebSocketHandler(session);\n\t\trequest.addTimeoutTask(session.getTimeoutTask());\n\n\t\tURI url = request.getTransportUrl();\n\t\tWebSocketHttpHeaders headers = new WebSocketHttpHeaders(request.getHandshakeHeaders());\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Starting WebSocket session on \" + url);\n\t\t}\n\t\tthis.webSocketClient.execute(handler, headers, url).whenComplete((webSocketSession, throwable) -> {\n\t\t\tif (throwable != null) {\n\t\t\t\tfuture.completeExceptionally(throwable);\n\t\t\t}\n\t\t});\n\t\treturn future;\n\t}\n\n\t@Override\n\tpublic void start() {\n\t\tif (!isRunning()) {\n\t\t\tif (this.webSocketClient instanceof Lifecycle lifecycle) {\n\t\t\t\tlifecycle.start();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.running = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void stop() {\n\t\tif (isRunning()) {\n\t\t\tif (this.webSocketClient instanceof Lifecycle lifecycle) {\n\t\t\t\tlifecycle.stop();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.running = false;\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isRunning() {\n\t\tif (this.webSocketClient instanceof Lifecycle lifecycle) {\n\t\t\treturn lifecycle.isRunning();\n\t\t}\n\t\telse {\n\t\t\treturn this.running;\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"WebSocketTransport[client=\" + this.webSocketClient + \"]\";\n\t}\n\n\n\tprivate static class ClientSockJsWebSocketHandler extends TextWebSocketHandler {\n\n\t\tprivate final WebSocketClientSockJsSession sockJsSession;\n\n\t\tprivate final AtomicBoolean connected = new AtomicBoolean();\n\n\t\tpublic ClientSockJsWebSocketHandler(WebSocketClientSockJsSession session) {\n\t\t\tAssert.notNull(session, \"Session must not be null\");\n\t\t\tthis.sockJsSession = session;\n\t\t}\n\n\t\t@Override\n\t\tpublic void afterConnectionEstablished(WebSocketSession webSocketSession) throws Exception {\n\t\t\tAssert.state(this.connected.compareAndSet(false, true), \"Already connected\");\n\t\t\tthis.sockJsSession.initializeDelegateSession(webSocketSession);\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleTextMessage(WebSocketSession webSocketSession, TextMessage message) throws Exception {\n\t\t\tthis.sockJsSession.handleFrame(message.getPayload());\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleTransportError(WebSocketSession webSocketSession, Throwable ex) throws Exception {\n\t\t\tthis.sockJsSession.handleTransportError(ex);\n\t\t}\n\n\t\t@Override\n\t\tpublic void afterConnectionClosed(WebSocketSession webSocketSession, CloseStatus status) throws Exception {\n\t\t\tthis.sockJsSession.afterTransportClosed(status);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.socket.sockjs.client.WebSocketTransport#afterConnectionClosed(webSocketSession,status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webSocketSession",
      "status"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "void",
    "signature": "public void afterConnectionClosed(WebSocketSession webSocketSession, CloseStatus status)",
    "source_code": "\t\tpublic void afterConnectionClosed(WebSocketSession webSocketSession, CloseStatus status) throws Exception {\n\t\t\tthis.sockJsSession.afterTransportClosed(status);\n\t\t}"
  },
  "org.springframework.web.socket.sockjs.client.WebSocketTransport#afterConnectionEstablished(webSocketSession)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webSocketSession"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "public void afterConnectionEstablished(WebSocketSession webSocketSession)",
    "source_code": "\t\tpublic void afterConnectionEstablished(WebSocketSession webSocketSession) throws Exception {\n\t\t\tAssert.state(this.connected.compareAndSet(false, true), \"Already connected\");\n\t\t\tthis.sockJsSession.initializeDelegateSession(webSocketSession);\n\t\t}"
  },
  "org.springframework.web.socket.sockjs.client.WebSocketTransport#connectAsync(request,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "CompletableFuture<WebSocketSession>",
    "signature": "public CompletableFuture<WebSocketSession> connectAsync(TransportRequest request,\n\t\t\tWebSocketHandler handler)",
    "source_code": "\tpublic CompletableFuture<WebSocketSession> connectAsync(TransportRequest request,"
  },
  "org.springframework.web.socket.sockjs.client.WebSocketTransport#getTransportTypes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "List<TransportType>",
    "signature": "public List<TransportType> getTransportTypes()",
    "source_code": "\tpublic List<TransportType> getTransportTypes() {\n\t\treturn Collections.singletonList(TransportType.WEBSOCKET);\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.WebSocketTransport#getWebSocketClient()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured {@code WebSocketClient}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "WebSocketClient",
    "signature": "public WebSocketClient getWebSocketClient()",
    "source_code": "\tpublic WebSocketClient getWebSocketClient() {\n\t\treturn this.webSocketClient;\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.WebSocketTransport#handleTextMessage(webSocketSession,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webSocketSession",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "void",
    "signature": "public void handleTextMessage(WebSocketSession webSocketSession, TextMessage message)",
    "source_code": "\t\tpublic void handleTextMessage(WebSocketSession webSocketSession, TextMessage message) throws Exception {\n\t\t\tthis.sockJsSession.handleFrame(message.getPayload());\n\t\t}"
  },
  "org.springframework.web.socket.sockjs.client.WebSocketTransport#handleTransportError(webSocketSession,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webSocketSession",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "void",
    "signature": "public void handleTransportError(WebSocketSession webSocketSession, Throwable ex)",
    "source_code": "\t\tpublic void handleTransportError(WebSocketSession webSocketSession, Throwable ex) throws Exception {\n\t\t\tthis.sockJsSession.handleTransportError(ex);\n\t\t}"
  },
  "org.springframework.web.socket.sockjs.client.WebSocketTransport#isRunning()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "boolean",
    "signature": "public boolean isRunning()",
    "source_code": "\tpublic boolean isRunning() {\n\t\tif (this.webSocketClient instanceof Lifecycle lifecycle) {\n\t\t\treturn lifecycle.isRunning();\n\t\t}\n\t\telse {\n\t\t\treturn this.running;\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.WebSocketTransport#start()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "public void start()",
    "source_code": "\tpublic void start() {\n\t\tif (!isRunning()) {\n\t\t\tif (this.webSocketClient instanceof Lifecycle lifecycle) {\n\t\t\t\tlifecycle.start();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.running = true;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.WebSocketTransport#stop()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "void",
    "signature": "public void stop()",
    "source_code": "\tpublic void stop() {\n\t\tif (isRunning()) {\n\t\t\tif (this.webSocketClient instanceof Lifecycle lifecycle) {\n\t\t\t\tlifecycle.stop();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.running = false;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.WebSocketTransport#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn \"WebSocketTransport[client=\" + this.webSocketClient + \"]\";\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.SockJsHttpRequestHandler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * An {@link HttpRequestHandler} that allows mapping a {@link SockJsService} to requests\n * in a Servlet container.\n *\n * @author Rossen Stoyanchev\n * @author Sebastien Deleuze\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "signature": "public class SockJsHttpRequestHandler",
    "source_code": "public class SockJsHttpRequestHandler"
  },
  "org.springframework.web.socket.sockjs.support.SockJsHttpRequestHandler#getCorsConfiguration(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "CorsConfiguration",
    "signature": "public CorsConfiguration getCorsConfiguration(HttpServletRequest request)",
    "source_code": "\tpublic CorsConfiguration getCorsConfiguration(HttpServletRequest request) {\n\t\tif (this.sockJsService instanceof CorsConfigurationSource ccs) {\n\t\t\treturn ccs.getCorsConfiguration(request);\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.SockJsHttpRequestHandler#getSockJsService()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link SockJsService}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "SockJsService",
    "signature": "public SockJsService getSockJsService()",
    "source_code": "\tpublic SockJsService getSockJsService() {\n\t\treturn this.sockJsService;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.SockJsHttpRequestHandler#getWebSocketHandler()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link WebSocketHandler}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "WebSocketHandler",
    "signature": "public WebSocketHandler getWebSocketHandler()",
    "source_code": "\tpublic WebSocketHandler getWebSocketHandler() {\n\t\treturn this.webSocketHandler;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.SockJsHttpRequestHandler#handleRequest(servletRequest,servletResponse)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletRequest",
      "servletResponse"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void handleRequest(HttpServletRequest servletRequest, HttpServletResponse servletResponse)",
    "source_code": "\tpublic void handleRequest(HttpServletRequest servletRequest, HttpServletResponse servletResponse)"
  },
  "org.springframework.web.socket.sockjs.support.SockJsHttpRequestHandler#isRunning()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "boolean",
    "signature": "public boolean isRunning()",
    "source_code": "\tpublic boolean isRunning() {\n\t\treturn this.running;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.SockJsHttpRequestHandler#setServletContext(servletContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "void",
    "signature": "public void setServletContext(ServletContext servletContext)",
    "source_code": "\tpublic void setServletContext(ServletContext servletContext) {\n\t\tif (this.sockJsService instanceof ServletContextAware servletContextAware) {\n\t\t\tservletContextAware.setServletContext(servletContext);\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.SockJsHttpRequestHandler#start()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "void",
    "signature": "public void start()",
    "source_code": "\tpublic void start() {\n\t\tif (!isRunning()) {\n\t\t\tthis.running = true;\n\t\t\tif (this.sockJsService instanceof Lifecycle lifecycle) {\n\t\t\t\tlifecycle.start();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.SockJsHttpRequestHandler#stop()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void stop()",
    "source_code": "\tpublic void stop() {\n\t\tif (isRunning()) {\n\t\t\tthis.running = false;\n\t\t\tif (this.sockJsService instanceof Lifecycle lifecycle) {\n\t\t\t\tlifecycle.stop();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.DefaultSockJsService": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A default implementation of {@link org.springframework.web.socket.sockjs.SockJsService}\n * with all default {@link TransportHandler} implementations pre-registered.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "signature": "public class DefaultSockJsService",
    "source_code": "public class DefaultSockJsService extends TransportHandlingSockJsService implements ServletContextAware {\n\n\t/**\n\t * Create a DefaultSockJsService with default {@link TransportHandler handler} types.\n\t * @param scheduler a task scheduler for heart-beat messages and removing\n\t * timed-out sessions; the provided TaskScheduler should be declared as a\n\t * Spring bean to ensure it is initialized at start up and shut down when the\n\t * application stops.\n\t */\n\tpublic DefaultSockJsService(TaskScheduler scheduler) {\n\t\tthis(scheduler, getDefaultTransportHandlers(null));\n\t}\n\n\t/**\n\t * Create a DefaultSockJsService with overridden {@link TransportHandler handler} types\n\t * replacing the corresponding default handler implementation.\n\t * @param scheduler a task scheduler for heart-beat messages and removing timed-out sessions;\n\t * the provided TaskScheduler should be declared as a Spring bean to ensure it gets\n\t * initialized at start-up and shuts down when the application stops\n\t * @param handlerOverrides zero or more overrides to the default transport handler types\n\t */\n\tpublic DefaultSockJsService(TaskScheduler scheduler, TransportHandler... handlerOverrides) {\n\t\tthis(scheduler, Arrays.asList(handlerOverrides));\n\t}\n\n\t/**\n\t * Create a DefaultSockJsService with overridden {@link TransportHandler handler} types\n\t * replacing the corresponding default handler implementation.\n\t * @param scheduler a task scheduler for heart-beat messages and removing timed-out sessions;\n\t * the provided TaskScheduler should be declared as a Spring bean to ensure it gets\n\t * initialized at start-up and shuts down when the application stops\n\t * @param handlerOverrides zero or more overrides to the default transport handler types\n\t */\n\tpublic DefaultSockJsService(TaskScheduler scheduler, Collection<TransportHandler> handlerOverrides) {\n\t\tsuper(scheduler, getDefaultTransportHandlers(handlerOverrides));\n\t}\n\n\n\tprivate static Set<TransportHandler> getDefaultTransportHandlers(@Nullable Collection<TransportHandler> overrides) {\n\t\tSet<TransportHandler> result = new LinkedHashSet<>(8);\n\t\tresult.add(new XhrPollingTransportHandler());\n\t\tresult.add(new XhrReceivingTransportHandler());\n\t\tresult.add(new XhrStreamingTransportHandler());\n\t\tresult.add(new EventSourceTransportHandler());\n\t\tresult.add(new HtmlFileTransportHandler());\n\t\ttry {\n\t\t\tresult.add(new WebSocketTransportHandler(new DefaultHandshakeHandler()));\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tLog logger = LogFactory.getLog(DefaultSockJsService.class);\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Failed to create a default WebSocketTransportHandler\", ex);\n\t\t\t}\n\t\t}\n\t\tif (overrides != null) {\n\t\t\tresult.addAll(overrides);\n\t\t}\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic void setServletContext(ServletContext servletContext) {\n\t\tfor (TransportHandler handler : getTransportHandlers().values()) {\n\t\t\tif (handler instanceof ServletContextAware servletContextAware) {\n\t\t\t\tservletContextAware.setServletContext(servletContext);\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.DefaultSockJsService#setServletContext(servletContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "void",
    "signature": "public void setServletContext(ServletContext servletContext)",
    "source_code": "\tpublic void setServletContext(ServletContext servletContext) {\n\t\tfor (TransportHandler handler : getTransportHandlers().values()) {\n\t\t\tif (handler instanceof ServletContextAware servletContextAware) {\n\t\t\t\tservletContextAware.setServletContext(servletContext);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.SockJsWebSocketHandler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * An implementation of {@link WebSocketHandler} that adds SockJS messages frames, sends\n * SockJS heartbeat messages, and delegates lifecycle events and messages to a target\n * {@link WebSocketHandler}.\n *\n * <p>Methods in this class allow exceptions from the wrapped {@link WebSocketHandler} to\n * propagate. However, any exceptions resulting from SockJS message handling (e.g. while\n * sending SockJS frames or heartbeat messages) are caught and treated as transport\n * errors, i.e. routed to the\n * {@link WebSocketHandler#handleTransportError(WebSocketSession, Throwable)\n * handleTransportError} method of the wrapped handler and the session closed.\n *\n * @author Rossen Stoyanchev\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "public class SockJsWebSocketHandler",
    "source_code": "public class SockJsWebSocketHandler extends TextWebSocketHandler implements SubProtocolCapable {\n\n\tprivate final SockJsServiceConfig sockJsServiceConfig;\n\n\tprivate final WebSocketServerSockJsSession sockJsSession;\n\n\tprivate final List<String> subProtocols;\n\n\tprivate final AtomicInteger sessionCount = new AtomicInteger();\n\n\n\tpublic SockJsWebSocketHandler(SockJsServiceConfig serviceConfig, WebSocketHandler webSocketHandler,\n\t\t\tWebSocketServerSockJsSession sockJsSession) {\n\n\t\tAssert.notNull(serviceConfig, \"serviceConfig must not be null\");\n\t\tAssert.notNull(webSocketHandler, \"webSocketHandler must not be null\");\n\t\tAssert.notNull(sockJsSession, \"session must not be null\");\n\n\t\tthis.sockJsServiceConfig = serviceConfig;\n\t\tthis.sockJsSession = sockJsSession;\n\n\t\twebSocketHandler = WebSocketHandlerDecorator.unwrap(webSocketHandler);\n\t\tthis.subProtocols = ((webSocketHandler instanceof SubProtocolCapable subProtocolCapable) ?\n\t\t\t\tnew ArrayList<>(subProtocolCapable.getSubProtocols()) : Collections.emptyList());\n\t}\n\n\t@Override\n\tpublic List<String> getSubProtocols() {\n\t\treturn this.subProtocols;\n\t}\n\n\tprotected SockJsServiceConfig getSockJsConfig() {\n\t\treturn this.sockJsServiceConfig;\n\t}\n\n\t@Override\n\tpublic void afterConnectionEstablished(WebSocketSession wsSession) throws Exception {\n\t\tAssert.state(this.sessionCount.compareAndSet(0, 1), \"Unexpected connection\");\n\t\tthis.sockJsSession.initializeDelegateSession(wsSession);\n\t}\n\n\t@Override\n\tpublic void handleTextMessage(WebSocketSession wsSession, TextMessage message) throws Exception {\n\t\tthis.sockJsSession.handleMessage(message, wsSession);\n\t}\n\n\t@Override\n\tpublic void afterConnectionClosed(WebSocketSession wsSession, CloseStatus status) throws Exception {\n\t\tthis.sockJsSession.delegateConnectionClosed(status);\n\t}\n\n\t@Override\n\tpublic void handleTransportError(WebSocketSession webSocketSession, Throwable exception) throws Exception {\n\t\tthis.sockJsSession.delegateError(exception);\n\t}\n\n}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.SockJsWebSocketHandler#afterConnectionClosed(wsSession,status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "wsSession",
      "status"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "void",
    "signature": "public void afterConnectionClosed(WebSocketSession wsSession, CloseStatus status)",
    "source_code": "\tpublic void afterConnectionClosed(WebSocketSession wsSession, CloseStatus status) throws Exception {\n\t\tthis.sockJsSession.delegateConnectionClosed(status);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.SockJsWebSocketHandler#afterConnectionEstablished(wsSession)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "wsSession"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "void",
    "signature": "public void afterConnectionEstablished(WebSocketSession wsSession)",
    "source_code": "\tpublic void afterConnectionEstablished(WebSocketSession wsSession) throws Exception {\n\t\tAssert.state(this.sessionCount.compareAndSet(0, 1), \"Unexpected connection\");\n\t\tthis.sockJsSession.initializeDelegateSession(wsSession);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.SockJsWebSocketHandler#getSockJsConfig()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "SockJsServiceConfig",
    "signature": "protected SockJsServiceConfig getSockJsConfig()",
    "source_code": "\tprotected SockJsServiceConfig getSockJsConfig() {\n\t\treturn this.sockJsServiceConfig;\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.SockJsWebSocketHandler#getSubProtocols()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "List<String>",
    "signature": "public List<String> getSubProtocols()",
    "source_code": "\tpublic List<String> getSubProtocols() {\n\t\treturn this.subProtocols;\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.SockJsWebSocketHandler#handleTextMessage(wsSession,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "wsSession",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "void",
    "signature": "public void handleTextMessage(WebSocketSession wsSession, TextMessage message)",
    "source_code": "\tpublic void handleTextMessage(WebSocketSession wsSession, TextMessage message) throws Exception {\n\t\tthis.sockJsSession.handleMessage(message, wsSession);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.SockJsWebSocketHandler#handleTransportError(webSocketSession,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webSocketSession",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "void",
    "signature": "public void handleTransportError(WebSocketSession webSocketSession, Throwable exception)",
    "source_code": "\tpublic void handleTransportError(WebSocketSession webSocketSession, Throwable exception) throws Exception {\n\t\tthis.sockJsSession.delegateError(exception);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.WebSocketTransportHandler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * WebSocket-based {@link TransportHandler}. Uses {@link SockJsWebSocketHandler} and\n * {@link WebSocketServerSockJsSession} to add SockJS processing.\n *\n * <p>Also implements {@link HandshakeHandler} to support raw WebSocket communication at\n * SockJS URL \"/websocket\".\n *\n * @author Rossen Stoyanchev\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "public class WebSocketTransportHandler",
    "source_code": "public class WebSocketTransportHandler extends AbstractTransportHandler"
  },
  "org.springframework.web.socket.sockjs.transport.handler.WebSocketTransportHandler#checkSessionType(session)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "boolean",
    "signature": "public boolean checkSessionType(SockJsSession session)",
    "source_code": "\tpublic boolean checkSessionType(SockJsSession session) {\n\t\treturn (session instanceof WebSocketServerSockJsSession);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.WebSocketTransportHandler#createSession(id,handler,Map<String,attrs)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "id",
      "handler",
      "Map<String",
      "attrs"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "AbstractSockJsSession",
    "signature": "public AbstractSockJsSession createSession(String id, WebSocketHandler handler, Map<String, Object> attrs)",
    "source_code": "\tpublic AbstractSockJsSession createSession(String id, WebSocketHandler handler, Map<String, Object> attrs) {\n\t\treturn new WebSocketServerSockJsSession(id, getServiceConfig(), handler, attrs);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.WebSocketTransportHandler#doHandshake(request,response,handler,Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "boolean",
    "signature": "public boolean doHandshake(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler handler, Map<String, Object> attributes)",
    "source_code": "\tpublic boolean doHandshake(ServerHttpRequest request, ServerHttpResponse response,"
  },
  "org.springframework.web.socket.sockjs.transport.handler.WebSocketTransportHandler#getHandshakeHandler()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "HandshakeHandler",
    "signature": "public HandshakeHandler getHandshakeHandler()",
    "source_code": "\tpublic HandshakeHandler getHandshakeHandler() {\n\t\treturn this.handshakeHandler;\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.WebSocketTransportHandler#getTransportType()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "TransportType",
    "signature": "public TransportType getTransportType()",
    "source_code": "\tpublic TransportType getTransportType() {\n\t\treturn TransportType.WEBSOCKET;\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.WebSocketTransportHandler#handleRequest(request,response,wsHandler,wsSession)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "wsHandler",
      "wsSession"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "void",
    "signature": "public void handleRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, SockJsSession wsSession)",
    "source_code": "\tpublic void handleRequest(ServerHttpRequest request, ServerHttpResponse response,"
  },
  "org.springframework.web.socket.sockjs.transport.handler.WebSocketTransportHandler#isRunning()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "boolean",
    "signature": "public boolean isRunning()",
    "source_code": "\tpublic boolean isRunning() {\n\t\treturn this.running;\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.WebSocketTransportHandler#setServletContext(servletContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "void",
    "signature": "public void setServletContext(ServletContext servletContext)",
    "source_code": "\tpublic void setServletContext(ServletContext servletContext) {\n\t\tif (this.handshakeHandler instanceof ServletContextAware servletContextAware) {\n\t\t\tservletContextAware.setServletContext(servletContext);\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.WebSocketTransportHandler#start()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void start()",
    "source_code": "\tpublic void start() {\n\t\tif (!isRunning()) {\n\t\t\tthis.running = true;\n\t\t\tif (this.handshakeHandler instanceof Lifecycle lifecycle) {\n\t\t\t\tlifecycle.start();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.WebSocketTransportHandler#stop()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "void",
    "signature": "public void stop()",
    "source_code": "\tpublic void stop() {\n\t\tif (isRunning()) {\n\t\t\tthis.running = false;\n\t\t\tif (this.handshakeHandler instanceof Lifecycle lifecycle) {\n\t\t\t\tlifecycle.stop();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.AbstractHttpSockJsSession": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * An abstract base class for use with HTTP transport SockJS sessions.\n *\n * @author Rossen Stoyanchev\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "signature": "public class AbstractHttpSockJsSession",
    "source_code": "public abstract class AbstractHttpSockJsSession extends AbstractSockJsSession {\n\n\tprivate final Queue<String> messageCache;\n\n\t@Nullable\n\tprivate volatile URI uri;\n\n\t@Nullable\n\tprivate volatile HttpHeaders handshakeHeaders;\n\n\t@Nullable\n\tprivate volatile Principal principal;\n\n\t@Nullable\n\tprivate volatile InetSocketAddress localAddress;\n\n\t@Nullable\n\tprivate volatile InetSocketAddress remoteAddress;\n\n\t@Nullable\n\tprivate volatile String acceptedProtocol;\n\n\t@Nullable\n\tprivate volatile ServerHttpResponse response;\n\n\t@Nullable\n\tprivate volatile SockJsFrameFormat frameFormat;\n\n\t@Nullable\n\tprivate volatile ServerHttpAsyncRequestControl asyncRequestControl;\n\n\tprivate boolean readyToSend;\n\n\n\tpublic AbstractHttpSockJsSession(String id, SockJsServiceConfig config,\n\t\t\tWebSocketHandler wsHandler, Map<String, Object> attributes) {\n\n\t\tsuper(id, config, wsHandler, attributes);\n\t\tthis.messageCache = new LinkedBlockingQueue<>(config.getHttpMessageCacheSize());\n\t}\n\n\n\t@Override\n\tpublic URI getUri() {\n\t\tURI uri = this.uri;\n\t\tAssert.state(uri != null, \"No initial request yet\");\n\t\treturn uri;\n\t}\n\n\t@Override\n\tpublic HttpHeaders getHandshakeHeaders() {\n\t\tHttpHeaders headers = this.handshakeHeaders;\n\t\tAssert.state(headers != null, \"No initial request yet\");\n\t\treturn headers;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Principal getPrincipal() {\n\t\treturn this.principal;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic InetSocketAddress getLocalAddress() {\n\t\treturn this.localAddress;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic InetSocketAddress getRemoteAddress() {\n\t\treturn this.remoteAddress;\n\t}\n\n\t/**\n\t * Unlike WebSocket where sub-protocol negotiation is part of the initial\n\t * handshake, in HTTP transports the same negotiation must be emulated and\n\t * the selected protocol set through this setter.\n\t * @param protocol the sub-protocol to set\n\t */\n\tpublic void setAcceptedProtocol(@Nullable String protocol) {\n\t\tthis.acceptedProtocol = protocol;\n\t}\n\n\t/**\n\t * Return the selected sub-protocol to use.\n\t */\n\t@Override\n\t@Nullable\n\tpublic String getAcceptedProtocol() {\n\t\treturn this.acceptedProtocol;\n\t}\n\n\t/**\n\t * Return the SockJS buffer for messages stored transparently between polling\n\t * requests. If the polling request takes longer than 5 seconds, the session\n\t * is closed.\n\t * @see org.springframework.web.socket.sockjs.transport.TransportHandlingSockJsService\n\t */\n\tprotected Queue<String> getMessageCache() {\n\t\treturn this.messageCache;\n\t}\n\n\n\t@Override\n\tpublic boolean isActive() {\n\t\tServerHttpAsyncRequestControl control = this.asyncRequestControl;\n\t\treturn (control != null && !control.isCompleted());\n\t}\n\n\t@Override\n\tpublic void setTextMessageSizeLimit(int messageSizeLimit) {\n\t\t// ignore\n\t}\n\n\t@Override\n\tpublic int getTextMessageSizeLimit() {\n\t\treturn -1;\n\t}\n\n\t@Override\n\tpublic void setBinaryMessageSizeLimit(int messageSizeLimit) {\n\t\t// ignore\n\t}\n\n\t@Override\n\tpublic int getBinaryMessageSizeLimit() {\n\t\treturn -1;\n\t}\n\n\t@Override\n\tpublic List<WebSocketExtension> getExtensions() {\n\t\treturn Collections.emptyList();\n\t}\n\n\n\t/**\n\t * Handle the first request for receiving messages on a SockJS HTTP transport\n\t * based session.\n\t * <p>Long polling-based transports (e.g. \"xhr\", \"jsonp\") complete the request\n\t * after writing the open frame. Streaming-based transports (\"xhr_streaming\",\n\t * \"eventsource\", and \"htmlfile\") leave the response open longer for further\n\t * streaming of message frames but will also close it eventually after some\n\t * amount of data has been sent.\n\t * @param request the current request\n\t * @param response the current response\n\t * @param frameFormat the transport-specific SocksJS frame format to use\n\t */\n\tpublic void handleInitialRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tSockJsFrameFormat frameFormat) throws SockJsException {\n\n\t\tthis.uri = request.getURI();\n\t\tthis.handshakeHeaders = request.getHeaders();\n\t\tthis.principal = request.getPrincipal();\n\t\ttry {\n\t\t\tthis.localAddress = request.getLocalAddress();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\t// Ignore\n\t\t}\n\t\ttry {\n\t\t\tthis.remoteAddress = request.getRemoteAddress();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\t// Ignore\n\t\t}\n\n\t\tsynchronized (this.responseLock) {\n\t\t\ttry {\n\t\t\t\tthis.response = response;\n\t\t\t\tthis.frameFormat = frameFormat;\n\t\t\t\tServerHttpAsyncRequestControl control = request.getAsyncRequestControl(response);\n\t\t\t\tthis.asyncRequestControl = control;\n\t\t\t\tcontrol.start(-1);\n\t\t\t\tdisableShallowEtagHeaderFilter(request);\n\t\t\t\t// Let \"our\" handler know before sending the open frame to the remote handler\n\t\t\t\tdelegateConnectionEstablished();\n\t\t\t\thandleRequestInternal(request, response, true);\n\t\t\t\t// Request might have been reset (e.g. polling sessions do after writing)\n\t\t\t\tthis.readyToSend = isActive();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\ttryCloseWithSockJsTransportError(ex, CloseStatus.SERVER_ERROR);\n\t\t\t\tthrow new SockJsTransportFailureException(\"Failed to open session\", getId(), ex);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Handle all requests, except the first one, to receive messages on a SockJS\n\t * HTTP transport based session.\n\t * <p>Long polling-based transports (e.g. \"xhr\", \"jsonp\") complete the request\n\t * after writing any buffered message frames (or the next one). Streaming-based\n\t * transports (\"xhr_streaming\", \"eventsource\", and \"htmlfile\") leave the\n\t * response open longer for further streaming of message frames but will also\n\t * close it eventually after some amount of data has been sent.\n\t * @param request the current request\n\t * @param response the current response\n\t * @param frameFormat the transport-specific SocksJS frame format to use\n\t */\n\tpublic void handleSuccessiveRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tSockJsFrameFormat frameFormat) throws SockJsException {\n\n\t\tsynchronized (this.responseLock) {\n\t\t\ttry {\n\t\t\t\tif (isClosed()) {\n\t\t\t\t\tString formattedFrame = frameFormat.format(SockJsFrame.closeFrameGoAway());\n\t\t\t\t\tresponse.getBody().write(formattedFrame.getBytes(SockJsFrame.CHARSET));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.response = response;\n\t\t\t\tthis.frameFormat = frameFormat;\n\t\t\t\tServerHttpAsyncRequestControl control = request.getAsyncRequestControl(response);\n\t\t\t\tthis.asyncRequestControl = control;\n\t\t\t\tcontrol.start(-1);\n\t\t\t\tdisableShallowEtagHeaderFilter(request);\n\t\t\t\thandleRequestInternal(request, response, false);\n\t\t\t\tthis.readyToSend = isActive();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\ttryCloseWithSockJsTransportError(ex, CloseStatus.SERVER_ERROR);\n\t\t\t\tthrow new SockJsTransportFailureException(\"Failed to handle SockJS receive request\", getId(), ex);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void disableShallowEtagHeaderFilter(ServerHttpRequest request) {\n\t\tif (request instanceof ServletServerHttpRequest servletServerHttpRequest) {\n\t\t\tServletRequest servletRequest = servletServerHttpRequest.getServletRequest();\n\t\t\tShallowEtagHeaderFilter.disableContentCaching(servletRequest);\n\t\t}\n\t}\n\n\t/**\n\t * Invoked when a SockJS transport request is received.\n\t * @param request the current request\n\t * @param response the current response\n\t * @param initialRequest whether it is the first request for the session\n\t */\n\tprotected abstract void handleRequestInternal(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tboolean initialRequest) throws IOException;\n\n\t@Override\n\tprotected final void sendMessageInternal(String message) throws SockJsTransportFailureException {\n\t\tsynchronized (this.responseLock) {\n\t\t\tthis.messageCache.add(message);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(this.messageCache.size() + \" message(s) to flush in session \" + getId());\n\t\t\t}\n\t\t\tif (isActive() && this.readyToSend) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Session is active, ready to flush.\");\n\t\t\t\t}\n\t\t\t\tcancelHeartbeat();\n\t\t\t\tflushCache();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Session is not active, not ready to flush.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Called when the connection is active and ready to write to the response.\n\t * Subclasses should only call this method from a method where the\n\t * \"responseLock\" is acquired.\n\t */\n\tprotected abstract void flushCache() throws SockJsTransportFailureException;\n\n\n\t@Override\n\tprotected void disconnect(CloseStatus status) {\n\t\tresetRequest();\n\t}\n\n\tprotected void resetRequest() {\n\t\tsynchronized (this.responseLock) {\n\t\t\tServerHttpAsyncRequestControl control = this.asyncRequestControl;\n\t\t\tthis.asyncRequestControl = null;\n\t\t\tthis.readyToSend = false;\n\t\t\tthis.response = null;\n\t\t\tupdateLastActiveTime();\n\t\t\tif (control != null && !control.isCompleted() && control.isStarted()) {\n\t\t\t\ttry {\n\t\t\t\t\tcontrol.complete();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t// Could be part of normal workflow (e.g. browser tab closed)\n\t\t\t\t\tlogger.debug(\"Failed to complete request: \" + ex.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tprotected void writeFrameInternal(SockJsFrame frame) throws IOException {\n\t\tif (isActive()) {\n\t\t\tSockJsFrameFormat frameFormat = this.frameFormat;\n\t\t\tServerHttpResponse response = this.response;\n\t\t\tif (frameFormat != null && response != null) {\n\t\t\t\tString formattedFrame = frameFormat.format(frame);\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Writing to HTTP response: \" + formattedFrame);\n\t\t\t\t}\n\t\t\t\tresponse.getBody().write(formattedFrame.getBytes(SockJsFrame.CHARSET));\n\t\t\t\tresponse.flush();\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.socket.sockjs.transport.session.AbstractHttpSockJsSession#disconnect(status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 327
    },
    "return": "void",
    "signature": "protected void disconnect(CloseStatus status)",
    "source_code": "\tprotected void disconnect(CloseStatus status) {\n\t\tresetRequest();\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.AbstractHttpSockJsSession#flushCache()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Called when the connection is active and ready to write to the response.\n\t * Subclasses should only call this method from a method where the\n\t * \"responseLock\" is acquired.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "void",
    "signature": "protected void flushCache()",
    "source_code": "\tprotected abstract void flushCache() throws SockJsTransportFailureException;"
  },
  "org.springframework.web.socket.sockjs.transport.session.AbstractHttpSockJsSession#getAcceptedProtocol()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the selected sub-protocol to use.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "String",
    "signature": "public String getAcceptedProtocol()",
    "source_code": "\tpublic String getAcceptedProtocol() {\n\t\treturn this.acceptedProtocol;\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.AbstractHttpSockJsSession#getBinaryMessageSizeLimit()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "int",
    "signature": "public int getBinaryMessageSizeLimit()",
    "source_code": "\tpublic int getBinaryMessageSizeLimit() {\n\t\treturn -1;\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.AbstractHttpSockJsSession#getExtensions()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "List<WebSocketExtension>",
    "signature": "public List<WebSocketExtension> getExtensions()",
    "source_code": "\tpublic List<WebSocketExtension> getExtensions() {\n\t\treturn Collections.emptyList();\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.AbstractHttpSockJsSession#getHandshakeHeaders()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders getHandshakeHeaders()",
    "source_code": "\tpublic HttpHeaders getHandshakeHeaders() {\n\t\tHttpHeaders headers = this.handshakeHeaders;\n\t\tAssert.state(headers != null, \"No initial request yet\");\n\t\treturn headers;\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.AbstractHttpSockJsSession#getLocalAddress()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "InetSocketAddress",
    "signature": "public InetSocketAddress getLocalAddress()",
    "source_code": "\tpublic InetSocketAddress getLocalAddress() {\n\t\treturn this.localAddress;\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.AbstractHttpSockJsSession#getMessageCache()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the SockJS buffer for messages stored transparently between polling\n\t * requests. If the polling request takes longer than 5 seconds, the session\n\t * is closed.\n\t * @see org.springframework.web.socket.sockjs.transport.TransportHandlingSockJsService\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "Queue<String>",
    "signature": "protected Queue<String> getMessageCache()",
    "source_code": "\tprotected Queue<String> getMessageCache() {\n\t\treturn this.messageCache;\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.AbstractHttpSockJsSession#getPrincipal()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "Principal",
    "signature": "public Principal getPrincipal()",
    "source_code": "\tpublic Principal getPrincipal() {\n\t\treturn this.principal;\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.AbstractHttpSockJsSession#getRemoteAddress()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "InetSocketAddress",
    "signature": "public InetSocketAddress getRemoteAddress()",
    "source_code": "\tpublic InetSocketAddress getRemoteAddress() {\n\t\treturn this.remoteAddress;\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.AbstractHttpSockJsSession#getTextMessageSizeLimit()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "int",
    "signature": "public int getTextMessageSizeLimit()",
    "source_code": "\tpublic int getTextMessageSizeLimit() {\n\t\treturn -1;\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.AbstractHttpSockJsSession#getUri()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "URI",
    "signature": "public URI getUri()",
    "source_code": "\tpublic URI getUri() {\n\t\tURI uri = this.uri;\n\t\tAssert.state(uri != null, \"No initial request yet\");\n\t\treturn uri;\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.AbstractHttpSockJsSession#handleInitialRequest(request,response,frameFormat)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the first request for receiving messages on a SockJS HTTP transport\n\t * based session.\n\t * <p>Long polling-based transports (e.g. \"xhr\", \"jsonp\") complete the request\n\t * after writing the open frame. Streaming-based transports (\"xhr_streaming\",\n\t * \"eventsource\", and \"htmlfile\") leave the response open longer for further\n\t * streaming of message frames but will also close it eventually after some\n\t * amount of data has been sent.\n\t * @param request the current request\n\t * @param response the current response\n\t * @param frameFormat the transport-specific SocksJS frame format to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "frameFormat"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "void",
    "signature": "public void handleInitialRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tSockJsFrameFormat frameFormat)",
    "source_code": "\tpublic void handleInitialRequest(ServerHttpRequest request, ServerHttpResponse response,"
  },
  "org.springframework.web.socket.sockjs.transport.session.AbstractHttpSockJsSession#handleRequestInternal(request,response,initialRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked when a SockJS transport request is received.\n\t * @param request the current request\n\t * @param response the current response\n\t * @param initialRequest whether it is the first request for the session\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "initialRequest"
    ],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "void",
    "signature": "protected void handleRequestInternal(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tboolean initialRequest)",
    "source_code": "\tprotected abstract void handleRequestInternal(ServerHttpRequest request, ServerHttpResponse response,"
  },
  "org.springframework.web.socket.sockjs.transport.session.AbstractHttpSockJsSession#handleSuccessiveRequest(request,response,frameFormat)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle all requests, except the first one, to receive messages on a SockJS\n\t * HTTP transport based session.\n\t * <p>Long polling-based transports (e.g. \"xhr\", \"jsonp\") complete the request\n\t * after writing any buffered message frames (or the next one). Streaming-based\n\t * transports (\"xhr_streaming\", \"eventsource\", and \"htmlfile\") leave the\n\t * response open longer for further streaming of message frames but will also\n\t * close it eventually after some amount of data has been sent.\n\t * @param request the current request\n\t * @param response the current response\n\t * @param frameFormat the transport-specific SocksJS frame format to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "frameFormat"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "void",
    "signature": "public void handleSuccessiveRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tSockJsFrameFormat frameFormat)",
    "source_code": "\tpublic void handleSuccessiveRequest(ServerHttpRequest request, ServerHttpResponse response,"
  },
  "org.springframework.web.socket.sockjs.transport.session.AbstractHttpSockJsSession#isActive()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "boolean",
    "signature": "public boolean isActive()",
    "source_code": "\tpublic boolean isActive() {\n\t\tServerHttpAsyncRequestControl control = this.asyncRequestControl;\n\t\treturn (control != null && !control.isCompleted());\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.AbstractHttpSockJsSession#resetRequest()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 331
    },
    "return": "void",
    "signature": "protected void resetRequest()",
    "source_code": "\tprotected void resetRequest() {\n\t\tsynchronized (this.responseLock) {\n\t\t\tServerHttpAsyncRequestControl control = this.asyncRequestControl;\n\t\t\tthis.asyncRequestControl = null;\n\t\t\tthis.readyToSend = false;\n\t\t\tthis.response = null;\n\t\t\tupdateLastActiveTime();\n\t\t\tif (control != null && !control.isCompleted() && control.isStarted()) {\n\t\t\t\ttry {\n\t\t\t\t\tcontrol.complete();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t// Could be part of normal workflow (e.g. browser tab closed)\n\t\t\t\t\tlogger.debug(\"Failed to complete request: \" + ex.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.AbstractHttpSockJsSession#sendMessageInternal(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "void",
    "signature": "protected void sendMessageInternal(String message)",
    "source_code": "\tprotected final void sendMessageInternal(String message) throws SockJsTransportFailureException {\n\t\tsynchronized (this.responseLock) {\n\t\t\tthis.messageCache.add(message);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(this.messageCache.size() + \" message(s) to flush in session \" + getId());\n\t\t\t}\n\t\t\tif (isActive() && this.readyToSend) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Session is active, ready to flush.\");\n\t\t\t\t}\n\t\t\t\tcancelHeartbeat();\n\t\t\t\tflushCache();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Session is not active, not ready to flush.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.AbstractHttpSockJsSession#setAcceptedProtocol(protocol)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Unlike WebSocket where sub-protocol negotiation is part of the initial\n\t * handshake, in HTTP transports the same negotiation must be emulated and\n\t * the selected protocol set through this setter.\n\t * @param protocol the sub-protocol to set\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "protocol"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "void",
    "signature": "public void setAcceptedProtocol(@Nullable String protocol)",
    "source_code": "\tpublic void setAcceptedProtocol(@Nullable String protocol) {\n\t\tthis.acceptedProtocol = protocol;\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.AbstractHttpSockJsSession#setBinaryMessageSizeLimit(messageSizeLimit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSizeLimit"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "void",
    "signature": "public void setBinaryMessageSizeLimit(int messageSizeLimit)",
    "source_code": "\tpublic void setBinaryMessageSizeLimit(int messageSizeLimit) {\n\t\t// ignore\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.AbstractHttpSockJsSession#setTextMessageSizeLimit(messageSizeLimit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSizeLimit"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "void",
    "signature": "public void setTextMessageSizeLimit(int messageSizeLimit)",
    "source_code": "\tpublic void setTextMessageSizeLimit(int messageSizeLimit) {\n\t\t// ignore\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.AbstractHttpSockJsSession#writeFrameInternal(frame)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "frame"
    ],
    "position": {
      "column": 1,
      "line": 351
    },
    "return": "void",
    "signature": "protected void writeFrameInternal(SockJsFrame frame)",
    "source_code": "\tprotected void writeFrameInternal(SockJsFrame frame) throws IOException {\n\t\tif (isActive()) {\n\t\t\tSockJsFrameFormat frameFormat = this.frameFormat;\n\t\t\tServerHttpResponse response = this.response;\n\t\t\tif (frameFormat != null && response != null) {\n\t\t\t\tString formattedFrame = frameFormat.format(frame);\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Writing to HTTP response: \" + formattedFrame);\n\t\t\t\t}\n\t\t\t\tresponse.getBody().write(formattedFrame.getBytes(SockJsFrame.CHARSET));\n\t\t\t\tresponse.flush();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A SockJS session for use with the WebSocket transport.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "signature": "public class WebSocketServerSockJsSession",
    "source_code": "public class WebSocketServerSockJsSession extends AbstractSockJsSession implements NativeWebSocketSession {\n\n\t@Nullable\n\tprivate WebSocketSession webSocketSession;\n\n\tprivate volatile boolean openFrameSent;\n\n\tprivate final Queue<String> initSessionCache = new LinkedBlockingDeque<>();\n\n\tprivate final Object initSessionLock = new Object();\n\n\tprivate final Object disconnectLock = new Object();\n\n\tprivate volatile boolean disconnected;\n\n\n\tpublic WebSocketServerSockJsSession(String id, SockJsServiceConfig config,\n\t\t\tWebSocketHandler handler, @Nullable Map<String, Object> attributes) {\n\n\t\tsuper(id, config, handler, attributes);\n\t}\n\n\n\t@Override\n\t@Nullable\n\tpublic URI getUri() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn this.webSocketSession.getUri();\n\t}\n\n\t@Override\n\tpublic HttpHeaders getHandshakeHeaders() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn this.webSocketSession.getHandshakeHeaders();\n\t}\n\n\t@Override\n\tpublic Principal getPrincipal() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn this.webSocketSession.getPrincipal();\n\t}\n\n\t@Override\n\tpublic InetSocketAddress getLocalAddress() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn this.webSocketSession.getLocalAddress();\n\t}\n\n\t@Override\n\tpublic InetSocketAddress getRemoteAddress() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn this.webSocketSession.getRemoteAddress();\n\t}\n\n\t@Override\n\tpublic String getAcceptedProtocol() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn this.webSocketSession.getAcceptedProtocol();\n\t}\n\n\t@Override\n\tpublic void setTextMessageSizeLimit(int messageSizeLimit) {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\tthis.webSocketSession.setTextMessageSizeLimit(messageSizeLimit);\n\t}\n\n\t@Override\n\tpublic int getTextMessageSizeLimit() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn this.webSocketSession.getTextMessageSizeLimit();\n\t}\n\n\t@Override\n\tpublic void setBinaryMessageSizeLimit(int messageSizeLimit) {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\tthis.webSocketSession.setBinaryMessageSizeLimit(messageSizeLimit);\n\t}\n\n\t@Override\n\tpublic int getBinaryMessageSizeLimit() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn this.webSocketSession.getBinaryMessageSizeLimit();\n\t}\n\n\t@Override\n\tpublic List<WebSocketExtension> getExtensions() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn this.webSocketSession.getExtensions();\n\t}\n\n\t@Override\n\tpublic Object getNativeSession() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn (this.webSocketSession instanceof NativeWebSocketSession nativeWsSession ?\n\t\t\t\tnativeWsSession.getNativeSession() : this.webSocketSession);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic <T> T getNativeSession(@Nullable Class<T> requiredType) {\n\t\treturn (this.webSocketSession instanceof NativeWebSocketSession nativeWsSession ?\n\t\t\t\tnativeWsSession.getNativeSession(requiredType) : null);\n\t}\n\n\n\tpublic void initializeDelegateSession(WebSocketSession session) {\n\t\tsynchronized (this.initSessionLock) {\n\t\t\tthis.webSocketSession = session;\n\t\t\ttry {\n\t\t\t\t// Let \"our\" handler know before sending the open frame to the remote handler\n\t\t\t\tdelegateConnectionEstablished();\n\t\t\t\tthis.webSocketSession.sendMessage(new TextMessage(SockJsFrame.openFrame().getContent()));\n\n\t\t\t\t// Flush any messages cached in the meantime\n\t\t\t\twhile (!this.initSessionCache.isEmpty()) {\n\t\t\t\t\twriteFrame(SockJsFrame.messageFrame(getMessageCodec(), this.initSessionCache.poll()));\n\t\t\t\t}\n\t\t\t\tscheduleHeartbeat();\n\t\t\t\tthis.openFrameSent = true;\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\ttryCloseWithSockJsTransportError(ex, CloseStatus.SERVER_ERROR);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isActive() {\n\t\treturn (this.webSocketSession != null && this.webSocketSession.isOpen() && !this.disconnected);\n\t}\n\n\tpublic void handleMessage(TextMessage message, WebSocketSession wsSession) throws Exception {\n\t\tString payload = message.getPayload();\n\t\tif (!StringUtils.hasLength(payload)) {\n\t\t\treturn;\n\t\t}\n\t\tString[] messages;\n\t\ttry {\n\t\t\tmessages = getSockJsServiceConfig().getMessageCodec().decode(payload);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tlogger.error(\"Broken data received. Terminating WebSocket connection abruptly\", ex);\n\t\t\ttryCloseWithSockJsTransportError(ex, CloseStatus.BAD_DATA);\n\t\t\treturn;\n\t\t}\n\t\tif (messages != null) {\n\t\t\tdelegateMessages(messages);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void sendMessageInternal(String message) throws SockJsTransportFailureException {\n\t\t// Open frame not sent yet?\n\t\t// If in the session initialization thread, then cache, otherwise wait.\n\t\tif (!this.openFrameSent) {\n\t\t\tsynchronized (this.initSessionLock) {\n\t\t\t\tif (!this.openFrameSent) {\n\t\t\t\t\tthis.initSessionCache.add(message);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcancelHeartbeat();\n\t\twriteFrame(SockJsFrame.messageFrame(getMessageCodec(), message));\n\t\tscheduleHeartbeat();\n\t}\n\n\t@Override\n\tprotected void writeFrameInternal(SockJsFrame frame) throws IOException {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Writing \" + frame);\n\t\t}\n\t\tTextMessage message = new TextMessage(frame.getContent());\n\t\tthis.webSocketSession.sendMessage(message);\n\t}\n\n\t@Override\n\tprotected void disconnect(CloseStatus status) throws IOException {\n\t\tif (isActive()) {\n\t\t\tsynchronized (this.disconnectLock) {\n\t\t\t\tif (isActive()) {\n\t\t\t\t\tthis.disconnected = true;\n\t\t\t\t\tif (this.webSocketSession != null) {\n\t\t\t\t\t\tthis.webSocketSession.close(status);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession#disconnect(status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "void",
    "signature": "protected void disconnect(CloseStatus status)",
    "source_code": "\tprotected void disconnect(CloseStatus status) throws IOException {\n\t\tif (isActive()) {\n\t\t\tsynchronized (this.disconnectLock) {\n\t\t\t\tif (isActive()) {\n\t\t\t\t\tthis.disconnected = true;\n\t\t\t\t\tif (this.webSocketSession != null) {\n\t\t\t\t\t\tthis.webSocketSession.close(status);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession#getAcceptedProtocol()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "String",
    "signature": "public String getAcceptedProtocol()",
    "source_code": "\tpublic String getAcceptedProtocol() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn this.webSocketSession.getAcceptedProtocol();\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession#getBinaryMessageSizeLimit()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "int",
    "signature": "public int getBinaryMessageSizeLimit()",
    "source_code": "\tpublic int getBinaryMessageSizeLimit() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn this.webSocketSession.getBinaryMessageSizeLimit();\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession#getExtensions()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "List<WebSocketExtension>",
    "signature": "public List<WebSocketExtension> getExtensions()",
    "source_code": "\tpublic List<WebSocketExtension> getExtensions() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn this.webSocketSession.getExtensions();\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession#getHandshakeHeaders()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders getHandshakeHeaders()",
    "source_code": "\tpublic HttpHeaders getHandshakeHeaders() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn this.webSocketSession.getHandshakeHeaders();\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession#getLocalAddress()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "InetSocketAddress",
    "signature": "public InetSocketAddress getLocalAddress()",
    "source_code": "\tpublic InetSocketAddress getLocalAddress() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn this.webSocketSession.getLocalAddress();\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession#getNativeSession()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "Object",
    "signature": "public Object getNativeSession()",
    "source_code": "\tpublic Object getNativeSession() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn (this.webSocketSession instanceof NativeWebSocketSession nativeWsSession ?\n\t\t\t\tnativeWsSession.getNativeSession() : this.webSocketSession);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession#getNativeSession(requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "T",
    "signature": "public T getNativeSession(@Nullable Class<T> requiredType)",
    "source_code": "\tpublic <T> T getNativeSession(@Nullable Class<T> requiredType) {\n\t\treturn (this.webSocketSession instanceof NativeWebSocketSession nativeWsSession ?\n\t\t\t\tnativeWsSession.getNativeSession(requiredType) : null);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession#getPrincipal()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "Principal",
    "signature": "public Principal getPrincipal()",
    "source_code": "\tpublic Principal getPrincipal() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn this.webSocketSession.getPrincipal();\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession#getRemoteAddress()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "InetSocketAddress",
    "signature": "public InetSocketAddress getRemoteAddress()",
    "source_code": "\tpublic InetSocketAddress getRemoteAddress() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn this.webSocketSession.getRemoteAddress();\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession#getTextMessageSizeLimit()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "int",
    "signature": "public int getTextMessageSizeLimit()",
    "source_code": "\tpublic int getTextMessageSizeLimit() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn this.webSocketSession.getTextMessageSizeLimit();\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession#getUri()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "URI",
    "signature": "public URI getUri()",
    "source_code": "\tpublic URI getUri() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn this.webSocketSession.getUri();\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession#handleMessage(message,wsSession)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "wsSession"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "void",
    "signature": "public void handleMessage(TextMessage message, WebSocketSession wsSession)",
    "source_code": "\tpublic void handleMessage(TextMessage message, WebSocketSession wsSession) throws Exception {\n\t\tString payload = message.getPayload();\n\t\tif (!StringUtils.hasLength(payload)) {\n\t\t\treturn;\n\t\t}\n\t\tString[] messages;\n\t\ttry {\n\t\t\tmessages = getSockJsServiceConfig().getMessageCodec().decode(payload);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tlogger.error(\"Broken data received. Terminating WebSocket connection abruptly\", ex);\n\t\t\ttryCloseWithSockJsTransportError(ex, CloseStatus.BAD_DATA);\n\t\t\treturn;\n\t\t}\n\t\tif (messages != null) {\n\t\t\tdelegateMessages(messages);\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession#initializeDelegateSession(session)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "void",
    "signature": "public void initializeDelegateSession(WebSocketSession session)",
    "source_code": "\tpublic void initializeDelegateSession(WebSocketSession session) {\n\t\tsynchronized (this.initSessionLock) {\n\t\t\tthis.webSocketSession = session;\n\t\t\ttry {\n\t\t\t\t// Let \"our\" handler know before sending the open frame to the remote handler\n\t\t\t\tdelegateConnectionEstablished();\n\t\t\t\tthis.webSocketSession.sendMessage(new TextMessage(SockJsFrame.openFrame().getContent()));\n\n\t\t\t\t// Flush any messages cached in the meantime\n\t\t\t\twhile (!this.initSessionCache.isEmpty()) {\n\t\t\t\t\twriteFrame(SockJsFrame.messageFrame(getMessageCodec(), this.initSessionCache.poll()));\n\t\t\t\t}\n\t\t\t\tscheduleHeartbeat();\n\t\t\t\tthis.openFrameSent = true;\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\ttryCloseWithSockJsTransportError(ex, CloseStatus.SERVER_ERROR);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession#isActive()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "boolean",
    "signature": "public boolean isActive()",
    "source_code": "\tpublic boolean isActive() {\n\t\treturn (this.webSocketSession != null && this.webSocketSession.isOpen() && !this.disconnected);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession#sendMessageInternal(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "void",
    "signature": "public void sendMessageInternal(String message)",
    "source_code": "\tpublic void sendMessageInternal(String message) throws SockJsTransportFailureException {\n\t\t// Open frame not sent yet?\n\t\t// If in the session initialization thread, then cache, otherwise wait.\n\t\tif (!this.openFrameSent) {\n\t\t\tsynchronized (this.initSessionLock) {\n\t\t\t\tif (!this.openFrameSent) {\n\t\t\t\t\tthis.initSessionCache.add(message);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcancelHeartbeat();\n\t\twriteFrame(SockJsFrame.messageFrame(getMessageCodec(), message));\n\t\tscheduleHeartbeat();\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession#setBinaryMessageSizeLimit(messageSizeLimit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSizeLimit"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "void",
    "signature": "public void setBinaryMessageSizeLimit(int messageSizeLimit)",
    "source_code": "\tpublic void setBinaryMessageSizeLimit(int messageSizeLimit) {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\tthis.webSocketSession.setBinaryMessageSizeLimit(messageSizeLimit);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession#setTextMessageSizeLimit(messageSizeLimit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSizeLimit"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "void",
    "signature": "public void setTextMessageSizeLimit(int messageSizeLimit)",
    "source_code": "\tpublic void setTextMessageSizeLimit(int messageSizeLimit) {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\tthis.webSocketSession.setTextMessageSizeLimit(messageSizeLimit);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession#writeFrameInternal(frame)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "frame"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "void",
    "signature": "protected void writeFrameInternal(SockJsFrame frame)",
    "source_code": "\tprotected void writeFrameInternal(SockJsFrame frame) throws IOException {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Writing \" + frame);\n\t\t}\n\t\tTextMessage message = new TextMessage(frame.getContent());\n\t\tthis.webSocketSession.sendMessage(message);\n\t}"
  },
  "org.springframework.web.util.pattern.<unknown>#getScore()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "int",
    "signature": "public int getScore()",
    "source_code": "\tpublic int getScore() {\n\t\treturn WILDCARD_WEIGHT;\n\t}"
  },
  "org.springframework.web.util.pattern.<unknown>#isLiteral()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "boolean",
    "signature": "public boolean isLiteral()",
    "source_code": "\tpublic boolean isLiteral() {\n\t\treturn true;\n\t}"
  }
}