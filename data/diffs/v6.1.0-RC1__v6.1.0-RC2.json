{
  "org.springframework.aop.support.ControlFlowPointcut#incrementEvaluationCount()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Increment the {@link #getEvaluations() evaluation count}.\n\t * @since 6.1\n\t * @see #matches(Method, Class, Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "void",
    "signature": "protected void incrementEvaluationCount()",
    "source_code": "\tprotected final void incrementEvaluationCount() {\n\t\tthis.evaluationCount.incrementAndGet();\n\t}"
  },
  "org.springframework.aop.support.NameMatchMethodPointcut#addMethodName(mappedNamePattern)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add another method name pattern, in addition to those already configured.\n\t * <p>Like the \"set\" methods, this method is for use when configuring proxies,\n\t * before a proxy is used.\n\t * <p><b>NOTE:</b> This method does not work after the proxy is in use, since\n\t * advice chains will be cached.\n\t * @param mappedNamePattern the additional method name pattern\n\t * @return this pointcut to allow for method chaining\n\t * @see #setMappedNames(String...)\n\t * @see #setMappedName(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedNamePattern"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "NameMatchMethodPointcut",
    "signature": "public NameMatchMethodPointcut addMethodName(String mappedNamePattern)",
    "source_code": "\tpublic NameMatchMethodPointcut addMethodName(String mappedNamePattern) {\n\t\tthis.mappedNamePatterns.add(mappedNamePattern);\n\t\treturn this;\n\t}"
  },
  "org.springframework.aop.support.NameMatchMethodPointcut#addMethodName(name)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add another eligible method name, in addition to those already named.\n\t * Like the set methods, this method is for use when configuring proxies,\n\t * before a proxy is used.\n\t * <p><b>NB:</b> This method does not work after the proxy is in\n\t * use, as advice chains will be cached.\n\t * @param name the name of the additional method that will match\n\t * @return this pointcut to allow for multiple additions in one line\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "NameMatchMethodPointcut",
    "signature": "public NameMatchMethodPointcut addMethodName(String name)",
    "source_code": "\tpublic NameMatchMethodPointcut addMethodName(String name) {\n\t\tthis.mappedNames.add(name);\n\t\treturn this;\n\t}"
  },
  "org.springframework.aop.support.NameMatchMethodPointcut#isMatch(methodName,mappedName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return if the given method name matches the mapped name.\n\t * <p>The default implementation checks for \"xxx*\", \"*xxx\" and \"*xxx*\" matches,\n\t * as well as direct equality. Can be overridden in subclasses.\n\t * @param methodName the method name of the class\n\t * @param mappedName the name in the descriptor\n\t * @return if the names match\n\t * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "methodName",
      "mappedName"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "boolean",
    "signature": "protected boolean isMatch(String methodName, String mappedName)",
    "source_code": "\tprotected boolean isMatch(String methodName, String mappedName) {\n\t\treturn PatternMatchUtils.simpleMatch(mappedName, methodName);\n\t}"
  },
  "org.springframework.aop.support.NameMatchMethodPointcut#isMatch(methodName,mappedNamePattern)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the given method name matches the mapped name pattern.\n\t * <p>The default implementation checks for {@code xxx*}, {@code *xxx},\n\t * {@code *xxx*}, and {@code xxx*yyy} matches, as well as direct equality.\n\t * <p>Can be overridden in subclasses.\n\t * @param methodName the method name to check\n\t * @param mappedNamePattern the method name pattern\n\t * @return {@code true} if the method name matches the pattern\n\t * @see PatternMatchUtils#simpleMatch(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "methodName",
      "mappedNamePattern"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "boolean",
    "signature": "protected boolean isMatch(String methodName, String mappedNamePattern)",
    "source_code": "\tprotected boolean isMatch(String methodName, String mappedNamePattern) {\n\t\treturn PatternMatchUtils.simpleMatch(mappedNamePattern, methodName);\n\t}"
  },
  "org.springframework.aop.support.NameMatchMethodPointcut#setMappedName(mappedName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenience method when we have only a single method name to match.\n\t * Use either this method or {@code setMappedNames}, not both.\n\t * @see #setMappedNames\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedName"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "return": "void",
    "signature": "public void setMappedName(String mappedName)",
    "source_code": "\tpublic void setMappedName(String mappedName) {\n\t\tsetMappedNames(mappedName);\n\t}"
  },
  "org.springframework.aop.support.NameMatchMethodPointcut#setMappedName(mappedNamePattern)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenience method for configuring a single method name pattern.\n\t * <p>Use either this method or {@link #setMappedNames(String...)}, but not both.\n\t * @see #setMappedNames\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedNamePattern"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "void",
    "signature": "public void setMappedName(String mappedNamePattern)",
    "source_code": "\tpublic void setMappedName(String mappedNamePattern) {\n\t\tsetMappedNames(mappedNamePattern);\n\t}"
  },
  "org.springframework.aop.support.NameMatchMethodPointcut#setMappedNames(mappedNamePatterns)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the method name patterns defining methods to match.\n\t * <p>Matching will be the union of all these; if any match, the pointcut matches.\n\t * @see #setMappedName(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedNamePatterns"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "void",
    "signature": "public void setMappedNames(String... mappedNamePatterns)",
    "source_code": "\tpublic void setMappedNames(String... mappedNamePatterns) {\n\t\tthis.mappedNamePatterns = new ArrayList<>(Arrays.asList(mappedNamePatterns));\n\t}"
  },
  "org.springframework.aop.support.NameMatchMethodPointcut#setMappedNames(mappedNames)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the method names defining methods to match.\n\t * Matching will be the union of all these; if any match,\n\t * the pointcut matches.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedNames"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "void",
    "signature": "public void setMappedNames(String... mappedNames)",
    "source_code": "\tpublic void setMappedNames(String... mappedNames) {\n\t\tthis.mappedNames = new ArrayList<>(Arrays.asList(mappedNames));\n\t}"
  },
  "org.springframework.aop.support.methodName": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The method against which to match, potentially {@code null}.\n\t * <p>Available for use in subclasses since 6.1.\n\t */",
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "signature": "protected String methodName",
    "source_code": "\tprotected final String methodName;",
    "type": "String"
  },
  "org.springframework.beans.<unknown>#getReadMethodType()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType getReadMethodType()",
    "source_code": "\tpublic ResolvableType getReadMethodType() {\n\t\tAssert.state(this.readMethodType != null, \"No read method available\");\n\t\treturn this.readMethodType;\n\t}"
  },
  "org.springframework.beans.<unknown>#getTypeDescriptor()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getTypeDescriptor()",
    "source_code": "\tpublic TypeDescriptor getTypeDescriptor() {\n\t\tTypeDescriptor typeDescriptor = this.typeDescriptor;\n\t\tif (typeDescriptor == null) {\n\t\t\tProperty property = new Property(getBeanClass(), getReadMethod(), getWriteMethod(), getName());\n\t\t\ttypeDescriptor = new TypeDescriptor(property);\n\t\t\tthis.typeDescriptor = typeDescriptor;\n\t\t}\n\t\treturn typeDescriptor;\n\t}"
  },
  "org.springframework.beans.<unknown>#getWriteMethodType()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType getWriteMethodType()",
    "source_code": "\tpublic ResolvableType getWriteMethodType() {\n\t\tResolvableType writeMethodType = this.writeMethodType;\n\t\tif (writeMethodType == null) {\n\t\t\twriteMethodType = ResolvableType.forMethodParameter(getWriteMethodParameter());\n\t\t\tthis.writeMethodType = writeMethodType;\n\t\t}\n\t\treturn writeMethodType;\n\t}"
  },
  "org.springframework.beans.BeanWrapperImpl": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Default {@link BeanWrapper} implementation that should be sufficient\n * for all typical use cases. Caches introspection results for efficiency.\n *\n * <p>Note: Auto-registers default property editors from the\n * {@code org.springframework.beans.propertyeditors} package, which apply\n * in addition to the JDK's standard PropertyEditors. Applications can call\n * the {@link #registerCustomEditor(Class, java.beans.PropertyEditor)} method\n * to register an editor for a particular instance (i.e. they are not shared\n * across the application). See the base class\n * {@link PropertyEditorRegistrySupport} for details.\n *\n * <p><b>NOTE: As of Spring 2.5, this is - for almost all purposes - an\n * internal class.</b> It is just public in order to allow for access from\n * other framework packages. For standard application access purposes, use the\n * {@link PropertyAccessorFactory#forBeanPropertyAccess} factory method instead.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Stephane Nicoll\n * @since 15 April 2001\n * @see #registerCustomEditor\n * @see #setPropertyValues\n * @see #setPropertyValue\n * @see #getPropertyValue\n * @see #getPropertyType\n * @see BeanWrapper\n * @see PropertyEditorRegistrySupport\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "signature": "public class BeanWrapperImpl",
    "source_code": "public class BeanWrapperImpl extends AbstractNestablePropertyAccessor implements BeanWrapper {\n\n\t/**\n\t * Cached introspections results for this object, to prevent encountering\n\t * the cost of JavaBeans introspection every time.\n\t */\n\t@Nullable\n\tprivate CachedIntrospectionResults cachedIntrospectionResults;\n\n\n\t/**\n\t * Create a new empty BeanWrapperImpl. Wrapped instance needs to be set afterwards.\n\t * Registers default editors.\n\t * @see #setWrappedInstance\n\t */\n\tpublic BeanWrapperImpl() {\n\t\tthis(true);\n\t}\n\n\t/**\n\t * Create a new empty BeanWrapperImpl. Wrapped instance needs to be set afterwards.\n\t * @param registerDefaultEditors whether to register default editors\n\t * (can be suppressed if the BeanWrapper won't need any type conversion)\n\t * @see #setWrappedInstance\n\t */\n\tpublic BeanWrapperImpl(boolean registerDefaultEditors) {\n\t\tsuper(registerDefaultEditors);\n\t}\n\n\t/**\n\t * Create a new BeanWrapperImpl for the given object.\n\t * @param object the object wrapped by this BeanWrapper\n\t */\n\tpublic BeanWrapperImpl(Object object) {\n\t\tsuper(object);\n\t}\n\n\t/**\n\t * Create a new BeanWrapperImpl, wrapping a new instance of the specified class.\n\t * @param clazz class to instantiate and wrap\n\t */\n\tpublic BeanWrapperImpl(Class<?> clazz) {\n\t\tsuper(clazz);\n\t}\n\n\t/**\n\t * Create a new BeanWrapperImpl for the given object,\n\t * registering a nested path that the object is in.\n\t * @param object the object wrapped by this BeanWrapper\n\t * @param nestedPath the nested path of the object\n\t * @param rootObject the root object at the top of the path\n\t */\n\tpublic BeanWrapperImpl(Object object, String nestedPath, Object rootObject) {\n\t\tsuper(object, nestedPath, rootObject);\n\t}\n\n\t/**\n\t * Create a new BeanWrapperImpl for the given object,\n\t * registering a nested path that the object is in.\n\t * @param object the object wrapped by this BeanWrapper\n\t * @param nestedPath the nested path of the object\n\t * @param parent the containing BeanWrapper (must not be {@code null})\n\t */\n\tprivate BeanWrapperImpl(Object object, String nestedPath, BeanWrapperImpl parent) {\n\t\tsuper(object, nestedPath, parent);\n\t}\n\n\n\t/**\n\t * Set a bean instance to hold, without any unwrapping of {@link java.util.Optional}.\n\t * @param object the actual target object\n\t * @since 4.3\n\t * @see #setWrappedInstance(Object)\n\t */\n\tpublic void setBeanInstance(Object object) {\n\t\tthis.wrappedObject = object;\n\t\tthis.rootObject = object;\n\t\tthis.typeConverterDelegate = new TypeConverterDelegate(this, this.wrappedObject);\n\t\tsetIntrospectionClass(object.getClass());\n\t}\n\n\t@Override\n\tpublic void setWrappedInstance(Object object, @Nullable String nestedPath, @Nullable Object rootObject) {\n\t\tsuper.setWrappedInstance(object, nestedPath, rootObject);\n\t\tsetIntrospectionClass(getWrappedClass());\n\t}\n\n\t/**\n\t * Set the class to introspect.\n\t * Needs to be called when the target object changes.\n\t * @param clazz the class to introspect\n\t */\n\tprotected void setIntrospectionClass(Class<?> clazz) {\n\t\tif (this.cachedIntrospectionResults != null && this.cachedIntrospectionResults.getBeanClass() != clazz) {\n\t\t\tthis.cachedIntrospectionResults = null;\n\t\t}\n\t}\n\n\t/**\n\t * Obtain a lazily initialized CachedIntrospectionResults instance\n\t * for the wrapped object.\n\t */\n\tprivate CachedIntrospectionResults getCachedIntrospectionResults() {\n\t\tif (this.cachedIntrospectionResults == null) {\n\t\t\tthis.cachedIntrospectionResults = CachedIntrospectionResults.forClass(getWrappedClass());\n\t\t}\n\t\treturn this.cachedIntrospectionResults;\n\t}\n\n\n\t/**\n\t * Convert the given value for the specified property to the latter's type.\n\t * <p>This method is only intended for optimizations in a BeanFactory.\n\t * Use the {@code convertIfNecessary} methods for programmatic conversion.\n\t * @param value the value to convert\n\t * @param propertyName the target property\n\t * (note that nested or indexed properties are not supported here)\n\t * @return the new value, possibly the result of type conversion\n\t * @throws TypeMismatchException if type conversion failed\n\t */\n\t@Nullable\n\tpublic Object convertForProperty(@Nullable Object value, String propertyName) throws TypeMismatchException {\n\t\tCachedIntrospectionResults cachedIntrospectionResults = getCachedIntrospectionResults();\n\t\tPropertyDescriptor pd = cachedIntrospectionResults.getPropertyDescriptor(propertyName);\n\t\tif (pd == null) {\n\t\t\tthrow new InvalidPropertyException(getRootClass(), getNestedPath() + propertyName,\n\t\t\t\t\t\"No property '\" + propertyName + \"' found\");\n\t\t}\n\t\tTypeDescriptor td = cachedIntrospectionResults.getTypeDescriptor(pd);\n\t\tif (td == null) {\n\t\t\ttd = cachedIntrospectionResults.addTypeDescriptor(pd, new TypeDescriptor(property(pd)));\n\t\t}\n\t\treturn convertForProperty(propertyName, null, value, td);\n\t}\n\n\tprivate Property property(PropertyDescriptor pd) {\n\t\tGenericTypeAwarePropertyDescriptor gpd = (GenericTypeAwarePropertyDescriptor) pd;\n\t\treturn new Property(gpd.getBeanClass(), gpd.getReadMethod(), gpd.getWriteMethod(), gpd.getName());\n\t}\n\n\t@Override\n\t@Nullable\n\tprotected BeanPropertyHandler getLocalPropertyHandler(String propertyName) {\n\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(propertyName);\n\t\treturn (pd != null ? new BeanPropertyHandler(pd) : null);\n\t}\n\n\t@Override\n\tprotected BeanWrapperImpl newNestedPropertyAccessor(Object object, String nestedPath) {\n\t\treturn new BeanWrapperImpl(object, nestedPath, this);\n\t}\n\n\t@Override\n\tprotected NotWritablePropertyException createNotWritablePropertyException(String propertyName) {\n\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n\t\tthrow new NotWritablePropertyException(getRootClass(), getNestedPath() + propertyName,\n\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t}\n\n\t@Override\n\tpublic PropertyDescriptor[] getPropertyDescriptors() {\n\t\treturn getCachedIntrospectionResults().getPropertyDescriptors();\n\t}\n\n\t@Override\n\tpublic PropertyDescriptor getPropertyDescriptor(String propertyName) throws InvalidPropertyException {\n\t\tBeanWrapperImpl nestedBw = (BeanWrapperImpl) getPropertyAccessorForPropertyPath(propertyName);\n\t\tString finalPath = getFinalPath(nestedBw, propertyName);\n\t\tPropertyDescriptor pd = nestedBw.getCachedIntrospectionResults().getPropertyDescriptor(finalPath);\n\t\tif (pd == null) {\n\t\t\tthrow new InvalidPropertyException(getRootClass(), getNestedPath() + propertyName,\n\t\t\t\t\t\"No property '\" + propertyName + \"' found\");\n\t\t}\n\t\treturn pd;\n\t}\n\n\n\tprivate class BeanPropertyHandler extends PropertyHandler {\n\n\t\tprivate final PropertyDescriptor pd;\n\n\t\tprivate final TypeDescriptor typeDescriptor;\n\n\t\tpublic BeanPropertyHandler(PropertyDescriptor pd) {\n\t\t\tsuper(pd.getPropertyType(), pd.getReadMethod() != null, pd.getWriteMethod() != null);\n\t\t\tthis.pd = pd;\n\t\t\tthis.typeDescriptor = new TypeDescriptor(property(pd));\n\t\t}\n\n\t\t@Override\n\t\tpublic TypeDescriptor toTypeDescriptor() {\n\t\t\treturn this.typeDescriptor;\n\t\t}\n\n\t\t@Override\n\t\tpublic ResolvableType getResolvableType() {\n\t\t\treturn this.typeDescriptor.getResolvableType();\n\t\t}\n\n\t\t@Override\n\t\tpublic TypeDescriptor getMapValueType(int nestingLevel) {\n\t\t\treturn new TypeDescriptor(\n\t\t\t\t\tthis.typeDescriptor.getResolvableType().getNested(nestingLevel).asMap().getGeneric(1),\n\t\t\t\t\tnull, this.typeDescriptor.getAnnotations());\n\t\t}\n\n\t\t@Override\n\t\tpublic TypeDescriptor getCollectionType(int nestingLevel) {\n\t\t\treturn new TypeDescriptor(\n\t\t\t\t\tthis.typeDescriptor.getResolvableType().getNested(nestingLevel).asCollection().getGeneric(),\n\t\t\t\t\tnull, this.typeDescriptor.getAnnotations());\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic TypeDescriptor nested(int level) {\n\t\t\treturn TypeDescriptor.nested(property(this.pd), level);\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Object getValue() throws Exception {\n\t\t\tMethod readMethod = this.pd.getReadMethod();\n\t\t\tReflectionUtils.makeAccessible(readMethod);\n\t\t\treturn readMethod.invoke(getWrappedInstance(), (Object[]) null);\n\t\t}\n\n\t\t@Override\n\t\tpublic void setValue(@Nullable Object value) throws Exception {\n\t\t\tMethod writeMethod = (this.pd instanceof GenericTypeAwarePropertyDescriptor typeAwarePd ?\n\t\t\t\t\ttypeAwarePd.getWriteMethodForActualAccess() : this.pd.getWriteMethod());\n\t\t\tReflectionUtils.makeAccessible(writeMethod);\n\t\t\twriteMethod.invoke(getWrappedInstance(), value);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.beans.BeanWrapperImpl#convertForProperty(value,propertyName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given value for the specified property to the latter's type.\n\t * <p>This method is only intended for optimizations in a BeanFactory.\n\t * Use the {@code convertIfNecessary} methods for programmatic conversion.\n\t * @param value the value to convert\n\t * @param propertyName the target property\n\t * (note that nested or indexed properties are not supported here)\n\t * @return the new value, possibly the result of type conversion\n\t * @throws TypeMismatchException if type conversion failed\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "propertyName"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "Object",
    "signature": "public Object convertForProperty(@Nullable Object value, String propertyName)",
    "source_code": "\tpublic Object convertForProperty(@Nullable Object value, String propertyName) throws TypeMismatchException {\n\t\tCachedIntrospectionResults cachedIntrospectionResults = getCachedIntrospectionResults();\n\t\tPropertyDescriptor pd = cachedIntrospectionResults.getPropertyDescriptor(propertyName);\n\t\tif (pd == null) {\n\t\t\tthrow new InvalidPropertyException(getRootClass(), getNestedPath() + propertyName,\n\t\t\t\t\t\"No property '\" + propertyName + \"' found\");\n\t\t}\n\t\tTypeDescriptor td = cachedIntrospectionResults.getTypeDescriptor(pd);\n\t\tif (td == null) {\n\t\t\ttd = cachedIntrospectionResults.addTypeDescriptor(pd, new TypeDescriptor(property(pd)));\n\t\t}\n\t\treturn convertForProperty(propertyName, null, value, td);\n\t}"
  },
  "org.springframework.beans.BeanWrapperImpl#createNotWritablePropertyException(propertyName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "propertyName"
    ],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "NotWritablePropertyException",
    "signature": "protected NotWritablePropertyException createNotWritablePropertyException(String propertyName)",
    "source_code": "\tprotected NotWritablePropertyException createNotWritablePropertyException(String propertyName) {\n\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n\t\tthrow new NotWritablePropertyException(getRootClass(), getNestedPath() + propertyName,\n\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t}"
  },
  "org.springframework.beans.BeanWrapperImpl#getCollectionType(nestingLevel)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nestingLevel"
    ],
    "position": {
      "column": 1,
      "line": 265
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getCollectionType(int nestingLevel)",
    "source_code": "\t\tpublic TypeDescriptor getCollectionType(int nestingLevel) {\n\t\t\treturn new TypeDescriptor(\n\t\t\t\t\tthis.typeDescriptor.getResolvableType().getNested(nestingLevel).asCollection().getGeneric(),\n\t\t\t\t\tnull, this.typeDescriptor.getAnnotations());\n\t\t}"
  },
  "org.springframework.beans.BeanWrapperImpl#getLocalPropertyHandler(propertyName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "propertyName"
    ],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "BeanPropertyHandler",
    "signature": "protected BeanPropertyHandler getLocalPropertyHandler(String propertyName)",
    "source_code": "\tprotected BeanPropertyHandler getLocalPropertyHandler(String propertyName) {\n\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(propertyName);\n\t\treturn (pd != null ? new BeanPropertyHandler(pd) : null);\n\t}"
  },
  "org.springframework.beans.BeanWrapperImpl#getMapValueType(nestingLevel)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nestingLevel"
    ],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getMapValueType(int nestingLevel)",
    "source_code": "\t\tpublic TypeDescriptor getMapValueType(int nestingLevel) {\n\t\t\treturn new TypeDescriptor(\n\t\t\t\t\tthis.typeDescriptor.getResolvableType().getNested(nestingLevel).asMap().getGeneric(1),\n\t\t\t\t\tnull, this.typeDescriptor.getAnnotations());\n\t\t}"
  },
  "org.springframework.beans.BeanWrapperImpl#getPropertyDescriptor(propertyName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "PropertyDescriptor",
    "signature": "public PropertyDescriptor getPropertyDescriptor(String propertyName)",
    "source_code": "\tpublic PropertyDescriptor getPropertyDescriptor(String propertyName) throws InvalidPropertyException {\n\t\tBeanWrapperImpl nestedBw = (BeanWrapperImpl) getPropertyAccessorForPropertyPath(propertyName);\n\t\tString finalPath = getFinalPath(nestedBw, propertyName);\n\t\tPropertyDescriptor pd = nestedBw.getCachedIntrospectionResults().getPropertyDescriptor(finalPath);\n\t\tif (pd == null) {\n\t\t\tthrow new InvalidPropertyException(getRootClass(), getNestedPath() + propertyName,\n\t\t\t\t\t\"No property '\" + propertyName + \"' found\");\n\t\t}\n\t\treturn pd;\n\t}"
  },
  "org.springframework.beans.BeanWrapperImpl#getPropertyDescriptors()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "PropertyDescriptor[]",
    "signature": "public PropertyDescriptor[] getPropertyDescriptors()",
    "source_code": "\tpublic PropertyDescriptor[] getPropertyDescriptors() {\n\t\treturn getCachedIntrospectionResults().getPropertyDescriptors();\n\t}"
  },
  "org.springframework.beans.BeanWrapperImpl#getResolvableType()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 253
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType getResolvableType()",
    "source_code": "\t\tpublic ResolvableType getResolvableType() {\n\t\t\treturn this.typeDescriptor.getResolvableType();\n\t\t}"
  },
  "org.springframework.beans.BeanWrapperImpl#getValue()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 279
    },
    "return": "Object",
    "signature": "public Object getValue()",
    "source_code": "\t\tpublic Object getValue() throws Exception {\n\t\t\tMethod readMethod = this.pd.getReadMethod();\n\t\t\tReflectionUtils.makeAccessible(readMethod);\n\t\t\treturn readMethod.invoke(getWrappedInstance(), (Object[]) null);\n\t\t}"
  },
  "org.springframework.beans.BeanWrapperImpl#nested(level)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "level"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor nested(int level)",
    "source_code": "\t\tpublic TypeDescriptor nested(int level) {\n\t\t\treturn TypeDescriptor.nested(property(this.pd), level);\n\t\t}"
  },
  "org.springframework.beans.BeanWrapperImpl#newNestedPropertyAccessor(object,nestedPath)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "nestedPath"
    ],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "BeanWrapperImpl",
    "signature": "protected BeanWrapperImpl newNestedPropertyAccessor(Object object, String nestedPath)",
    "source_code": "\tprotected BeanWrapperImpl newNestedPropertyAccessor(Object object, String nestedPath) {\n\t\treturn new BeanWrapperImpl(object, nestedPath, this);\n\t}"
  },
  "org.springframework.beans.BeanWrapperImpl#setBeanInstance(object)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a bean instance to hold, without any unwrapping of {@link java.util.Optional}.\n\t * @param object the actual target object\n\t * @since 4.3\n\t * @see #setWrappedInstance(Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "void",
    "signature": "public void setBeanInstance(Object object)",
    "source_code": "\tpublic void setBeanInstance(Object object) {\n\t\tthis.wrappedObject = object;\n\t\tthis.rootObject = object;\n\t\tthis.typeConverterDelegate = new TypeConverterDelegate(this, this.wrappedObject);\n\t\tsetIntrospectionClass(object.getClass());\n\t}"
  },
  "org.springframework.beans.BeanWrapperImpl#setIntrospectionClass(clazz)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the class to introspect.\n\t * Needs to be called when the target object changes.\n\t * @param clazz the class to introspect\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "void",
    "signature": "protected void setIntrospectionClass(Class<?> clazz)",
    "source_code": "\tprotected void setIntrospectionClass(Class<?> clazz) {\n\t\tif (this.cachedIntrospectionResults != null && this.cachedIntrospectionResults.getBeanClass() != clazz) {\n\t\t\tthis.cachedIntrospectionResults = null;\n\t\t}\n\t}"
  },
  "org.springframework.beans.BeanWrapperImpl#setValue(value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "void",
    "signature": "public void setValue(@Nullable Object value)",
    "source_code": "\t\tpublic void setValue(@Nullable Object value) throws Exception {\n\t\t\tMethod writeMethod = (this.pd instanceof GenericTypeAwarePropertyDescriptor typeAwarePd ?\n\t\t\t\t\ttypeAwarePd.getWriteMethodForActualAccess() : this.pd.getWriteMethod());\n\t\t\tReflectionUtils.makeAccessible(writeMethod);\n\t\t\twriteMethod.invoke(getWrappedInstance(), value);\n\t\t}"
  },
  "org.springframework.beans.BeanWrapperImpl#setWrappedInstance(object,nestedPath,rootObject)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "nestedPath",
      "rootObject"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "void",
    "signature": "public void setWrappedInstance(Object object, @Nullable String nestedPath, @Nullable Object rootObject)",
    "source_code": "\tpublic void setWrappedInstance(Object object, @Nullable String nestedPath, @Nullable Object rootObject) {\n\t\tsuper.setWrappedInstance(object, nestedPath, rootObject);\n\t\tsetIntrospectionClass(getWrappedClass());\n\t}"
  },
  "org.springframework.beans.BeanWrapperImpl#toTypeDescriptor()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor toTypeDescriptor()",
    "source_code": "\t\tpublic TypeDescriptor toTypeDescriptor() {\n\t\t\treturn this.typeDescriptor;\n\t\t}"
  },
  "org.springframework.beans.factory.config.TypedStringValue#compareTo(o)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "int",
    "signature": "public int compareTo(@Nullable TypedStringValue o)",
    "source_code": "\tpublic int compareTo(@Nullable TypedStringValue o) {\n\t\treturn Comparator.comparing(TypedStringValue::getValue).compare(this, o);\n\t}"
  },
  "org.springframework.core.convert.TypeDescriptor#nested(nestingLevel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a type descriptor for a nested type declared within this descriptor.\n\t * @param nestingLevel the nesting level of the collection/array element or\n\t * map key/value declaration within the property\n\t * @return the nested type descriptor at the specified nesting level, or\n\t * {@code null} if it could not be obtained\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nestingLevel"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor nested(int nestingLevel)",
    "source_code": "\tpublic TypeDescriptor nested(int nestingLevel) {\n\t\tResolvableType nested = this.resolvableType;\n\t\tfor (int i = 0; i < nestingLevel; i++) {\n\t\t\tif (Object.class == nested.getType()) {\n\t\t\t\t// Could be a collection type but we don't know about its element type,\n\t\t\t\t// so let's just assume there is an element type of type Object...\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnested = nested.getNested(2);\n\t\t\t}\n\t\t}\n\t\tif (nested == ResolvableType.NONE) {\n\t\t\treturn null;\n\t\t}\n\t\treturn getRelatedIfResolvable(nested);\n\t}"
  },
  "org.springframework.http.ProblemDetail#setProperties(Map<String,properties)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Setter for the {@link #getProperties() properties map}.\n\t * <p>By default, this is not set.\n\t * <p>When Jackson JSON is present on the classpath, any properties set here\n\t * are rendered as top level key-value pairs in the output JSON. Otherwise,\n\t * they are rendered as a {@code \"properties\"} sub-map.\n\t * @param properties the properties map\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "properties"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "void",
    "signature": "public void setProperties(@Nullable Map<String, Object> properties)",
    "source_code": "\tpublic void setProperties(@Nullable Map<String, Object> properties) {\n\t\tthis.properties = properties;\n\t}"
  },
  "org.springframework.http.client.<unknown>#repeatable()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "boolean",
    "signature": "public boolean repeatable()",
    "source_code": "\t\t\t\tpublic boolean repeatable() {\n\t\t\t\t\treturn true;\n\t\t\t\t}"
  },
  "org.springframework.http.client.<unknown>#writeTo(outputStream)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outputStream"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "void",
    "signature": "public void writeTo(OutputStream outputStream)",
    "source_code": "\t\t\t\tpublic void writeTo(OutputStream outputStream) throws IOException {\n\t\t\t\t\tStreamUtils.copy(bufferedOutput, outputStream);\n\t\t\t\t}"
  },
  "org.springframework.test.context.aot.<unknown>#registerHints(runtimeHints,mergedConfig,classLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runtimeHints",
      "mergedConfig",
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "void",
    "signature": "public void registerHints(RuntimeHints runtimeHints, MergedContextConfiguration mergedConfig, ClassLoader classLoader)",
    "source_code": "\tpublic void registerHints(RuntimeHints runtimeHints, MergedContextConfiguration mergedConfig, ClassLoader classLoader) {\n\t\t// @ContextConfiguration(loader = ...)\n\t\tContextLoader contextLoader = mergedConfig.getContextLoader();\n\t\tif (contextLoader != null) {\n\t\t\tregisterDeclaredConstructors(contextLoader.getClass(), runtimeHints);\n\t\t}\n\n\t\t// @ContextConfiguration(initializers = ...)\n\t\tmergedConfig.getContextInitializerClasses()\n\t\t\t\t.forEach(clazz -> registerDeclaredConstructors(clazz, runtimeHints));\n\n\t\t// @ContextConfiguration(locations = ...)\n\t\tregisterClasspathResources(\"@ContextConfiguration\", mergedConfig.getLocations(), runtimeHints, classLoader);\n\n\t\tfor (PropertySourceDescriptor descriptor : mergedConfig.getPropertySourceDescriptors()) {\n\t\t\t// @TestPropertySource(locations = ...)\n\t\t\tregisterClasspathResources(\"@TestPropertySource\", descriptor.locations(), runtimeHints, classLoader);\n\n\t\t\t// @TestPropertySource(factory = ...)\n\t\t\tClass<?> factoryClass = descriptor.propertySourceFactory();\n\t\t\tif (factoryClass != null) {\n\t\t\t\tregisterDeclaredConstructors(factoryClass, runtimeHints);\n\t\t\t}\n\t\t}\n\n\t\t// @WebAppConfiguration(value = ...)\n\t\tif (webMergedContextConfigurationClass.isInstance(mergedConfig)) {\n\t\t\tString resourceBasePath = null;\n\t\t\ttry {\n\t\t\t\tresourceBasePath = (String) getResourceBasePathMethod.invoke(mergedConfig);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Failed to invoke WebMergedContextConfiguration#getResourceBasePath()\", ex);\n\t\t\t}\n\t\t\tregisterClasspathResourceDirectoryStructure(resourceBasePath, runtimeHints);\n\t\t}\n\t}"
  },
  "org.springframework.test.web.servlet.setup.AbstractMockMvcBuilder#addFilter(filter,Map<String,initParams,dispatcherTypes,urlPatterns)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "filter",
      "Map<String",
      "initParams",
      "dispatcherTypes",
      "urlPatterns"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "T",
    "signature": "public T addFilter(Filter filter, Map<String, String> initParams,\n\t\t\tEnumSet<DispatcherType> dispatcherTypes, String... urlPatterns)",
    "source_code": "\tpublic <T extends B> T addFilter("
  },
  "org.springframework.test.web.servlet.setup.AbstractMockMvcBuilder#addFilter(filter,filterName,Map<String,initParams,dispatcherTypes,urlPatterns)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "filter",
      "filterName",
      "Map<String",
      "initParams",
      "dispatcherTypes",
      "urlPatterns"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "T",
    "signature": "public T addFilter(Filter filter, @Nullable String filterName, Map<String, String> initParams,\n\t\t\tEnumSet<DispatcherType> dispatcherTypes, String... urlPatterns)",
    "source_code": "\tpublic <T extends B> T addFilter("
  },
  "org.springframework.util.ConcurrentReferenceHashMap#restructureIfNecessary(allowResize)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Restructure the underlying data structure when it becomes necessary. This\n\t\t * method can increase the size of the references table as well as purge any\n\t\t * references that have been garbage collected.\n\t\t * @param allowResize if resizing is permitted\n\t\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "allowResize"
    ],
    "position": {
      "column": 1,
      "line": 571
    },
    "return": "void",
    "signature": "protected void restructureIfNecessary(boolean allowResize)",
    "source_code": "\t\tprotected final void restructureIfNecessary(boolean allowResize) {\n\t\t\tint currCount = this.count.get();\n\t\t\tboolean needsResize = allowResize && (currCount > 0 && currCount >= this.resizeThreshold);\n\t\t\tReference<K, V> ref = this.referenceManager.pollForPurge();\n\t\t\tif (ref != null || (needsResize)) {\n\t\t\t\trestructure(allowResize, ref);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.reactive.resource.ResourceWebHandler#getEtagGenerator()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the HTTP ETag generator function to be used when serving resources.\n\t * @return the HTTP ETag generator function\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 301
    },
    "return": "String>",
    "signature": "public String> getEtagGenerator()",
    "source_code": "\tpublic Function<Resource, String> getEtagGenerator() {\n\t\treturn this.etagGenerator;\n\t}"
  },
  "org.springframework.web.reactive.resource.ResourceWebHandler#setEtagGenerator(Function<Resource,etagGenerator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a generator function that will be used to create the ETag information,\n\t * given a {@link Resource} that is about to be written to the response.\n\t * <p>This function should return a String that will be used as an argument in\n\t * {@link ServerWebExchange#checkNotModified(String)}, or {@code null} if no value\n\t * can be generated for the given resource.\n\t * @param etagGenerator the HTTP ETag generator function to use.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<Resource",
      "etagGenerator"
    ],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "void",
    "signature": "public void setEtagGenerator(@Nullable Function<Resource, String> etagGenerator)",
    "source_code": "\tpublic void setEtagGenerator(@Nullable Function<Resource, String> etagGenerator) {\n\t\tthis.etagGenerator = etagGenerator;\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#headers()": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders headers()",
    "source_code": "\tpublic HttpHeaders headers() {\n\t\treturn delegate(ServerResponse::headers);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler#handleMaxUploadSizeExceededException(ex,headers,status,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of any {@link MaxUploadSizeExceededException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 455
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleMaxUploadSizeExceededException(MaxUploadSizeExceededException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleMaxUploadSizeExceededException("
  },
  "org.springframework.web.servlet.resource.ResourceHttpRequestHandler#getEtagGenerator()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the HTTP ETag generator function to be used when serving resources.\n\t * @return the HTTP ETag generator function\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 409
    },
    "return": "String>",
    "signature": "public String> getEtagGenerator()",
    "source_code": "\tpublic Function<Resource, String> getEtagGenerator() {\n\t\treturn this.etagGenerator;\n\t}"
  },
  "org.springframework.web.servlet.resource.ResourceHttpRequestHandler#setEtagGenerator(Function<Resource,etagGenerator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a generator function that will be used to create the ETag information,\n\t * given a {@link Resource} that is about to be written to the response.\n\t * <p>This function should return a String that will be used as an argument in\n\t * {@link ServletWebRequest#checkNotModified(String)}, or {@code null} if no value\n\t * can be generated for the given resource.\n\t * @param etagGenerator the HTTP ETag generator function to use.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<Resource",
      "etagGenerator"
    ],
    "position": {
      "column": 1,
      "line": 399
    },
    "return": "void",
    "signature": "public void setEtagGenerator(@Nullable Function<Resource, String> etagGenerator)",
    "source_code": "\tpublic void setEtagGenerator(@Nullable Function<Resource, String> etagGenerator) {\n\t\tthis.etagGenerator = etagGenerator;\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.disconnectedClientLogger": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Separate logger to use on network IO failure after a client has gone away.\n\t * @see #DISCONNECTED_CLIENT_LOG_CATEGORY\n\t */",
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "signature": "protected Log disconnectedClientLogger",
    "source_code": "\tprotected static final Log disconnectedClientLogger = LogFactory.getLog(DISCONNECTED_CLIENT_LOG_CATEGORY);",
    "type": "Log"
  },
  "org.springframework.web.util.<unknown>#copyToUriComponentsBuilder(builder)": {
    "change": "modifier_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "builder"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "void",
    "signature": "protected void copyToUriComponentsBuilder(UriComponentsBuilder builder)",
    "source_code": "\tprotected void copyToUriComponentsBuilder(UriComponentsBuilder builder) {\n\t\tif (getScheme() != null) {\n\t\t\tbuilder.scheme(getScheme());\n\t\t}\n\t\tif (getSchemeSpecificPart() != null) {\n\t\t\tbuilder.schemeSpecificPart(getSchemeSpecificPart());\n\t\t}\n\t\tif (getFragment() != null) {\n\t\t\tbuilder.fragment(getFragment());\n\t\t}\n\t}"
  },
  "org.springframework.web.util.<unknown>#encode(charset)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "UriComponents",
    "signature": "public UriComponents encode(Charset charset)",
    "source_code": "\tpublic UriComponents encode(Charset charset) {\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.<unknown>#expandInternal(uriVariables)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "UriComponents",
    "signature": "protected UriComponents expandInternal(UriTemplateVariables uriVariables)",
    "source_code": "\tprotected UriComponents expandInternal(UriTemplateVariables uriVariables) {\n\t\tString expandedScheme = expandUriComponent(getScheme(), uriVariables);\n\t\tString expandedSsp = expandUriComponent(getSchemeSpecificPart(), uriVariables);\n\t\tString expandedFragment = expandUriComponent(getFragment(), uriVariables);\n\t\treturn new OpaqueUriComponents(expandedScheme, expandedSsp, expandedFragment);\n\t}"
  }
}