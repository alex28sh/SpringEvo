{
  "org.apache.commons.logging.<unknown>#createLocationAwareLog(name)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "Log",
    "signature": "public Log createLocationAwareLog(String name)",
    "source_code": "\t\tpublic static Log createLocationAwareLog(String name) {\n\t\t\tLogger logger = LoggerFactory.getLogger(name);\n\t\t\treturn (logger instanceof LocationAwareLogger ?\n\t\t\t\t\tnew Slf4jLocationAwareLog((LocationAwareLogger) logger) : new Slf4jLog<>(logger));\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#createLog(name)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "Log",
    "signature": "public Log createLog(String name)",
    "source_code": "\t\tpublic static Log createLog(String name) {\n\t\t\treturn new JavaUtilLog(name);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#debug(message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 580
    },
    "return": "void",
    "signature": "public void debug(Object message)",
    "source_code": "\t\tpublic void debug(Object message) {\n\t\t\tlog(java.util.logging.Level.FINE, message, null);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#debug(message,exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 585
    },
    "return": "void",
    "signature": "public void debug(Object message, Throwable exception)",
    "source_code": "\t\tpublic void debug(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.FINE, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#error(message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 550
    },
    "return": "void",
    "signature": "public void error(Object message)",
    "source_code": "\t\tpublic void error(Object message) {\n\t\t\tlog(java.util.logging.Level.SEVERE, message, null);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#error(message,exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 555
    },
    "return": "void",
    "signature": "public void error(Object message, Throwable exception)",
    "source_code": "\t\tpublic void error(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.SEVERE, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#fatal(message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 540
    },
    "return": "void",
    "signature": "public void fatal(Object message)",
    "source_code": "\t\tpublic void fatal(Object message) {\n\t\t\terror(message);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#fatal(message,exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 545
    },
    "return": "void",
    "signature": "public void fatal(Object message, Throwable exception)",
    "source_code": "\t\tpublic void fatal(Object message, Throwable exception) {\n\t\t\terror(message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#getSourceClassName()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 634
    },
    "return": "String",
    "signature": "public String getSourceClassName()",
    "source_code": "\t\tpublic String getSourceClassName() {\n\t\t\tif (!this.resolved) {\n\t\t\t\tresolve();\n\t\t\t}\n\t\t\treturn super.getSourceClassName();\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#getSourceMethodName()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 648
    },
    "return": "String",
    "signature": "public String getSourceMethodName()",
    "source_code": "\t\tpublic String getSourceMethodName() {\n\t\t\tif (!this.resolved) {\n\t\t\t\tresolve();\n\t\t\t}\n\t\t\treturn super.getSourceMethodName();\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#info(message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 570
    },
    "return": "void",
    "signature": "public void info(Object message)",
    "source_code": "\t\tpublic void info(Object message) {\n\t\t\tlog(java.util.logging.Level.INFO, message, null);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#info(message,exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 575
    },
    "return": "void",
    "signature": "public void info(Object message, Throwable exception)",
    "source_code": "\t\tpublic void info(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.INFO, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#isDebugEnabled()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 530
    },
    "return": "boolean",
    "signature": "public boolean isDebugEnabled()",
    "source_code": "\t\tpublic boolean isDebugEnabled() {\n\t\t\treturn this.logger.isLoggable(java.util.logging.Level.FINE);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#isErrorEnabled()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 515
    },
    "return": "boolean",
    "signature": "public boolean isErrorEnabled()",
    "source_code": "\t\tpublic boolean isErrorEnabled() {\n\t\t\treturn this.logger.isLoggable(java.util.logging.Level.SEVERE);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#isFatalEnabled()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 510
    },
    "return": "boolean",
    "signature": "public boolean isFatalEnabled()",
    "source_code": "\t\tpublic boolean isFatalEnabled() {\n\t\t\treturn isErrorEnabled();\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#isInfoEnabled()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 525
    },
    "return": "boolean",
    "signature": "public boolean isInfoEnabled()",
    "source_code": "\t\tpublic boolean isInfoEnabled() {\n\t\t\treturn this.logger.isLoggable(java.util.logging.Level.INFO);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#isTraceEnabled()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 535
    },
    "return": "boolean",
    "signature": "public boolean isTraceEnabled()",
    "source_code": "\t\tpublic boolean isTraceEnabled() {\n\t\t\treturn this.logger.isLoggable(java.util.logging.Level.FINEST);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#isWarnEnabled()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 520
    },
    "return": "boolean",
    "signature": "public boolean isWarnEnabled()",
    "source_code": "\t\tpublic boolean isWarnEnabled() {\n\t\t\treturn this.logger.isLoggable(java.util.logging.Level.WARNING);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#readResolve()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 616
    },
    "return": "Object",
    "signature": "protected Object readResolve()",
    "source_code": "\t\tprotected Object readResolve() {\n\t\t\treturn new JavaUtilLog(this.name);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#setSourceClassName(sourceClassName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceClassName"
    ],
    "position": {
      "column": 1,
      "line": 642
    },
    "return": "void",
    "signature": "public void setSourceClassName(String sourceClassName)",
    "source_code": "\t\tpublic void setSourceClassName(String sourceClassName) {\n\t\t\tsuper.setSourceClassName(sourceClassName);\n\t\t\tthis.resolved = true;\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#setSourceMethodName(sourceMethodName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceMethodName"
    ],
    "position": {
      "column": 1,
      "line": 656
    },
    "return": "void",
    "signature": "public void setSourceMethodName(String sourceMethodName)",
    "source_code": "\t\tpublic void setSourceMethodName(String sourceMethodName) {\n\t\t\tsuper.setSourceMethodName(sourceMethodName);\n\t\t\tthis.resolved = true;\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#trace(message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 590
    },
    "return": "void",
    "signature": "public void trace(Object message)",
    "source_code": "\t\tpublic void trace(Object message) {\n\t\t\tlog(java.util.logging.Level.FINEST, message, null);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#trace(message,exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 595
    },
    "return": "void",
    "signature": "public void trace(Object message, Throwable exception)",
    "source_code": "\t\tpublic void trace(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.FINEST, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#warn(message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 560
    },
    "return": "void",
    "signature": "public void warn(Object message)",
    "source_code": "\t\tpublic void warn(Object message) {\n\t\t\tlog(java.util.logging.Level.WARNING, message, null);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#warn(message,exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 565
    },
    "return": "void",
    "signature": "public void warn(Object message, Throwable exception)",
    "source_code": "\t\tpublic void warn(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.WARNING, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#writeReplace()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 681
    },
    "return": "Object",
    "signature": "protected Object writeReplace()",
    "source_code": "\t\tprotected Object writeReplace() {\n\t\t\tLogRecord serialized = new LogRecord(getLevel(), getMessage());\n\t\t\tserialized.setLoggerName(getLoggerName());\n\t\t\tserialized.setResourceBundle(getResourceBundle());\n\t\t\tserialized.setResourceBundleName(getResourceBundleName());\n\t\t\tserialized.setSourceClassName(getSourceClassName());\n\t\t\tserialized.setSourceMethodName(getSourceMethodName());\n\t\t\tserialized.setSequenceNumber(getSequenceNumber());\n\t\t\tserialized.setParameters(getParameters());\n\t\t\tserialized.setLongThreadID(getLongThreadID());\n\t\t\tserialized.setInstant(getInstant());\n\t\t\tserialized.setThrown(getThrown());\n\t\t\treturn serialized;\n\t\t}"
  },
  "org.apache.commons.logging.logger": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 278
    },
    "signature": "protected T logger",
    "source_code": "\t\tprotected final transient T logger;",
    "type": "T"
  },
  "org.apache.commons.logging.name": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 276
    },
    "signature": "protected String name",
    "source_code": "\t\tprotected final String name;",
    "type": "String"
  },
  "org.springframework.aot.nativex.INSTANCE": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "signature": "public ReflectionHintsWriter INSTANCE",
    "source_code": "\tpublic static final ReflectionHintsWriter INSTANCE = new ReflectionHintsWriter();",
    "type": "ReflectionHintsWriter"
  },
  "org.springframework.context.expression.BeanExpressionContextAccessor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * EL property accessor that knows how to traverse the beans and contextual objects\n * of a Spring {@link org.springframework.beans.factory.config.BeanExpressionContext}.\n *\n * @author Juergen Hoeller\n * @author Andy Clement\n * @since 3.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 35
    },
    "signature": "public class BeanExpressionContextAccessor",
    "source_code": "public class BeanExpressionContextAccessor implements PropertyAccessor {\n\n\t@Override\n\tpublic boolean canRead(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\treturn (target instanceof BeanExpressionContext bec && bec.containsObject(name));\n\t}\n\n\t@Override\n\tpublic TypedValue read(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\tAssert.state(target instanceof BeanExpressionContext, \"Target must be of type BeanExpressionContext\");\n\t\treturn new TypedValue(((BeanExpressionContext) target).getObject(name));\n\t}\n\n\t@Override\n\tpublic boolean canWrite(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object newValue)\n\t\t\tthrows AccessException {\n\n\t\tthrow new AccessException(\"Beans in a BeanFactory are read-only\");\n\t}\n\n\t@Override\n\tpublic Class<?>[] getSpecificTargetClasses() {\n\t\treturn new Class<?>[] {BeanExpressionContext.class};\n\t}\n\n}"
  },
  "org.springframework.context.expression.BeanExpressionContextAccessor#canRead(context,target,name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "return": "boolean",
    "signature": "public boolean canRead(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\tpublic boolean canRead(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\treturn (target instanceof BeanExpressionContext bec && bec.containsObject(name));\n\t}"
  },
  "org.springframework.context.expression.BeanExpressionContextAccessor#canWrite(context,target,name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "return": "boolean",
    "signature": "public boolean canWrite(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\tpublic boolean canWrite(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\treturn false;\n\t}"
  },
  "org.springframework.context.expression.BeanExpressionContextAccessor#read(context,target,name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "return": "TypedValue",
    "signature": "public TypedValue read(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\tpublic TypedValue read(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\tAssert.state(target instanceof BeanExpressionContext, \"Target must be of type BeanExpressionContext\");\n\t\treturn new TypedValue(((BeanExpressionContext) target).getObject(name));\n\t}"
  },
  "org.springframework.context.expression.BeanExpressionContextAccessor#write(context,target,name,newValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name",
      "newValue"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "return": "void",
    "signature": "public void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object newValue)",
    "source_code": "\tpublic void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object newValue)"
  },
  "org.springframework.context.expression.BeanFactoryAccessor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * EL property accessor that knows how to traverse the beans of a\n * Spring {@link org.springframework.beans.factory.BeanFactory}.\n *\n * @author Juergen Hoeller\n * @author Andy Clement\n * @since 3.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 35
    },
    "signature": "public class BeanFactoryAccessor",
    "source_code": "public class BeanFactoryAccessor implements PropertyAccessor {\n\n\t@Override\n\tpublic Class<?>[] getSpecificTargetClasses() {\n\t\treturn new Class<?>[] {BeanFactory.class};\n\t}\n\n\t@Override\n\tpublic boolean canRead(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\treturn (target instanceof BeanFactory beanFactory && beanFactory.containsBean(name));\n\t}\n\n\t@Override\n\tpublic TypedValue read(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\tAssert.state(target instanceof BeanFactory, \"Target must be of type BeanFactory\");\n\t\treturn new TypedValue(((BeanFactory) target).getBean(name));\n\t}\n\n\t@Override\n\tpublic boolean canWrite(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object newValue)\n\t\t\tthrows AccessException {\n\n\t\tthrow new AccessException(\"Beans in a BeanFactory are read-only\");\n\t}\n\n}"
  },
  "org.springframework.context.expression.BeanFactoryAccessor#canRead(context,target,name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "return": "boolean",
    "signature": "public boolean canRead(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\tpublic boolean canRead(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\treturn (target instanceof BeanFactory beanFactory && beanFactory.containsBean(name));\n\t}"
  },
  "org.springframework.context.expression.BeanFactoryAccessor#canWrite(context,target,name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "return": "boolean",
    "signature": "public boolean canWrite(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\tpublic boolean canWrite(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\treturn false;\n\t}"
  },
  "org.springframework.context.expression.BeanFactoryAccessor#read(context,target,name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "return": "TypedValue",
    "signature": "public TypedValue read(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\tpublic TypedValue read(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\tAssert.state(target instanceof BeanFactory, \"Target must be of type BeanFactory\");\n\t\treturn new TypedValue(((BeanFactory) target).getBean(name));\n\t}"
  },
  "org.springframework.context.expression.BeanFactoryAccessor#write(context,target,name,newValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name",
      "newValue"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "void",
    "signature": "public void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object newValue)",
    "source_code": "\tpublic void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object newValue)"
  },
  "org.springframework.context.support.<unknown>#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other ||\n\t\t\t\t(other instanceof ApplicationListenerDetector applicationListenerDectector &&\n\t\t\t\tthis.applicationContext == applicationListenerDectector.applicationContext));\n\t}"
  },
  "org.springframework.context.support.<unknown>#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn ObjectUtils.nullSafeHashCode(this.applicationContext);\n\t}"
  },
  "org.springframework.context.support.<unknown>#postProcessBeforeDestruction(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "public void postProcessBeforeDestruction(Object bean, String beanName)",
    "source_code": "\tpublic void postProcessBeforeDestruction(Object bean, String beanName) {\n\t\tif (bean instanceof ApplicationListener<?> applicationListener) {\n\t\t\ttry {\n\t\t\t\tApplicationEventMulticaster multicaster = this.applicationContext.getApplicationEventMulticaster();\n\t\t\t\tmulticaster.removeApplicationListener(applicationListener);\n\t\t\t\tmulticaster.removeApplicationListenerBean(beanName);\n\t\t\t}\n\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\t// ApplicationEventMulticaster not initialized yet - no need to remove a listener\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.context.support.<unknown>#postProcessMergedBeanDefinition(beanDefinition,beanType,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanDefinition",
      "beanType",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "void",
    "signature": "public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName)",
    "source_code": "\tpublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {\n\t\tif (ApplicationListener.class.isAssignableFrom(beanType)) {\n\t\t\tthis.singletonNames.put(beanName, beanDefinition.isSingleton());\n\t\t}\n\t}"
  },
  "org.springframework.context.support.<unknown>#requiresDestruction(bean)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "boolean",
    "signature": "public boolean requiresDestruction(Object bean)",
    "source_code": "\tpublic boolean requiresDestruction(Object bean) {\n\t\treturn (bean instanceof ApplicationListener);\n\t}"
  },
  "org.springframework.context.support.AbstractMessageSource": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract implementation of the {@link HierarchicalMessageSource} interface,\n * implementing common handling of message variants, making it easy\n * to implement a specific strategy for a concrete MessageSource.\n *\n * <p>Subclasses must implement the abstract {@link #resolveCode}\n * method. For efficient resolution of messages without arguments, the\n * {@link #resolveCodeWithoutArguments} method should be overridden\n * as well, resolving messages without a MessageFormat being involved.\n *\n * <p><b>Note:</b> By default, message texts are only parsed through\n * MessageFormat if arguments have been passed in for the message. In case\n * of no arguments, message texts will be returned as-is. As a consequence,\n * you should only use MessageFormat escaping for messages with actual\n * arguments, and keep all other messages unescaped. If you prefer to\n * escape all messages, set the \"alwaysUseMessageFormat\" flag to \"true\".\n *\n * <p>Supports not only MessageSourceResolvables as primary messages\n * but also resolution of message arguments that are in turn\n * MessageSourceResolvables themselves.\n *\n * <p>This class does not implement caching of messages per code, thus\n * subclasses can dynamically change messages over time. Subclasses are\n * encouraged to cache their messages in a modification-aware fashion,\n * allowing for hot deployment of updated messages.\n *\n * @author Juergen Hoeller\n * @author Rod Johnson\n * @see #resolveCode(String, java.util.Locale)\n * @see #resolveCodeWithoutArguments(String, java.util.Locale)\n * @see #setAlwaysUseMessageFormat\n * @see java.text.MessageFormat\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "signature": "public class AbstractMessageSource",
    "source_code": "public abstract class AbstractMessageSource extends MessageSourceSupport implements HierarchicalMessageSource {\n\n\t@Nullable\n\tprivate MessageSource parentMessageSource;\n\n\t@Nullable\n\tprivate Properties commonMessages;\n\n\tprivate boolean useCodeAsDefaultMessage = false;\n\n\n\t@Override\n\tpublic void setParentMessageSource(@Nullable MessageSource parent) {\n\t\tthis.parentMessageSource = parent;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic MessageSource getParentMessageSource() {\n\t\treturn this.parentMessageSource;\n\t}\n\n\t/**\n\t * Specify locale-independent common messages, with the message code as key\n\t * and the full message String (may contain argument placeholders) as value.\n\t * <p>May also link to an externally defined Properties object, e.g. defined\n\t * through a {@link org.springframework.beans.factory.config.PropertiesFactoryBean}.\n\t */\n\tpublic void setCommonMessages(@Nullable Properties commonMessages) {\n\t\tthis.commonMessages = commonMessages;\n\t}\n\n\t/**\n\t * Return a Properties object defining locale-independent common messages, if any.\n\t */\n\t@Nullable\n\tprotected Properties getCommonMessages() {\n\t\treturn this.commonMessages;\n\t}\n\n\t/**\n\t * Set whether to use the message code as default message instead of\n\t * throwing a NoSuchMessageException. Useful for development and debugging.\n\t * Default is \"false\".\n\t * <p>Note: In case of a MessageSourceResolvable with multiple codes\n\t * (like a FieldError) and a MessageSource that has a parent MessageSource,\n\t * do <i>not</i> activate \"useCodeAsDefaultMessage\" in the <i>parent</i>:\n\t * Else, you'll get the first code returned as message by the parent,\n\t * without attempts to check further codes.\n\t * <p>To be able to work with \"useCodeAsDefaultMessage\" turned on in the parent,\n\t * AbstractMessageSource and AbstractApplicationContext contain special checks\n\t * to delegate to the internal {@link #getMessageInternal} method if available.\n\t * In general, it is recommended to just use \"useCodeAsDefaultMessage\" during\n\t * development and not rely on it in production in the first place, though.\n\t * @see #getMessage(String, Object[], Locale)\n\t * @see org.springframework.validation.FieldError\n\t */\n\tpublic void setUseCodeAsDefaultMessage(boolean useCodeAsDefaultMessage) {\n\t\tthis.useCodeAsDefaultMessage = useCodeAsDefaultMessage;\n\t}\n\n\t/**\n\t * Return whether to use the message code as default message instead of\n\t * throwing a NoSuchMessageException. Useful for development and debugging.\n\t * Default is \"false\".\n\t * <p>Alternatively, consider overriding the {@link #getDefaultMessage}\n\t * method to return a custom fallback message for an unresolvable code.\n\t * @see #getDefaultMessage(String)\n\t */\n\tprotected boolean isUseCodeAsDefaultMessage() {\n\t\treturn this.useCodeAsDefaultMessage;\n\t}\n\n\n\t@Override\n\tpublic final String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale) {\n\t\tString msg = getMessageInternal(code, args, locale);\n\t\tif (msg != null) {\n\t\t\treturn msg;\n\t\t}\n\t\tif (defaultMessage == null) {\n\t\t\treturn getDefaultMessage(code);\n\t\t}\n\t\treturn renderDefaultMessage(defaultMessage, args, locale);\n\t}\n\n\t@Override\n\tpublic final String getMessage(String code, @Nullable Object[] args, Locale locale) throws NoSuchMessageException {\n\t\tString msg = getMessageInternal(code, args, locale);\n\t\tif (msg != null) {\n\t\t\treturn msg;\n\t\t}\n\t\tString fallback = getDefaultMessage(code);\n\t\tif (fallback != null) {\n\t\t\treturn fallback;\n\t\t}\n\t\tthrow new NoSuchMessageException(code, locale);\n\t}\n\n\t@Override\n\tpublic final String getMessage(MessageSourceResolvable resolvable, Locale locale) throws NoSuchMessageException {\n\t\tString[] codes = resolvable.getCodes();\n\t\tif (codes != null) {\n\t\t\tfor (String code : codes) {\n\t\t\t\tString message = getMessageInternal(code, resolvable.getArguments(), locale);\n\t\t\t\tif (message != null) {\n\t\t\t\t\treturn message;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tString defaultMessage = getDefaultMessage(resolvable, locale);\n\t\tif (defaultMessage != null) {\n\t\t\treturn defaultMessage;\n\t\t}\n\t\tthrow new NoSuchMessageException(!ObjectUtils.isEmpty(codes) ? codes[codes.length - 1] : \"\", locale);\n\t}\n\n\n\t/**\n\t * Resolve the given code and arguments as message in the given Locale,\n\t * returning {@code null} if not found. Does <i>not</i> fall back to\n\t * the code as default message. Invoked by {@code getMessage} methods.\n\t * @param code the code to lookup up, such as 'calculator.noRateSet'\n\t * @param args array of arguments that will be filled in for params\n\t * within the message\n\t * @param locale the locale in which to do the lookup\n\t * @return the resolved message, or {@code null} if not found\n\t * @see #getMessage(String, Object[], String, Locale)\n\t * @see #getMessage(String, Object[], Locale)\n\t * @see #getMessage(MessageSourceResolvable, Locale)\n\t * @see #setUseCodeAsDefaultMessage\n\t */\n\t@Nullable\n\tprotected String getMessageInternal(@Nullable String code, @Nullable Object[] args, @Nullable Locale locale) {\n\t\tif (code == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (locale == null) {\n\t\t\tlocale = Locale.getDefault();\n\t\t}\n\t\tObject[] argsToUse = args;\n\n\t\tif (!isAlwaysUseMessageFormat() && ObjectUtils.isEmpty(args)) {\n\t\t\t// Optimized resolution: no arguments to apply,\n\t\t\t// therefore no MessageFormat needs to be involved.\n\t\t\t// Note that the default implementation still uses MessageFormat;\n\t\t\t// this can be overridden in specific subclasses.\n\t\t\tString message = resolveCodeWithoutArguments(code, locale);\n\t\t\tif (message != null) {\n\t\t\t\treturn message;\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\t// Resolve arguments eagerly, for the case where the message\n\t\t\t// is defined in a parent MessageSource but resolvable arguments\n\t\t\t// are defined in the child MessageSource.\n\t\t\targsToUse = resolveArguments(args, locale);\n\n\t\t\tMessageFormat messageFormat = resolveCode(code, locale);\n\t\t\tif (messageFormat != null) {\n\t\t\t\tsynchronized (messageFormat) {\n\t\t\t\t\treturn messageFormat.format(argsToUse);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check locale-independent common messages for the given message code.\n\t\tProperties commonMessages = getCommonMessages();\n\t\tif (commonMessages != null) {\n\t\t\tString commonMessage = commonMessages.getProperty(code);\n\t\t\tif (commonMessage != null) {\n\t\t\t\treturn formatMessage(commonMessage, args, locale);\n\t\t\t}\n\t\t}\n\n\t\t// Not found -> check parent, if any.\n\t\treturn getMessageFromParent(code, argsToUse, locale);\n\t}\n\n\t/**\n\t * Try to retrieve the given message from the parent {@code MessageSource}, if any.\n\t * @param code the code to lookup up, such as 'calculator.noRateSet'\n\t * @param args array of arguments that will be filled in for params\n\t * within the message\n\t * @param locale the locale in which to do the lookup\n\t * @return the resolved message, or {@code null} if not found\n\t * @see #getParentMessageSource()\n\t */\n\t@Nullable\n\tprotected String getMessageFromParent(String code, @Nullable Object[] args, Locale locale) {\n\t\tMessageSource parent = getParentMessageSource();\n\t\tif (parent != null) {\n\t\t\tif (parent instanceof AbstractMessageSource abstractMessageSource) {\n\t\t\t\t// Call internal method to avoid getting the default code back\n\t\t\t\t// in case of \"useCodeAsDefaultMessage\" being activated.\n\t\t\t\treturn abstractMessageSource.getMessageInternal(code, args, locale);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Check parent MessageSource, returning null if not found there.\n\t\t\t\t// Covers custom MessageSource impls and DelegatingMessageSource.\n\t\t\t\treturn parent.getMessage(code, args, null, locale);\n\t\t\t}\n\t\t}\n\t\t// Not found in parent either.\n\t\treturn null;\n\t}\n\n\t/**\n\t * Get a default message for the given {@code MessageSourceResolvable}.\n\t * <p>This implementation fully renders the default message if available,\n\t * or just returns the plain default message {@code String} if the primary\n\t * message code is being used as a default message.\n\t * @param resolvable the value object to resolve a default message for\n\t * @param locale the current locale\n\t * @return the default message, or {@code null} if none\n\t * @since 4.3.6\n\t * @see #renderDefaultMessage(String, Object[], Locale)\n\t * @see #getDefaultMessage(String)\n\t */\n\t@Nullable\n\tprotected String getDefaultMessage(MessageSourceResolvable resolvable, Locale locale) {\n\t\tString defaultMessage = resolvable.getDefaultMessage();\n\t\tString[] codes = resolvable.getCodes();\n\t\tif (defaultMessage != null) {\n\t\t\tif (resolvable instanceof DefaultMessageSourceResolvable defaultMessageSourceResolvable &&\n\t\t\t\t\t!defaultMessageSourceResolvable.shouldRenderDefaultMessage()) {\n\t\t\t\t// Given default message does not contain any argument placeholders\n\t\t\t\t// (and isn't escaped for alwaysUseMessageFormat either) -> return as-is.\n\t\t\t\treturn defaultMessage;\n\t\t\t}\n\t\t\tif (!ObjectUtils.isEmpty(codes) && defaultMessage.equals(codes[0])) {\n\t\t\t\t// Never format a code-as-default-message, even with alwaysUseMessageFormat=true\n\t\t\t\treturn defaultMessage;\n\t\t\t}\n\t\t\treturn renderDefaultMessage(defaultMessage, resolvable.getArguments(), locale);\n\t\t}\n\t\treturn (!ObjectUtils.isEmpty(codes) ? getDefaultMessage(codes[0]) : null);\n\t}\n\n\t/**\n\t * Return a fallback default message for the given code, if any.\n\t * <p>Default is to return the code itself if \"useCodeAsDefaultMessage\" is activated,\n\t * or return no fallback else. In case of no fallback, the caller will usually\n\t * receive a {@code NoSuchMessageException} from {@code getMessage}.\n\t * @param code the message code that we couldn't resolve\n\t * and that we didn't receive an explicit default message for\n\t * @return the default message to use, or {@code null} if none\n\t * @see #setUseCodeAsDefaultMessage\n\t */\n\t@Nullable\n\tprotected String getDefaultMessage(String code) {\n\t\tif (isUseCodeAsDefaultMessage()) {\n\t\t\treturn code;\n\t\t}\n\t\treturn null;\n\t}\n\n\n\t/**\n\t * Searches through the given array of objects, finds any MessageSourceResolvable\n\t * objects and resolves them.\n\t * <p>Allows for messages to have MessageSourceResolvables as arguments.\n\t * @param args array of arguments for a message\n\t * @param locale the locale to resolve through\n\t * @return an array of arguments with any MessageSourceResolvables resolved\n\t */\n\t@Override\n\tprotected Object[] resolveArguments(@Nullable Object[] args, Locale locale) {\n\t\tif (ObjectUtils.isEmpty(args)) {\n\t\t\treturn super.resolveArguments(args, locale);\n\t\t}\n\t\tList<Object> resolvedArgs = new ArrayList<>(args.length);\n\t\tfor (Object arg : args) {\n\t\t\tif (arg instanceof MessageSourceResolvable messageSourceResolvable) {\n\t\t\t\tresolvedArgs.add(getMessage(messageSourceResolvable, locale));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresolvedArgs.add(arg);\n\t\t\t}\n\t\t}\n\t\treturn resolvedArgs.toArray();\n\t}\n\n\t/**\n\t * Subclasses can override this method to resolve a message without arguments\n\t * in an optimized fashion, i.e. to resolve without involving a MessageFormat.\n\t * <p>The default implementation <i>does</i> use MessageFormat, through\n\t * delegating to the {@link #resolveCode} method. Subclasses are encouraged\n\t * to replace this with optimized resolution.\n\t * <p>Unfortunately, {@code java.text.MessageFormat} is not implemented\n\t * in an efficient fashion. In particular, it does not detect that a message\n\t * pattern doesn't contain argument placeholders in the first place. Therefore,\n\t * it is advisable to circumvent MessageFormat for messages without arguments.\n\t * @param code the code of the message to resolve\n\t * @param locale the locale to resolve the code for\n\t * (subclasses are encouraged to support internationalization)\n\t * @return the message String, or {@code null} if not found\n\t * @see #resolveCode\n\t * @see java.text.MessageFormat\n\t */\n\t@Nullable\n\tprotected String resolveCodeWithoutArguments(String code, Locale locale) {\n\t\tMessageFormat messageFormat = resolveCode(code, locale);\n\t\tif (messageFormat != null) {\n\t\t\tsynchronized (messageFormat) {\n\t\t\t\treturn messageFormat.format(new Object[0]);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Subclasses must implement this method to resolve a message.\n\t * <p>Returns a MessageFormat instance rather than a message String,\n\t * to allow for appropriate caching of MessageFormats in subclasses.\n\t * <p><b>Subclasses are encouraged to provide optimized resolution\n\t * for messages without arguments, not involving MessageFormat.</b>\n\t * See the {@link #resolveCodeWithoutArguments} javadoc for details.\n\t * @param code the code of the message to resolve\n\t * @param locale the locale to resolve the code for\n\t * (subclasses are encouraged to support internationalization)\n\t * @return the MessageFormat for the message, or {@code null} if not found\n\t * @see #resolveCodeWithoutArguments(String, java.util.Locale)\n\t */\n\t@Nullable\n\tprotected abstract MessageFormat resolveCode(String code, Locale locale);\n\n}"
  },
  "org.springframework.context.support.AbstractMessageSource#getCommonMessages()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a Properties object defining locale-independent common messages, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "Properties",
    "signature": "protected Properties getCommonMessages()",
    "source_code": "\tprotected Properties getCommonMessages() {\n\t\treturn this.commonMessages;\n\t}"
  },
  "org.springframework.context.support.AbstractMessageSource#getDefaultMessage(code)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a fallback default message for the given code, if any.\n\t * <p>Default is to return the code itself if \"useCodeAsDefaultMessage\" is activated,\n\t * or return no fallback else. In case of no fallback, the caller will usually\n\t * receive a {@code NoSuchMessageException} from {@code getMessage}.\n\t * @param code the message code that we couldn't resolve\n\t * and that we didn't receive an explicit default message for\n\t * @return the default message to use, or {@code null} if none\n\t * @see #setUseCodeAsDefaultMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "code"
    ],
    "position": {
      "column": 1,
      "line": 316
    },
    "return": "String",
    "signature": "protected String getDefaultMessage(String code)",
    "source_code": "\tprotected String getDefaultMessage(String code) {\n\t\tif (isUseCodeAsDefaultMessage()) {\n\t\t\treturn code;\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.context.support.AbstractMessageSource#getDefaultMessage(resolvable,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get a default message for the given {@code MessageSourceResolvable}.\n\t * <p>This implementation fully renders the default message if available,\n\t * or just returns the plain default message {@code String} if the primary\n\t * message code is being used as a default message.\n\t * @param resolvable the value object to resolve a default message for\n\t * @param locale the current locale\n\t * @return the default message, or {@code null} if none\n\t * @since 4.3.6\n\t * @see #renderDefaultMessage(String, Object[], Locale)\n\t * @see #getDefaultMessage(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resolvable",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "String",
    "signature": "protected String getDefaultMessage(MessageSourceResolvable resolvable, Locale locale)",
    "source_code": "\tprotected String getDefaultMessage(MessageSourceResolvable resolvable, Locale locale) {\n\t\tString defaultMessage = resolvable.getDefaultMessage();\n\t\tString[] codes = resolvable.getCodes();\n\t\tif (defaultMessage != null) {\n\t\t\tif (resolvable instanceof DefaultMessageSourceResolvable defaultMessageSourceResolvable &&\n\t\t\t\t\t!defaultMessageSourceResolvable.shouldRenderDefaultMessage()) {\n\t\t\t\t// Given default message does not contain any argument placeholders\n\t\t\t\t// (and isn't escaped for alwaysUseMessageFormat either) -> return as-is.\n\t\t\t\treturn defaultMessage;\n\t\t\t}\n\t\t\tif (!ObjectUtils.isEmpty(codes) && defaultMessage.equals(codes[0])) {\n\t\t\t\t// Never format a code-as-default-message, even with alwaysUseMessageFormat=true\n\t\t\t\treturn defaultMessage;\n\t\t\t}\n\t\t\treturn renderDefaultMessage(defaultMessage, resolvable.getArguments(), locale);\n\t\t}\n\t\treturn (!ObjectUtils.isEmpty(codes) ? getDefaultMessage(codes[0]) : null);\n\t}"
  },
  "org.springframework.context.support.AbstractMessageSource#getMessage(code,args,defaultMessage,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "defaultMessage",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale)",
    "source_code": "\tpublic final String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale) {\n\t\tString msg = getMessageInternal(code, args, locale);\n\t\tif (msg != null) {\n\t\t\treturn msg;\n\t\t}\n\t\tif (defaultMessage == null) {\n\t\t\treturn getDefaultMessage(code);\n\t\t}\n\t\treturn renderDefaultMessage(defaultMessage, args, locale);\n\t}"
  },
  "org.springframework.context.support.AbstractMessageSource#getMessage(code,args,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable Object[] args, Locale locale)",
    "source_code": "\tpublic final String getMessage(String code, @Nullable Object[] args, Locale locale) throws NoSuchMessageException {\n\t\tString msg = getMessageInternal(code, args, locale);\n\t\tif (msg != null) {\n\t\t\treturn msg;\n\t\t}\n\t\tString fallback = getDefaultMessage(code);\n\t\tif (fallback != null) {\n\t\t\treturn fallback;\n\t\t}\n\t\tthrow new NoSuchMessageException(code, locale);\n\t}"
  },
  "org.springframework.context.support.AbstractMessageSource#getMessage(resolvable,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolvable",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "String",
    "signature": "public String getMessage(MessageSourceResolvable resolvable, Locale locale)",
    "source_code": "\tpublic final String getMessage(MessageSourceResolvable resolvable, Locale locale) throws NoSuchMessageException {\n\t\tString[] codes = resolvable.getCodes();\n\t\tif (codes != null) {\n\t\t\tfor (String code : codes) {\n\t\t\t\tString message = getMessageInternal(code, resolvable.getArguments(), locale);\n\t\t\t\tif (message != null) {\n\t\t\t\t\treturn message;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tString defaultMessage = getDefaultMessage(resolvable, locale);\n\t\tif (defaultMessage != null) {\n\t\t\treturn defaultMessage;\n\t\t}\n\t\tthrow new NoSuchMessageException(!ObjectUtils.isEmpty(codes) ? codes[codes.length - 1] : \"\", locale);\n\t}"
  },
  "org.springframework.context.support.AbstractMessageSource#getMessageFromParent(code,args,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Try to retrieve the given message from the parent {@code MessageSource}, if any.\n\t * @param code the code to lookup up, such as 'calculator.noRateSet'\n\t * @param args array of arguments that will be filled in for params\n\t * within the message\n\t * @param locale the locale in which to do the lookup\n\t * @return the resolved message, or {@code null} if not found\n\t * @see #getParentMessageSource()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "code",
      "args",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "String",
    "signature": "protected String getMessageFromParent(String code, @Nullable Object[] args, Locale locale)",
    "source_code": "\tprotected String getMessageFromParent(String code, @Nullable Object[] args, Locale locale) {\n\t\tMessageSource parent = getParentMessageSource();\n\t\tif (parent != null) {\n\t\t\tif (parent instanceof AbstractMessageSource abstractMessageSource) {\n\t\t\t\t// Call internal method to avoid getting the default code back\n\t\t\t\t// in case of \"useCodeAsDefaultMessage\" being activated.\n\t\t\t\treturn abstractMessageSource.getMessageInternal(code, args, locale);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Check parent MessageSource, returning null if not found there.\n\t\t\t\t// Covers custom MessageSource impls and DelegatingMessageSource.\n\t\t\t\treturn parent.getMessage(code, args, null, locale);\n\t\t\t}\n\t\t}\n\t\t// Not found in parent either.\n\t\treturn null;\n\t}"
  },
  "org.springframework.context.support.AbstractMessageSource#getMessageInternal(code,args,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the given code and arguments as message in the given Locale,\n\t * returning {@code null} if not found. Does <i>not</i> fall back to\n\t * the code as default message. Invoked by {@code getMessage} methods.\n\t * @param code the code to lookup up, such as 'calculator.noRateSet'\n\t * @param args array of arguments that will be filled in for params\n\t * within the message\n\t * @param locale the locale in which to do the lookup\n\t * @return the resolved message, or {@code null} if not found\n\t * @see #getMessage(String, Object[], String, Locale)\n\t * @see #getMessage(String, Object[], Locale)\n\t * @see #getMessage(MessageSourceResolvable, Locale)\n\t * @see #setUseCodeAsDefaultMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "code",
      "args",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "String",
    "signature": "protected String getMessageInternal(@Nullable String code, @Nullable Object[] args, @Nullable Locale locale)",
    "source_code": "\tprotected String getMessageInternal(@Nullable String code, @Nullable Object[] args, @Nullable Locale locale) {\n\t\tif (code == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (locale == null) {\n\t\t\tlocale = Locale.getDefault();\n\t\t}\n\t\tObject[] argsToUse = args;\n\n\t\tif (!isAlwaysUseMessageFormat() && ObjectUtils.isEmpty(args)) {\n\t\t\t// Optimized resolution: no arguments to apply,\n\t\t\t// therefore no MessageFormat needs to be involved.\n\t\t\t// Note that the default implementation still uses MessageFormat;\n\t\t\t// this can be overridden in specific subclasses.\n\t\t\tString message = resolveCodeWithoutArguments(code, locale);\n\t\t\tif (message != null) {\n\t\t\t\treturn message;\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\t// Resolve arguments eagerly, for the case where the message\n\t\t\t// is defined in a parent MessageSource but resolvable arguments\n\t\t\t// are defined in the child MessageSource.\n\t\t\targsToUse = resolveArguments(args, locale);\n\n\t\t\tMessageFormat messageFormat = resolveCode(code, locale);\n\t\t\tif (messageFormat != null) {\n\t\t\t\tsynchronized (messageFormat) {\n\t\t\t\t\treturn messageFormat.format(argsToUse);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check locale-independent common messages for the given message code.\n\t\tProperties commonMessages = getCommonMessages();\n\t\tif (commonMessages != null) {\n\t\t\tString commonMessage = commonMessages.getProperty(code);\n\t\t\tif (commonMessage != null) {\n\t\t\t\treturn formatMessage(commonMessage, args, locale);\n\t\t\t}\n\t\t}\n\n\t\t// Not found -> check parent, if any.\n\t\treturn getMessageFromParent(code, argsToUse, locale);\n\t}"
  },
  "org.springframework.context.support.AbstractMessageSource#getParentMessageSource()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "MessageSource",
    "signature": "public MessageSource getParentMessageSource()",
    "source_code": "\tpublic MessageSource getParentMessageSource() {\n\t\treturn this.parentMessageSource;\n\t}"
  },
  "org.springframework.context.support.AbstractMessageSource#isUseCodeAsDefaultMessage()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether to use the message code as default message instead of\n\t * throwing a NoSuchMessageException. Useful for development and debugging.\n\t * Default is \"false\".\n\t * <p>Alternatively, consider overriding the {@link #getDefaultMessage}\n\t * method to return a custom fallback message for an unresolvable code.\n\t * @see #getDefaultMessage(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "boolean",
    "signature": "protected boolean isUseCodeAsDefaultMessage()",
    "source_code": "\tprotected boolean isUseCodeAsDefaultMessage() {\n\t\treturn this.useCodeAsDefaultMessage;\n\t}"
  },
  "org.springframework.context.support.AbstractMessageSource#resolveArguments(args,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Searches through the given array of objects, finds any MessageSourceResolvable\n\t * objects and resolves them.\n\t * <p>Allows for messages to have MessageSourceResolvables as arguments.\n\t * @param args array of arguments for a message\n\t * @param locale the locale to resolve through\n\t * @return an array of arguments with any MessageSourceResolvables resolved\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "args",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "Object[]",
    "signature": "protected Object[] resolveArguments(@Nullable Object[] args, Locale locale)",
    "source_code": "\tprotected Object[] resolveArguments(@Nullable Object[] args, Locale locale) {\n\t\tif (ObjectUtils.isEmpty(args)) {\n\t\t\treturn super.resolveArguments(args, locale);\n\t\t}\n\t\tList<Object> resolvedArgs = new ArrayList<>(args.length);\n\t\tfor (Object arg : args) {\n\t\t\tif (arg instanceof MessageSourceResolvable messageSourceResolvable) {\n\t\t\t\tresolvedArgs.add(getMessage(messageSourceResolvable, locale));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresolvedArgs.add(arg);\n\t\t\t}\n\t\t}\n\t\treturn resolvedArgs.toArray();\n\t}"
  },
  "org.springframework.context.support.AbstractMessageSource#resolveCode(code,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses must implement this method to resolve a message.\n\t * <p>Returns a MessageFormat instance rather than a message String,\n\t * to allow for appropriate caching of MessageFormats in subclasses.\n\t * <p><b>Subclasses are encouraged to provide optimized resolution\n\t * for messages without arguments, not involving MessageFormat.</b>\n\t * See the {@link #resolveCodeWithoutArguments} javadoc for details.\n\t * @param code the code of the message to resolve\n\t * @param locale the locale to resolve the code for\n\t * (subclasses are encouraged to support internationalization)\n\t * @return the MessageFormat for the message, or {@code null} if not found\n\t * @see #resolveCodeWithoutArguments(String, java.util.Locale)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "code",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 391
    },
    "return": "MessageFormat",
    "signature": "protected MessageFormat resolveCode(String code, Locale locale)",
    "source_code": "\tprotected abstract MessageFormat resolveCode(String code, Locale locale);"
  },
  "org.springframework.context.support.AbstractMessageSource#resolveCodeWithoutArguments(code,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses can override this method to resolve a message without arguments\n\t * in an optimized fashion, i.e. to resolve without involving a MessageFormat.\n\t * <p>The default implementation <i>does</i> use MessageFormat, through\n\t * delegating to the {@link #resolveCode} method. Subclasses are encouraged\n\t * to replace this with optimized resolution.\n\t * <p>Unfortunately, {@code java.text.MessageFormat} is not implemented\n\t * in an efficient fashion. In particular, it does not detect that a message\n\t * pattern doesn't contain argument placeholders in the first place. Therefore,\n\t * it is advisable to circumvent MessageFormat for messages without arguments.\n\t * @param code the code of the message to resolve\n\t * @param locale the locale to resolve the code for\n\t * (subclasses are encouraged to support internationalization)\n\t * @return the message String, or {@code null} if not found\n\t * @see #resolveCode\n\t * @see java.text.MessageFormat\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "code",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 367
    },
    "return": "String",
    "signature": "protected String resolveCodeWithoutArguments(String code, Locale locale)",
    "source_code": "\tprotected String resolveCodeWithoutArguments(String code, Locale locale) {\n\t\tMessageFormat messageFormat = resolveCode(code, locale);\n\t\tif (messageFormat != null) {\n\t\t\tsynchronized (messageFormat) {\n\t\t\t\treturn messageFormat.format(new Object[0]);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.context.support.AbstractMessageSource#setCommonMessages(commonMessages)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify locale-independent common messages, with the message code as key\n\t * and the full message String (may contain argument placeholders) as value.\n\t * <p>May also link to an externally defined Properties object, e.g. defined\n\t * through a {@link org.springframework.beans.factory.config.PropertiesFactoryBean}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "commonMessages"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "void",
    "signature": "public void setCommonMessages(@Nullable Properties commonMessages)",
    "source_code": "\tpublic void setCommonMessages(@Nullable Properties commonMessages) {\n\t\tthis.commonMessages = commonMessages;\n\t}"
  },
  "org.springframework.context.support.AbstractMessageSource#setParentMessageSource(parent)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parent"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "void",
    "signature": "public void setParentMessageSource(@Nullable MessageSource parent)",
    "source_code": "\tpublic void setParentMessageSource(@Nullable MessageSource parent) {\n\t\tthis.parentMessageSource = parent;\n\t}"
  },
  "org.springframework.context.support.AbstractMessageSource#setUseCodeAsDefaultMessage(useCodeAsDefaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to use the message code as default message instead of\n\t * throwing a NoSuchMessageException. Useful for development and debugging.\n\t * Default is \"false\".\n\t * <p>Note: In case of a MessageSourceResolvable with multiple codes\n\t * (like a FieldError) and a MessageSource that has a parent MessageSource,\n\t * do <i>not</i> activate \"useCodeAsDefaultMessage\" in the <i>parent</i>:\n\t * Else, you'll get the first code returned as message by the parent,\n\t * without attempts to check further codes.\n\t * <p>To be able to work with \"useCodeAsDefaultMessage\" turned on in the parent,\n\t * AbstractMessageSource and AbstractApplicationContext contain special checks\n\t * to delegate to the internal {@link #getMessageInternal} method if available.\n\t * In general, it is recommended to just use \"useCodeAsDefaultMessage\" during\n\t * development and not rely on it in production in the first place, though.\n\t * @see #getMessage(String, Object[], Locale)\n\t * @see org.springframework.validation.FieldError\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "useCodeAsDefaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "void",
    "signature": "public void setUseCodeAsDefaultMessage(boolean useCodeAsDefaultMessage)",
    "source_code": "\tpublic void setUseCodeAsDefaultMessage(boolean useCodeAsDefaultMessage) {\n\t\tthis.useCodeAsDefaultMessage = useCodeAsDefaultMessage;\n\t}"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Default implementation of the {@link LifecycleProcessor} strategy.\n *\n * @author Mark Fisher\n * @author Juergen Hoeller\n * @since 3.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "signature": "public class DefaultLifecycleProcessor",
    "source_code": "public class DefaultLifecycleProcessor implements LifecycleProcessor, BeanFactoryAware {\n\n\tprivate final Log logger = LogFactory.getLog(getClass());\n\n\tprivate volatile long timeoutPerShutdownPhase = 30000;\n\n\tprivate volatile boolean running;\n\n\t@Nullable\n\tprivate volatile ConfigurableListableBeanFactory beanFactory;\n\n\n\t/**\n\t * Specify the maximum time allotted in milliseconds for the shutdown of\n\t * any phase (group of SmartLifecycle beans with the same 'phase' value).\n\t * <p>The default value is 30 seconds.\n\t */\n\tpublic void setTimeoutPerShutdownPhase(long timeoutPerShutdownPhase) {\n\t\tthis.timeoutPerShutdownPhase = timeoutPerShutdownPhase;\n\t}\n\n\t@Override\n\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tif (!(beanFactory instanceof ConfigurableListableBeanFactory clbf)) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"DefaultLifecycleProcessor requires a ConfigurableListableBeanFactory: \" + beanFactory);\n\t\t}\n\t\tthis.beanFactory = clbf;\n\t}\n\n\tprivate ConfigurableListableBeanFactory getBeanFactory() {\n\t\tConfigurableListableBeanFactory beanFactory = this.beanFactory;\n\t\tAssert.state(beanFactory != null, \"No BeanFactory available\");\n\t\treturn beanFactory;\n\t}\n\n\n\t// Lifecycle implementation\n\n\t/**\n\t * Start all registered beans that implement {@link Lifecycle} and are <i>not</i>\n\t * already running. Any bean that implements {@link SmartLifecycle} will be\n\t * started within its 'phase', and all phases will be ordered from lowest to\n\t * highest value. All beans that do not implement {@link SmartLifecycle} will be\n\t * started in the default phase 0. A bean declared as a dependency of another bean\n\t * will be started before the dependent bean regardless of the declared phase.\n\t */\n\t@Override\n\tpublic void start() {\n\t\tstartBeans(false);\n\t\tthis.running = true;\n\t}\n\n\t/**\n\t * Stop all registered beans that implement {@link Lifecycle} and <i>are</i>\n\t * currently running. Any bean that implements {@link SmartLifecycle} will be\n\t * stopped within its 'phase', and all phases will be ordered from highest to\n\t * lowest value. All beans that do not implement {@link SmartLifecycle} will be\n\t * stopped in the default phase 0. A bean declared as dependent on another bean\n\t * will be stopped before the dependency bean regardless of the declared phase.\n\t */\n\t@Override\n\tpublic void stop() {\n\t\tstopBeans();\n\t\tthis.running = false;\n\t}\n\n\t@Override\n\tpublic void onRefresh() {\n\t\tstartBeans(true);\n\t\tthis.running = true;\n\t}\n\n\t@Override\n\tpublic void onClose() {\n\t\tstopBeans();\n\t\tthis.running = false;\n\t}\n\n\t@Override\n\tpublic boolean isRunning() {\n\t\treturn this.running;\n\t}\n\n\n\t// Internal helpers\n\n\tprivate void startBeans(boolean autoStartupOnly) {\n\t\tMap<String, Lifecycle> lifecycleBeans = getLifecycleBeans();\n\t\tMap<Integer, LifecycleGroup> phases = new TreeMap<>();\n\n\t\tlifecycleBeans.forEach((beanName, bean) -> {\n\t\t\tif (!autoStartupOnly || (bean instanceof SmartLifecycle smartLifecycle && smartLifecycle.isAutoStartup())) {\n\t\t\t\tint phase = getPhase(bean);\n\t\t\t\tphases.computeIfAbsent(\n\t\t\t\t\t\tphase,\n\t\t\t\t\t\tp -> new LifecycleGroup(phase, this.timeoutPerShutdownPhase, lifecycleBeans, autoStartupOnly)\n\t\t\t\t).add(beanName, bean);\n\t\t\t}\n\t\t});\n\t\tif (!phases.isEmpty()) {\n\t\t\tphases.values().forEach(LifecycleGroup::start);\n\t\t}\n\t}\n\n\t/**\n\t * Start the specified bean as part of the given set of Lifecycle beans,\n\t * making sure that any beans that it depends on are started first.\n\t * @param lifecycleBeans a Map with bean name as key and Lifecycle instance as value\n\t * @param beanName the name of the bean to start\n\t */\n\tprivate void doStart(Map<String, ? extends Lifecycle> lifecycleBeans, String beanName, boolean autoStartupOnly) {\n\t\tLifecycle bean = lifecycleBeans.remove(beanName);\n\t\tif (bean != null && bean != this) {\n\t\t\tString[] dependenciesForBean = getBeanFactory().getDependenciesForBean(beanName);\n\t\t\tfor (String dependency : dependenciesForBean) {\n\t\t\t\tdoStart(lifecycleBeans, dependency, autoStartupOnly);\n\t\t\t}\n\t\t\tif (!bean.isRunning() &&\n\t\t\t\t\t(!autoStartupOnly || !(bean instanceof SmartLifecycle smartLifecycle) || smartLifecycle.isAutoStartup())) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Starting bean '\" + beanName + \"' of type [\" + bean.getClass().getName() + \"]\");\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tbean.start();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tthrow new ApplicationContextException(\"Failed to start bean '\" + beanName + \"'\", ex);\n\t\t\t\t}\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Successfully started bean '\" + beanName + \"'\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void stopBeans() {\n\t\tMap<String, Lifecycle> lifecycleBeans = getLifecycleBeans();\n\t\tMap<Integer, LifecycleGroup> phases = new HashMap<>();\n\t\tlifecycleBeans.forEach((beanName, bean) -> {\n\t\t\tint shutdownPhase = getPhase(bean);\n\t\t\tLifecycleGroup group = phases.get(shutdownPhase);\n\t\t\tif (group == null) {\n\t\t\t\tgroup = new LifecycleGroup(shutdownPhase, this.timeoutPerShutdownPhase, lifecycleBeans, false);\n\t\t\t\tphases.put(shutdownPhase, group);\n\t\t\t}\n\t\t\tgroup.add(beanName, bean);\n\t\t});\n\t\tif (!phases.isEmpty()) {\n\t\t\tList<Integer> keys = new ArrayList<>(phases.keySet());\n\t\t\tkeys.sort(Collections.reverseOrder());\n\t\t\tfor (Integer key : keys) {\n\t\t\t\tphases.get(key).stop();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Stop the specified bean as part of the given set of Lifecycle beans,\n\t * making sure that any beans that depends on it are stopped first.\n\t * @param lifecycleBeans a Map with bean name as key and Lifecycle instance as value\n\t * @param beanName the name of the bean to stop\n\t */\n\tprivate void doStop(Map<String, ? extends Lifecycle> lifecycleBeans, final String beanName,\n\t\t\tfinal CountDownLatch latch, final Set<String> countDownBeanNames) {\n\n\t\tLifecycle bean = lifecycleBeans.remove(beanName);\n\t\tif (bean != null) {\n\t\t\tString[] dependentBeans = getBeanFactory().getDependentBeans(beanName);\n\t\t\tfor (String dependentBean : dependentBeans) {\n\t\t\t\tdoStop(lifecycleBeans, dependentBean, latch, countDownBeanNames);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tif (bean.isRunning()) {\n\t\t\t\t\tif (bean instanceof SmartLifecycle smartLifecycle) {\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Asking bean '\" + beanName + \"' of type [\" +\n\t\t\t\t\t\t\t\t\tbean.getClass().getName() + \"] to stop\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcountDownBeanNames.add(beanName);\n\t\t\t\t\t\tsmartLifecycle.stop(() -> {\n\t\t\t\t\t\t\tlatch.countDown();\n\t\t\t\t\t\t\tcountDownBeanNames.remove(beanName);\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Bean '\" + beanName + \"' completed its stop procedure\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Stopping bean '\" + beanName + \"' of type [\" +\n\t\t\t\t\t\t\t\t\tbean.getClass().getName() + \"]\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbean.stop();\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Successfully stopped bean '\" + beanName + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (bean instanceof SmartLifecycle) {\n\t\t\t\t\t// Don't wait for beans that aren't running...\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\tlogger.warn(\"Failed to stop bean '\" + beanName + \"'\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// overridable hooks\n\n\t/**\n\t * Retrieve all applicable Lifecycle beans: all singletons that have already been created,\n\t * as well as all SmartLifecycle beans (even if they are marked as lazy-init).\n\t * @return the Map of applicable beans, with bean names as keys and bean instances as values\n\t */\n\tprotected Map<String, Lifecycle> getLifecycleBeans() {\n\t\tConfigurableListableBeanFactory beanFactory = getBeanFactory();\n\t\tMap<String, Lifecycle> beans = new LinkedHashMap<>();\n\t\tString[] beanNames = beanFactory.getBeanNamesForType(Lifecycle.class, false, false);\n\t\tfor (String beanName : beanNames) {\n\t\t\tString beanNameToRegister = BeanFactoryUtils.transformedBeanName(beanName);\n\t\t\tboolean isFactoryBean = beanFactory.isFactoryBean(beanNameToRegister);\n\t\t\tString beanNameToCheck = (isFactoryBean ? BeanFactory.FACTORY_BEAN_PREFIX + beanName : beanName);\n\t\t\tif ((beanFactory.containsSingleton(beanNameToRegister) &&\n\t\t\t\t\t(!isFactoryBean || matchesBeanType(Lifecycle.class, beanNameToCheck, beanFactory))) ||\n\t\t\t\t\tmatchesBeanType(SmartLifecycle.class, beanNameToCheck, beanFactory)) {\n\t\t\t\tObject bean = beanFactory.getBean(beanNameToCheck);\n\t\t\t\tif (bean != this && bean instanceof Lifecycle lifecycle) {\n\t\t\t\t\tbeans.put(beanNameToRegister, lifecycle);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn beans;\n\t}\n\n\tprivate boolean matchesBeanType(Class<?> targetType, String beanName, BeanFactory beanFactory) {\n\t\tClass<?> beanType = beanFactory.getType(beanName);\n\t\treturn (beanType != null && targetType.isAssignableFrom(beanType));\n\t}\n\n\t/**\n\t * Determine the lifecycle phase of the given bean.\n\t * <p>The default implementation checks for the {@link Phased} interface, using\n\t * a default of 0 otherwise. Can be overridden to apply other/further policies.\n\t * @param bean the bean to introspect\n\t * @return the phase (an integer value)\n\t * @see Phased#getPhase()\n\t * @see SmartLifecycle\n\t */\n\tprotected int getPhase(Lifecycle bean) {\n\t\treturn (bean instanceof Phased phased ? phased.getPhase() : 0);\n\t}\n\n\n\t/**\n\t * Helper class for maintaining a group of Lifecycle beans that should be started\n\t * and stopped together based on their 'phase' value (or the default value of 0).\n\t */\n\tprivate class LifecycleGroup {\n\n\t\tprivate final int phase;\n\n\t\tprivate final long timeout;\n\n\t\tprivate final Map<String, ? extends Lifecycle> lifecycleBeans;\n\n\t\tprivate final boolean autoStartupOnly;\n\n\t\tprivate final List<LifecycleGroupMember> members = new ArrayList<>();\n\n\t\tprivate int smartMemberCount;\n\n\t\tpublic LifecycleGroup(\n\t\t\t\tint phase, long timeout, Map<String, ? extends Lifecycle> lifecycleBeans, boolean autoStartupOnly) {\n\n\t\t\tthis.phase = phase;\n\t\t\tthis.timeout = timeout;\n\t\t\tthis.lifecycleBeans = lifecycleBeans;\n\t\t\tthis.autoStartupOnly = autoStartupOnly;\n\t\t}\n\n\t\tpublic void add(String name, Lifecycle bean) {\n\t\t\tthis.members.add(new LifecycleGroupMember(name, bean));\n\t\t\tif (bean instanceof SmartLifecycle) {\n\t\t\t\tthis.smartMemberCount++;\n\t\t\t}\n\t\t}\n\n\t\tpublic void start() {\n\t\t\tif (this.members.isEmpty()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Starting beans in phase \" + this.phase);\n\t\t\t}\n\t\t\tCollections.sort(this.members);\n\t\t\tfor (LifecycleGroupMember member : this.members) {\n\t\t\t\tdoStart(this.lifecycleBeans, member.name, this.autoStartupOnly);\n\t\t\t}\n\t\t}\n\n\t\tpublic void stop() {\n\t\t\tif (this.members.isEmpty()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Stopping beans in phase \" + this.phase);\n\t\t\t}\n\t\t\tthis.members.sort(Collections.reverseOrder());\n\t\t\tCountDownLatch latch = new CountDownLatch(this.smartMemberCount);\n\t\t\tSet<String> countDownBeanNames = Collections.synchronizedSet(new LinkedHashSet<>());\n\t\t\tSet<String> lifecycleBeanNames = new HashSet<>(this.lifecycleBeans.keySet());\n\t\t\tfor (LifecycleGroupMember member : this.members) {\n\t\t\t\tif (lifecycleBeanNames.contains(member.name)) {\n\t\t\t\t\tdoStop(this.lifecycleBeans, member.name, latch, countDownBeanNames);\n\t\t\t\t}\n\t\t\t\telse if (member.bean instanceof SmartLifecycle) {\n\t\t\t\t\t// Already removed: must have been a dependent bean from another phase\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tlatch.await(this.timeout, TimeUnit.MILLISECONDS);\n\t\t\t\tif (latch.getCount() > 0 && !countDownBeanNames.isEmpty() && logger.isInfoEnabled()) {\n\t\t\t\t\tlogger.info(\"Failed to shut down \" + countDownBeanNames.size() + \" bean\" +\n\t\t\t\t\t\t\t(countDownBeanNames.size() > 1 ? \"s\" : \"\") + \" with phase value \" +\n\t\t\t\t\t\t\tthis.phase + \" within timeout of \" + this.timeout + \"ms: \" + countDownBeanNames);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (InterruptedException ex) {\n\t\t\t\tThread.currentThread().interrupt();\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Adapts the Comparable interface onto the lifecycle phase model.\n\t */\n\tprivate class LifecycleGroupMember implements Comparable<LifecycleGroupMember> {\n\n\t\tprivate final String name;\n\n\t\tprivate final Lifecycle bean;\n\n\t\tLifecycleGroupMember(String name, Lifecycle bean) {\n\t\t\tthis.name = name;\n\t\t\tthis.bean = bean;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(LifecycleGroupMember other) {\n\t\t\tint thisPhase = getPhase(this.bean);\n\t\t\tint otherPhase = getPhase(other.bean);\n\t\t\treturn Integer.compare(thisPhase, otherPhase);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#add(name,bean)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 340
    },
    "return": "void",
    "signature": "public void add(String name, Lifecycle bean)",
    "source_code": "\t\tpublic void add(String name, Lifecycle bean) {\n\t\t\tthis.members.add(new LifecycleGroupMember(name, bean));\n\t\t\tif (bean instanceof SmartLifecycle) {\n\t\t\t\tthis.smartMemberCount++;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#compareTo(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 410
    },
    "return": "int",
    "signature": "public int compareTo(LifecycleGroupMember other)",
    "source_code": "\t\tpublic int compareTo(LifecycleGroupMember other) {\n\t\t\tint thisPhase = getPhase(this.bean);\n\t\t\tint otherPhase = getPhase(other.bean);\n\t\t\treturn Integer.compare(thisPhase, otherPhase);\n\t\t}"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#getLifecycleBeans()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve all applicable Lifecycle beans: all singletons that have already been created,\n\t * as well as all SmartLifecycle beans (even if they are marked as lazy-init).\n\t * @return the Map of applicable beans, with bean names as keys and bean instances as values\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "Lifecycle>",
    "signature": "protected Lifecycle> getLifecycleBeans()",
    "source_code": "\tprotected Map<String, Lifecycle> getLifecycleBeans() {\n\t\tConfigurableListableBeanFactory beanFactory = getBeanFactory();\n\t\tMap<String, Lifecycle> beans = new LinkedHashMap<>();\n\t\tString[] beanNames = beanFactory.getBeanNamesForType(Lifecycle.class, false, false);\n\t\tfor (String beanName : beanNames) {\n\t\t\tString beanNameToRegister = BeanFactoryUtils.transformedBeanName(beanName);\n\t\t\tboolean isFactoryBean = beanFactory.isFactoryBean(beanNameToRegister);\n\t\t\tString beanNameToCheck = (isFactoryBean ? BeanFactory.FACTORY_BEAN_PREFIX + beanName : beanName);\n\t\t\tif ((beanFactory.containsSingleton(beanNameToRegister) &&\n\t\t\t\t\t(!isFactoryBean || matchesBeanType(Lifecycle.class, beanNameToCheck, beanFactory))) ||\n\t\t\t\t\tmatchesBeanType(SmartLifecycle.class, beanNameToCheck, beanFactory)) {\n\t\t\t\tObject bean = beanFactory.getBean(beanNameToCheck);\n\t\t\t\tif (bean != this && bean instanceof Lifecycle lifecycle) {\n\t\t\t\t\tbeans.put(beanNameToRegister, lifecycle);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn beans;\n\t}"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#getPhase(bean)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the lifecycle phase of the given bean.\n\t * <p>The default implementation checks for the {@link Phased} interface, using\n\t * a default of 0 otherwise. Can be overridden to apply other/further policies.\n\t * @param bean the bean to introspect\n\t * @return the phase (an integer value)\n\t * @see Phased#getPhase()\n\t * @see SmartLifecycle\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "int",
    "signature": "protected int getPhase(Lifecycle bean)",
    "source_code": "\tprotected int getPhase(Lifecycle bean) {\n\t\treturn (bean instanceof Phased phased ? phased.getPhase() : 0);\n\t}"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#isRunning()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "boolean",
    "signature": "public boolean isRunning()",
    "source_code": "\tpublic boolean isRunning() {\n\t\treturn this.running;\n\t}"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#onClose()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "void",
    "signature": "public void onClose()",
    "source_code": "\tpublic void onClose() {\n\t\tstopBeans();\n\t\tthis.running = false;\n\t}"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#onRefresh()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "void",
    "signature": "public void onRefresh()",
    "source_code": "\tpublic void onRefresh() {\n\t\tstartBeans(true);\n\t\tthis.running = true;\n\t}"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "void",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tif (!(beanFactory instanceof ConfigurableListableBeanFactory clbf)) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"DefaultLifecycleProcessor requires a ConfigurableListableBeanFactory: \" + beanFactory);\n\t\t}\n\t\tthis.beanFactory = clbf;\n\t}"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#setTimeoutPerShutdownPhase(timeoutPerShutdownPhase)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the maximum time allotted in milliseconds for the shutdown of\n\t * any phase (group of SmartLifecycle beans with the same 'phase' value).\n\t * <p>The default value is 30 seconds.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeoutPerShutdownPhase"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "void",
    "signature": "public void setTimeoutPerShutdownPhase(long timeoutPerShutdownPhase)",
    "source_code": "\tpublic void setTimeoutPerShutdownPhase(long timeoutPerShutdownPhase) {\n\t\tthis.timeoutPerShutdownPhase = timeoutPerShutdownPhase;\n\t}"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#start()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "void",
    "signature": "public void start()",
    "source_code": "\t\tpublic void start() {\n\t\t\tif (this.members.isEmpty()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Starting beans in phase \" + this.phase);\n\t\t\t}\n\t\t\tCollections.sort(this.members);\n\t\t\tfor (LifecycleGroupMember member : this.members) {\n\t\t\t\tdoStart(this.lifecycleBeans, member.name, this.autoStartupOnly);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#stop()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 360
    },
    "return": "void",
    "signature": "public void stop()",
    "source_code": "\t\tpublic void stop() {\n\t\t\tif (this.members.isEmpty()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Stopping beans in phase \" + this.phase);\n\t\t\t}\n\t\t\tthis.members.sort(Collections.reverseOrder());\n\t\t\tCountDownLatch latch = new CountDownLatch(this.smartMemberCount);\n\t\t\tSet<String> countDownBeanNames = Collections.synchronizedSet(new LinkedHashSet<>());\n\t\t\tSet<String> lifecycleBeanNames = new HashSet<>(this.lifecycleBeans.keySet());\n\t\t\tfor (LifecycleGroupMember member : this.members) {\n\t\t\t\tif (lifecycleBeanNames.contains(member.name)) {\n\t\t\t\t\tdoStop(this.lifecycleBeans, member.name, latch, countDownBeanNames);\n\t\t\t\t}\n\t\t\t\telse if (member.bean instanceof SmartLifecycle) {\n\t\t\t\t\t// Already removed: must have been a dependent bean from another phase\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tlatch.await(this.timeout, TimeUnit.MILLISECONDS);\n\t\t\t\tif (latch.getCount() > 0 && !countDownBeanNames.isEmpty() && logger.isInfoEnabled()) {\n\t\t\t\t\tlogger.info(\"Failed to shut down \" + countDownBeanNames.size() + \" bean\" +\n\t\t\t\t\t\t\t(countDownBeanNames.size() > 1 ? \"s\" : \"\") + \" with phase value \" +\n\t\t\t\t\t\t\tthis.phase + \" within timeout of \" + this.timeout + \"ms: \" + countDownBeanNames);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (InterruptedException ex) {\n\t\t\t\tThread.currentThread().interrupt();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.context.support.GenericApplicationContext": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Generic ApplicationContext implementation that holds a single internal\n * {@link org.springframework.beans.factory.support.DefaultListableBeanFactory}\n * instance and does not assume a specific bean definition format. Implements\n * the {@link org.springframework.beans.factory.support.BeanDefinitionRegistry}\n * interface in order to allow for applying any bean definition readers to it.\n *\n * <p>Typical usage is to register a variety of bean definitions via the\n * {@link org.springframework.beans.factory.support.BeanDefinitionRegistry}\n * interface and then call {@link #refresh()} to initialize those beans\n * with application context semantics (handling\n * {@link org.springframework.context.ApplicationContextAware}, auto-detecting\n * {@link org.springframework.beans.factory.config.BeanFactoryPostProcessor BeanFactoryPostProcessors},\n * etc).\n *\n * <p>In contrast to other ApplicationContext implementations that create a new\n * internal BeanFactory instance for each refresh, the internal BeanFactory of\n * this context is available right from the start, to be able to register bean\n * definitions on it. {@link #refresh()} may only be called once.\n *\n * <p>This ApplicationContext implementation is suitable for Ahead of Time\n * processing, using {@link #refreshForAotProcessing()} as an alternative to the\n * regular {@link #refresh()}.\n *\n * <p>Usage example:\n *\n * <pre class=\"code\">\n * GenericApplicationContext ctx = new GenericApplicationContext();\n * XmlBeanDefinitionReader xmlReader = new XmlBeanDefinitionReader(ctx);\n * xmlReader.loadBeanDefinitions(new ClassPathResource(\"applicationContext.xml\"));\n * PropertiesBeanDefinitionReader propReader = new PropertiesBeanDefinitionReader(ctx);\n * propReader.loadBeanDefinitions(new ClassPathResource(\"otherBeans.properties\"));\n * ctx.refresh();\n *\n * MyBean myBean = (MyBean) ctx.getBean(\"myBean\");\n * ...</pre>\n *\n * For the typical case of XML bean definitions, simply use\n * {@link ClassPathXmlApplicationContext} or {@link FileSystemXmlApplicationContext},\n * which are easier to set up - but less flexible, since you can just use standard\n * resource locations for XML bean definitions, rather than mixing arbitrary bean\n * definition formats. The equivalent in a web environment is\n * {@link org.springframework.web.context.support.XmlWebApplicationContext}.\n *\n * <p>For custom application context implementations that are supposed to read\n * special bean definition formats in a refreshable manner, consider deriving\n * from the {@link AbstractRefreshableApplicationContext} base class.\n *\n * @author Juergen Hoeller\n * @author Chris Beams\n * @author Stephane Nicoll\n * @author Sam Brannen\n * @since 1.1.2\n * @see #registerBeanDefinition\n * @see #refresh()\n * @see org.springframework.beans.factory.xml.XmlBeanDefinitionReader\n * @see org.springframework.beans.factory.support.PropertiesBeanDefinitionReader\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "signature": "public class GenericApplicationContext",
    "source_code": "public class GenericApplicationContext extends AbstractApplicationContext implements BeanDefinitionRegistry {\n\n\tprivate static final Consumer<Builder> asClassBasedProxy = hint ->\n\t\t\thint.withMembers(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS,\n\t\t\t\t\tMemberCategory.INVOKE_DECLARED_METHODS,\n\t\t\t\t\tMemberCategory.DECLARED_FIELDS);\n\n\tprivate static final Consumer<Builder> asProxiedUserClass = hint ->\n\t\t\thint.withMembers(MemberCategory.INVOKE_PUBLIC_METHODS);\n\n\n\tprivate final DefaultListableBeanFactory beanFactory;\n\n\t@Nullable\n\tprivate ResourceLoader resourceLoader;\n\n\tprivate boolean customClassLoader = false;\n\n\tprivate final AtomicBoolean refreshed = new AtomicBoolean();\n\n\n\t/**\n\t * Create a new GenericApplicationContext.\n\t * @see #registerBeanDefinition\n\t * @see #refresh\n\t */\n\tpublic GenericApplicationContext() {\n\t\tthis.beanFactory = new DefaultListableBeanFactory();\n\t}\n\n\t/**\n\t * Create a new GenericApplicationContext with the given DefaultListableBeanFactory.\n\t * @param beanFactory the DefaultListableBeanFactory instance to use for this context\n\t * @see #registerBeanDefinition\n\t * @see #refresh\n\t */\n\tpublic GenericApplicationContext(DefaultListableBeanFactory beanFactory) {\n\t\tAssert.notNull(beanFactory, \"BeanFactory must not be null\");\n\t\tthis.beanFactory = beanFactory;\n\t}\n\n\t/**\n\t * Create a new GenericApplicationContext with the given parent.\n\t * @param parent the parent application context\n\t * @see #registerBeanDefinition\n\t * @see #refresh\n\t */\n\tpublic GenericApplicationContext(@Nullable ApplicationContext parent) {\n\t\tthis();\n\t\tsetParent(parent);\n\t}\n\n\t/**\n\t * Create a new GenericApplicationContext with the given DefaultListableBeanFactory.\n\t * @param beanFactory the DefaultListableBeanFactory instance to use for this context\n\t * @param parent the parent application context\n\t * @see #registerBeanDefinition\n\t * @see #refresh\n\t */\n\tpublic GenericApplicationContext(DefaultListableBeanFactory beanFactory, ApplicationContext parent) {\n\t\tthis(beanFactory);\n\t\tsetParent(parent);\n\t}\n\n\n\t/**\n\t * Set the parent of this application context, also setting\n\t * the parent of the internal BeanFactory accordingly.\n\t * @see org.springframework.beans.factory.config.ConfigurableBeanFactory#setParentBeanFactory\n\t */\n\t@Override\n\tpublic void setParent(@Nullable ApplicationContext parent) {\n\t\tsuper.setParent(parent);\n\t\tthis.beanFactory.setParentBeanFactory(getInternalParentBeanFactory());\n\t}\n\n\t@Override\n\tpublic void setApplicationStartup(ApplicationStartup applicationStartup) {\n\t\tsuper.setApplicationStartup(applicationStartup);\n\t\tthis.beanFactory.setApplicationStartup(applicationStartup);\n\t}\n\n\t/**\n\t * Set whether it should be allowed to override bean definitions by registering\n\t * a different definition with the same name, automatically replacing the former.\n\t * If not, an exception will be thrown. Default is \"true\".\n\t * @since 3.0\n\t * @see org.springframework.beans.factory.support.DefaultListableBeanFactory#setAllowBeanDefinitionOverriding\n\t */\n\tpublic void setAllowBeanDefinitionOverriding(boolean allowBeanDefinitionOverriding) {\n\t\tthis.beanFactory.setAllowBeanDefinitionOverriding(allowBeanDefinitionOverriding);\n\t}\n\n\t/**\n\t * Set whether to allow circular references between beans - and automatically\n\t * try to resolve them.\n\t * <p>Default is \"true\". Turn this off to throw an exception when encountering\n\t * a circular reference, disallowing them completely.\n\t * @since 3.0\n\t * @see org.springframework.beans.factory.support.DefaultListableBeanFactory#setAllowCircularReferences\n\t */\n\tpublic void setAllowCircularReferences(boolean allowCircularReferences) {\n\t\tthis.beanFactory.setAllowCircularReferences(allowCircularReferences);\n\t}\n\n\t/**\n\t * Set a ResourceLoader to use for this context. If set, the context will\n\t * delegate all {@code getResource} calls to the given ResourceLoader.\n\t * If not set, default resource loading will apply.\n\t * <p>The main reason to specify a custom ResourceLoader is to resolve\n\t * resource paths (without URL prefix) in a specific fashion.\n\t * The default behavior is to resolve such paths as class path locations.\n\t * To resolve resource paths as file system locations, specify a\n\t * FileSystemResourceLoader here.\n\t * <p>You can also pass in a full ResourcePatternResolver, which will\n\t * be autodetected by the context and used for {@code getResources}\n\t * calls as well. Else, default resource pattern matching will apply.\n\t * @see #getResource\n\t * @see org.springframework.core.io.DefaultResourceLoader\n\t * @see org.springframework.core.io.FileSystemResourceLoader\n\t * @see org.springframework.core.io.support.ResourcePatternResolver\n\t * @see #getResources\n\t */\n\tpublic void setResourceLoader(ResourceLoader resourceLoader) {\n\t\tthis.resourceLoader = resourceLoader;\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// ResourceLoader / ResourcePatternResolver override if necessary\n\t//---------------------------------------------------------------------\n\n\t/**\n\t * This implementation delegates to this context's {@code ResourceLoader} if set,\n\t * falling back to the default superclass behavior otherwise.\n\t * <p>As of Spring Framework 5.3.22, this method also honors registered\n\t * {@linkplain #getProtocolResolvers() protocol resolvers} when a custom\n\t * {@code ResourceLoader} has been set.\n\t * @see #setResourceLoader(ResourceLoader)\n\t * @see #addProtocolResolver(ProtocolResolver)\n\t */\n\t@Override\n\tpublic Resource getResource(String location) {\n\t\tif (this.resourceLoader != null) {\n\t\t\tfor (ProtocolResolver protocolResolver : getProtocolResolvers()) {\n\t\t\t\tResource resource = protocolResolver.resolve(location, this);\n\t\t\t\tif (resource != null) {\n\t\t\t\t\treturn resource;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.resourceLoader.getResource(location);\n\t\t}\n\t\treturn super.getResource(location);\n\t}\n\n\t/**\n\t * This implementation delegates to this context's ResourceLoader if it\n\t * implements the ResourcePatternResolver interface, falling back to the\n\t * default superclass behavior otherwise.\n\t * @see #setResourceLoader\n\t */\n\t@Override\n\tpublic Resource[] getResources(String locationPattern) throws IOException {\n\t\tif (this.resourceLoader instanceof ResourcePatternResolver resourcePatternResolver) {\n\t\t\treturn resourcePatternResolver.getResources(locationPattern);\n\t\t}\n\t\treturn super.getResources(locationPattern);\n\t}\n\n\t@Override\n\tpublic void setClassLoader(@Nullable ClassLoader classLoader) {\n\t\tsuper.setClassLoader(classLoader);\n\t\tthis.customClassLoader = true;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic ClassLoader getClassLoader() {\n\t\tif (this.resourceLoader != null && !this.customClassLoader) {\n\t\t\treturn this.resourceLoader.getClassLoader();\n\t\t}\n\t\treturn super.getClassLoader();\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Implementations of AbstractApplicationContext's template methods\n\t//---------------------------------------------------------------------\n\n\t/**\n\t * Do nothing: We hold a single internal BeanFactory and rely on callers\n\t * to register beans through our public methods (or the BeanFactory's).\n\t * @see #registerBeanDefinition\n\t */\n\t@Override\n\tprotected final void refreshBeanFactory() throws IllegalStateException {\n\t\tif (!this.refreshed.compareAndSet(false, true)) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"GenericApplicationContext does not support multiple refresh attempts: just call 'refresh' once\");\n\t\t}\n\t\tthis.beanFactory.setSerializationId(getId());\n\t}\n\n\t@Override\n\tprotected void cancelRefresh(BeansException ex) {\n\t\tthis.beanFactory.setSerializationId(null);\n\t\tsuper.cancelRefresh(ex);\n\t}\n\n\t/**\n\t * Not much to do: We hold a single internal BeanFactory that will never\n\t * get released.\n\t */\n\t@Override\n\tprotected final void closeBeanFactory() {\n\t\tthis.beanFactory.setSerializationId(null);\n\t}\n\n\t/**\n\t * Return the single internal BeanFactory held by this context\n\t * (as ConfigurableListableBeanFactory).\n\t */\n\t@Override\n\tpublic final ConfigurableListableBeanFactory getBeanFactory() {\n\t\treturn this.beanFactory;\n\t}\n\n\t/**\n\t * Return the underlying bean factory of this context,\n\t * available for registering bean definitions.\n\t * <p><b>NOTE:</b> You need to call {@link #refresh()} to initialize the\n\t * bean factory and its contained beans with application context semantics\n\t * (autodetecting BeanFactoryPostProcessors, etc).\n\t * @return the internal bean factory (as DefaultListableBeanFactory)\n\t */\n\tpublic final DefaultListableBeanFactory getDefaultListableBeanFactory() {\n\t\treturn this.beanFactory;\n\t}\n\n\t@Override\n\tpublic AutowireCapableBeanFactory getAutowireCapableBeanFactory() throws IllegalStateException {\n\t\tassertBeanFactoryActive();\n\t\treturn this.beanFactory;\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Implementation of BeanDefinitionRegistry\n\t//---------------------------------------------------------------------\n\n\t@Override\n\tpublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\n\t\t\tthrows BeanDefinitionStoreException {\n\n\t\tthis.beanFactory.registerBeanDefinition(beanName, beanDefinition);\n\t}\n\n\t@Override\n\tpublic void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException {\n\t\tthis.beanFactory.removeBeanDefinition(beanName);\n\t}\n\n\t@Override\n\tpublic BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException {\n\t\treturn this.beanFactory.getBeanDefinition(beanName);\n\t}\n\n\t@Override\n\tpublic boolean isBeanNameInUse(String beanName) {\n\t\treturn this.beanFactory.isBeanNameInUse(beanName);\n\t}\n\n\t@Override\n\tpublic void registerAlias(String beanName, String alias) {\n\t\tthis.beanFactory.registerAlias(beanName, alias);\n\t}\n\n\t@Override\n\tpublic void removeAlias(String alias) {\n\t\tthis.beanFactory.removeAlias(alias);\n\t}\n\n\t@Override\n\tpublic boolean isAlias(String beanName) {\n\t\treturn this.beanFactory.isAlias(beanName);\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// AOT processing\n\t//---------------------------------------------------------------------\n\n\t/**\n\t * Load or refresh the persistent representation of the configuration up to\n\t * a point where the underlying bean factory is ready to create bean\n\t * instances.\n\t * <p>This variant of {@link #refresh()} is used by Ahead of Time (AOT)\n\t * processing that optimizes the application context, typically at build time.\n\t * <p>In this mode, only {@link BeanDefinitionRegistryPostProcessor} and\n\t * {@link MergedBeanDefinitionPostProcessor} are invoked.\n\t * @param runtimeHints the runtime hints\n\t * @throws BeansException if the bean factory could not be initialized\n\t * @throws IllegalStateException if already initialized and multiple refresh\n\t * attempts are not supported\n\t * @since 6.0\n\t */\n\tpublic void refreshForAotProcessing(RuntimeHints runtimeHints) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Preparing bean factory for AOT processing\");\n\t\t}\n\t\tprepareRefresh();\n\t\tobtainFreshBeanFactory();\n\t\tprepareBeanFactory(this.beanFactory);\n\t\tpostProcessBeanFactory(this.beanFactory);\n\t\tinvokeBeanFactoryPostProcessors(this.beanFactory);\n\t\tthis.beanFactory.freezeConfiguration();\n\t\tPostProcessorRegistrationDelegate.invokeMergedBeanDefinitionPostProcessors(this.beanFactory);\n\t\tpreDetermineBeanTypes(runtimeHints);\n\t}\n\n\t/**\n\t * Pre-determine bean types in order to trigger early proxy class creation.\n\t * @see org.springframework.beans.factory.BeanFactory#getType\n\t * @see SmartInstantiationAwareBeanPostProcessor#determineBeanType\n\t */\n\tprivate void preDetermineBeanTypes(RuntimeHints runtimeHints) {\n\t\tList<SmartInstantiationAwareBeanPostProcessor> bpps =\n\t\t\t\tPostProcessorRegistrationDelegate.loadBeanPostProcessors(\n\t\t\t\t\t\tthis.beanFactory, SmartInstantiationAwareBeanPostProcessor.class);\n\n\t\tfor (String beanName : this.beanFactory.getBeanDefinitionNames()) {\n\t\t\tClass<?> beanType = this.beanFactory.getType(beanName);\n\t\t\tif (beanType != null) {\n\t\t\t\tregisterProxyHintIfNecessary(beanType, runtimeHints);\n\t\t\t\tfor (SmartInstantiationAwareBeanPostProcessor bpp : bpps) {\n\t\t\t\t\tClass<?> newBeanType = bpp.determineBeanType(beanType, beanName);\n\t\t\t\t\tif (newBeanType != beanType) {\n\t\t\t\t\t\tregisterProxyHintIfNecessary(newBeanType, runtimeHints);\n\t\t\t\t\t\tbeanType = newBeanType;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void registerProxyHintIfNecessary(Class<?> beanType, RuntimeHints runtimeHints) {\n\t\tif (Proxy.isProxyClass(beanType)) {\n\t\t\t// A JDK proxy class needs an explicit hint\n\t\t\truntimeHints.proxies().registerJdkProxy(beanType.getInterfaces());\n\t\t}\n\t\telse {\n\t\t\t// Potentially a CGLIB-generated subclass with reflection hints\n\t\t\tClass<?> userClass = ClassUtils.getUserClass(beanType);\n\t\t\tif (userClass != beanType) {\n\t\t\t\truntimeHints.reflection()\n\t\t\t\t\t\t.registerType(beanType, asClassBasedProxy)\n\t\t\t\t\t\t.registerType(userClass, asProxiedUserClass);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Convenient methods for registering individual beans\n\t//---------------------------------------------------------------------\n\n\t/**\n\t * Register a bean from the given bean class, optionally providing explicit\n\t * constructor arguments for consideration in the autowiring process.\n\t * @param beanClass the class of the bean\n\t * @param constructorArgs custom argument values to be fed into Spring's\n\t * constructor resolution algorithm, resolving either all arguments or just\n\t * specific ones, with the rest to be resolved through regular autowiring\n\t * (may be {@code null} or empty)\n\t * @since 5.2 (since 5.0 on the AnnotationConfigApplicationContext subclass)\n\t */\n\tpublic <T> void registerBean(Class<T> beanClass, Object... constructorArgs) {\n\t\tregisterBean(null, beanClass, constructorArgs);\n\t}\n\n\t/**\n\t * Register a bean from the given bean class, optionally providing explicit\n\t * constructor arguments for consideration in the autowiring process.\n\t * @param beanName the name of the bean (may be {@code null})\n\t * @param beanClass the class of the bean\n\t * @param constructorArgs custom argument values to be fed into Spring's\n\t * constructor resolution algorithm, resolving either all arguments or just\n\t * specific ones, with the rest to be resolved through regular autowiring\n\t * (may be {@code null} or empty)\n\t * @since 5.2 (since 5.0 on the AnnotationConfigApplicationContext subclass)\n\t */\n\tpublic <T> void registerBean(@Nullable String beanName, Class<T> beanClass, Object... constructorArgs) {\n\t\tregisterBean(beanName, beanClass, (Supplier<T>) null,\n\t\t\t\tbd -> {\n\t\t\t\t\tfor (Object arg : constructorArgs) {\n\t\t\t\t\t\tbd.getConstructorArgumentValues().addGenericArgumentValue(arg);\n\t\t\t\t\t}\n\t\t\t\t});\n\t}\n\n\t/**\n\t * Register a bean from the given bean class, optionally customizing its\n\t * bean definition metadata (typically declared as a lambda expression).\n\t * @param beanClass the class of the bean (resolving a public constructor\n\t * to be autowired, possibly simply the default constructor)\n\t * @param customizers one or more callbacks for customizing the factory's\n\t * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag\n\t * @since 5.0\n\t * @see #registerBean(String, Class, Supplier, BeanDefinitionCustomizer...)\n\t */\n\tpublic final <T> void registerBean(Class<T> beanClass, BeanDefinitionCustomizer... customizers) {\n\t\tregisterBean(null, beanClass, null, customizers);\n\t}\n\n\t/**\n\t * Register a bean from the given bean class, optionally customizing its\n\t * bean definition metadata (typically declared as a lambda expression).\n\t * @param beanName the name of the bean (may be {@code null})\n\t * @param beanClass the class of the bean (resolving a public constructor\n\t * to be autowired, possibly simply the default constructor)\n\t * @param customizers one or more callbacks for customizing the factory's\n\t * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag\n\t * @since 5.0\n\t * @see #registerBean(String, Class, Supplier, BeanDefinitionCustomizer...)\n\t */\n\tpublic final <T> void registerBean(\n\t\t\t@Nullable String beanName, Class<T> beanClass, BeanDefinitionCustomizer... customizers) {\n\n\t\tregisterBean(beanName, beanClass, null, customizers);\n\t}\n\n\t/**\n\t * Register a bean from the given bean class, using the given supplier for\n\t * obtaining a new instance (typically declared as a lambda expression or\n\t * method reference), optionally customizing its bean definition metadata\n\t * (again typically declared as a lambda expression).\n\t * @param beanClass the class of the bean\n\t * @param supplier a callback for creating an instance of the bean\n\t * @param customizers one or more callbacks for customizing the factory's\n\t * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag\n\t * @since 5.0\n\t * @see #registerBean(String, Class, Supplier, BeanDefinitionCustomizer...)\n\t */\n\tpublic final <T> void registerBean(\n\t\t\tClass<T> beanClass, Supplier<T> supplier, BeanDefinitionCustomizer... customizers) {\n\n\t\tregisterBean(null, beanClass, supplier, customizers);\n\t}\n\n\t/**\n\t * Register a bean from the given bean class, using the given supplier for\n\t * obtaining a new instance (typically declared as a lambda expression or\n\t * method reference), optionally customizing its bean definition metadata\n\t * (again typically declared as a lambda expression).\n\t * <p>This method can be overridden to adapt the registration mechanism for\n\t * all {@code registerBean} methods (since they all delegate to this one).\n\t * @param beanName the name of the bean (may be {@code null})\n\t * @param beanClass the class of the bean\n\t * @param supplier a callback for creating an instance of the bean (in case\n\t * of {@code null}, resolving a public constructor to be autowired instead)\n\t * @param customizers one or more callbacks for customizing the factory's\n\t * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag\n\t * @since 5.0\n\t */\n\tpublic <T> void registerBean(@Nullable String beanName, Class<T> beanClass,\n\t\t\t@Nullable Supplier<T> supplier, BeanDefinitionCustomizer... customizers) {\n\n\t\tClassDerivedBeanDefinition beanDefinition = new ClassDerivedBeanDefinition(beanClass);\n\t\tif (supplier != null) {\n\t\t\tbeanDefinition.setInstanceSupplier(supplier);\n\t\t}\n\t\tfor (BeanDefinitionCustomizer customizer : customizers) {\n\t\t\tcustomizer.customize(beanDefinition);\n\t\t}\n\n\t\tString nameToUse = (beanName != null ? beanName : beanClass.getName());\n\t\tregisterBeanDefinition(nameToUse, beanDefinition);\n\t}\n\n\n\t/**\n\t * {@link RootBeanDefinition} marker subclass for {@code #registerBean} based\n\t * registrations with flexible autowiring for public constructors.\n\t */\n\t@SuppressWarnings(\"serial\")\n\tprivate static class ClassDerivedBeanDefinition extends RootBeanDefinition {\n\n\t\tpublic ClassDerivedBeanDefinition(Class<?> beanClass) {\n\t\t\tsuper(beanClass);\n\t\t}\n\n\t\tpublic ClassDerivedBeanDefinition(ClassDerivedBeanDefinition original) {\n\t\t\tsuper(original);\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Constructor<?>[] getPreferredConstructors() {\n\t\t\tClass<?> clazz = getBeanClass();\n\t\t\tConstructor<?> primaryCtor = BeanUtils.findPrimaryConstructor(clazz);\n\t\t\tif (primaryCtor != null) {\n\t\t\t\treturn new Constructor<?>[] {primaryCtor};\n\t\t\t}\n\t\t\tConstructor<?>[] publicCtors = clazz.getConstructors();\n\t\t\tif (publicCtors.length > 0) {\n\t\t\t\treturn publicCtors;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic RootBeanDefinition cloneBeanDefinition() {\n\t\t\treturn new ClassDerivedBeanDefinition(this);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.context.support.GenericApplicationContext#cancelRefresh(ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 316
    },
    "return": "void",
    "signature": "protected void cancelRefresh(BeansException ex)",
    "source_code": "\tprotected void cancelRefresh(BeansException ex) {\n\t\tthis.beanFactory.setSerializationId(null);\n\t\tsuper.cancelRefresh(ex);\n\t}"
  },
  "org.springframework.context.support.GenericApplicationContext#cloneBeanDefinition()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 623
    },
    "return": "RootBeanDefinition",
    "signature": "public RootBeanDefinition cloneBeanDefinition()",
    "source_code": "\t\tpublic RootBeanDefinition cloneBeanDefinition() {\n\t\t\treturn new ClassDerivedBeanDefinition(this);\n\t\t}"
  },
  "org.springframework.context.support.GenericApplicationContext#closeBeanFactory()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Not much to do: We hold a single internal BeanFactory that will never\n\t * get released.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 326
    },
    "return": "void",
    "signature": "protected void closeBeanFactory()",
    "source_code": "\tprotected final void closeBeanFactory() {\n\t\tthis.beanFactory.setSerializationId(null);\n\t}"
  },
  "org.springframework.context.support.GenericApplicationContext#getAutowireCapableBeanFactory()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 352
    },
    "return": "AutowireCapableBeanFactory",
    "signature": "public AutowireCapableBeanFactory getAutowireCapableBeanFactory()",
    "source_code": "\tpublic AutowireCapableBeanFactory getAutowireCapableBeanFactory() throws IllegalStateException {\n\t\tassertBeanFactoryActive();\n\t\treturn this.beanFactory;\n\t}"
  },
  "org.springframework.context.support.GenericApplicationContext#getBeanDefinition(beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 375
    },
    "return": "BeanDefinition",
    "signature": "public BeanDefinition getBeanDefinition(String beanName)",
    "source_code": "\tpublic BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException {\n\t\treturn this.beanFactory.getBeanDefinition(beanName);\n\t}"
  },
  "org.springframework.context.support.GenericApplicationContext#getBeanFactory()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the single internal BeanFactory held by this context\n\t * (as ConfigurableListableBeanFactory).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 335
    },
    "return": "ConfigurableListableBeanFactory",
    "signature": "public ConfigurableListableBeanFactory getBeanFactory()",
    "source_code": "\tpublic final ConfigurableListableBeanFactory getBeanFactory() {\n\t\treturn this.beanFactory;\n\t}"
  },
  "org.springframework.context.support.GenericApplicationContext#getClassLoader()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 289
    },
    "return": "ClassLoader",
    "signature": "public ClassLoader getClassLoader()",
    "source_code": "\tpublic ClassLoader getClassLoader() {\n\t\tif (this.resourceLoader != null && !this.customClassLoader) {\n\t\t\treturn this.resourceLoader.getClassLoader();\n\t\t}\n\t\treturn super.getClassLoader();\n\t}"
  },
  "org.springframework.context.support.GenericApplicationContext#getDefaultListableBeanFactory()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the underlying bean factory of this context,\n\t * available for registering bean definitions.\n\t * <p><b>NOTE:</b> You need to call {@link #refresh()} to initialize the\n\t * bean factory and its contained beans with application context semantics\n\t * (autodetecting BeanFactoryPostProcessors, etc).\n\t * @return the internal bean factory (as DefaultListableBeanFactory)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "DefaultListableBeanFactory",
    "signature": "public DefaultListableBeanFactory getDefaultListableBeanFactory()",
    "source_code": "\tpublic final DefaultListableBeanFactory getDefaultListableBeanFactory() {\n\t\treturn this.beanFactory;\n\t}"
  },
  "org.springframework.context.support.GenericApplicationContext#getResource(location)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation delegates to this context's {@code ResourceLoader} if set,\n\t * falling back to the default superclass behavior otherwise.\n\t * <p>As of Spring Framework 5.3.22, this method also honors registered\n\t * {@linkplain #getProtocolResolvers() protocol resolvers} when a custom\n\t * {@code ResourceLoader} has been set.\n\t * @see #setResourceLoader(ResourceLoader)\n\t * @see #addProtocolResolver(ProtocolResolver)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "Resource",
    "signature": "public Resource getResource(String location)",
    "source_code": "\tpublic Resource getResource(String location) {\n\t\tif (this.resourceLoader != null) {\n\t\t\tfor (ProtocolResolver protocolResolver : getProtocolResolvers()) {\n\t\t\t\tResource resource = protocolResolver.resolve(location, this);\n\t\t\t\tif (resource != null) {\n\t\t\t\t\treturn resource;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.resourceLoader.getResource(location);\n\t\t}\n\t\treturn super.getResource(location);\n\t}"
  },
  "org.springframework.context.support.GenericApplicationContext#getResources(locationPattern)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation delegates to this context's ResourceLoader if it\n\t * implements the ResourcePatternResolver interface, falling back to the\n\t * default superclass behavior otherwise.\n\t * @see #setResourceLoader\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locationPattern"
    ],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "Resource[]",
    "signature": "public Resource[] getResources(String locationPattern)",
    "source_code": "\tpublic Resource[] getResources(String locationPattern) throws IOException {\n\t\tif (this.resourceLoader instanceof ResourcePatternResolver resourcePatternResolver) {\n\t\t\treturn resourcePatternResolver.getResources(locationPattern);\n\t\t}\n\t\treturn super.getResources(locationPattern);\n\t}"
  },
  "org.springframework.context.support.GenericApplicationContext#isAlias(beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 395
    },
    "return": "boolean",
    "signature": "public boolean isAlias(String beanName)",
    "source_code": "\tpublic boolean isAlias(String beanName) {\n\t\treturn this.beanFactory.isAlias(beanName);\n\t}"
  },
  "org.springframework.context.support.GenericApplicationContext#isBeanNameInUse(beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 380
    },
    "return": "boolean",
    "signature": "public boolean isBeanNameInUse(String beanName)",
    "source_code": "\tpublic boolean isBeanNameInUse(String beanName) {\n\t\treturn this.beanFactory.isBeanNameInUse(beanName);\n\t}"
  },
  "org.springframework.context.support.GenericApplicationContext#refreshBeanFactory()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Do nothing: We hold a single internal BeanFactory and rely on callers\n\t * to register beans through our public methods (or the BeanFactory's).\n\t * @see #registerBeanDefinition\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 307
    },
    "return": "void",
    "signature": "protected void refreshBeanFactory()",
    "source_code": "\tprotected final void refreshBeanFactory() throws IllegalStateException {\n\t\tif (!this.refreshed.compareAndSet(false, true)) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"GenericApplicationContext does not support multiple refresh attempts: just call 'refresh' once\");\n\t\t}\n\t\tthis.beanFactory.setSerializationId(getId());\n\t}"
  },
  "org.springframework.context.support.GenericApplicationContext#refreshForAotProcessing(runtimeHints)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Load or refresh the persistent representation of the configuration up to\n\t * a point where the underlying bean factory is ready to create bean\n\t * instances.\n\t * <p>This variant of {@link #refresh()} is used by Ahead of Time (AOT)\n\t * processing that optimizes the application context, typically at build time.\n\t * <p>In this mode, only {@link BeanDefinitionRegistryPostProcessor} and\n\t * {@link MergedBeanDefinitionPostProcessor} are invoked.\n\t * @param runtimeHints the runtime hints\n\t * @throws BeansException if the bean factory could not be initialized\n\t * @throws IllegalStateException if already initialized and multiple refresh\n\t * attempts are not supported\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runtimeHints"
    ],
    "position": {
      "column": 1,
      "line": 418
    },
    "return": "void",
    "signature": "public void refreshForAotProcessing(RuntimeHints runtimeHints)",
    "source_code": "\tpublic void refreshForAotProcessing(RuntimeHints runtimeHints) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Preparing bean factory for AOT processing\");\n\t\t}\n\t\tprepareRefresh();\n\t\tobtainFreshBeanFactory();\n\t\tprepareBeanFactory(this.beanFactory);\n\t\tpostProcessBeanFactory(this.beanFactory);\n\t\tinvokeBeanFactoryPostProcessors(this.beanFactory);\n\t\tthis.beanFactory.freezeConfiguration();\n\t\tPostProcessorRegistrationDelegate.invokeMergedBeanDefinitionPostProcessors(this.beanFactory);\n\t\tpreDetermineBeanTypes(runtimeHints);\n\t}"
  },
  "org.springframework.context.support.GenericApplicationContext#registerAlias(beanName,alias)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "alias"
    ],
    "position": {
      "column": 1,
      "line": 385
    },
    "return": "void",
    "signature": "public void registerAlias(String beanName, String alias)",
    "source_code": "\tpublic void registerAlias(String beanName, String alias) {\n\t\tthis.beanFactory.registerAlias(beanName, alias);\n\t}"
  },
  "org.springframework.context.support.GenericApplicationContext#registerBean(beanClass,constructorArgs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, optionally providing explicit\n\t * constructor arguments for consideration in the autowiring process.\n\t * @param beanClass the class of the bean\n\t * @param constructorArgs custom argument values to be fed into Spring's\n\t * constructor resolution algorithm, resolving either all arguments or just\n\t * specific ones, with the rest to be resolved through regular autowiring\n\t * (may be {@code null} or empty)\n\t * @since 5.2 (since 5.0 on the AnnotationConfigApplicationContext subclass)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "constructorArgs"
    ],
    "position": {
      "column": 1,
      "line": 488
    },
    "return": "void",
    "signature": "public void registerBean(Class<T> beanClass, Object... constructorArgs)",
    "source_code": "\tpublic <T> void registerBean(Class<T> beanClass, Object... constructorArgs) {\n\t\tregisterBean(null, beanClass, constructorArgs);\n\t}"
  },
  "org.springframework.context.support.GenericApplicationContext#registerBean(beanClass,customizers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, optionally customizing its\n\t * bean definition metadata (typically declared as a lambda expression).\n\t * @param beanClass the class of the bean (resolving a public constructor\n\t * to be autowired, possibly simply the default constructor)\n\t * @param customizers one or more callbacks for customizing the factory's\n\t * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag\n\t * @since 5.0\n\t * @see #registerBean(String, Class, Supplier, BeanDefinitionCustomizer...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "customizers"
    ],
    "position": {
      "column": 1,
      "line": 522
    },
    "return": "void",
    "signature": "public void registerBean(Class<T> beanClass, BeanDefinitionCustomizer... customizers)",
    "source_code": "\tpublic final <T> void registerBean(Class<T> beanClass, BeanDefinitionCustomizer... customizers) {\n\t\tregisterBean(null, beanClass, null, customizers);\n\t}"
  },
  "org.springframework.context.support.GenericApplicationContext#registerBean(beanClass,supplier,customizers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, using the given supplier for\n\t * obtaining a new instance (typically declared as a lambda expression or\n\t * method reference), optionally customizing its bean definition metadata\n\t * (again typically declared as a lambda expression).\n\t * @param beanClass the class of the bean\n\t * @param supplier a callback for creating an instance of the bean\n\t * @param customizers one or more callbacks for customizing the factory's\n\t * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag\n\t * @since 5.0\n\t * @see #registerBean(String, Class, Supplier, BeanDefinitionCustomizer...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "supplier",
      "customizers"
    ],
    "position": {
      "column": 1,
      "line": 555
    },
    "return": "void",
    "signature": "public void registerBean(Class<T> beanClass, Supplier<T> supplier, BeanDefinitionCustomizer... customizers)",
    "source_code": "\tpublic final <T> void registerBean("
  },
  "org.springframework.context.support.GenericApplicationContext#registerBean(beanName,beanClass,constructorArgs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, optionally providing explicit\n\t * constructor arguments for consideration in the autowiring process.\n\t * @param beanName the name of the bean (may be {@code null})\n\t * @param beanClass the class of the bean\n\t * @param constructorArgs custom argument values to be fed into Spring's\n\t * constructor resolution algorithm, resolving either all arguments or just\n\t * specific ones, with the rest to be resolved through regular autowiring\n\t * (may be {@code null} or empty)\n\t * @since 5.2 (since 5.0 on the AnnotationConfigApplicationContext subclass)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "beanClass",
      "constructorArgs"
    ],
    "position": {
      "column": 1,
      "line": 503
    },
    "return": "void",
    "signature": "public void registerBean(@Nullable String beanName, Class<T> beanClass, Object... constructorArgs)",
    "source_code": "\tpublic <T> void registerBean(@Nullable String beanName, Class<T> beanClass, Object... constructorArgs) {\n\t\tregisterBean(beanName, beanClass, (Supplier<T>) null,\n\t\t\t\tbd -> {\n\t\t\t\t\tfor (Object arg : constructorArgs) {\n\t\t\t\t\t\tbd.getConstructorArgumentValues().addGenericArgumentValue(arg);\n\t\t\t\t\t}\n\t\t\t\t});\n\t}"
  },
  "org.springframework.context.support.GenericApplicationContext#registerBean(beanName,beanClass,customizers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, optionally customizing its\n\t * bean definition metadata (typically declared as a lambda expression).\n\t * @param beanName the name of the bean (may be {@code null})\n\t * @param beanClass the class of the bean (resolving a public constructor\n\t * to be autowired, possibly simply the default constructor)\n\t * @param customizers one or more callbacks for customizing the factory's\n\t * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag\n\t * @since 5.0\n\t * @see #registerBean(String, Class, Supplier, BeanDefinitionCustomizer...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "beanClass",
      "customizers"
    ],
    "position": {
      "column": 1,
      "line": 537
    },
    "return": "void",
    "signature": "public void registerBean(@Nullable String beanName, Class<T> beanClass, BeanDefinitionCustomizer... customizers)",
    "source_code": "\tpublic final <T> void registerBean("
  },
  "org.springframework.context.support.GenericApplicationContext#registerBean(beanName,beanClass,supplier,customizers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, using the given supplier for\n\t * obtaining a new instance (typically declared as a lambda expression or\n\t * method reference), optionally customizing its bean definition metadata\n\t * (again typically declared as a lambda expression).\n\t * <p>This method can be overridden to adapt the registration mechanism for\n\t * all {@code registerBean} methods (since they all delegate to this one).\n\t * @param beanName the name of the bean (may be {@code null})\n\t * @param beanClass the class of the bean\n\t * @param supplier a callback for creating an instance of the bean (in case\n\t * of {@code null}, resolving a public constructor to be autowired instead)\n\t * @param customizers one or more callbacks for customizing the factory's\n\t * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "beanClass",
      "supplier",
      "customizers"
    ],
    "position": {
      "column": 1,
      "line": 576
    },
    "return": "void",
    "signature": "public void registerBean(@Nullable String beanName, Class<T> beanClass,\n\t\t\t@Nullable Supplier<T> supplier, BeanDefinitionCustomizer... customizers)",
    "source_code": "\tpublic <T> void registerBean(@Nullable String beanName, Class<T> beanClass,"
  },
  "org.springframework.context.support.GenericApplicationContext#registerBeanDefinition(beanName,beanDefinition)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "beanDefinition"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "void",
    "signature": "public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)",
    "source_code": "\tpublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)"
  },
  "org.springframework.context.support.GenericApplicationContext#removeAlias(alias)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "alias"
    ],
    "position": {
      "column": 1,
      "line": 390
    },
    "return": "void",
    "signature": "public void removeAlias(String alias)",
    "source_code": "\tpublic void removeAlias(String alias) {\n\t\tthis.beanFactory.removeAlias(alias);\n\t}"
  },
  "org.springframework.context.support.GenericApplicationContext#removeBeanDefinition(beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 370
    },
    "return": "void",
    "signature": "public void removeBeanDefinition(String beanName)",
    "source_code": "\tpublic void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException {\n\t\tthis.beanFactory.removeBeanDefinition(beanName);\n\t}"
  },
  "org.springframework.context.support.GenericApplicationContext#setAllowBeanDefinitionOverriding(allowBeanDefinitionOverriding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether it should be allowed to override bean definitions by registering\n\t * a different definition with the same name, automatically replacing the former.\n\t * If not, an exception will be thrown. Default is \"true\".\n\t * @since 3.0\n\t * @see org.springframework.beans.factory.support.DefaultListableBeanFactory#setAllowBeanDefinitionOverriding\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "allowBeanDefinitionOverriding"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "void",
    "signature": "public void setAllowBeanDefinitionOverriding(boolean allowBeanDefinitionOverriding)",
    "source_code": "\tpublic void setAllowBeanDefinitionOverriding(boolean allowBeanDefinitionOverriding) {\n\t\tthis.beanFactory.setAllowBeanDefinitionOverriding(allowBeanDefinitionOverriding);\n\t}"
  },
  "org.springframework.context.support.GenericApplicationContext#setAllowCircularReferences(allowCircularReferences)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to allow circular references between beans - and automatically\n\t * try to resolve them.\n\t * <p>Default is \"true\". Turn this off to throw an exception when encountering\n\t * a circular reference, disallowing them completely.\n\t * @since 3.0\n\t * @see org.springframework.beans.factory.support.DefaultListableBeanFactory#setAllowCircularReferences\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "allowCircularReferences"
    ],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "void",
    "signature": "public void setAllowCircularReferences(boolean allowCircularReferences)",
    "source_code": "\tpublic void setAllowCircularReferences(boolean allowCircularReferences) {\n\t\tthis.beanFactory.setAllowCircularReferences(allowCircularReferences);\n\t}"
  },
  "org.springframework.context.support.GenericApplicationContext#setApplicationStartup(applicationStartup)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "applicationStartup"
    ],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "void",
    "signature": "public void setApplicationStartup(ApplicationStartup applicationStartup)",
    "source_code": "\tpublic void setApplicationStartup(ApplicationStartup applicationStartup) {\n\t\tsuper.setApplicationStartup(applicationStartup);\n\t\tthis.beanFactory.setApplicationStartup(applicationStartup);\n\t}"
  },
  "org.springframework.context.support.GenericApplicationContext#setClassLoader(classLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "void",
    "signature": "public void setClassLoader(@Nullable ClassLoader classLoader)",
    "source_code": "\tpublic void setClassLoader(@Nullable ClassLoader classLoader) {\n\t\tsuper.setClassLoader(classLoader);\n\t\tthis.customClassLoader = true;\n\t}"
  },
  "org.springframework.context.support.GenericApplicationContext#setParent(parent)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the parent of this application context, also setting\n\t * the parent of the internal BeanFactory accordingly.\n\t * @see org.springframework.beans.factory.config.ConfigurableBeanFactory#setParentBeanFactory\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parent"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "void",
    "signature": "public void setParent(@Nullable ApplicationContext parent)",
    "source_code": "\tpublic void setParent(@Nullable ApplicationContext parent) {\n\t\tsuper.setParent(parent);\n\t\tthis.beanFactory.setParentBeanFactory(getInternalParentBeanFactory());\n\t}"
  },
  "org.springframework.context.support.GenericApplicationContext#setResourceLoader(resourceLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a ResourceLoader to use for this context. If set, the context will\n\t * delegate all {@code getResource} calls to the given ResourceLoader.\n\t * If not set, default resource loading will apply.\n\t * <p>The main reason to specify a custom ResourceLoader is to resolve\n\t * resource paths (without URL prefix) in a specific fashion.\n\t * The default behavior is to resolve such paths as class path locations.\n\t * To resolve resource paths as file system locations, specify a\n\t * FileSystemResourceLoader here.\n\t * <p>You can also pass in a full ResourcePatternResolver, which will\n\t * be autodetected by the context and used for {@code getResources}\n\t * calls as well. Else, default resource pattern matching will apply.\n\t * @see #getResource\n\t * @see org.springframework.core.io.DefaultResourceLoader\n\t * @see org.springframework.core.io.FileSystemResourceLoader\n\t * @see org.springframework.core.io.support.ResourcePatternResolver\n\t * @see #getResources\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resourceLoader"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "void",
    "signature": "public void setResourceLoader(ResourceLoader resourceLoader)",
    "source_code": "\tpublic void setResourceLoader(ResourceLoader resourceLoader) {\n\t\tthis.resourceLoader = resourceLoader;\n\t}"
  },
  "org.springframework.context.support.GenericGroovyApplicationContext": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * An {@link org.springframework.context.ApplicationContext} implementation that extends\n * {@link GenericApplicationContext} and implements {@link GroovyObject} such that beans\n * can be retrieved with the dot de-reference syntax instead of using {@link #getBean}.\n *\n * <p>Consider this as the equivalent of {@link GenericXmlApplicationContext} for\n * Groovy bean definitions, or even an upgrade thereof since it seamlessly understands\n * XML bean definition files as well. The main difference is that, within a Groovy\n * script, the context can be used with an inline bean definition closure as follows:\n *\n * <pre class=\"code\">\n * import org.hibernate.SessionFactory\n * import org.apache.commons.dbcp.BasicDataSource\n *\n * def context = new GenericGroovyApplicationContext()\n * context.reader.beans {\n *     dataSource(BasicDataSource) {                  // &lt;--- invokeMethod\n *         driverClassName = \"org.hsqldb.jdbcDriver\"\n *         url = \"jdbc:hsqldb:mem:grailsDB\"\n *         username = \"sa\"                            // &lt;-- setProperty\n *         password = \"\"\n *         settings = [mynew:\"setting\"]\n *     }\n *     sessionFactory(SessionFactory) {\n *         dataSource = dataSource                    // &lt;-- getProperty for retrieving references\n *     }\n *     myService(MyService) {\n *         nestedBean = { AnotherBean bean -&gt;         // &lt;-- setProperty with closure for nested bean\n *             dataSource = dataSource\n *         }\n *     }\n * }\n * context.refresh()\n * </pre>\n *\n * <p>Alternatively, load a Groovy bean definition script like the following\n * from an external resource (e.g. an \"applicationContext.groovy\" file):\n *\n * <pre class=\"code\">\n * import org.hibernate.SessionFactory\n * import org.apache.commons.dbcp.BasicDataSource\n *\n * beans {\n *     dataSource(BasicDataSource) {\n *         driverClassName = \"org.hsqldb.jdbcDriver\"\n *         url = \"jdbc:hsqldb:mem:grailsDB\"\n *         username = \"sa\"\n *         password = \"\"\n *         settings = [mynew:\"setting\"]\n *     }\n *     sessionFactory(SessionFactory) {\n *         dataSource = dataSource\n *     }\n *     myService(MyService) {\n *         nestedBean = { AnotherBean bean -&gt;\n *             dataSource = dataSource\n *         }\n *     }\n * }\n * </pre>\n *\n * <p>With the following Java code creating the {@code GenericGroovyApplicationContext}\n * (potentially using Ant-style '*'/'**' location patterns):\n *\n * <pre class=\"code\">\n * GenericGroovyApplicationContext context = new GenericGroovyApplicationContext();\n * context.load(\"org/myapp/applicationContext.groovy\");\n * context.refresh();\n * </pre>\n *\n * <p>Or even more concise, provided that no extra configuration is needed:\n *\n * <pre class=\"code\">\n * ApplicationContext context = new GenericGroovyApplicationContext(\"org/myapp/applicationContext.groovy\");\n * </pre>\n *\n * <p><b>This application context also understands XML bean definition files,\n * allowing for seamless mixing and matching with Groovy bean definition files.</b>\n * \".xml\" files will be parsed as XML content; all other kinds of resources will\n * be parsed as Groovy scripts.\n *\n * @author Juergen Hoeller\n * @author Jeff Brown\n * @since 4.0\n * @see org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "signature": "public class GenericGroovyApplicationContext",
    "source_code": "public class GenericGroovyApplicationContext extends GenericApplicationContext implements GroovyObject {\n\n\tprivate final GroovyBeanDefinitionReader reader = new GroovyBeanDefinitionReader(this);\n\n\tprivate final BeanWrapper contextWrapper = new BeanWrapperImpl(this);\n\n\tprivate MetaClass metaClass = GroovySystem.getMetaClassRegistry().getMetaClass(getClass());\n\n\n\t/**\n\t * Create a new GenericGroovyApplicationContext that needs to be\n\t * {@link #load loaded} and then manually {@link #refresh refreshed}.\n\t */\n\tpublic GenericGroovyApplicationContext() {\n\t}\n\n\t/**\n\t * Create a new GenericGroovyApplicationContext, loading bean definitions\n\t * from the given resources and automatically refreshing the context.\n\t * @param resources the resources to load from\n\t */\n\tpublic GenericGroovyApplicationContext(Resource... resources) {\n\t\tload(resources);\n\t\trefresh();\n\t}\n\n\t/**\n\t * Create a new GenericGroovyApplicationContext, loading bean definitions\n\t * from the given resource locations and automatically refreshing the context.\n\t * @param resourceLocations the resources to load from\n\t */\n\tpublic GenericGroovyApplicationContext(String... resourceLocations) {\n\t\tload(resourceLocations);\n\t\trefresh();\n\t}\n\n\t/**\n\t * Create a new GenericGroovyApplicationContext, loading bean definitions\n\t * from the given resource locations and automatically refreshing the context.\n\t * @param relativeClass class whose package will be used as a prefix when\n\t * loading each specified resource name\n\t * @param resourceNames relatively-qualified names of resources to load\n\t */\n\tpublic GenericGroovyApplicationContext(Class<?> relativeClass, String... resourceNames) {\n\t\tload(relativeClass, resourceNames);\n\t\trefresh();\n\t}\n\n\n\t/**\n\t * Exposes the underlying {@link GroovyBeanDefinitionReader} for convenient access\n\t * to the {@code loadBeanDefinition} methods on it as well as the ability\n\t * to specify an inline Groovy bean definition closure.\n\t * @see GroovyBeanDefinitionReader#loadBeanDefinitions(org.springframework.core.io.Resource...)\n\t * @see GroovyBeanDefinitionReader#loadBeanDefinitions(String...)\n\t */\n\tpublic final GroovyBeanDefinitionReader getReader() {\n\t\treturn this.reader;\n\t}\n\n\t/**\n\t * Delegates the given environment to underlying {@link GroovyBeanDefinitionReader}.\n\t * Should be called before any call to {@code #load}.\n\t */\n\t@Override\n\tpublic void setEnvironment(ConfigurableEnvironment environment) {\n\t\tsuper.setEnvironment(environment);\n\t\tthis.reader.setEnvironment(getEnvironment());\n\t}\n\n\t/**\n\t * Load bean definitions from the given Groovy scripts or XML files.\n\t * <p>Note that \".xml\" files will be parsed as XML content; all other kinds\n\t * of resources will be parsed as Groovy scripts.\n\t * @param resources one or more resources to load from\n\t */\n\tpublic void load(Resource... resources) {\n\t\tthis.reader.loadBeanDefinitions(resources);\n\t}\n\n\t/**\n\t * Load bean definitions from the given Groovy scripts or XML files.\n\t * <p>Note that \".xml\" files will be parsed as XML content; all other kinds\n\t * of resources will be parsed as Groovy scripts.\n\t * @param resourceLocations one or more resource locations to load from\n\t */\n\tpublic void load(String... resourceLocations) {\n\t\tthis.reader.loadBeanDefinitions(resourceLocations);\n\t}\n\n\t/**\n\t * Load bean definitions from the given Groovy scripts or XML files.\n\t * <p>Note that \".xml\" files will be parsed as XML content; all other kinds\n\t * of resources will be parsed as Groovy scripts.\n\t * @param relativeClass class whose package will be used as a prefix when\n\t * loading each specified resource name\n\t * @param resourceNames relatively-qualified names of resources to load\n\t */\n\tpublic void load(Class<?> relativeClass, String... resourceNames) {\n\t\tResource[] resources = new Resource[resourceNames.length];\n\t\tfor (int i = 0; i < resourceNames.length; i++) {\n\t\t\tresources[i] = new ClassPathResource(resourceNames[i], relativeClass);\n\t\t}\n\t\tload(resources);\n\t}\n\n\n\t// Implementation of the GroovyObject interface\n\n\t@Override\n\tpublic void setMetaClass(MetaClass metaClass) {\n\t\tthis.metaClass = metaClass;\n\t}\n\n\t@Override\n\tpublic MetaClass getMetaClass() {\n\t\treturn this.metaClass;\n\t}\n\n\t@Override\n\tpublic Object invokeMethod(String name, Object args) {\n\t\treturn this.metaClass.invokeMethod(this, name, args);\n\t}\n\n\t@Override\n\tpublic void setProperty(String property, Object newValue) {\n\t\tif (newValue instanceof BeanDefinition beanDefinition) {\n\t\t\tregisterBeanDefinition(property, beanDefinition);\n\t\t}\n\t\telse {\n\t\t\tthis.metaClass.setProperty(this, property, newValue);\n\t\t}\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Object getProperty(String property) {\n\t\tif (containsBean(property)) {\n\t\t\treturn getBean(property);\n\t\t}\n\t\telse if (this.contextWrapper.isReadableProperty(property)) {\n\t\t\treturn this.contextWrapper.getPropertyValue(property);\n\t\t}\n\t\tthrow new NoSuchBeanDefinitionException(property);\n\t}\n\n}"
  },
  "org.springframework.context.support.GenericGroovyApplicationContext#getMetaClass()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 234
    },
    "return": "MetaClass",
    "signature": "public MetaClass getMetaClass()",
    "source_code": "\tpublic MetaClass getMetaClass() {\n\t\treturn this.metaClass;\n\t}"
  },
  "org.springframework.context.support.GenericGroovyApplicationContext#getProperty(property)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "property"
    ],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "Object",
    "signature": "public Object getProperty(String property)",
    "source_code": "\tpublic Object getProperty(String property) {\n\t\tif (containsBean(property)) {\n\t\t\treturn getBean(property);\n\t\t}\n\t\telse if (this.contextWrapper.isReadableProperty(property)) {\n\t\t\treturn this.contextWrapper.getPropertyValue(property);\n\t\t}\n\t\tthrow new NoSuchBeanDefinitionException(property);\n\t}"
  },
  "org.springframework.context.support.GenericGroovyApplicationContext#getReader()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Exposes the underlying {@link GroovyBeanDefinitionReader} for convenient access\n\t * to the {@code loadBeanDefinition} methods on it as well as the ability\n\t * to specify an inline Groovy bean definition closure.\n\t * @see GroovyBeanDefinitionReader#loadBeanDefinitions(org.springframework.core.io.Resource...)\n\t * @see GroovyBeanDefinitionReader#loadBeanDefinitions(String...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "GroovyBeanDefinitionReader",
    "signature": "public GroovyBeanDefinitionReader getReader()",
    "source_code": "\tpublic final GroovyBeanDefinitionReader getReader() {\n\t\treturn this.reader;\n\t}"
  },
  "org.springframework.context.support.GenericGroovyApplicationContext#invokeMethod(name,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "Object",
    "signature": "public Object invokeMethod(String name, Object args)",
    "source_code": "\tpublic Object invokeMethod(String name, Object args) {\n\t\treturn this.metaClass.invokeMethod(this, name, args);\n\t}"
  },
  "org.springframework.context.support.GenericGroovyApplicationContext#load(relativeClass,resourceNames)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Load bean definitions from the given Groovy scripts or XML files.\n\t * <p>Note that \".xml\" files will be parsed as XML content; all other kinds\n\t * of resources will be parsed as Groovy scripts.\n\t * @param relativeClass class whose package will be used as a prefix when\n\t * loading each specified resource name\n\t * @param resourceNames relatively-qualified names of resources to load\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "relativeClass",
      "resourceNames"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "void",
    "signature": "public void load(Class<?> relativeClass, String... resourceNames)",
    "source_code": "\tpublic void load(Class<?> relativeClass, String... resourceNames) {\n\t\tResource[] resources = new Resource[resourceNames.length];\n\t\tfor (int i = 0; i < resourceNames.length; i++) {\n\t\t\tresources[i] = new ClassPathResource(resourceNames[i], relativeClass);\n\t\t}\n\t\tload(resources);\n\t}"
  },
  "org.springframework.context.support.GenericGroovyApplicationContext#load(resourceLocations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Load bean definitions from the given Groovy scripts or XML files.\n\t * <p>Note that \".xml\" files will be parsed as XML content; all other kinds\n\t * of resources will be parsed as Groovy scripts.\n\t * @param resourceLocations one or more resource locations to load from\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resourceLocations"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "void",
    "signature": "public void load(String... resourceLocations)",
    "source_code": "\tpublic void load(String... resourceLocations) {\n\t\tthis.reader.loadBeanDefinitions(resourceLocations);\n\t}"
  },
  "org.springframework.context.support.GenericGroovyApplicationContext#load(resources)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Load bean definitions from the given Groovy scripts or XML files.\n\t * <p>Note that \".xml\" files will be parsed as XML content; all other kinds\n\t * of resources will be parsed as Groovy scripts.\n\t * @param resources one or more resources to load from\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resources"
    ],
    "position": {
      "column": 1,
      "line": 195
    },
    "return": "void",
    "signature": "public void load(Resource... resources)",
    "source_code": "\tpublic void load(Resource... resources) {\n\t\tthis.reader.loadBeanDefinitions(resources);\n\t}"
  },
  "org.springframework.context.support.GenericGroovyApplicationContext#setEnvironment(environment)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates the given environment to underlying {@link GroovyBeanDefinitionReader}.\n\t * Should be called before any call to {@code #load}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "environment"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "void",
    "signature": "public void setEnvironment(ConfigurableEnvironment environment)",
    "source_code": "\tpublic void setEnvironment(ConfigurableEnvironment environment) {\n\t\tsuper.setEnvironment(environment);\n\t\tthis.reader.setEnvironment(getEnvironment());\n\t}"
  },
  "org.springframework.context.support.GenericGroovyApplicationContext#setMetaClass(metaClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "metaClass"
    ],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "void",
    "signature": "public void setMetaClass(MetaClass metaClass)",
    "source_code": "\tpublic void setMetaClass(MetaClass metaClass) {\n\t\tthis.metaClass = metaClass;\n\t}"
  },
  "org.springframework.context.support.GenericGroovyApplicationContext#setProperty(property,newValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "property",
      "newValue"
    ],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "void",
    "signature": "public void setProperty(String property, Object newValue)",
    "source_code": "\tpublic void setProperty(String property, Object newValue) {\n\t\tif (newValue instanceof BeanDefinition beanDefinition) {\n\t\t\tregisterBeanDefinition(property, beanDefinition);\n\t\t}\n\t\telse {\n\t\t\tthis.metaClass.setProperty(this, property, newValue);\n\t\t}\n\t}"
  },
  "org.springframework.context.support.PropertiesHolder": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * PropertiesHolder for caching.\n\t * Stores the last-modified timestamp of the source file for efficient\n\t * change detection, and the timestamp of the last refresh attempt\n\t * (updated every time the cache entry gets re-validated).\n\t */",
    "kind": "class",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 555
    },
    "signature": "protected class PropertiesHolder",
    "source_code": "\tprotected class PropertiesHolder {\n\n\t\t@Nullable\n\t\tprivate final Properties properties;\n\n\t\tprivate final long fileTimestamp;\n\n\t\tprivate volatile long refreshTimestamp = -2;\n\n\t\tprivate final ReentrantLock refreshLock = new ReentrantLock();\n\n\t\t/** Cache to hold already generated MessageFormats per message code. */\n\t\tprivate final ConcurrentMap<String, Map<Locale, MessageFormat>> cachedMessageFormats =\n\t\t\t\tnew ConcurrentHashMap<>();\n\n\t\tpublic PropertiesHolder() {\n\t\t\tthis.properties = null;\n\t\t\tthis.fileTimestamp = -1;\n\t\t}\n\n\t\tpublic PropertiesHolder(Properties properties, long fileTimestamp) {\n\t\t\tthis.properties = properties;\n\t\t\tthis.fileTimestamp = fileTimestamp;\n\t\t}\n\n\t\t@Nullable\n\t\tpublic Properties getProperties() {\n\t\t\treturn this.properties;\n\t\t}\n\n\t\tpublic long getFileTimestamp() {\n\t\t\treturn this.fileTimestamp;\n\t\t}\n\n\t\tpublic void setRefreshTimestamp(long refreshTimestamp) {\n\t\t\tthis.refreshTimestamp = refreshTimestamp;\n\t\t}\n\n\t\tpublic long getRefreshTimestamp() {\n\t\t\treturn this.refreshTimestamp;\n\t\t}\n\n\t\t@Nullable\n\t\tpublic String getProperty(String code) {\n\t\t\tif (this.properties == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn this.properties.getProperty(code);\n\t\t}\n\n\t\t@Nullable\n\t\tpublic MessageFormat getMessageFormat(String code, Locale locale) {\n\t\t\tif (this.properties == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tMap<Locale, MessageFormat> localeMap = this.cachedMessageFormats.get(code);\n\t\t\tif (localeMap != null) {\n\t\t\t\tMessageFormat result = localeMap.get(locale);\n\t\t\t\tif (result != null) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\tString msg = this.properties.getProperty(code);\n\t\t\tif (msg != null) {\n\t\t\t\tif (localeMap == null) {\n\t\t\t\t\tlocaleMap = new ConcurrentHashMap<>();\n\t\t\t\t\tMap<Locale, MessageFormat> existing = this.cachedMessageFormats.putIfAbsent(code, localeMap);\n\t\t\t\t\tif (existing != null) {\n\t\t\t\t\t\tlocaleMap = existing;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tMessageFormat result = createMessageFormat(msg, locale);\n\t\t\t\tlocaleMap.put(locale, result);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.context.support.ReloadableResourceBundleMessageSource": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Spring-specific {@link org.springframework.context.MessageSource} implementation\n * that accesses resource bundles using specified basenames, participating in the\n * Spring {@link org.springframework.context.ApplicationContext}'s resource loading.\n *\n * <p>In contrast to the JDK-based {@link ResourceBundleMessageSource}, this class uses\n * {@link java.util.Properties} instances as its custom data structure for messages,\n * loading them via a {@link org.springframework.util.PropertiesPersister} strategy\n * from Spring {@link Resource} handles. This strategy is not only capable of\n * reloading files based on timestamp changes, but also of loading properties files\n * with a specific character encoding. It will detect XML property files as well.\n *\n * <p>Note that the basenames set as {@link #setBasenames \"basenames\"} property\n * are treated in a slightly different fashion than the \"basenames\" property of\n * {@link ResourceBundleMessageSource}. It follows the basic ResourceBundle rule of not\n * specifying file extension or language codes, but can refer to any Spring resource\n * location (instead of being restricted to classpath resources). With a \"classpath:\"\n * prefix, resources can still be loaded from the classpath, but \"cacheSeconds\" values\n * other than \"-1\" (caching forever) might not work reliably in this case.\n *\n * <p>For a typical web application, message files could be placed in {@code WEB-INF}:\n * e.g. a \"WEB-INF/messages\" basename would find a \"WEB-INF/messages.properties\",\n * \"WEB-INF/messages_en.properties\" etc arrangement as well as \"WEB-INF/messages.xml\",\n * \"WEB-INF/messages_en.xml\" etc. Note that message definitions in a <i>previous</i>\n * resource bundle will override ones in a later bundle, due to sequential lookup.\n\n * <p>This MessageSource can easily be used outside an\n * {@link org.springframework.context.ApplicationContext}: it will use a\n * {@link org.springframework.core.io.DefaultResourceLoader} as default,\n * simply getting overridden with the ApplicationContext's resource loader\n * if running in a context. It does not have any other specific dependencies.\n *\n * <p>Thanks to Thomas Achleitner for providing the initial implementation of\n * this message source!\n *\n * @author Juergen Hoeller\n * @see #setCacheSeconds\n * @see #setBasenames\n * @see #setDefaultEncoding\n * @see #setFileEncodings\n * @see #setPropertiesPersister\n * @see #setResourceLoader\n * @see org.springframework.core.io.DefaultResourceLoader\n * @see ResourceBundleMessageSource\n * @see java.util.ResourceBundle\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "signature": "public class ReloadableResourceBundleMessageSource",
    "source_code": "public class ReloadableResourceBundleMessageSource extends AbstractResourceBasedMessageSource"
  },
  "org.springframework.context.support.ReloadableResourceBundleMessageSource#calculateAllFilenames(basename,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Calculate all filenames for the given bundle basename and Locale.\n\t * Will calculate filenames for the given Locale, the system Locale\n\t * (if applicable), and the default file.\n\t * @param basename the basename of the bundle\n\t * @param locale the locale\n\t * @return the List of filenames to check\n\t * @see #setFallbackToSystemLocale\n\t * @see #calculateFilenamesForLocale\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "basename",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 275
    },
    "return": "List<String>",
    "signature": "protected List<String> calculateAllFilenames(String basename, Locale locale)",
    "source_code": "\tprotected List<String> calculateAllFilenames(String basename, Locale locale) {\n\t\tMap<Locale, List<String>> localeMap = this.cachedFilenames.get(basename);\n\t\tif (localeMap != null) {\n\t\t\tList<String> filenames = localeMap.get(locale);\n\t\t\tif (filenames != null) {\n\t\t\t\treturn filenames;\n\t\t\t}\n\t\t}\n\n\t\t// Filenames for given Locale\n\t\tList<String> filenames = new ArrayList<>(7);\n\t\tfilenames.addAll(calculateFilenamesForLocale(basename, locale));\n\n\t\t// Filenames for default Locale, if any\n\t\tLocale defaultLocale = getDefaultLocale();\n\t\tif (defaultLocale != null && !defaultLocale.equals(locale)) {\n\t\t\tList<String> fallbackFilenames = calculateFilenamesForLocale(basename, defaultLocale);\n\t\t\tfor (String fallbackFilename : fallbackFilenames) {\n\t\t\t\tif (!filenames.contains(fallbackFilename)) {\n\t\t\t\t\t// Entry for fallback locale that isn't already in filenames list.\n\t\t\t\t\tfilenames.add(fallbackFilename);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Filename for default bundle file\n\t\tfilenames.add(basename);\n\n\t\tif (localeMap == null) {\n\t\t\tlocaleMap = new ConcurrentHashMap<>();\n\t\t\tMap<Locale, List<String>> existing = this.cachedFilenames.putIfAbsent(basename, localeMap);\n\t\t\tif (existing != null) {\n\t\t\t\tlocaleMap = existing;\n\t\t\t}\n\t\t}\n\t\tlocaleMap.put(locale, filenames);\n\t\treturn filenames;\n\t}"
  },
  "org.springframework.context.support.ReloadableResourceBundleMessageSource#calculateFilenamesForLocale(basename,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Calculate the filenames for the given bundle basename and Locale,\n\t * appending language code, country code, and variant code.\n\t * <p>For example, basename \"messages\", Locale \"de_AT_oo\" &rarr; \"messages_de_AT_OO\",\n\t * \"messages_de_AT\", \"messages_de\".\n\t * <p>Follows the rules defined by {@link java.util.Locale#toString()}.\n\t * @param basename the basename of the bundle\n\t * @param locale the locale\n\t * @return the List of filenames to check\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "basename",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 324
    },
    "return": "List<String>",
    "signature": "protected List<String> calculateFilenamesForLocale(String basename, Locale locale)",
    "source_code": "\tprotected List<String> calculateFilenamesForLocale(String basename, Locale locale) {\n\t\tList<String> result = new ArrayList<>(3);\n\t\tString language = locale.getLanguage();\n\t\tString country = locale.getCountry();\n\t\tString variant = locale.getVariant();\n\t\tStringBuilder temp = new StringBuilder(basename);\n\n\t\ttemp.append('_');\n\t\tif (language.length() > 0) {\n\t\t\ttemp.append(language);\n\t\t\tresult.add(0, temp.toString());\n\t\t}\n\n\t\ttemp.append('_');\n\t\tif (country.length() > 0) {\n\t\t\ttemp.append(country);\n\t\t\tresult.add(0, temp.toString());\n\t\t}\n\n\t\tif (variant.length() > 0 && (language.length() > 0 || country.length() > 0)) {\n\t\t\ttemp.append('_').append(variant);\n\t\t\tresult.add(0, temp.toString());\n\t\t}\n\n\t\treturn result;\n\t}"
  },
  "org.springframework.context.support.ReloadableResourceBundleMessageSource#clearCache()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Clear the resource bundle cache.\n\t * Subsequent resolve calls will lead to reloading of the properties files.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 525
    },
    "return": "void",
    "signature": "public void clearCache()",
    "source_code": "\tpublic void clearCache() {\n\t\tlogger.debug(\"Clearing entire resource bundle cache\");\n\t\tthis.cachedProperties.clear();\n\t\tthis.cachedMergedProperties.clear();\n\t}"
  },
  "org.springframework.context.support.ReloadableResourceBundleMessageSource#clearCacheIncludingAncestors()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Clear the resource bundle caches of this MessageSource and all its ancestors.\n\t * @see #clearCache\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 535
    },
    "return": "void",
    "signature": "public void clearCacheIncludingAncestors()",
    "source_code": "\tpublic void clearCacheIncludingAncestors() {\n\t\tclearCache();\n\t\tif (getParentMessageSource() instanceof ReloadableResourceBundleMessageSource reloadableMsgSrc) {\n\t\t\treloadableMsgSrc.clearCacheIncludingAncestors();\n\t\t}\n\t}"
  },
  "org.springframework.context.support.ReloadableResourceBundleMessageSource#getFileTimestamp()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 585
    },
    "return": "long",
    "signature": "public long getFileTimestamp()",
    "source_code": "\t\tpublic long getFileTimestamp() {\n\t\t\treturn this.fileTimestamp;\n\t\t}"
  },
  "org.springframework.context.support.ReloadableResourceBundleMessageSource#getMergedProperties(locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get a PropertiesHolder that contains the actually visible properties\n\t * for a Locale, after merging all specified resource bundles.\n\t * Either fetches the holder from the cache or freshly loads it.\n\t * <p>Only used when caching resource bundle contents forever, i.e.\n\t * with cacheSeconds &lt; 0. Therefore, merged properties are always\n\t * cached forever.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 234
    },
    "return": "PropertiesHolder",
    "signature": "protected PropertiesHolder getMergedProperties(Locale locale)",
    "source_code": "\tprotected PropertiesHolder getMergedProperties(Locale locale) {\n\t\tPropertiesHolder mergedHolder = this.cachedMergedProperties.get(locale);\n\t\tif (mergedHolder != null) {\n\t\t\treturn mergedHolder;\n\t\t}\n\n\t\tProperties mergedProps = newProperties();\n\t\tlong latestTimestamp = -1;\n\t\tString[] basenames = StringUtils.toStringArray(getBasenameSet());\n\t\tfor (int i = basenames.length - 1; i >= 0; i--) {\n\t\t\tList<String> filenames = calculateAllFilenames(basenames[i], locale);\n\t\t\tfor (int j = filenames.size() - 1; j >= 0; j--) {\n\t\t\t\tString filename = filenames.get(j);\n\t\t\t\tPropertiesHolder propHolder = getProperties(filename);\n\t\t\t\tif (propHolder.getProperties() != null) {\n\t\t\t\t\tmergedProps.putAll(propHolder.getProperties());\n\t\t\t\t\tif (propHolder.getFileTimestamp() > latestTimestamp) {\n\t\t\t\t\t\tlatestTimestamp = propHolder.getFileTimestamp();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmergedHolder = new PropertiesHolder(mergedProps, latestTimestamp);\n\t\tPropertiesHolder existing = this.cachedMergedProperties.putIfAbsent(locale, mergedHolder);\n\t\tif (existing != null) {\n\t\t\tmergedHolder = existing;\n\t\t}\n\t\treturn mergedHolder;\n\t}"
  },
  "org.springframework.context.support.ReloadableResourceBundleMessageSource#getMessageFormat(code,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 606
    },
    "return": "MessageFormat",
    "signature": "public MessageFormat getMessageFormat(String code, Locale locale)",
    "source_code": "\t\tpublic MessageFormat getMessageFormat(String code, Locale locale) {\n\t\t\tif (this.properties == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tMap<Locale, MessageFormat> localeMap = this.cachedMessageFormats.get(code);\n\t\t\tif (localeMap != null) {\n\t\t\t\tMessageFormat result = localeMap.get(locale);\n\t\t\t\tif (result != null) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\tString msg = this.properties.getProperty(code);\n\t\t\tif (msg != null) {\n\t\t\t\tif (localeMap == null) {\n\t\t\t\t\tlocaleMap = new ConcurrentHashMap<>();\n\t\t\t\t\tMap<Locale, MessageFormat> existing = this.cachedMessageFormats.putIfAbsent(code, localeMap);\n\t\t\t\t\tif (existing != null) {\n\t\t\t\t\t\tlocaleMap = existing;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tMessageFormat result = createMessageFormat(msg, locale);\n\t\t\t\tlocaleMap.put(locale, result);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.context.support.ReloadableResourceBundleMessageSource#getProperties()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 581
    },
    "return": "Properties",
    "signature": "public Properties getProperties()",
    "source_code": "\t\tpublic Properties getProperties() {\n\t\t\treturn this.properties;\n\t\t}"
  },
  "org.springframework.context.support.ReloadableResourceBundleMessageSource#getProperties(filename)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get a PropertiesHolder for the given filename, either from the\n\t * cache or freshly loaded.\n\t * @param filename the bundle filename (basename + Locale)\n\t * @return the current PropertiesHolder for the bundle\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "filename"
    ],
    "position": {
      "column": 1,
      "line": 358
    },
    "return": "PropertiesHolder",
    "signature": "protected PropertiesHolder getProperties(String filename)",
    "source_code": "\tprotected PropertiesHolder getProperties(String filename) {\n\t\tPropertiesHolder propHolder = this.cachedProperties.get(filename);\n\t\tlong originalTimestamp = -2;\n\n\t\tif (propHolder != null) {\n\t\t\toriginalTimestamp = propHolder.getRefreshTimestamp();\n\t\t\tif (originalTimestamp == -1 || originalTimestamp > System.currentTimeMillis() - getCacheMillis()) {\n\t\t\t\t// Up to date\n\t\t\t\treturn propHolder;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpropHolder = new PropertiesHolder();\n\t\t\tPropertiesHolder existingHolder = this.cachedProperties.putIfAbsent(filename, propHolder);\n\t\t\tif (existingHolder != null) {\n\t\t\t\tpropHolder = existingHolder;\n\t\t\t}\n\t\t}\n\n\t\t// At this point, we need to refresh...\n\t\tif (this.concurrentRefresh && propHolder.getRefreshTimestamp() >= 0) {\n\t\t\t// A populated but stale holder -> could keep using it.\n\t\t\tif (!propHolder.refreshLock.tryLock()) {\n\t\t\t\t// Getting refreshed by another thread already ->\n\t\t\t\t// let's return the existing properties for the time being.\n\t\t\t\treturn propHolder;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpropHolder.refreshLock.lock();\n\t\t}\n\t\ttry {\n\t\t\tPropertiesHolder existingHolder = this.cachedProperties.get(filename);\n\t\t\tif (existingHolder != null && existingHolder.getRefreshTimestamp() > originalTimestamp) {\n\t\t\t\treturn existingHolder;\n\t\t\t}\n\t\t\treturn refreshProperties(filename, propHolder);\n\t\t}\n\t\tfinally {\n\t\t\tpropHolder.refreshLock.unlock();\n\t\t}\n\t}"
  },
  "org.springframework.context.support.ReloadableResourceBundleMessageSource#getProperty(code)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code"
    ],
    "position": {
      "column": 1,
      "line": 598
    },
    "return": "String",
    "signature": "public String getProperty(String code)",
    "source_code": "\t\tpublic String getProperty(String code) {\n\t\t\tif (this.properties == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn this.properties.getProperty(code);\n\t\t}"
  },
  "org.springframework.context.support.ReloadableResourceBundleMessageSource#getRefreshTimestamp()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 593
    },
    "return": "long",
    "signature": "public long getRefreshTimestamp()",
    "source_code": "\t\tpublic long getRefreshTimestamp() {\n\t\t\treturn this.refreshTimestamp;\n\t\t}"
  },
  "org.springframework.context.support.ReloadableResourceBundleMessageSource#loadProperties(resource,filename)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Load the properties from the given resource.\n\t * @param resource the resource to load from\n\t * @param filename the original bundle filename (basename + Locale)\n\t * @return the populated Properties instance\n\t * @throws IOException if properties loading failed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resource",
      "filename"
    ],
    "position": {
      "column": 1,
      "line": 472
    },
    "return": "Properties",
    "signature": "protected Properties loadProperties(Resource resource, String filename)",
    "source_code": "\tprotected Properties loadProperties(Resource resource, String filename) throws IOException {\n\t\tProperties props = newProperties();\n\t\ttry (InputStream is = resource.getInputStream()) {\n\t\t\tString resourceFilename = resource.getFilename();\n\t\t\tif (resourceFilename != null && resourceFilename.endsWith(XML_SUFFIX)) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Loading properties [\" + resource.getFilename() + \"]\");\n\t\t\t\t}\n\t\t\t\tthis.propertiesPersister.loadFromXml(props, is);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString encoding = null;\n\t\t\t\tif (this.fileEncodings != null) {\n\t\t\t\t\tencoding = this.fileEncodings.getProperty(filename);\n\t\t\t\t}\n\t\t\t\tif (encoding == null) {\n\t\t\t\t\tencoding = getDefaultEncoding();\n\t\t\t\t}\n\t\t\t\tif (encoding != null) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Loading properties [\" + resource.getFilename() + \"] with encoding '\" + encoding + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\tthis.propertiesPersister.load(props, new InputStreamReader(is, encoding));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Loading properties [\" + resource.getFilename() + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\tthis.propertiesPersister.load(props, is);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn props;\n\t\t}\n\t}"
  },
  "org.springframework.context.support.ReloadableResourceBundleMessageSource#newProperties()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Template method for creating a plain new {@link Properties} instance.\n\t * The default implementation simply calls {@link Properties#Properties()}.\n\t * <p>Allows for returning a custom {@link Properties} extension in subclasses.\n\t * Overriding methods should just instantiate a custom {@link Properties} subclass,\n\t * with no further initialization or population to be performed at that point.\n\t * @return a plain Properties instance\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 516
    },
    "return": "Properties",
    "signature": "protected Properties newProperties()",
    "source_code": "\tprotected Properties newProperties() {\n\t\treturn new Properties();\n\t}"
  },
  "org.springframework.context.support.ReloadableResourceBundleMessageSource#refreshProperties(filename,propHolder)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Refresh the PropertiesHolder for the given bundle filename.\n\t * The holder can be {@code null} if not cached before, or a timed-out cache entry\n\t * (potentially getting re-validated against the current last-modified timestamp).\n\t * @param filename the bundle filename (basename + Locale)\n\t * @param propHolder the current PropertiesHolder for the bundle\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "filename",
      "propHolder"
    ],
    "position": {
      "column": 1,
      "line": 408
    },
    "return": "PropertiesHolder",
    "signature": "protected PropertiesHolder refreshProperties(String filename, @Nullable PropertiesHolder propHolder)",
    "source_code": "\tprotected PropertiesHolder refreshProperties(String filename, @Nullable PropertiesHolder propHolder) {\n\t\tlong refreshTimestamp = (getCacheMillis() < 0 ? -1 : System.currentTimeMillis());\n\n\t\tResource resource = this.resourceLoader.getResource(filename + PROPERTIES_SUFFIX);\n\t\tif (!resource.exists()) {\n\t\t\tresource = this.resourceLoader.getResource(filename + XML_SUFFIX);\n\t\t}\n\n\t\tif (resource.exists()) {\n\t\t\tlong fileTimestamp = -1;\n\t\t\tif (getCacheMillis() >= 0) {\n\t\t\t\t// Last-modified timestamp of file will just be read if caching with timeout.\n\t\t\t\ttry {\n\t\t\t\t\tfileTimestamp = resource.lastModified();\n\t\t\t\t\tif (propHolder != null && propHolder.getFileTimestamp() == fileTimestamp) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Re-caching properties for filename [\" + filename + \"] - file hasn't been modified\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpropHolder.setRefreshTimestamp(refreshTimestamp);\n\t\t\t\t\t\treturn propHolder;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\t// Probably a class path resource: cache it forever.\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(resource + \" could not be resolved in the file system - assuming that it hasn't changed\", ex);\n\t\t\t\t\t}\n\t\t\t\t\tfileTimestamp = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tProperties props = loadProperties(resource, filename);\n\t\t\t\tpropHolder = new PropertiesHolder(props, fileTimestamp);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\tlogger.warn(\"Could not parse properties file [\" + resource.getFilename() + \"]\", ex);\n\t\t\t\t}\n\t\t\t\t// Empty holder representing \"not valid\".\n\t\t\t\tpropHolder = new PropertiesHolder();\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\t// Resource does not exist.\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"No properties file found for [\" + filename + \"] - neither plain properties nor XML\");\n\t\t\t}\n\t\t\t// Empty holder representing \"not found\".\n\t\t\tpropHolder = new PropertiesHolder();\n\t\t}\n\n\t\tpropHolder.setRefreshTimestamp(refreshTimestamp);\n\t\tthis.cachedProperties.put(filename, propHolder);\n\t\treturn propHolder;\n\t}"
  },
  "org.springframework.context.support.ReloadableResourceBundleMessageSource#resolveCode(code,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolves the given message code as key in the retrieved bundle files,\n\t * using a cached MessageFormat instance per message code.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "code",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "MessageFormat",
    "signature": "protected MessageFormat resolveCode(String code, Locale locale)",
    "source_code": "\tprotected MessageFormat resolveCode(String code, Locale locale) {\n\t\tif (getCacheMillis() < 0) {\n\t\t\tPropertiesHolder propHolder = getMergedProperties(locale);\n\t\t\tMessageFormat result = propHolder.getMessageFormat(code, locale);\n\t\t\tif (result != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (String basename : getBasenameSet()) {\n\t\t\t\tList<String> filenames = calculateAllFilenames(basename, locale);\n\t\t\t\tfor (String filename : filenames) {\n\t\t\t\t\tPropertiesHolder propHolder = getProperties(filename);\n\t\t\t\t\tMessageFormat result = propHolder.getMessageFormat(code, locale);\n\t\t\t\t\tif (result != null) {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.context.support.ReloadableResourceBundleMessageSource#resolveCodeWithoutArguments(code,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolves the given message code as key in the retrieved bundle files,\n\t * returning the value found in the bundle as-is (without MessageFormat parsing).\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "code",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "String",
    "signature": "protected String resolveCodeWithoutArguments(String code, Locale locale)",
    "source_code": "\tprotected String resolveCodeWithoutArguments(String code, Locale locale) {\n\t\tif (getCacheMillis() < 0) {\n\t\t\tPropertiesHolder propHolder = getMergedProperties(locale);\n\t\t\tString result = propHolder.getProperty(code);\n\t\t\tif (result != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (String basename : getBasenameSet()) {\n\t\t\t\tList<String> filenames = calculateAllFilenames(basename, locale);\n\t\t\t\tfor (String filename : filenames) {\n\t\t\t\t\tPropertiesHolder propHolder = getProperties(filename);\n\t\t\t\t\tString result = propHolder.getProperty(code);\n\t\t\t\t\tif (result != null) {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.context.support.ReloadableResourceBundleMessageSource#setConcurrentRefresh(concurrentRefresh)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether to allow for concurrent refresh behavior, i.e. one thread\n\t * locked in a refresh attempt for a specific cached properties file whereas\n\t * other threads keep returning the old properties for the time being, until\n\t * the refresh attempt has completed.\n\t * <p>Default is \"true\": this behavior is new as of Spring Framework 4.1,\n\t * minimizing contention between threads. If you prefer the old behavior,\n\t * i.e. to fully block on refresh, switch this flag to \"false\".\n\t * @since 4.1\n\t * @see #setCacheSeconds\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "concurrentRefresh"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "void",
    "signature": "public void setConcurrentRefresh(boolean concurrentRefresh)",
    "source_code": "\tpublic void setConcurrentRefresh(boolean concurrentRefresh) {\n\t\tthis.concurrentRefresh = concurrentRefresh;\n\t}"
  },
  "org.springframework.context.support.ReloadableResourceBundleMessageSource#setFileEncodings(fileEncodings)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set per-file charsets to use for parsing properties files.\n\t * <p>Only applies to classic properties files, not to XML files.\n\t * @param fileEncodings a Properties with filenames as keys and charset\n\t * names as values. Filenames have to match the basename syntax,\n\t * with optional locale-specific components: e.g. \"WEB-INF/messages\"\n\t * or \"WEB-INF/messages_en\".\n\t * @see #setBasenames\n\t * @see org.springframework.util.PropertiesPersister#load\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fileEncodings"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "void",
    "signature": "public void setFileEncodings(Properties fileEncodings)",
    "source_code": "\tpublic void setFileEncodings(Properties fileEncodings) {\n\t\tthis.fileEncodings = fileEncodings;\n\t}"
  },
  "org.springframework.context.support.ReloadableResourceBundleMessageSource#setPropertiesPersister(propertiesPersister)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the PropertiesPersister to use for parsing properties files.\n\t * <p>The default is {@code DefaultPropertiesPersister}.\n\t * @see DefaultPropertiesPersister#INSTANCE\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertiesPersister"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "public void setPropertiesPersister(@Nullable PropertiesPersister propertiesPersister)",
    "source_code": "\tpublic void setPropertiesPersister(@Nullable PropertiesPersister propertiesPersister) {\n\t\tthis.propertiesPersister =\n\t\t\t\t(propertiesPersister != null ? propertiesPersister : DefaultPropertiesPersister.INSTANCE);\n\t}"
  },
  "org.springframework.context.support.ReloadableResourceBundleMessageSource#setRefreshTimestamp(refreshTimestamp)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "refreshTimestamp"
    ],
    "position": {
      "column": 1,
      "line": 589
    },
    "return": "void",
    "signature": "public void setRefreshTimestamp(long refreshTimestamp)",
    "source_code": "\t\tpublic void setRefreshTimestamp(long refreshTimestamp) {\n\t\t\tthis.refreshTimestamp = refreshTimestamp;\n\t\t}"
  },
  "org.springframework.context.support.ReloadableResourceBundleMessageSource#setResourceLoader(resourceLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the ResourceLoader to use for loading bundle properties files.\n\t * <p>The default is a DefaultResourceLoader. Will get overridden by the\n\t * ApplicationContext if running in a context, as it implements the\n\t * ResourceLoaderAware interface. Can be manually overridden when\n\t * running outside an ApplicationContext.\n\t * @see org.springframework.core.io.DefaultResourceLoader\n\t * @see org.springframework.context.ResourceLoaderAware\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resourceLoader"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "void",
    "signature": "public void setResourceLoader(@Nullable ResourceLoader resourceLoader)",
    "source_code": "\tpublic void setResourceLoader(@Nullable ResourceLoader resourceLoader) {\n\t\tthis.resourceLoader = (resourceLoader != null ? resourceLoader : new DefaultResourceLoader());\n\t}"
  },
  "org.springframework.context.support.ReloadableResourceBundleMessageSource#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 544
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn getClass().getName() + \": basenames=\" + getBasenameSet();\n\t}"
  },
  "org.springframework.http.client.reactive.HttpComponentsClientHttpConnector": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link ClientHttpConnector} implementation for the Apache HttpComponents HttpClient 5.x.\n *\n * @author Martin Tarj\u00e1nyi\n * @author Arjen Poutsma\n * @since 5.3\n * @see <a href=\"https://hc.apache.org/index.html\">Apache HttpComponents</a>\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "signature": "public class HttpComponentsClientHttpConnector",
    "source_code": "public class HttpComponentsClientHttpConnector implements ClientHttpConnector, Closeable {\n\n\tprivate final CloseableHttpAsyncClient client;\n\n\tprivate final BiFunction<HttpMethod, URI, ? extends HttpClientContext> contextProvider;\n\n\tprivate DataBufferFactory dataBufferFactory = DefaultDataBufferFactory.sharedInstance;\n\n\n\t/**\n\t * Default constructor that creates and starts a new instance of {@link CloseableHttpAsyncClient}.\n\t */\n\tpublic HttpComponentsClientHttpConnector() {\n\t\tthis(HttpAsyncClients.createDefault());\n\t}\n\n\t/**\n\t * Constructor with a pre-configured {@link CloseableHttpAsyncClient} instance.\n\t * @param client the client to use\n\t */\n\tpublic HttpComponentsClientHttpConnector(CloseableHttpAsyncClient client) {\n\t\tthis(client, (method, uri) -> HttpClientContext.create());\n\t}\n\n\t/**\n\t * Constructor with a pre-configured {@link CloseableHttpAsyncClient} instance\n\t * and a {@link HttpClientContext} supplier lambda which is called before each request\n\t * and passed to the client.\n\t * @param client the client to use\n\t * @param contextProvider a {@link HttpClientContext} supplier\n\t */\n\tpublic HttpComponentsClientHttpConnector(CloseableHttpAsyncClient client,\n\t\t\tBiFunction<HttpMethod, URI, ? extends HttpClientContext> contextProvider) {\n\n\t\tAssert.notNull(client, \"Client must not be null\");\n\t\tAssert.notNull(contextProvider, \"ContextProvider must not be null\");\n\n\t\tthis.contextProvider = contextProvider;\n\t\tthis.client = client;\n\t\tthis.client.start();\n\t}\n\n\n\t/**\n\t * Set the buffer factory to use.\n\t */\n\tpublic void setBufferFactory(DataBufferFactory bufferFactory) {\n\t\tthis.dataBufferFactory = bufferFactory;\n\t}\n\n\n\t@Override\n\tpublic Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,\n\t\t\tFunction<? super ClientHttpRequest, Mono<Void>> requestCallback) {\n\n\t\tHttpClientContext context = this.contextProvider.apply(method, uri);\n\n\t\tif (context.getCookieStore() == null) {\n\t\t\tcontext.setCookieStore(new BasicCookieStore());\n\t\t}\n\n\t\tHttpComponentsClientHttpRequest request = new HttpComponentsClientHttpRequest(method, uri,\n\t\t\t\tcontext, this.dataBufferFactory);\n\n\t\treturn requestCallback.apply(request).then(Mono.defer(() -> execute(request, context)));\n\t}\n\n\tprivate Mono<ClientHttpResponse> execute(HttpComponentsClientHttpRequest request, HttpClientContext context) {\n\t\tAsyncRequestProducer requestProducer = request.toRequestProducer();\n\n\t\treturn Mono.create(sink -> {\n\t\t\tReactiveResponseConsumer reactiveResponseConsumer =\n\t\t\t\t\tnew ReactiveResponseConsumer(new MonoFutureCallbackAdapter(sink, this.dataBufferFactory, context));\n\n\t\t\tthis.client.execute(requestProducer, reactiveResponseConsumer, context, null);\n\t\t});\n\t}\n\n\t@Override\n\tpublic void close() throws IOException {\n\t\tthis.client.close();\n\t}\n\n\tprivate static class MonoFutureCallbackAdapter\n\t\t\timplements FutureCallback<Message<HttpResponse, Publisher<ByteBuffer>>> {\n\n\t\tprivate final MonoSink<ClientHttpResponse> sink;\n\n\t\tprivate final DataBufferFactory dataBufferFactory;\n\n\t\tprivate final HttpClientContext context;\n\n\t\tpublic MonoFutureCallbackAdapter(MonoSink<ClientHttpResponse> sink,\n\t\t\t\tDataBufferFactory dataBufferFactory, HttpClientContext context) {\n\t\t\tthis.sink = sink;\n\t\t\tthis.dataBufferFactory = dataBufferFactory;\n\t\t\tthis.context = context;\n\t\t}\n\n\t\t@Override\n\t\tpublic void completed(Message<HttpResponse, Publisher<ByteBuffer>> result) {\n\t\t\tHttpComponentsClientHttpResponse response =\n\t\t\t\t\tnew HttpComponentsClientHttpResponse(this.dataBufferFactory, result, this.context);\n\t\t\tthis.sink.success(response);\n\t\t}\n\n\t\t@Override\n\t\tpublic void failed(Exception ex) {\n\t\t\tThrowable t = (ex instanceof HttpStreamResetException hsre ? hsre.getCause() : ex);\n\t\t\tthis.sink.error(t);\n\t\t}\n\n\t\t@Override\n\t\tpublic void cancelled() {\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.http.client.reactive.HttpComponentsClientHttpConnector#cancelled()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "void",
    "signature": "public void cancelled()",
    "source_code": "\t\tpublic void cancelled() {\n\t\t}"
  },
  "org.springframework.http.client.reactive.HttpComponentsClientHttpConnector#close()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\tpublic void close() throws IOException {\n\t\tthis.client.close();\n\t}"
  },
  "org.springframework.http.client.reactive.HttpComponentsClientHttpConnector#completed(Message<HttpResponse,result)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Message<HttpResponse",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "void",
    "signature": "public void completed(Message<HttpResponse, Publisher<ByteBuffer>> result)",
    "source_code": "\t\tpublic void completed(Message<HttpResponse, Publisher<ByteBuffer>> result) {\n\t\t\tHttpComponentsClientHttpResponse response =\n\t\t\t\t\tnew HttpComponentsClientHttpResponse(this.dataBufferFactory, result, this.context);\n\t\t\tthis.sink.success(response);\n\t\t}"
  },
  "org.springframework.http.client.reactive.HttpComponentsClientHttpConnector#connect(method,uri,ClientHttpRequest,requestCallback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "uri",
      "ClientHttpRequest",
      "requestCallback"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "Mono<ClientHttpResponse>",
    "signature": "public Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,\n\t\t\tFunction<? super ClientHttpRequest, Mono<Void>> requestCallback)",
    "source_code": "\tpublic Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,"
  },
  "org.springframework.http.client.reactive.HttpComponentsClientHttpConnector#failed(ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "void",
    "signature": "public void failed(Exception ex)",
    "source_code": "\t\tpublic void failed(Exception ex) {\n\t\t\tThrowable t = (ex instanceof HttpStreamResetException hsre ? hsre.getCause() : ex);\n\t\t\tthis.sink.error(t);\n\t\t}"
  },
  "org.springframework.http.client.reactive.HttpComponentsClientHttpConnector#setBufferFactory(bufferFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the buffer factory to use.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bufferFactory"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "void",
    "signature": "public void setBufferFactory(DataBufferFactory bufferFactory)",
    "source_code": "\tpublic void setBufferFactory(DataBufferFactory bufferFactory) {\n\t\tthis.dataBufferFactory = bufferFactory;\n\t}"
  },
  "org.springframework.http.client.reactive.JettyResourceFactory": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Factory to manage Jetty resources, i.e. {@link Executor}, {@link ByteBufferPool} and\n * {@link Scheduler}, within the lifecycle of a Spring {@code ApplicationContext}.\n *\n * <p>This factory implements {@link InitializingBean} and {@link DisposableBean}\n * and is expected typically to be declared as a Spring-managed bean.\n *\n * @author Sebastien Deleuze\n * @since 5.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "signature": "public class JettyResourceFactory",
    "source_code": "public class JettyResourceFactory implements InitializingBean, DisposableBean {\n\n\t@Nullable\n\tprivate Executor executor;\n\n\t@Nullable\n\tprivate ByteBufferPool byteBufferPool;\n\n\t@Nullable\n\tprivate Scheduler scheduler;\n\n\tprivate String threadPrefix = \"jetty-http\";\n\n\n\t/**\n\t * Configure the {@link Executor} to use.\n\t * <p>By default, initialized with a {@link QueuedThreadPool}.\n\t * @param executor the executor to use\n\t */\n\tpublic void setExecutor(@Nullable Executor executor) {\n\t\tthis.executor = executor;\n\t}\n\n\t/**\n\t * Configure the {@link ByteBufferPool} to use.\n\t * <p>By default, initialized with a {@link MappedByteBufferPool}.\n\t * @param byteBufferPool the {@link ByteBuffer} pool to use\n\t */\n\tpublic void setByteBufferPool(@Nullable ByteBufferPool byteBufferPool) {\n\t\tthis.byteBufferPool = byteBufferPool;\n\t}\n\n\t/**\n\t * Configure the {@link Scheduler} to use.\n\t * <p>By default, initialized with a {@link ScheduledExecutorScheduler}.\n\t * @param scheduler the {@link Scheduler} to use\n\t */\n\tpublic void setScheduler(@Nullable Scheduler scheduler) {\n\t\tthis.scheduler = scheduler;\n\t}\n\n\t/**\n\t * Configure the thread prefix to initialize {@link QueuedThreadPool} executor with. This\n\t * is used only when a {@link Executor} instance isn't\n\t * {@link #setExecutor(Executor) provided}.\n\t * <p>By default set to \"jetty-http\".\n\t * @param threadPrefix the thread prefix to use\n\t */\n\tpublic void setThreadPrefix(String threadPrefix) {\n\t\tAssert.notNull(threadPrefix, \"Thread prefix is required\");\n\t\tthis.threadPrefix = threadPrefix;\n\t}\n\n\t/**\n\t * Return the configured {@link Executor}.\n\t */\n\t@Nullable\n\tpublic Executor getExecutor() {\n\t\treturn this.executor;\n\t}\n\n\t/**\n\t * Return the configured {@link ByteBufferPool}.\n\t */\n\t@Nullable\n\tpublic ByteBufferPool getByteBufferPool() {\n\t\treturn this.byteBufferPool;\n\t}\n\n\t/**\n\t * Return the configured {@link Scheduler}.\n\t */\n\t@Nullable\n\tpublic Scheduler getScheduler() {\n\t\treturn this.scheduler;\n\t}\n\n\t@Override\n\tpublic void afterPropertiesSet() throws Exception {\n\t\tString name = this.threadPrefix + \"@\" + Integer.toHexString(hashCode());\n\t\tif (this.executor == null) {\n\t\t\tQueuedThreadPool threadPool = new QueuedThreadPool();\n\t\t\tthreadPool.setName(name);\n\t\t\tthis.executor = threadPool;\n\t\t}\n\t\tif (this.byteBufferPool == null) {\n\t\t\tthis.byteBufferPool = new MappedByteBufferPool(2048,\n\t\t\t\t\tthis.executor instanceof ThreadPool.SizedThreadPool sizedThreadPool ?\n\t\t\t\t\t\t\tsizedThreadPool.getMaxThreads() / 2 :\n\t\t\t\t\t\t\tProcessorUtils.availableProcessors() * 2);\n\t\t}\n\t\tif (this.scheduler == null) {\n\t\t\tthis.scheduler = new ScheduledExecutorScheduler(name + \"-scheduler\", false);\n\t\t}\n\n\t\tif (this.executor instanceof LifeCycle lifeCycle) {\n\t\t\tlifeCycle.start();\n\t\t}\n\t\tthis.scheduler.start();\n\t}\n\n\t@Override\n\tpublic void destroy() throws Exception {\n\t\ttry {\n\t\t\tif (this.executor instanceof LifeCycle lifeCycle) {\n\t\t\t\tlifeCycle.stop();\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\t// ignore\n\t\t}\n\t\ttry {\n\t\t\tif (this.scheduler != null) {\n\t\t\t\tthis.scheduler.stop();\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\t// ignore\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.http.client.reactive.JettyResourceFactory#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() throws Exception {\n\t\tString name = this.threadPrefix + \"@\" + Integer.toHexString(hashCode());\n\t\tif (this.executor == null) {\n\t\t\tQueuedThreadPool threadPool = new QueuedThreadPool();\n\t\t\tthreadPool.setName(name);\n\t\t\tthis.executor = threadPool;\n\t\t}\n\t\tif (this.byteBufferPool == null) {\n\t\t\tthis.byteBufferPool = new MappedByteBufferPool(2048,\n\t\t\t\t\tthis.executor instanceof ThreadPool.SizedThreadPool sizedThreadPool ?\n\t\t\t\t\t\t\tsizedThreadPool.getMaxThreads() / 2 :\n\t\t\t\t\t\t\tProcessorUtils.availableProcessors() * 2);\n\t\t}\n\t\tif (this.scheduler == null) {\n\t\t\tthis.scheduler = new ScheduledExecutorScheduler(name + \"-scheduler\", false);\n\t\t}\n\n\t\tif (this.executor instanceof LifeCycle lifeCycle) {\n\t\t\tlifeCycle.start();\n\t\t}\n\t\tthis.scheduler.start();\n\t}"
  },
  "org.springframework.http.client.reactive.JettyResourceFactory#destroy()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "void",
    "signature": "public void destroy()",
    "source_code": "\tpublic void destroy() throws Exception {\n\t\ttry {\n\t\t\tif (this.executor instanceof LifeCycle lifeCycle) {\n\t\t\t\tlifeCycle.stop();\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\t// ignore\n\t\t}\n\t\ttry {\n\t\t\tif (this.scheduler != null) {\n\t\t\t\tthis.scheduler.stop();\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\t// ignore\n\t\t}\n\t}"
  },
  "org.springframework.http.client.reactive.JettyResourceFactory#getByteBufferPool()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured {@link ByteBufferPool}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "ByteBufferPool",
    "signature": "public ByteBufferPool getByteBufferPool()",
    "source_code": "\tpublic ByteBufferPool getByteBufferPool() {\n\t\treturn this.byteBufferPool;\n\t}"
  },
  "org.springframework.http.client.reactive.JettyResourceFactory#getExecutor()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured {@link Executor}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "Executor",
    "signature": "public Executor getExecutor()",
    "source_code": "\tpublic Executor getExecutor() {\n\t\treturn this.executor;\n\t}"
  },
  "org.springframework.http.client.reactive.JettyResourceFactory#getScheduler()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured {@link Scheduler}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "Scheduler",
    "signature": "public Scheduler getScheduler()",
    "source_code": "\tpublic Scheduler getScheduler() {\n\t\treturn this.scheduler;\n\t}"
  },
  "org.springframework.http.client.reactive.JettyResourceFactory#setByteBufferPool(byteBufferPool)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@link ByteBufferPool} to use.\n\t * <p>By default, initialized with a {@link MappedByteBufferPool}.\n\t * @param byteBufferPool the {@link ByteBuffer} pool to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "byteBufferPool"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "void",
    "signature": "public void setByteBufferPool(@Nullable ByteBufferPool byteBufferPool)",
    "source_code": "\tpublic void setByteBufferPool(@Nullable ByteBufferPool byteBufferPool) {\n\t\tthis.byteBufferPool = byteBufferPool;\n\t}"
  },
  "org.springframework.http.client.reactive.JettyResourceFactory#setExecutor(executor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@link Executor} to use.\n\t * <p>By default, initialized with a {@link QueuedThreadPool}.\n\t * @param executor the executor to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "executor"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "void",
    "signature": "public void setExecutor(@Nullable Executor executor)",
    "source_code": "\tpublic void setExecutor(@Nullable Executor executor) {\n\t\tthis.executor = executor;\n\t}"
  },
  "org.springframework.http.client.reactive.JettyResourceFactory#setScheduler(scheduler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@link Scheduler} to use.\n\t * <p>By default, initialized with a {@link ScheduledExecutorScheduler}.\n\t * @param scheduler the {@link Scheduler} to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scheduler"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "void",
    "signature": "public void setScheduler(@Nullable Scheduler scheduler)",
    "source_code": "\tpublic void setScheduler(@Nullable Scheduler scheduler) {\n\t\tthis.scheduler = scheduler;\n\t}"
  },
  "org.springframework.http.client.reactive.JettyResourceFactory#setThreadPrefix(threadPrefix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the thread prefix to initialize {@link QueuedThreadPool} executor with. This\n\t * is used only when a {@link Executor} instance isn't\n\t * {@link #setExecutor(Executor) provided}.\n\t * <p>By default set to \"jetty-http\".\n\t * @param threadPrefix the thread prefix to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "threadPrefix"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "void",
    "signature": "public void setThreadPrefix(String threadPrefix)",
    "source_code": "\tpublic void setThreadPrefix(String threadPrefix) {\n\t\tAssert.notNull(threadPrefix, \"Thread prefix is required\");\n\t\tthis.threadPrefix = threadPrefix;\n\t}"
  },
  "org.springframework.http.codec.DecoderHttpMessageReader": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code HttpMessageReader} that wraps and delegates to a {@link Decoder}.\n *\n * <p>Also a {@code HttpMessageReader} that pre-resolves decoding hints\n * from the extra information available on the server side such as the request\n * or controller method parameter annotations.\n *\n * @author Arjen Poutsma\n * @author Sebastien Deleuze\n * @author Rossen Stoyanchev\n * @since 5.0\n * @param <T> the type of objects in the decoded output stream\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "signature": "public class DecoderHttpMessageReader",
    "source_code": "public class DecoderHttpMessageReader<T> implements HttpMessageReader<T> {\n\n\tprivate final Decoder<T> decoder;\n\n\tprivate final List<MediaType> mediaTypes;\n\n\n\t/**\n\t * Create an instance wrapping the given {@link Decoder}.\n\t */\n\tpublic DecoderHttpMessageReader(Decoder<T> decoder) {\n\t\tAssert.notNull(decoder, \"Decoder is required\");\n\t\tinitLogger(decoder);\n\t\tthis.decoder = decoder;\n\t\tthis.mediaTypes = MediaType.asMediaTypes(decoder.getDecodableMimeTypes());\n\t}\n\n\tprivate static void initLogger(Decoder<?> decoder) {\n\t\tif (decoder instanceof AbstractDecoder<?> abstractDecoder &&\n\t\t\t\tdecoder.getClass().getName().startsWith(\"org.springframework.core.codec\")) {\n\t\t\tLog logger = HttpLogging.forLog(abstractDecoder.getLogger());\n\t\t\tabstractDecoder.setLogger(logger);\n\t\t}\n\t}\n\n\n\t/**\n\t * Return the {@link Decoder} of this reader.\n\t */\n\tpublic Decoder<T> getDecoder() {\n\t\treturn this.decoder;\n\t}\n\n\t@Override\n\tpublic List<MediaType> getReadableMediaTypes() {\n\t\treturn this.mediaTypes;\n\t}\n\n\t@Override\n\tpublic List<MediaType> getReadableMediaTypes(ResolvableType elementType) {\n\t\treturn MediaType.asMediaTypes(this.decoder.getDecodableMimeTypes(elementType));\n\t}\n\n\t@Override\n\tpublic boolean canRead(ResolvableType elementType, @Nullable MediaType mediaType) {\n\t\treturn this.decoder.canDecode(elementType, mediaType);\n\t}\n\n\t@Override\n\tpublic Flux<T> read(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints) {\n\t\tMediaType contentType = getContentType(message);\n\t\tMap<String, Object> allHints = Hints.merge(hints, getReadHints(elementType, message));\n\t\treturn this.decoder.decode(message.getBody(), elementType, contentType, allHints);\n\t}\n\n\t@Override\n\tpublic Mono<T> readMono(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints) {\n\t\tMediaType contentType = getContentType(message);\n\t\tMap<String, Object> allHints = Hints.merge(hints, getReadHints(elementType, message));\n\t\treturn this.decoder.decodeToMono(message.getBody(), elementType, contentType, allHints);\n\t}\n\n\t/**\n\t * Determine the Content-Type of the HTTP message based on the\n\t * \"Content-Type\" header or otherwise default to\n\t * {@link MediaType#APPLICATION_OCTET_STREAM}.\n\t * @param inputMessage the HTTP message\n\t * @return the MediaType, possibly {@code null}.\n\t */\n\t@Nullable\n\tprotected MediaType getContentType(HttpMessage inputMessage) {\n\t\tMediaType contentType = inputMessage.getHeaders().getContentType();\n\t\treturn (contentType != null ? contentType : MediaType.APPLICATION_OCTET_STREAM);\n\t}\n\n\t/**\n\t * Get additional hints for decoding based on the input HTTP message.\n\t * @since 5.3\n\t */\n\tprotected Map<String, Object> getReadHints(ResolvableType elementType, ReactiveHttpInputMessage message) {\n\t\treturn Hints.none();\n\t}\n\n\n\t// Server-side only...\n\n\t@Override\n\tpublic Flux<T> read(ResolvableType actualType, ResolvableType elementType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response, Map<String, Object> hints) {\n\n\t\tMap<String, Object> allHints = Hints.merge(hints,\n\t\t\t\tgetReadHints(actualType, elementType, request, response));\n\n\t\treturn read(elementType, request, allHints);\n\t}\n\n\t@Override\n\tpublic Mono<T> readMono(ResolvableType actualType, ResolvableType elementType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response, Map<String, Object> hints) {\n\n\t\tMap<String, Object> allHints = Hints.merge(hints,\n\t\t\t\tgetReadHints(actualType, elementType, request, response));\n\n\t\treturn readMono(elementType, request, allHints);\n\t}\n\n\t/**\n\t * Get additional hints for decoding for example based on the server request\n\t * or annotations from controller method parameters. By default, delegate to\n\t * the decoder if it is an instance of {@link HttpMessageDecoder}.\n\t */\n\tprotected Map<String, Object> getReadHints(ResolvableType actualType,\n\t\t\tResolvableType elementType, ServerHttpRequest request, ServerHttpResponse response) {\n\n\t\tif (this.decoder instanceof HttpMessageDecoder<?> httpMessageDecoder) {\n\t\t\treturn httpMessageDecoder.getDecodeHints(actualType, elementType, request, response);\n\t\t}\n\t\treturn Hints.none();\n\t}\n\n}"
  },
  "org.springframework.http.codec.DecoderHttpMessageReader#canRead(elementType,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "boolean",
    "signature": "public boolean canRead(ResolvableType elementType, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canRead(ResolvableType elementType, @Nullable MediaType mediaType) {\n\t\treturn this.decoder.canDecode(elementType, mediaType);\n\t}"
  },
  "org.springframework.http.codec.DecoderHttpMessageReader#getContentType(inputMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the Content-Type of the HTTP message based on the\n\t * \"Content-Type\" header or otherwise default to\n\t * {@link MediaType#APPLICATION_OCTET_STREAM}.\n\t * @param inputMessage the HTTP message\n\t * @return the MediaType, possibly {@code null}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "MediaType",
    "signature": "protected MediaType getContentType(HttpMessage inputMessage)",
    "source_code": "\tprotected MediaType getContentType(HttpMessage inputMessage) {\n\t\tMediaType contentType = inputMessage.getHeaders().getContentType();\n\t\treturn (contentType != null ? contentType : MediaType.APPLICATION_OCTET_STREAM);\n\t}"
  },
  "org.springframework.http.codec.DecoderHttpMessageReader#getDecoder()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link Decoder} of this reader.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "Decoder<T>",
    "signature": "public Decoder<T> getDecoder()",
    "source_code": "\tpublic Decoder<T> getDecoder() {\n\t\treturn this.decoder;\n\t}"
  },
  "org.springframework.http.codec.DecoderHttpMessageReader#getReadHints(actualType,elementType,request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get additional hints for decoding for example based on the server request\n\t * or annotations from controller method parameters. By default, delegate to\n\t * the decoder if it is an instance of {@link HttpMessageDecoder}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "actualType",
      "elementType",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "Object>",
    "signature": "protected Object> getReadHints(ResolvableType actualType,\n\t\t\tResolvableType elementType, ServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tprotected Map<String, Object> getReadHints(ResolvableType actualType,"
  },
  "org.springframework.http.codec.DecoderHttpMessageReader#getReadHints(elementType,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get additional hints for decoding based on the input HTTP message.\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "elementType",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "Object>",
    "signature": "protected Object> getReadHints(ResolvableType elementType, ReactiveHttpInputMessage message)",
    "source_code": "\tprotected Map<String, Object> getReadHints(ResolvableType elementType, ReactiveHttpInputMessage message) {\n\t\treturn Hints.none();\n\t}"
  },
  "org.springframework.http.codec.DecoderHttpMessageReader#getReadableMediaTypes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "List<MediaType>",
    "signature": "public List<MediaType> getReadableMediaTypes()",
    "source_code": "\tpublic List<MediaType> getReadableMediaTypes() {\n\t\treturn this.mediaTypes;\n\t}"
  },
  "org.springframework.http.codec.DecoderHttpMessageReader#getReadableMediaTypes(elementType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "List<MediaType>",
    "signature": "public List<MediaType> getReadableMediaTypes(ResolvableType elementType)",
    "source_code": "\tpublic List<MediaType> getReadableMediaTypes(ResolvableType elementType) {\n\t\treturn MediaType.asMediaTypes(this.decoder.getDecodableMimeTypes(elementType));\n\t}"
  },
  "org.springframework.http.codec.DecoderHttpMessageReader#read(actualType,elementType,request,response,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "actualType",
      "elementType",
      "request",
      "response",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "Flux<T>",
    "signature": "public Flux<T> read(ResolvableType actualType, ResolvableType elementType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response, Map<String, Object> hints)",
    "source_code": "\tpublic Flux<T> read(ResolvableType actualType, ResolvableType elementType,"
  },
  "org.springframework.http.codec.DecoderHttpMessageReader#read(elementType,message,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "message",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "Flux<T>",
    "signature": "public Flux<T> read(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints)",
    "source_code": "\tpublic Flux<T> read(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints) {\n\t\tMediaType contentType = getContentType(message);\n\t\tMap<String, Object> allHints = Hints.merge(hints, getReadHints(elementType, message));\n\t\treturn this.decoder.decode(message.getBody(), elementType, contentType, allHints);\n\t}"
  },
  "org.springframework.http.codec.DecoderHttpMessageReader#readMono(actualType,elementType,request,response,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "actualType",
      "elementType",
      "request",
      "response",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> readMono(ResolvableType actualType, ResolvableType elementType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<T> readMono(ResolvableType actualType, ResolvableType elementType,"
  },
  "org.springframework.http.codec.DecoderHttpMessageReader#readMono(elementType,message,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "message",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> readMono(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<T> readMono(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints) {\n\t\tMediaType contentType = getContentType(message);\n\t\tMap<String, Object> allHints = Hints.merge(hints, getReadHints(elementType, message));\n\t\treturn this.decoder.decodeToMono(message.getBody(), elementType, contentType, allHints);\n\t}"
  },
  "org.springframework.http.codec.EncoderHttpMessageWriter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code HttpMessageWriter} that wraps and delegates to an {@link Encoder}.\n *\n * <p>Also a {@code HttpMessageWriter} that pre-resolves encoding hints\n * from the extra information available on the server side such as the request\n * or controller method annotations.\n *\n * @author Arjen Poutsma\n * @author Sebastien Deleuze\n * @author Rossen Stoyanchev\n * @author Brian Clozel\n * @author Sam Brannen\n * @since 5.0\n * @param <T> the type of objects in the input stream\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "signature": "public class EncoderHttpMessageWriter",
    "source_code": "public class EncoderHttpMessageWriter<T> implements HttpMessageWriter<T> {\n\n\tprivate static final Log logger = HttpLogging.forLogName(EncoderHttpMessageWriter.class);\n\n\n\tprivate final Encoder<T> encoder;\n\n\tprivate final List<MediaType> mediaTypes;\n\n\t@Nullable\n\tprivate final MediaType defaultMediaType;\n\n\n\t/**\n\t * Create an instance wrapping the given {@link Encoder}.\n\t */\n\tpublic EncoderHttpMessageWriter(Encoder<T> encoder) {\n\t\tAssert.notNull(encoder, \"Encoder is required\");\n\t\tinitLogger(encoder);\n\t\tthis.encoder = encoder;\n\t\tthis.mediaTypes = MediaType.asMediaTypes(encoder.getEncodableMimeTypes());\n\t\tthis.defaultMediaType = initDefaultMediaType(this.mediaTypes);\n\t}\n\n\tprivate static void initLogger(Encoder<?> encoder) {\n\t\tif (encoder instanceof AbstractEncoder<?> abstractEncoder &&\n\t\t\t\tencoder.getClass().getName().startsWith(\"org.springframework.core.codec\")) {\n\t\t\tLog logger = HttpLogging.forLog(abstractEncoder.getLogger());\n\t\t\tabstractEncoder.setLogger(logger);\n\t\t}\n\t}\n\n\t@Nullable\n\tprivate static MediaType initDefaultMediaType(List<MediaType> mediaTypes) {\n\t\treturn mediaTypes.stream().filter(MediaType::isConcrete).findFirst().orElse(null);\n\t}\n\n\n\t/**\n\t * Return the {@code Encoder} of this writer.\n\t */\n\tpublic Encoder<T> getEncoder() {\n\t\treturn this.encoder;\n\t}\n\n\t@Override\n\tpublic List<MediaType> getWritableMediaTypes() {\n\t\treturn this.mediaTypes;\n\t}\n\n\t@Override\n\tpublic List<MediaType> getWritableMediaTypes(ResolvableType elementType) {\n\t\treturn MediaType.asMediaTypes(getEncoder().getEncodableMimeTypes(elementType));\n\t}\n\n\t@Override\n\tpublic boolean canWrite(ResolvableType elementType, @Nullable MediaType mediaType) {\n\t\treturn this.encoder.canEncode(elementType, mediaType);\n\t}\n\n\t@Override\n\tpublic Mono<Void> write(Publisher<? extends T> inputStream, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ReactiveHttpOutputMessage message, Map<String, Object> hints) {\n\n\t\tMediaType contentType = updateContentType(message, mediaType);\n\n\t\tFlux<DataBuffer> body = this.encoder.encode(\n\t\t\t\tinputStream, message.bufferFactory(), elementType, contentType, hints);\n\n\t\tif (inputStream instanceof Mono) {\n\t\t\treturn body\n\t\t\t\t\t.singleOrEmpty()\n\t\t\t\t\t.switchIfEmpty(Mono.defer(() -> {\n\t\t\t\t\t\tmessage.getHeaders().setContentLength(0);\n\t\t\t\t\t\treturn message.setComplete().then(Mono.empty());\n\t\t\t\t\t}))\n\t\t\t\t\t.flatMap(buffer -> {\n\t\t\t\t\t\tHints.touchDataBuffer(buffer, hints, logger);\n\t\t\t\t\t\tmessage.getHeaders().setContentLength(buffer.readableByteCount());\n\t\t\t\t\t\treturn message.writeWith(Mono.just(buffer)\n\t\t\t\t\t\t\t\t.doOnDiscard(DataBuffer.class, DataBufferUtils::release));\n\t\t\t\t\t})\n\t\t\t\t\t.doOnDiscard(DataBuffer.class, DataBufferUtils::release);\n\t\t}\n\n\t\tif (isStreamingMediaType(contentType)) {\n\t\t\treturn message.writeAndFlushWith(body.map(buffer -> {\n\t\t\t\tHints.touchDataBuffer(buffer, hints, logger);\n\t\t\t\treturn Mono.just(buffer).doOnDiscard(DataBuffer.class, DataBufferUtils::release);\n\t\t\t}));\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tbody = body.doOnNext(buffer -> Hints.touchDataBuffer(buffer, hints, logger));\n\t\t}\n\t\treturn message.writeWith(body);\n\t}\n\n\t@Nullable\n\tprivate MediaType updateContentType(ReactiveHttpOutputMessage message, @Nullable MediaType mediaType) {\n\t\tMediaType result = message.getHeaders().getContentType();\n\t\tif (result != null) {\n\t\t\treturn result;\n\t\t}\n\t\tMediaType fallback = this.defaultMediaType;\n\t\tresult = (useFallback(mediaType, fallback) ? fallback : mediaType);\n\t\tif (result != null) {\n\t\t\tresult = addDefaultCharset(result, fallback);\n\t\t\tmessage.getHeaders().setContentType(result);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static boolean useFallback(@Nullable MediaType main, @Nullable MediaType fallback) {\n\t\treturn (main == null || !main.isConcrete() ||\n\t\t\t\tmain.equals(MediaType.APPLICATION_OCTET_STREAM) && fallback != null);\n\t}\n\n\tprivate static MediaType addDefaultCharset(MediaType main, @Nullable MediaType defaultType) {\n\t\tif (main.getCharset() == null && defaultType != null && defaultType.getCharset() != null) {\n\t\t\treturn new MediaType(main, defaultType.getCharset());\n\t\t}\n\t\treturn main;\n\t}\n\n\tprivate boolean isStreamingMediaType(@Nullable MediaType mediaType) {\n\t\tif (mediaType == null || !(this.encoder instanceof HttpMessageEncoder<?> httpMessageEncoder)) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (MediaType streamingMediaType : httpMessageEncoder.getStreamingMediaTypes()) {\n\t\t\tif (mediaType.isCompatibleWith(streamingMediaType) && matchParameters(mediaType, streamingMediaType)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean matchParameters(MediaType streamingMediaType, MediaType mediaType) {\n\t\tfor (String name : streamingMediaType.getParameters().keySet()) {\n\t\t\tString s1 = streamingMediaType.getParameter(name);\n\t\t\tString s2 = mediaType.getParameter(name);\n\t\t\tif (StringUtils.hasText(s1) && StringUtils.hasText(s2) && !s1.equalsIgnoreCase(s2)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\n\t// Server side only...\n\n\t@Override\n\tpublic Mono<Void> write(Publisher<? extends T> inputStream, ResolvableType actualType,\n\t\t\tResolvableType elementType, @Nullable MediaType mediaType, ServerHttpRequest request,\n\t\t\tServerHttpResponse response, Map<String, Object> hints) {\n\n\t\tMap<String, Object> allHints = Hints.merge(hints,\n\t\t\t\tgetWriteHints(actualType, elementType, mediaType, request, response));\n\n\t\treturn write(inputStream, elementType, mediaType, response, allHints);\n\t}\n\n\t/**\n\t * Get additional hints for encoding for example based on the server request\n\t * or annotations from controller method parameters. By default, delegate to\n\t * the encoder if it is an instance of {@link HttpMessageEncoder}.\n\t */\n\tprotected Map<String, Object> getWriteHints(ResolvableType streamType, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ServerHttpRequest request, ServerHttpResponse response) {\n\n\t\tif (this.encoder instanceof HttpMessageEncoder<?> httpMessageEncoder) {\n\t\t\treturn httpMessageEncoder.getEncodeHints(streamType, elementType, mediaType, request, response);\n\t\t}\n\t\treturn Hints.none();\n\t}\n\n}"
  },
  "org.springframework.http.codec.EncoderHttpMessageWriter#canWrite(elementType,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "boolean",
    "signature": "public boolean canWrite(ResolvableType elementType, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canWrite(ResolvableType elementType, @Nullable MediaType mediaType) {\n\t\treturn this.encoder.canEncode(elementType, mediaType);\n\t}"
  },
  "org.springframework.http.codec.EncoderHttpMessageWriter#getEncoder()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@code Encoder} of this writer.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "Encoder<T>",
    "signature": "public Encoder<T> getEncoder()",
    "source_code": "\tpublic Encoder<T> getEncoder() {\n\t\treturn this.encoder;\n\t}"
  },
  "org.springframework.http.codec.EncoderHttpMessageWriter#getWritableMediaTypes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "List<MediaType>",
    "signature": "public List<MediaType> getWritableMediaTypes()",
    "source_code": "\tpublic List<MediaType> getWritableMediaTypes() {\n\t\treturn this.mediaTypes;\n\t}"
  },
  "org.springframework.http.codec.EncoderHttpMessageWriter#getWritableMediaTypes(elementType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "List<MediaType>",
    "signature": "public List<MediaType> getWritableMediaTypes(ResolvableType elementType)",
    "source_code": "\tpublic List<MediaType> getWritableMediaTypes(ResolvableType elementType) {\n\t\treturn MediaType.asMediaTypes(getEncoder().getEncodableMimeTypes(elementType));\n\t}"
  },
  "org.springframework.http.codec.EncoderHttpMessageWriter#getWriteHints(streamType,elementType,mediaType,request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get additional hints for encoding for example based on the server request\n\t * or annotations from controller method parameters. By default, delegate to\n\t * the encoder if it is an instance of {@link HttpMessageEncoder}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "streamType",
      "elementType",
      "mediaType",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "Object>",
    "signature": "protected Object> getWriteHints(ResolvableType streamType, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tprotected Map<String, Object> getWriteHints(ResolvableType streamType, ResolvableType elementType,"
  },
  "org.springframework.http.codec.EncoderHttpMessageWriter#write(inputStream,actualType,elementType,mediaType,request,response,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inputStream",
      "actualType",
      "elementType",
      "mediaType",
      "request",
      "response",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> write(Publisher<? extends T> inputStream, ResolvableType actualType,\n\t\t\tResolvableType elementType, @Nullable MediaType mediaType, ServerHttpRequest request,\n\t\t\tServerHttpResponse response, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<Void> write(Publisher<? extends T> inputStream, ResolvableType actualType,"
  },
  "org.springframework.http.codec.EncoderHttpMessageWriter#write(inputStream,elementType,mediaType,message,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inputStream",
      "elementType",
      "mediaType",
      "message",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> write(Publisher<? extends T> inputStream, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ReactiveHttpOutputMessage message, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<Void> write(Publisher<? extends T> inputStream, ResolvableType elementType,"
  },
  "org.springframework.http.codec.ResourceHttpMessageWriter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code HttpMessageWriter} that can write a {@link Resource}.\n *\n * <p>Also an implementation of {@code HttpMessageWriter} with support for writing one\n * or more {@link ResourceRegion}'s based on the HTTP ranges specified in the request.\n *\n * <p>For reading to a Resource, use {@link ResourceDecoder} wrapped with\n * {@link DecoderHttpMessageReader}.\n *\n * @author Arjen Poutsma\n * @author Brian Clozel\n * @author Rossen Stoyanchev\n * @since 5.0\n * @see ResourceEncoder\n * @see ResourceRegionEncoder\n * @see HttpRange\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "signature": "public class ResourceHttpMessageWriter",
    "source_code": "public class ResourceHttpMessageWriter implements HttpMessageWriter<Resource> {\n\n\tprivate static final ResolvableType REGION_TYPE = ResolvableType.forClass(ResourceRegion.class);\n\n\tprivate static final Log logger = HttpLogging.forLogName(ResourceHttpMessageWriter.class);\n\n\n\tprivate final ResourceEncoder encoder;\n\n\tprivate final ResourceRegionEncoder regionEncoder;\n\n\tprivate final List<MediaType> mediaTypes;\n\n\n\tpublic ResourceHttpMessageWriter() {\n\t\tthis(ResourceEncoder.DEFAULT_BUFFER_SIZE);\n\t}\n\n\tpublic ResourceHttpMessageWriter(int bufferSize) {\n\t\tthis.encoder = new ResourceEncoder(bufferSize);\n\t\tthis.regionEncoder = new ResourceRegionEncoder(bufferSize);\n\t\tthis.mediaTypes = MediaType.asMediaTypes(this.encoder.getEncodableMimeTypes());\n\t}\n\n\n\t@Override\n\tpublic boolean canWrite(ResolvableType elementType, @Nullable MediaType mediaType) {\n\t\treturn this.encoder.canEncode(elementType, mediaType);\n\t}\n\n\t@Override\n\tpublic List<MediaType> getWritableMediaTypes() {\n\t\treturn this.mediaTypes;\n\t}\n\n\n\t// Client or server: single Resource...\n\n\t@Override\n\tpublic Mono<Void> write(Publisher<? extends Resource> inputStream, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ReactiveHttpOutputMessage message, Map<String, Object> hints) {\n\n\t\treturn Mono.from(inputStream).flatMap(resource ->\n\t\t\t\twriteResource(resource, elementType, mediaType, message, hints));\n\t}\n\n\tprivate Mono<Void> writeResource(Resource resource, ResolvableType type, @Nullable MediaType mediaType,\n\t\t\tReactiveHttpOutputMessage message, Map<String, Object> hints) {\n\n\t\taddHeaders(message, resource, mediaType, hints);\n\n\t\treturn zeroCopy(resource, null, message, hints)\n\t\t\t\t.orElseGet(() -> {\n\t\t\t\t\tMono<Resource> input = Mono.just(resource);\n\t\t\t\t\tDataBufferFactory factory = message.bufferFactory();\n\t\t\t\t\tFlux<DataBuffer> body = this.encoder.encode(input, factory, type, message.getHeaders().getContentType(), hints);\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tbody = body.doOnNext(buffer -> Hints.touchDataBuffer(buffer, hints, logger));\n\t\t\t\t\t}\n\t\t\t\t\treturn message.writeWith(body);\n\t\t\t\t});\n\t}\n\n\t/**\n\t * Adds the default headers for the given resource to the given message.\n\t * @since 6.0\n\t */\n\tpublic void addHeaders(ReactiveHttpOutputMessage message, Resource resource, @Nullable MediaType contentType, Map<String, Object> hints) {\n\t\tHttpHeaders headers = message.getHeaders();\n\t\tMediaType resourceMediaType = getResourceMediaType(contentType, resource, hints);\n\t\theaders.setContentType(resourceMediaType);\n\n\t\tif (headers.getContentLength() < 0) {\n\t\t\tlong length = lengthOf(resource);\n\t\t\tif (length != -1) {\n\t\t\t\theaders.setContentLength(length);\n\t\t\t}\n\t\t}\n\t\tif (message instanceof ServerHttpResponse) {\n\t\t\t// server side\n\t\t\theaders.set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n\t\t}\n\t}\n\n\tprivate static MediaType getResourceMediaType(\n\t\t\t@Nullable MediaType mediaType, Resource resource, Map<String, Object> hints) {\n\n\t\tif (mediaType != null && mediaType.isConcrete() && !mediaType.equals(MediaType.APPLICATION_OCTET_STREAM)) {\n\t\t\treturn mediaType;\n\t\t}\n\t\tmediaType = MediaTypeFactory.getMediaType(resource).orElse(MediaType.APPLICATION_OCTET_STREAM);\n\t\tif (logger.isDebugEnabled() && !Hints.isLoggingSuppressed(hints)) {\n\t\t\tlogger.debug(Hints.getLogPrefix(hints) + \"Resource associated with '\" + mediaType + \"'\");\n\t\t}\n\t\treturn mediaType;\n\t}\n\n\tprivate static long lengthOf(Resource resource) {\n\t\t// Don't consume InputStream...\n\t\tif (InputStreamResource.class != resource.getClass()) {\n\t\t\ttry {\n\t\t\t\treturn resource.contentLength();\n\t\t\t}\n\t\t\tcatch (IOException ignored) {\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tprivate static Optional<Mono<Void>> zeroCopy(Resource resource, @Nullable ResourceRegion region,\n\t\t\tReactiveHttpOutputMessage message, Map<String, Object> hints) {\n\n\t\tif (message instanceof ZeroCopyHttpOutputMessage zeroCopyHttpOutputMessage && resource.isFile()) {\n\t\t\ttry {\n\t\t\t\tFile file = resource.getFile();\n\t\t\t\tlong pos = region != null ? region.getPosition() : 0;\n\t\t\t\tlong count = region != null ? region.getCount() : file.length();\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tString formatted = region != null ? \"region \" + pos + \"-\" + (count) + \" of \" : \"\";\n\t\t\t\t\tlogger.debug(Hints.getLogPrefix(hints) + \"Zero-copy \" + formatted + \"[\" + resource + \"]\");\n\t\t\t\t}\n\t\t\t\treturn Optional.of(zeroCopyHttpOutputMessage.writeWith(file, pos, count));\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\t// should not happen\n\t\t\t}\n\t\t}\n\t\treturn Optional.empty();\n\t}\n\n\n\t// Server-side only: single Resource or sub-regions...\n\n\t@Override\n\tpublic Mono<Void> write(Publisher<? extends Resource> inputStream, @Nullable ResolvableType actualType,\n\t\t\tResolvableType elementType, @Nullable MediaType mediaType, ServerHttpRequest request,\n\t\t\tServerHttpResponse response, Map<String, Object> hints) {\n\n\t\tHttpHeaders headers = response.getHeaders();\n\t\theaders.set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n\n\t\tList<HttpRange> ranges;\n\t\ttry {\n\t\t\tranges = request.getHeaders().getRange();\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\tresponse.setStatusCode(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE);\n\t\t\treturn response.setComplete();\n\t\t}\n\n\t\treturn Mono.from(inputStream).flatMap(resource -> {\n\t\t\tif (ranges.isEmpty()) {\n\t\t\t\treturn writeResource(resource, elementType, mediaType, response, hints);\n\t\t\t}\n\t\t\tresponse.setStatusCode(HttpStatus.PARTIAL_CONTENT);\n\t\t\tList<ResourceRegion> regions = HttpRange.toResourceRegions(ranges, resource);\n\t\t\tMediaType resourceMediaType = getResourceMediaType(mediaType, resource, hints);\n\t\t\tif (regions.size() == 1){\n\t\t\t\tResourceRegion region = regions.get(0);\n\t\t\t\theaders.setContentType(resourceMediaType);\n\t\t\t\tlong contentLength = lengthOf(resource);\n\t\t\t\tif (contentLength != -1) {\n\t\t\t\t\tlong start = region.getPosition();\n\t\t\t\t\tlong end = start + region.getCount() - 1;\n\t\t\t\t\tend = Math.min(end, contentLength - 1);\n\t\t\t\t\theaders.add(\"Content-Range\", \"bytes \" + start + '-' + end + '/' + contentLength);\n\t\t\t\t\theaders.setContentLength(end - start + 1);\n\t\t\t\t}\n\t\t\t\treturn writeSingleRegion(region, response, hints);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString boundary = MimeTypeUtils.generateMultipartBoundaryString();\n\t\t\t\tMediaType multipartType = MediaType.parseMediaType(\"multipart/byteranges;boundary=\" + boundary);\n\t\t\t\theaders.setContentType(multipartType);\n\t\t\t\tMap<String, Object> allHints = Hints.merge(hints, ResourceRegionEncoder.BOUNDARY_STRING_HINT, boundary);\n\t\t\t\treturn encodeAndWriteRegions(Flux.fromIterable(regions), resourceMediaType, response, allHints);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate Mono<Void> writeSingleRegion(ResourceRegion region, ReactiveHttpOutputMessage message,\n\t\t\tMap<String, Object> hints) {\n\n\t\treturn zeroCopy(region.getResource(), region, message, hints)\n\t\t\t\t.orElseGet(() -> {\n\t\t\t\t\tPublisher<? extends ResourceRegion> input = Mono.just(region);\n\t\t\t\t\tMediaType mediaType = message.getHeaders().getContentType();\n\t\t\t\t\treturn encodeAndWriteRegions(input, mediaType, message, hints);\n\t\t\t\t});\n\t}\n\n\tprivate Mono<Void> encodeAndWriteRegions(Publisher<? extends ResourceRegion> publisher,\n\t\t\t@Nullable MediaType mediaType, ReactiveHttpOutputMessage message, Map<String, Object> hints) {\n\n\t\tFlux<DataBuffer> body = this.regionEncoder.encode(\n\t\t\t\tpublisher, message.bufferFactory(), REGION_TYPE, mediaType, hints);\n\n\t\treturn message.writeWith(body);\n\t}\n\n}"
  },
  "org.springframework.http.codec.ResourceHttpMessageWriter#addHeaders(message,resource,contentType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Adds the default headers for the given resource to the given message.\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "resource",
      "contentType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "void",
    "signature": "public void addHeaders(ReactiveHttpOutputMessage message, Resource resource, @Nullable MediaType contentType, Map<String, Object> hints)",
    "source_code": "\tpublic void addHeaders(ReactiveHttpOutputMessage message, Resource resource, @Nullable MediaType contentType, Map<String, Object> hints) {\n\t\tHttpHeaders headers = message.getHeaders();\n\t\tMediaType resourceMediaType = getResourceMediaType(contentType, resource, hints);\n\t\theaders.setContentType(resourceMediaType);\n\n\t\tif (headers.getContentLength() < 0) {\n\t\t\tlong length = lengthOf(resource);\n\t\t\tif (length != -1) {\n\t\t\t\theaders.setContentLength(length);\n\t\t\t}\n\t\t}\n\t\tif (message instanceof ServerHttpResponse) {\n\t\t\t// server side\n\t\t\theaders.set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.ResourceHttpMessageWriter#canWrite(elementType,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "boolean",
    "signature": "public boolean canWrite(ResolvableType elementType, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canWrite(ResolvableType elementType, @Nullable MediaType mediaType) {\n\t\treturn this.encoder.canEncode(elementType, mediaType);\n\t}"
  },
  "org.springframework.http.codec.ResourceHttpMessageWriter#getWritableMediaTypes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "List<MediaType>",
    "signature": "public List<MediaType> getWritableMediaTypes()",
    "source_code": "\tpublic List<MediaType> getWritableMediaTypes() {\n\t\treturn this.mediaTypes;\n\t}"
  },
  "org.springframework.http.codec.ResourceHttpMessageWriter#write(inputStream,actualType,elementType,mediaType,request,response,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inputStream",
      "actualType",
      "elementType",
      "mediaType",
      "request",
      "response",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> write(Publisher<? extends Resource> inputStream, @Nullable ResolvableType actualType,\n\t\t\tResolvableType elementType, @Nullable MediaType mediaType, ServerHttpRequest request,\n\t\t\tServerHttpResponse response, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<Void> write(Publisher<? extends Resource> inputStream, @Nullable ResolvableType actualType,"
  },
  "org.springframework.http.codec.ResourceHttpMessageWriter#write(inputStream,elementType,mediaType,message,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inputStream",
      "elementType",
      "mediaType",
      "message",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> write(Publisher<? extends Resource> inputStream, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ReactiveHttpOutputMessage message, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<Void> write(Publisher<? extends Resource> inputStream, ResolvableType elementType,"
  },
  "org.springframework.http.codec.ServerSentEventHttpMessageWriter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code HttpMessageWriter} for {@code \"text/event-stream\"} responses.\n *\n * @author Sebastien Deleuze\n * @author Arjen Poutsma\n * @author Rossen Stoyanchev\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "signature": "public class ServerSentEventHttpMessageWriter",
    "source_code": "public class ServerSentEventHttpMessageWriter implements HttpMessageWriter<Object> {\n\n\tprivate static final MediaType DEFAULT_MEDIA_TYPE = new MediaType(\"text\", \"event-stream\", StandardCharsets.UTF_8);\n\n\tprivate static final List<MediaType> WRITABLE_MEDIA_TYPES = Collections.singletonList(MediaType.TEXT_EVENT_STREAM);\n\n\tprivate static final Log logger = HttpLogging.forLogName(ServerSentEventHttpMessageWriter.class);\n\n\n\t@Nullable\n\tprivate final Encoder<?> encoder;\n\n\n\t/**\n\t * Constructor without an {@code Encoder}. In this mode only {@code String}\n\t * is supported for event data to be encoded.\n\t */\n\tpublic ServerSentEventHttpMessageWriter() {\n\t\tthis(null);\n\t}\n\n\t/**\n\t * Constructor with JSON {@code Encoder} for encoding objects.\n\t * Support for {@code String} event data is built-in.\n\t * @param encoder the Encoder to use (may be {@code null})\n\t */\n\tpublic ServerSentEventHttpMessageWriter(@Nullable Encoder<?> encoder) {\n\t\tthis.encoder = encoder;\n\t}\n\n\n\t/**\n\t * Return the configured {@code Encoder}, if any.\n\t */\n\t@Nullable\n\tpublic Encoder<?> getEncoder() {\n\t\treturn this.encoder;\n\t}\n\n\t@Override\n\tpublic List<MediaType> getWritableMediaTypes() {\n\t\treturn WRITABLE_MEDIA_TYPES;\n\t}\n\n\n\t@Override\n\tpublic boolean canWrite(ResolvableType elementType, @Nullable MediaType mediaType) {\n\t\treturn (mediaType == null || MediaType.TEXT_EVENT_STREAM.includes(mediaType) ||\n\t\t\t\tServerSentEvent.class.isAssignableFrom(elementType.toClass()));\n\t}\n\n\t@Override\n\tpublic Mono<Void> write(Publisher<?> input, ResolvableType elementType, @Nullable MediaType mediaType,\n\t\t\tReactiveHttpOutputMessage message, Map<String, Object> hints) {\n\n\t\tmediaType = (mediaType != null && mediaType.getCharset() != null ? mediaType : DEFAULT_MEDIA_TYPE);\n\t\tDataBufferFactory bufferFactory = message.bufferFactory();\n\n\t\tmessage.getHeaders().setContentType(mediaType);\n\t\treturn message.writeAndFlushWith(encode(input, elementType, mediaType, bufferFactory, hints));\n\t}\n\n\tprivate Flux<Publisher<DataBuffer>> encode(Publisher<?> input, ResolvableType elementType,\n\t\t\tMediaType mediaType, DataBufferFactory factory, Map<String, Object> hints) {\n\n\t\tResolvableType dataType = (ServerSentEvent.class.isAssignableFrom(elementType.toClass()) ?\n\t\t\t\telementType.getGeneric() : elementType);\n\n\t\treturn Flux.from(input).map(element -> {\n\n\t\t\tServerSentEvent<?> sse = (element instanceof ServerSentEvent<?> serverSentEvent ?\n\t\t\t\t\tserverSentEvent : ServerSentEvent.builder().data(element).build());\n\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tString id = sse.id();\n\t\t\tString event = sse.event();\n\t\t\tDuration retry = sse.retry();\n\t\t\tString comment = sse.comment();\n\t\t\tObject data = sse.data();\n\t\t\tif (id != null) {\n\t\t\t\twriteField(\"id\", id, sb);\n\t\t\t}\n\t\t\tif (event != null) {\n\t\t\t\twriteField(\"event\", event, sb);\n\t\t\t}\n\t\t\tif (retry != null) {\n\t\t\t\twriteField(\"retry\", retry.toMillis(), sb);\n\t\t\t}\n\t\t\tif (comment != null) {\n\t\t\t\tsb.append(':').append(StringUtils.replace(comment, \"\\n\", \"\\n:\")).append('\\n');\n\t\t\t}\n\t\t\tif (data != null) {\n\t\t\t\tsb.append(\"data:\");\n\t\t\t}\n\n\t\t\tFlux<DataBuffer> result;\n\t\t\tif (data == null) {\n\t\t\t\tresult = Flux.just(encodeText(sb + \"\\n\", mediaType, factory));\n\t\t\t}\n\t\t\telse if (data instanceof String text) {\n\t\t\t\ttext = StringUtils.replace(text, \"\\n\", \"\\ndata:\");\n\t\t\t\tresult = Flux.just(encodeText(sb + text + \"\\n\\n\", mediaType, factory));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult = encodeEvent(sb, data, dataType, mediaType, factory, hints);\n\t\t\t}\n\n\t\t\treturn result.doOnDiscard(DataBuffer.class, DataBufferUtils::release);\n\t\t});\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate <T> Flux<DataBuffer> encodeEvent(StringBuilder eventContent, T data, ResolvableType dataType,\n\t\t\tMediaType mediaType, DataBufferFactory factory, Map<String, Object> hints) {\n\n\t\tif (this.encoder == null) {\n\t\t\tthrow new CodecException(\"No SSE encoder configured and the data is not String.\");\n\t\t}\n\n\t\treturn Flux.defer(() -> {\n\t\t\tDataBuffer startBuffer = encodeText(eventContent, mediaType, factory);\n\t\t\tDataBuffer endBuffer = encodeText(\"\\n\\n\", mediaType, factory);\n\t\t\tDataBuffer dataBuffer = ((Encoder<T>) this.encoder).encodeValue(data, factory, dataType, mediaType, hints);\n\t\t\tHints.touchDataBuffer(dataBuffer, hints, logger);\n\t\t\treturn Flux.just(startBuffer, dataBuffer, endBuffer);\n\t\t});\n\t}\n\n\tprivate void writeField(String fieldName, Object fieldValue, StringBuilder sb) {\n\t\tsb.append(fieldName).append(':').append(fieldValue).append('\\n');\n\t}\n\n\tprivate DataBuffer encodeText(CharSequence text, MediaType mediaType, DataBufferFactory bufferFactory) {\n\t\tAssert.notNull(mediaType.getCharset(), \"Expected MediaType with charset\");\n\t\tbyte[] bytes = text.toString().getBytes(mediaType.getCharset());\n\t\treturn bufferFactory.wrap(bytes);  // wrapping, not allocating\n\t}\n\n\t@Override\n\tpublic Mono<Void> write(Publisher<?> input, ResolvableType actualType, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tMap<String, Object> hints) {\n\n\t\tMap<String, Object> allHints = Hints.merge(hints,\n\t\t\t\tgetEncodeHints(actualType, elementType, mediaType, request, response));\n\n\t\treturn write(input, elementType, mediaType, response, allHints);\n\t}\n\n\tprivate Map<String, Object> getEncodeHints(ResolvableType actualType, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ServerHttpRequest request, ServerHttpResponse response) {\n\n\t\tif (this.encoder instanceof HttpMessageEncoder<?> httpMessageEncoder) {\n\t\t\treturn httpMessageEncoder.getEncodeHints(actualType, elementType, mediaType, request, response);\n\t\t}\n\t\treturn Hints.none();\n\t}\n\n}"
  },
  "org.springframework.http.codec.ServerSentEventHttpMessageWriter#canWrite(elementType,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "boolean",
    "signature": "public boolean canWrite(ResolvableType elementType, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canWrite(ResolvableType elementType, @Nullable MediaType mediaType) {\n\t\treturn (mediaType == null || MediaType.TEXT_EVENT_STREAM.includes(mediaType) ||\n\t\t\t\tServerSentEvent.class.isAssignableFrom(elementType.toClass()));\n\t}"
  },
  "org.springframework.http.codec.ServerSentEventHttpMessageWriter#getWritableMediaTypes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "List<MediaType>",
    "signature": "public List<MediaType> getWritableMediaTypes()",
    "source_code": "\tpublic List<MediaType> getWritableMediaTypes() {\n\t\treturn WRITABLE_MEDIA_TYPES;\n\t}"
  },
  "org.springframework.http.codec.ServerSentEventHttpMessageWriter#write(input,actualType,elementType,mediaType,request,response,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "input",
      "actualType",
      "elementType",
      "mediaType",
      "request",
      "response",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> write(Publisher<?> input, ResolvableType actualType, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tMap<String, Object> hints)",
    "source_code": "\tpublic Mono<Void> write(Publisher<?> input, ResolvableType actualType, ResolvableType elementType,"
  },
  "org.springframework.http.codec.ServerSentEventHttpMessageWriter#write(input,elementType,mediaType,message,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "input",
      "elementType",
      "mediaType",
      "message",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> write(Publisher<?> input, ResolvableType elementType, @Nullable MediaType mediaType,\n\t\t\tReactiveHttpOutputMessage message, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<Void> write(Publisher<?> input, ResolvableType elementType, @Nullable MediaType mediaType,"
  },
  "org.springframework.http.codec.json.AbstractJackson2Decoder": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract base class for Jackson 2.x decoding, leveraging non-blocking parsing.\n *\n * @author Sebastien Deleuze\n * @author Rossen Stoyanchev\n * @author Arjen Poutsma\n * @since 5.0\n * @see <a href=\"https://github.com/FasterXML/jackson-core/issues/57\" target=\"_blank\">Add support for non-blocking (\"async\") JSON parsing</a>\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "signature": "public class AbstractJackson2Decoder",
    "source_code": "public abstract class AbstractJackson2Decoder extends Jackson2CodecSupport implements HttpMessageDecoder<Object> {\n\n\tprivate int maxInMemorySize = 256 * 1024;\n\n\n\t/**\n\t * Constructor with a Jackson {@link ObjectMapper} to use.\n\t */\n\tprotected AbstractJackson2Decoder(ObjectMapper mapper, MimeType... mimeTypes) {\n\t\tsuper(mapper, mimeTypes);\n\t}\n\n\n\t/**\n\t * Set the max number of bytes that can be buffered by this decoder. This\n\t * is either the size of the entire input when decoding as a whole, or the\n\t * size of one top-level JSON object within a JSON stream. When the limit\n\t * is exceeded, {@link DataBufferLimitException} is raised.\n\t * <p>By default this is set to 256K.\n\t * @param byteCount the max number of bytes to buffer, or -1 for unlimited\n\t * @since 5.1.11\n\t */\n\tpublic void setMaxInMemorySize(int byteCount) {\n\t\tthis.maxInMemorySize = byteCount;\n\t}\n\n\t/**\n\t * Return the {@link #setMaxInMemorySize configured} byte count limit.\n\t * @since 5.1.11\n\t */\n\tpublic int getMaxInMemorySize() {\n\t\treturn this.maxInMemorySize;\n\t}\n\n\n\t@Override\n\tpublic boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType) {\n\t\tObjectMapper mapper = selectObjectMapper(elementType, mimeType);\n\t\tif (mapper == null) {\n\t\t\treturn false;\n\t\t}\n\t\tJavaType javaType = mapper.constructType(elementType.getType());\n\t\t// Skip String: CharSequenceDecoder + \"*/*\" comes after\n\t\tif (CharSequence.class.isAssignableFrom(elementType.toClass()) || !supportsMimeType(mimeType)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!logger.isDebugEnabled()) {\n\t\t\treturn mapper.canDeserialize(javaType);\n\t\t}\n\t\telse {\n\t\t\tAtomicReference<Throwable> causeRef = new AtomicReference<>();\n\t\t\tif (mapper.canDeserialize(javaType, causeRef)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tlogWarningIfNecessary(javaType, causeRef.get());\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Override\n\tpublic Flux<Object> decode(Publisher<DataBuffer> input, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tObjectMapper mapper = selectObjectMapper(elementType, mimeType);\n\t\tif (mapper == null) {\n\t\t\treturn Flux.error(new IllegalStateException(\"No ObjectMapper for \" + elementType));\n\t\t}\n\n\t\tboolean forceUseOfBigDecimal = mapper.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS);\n\t\tif (BigDecimal.class.equals(elementType.getType())) {\n\t\t\tforceUseOfBigDecimal = true;\n\t\t}\n\n\t\tFlux<DataBuffer> processed = processInput(input, elementType, mimeType, hints);\n\t\tFlux<TokenBuffer> tokens = Jackson2Tokenizer.tokenize(processed, mapper.getFactory(), mapper,\n\t\t\t\ttrue, forceUseOfBigDecimal, getMaxInMemorySize());\n\n\t\treturn Flux.deferContextual(contextView -> {\n\n\t\t\tMap<String, Object> hintsToUse = contextView.isEmpty() ? hints :\n\t\t\t\t\tHints.merge(hints, ContextView.class.getName(), contextView);\n\n\t\t\tObjectReader reader = createObjectReader(mapper, elementType, hintsToUse);\n\n\t\t\treturn tokens.handle((tokenBuffer, sink) -> {\n\t\t\t\ttry {\n\t\t\t\t\tObject value = reader.readValue(tokenBuffer.asParser(mapper));\n\t\t\t\t\tlogValue(value, hints);\n\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\tsink.next(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\tsink.error(processException(ex));\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Process the input publisher into a flux. Default implementation returns\n\t * {@link Flux#from(Publisher)}, but subclasses can choose to customize\n\t * this behavior.\n\t * @param input the {@code DataBuffer} input stream to process\n\t * @param elementType the expected type of elements in the output stream\n\t * @param mimeType the MIME type associated with the input stream (optional)\n\t * @param hints additional information about how to do encode\n\t * @return the processed flux\n\t * @since 5.1.14\n\t */\n\tprotected Flux<DataBuffer> processInput(Publisher<DataBuffer> input, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\treturn Flux.from(input);\n\t}\n\n\t@Override\n\tpublic Mono<Object> decodeToMono(Publisher<DataBuffer> input, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\treturn Mono.deferContextual(contextView -> {\n\n\t\t\tMap<String, Object> hintsToUse = contextView.isEmpty() ? hints :\n\t\t\t\t\tHints.merge(hints, ContextView.class.getName(), contextView);\n\n\t\t\treturn DataBufferUtils.join(input, this.maxInMemorySize).flatMap(dataBuffer ->\n\t\t\t\t\tMono.justOrEmpty(decode(dataBuffer, elementType, mimeType, hintsToUse)));\n\t\t});\n\t}\n\n\t@Override\n\tpublic Object decode(DataBuffer dataBuffer, ResolvableType targetType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) throws DecodingException {\n\n\t\tObjectMapper mapper = selectObjectMapper(targetType, mimeType);\n\t\tif (mapper == null) {\n\t\t\tthrow new IllegalStateException(\"No ObjectMapper for \" + targetType);\n\t\t}\n\n\t\ttry {\n\t\t\tObjectReader objectReader = createObjectReader(mapper, targetType, hints);\n\t\t\tObject value = objectReader.readValue(dataBuffer.asInputStream());\n\t\t\tlogValue(value, hints);\n\t\t\treturn value;\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow processException(ex);\n\t\t}\n\t\tfinally {\n\t\t\tDataBufferUtils.release(dataBuffer);\n\t\t}\n\t}\n\n\tprivate ObjectReader createObjectReader(\n\t\t\tObjectMapper mapper, ResolvableType elementType, @Nullable Map<String, Object> hints) {\n\n\t\tAssert.notNull(elementType, \"'elementType' must not be null\");\n\t\tClass<?> contextClass = getContextClass(elementType);\n\t\tif (contextClass == null && hints != null) {\n\t\t\tcontextClass = getContextClass((ResolvableType) hints.get(ACTUAL_TYPE_HINT));\n\t\t}\n\t\tJavaType javaType = getJavaType(elementType.getType(), contextClass);\n\t\tClass<?> jsonView = (hints != null ? (Class<?>) hints.get(Jackson2CodecSupport.JSON_VIEW_HINT) : null);\n\n\t\tObjectReader objectReader = (jsonView != null ?\n\t\t\t\tmapper.readerWithView(jsonView).forType(javaType) :\n\t\t\t\tmapper.readerFor(javaType));\n\n\t\treturn customizeReader(objectReader, elementType, hints);\n\t}\n\n\t/**\n\t * Subclasses can use this method to customize {@link ObjectReader} used\n\t * for reading values.\n\t * @param reader the reader instance to customize\n\t * @param elementType the target type of element values to read to\n\t * @param hints a map with serialization hints;\n\t * the Reactor Context, when available, may be accessed under the key\n\t * {@code ContextView.class.getName()}\n\t * @return the customized {@code ObjectReader} to use\n\t * @since 6.0\n\t */\n\tprotected ObjectReader customizeReader(\n\t\t\tObjectReader reader, ResolvableType elementType, @Nullable Map<String, Object> hints) {\n\n\t\treturn reader;\n\t}\n\n\t@Nullable\n\tprivate Class<?> getContextClass(@Nullable ResolvableType elementType) {\n\t\tMethodParameter param = (elementType != null ? getParameter(elementType)  : null);\n\t\treturn (param != null ? param.getContainingClass() : null);\n\t}\n\n\tprivate void logValue(@Nullable Object value, @Nullable Map<String, Object> hints) {\n\t\tif (!Hints.isLoggingSuppressed(hints)) {\n\t\t\tLogFormatUtils.traceDebug(logger, traceOn -> {\n\t\t\t\tString formatted = LogFormatUtils.formatValue(value, !traceOn);\n\t\t\t\treturn Hints.getLogPrefix(hints) + \"Decoded [\" + formatted + \"]\";\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate CodecException processException(IOException ex) {\n\t\tif (ex instanceof InvalidDefinitionException ide) {\n\t\t\tJavaType type = ide.getType();\n\t\t\treturn new CodecException(\"Type definition error: \" + type, ex);\n\t\t}\n\t\tif (ex instanceof JsonProcessingException jpe) {\n\t\t\tString originalMessage = jpe.getOriginalMessage();\n\t\t\treturn new DecodingException(\"JSON decoding error: \" + originalMessage, ex);\n\t\t}\n\t\treturn new DecodingException(\"I/O error while parsing input stream\", ex);\n\t}\n\n\n\t// HttpMessageDecoder\n\n\t@Override\n\tpublic Map<String, Object> getDecodeHints(ResolvableType actualType, ResolvableType elementType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response) {\n\n\t\treturn getHints(actualType);\n\t}\n\n\t@Override\n\tpublic List<MimeType> getDecodableMimeTypes() {\n\t\treturn getMimeTypes();\n\t}\n\n\t@Override\n\tpublic List<MimeType> getDecodableMimeTypes(ResolvableType targetType) {\n\t\treturn getMimeTypes(targetType);\n\t}\n\n\t// Jackson2CodecSupport\n\n\t@Override\n\tprotected <A extends Annotation> A getAnnotation(MethodParameter parameter, Class<A> annotType) {\n\t\treturn parameter.getParameterAnnotation(annotType);\n\t}\n\n}"
  },
  "org.springframework.http.codec.json.AbstractJackson2Decoder#canDecode(elementType,mimeType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "boolean",
    "signature": "public boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType)",
    "source_code": "\tpublic boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType) {\n\t\tObjectMapper mapper = selectObjectMapper(elementType, mimeType);\n\t\tif (mapper == null) {\n\t\t\treturn false;\n\t\t}\n\t\tJavaType javaType = mapper.constructType(elementType.getType());\n\t\t// Skip String: CharSequenceDecoder + \"*/*\" comes after\n\t\tif (CharSequence.class.isAssignableFrom(elementType.toClass()) || !supportsMimeType(mimeType)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!logger.isDebugEnabled()) {\n\t\t\treturn mapper.canDeserialize(javaType);\n\t\t}\n\t\telse {\n\t\t\tAtomicReference<Throwable> causeRef = new AtomicReference<>();\n\t\t\tif (mapper.canDeserialize(javaType, causeRef)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tlogWarningIfNecessary(javaType, causeRef.get());\n\t\t\treturn false;\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.json.AbstractJackson2Decoder#customizeReader(reader,elementType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses can use this method to customize {@link ObjectReader} used\n\t * for reading values.\n\t * @param reader the reader instance to customize\n\t * @param elementType the target type of element values to read to\n\t * @param hints a map with serialization hints;\n\t * the Reactor Context, when available, may be accessed under the key\n\t * {@code ContextView.class.getName()}\n\t * @return the customized {@code ObjectReader} to use\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "reader",
      "elementType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 245
    },
    "return": "ObjectReader",
    "signature": "protected ObjectReader customizeReader(ObjectReader reader, ResolvableType elementType, @Nullable Map<String, Object> hints)",
    "source_code": "\tprotected ObjectReader customizeReader("
  },
  "org.springframework.http.codec.json.AbstractJackson2Decoder#decode(dataBuffer,targetType,mimeType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataBuffer",
      "targetType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "Object",
    "signature": "public Object decode(DataBuffer dataBuffer, ResolvableType targetType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic Object decode(DataBuffer dataBuffer, ResolvableType targetType,"
  },
  "org.springframework.http.codec.json.AbstractJackson2Decoder#decode(input,elementType,mimeType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "input",
      "elementType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "Flux<Object>",
    "signature": "public Flux<Object> decode(Publisher<DataBuffer> input, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic Flux<Object> decode(Publisher<DataBuffer> input, ResolvableType elementType,"
  },
  "org.springframework.http.codec.json.AbstractJackson2Decoder#decodeToMono(input,elementType,mimeType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "input",
      "elementType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "Mono<Object>",
    "signature": "public Mono<Object> decodeToMono(Publisher<DataBuffer> input, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic Mono<Object> decodeToMono(Publisher<DataBuffer> input, ResolvableType elementType,"
  },
  "org.springframework.http.codec.json.AbstractJackson2Decoder#getAnnotation(parameter,annotType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "annotType"
    ],
    "position": {
      "column": 1,
      "line": 301
    },
    "return": "A",
    "signature": "protected A getAnnotation(MethodParameter parameter, Class<A> annotType)",
    "source_code": "\tprotected <A extends Annotation> A getAnnotation(MethodParameter parameter, Class<A> annotType) {\n\t\treturn parameter.getParameterAnnotation(annotType);\n\t}"
  },
  "org.springframework.http.codec.json.AbstractJackson2Decoder#getDecodableMimeTypes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 289
    },
    "return": "List<MimeType>",
    "signature": "public List<MimeType> getDecodableMimeTypes()",
    "source_code": "\tpublic List<MimeType> getDecodableMimeTypes() {\n\t\treturn getMimeTypes();\n\t}"
  },
  "org.springframework.http.codec.json.AbstractJackson2Decoder#getDecodableMimeTypes(targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 294
    },
    "return": "List<MimeType>",
    "signature": "public List<MimeType> getDecodableMimeTypes(ResolvableType targetType)",
    "source_code": "\tpublic List<MimeType> getDecodableMimeTypes(ResolvableType targetType) {\n\t\treturn getMimeTypes(targetType);\n\t}"
  },
  "org.springframework.http.codec.json.AbstractJackson2Decoder#getDecodeHints(actualType,elementType,request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "actualType",
      "elementType",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "Object>",
    "signature": "public Object> getDecodeHints(ResolvableType actualType, ResolvableType elementType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tpublic Map<String, Object> getDecodeHints(ResolvableType actualType, ResolvableType elementType,"
  },
  "org.springframework.http.codec.json.AbstractJackson2Decoder#getMaxInMemorySize()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link #setMaxInMemorySize configured} byte count limit.\n\t * @since 5.1.11\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "int",
    "signature": "public int getMaxInMemorySize()",
    "source_code": "\tpublic int getMaxInMemorySize() {\n\t\treturn this.maxInMemorySize;\n\t}"
  },
  "org.springframework.http.codec.json.AbstractJackson2Decoder#processInput(input,elementType,mimeType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Process the input publisher into a flux. Default implementation returns\n\t * {@link Flux#from(Publisher)}, but subclasses can choose to customize\n\t * this behavior.\n\t * @param input the {@code DataBuffer} input stream to process\n\t * @param elementType the expected type of elements in the output stream\n\t * @param mimeType the MIME type associated with the input stream (optional)\n\t * @param hints additional information about how to do encode\n\t * @return the processed flux\n\t * @since 5.1.14\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "input",
      "elementType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "Flux<DataBuffer>",
    "signature": "protected Flux<DataBuffer> processInput(Publisher<DataBuffer> input, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tprotected Flux<DataBuffer> processInput(Publisher<DataBuffer> input, ResolvableType elementType,"
  },
  "org.springframework.http.codec.json.AbstractJackson2Decoder#setMaxInMemorySize(byteCount)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the max number of bytes that can be buffered by this decoder. This\n\t * is either the size of the entire input when decoding as a whole, or the\n\t * size of one top-level JSON object within a JSON stream. When the limit\n\t * is exceeded, {@link DataBufferLimitException} is raised.\n\t * <p>By default this is set to 256K.\n\t * @param byteCount the max number of bytes to buffer, or -1 for unlimited\n\t * @since 5.1.11\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "byteCount"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "void",
    "signature": "public void setMaxInMemorySize(int byteCount)",
    "source_code": "\tpublic void setMaxInMemorySize(int byteCount) {\n\t\tthis.maxInMemorySize = byteCount;\n\t}"
  },
  "org.springframework.http.codec.json.JSON_VIEW_HINT": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The key for the hint to specify a \"JSON View\" for encoding or decoding\n\t * with the value expected to be a {@link Class}.\n\t * @see <a href=\"https://www.baeldung.com/jackson-json-view-annotation\">Jackson JSON Views</a>\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "signature": "public String JSON_VIEW_HINT",
    "source_code": "\tpublic static final String JSON_VIEW_HINT = Jackson2CodecSupport.class.getName() + \".jsonView\";",
    "type": "String"
  },
  "org.springframework.http.codec.json.Jackson2CodecSupport": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Base class providing support methods for Jackson 2.x encoding and decoding.\n *\n * @author Sebastien Deleuze\n * @author Rossen Stoyanchev\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "signature": "public class Jackson2CodecSupport",
    "source_code": "public abstract class Jackson2CodecSupport {\n\n\t/**\n\t * The key for the hint to specify a \"JSON View\" for encoding or decoding\n\t * with the value expected to be a {@link Class}.\n\t * @see <a href=\"https://www.baeldung.com/jackson-json-view-annotation\">Jackson JSON Views</a>\n\t */\n\tpublic static final String JSON_VIEW_HINT = Jackson2CodecSupport.class.getName() + \".jsonView\";\n\n\t/**\n\t * The key for the hint to access the actual ResolvableType passed into\n\t * {@link org.springframework.http.codec.HttpMessageReader#read(ResolvableType, ResolvableType, ServerHttpRequest, ServerHttpResponse, Map)}\n\t * (server-side only). Currently set when the method argument has generics because\n\t * in case of reactive types, use of {@code ResolvableType.getGeneric()} means no\n\t * MethodParameter source and no knowledge of the containing class.\n\t */\n\tstatic final String ACTUAL_TYPE_HINT = Jackson2CodecSupport.class.getName() + \".actualType\";\n\n\tprivate static final String JSON_VIEW_HINT_ERROR =\n\t\t\t\"@JsonView only supported for write hints with exactly 1 class argument: \";\n\n\tprivate static final List<MimeType> DEFAULT_MIME_TYPES = List.of(\n\t\t\tMediaType.APPLICATION_JSON,\n\t\t\tnew MediaType(\"application\", \"*+json\"),\n\t\t\tMediaType.APPLICATION_NDJSON);\n\n\n\tprotected final Log logger = HttpLogging.forLogName(getClass());\n\n\tprivate ObjectMapper defaultObjectMapper;\n\n\t@Nullable\n\tprivate Map<Class<?>, Map<MimeType, ObjectMapper>> objectMapperRegistrations;\n\n\tprivate final List<MimeType> mimeTypes;\n\n\tprivate final List<MimeType> problemDetailMimeTypes;\n\n\n\t/**\n\t * Constructor with a Jackson {@link ObjectMapper} to use.\n\t */\n\tprotected Jackson2CodecSupport(ObjectMapper objectMapper, MimeType... mimeTypes) {\n\t\tAssert.notNull(objectMapper, \"ObjectMapper must not be null\");\n\t\tthis.defaultObjectMapper = objectMapper;\n\t\tthis.mimeTypes = (!ObjectUtils.isEmpty(mimeTypes) ? List.of(mimeTypes) : DEFAULT_MIME_TYPES);\n\t\tthis.problemDetailMimeTypes = initProblemDetailMediaTypes(this.mimeTypes);\n\t}\n\n\tprivate static List<MimeType> initProblemDetailMediaTypes(List<MimeType> supportedMimeTypes) {\n\t\tList<MimeType> mimeTypes = new ArrayList<>();\n\t\tmimeTypes.add(MediaType.APPLICATION_PROBLEM_JSON);\n\t\tmimeTypes.addAll(supportedMimeTypes);\n\t\treturn Collections.unmodifiableList(mimeTypes);\n\t}\n\n\n\t/**\n\t * Configure the default ObjectMapper instance to use.\n\t * @param objectMapper the ObjectMapper instance\n\t * @since 5.3.4\n\t */\n\tpublic void setObjectMapper(ObjectMapper objectMapper) {\n\t\tAssert.notNull(objectMapper, \"ObjectMapper must not be null\");\n\t\tthis.defaultObjectMapper = objectMapper;\n\t}\n\n\t/**\n\t * Return the {@link #setObjectMapper configured} default ObjectMapper.\n\t */\n\tpublic ObjectMapper getObjectMapper() {\n\t\treturn this.defaultObjectMapper;\n\t}\n\n\t/**\n\t * Configure the {@link ObjectMapper} instances to use for the given\n\t * {@link Class}. This is useful when you want to deviate from the\n\t * {@link #getObjectMapper() default} ObjectMapper or have the\n\t * {@code ObjectMapper} vary by {@code MediaType}.\n\t * <p><strong>Note:</strong> Use of this method effectively turns off use of\n\t * the default {@link #getObjectMapper() ObjectMapper} and supported\n\t * {@link #getMimeTypes() MimeTypes} for the given class. Therefore it is\n\t * important for the mappings configured here to\n\t * {@link MediaType#includes(MediaType) include} every MediaType that must\n\t * be supported for the given class.\n\t * @param clazz the type of Object to register ObjectMapper instances for\n\t * @param registrar a consumer to populate or otherwise update the\n\t * MediaType-to-ObjectMapper associations for the given Class\n\t * @since 5.3.4\n\t */\n\tpublic void registerObjectMappersForType(Class<?> clazz, Consumer<Map<MimeType, ObjectMapper>> registrar) {\n\t\tif (this.objectMapperRegistrations == null) {\n\t\t\tthis.objectMapperRegistrations = new LinkedHashMap<>();\n\t\t}\n\t\tMap<MimeType, ObjectMapper> registrations =\n\t\t\t\tthis.objectMapperRegistrations.computeIfAbsent(clazz, c -> new LinkedHashMap<>());\n\t\tregistrar.accept(registrations);\n\t}\n\n\t/**\n\t * Return ObjectMapper registrations for the given class, if any.\n\t * @param clazz the class to look up for registrations for\n\t * @return a map with registered MediaType-to-ObjectMapper registrations,\n\t * or empty if in case of no registrations for the given class.\n\t * @since 5.3.4\n\t */\n\t@Nullable\n\tpublic Map<MimeType, ObjectMapper> getObjectMappersForType(Class<?> clazz) {\n\t\tfor (Map.Entry<Class<?>, Map<MimeType, ObjectMapper>> entry : getObjectMapperRegistrations().entrySet()) {\n\t\t\tif (entry.getKey().isAssignableFrom(clazz)) {\n\t\t\t\treturn entry.getValue();\n\t\t\t}\n\t\t}\n\t\treturn Collections.emptyMap();\n\t}\n\n\tprotected Map<Class<?>, Map<MimeType, ObjectMapper>> getObjectMapperRegistrations() {\n\t\treturn (this.objectMapperRegistrations != null ? this.objectMapperRegistrations : Collections.emptyMap());\n\t}\n\n\t/**\n\t * Subclasses should expose this as \"decodable\" or \"encodable\" mime types.\n\t */\n\tprotected List<MimeType> getMimeTypes() {\n\t\treturn this.mimeTypes;\n\t}\n\n\tprotected List<MimeType> getMimeTypes(ResolvableType elementType) {\n\t\tClass<?> elementClass = elementType.toClass();\n\t\tList<MimeType> result = null;\n\t\tfor (Map.Entry<Class<?>, Map<MimeType, ObjectMapper>> entry : getObjectMapperRegistrations().entrySet()) {\n\t\t\tif (entry.getKey().isAssignableFrom(elementClass)) {\n\t\t\t\tresult = (result != null ? result : new ArrayList<>(entry.getValue().size()));\n\t\t\t\tresult.addAll(entry.getValue().keySet());\n\t\t\t}\n\t\t}\n\t\tif (!CollectionUtils.isEmpty(result)) {\n\t\t\treturn result;\n\t\t}\n\t\treturn (ProblemDetail.class.isAssignableFrom(elementClass) ? this.problemDetailMimeTypes : getMimeTypes());\n\t}\n\n\tprotected boolean supportsMimeType(@Nullable MimeType mimeType) {\n\t\tif (mimeType == null) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (MimeType supportedMimeType : this.mimeTypes) {\n\t\t\tif (supportedMimeType.isCompatibleWith(mimeType)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Determine whether to log the given exception coming from a\n\t * {@link ObjectMapper#canDeserialize} / {@link ObjectMapper#canSerialize} check.\n\t * @param type the class that Jackson tested for (de-)serializability\n\t * @param cause the Jackson-thrown exception to evaluate\n\t * (typically a {@link JsonMappingException})\n\t * @since 5.3.1\n\t */\n\tprotected void logWarningIfNecessary(Type type, @Nullable Throwable cause) {\n\t\tif (cause == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tString msg = \"Failed to evaluate Jackson \" + (type instanceof JavaType ? \"de\" : \"\") +\n\t\t\t\t\t\"serialization for type [\" + type + \"]\";\n\t\t\tlogger.debug(msg, cause);\n\t\t}\n\t}\n\n\tprotected JavaType getJavaType(Type type, @Nullable Class<?> contextClass) {\n\t\treturn this.defaultObjectMapper.constructType(GenericTypeResolver.resolveType(type, contextClass));\n\t}\n\n\tprotected Map<String, Object> getHints(ResolvableType resolvableType) {\n\t\tMethodParameter param = getParameter(resolvableType);\n\t\tif (param != null) {\n\t\t\tMap<String, Object> hints = null;\n\t\t\tif (resolvableType.hasGenerics()) {\n\t\t\t\thints = new HashMap<>(2);\n\t\t\t\thints.put(ACTUAL_TYPE_HINT, resolvableType);\n\t\t\t}\n\t\t\tJsonView annotation = getAnnotation(param, JsonView.class);\n\t\t\tif (annotation != null) {\n\t\t\t\tClass<?>[] classes = annotation.value();\n\t\t\t\tAssert.isTrue(classes.length == 1, () -> JSON_VIEW_HINT_ERROR + param);\n\t\t\t\thints = (hints != null ? hints : new HashMap<>(1));\n\t\t\t\thints.put(JSON_VIEW_HINT, classes[0]);\n\t\t\t}\n\t\t\tif (hints != null) {\n\t\t\t\treturn hints;\n\t\t\t}\n\t\t}\n\t\treturn Hints.none();\n\t}\n\n\t@Nullable\n\tprotected MethodParameter getParameter(ResolvableType type) {\n\t\treturn (type.getSource() instanceof MethodParameter methodParameter ? methodParameter : null);\n\t}\n\n\t@Nullable\n\tprotected abstract <A extends Annotation> A getAnnotation(MethodParameter parameter, Class<A> annotType);\n\n\t/**\n\t * Select an ObjectMapper to use, either the main ObjectMapper or another\n\t * if the handling for the given Class has been customized through\n\t * {@link #registerObjectMappersForType(Class, Consumer)}.\n\t * @since 5.3.4\n\t */\n\t@Nullable\n\tprotected ObjectMapper selectObjectMapper(ResolvableType targetType, @Nullable MimeType targetMimeType) {\n\t\tif (targetMimeType == null || CollectionUtils.isEmpty(this.objectMapperRegistrations)) {\n\t\t\treturn this.defaultObjectMapper;\n\t\t}\n\t\tClass<?> targetClass = targetType.toClass();\n\t\tfor (Map.Entry<Class<?>, Map<MimeType, ObjectMapper>> typeEntry : getObjectMapperRegistrations().entrySet()) {\n\t\t\tif (typeEntry.getKey().isAssignableFrom(targetClass)) {\n\t\t\t\tfor (Map.Entry<MimeType, ObjectMapper> objectMapperEntry : typeEntry.getValue().entrySet()) {\n\t\t\t\t\tif (objectMapperEntry.getKey().includes(targetMimeType)) {\n\t\t\t\t\t\treturn objectMapperEntry.getValue();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// No matching registrations\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t// No registrations\n\t\treturn this.defaultObjectMapper;\n\t}\n\n}"
  },
  "org.springframework.http.codec.json.Jackson2CodecSupport#getAnnotation(parameter,annotType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "annotType"
    ],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "A",
    "signature": "protected A getAnnotation(MethodParameter parameter, Class<A> annotType)",
    "source_code": "\tprotected abstract <A extends Annotation> A getAnnotation(MethodParameter parameter, Class<A> annotType);"
  },
  "org.springframework.http.codec.json.Jackson2CodecSupport#getHints(resolvableType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resolvableType"
    ],
    "position": {
      "column": 1,
      "line": 234
    },
    "return": "Object>",
    "signature": "protected Object> getHints(ResolvableType resolvableType)",
    "source_code": "\tprotected Map<String, Object> getHints(ResolvableType resolvableType) {\n\t\tMethodParameter param = getParameter(resolvableType);\n\t\tif (param != null) {\n\t\t\tMap<String, Object> hints = null;\n\t\t\tif (resolvableType.hasGenerics()) {\n\t\t\t\thints = new HashMap<>(2);\n\t\t\t\thints.put(ACTUAL_TYPE_HINT, resolvableType);\n\t\t\t}\n\t\t\tJsonView annotation = getAnnotation(param, JsonView.class);\n\t\t\tif (annotation != null) {\n\t\t\t\tClass<?>[] classes = annotation.value();\n\t\t\t\tAssert.isTrue(classes.length == 1, () -> JSON_VIEW_HINT_ERROR + param);\n\t\t\t\thints = (hints != null ? hints : new HashMap<>(1));\n\t\t\t\thints.put(JSON_VIEW_HINT, classes[0]);\n\t\t\t}\n\t\t\tif (hints != null) {\n\t\t\t\treturn hints;\n\t\t\t}\n\t\t}\n\t\treturn Hints.none();\n\t}"
  },
  "org.springframework.http.codec.json.Jackson2CodecSupport#getJavaType(type,contextClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "type",
      "contextClass"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "JavaType",
    "signature": "protected JavaType getJavaType(Type type, @Nullable Class<?> contextClass)",
    "source_code": "\tprotected JavaType getJavaType(Type type, @Nullable Class<?> contextClass) {\n\t\treturn this.defaultObjectMapper.constructType(GenericTypeResolver.resolveType(type, contextClass));\n\t}"
  },
  "org.springframework.http.codec.json.Jackson2CodecSupport#getMimeTypes()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses should expose this as \"decodable\" or \"encodable\" mime types.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "List<MimeType>",
    "signature": "protected List<MimeType> getMimeTypes()",
    "source_code": "\tprotected List<MimeType> getMimeTypes() {\n\t\treturn this.mimeTypes;\n\t}"
  },
  "org.springframework.http.codec.json.Jackson2CodecSupport#getMimeTypes(elementType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "elementType"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "List<MimeType>",
    "signature": "protected List<MimeType> getMimeTypes(ResolvableType elementType)",
    "source_code": "\tprotected List<MimeType> getMimeTypes(ResolvableType elementType) {\n\t\tClass<?> elementClass = elementType.toClass();\n\t\tList<MimeType> result = null;\n\t\tfor (Map.Entry<Class<?>, Map<MimeType, ObjectMapper>> entry : getObjectMapperRegistrations().entrySet()) {\n\t\t\tif (entry.getKey().isAssignableFrom(elementClass)) {\n\t\t\t\tresult = (result != null ? result : new ArrayList<>(entry.getValue().size()));\n\t\t\t\tresult.addAll(entry.getValue().keySet());\n\t\t\t}\n\t\t}\n\t\tif (!CollectionUtils.isEmpty(result)) {\n\t\t\treturn result;\n\t\t}\n\t\treturn (ProblemDetail.class.isAssignableFrom(elementClass) ? this.problemDetailMimeTypes : getMimeTypes());\n\t}"
  },
  "org.springframework.http.codec.json.Jackson2CodecSupport#getObjectMapper()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link #setObjectMapper configured} default ObjectMapper.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "ObjectMapper",
    "signature": "public ObjectMapper getObjectMapper()",
    "source_code": "\tpublic ObjectMapper getObjectMapper() {\n\t\treturn this.defaultObjectMapper;\n\t}"
  },
  "org.springframework.http.codec.json.Jackson2CodecSupport#getObjectMappersForType(clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return ObjectMapper registrations for the given class, if any.\n\t * @param clazz the class to look up for registrations for\n\t * @return a map with registered MediaType-to-ObjectMapper registrations,\n\t * or empty if in case of no registrations for the given class.\n\t * @since 5.3.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "ObjectMapper>",
    "signature": "public ObjectMapper> getObjectMappersForType(Class<?> clazz)",
    "source_code": "\tpublic Map<MimeType, ObjectMapper> getObjectMappersForType(Class<?> clazz) {\n\t\tfor (Map.Entry<Class<?>, Map<MimeType, ObjectMapper>> entry : getObjectMapperRegistrations().entrySet()) {\n\t\t\tif (entry.getKey().isAssignableFrom(clazz)) {\n\t\t\t\treturn entry.getValue();\n\t\t\t}\n\t\t}\n\t\treturn Collections.emptyMap();\n\t}"
  },
  "org.springframework.http.codec.json.Jackson2CodecSupport#getParameter(type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 257
    },
    "return": "MethodParameter",
    "signature": "protected MethodParameter getParameter(ResolvableType type)",
    "source_code": "\tprotected MethodParameter getParameter(ResolvableType type) {\n\t\treturn (type.getSource() instanceof MethodParameter methodParameter ? methodParameter : null);\n\t}"
  },
  "org.springframework.http.codec.json.Jackson2CodecSupport#logWarningIfNecessary(type,cause)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether to log the given exception coming from a\n\t * {@link ObjectMapper#canDeserialize} / {@link ObjectMapper#canSerialize} check.\n\t * @param type the class that Jackson tested for (de-)serializability\n\t * @param cause the Jackson-thrown exception to evaluate\n\t * (typically a {@link JsonMappingException})\n\t * @since 5.3.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "type",
      "cause"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "void",
    "signature": "protected void logWarningIfNecessary(Type type, @Nullable Throwable cause)",
    "source_code": "\tprotected void logWarningIfNecessary(Type type, @Nullable Throwable cause) {\n\t\tif (cause == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tString msg = \"Failed to evaluate Jackson \" + (type instanceof JavaType ? \"de\" : \"\") +\n\t\t\t\t\t\"serialization for type [\" + type + \"]\";\n\t\t\tlogger.debug(msg, cause);\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.json.Jackson2CodecSupport#registerObjectMappersForType(clazz,Consumer<Map<MimeType,registrar)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@link ObjectMapper} instances to use for the given\n\t * {@link Class}. This is useful when you want to deviate from the\n\t * {@link #getObjectMapper() default} ObjectMapper or have the\n\t * {@code ObjectMapper} vary by {@code MediaType}.\n\t * <p><strong>Note:</strong> Use of this method effectively turns off use of\n\t * the default {@link #getObjectMapper() ObjectMapper} and supported\n\t * {@link #getMimeTypes() MimeTypes} for the given class. Therefore it is\n\t * important for the mappings configured here to\n\t * {@link MediaType#includes(MediaType) include} every MediaType that must\n\t * be supported for the given class.\n\t * @param clazz the type of Object to register ObjectMapper instances for\n\t * @param registrar a consumer to populate or otherwise update the\n\t * MediaType-to-ObjectMapper associations for the given Class\n\t * @since 5.3.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "Consumer<Map<MimeType",
      "registrar"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "void",
    "signature": "public void registerObjectMappersForType(Class<?> clazz, Consumer<Map<MimeType, ObjectMapper>> registrar)",
    "source_code": "\tpublic void registerObjectMappersForType(Class<?> clazz, Consumer<Map<MimeType, ObjectMapper>> registrar) {\n\t\tif (this.objectMapperRegistrations == null) {\n\t\t\tthis.objectMapperRegistrations = new LinkedHashMap<>();\n\t\t}\n\t\tMap<MimeType, ObjectMapper> registrations =\n\t\t\t\tthis.objectMapperRegistrations.computeIfAbsent(clazz, c -> new LinkedHashMap<>());\n\t\tregistrar.accept(registrations);\n\t}"
  },
  "org.springframework.http.codec.json.Jackson2CodecSupport#selectObjectMapper(targetType,targetMimeType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Select an ObjectMapper to use, either the main ObjectMapper or another\n\t * if the handling for the given Class has been customized through\n\t * {@link #registerObjectMappersForType(Class, Consumer)}.\n\t * @since 5.3.4\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "targetType",
      "targetMimeType"
    ],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "ObjectMapper",
    "signature": "protected ObjectMapper selectObjectMapper(ResolvableType targetType, @Nullable MimeType targetMimeType)",
    "source_code": "\tprotected ObjectMapper selectObjectMapper(ResolvableType targetType, @Nullable MimeType targetMimeType) {\n\t\tif (targetMimeType == null || CollectionUtils.isEmpty(this.objectMapperRegistrations)) {\n\t\t\treturn this.defaultObjectMapper;\n\t\t}\n\t\tClass<?> targetClass = targetType.toClass();\n\t\tfor (Map.Entry<Class<?>, Map<MimeType, ObjectMapper>> typeEntry : getObjectMapperRegistrations().entrySet()) {\n\t\t\tif (typeEntry.getKey().isAssignableFrom(targetClass)) {\n\t\t\t\tfor (Map.Entry<MimeType, ObjectMapper> objectMapperEntry : typeEntry.getValue().entrySet()) {\n\t\t\t\t\tif (objectMapperEntry.getKey().includes(targetMimeType)) {\n\t\t\t\t\t\treturn objectMapperEntry.getValue();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// No matching registrations\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t// No registrations\n\t\treturn this.defaultObjectMapper;\n\t}"
  },
  "org.springframework.http.codec.json.Jackson2CodecSupport#setObjectMapper(objectMapper)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the default ObjectMapper instance to use.\n\t * @param objectMapper the ObjectMapper instance\n\t * @since 5.3.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "objectMapper"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "void",
    "signature": "public void setObjectMapper(ObjectMapper objectMapper)",
    "source_code": "\tpublic void setObjectMapper(ObjectMapper objectMapper) {\n\t\tAssert.notNull(objectMapper, \"ObjectMapper must not be null\");\n\t\tthis.defaultObjectMapper = objectMapper;\n\t}"
  },
  "org.springframework.http.codec.json.Jackson2CodecSupport#supportsMimeType(mimeType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "boolean",
    "signature": "protected boolean supportsMimeType(@Nullable MimeType mimeType)",
    "source_code": "\tprotected boolean supportsMimeType(@Nullable MimeType mimeType) {\n\t\tif (mimeType == null) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (MimeType supportedMimeType : this.mimeTypes) {\n\t\t\tif (supportedMimeType.isCompatibleWith(mimeType)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.http.codec.json.logger": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = HttpLogging.forLogName(getClass());",
    "type": "Log"
  },
  "org.springframework.http.codec.multipart.MultipartHttpMessageReader": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code HttpMessageReader} for reading {@code \"multipart/form-data\"} requests\n * into a {@code MultiValueMap<String, Part>}.\n *\n * <p>Note that this reader depends on access to an\n * {@code HttpMessageReader<Part>} for the actual parsing of multipart content.\n * The purpose of this reader is to collect the parts into a map.\n *\n * @author Rossen Stoyanchev\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "public class MultipartHttpMessageReader",
    "source_code": "public class MultipartHttpMessageReader extends LoggingCodecSupport"
  },
  "org.springframework.http.codec.multipart.MultipartHttpMessageReader#canRead(elementType,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "boolean",
    "signature": "public boolean canRead(ResolvableType elementType, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canRead(ResolvableType elementType, @Nullable MediaType mediaType) {\n\t\tif (MULTIPART_VALUE_TYPE.isAssignableFrom(elementType)) {\n\t\t\tif (mediaType == null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (MediaType supportedMediaType : MIME_TYPES) {\n\t\t\t\tif (supportedMediaType.isCompatibleWith(mediaType)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.http.codec.multipart.MultipartHttpMessageReader#getPartReader()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured parts reader.\n\t * @since 5.1.11\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "HttpMessageReader<Part>",
    "signature": "public HttpMessageReader<Part> getPartReader()",
    "source_code": "\tpublic HttpMessageReader<Part> getPartReader() {\n\t\treturn this.partReader;\n\t}"
  },
  "org.springframework.http.codec.multipart.MultipartHttpMessageReader#getReadableMediaTypes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "List<MediaType>",
    "signature": "public List<MediaType> getReadableMediaTypes()",
    "source_code": "\tpublic List<MediaType> getReadableMediaTypes() {\n\t\treturn MIME_TYPES;\n\t}"
  },
  "org.springframework.http.codec.multipart.MultipartHttpMessageReader#read(elementType,message,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "message",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "Part>>",
    "signature": "public Part>> read(ResolvableType elementType,\n\t\t\tReactiveHttpInputMessage message, Map<String, Object> hints)",
    "source_code": "\tpublic Flux<MultiValueMap<String, Part>> read(ResolvableType elementType,"
  },
  "org.springframework.http.codec.multipart.MultipartHttpMessageReader#readMono(elementType,inputMessage,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "inputMessage",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "Part>>",
    "signature": "public Part>> readMono(ResolvableType elementType,\n\t\t\tReactiveHttpInputMessage inputMessage, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<MultiValueMap<String, Part>> readMono(ResolvableType elementType,"
  },
  "org.springframework.http.codec.multipart.PartHttpMessageWriter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link HttpMessageWriter} for writing with {@link Part}. This can be useful\n * on the server side to write a {@code Flux<Part>} received from a client to\n * some remote service.\n *\n * @author Rossen Stoyanchev\n * @since 5.3\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "signature": "public class PartHttpMessageWriter",
    "source_code": "public class PartHttpMessageWriter extends MultipartWriterSupport implements HttpMessageWriter<Part> {\n\n\n\tpublic PartHttpMessageWriter() {\n\t\tsuper(MultipartHttpMessageReader.MIME_TYPES);\n\t}\n\n\n\t@Override\n\tpublic Mono<Void> write(Publisher<? extends Part> parts,\n\t\t\tResolvableType elementType, @Nullable MediaType mediaType, ReactiveHttpOutputMessage outputMessage,\n\t\t\tMap<String, Object> hints) {\n\n\t\tbyte[] boundary = generateMultipartBoundary();\n\n\t\tmediaType = getMultipartMediaType(mediaType, boundary);\n\t\toutputMessage.getHeaders().setContentType(mediaType);\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(Hints.getLogPrefix(hints) + \"Encoding Publisher<Part>\");\n\t\t}\n\n\t\tFlux<DataBuffer> body = Flux.from(parts)\n\t\t\t\t.concatMap(part -> encodePart(boundary, part, outputMessage.bufferFactory()))\n\t\t\t\t.concatWith(generateLastLine(boundary, outputMessage.bufferFactory()))\n\t\t\t\t.doOnDiscard(DataBuffer.class, DataBufferUtils::release);\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tbody = body.doOnNext(buffer -> Hints.touchDataBuffer(buffer, hints, logger));\n\t\t}\n\n\t\treturn outputMessage.writeWith(body);\n\t}\n\n\tprivate <T> Flux<DataBuffer> encodePart(byte[] boundary, Part part, DataBufferFactory bufferFactory) {\n\t\tHttpHeaders headers = new HttpHeaders(part.headers());\n\n\t\tString name = part.name();\n\t\tif (!headers.containsKey(HttpHeaders.CONTENT_DISPOSITION)) {\n\t\t\theaders.setContentDispositionFormData(name,\n\t\t\t\t\t(part instanceof FilePart filePart ? filePart.filename() : null));\n\t\t}\n\n\t\treturn Flux.concat(\n\t\t\t\tgenerateBoundaryLine(boundary, bufferFactory),\n\t\t\t\tgeneratePartHeaders(headers, bufferFactory),\n\t\t\t\tpart.content(),\n\t\t\t\tgenerateNewLine(bufferFactory));\n\t}\n\n}"
  },
  "org.springframework.http.codec.multipart.PartHttpMessageWriter#write(parts,elementType,mediaType,outputMessage,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parts",
      "elementType",
      "mediaType",
      "outputMessage",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> write(Publisher<? extends Part> parts,\n\t\t\tResolvableType elementType, @Nullable MediaType mediaType, ReactiveHttpOutputMessage outputMessage,\n\t\t\tMap<String, Object> hints)",
    "source_code": "\tpublic Mono<Void> write(Publisher<? extends Part> parts,"
  },
  "org.springframework.http.codec.support.<unknown>#addCodec(codecs,codec)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize a codec and add it to the List.\n\t * @since 5.1.13\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "codecs",
      "codec"
    ],
    "position": {
      "column": 1,
      "line": 417
    },
    "return": "void",
    "signature": "protected void addCodec(List<T> codecs, T codec)",
    "source_code": "\tprotected <T> void addCodec(List<T> codecs, T codec) {\n\t\tinitCodec(codec);\n\t\tcodecs.add(codec);\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#configureDefaultCodec(codecConsumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "codecConsumer"
    ],
    "position": {
      "column": 1,
      "line": 324
    },
    "return": "void",
    "signature": "public void configureDefaultCodec(Consumer<Object> codecConsumer)",
    "source_code": "\tpublic void configureDefaultCodec(Consumer<Object> codecConsumer) {\n\t\tthis.codecConsumer = (this.codecConsumer != null ?\n\t\t\t\tthis.codecConsumer.andThen(codecConsumer) : codecConsumer);\n\t\tinitReaders();\n\t\tinitWriters();\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#enableLoggingRequestDetails(enable)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "enable"
    ],
    "position": {
      "column": 1,
      "line": 346
    },
    "return": "void",
    "signature": "public void enableLoggingRequestDetails(boolean enable)",
    "source_code": "\tpublic void enableLoggingRequestDetails(boolean enable) {\n\t\tif (!ObjectUtils.nullSafeEquals(this.enableLoggingRequestDetails, enable)) {\n\t\t\tthis.enableLoggingRequestDetails = enable;\n\t\t\tinitReaders();\n\t\t\tinitWriters();\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#extendObjectReaders(objectReaders)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for client or server specific Object readers.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "objectReaders"
    ],
    "position": {
      "column": 1,
      "line": 586
    },
    "return": "void",
    "signature": "protected void extendObjectReaders(List<HttpMessageReader<?>> objectReaders)",
    "source_code": "\tprotected void extendObjectReaders(List<HttpMessageReader<?>> objectReaders) {\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#extendObjectWriters(objectWriters)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for client or server specific Object writers.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "objectWriters"
    ],
    "position": {
      "column": 1,
      "line": 708
    },
    "return": "void",
    "signature": "protected void extendObjectWriters(List<HttpMessageWriter<?>> objectWriters)",
    "source_code": "\tprotected void extendObjectWriters(List<HttpMessageWriter<?>> objectWriters) {\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#extendTypedReaders(typedReaders)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for client or server specific typed readers.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "typedReaders"
    ],
    "position": {
      "column": 1,
      "line": 534
    },
    "return": "void",
    "signature": "protected void extendTypedReaders(List<HttpMessageReader<?>> typedReaders)",
    "source_code": "\tprotected void extendTypedReaders(List<HttpMessageReader<?>> typedReaders) {\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#extendTypedWriters(typedWriters)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for client or server specific typed writers.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "typedWriters"
    ],
    "position": {
      "column": 1,
      "line": 650
    },
    "return": "void",
    "signature": "protected void extendTypedWriters(List<HttpMessageWriter<?>> typedWriters)",
    "source_code": "\tprotected void extendTypedWriters(List<HttpMessageWriter<?>> typedWriters) {\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#initObjectReaders()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Reset and initialize object readers.\n\t * @since 5.3.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 548
    },
    "return": "void",
    "signature": "protected void initObjectReaders()",
    "source_code": "\tprotected void initObjectReaders() {\n\t\tthis.objectReaders.clear();\n\t\tif (!this.registerDefaults) {\n\t\t\treturn;\n\t\t}\n\t\tif (kotlinSerializationCborPresent) {\n\t\t\taddCodec(this.objectReaders, new DecoderHttpMessageReader<>(this.kotlinSerializationCborDecoder != null ?\n\t\t\t\t\t(KotlinSerializationCborDecoder) this.kotlinSerializationCborDecoder :\n\t\t\t\t\tnew KotlinSerializationCborDecoder()));\n\t\t}\n\t\tif (kotlinSerializationJsonPresent) {\n\t\t\taddCodec(this.objectReaders, new DecoderHttpMessageReader<>(getKotlinSerializationJsonDecoder()));\n\t\t}\n\t\tif (kotlinSerializationProtobufPresent) {\n\t\t\taddCodec(this.objectReaders,\n\t\t\t\t\tnew DecoderHttpMessageReader<>(this.kotlinSerializationProtobufDecoder != null ?\n\t\t\t\t\t\t\t(KotlinSerializationProtobufDecoder) this.kotlinSerializationProtobufDecoder :\n\t\t\t\t\t\t\tnew KotlinSerializationProtobufDecoder()));\n\t\t}\n\t\tif (jackson2Present) {\n\t\t\taddCodec(this.objectReaders, new DecoderHttpMessageReader<>(getJackson2JsonDecoder()));\n\t\t}\n\t\tif (jackson2SmilePresent) {\n\t\t\taddCodec(this.objectReaders, new DecoderHttpMessageReader<>(this.jackson2SmileDecoder != null ?\n\t\t\t\t\t(Jackson2SmileDecoder) this.jackson2SmileDecoder : new Jackson2SmileDecoder()));\n\t\t}\n\t\tif (jaxb2Present) {\n\t\t\taddCodec(this.objectReaders, new DecoderHttpMessageReader<>(this.jaxb2Decoder != null ?\n\t\t\t\t\t(Jaxb2XmlDecoder) this.jaxb2Decoder : new Jaxb2XmlDecoder()));\n\t\t}\n\n\t\t// client vs server..\n\t\textendObjectReaders(this.objectReaders);\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#initObjectWriters()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Reset and initialize object writers.\n\t * @since 5.3.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 664
    },
    "return": "void",
    "signature": "protected void initObjectWriters()",
    "source_code": "\tprotected void initObjectWriters() {\n\t\tthis.objectWriters.clear();\n\t\tif (!this.registerDefaults) {\n\t\t\treturn;\n\t\t}\n\t\tthis.objectWriters.addAll(getBaseObjectWriters());\n\t\textendObjectWriters(this.objectWriters);\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#initReaders()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Reset and initialize typed readers and object readers.\n\t * @since 5.3.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 195
    },
    "return": "void",
    "signature": "protected void initReaders()",
    "source_code": "\tprotected void initReaders() {\n\t\tinitTypedReaders();\n\t\tinitObjectReaders();\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#initTypedReaders()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Reset and initialize typed readers.\n\t * @since 5.3.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 383
    },
    "return": "void",
    "signature": "protected void initTypedReaders()",
    "source_code": "\tprotected void initTypedReaders() {\n\t\tthis.typedReaders.clear();\n\t\tif (!this.registerDefaults) {\n\t\t\treturn;\n\t\t}\n\t\taddCodec(this.typedReaders, new DecoderHttpMessageReader<>(new ByteArrayDecoder()));\n\t\taddCodec(this.typedReaders, new DecoderHttpMessageReader<>(new ByteBufferDecoder()));\n\t\taddCodec(this.typedReaders, new DecoderHttpMessageReader<>(new DataBufferDecoder()));\n\t\tif (nettyByteBufPresent) {\n\t\t\taddCodec(this.typedReaders, new DecoderHttpMessageReader<>(new NettyByteBufDecoder()));\n\t\t}\n\t\tif (netty5BufferPresent) {\n\t\t\taddCodec(this.typedReaders, new DecoderHttpMessageReader<>(new Netty5BufferDecoder()));\n\t\t}\n\t\taddCodec(this.typedReaders, new ResourceHttpMessageReader(new ResourceDecoder()));\n\t\taddCodec(this.typedReaders, new DecoderHttpMessageReader<>(StringDecoder.textPlainOnly()));\n\t\tif (protobufPresent) {\n\t\t\taddCodec(this.typedReaders, new DecoderHttpMessageReader<>(this.protobufDecoder != null ?\n\t\t\t\t\t(ProtobufDecoder) this.protobufDecoder : new ProtobufDecoder()));\n\t\t}\n\t\telse if (kotlinSerializationProtobufPresent) {\n\t\t\taddCodec(this.typedReaders, new DecoderHttpMessageReader<>(this.kotlinSerializationProtobufDecoder != null ?\n\t\t\t\t\t(KotlinSerializationProtobufDecoder) this.kotlinSerializationProtobufDecoder : new KotlinSerializationProtobufDecoder()));\n\t\t}\n\t\taddCodec(this.typedReaders, new FormHttpMessageReader());\n\n\t\t// client vs server..\n\t\textendTypedReaders(this.typedReaders);\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#initTypedWriters()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Reset and initialize typed writers.\n\t * @since 5.3.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 612
    },
    "return": "void",
    "signature": "protected void initTypedWriters()",
    "source_code": "\tprotected void initTypedWriters() {\n\t\tthis.typedWriters.clear();\n\t\tif (!this.registerDefaults) {\n\t\t\treturn;\n\t\t}\n\t\tthis.typedWriters.addAll(getBaseTypedWriters());\n\t\textendTypedWriters(this.typedWriters);\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#initWriters()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Reset and initialize typed writers and object writers.\n\t * @since 5.3.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "void",
    "signature": "protected void initWriters()",
    "source_code": "\tprotected void initWriters() {\n\t\tinitTypedWriters();\n\t\tinitObjectWriters();\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#isEnableLoggingRequestDetails()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 356
    },
    "return": "Boolean",
    "signature": "public Boolean isEnableLoggingRequestDetails()",
    "source_code": "\tpublic Boolean isEnableLoggingRequestDetails() {\n\t\treturn this.enableLoggingRequestDetails;\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#jackson2JsonDecoder(decoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "decoder"
    ],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "void",
    "signature": "public void jackson2JsonDecoder(Decoder<?> decoder)",
    "source_code": "\tpublic void jackson2JsonDecoder(Decoder<?> decoder) {\n\t\tthis.jackson2JsonDecoder = decoder;\n\t\tinitObjectReaders();\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#jackson2JsonEncoder(encoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encoder"
    ],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "void",
    "signature": "public void jackson2JsonEncoder(Encoder<?> encoder)",
    "source_code": "\tpublic void jackson2JsonEncoder(Encoder<?> encoder) {\n\t\tthis.jackson2JsonEncoder = encoder;\n\t\tinitObjectWriters();\n\t\tinitTypedWriters();\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#jackson2SmileDecoder(decoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "decoder"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "void",
    "signature": "public void jackson2SmileDecoder(Decoder<?> decoder)",
    "source_code": "\tpublic void jackson2SmileDecoder(Decoder<?> decoder) {\n\t\tthis.jackson2SmileDecoder = decoder;\n\t\tinitObjectReaders();\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#jackson2SmileEncoder(encoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encoder"
    ],
    "position": {
      "column": 1,
      "line": 257
    },
    "return": "void",
    "signature": "public void jackson2SmileEncoder(Encoder<?> encoder)",
    "source_code": "\tpublic void jackson2SmileEncoder(Encoder<?> encoder) {\n\t\tthis.jackson2SmileEncoder = encoder;\n\t\tinitObjectWriters();\n\t\tinitTypedWriters();\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#jaxb2Decoder(decoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "decoder"
    ],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "void",
    "signature": "public void jaxb2Decoder(Decoder<?> decoder)",
    "source_code": "\tpublic void jaxb2Decoder(Decoder<?> decoder) {\n\t\tthis.jaxb2Decoder = decoder;\n\t\tinitObjectReaders();\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#jaxb2Encoder(encoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encoder"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "void",
    "signature": "public void jaxb2Encoder(Encoder<?> encoder)",
    "source_code": "\tpublic void jaxb2Encoder(Encoder<?> encoder) {\n\t\tthis.jaxb2Encoder = encoder;\n\t\tinitObjectWriters();\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#kotlinSerializationCborDecoder(decoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "decoder"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "void",
    "signature": "public void kotlinSerializationCborDecoder(Decoder<?> decoder)",
    "source_code": "\tpublic void kotlinSerializationCborDecoder(Decoder<?> decoder) {\n\t\tthis.kotlinSerializationCborDecoder = decoder;\n\t\tinitObjectReaders();\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#kotlinSerializationCborEncoder(encoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encoder"
    ],
    "position": {
      "column": 1,
      "line": 294
    },
    "return": "void",
    "signature": "public void kotlinSerializationCborEncoder(Encoder<?> encoder)",
    "source_code": "\tpublic void kotlinSerializationCborEncoder(Encoder<?> encoder) {\n\t\tthis.kotlinSerializationCborEncoder = encoder;\n\t\tinitObjectWriters();\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#kotlinSerializationJsonDecoder(decoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "decoder"
    ],
    "position": {
      "column": 1,
      "line": 300
    },
    "return": "void",
    "signature": "public void kotlinSerializationJsonDecoder(Decoder<?> decoder)",
    "source_code": "\tpublic void kotlinSerializationJsonDecoder(Decoder<?> decoder) {\n\t\tthis.kotlinSerializationJsonDecoder = decoder;\n\t\tinitObjectReaders();\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#kotlinSerializationJsonEncoder(encoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encoder"
    ],
    "position": {
      "column": 1,
      "line": 306
    },
    "return": "void",
    "signature": "public void kotlinSerializationJsonEncoder(Encoder<?> encoder)",
    "source_code": "\tpublic void kotlinSerializationJsonEncoder(Encoder<?> encoder) {\n\t\tthis.kotlinSerializationJsonEncoder = encoder;\n\t\tinitObjectWriters();\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#kotlinSerializationProtobufDecoder(decoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "decoder"
    ],
    "position": {
      "column": 1,
      "line": 312
    },
    "return": "void",
    "signature": "public void kotlinSerializationProtobufDecoder(Decoder<?> decoder)",
    "source_code": "\tpublic void kotlinSerializationProtobufDecoder(Decoder<?> decoder) {\n\t\tthis.kotlinSerializationProtobufDecoder = decoder;\n\t\tinitObjectReaders();\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#kotlinSerializationProtobufEncoder(encoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encoder"
    ],
    "position": {
      "column": 1,
      "line": 318
    },
    "return": "void",
    "signature": "public void kotlinSerializationProtobufEncoder(Encoder<?> encoder)",
    "source_code": "\tpublic void kotlinSerializationProtobufEncoder(Encoder<?> encoder) {\n\t\tthis.kotlinSerializationProtobufEncoder = encoder;\n\t\tinitObjectWriters();\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#maxInMemorySize()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "Integer",
    "signature": "public Integer maxInMemorySize()",
    "source_code": "\tpublic Integer maxInMemorySize() {\n\t\treturn this.maxInMemorySize;\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#maxInMemorySize(byteCount)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "byteCount"
    ],
    "position": {
      "column": 1,
      "line": 332
    },
    "return": "void",
    "signature": "public void maxInMemorySize(int byteCount)",
    "source_code": "\tpublic void maxInMemorySize(int byteCount) {\n\t\tif (!ObjectUtils.nullSafeEquals(this.maxInMemorySize, byteCount)) {\n\t\t\tthis.maxInMemorySize = byteCount;\n\t\t\tinitReaders();\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#protobufDecoder(decoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "decoder"
    ],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "void",
    "signature": "public void protobufDecoder(Decoder<?> decoder)",
    "source_code": "\tpublic void protobufDecoder(Decoder<?> decoder) {\n\t\tthis.protobufDecoder = decoder;\n\t\tinitTypedReaders();\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#protobufEncoder(encoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encoder"
    ],
    "position": {
      "column": 1,
      "line": 270
    },
    "return": "void",
    "signature": "public void protobufEncoder(Encoder<?> encoder)",
    "source_code": "\tpublic void protobufEncoder(Encoder<?> encoder) {\n\t\tthis.protobufEncoder = encoder;\n\t\tinitTypedWriters();\n\t}"
  },
  "org.springframework.http.codec.support.DefaultCustomCodecs": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Default implementation of {@code CustomCodecs}.\n\t */",
    "kind": "class",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "signature": "protected class DefaultCustomCodecs",
    "source_code": "\tprotected static final class DefaultCustomCodecs implements CustomCodecs {\n\n\t\tprivate final Map<HttpMessageReader<?>, Boolean> typedReaders = new LinkedHashMap<>(4);\n\n\t\tprivate final Map<HttpMessageWriter<?>, Boolean> typedWriters = new LinkedHashMap<>(4);\n\n\t\tprivate final Map<HttpMessageReader<?>, Boolean> objectReaders = new LinkedHashMap<>(4);\n\n\t\tprivate final Map<HttpMessageWriter<?>, Boolean> objectWriters = new LinkedHashMap<>(4);\n\n\t\tprivate final List<Consumer<DefaultCodecConfig>> defaultConfigConsumers = new ArrayList<>(4);\n\n\t\tDefaultCustomCodecs() {\n\t\t}\n\n\t\t/**\n\t\t * Create a deep copy of the given {@link DefaultCustomCodecs}.\n\t\t * @since 5.1.12\n\t\t */\n\t\tDefaultCustomCodecs(DefaultCustomCodecs other) {\n\t\t\tthis.typedReaders.putAll(other.typedReaders);\n\t\t\tthis.typedWriters.putAll(other.typedWriters);\n\t\t\tthis.objectReaders.putAll(other.objectReaders);\n\t\t\tthis.objectWriters.putAll(other.objectWriters);\n\t\t}\n\n\t\t@Override\n\t\tpublic void register(Object codec) {\n\t\t\taddCodec(codec, false);\n\t\t}\n\n\t\t@Override\n\t\tpublic void registerWithDefaultConfig(Object codec) {\n\t\t\taddCodec(codec, true);\n\t\t}\n\n\t\t@Override\n\t\tpublic void registerWithDefaultConfig(Object codec, Consumer<DefaultCodecConfig> configConsumer) {\n\t\t\taddCodec(codec, false);\n\t\t\tthis.defaultConfigConsumers.add(configConsumer);\n\t\t}\n\n\t\t@SuppressWarnings(\"deprecation\")\n\t\t@Override\n\t\tpublic void decoder(Decoder<?> decoder) {\n\t\t\taddCodec(decoder, false);\n\t\t}\n\n\t\t@SuppressWarnings(\"deprecation\")\n\t\t@Override\n\t\tpublic void encoder(Encoder<?> encoder) {\n\t\t\taddCodec(encoder, false);\n\t\t}\n\n\t\t@SuppressWarnings(\"deprecation\")\n\t\t@Override\n\t\tpublic void reader(HttpMessageReader<?> reader) {\n\t\t\taddCodec(reader, false);\n\t\t}\n\n\t\t@SuppressWarnings(\"deprecation\")\n\t\t@Override\n\t\tpublic void writer(HttpMessageWriter<?> writer) {\n\t\t\taddCodec(writer, false);\n\t\t}\n\n\t\t@SuppressWarnings(\"deprecation\")\n\t\t@Override\n\t\tpublic void withDefaultCodecConfig(Consumer<DefaultCodecConfig> codecsConfigConsumer) {\n\t\t\tthis.defaultConfigConsumers.add(codecsConfigConsumer);\n\t\t}\n\n\t\tprivate void addCodec(Object codec, boolean applyDefaultConfig) {\n\n\t\t\tif (codec instanceof Decoder<?> decoder) {\n\t\t\t\tcodec = new DecoderHttpMessageReader<>(decoder);\n\t\t\t}\n\t\t\telse if (codec instanceof Encoder<?> encoder) {\n\t\t\t\tcodec = new EncoderHttpMessageWriter<>(encoder);\n\t\t\t}\n\n\t\t\tif (codec instanceof HttpMessageReader<?> reader) {\n\t\t\t\tboolean canReadToObject = reader.canRead(ResolvableType.forClass(Object.class), null);\n\t\t\t\t(canReadToObject ? this.objectReaders : this.typedReaders).put(reader, applyDefaultConfig);\n\t\t\t}\n\t\t\telse if (codec instanceof HttpMessageWriter<?> writer) {\n\t\t\t\tboolean canWriteObject = writer.canWrite(ResolvableType.forClass(Object.class), null);\n\t\t\t\t(canWriteObject ? this.objectWriters : this.typedWriters).put(writer, applyDefaultConfig);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"Unexpected codec type: \" + codec.getClass().getName());\n\t\t\t}\n\t\t}\n\n\t\t// Package private accessors...\n\n\t\tMap<HttpMessageReader<?>, Boolean> getTypedReaders() {\n\t\t\treturn this.typedReaders;\n\t\t}\n\n\t\tMap<HttpMessageWriter<?>, Boolean> getTypedWriters() {\n\t\t\treturn this.typedWriters;\n\t\t}\n\n\t\tMap<HttpMessageReader<?>, Boolean> getObjectReaders() {\n\t\t\treturn this.objectReaders;\n\t\t}\n\n\t\tMap<HttpMessageWriter<?>, Boolean> getObjectWriters() {\n\t\t\treturn this.objectWriters;\n\t\t}\n\n\t\tList<Consumer<DefaultCodecConfig>> getDefaultConfigConsumers() {\n\t\t\treturn this.defaultConfigConsumers;\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.support.DefaultCustomCodecs#clone()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "CodecConfigurer",
    "signature": "public CodecConfigurer clone()",
    "source_code": "\tpublic abstract CodecConfigurer clone();"
  },
  "org.springframework.http.codec.support.DefaultCustomCodecs#cloneDefaultCodecs()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses should override this to create a deep copy of\n\t * {@link BaseDefaultCodecs} which can be client or server specific.\n\t * @since 5.1.12\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "BaseDefaultCodecs",
    "signature": "protected BaseDefaultCodecs cloneDefaultCodecs()",
    "source_code": "\tprotected abstract BaseDefaultCodecs cloneDefaultCodecs();"
  },
  "org.springframework.http.codec.support.DefaultCustomCodecs#customCodecs()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "CustomCodecs",
    "signature": "public CustomCodecs customCodecs()",
    "source_code": "\tpublic CustomCodecs customCodecs() {\n\t\treturn this.customCodecs;\n\t}"
  },
  "org.springframework.http.codec.support.DefaultCustomCodecs#decoder(decoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "decoder"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "void",
    "signature": "public void decoder(Decoder<?> decoder)",
    "source_code": "\t\tpublic void decoder(Decoder<?> decoder) {\n\t\t\taddCodec(decoder, false);\n\t\t}"
  },
  "org.springframework.http.codec.support.DefaultCustomCodecs#defaultCodecs()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "DefaultCodecs",
    "signature": "public DefaultCodecs defaultCodecs()",
    "source_code": "\tpublic DefaultCodecs defaultCodecs() {\n\t\treturn this.defaultCodecs;\n\t}"
  },
  "org.springframework.http.codec.support.DefaultCustomCodecs#encoder(encoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encoder"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "void",
    "signature": "public void encoder(Encoder<?> encoder)",
    "source_code": "\t\tpublic void encoder(Encoder<?> encoder) {\n\t\t\taddCodec(encoder, false);\n\t\t}"
  },
  "org.springframework.http.codec.support.DefaultCustomCodecs#reader(reader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "reader"
    ],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "void",
    "signature": "public void reader(HttpMessageReader<?> reader)",
    "source_code": "\t\tpublic void reader(HttpMessageReader<?> reader) {\n\t\t\taddCodec(reader, false);\n\t\t}"
  },
  "org.springframework.http.codec.support.DefaultCustomCodecs#register(codec)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "codec"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "void",
    "signature": "public void register(Object codec)",
    "source_code": "\t\tpublic void register(Object codec) {\n\t\t\taddCodec(codec, false);\n\t\t}"
  },
  "org.springframework.http.codec.support.DefaultCustomCodecs#registerDefaults(shouldRegister)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "shouldRegister"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void registerDefaults(boolean shouldRegister)",
    "source_code": "\tpublic void registerDefaults(boolean shouldRegister) {\n\t\tthis.defaultCodecs.registerDefaults(shouldRegister);\n\t}"
  },
  "org.springframework.http.codec.support.DefaultCustomCodecs#registerWithDefaultConfig(codec)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "codec"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "void",
    "signature": "public void registerWithDefaultConfig(Object codec)",
    "source_code": "\t\tpublic void registerWithDefaultConfig(Object codec) {\n\t\t\taddCodec(codec, true);\n\t\t}"
  },
  "org.springframework.http.codec.support.DefaultCustomCodecs#registerWithDefaultConfig(codec,configConsumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "codec",
      "configConsumer"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "void",
    "signature": "public void registerWithDefaultConfig(Object codec, Consumer<DefaultCodecConfig> configConsumer)",
    "source_code": "\t\tpublic void registerWithDefaultConfig(Object codec, Consumer<DefaultCodecConfig> configConsumer) {\n\t\t\taddCodec(codec, false);\n\t\t\tthis.defaultConfigConsumers.add(configConsumer);\n\t\t}"
  },
  "org.springframework.http.codec.support.DefaultCustomCodecs#withDefaultCodecConfig(codecsConfigConsumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "codecsConfigConsumer"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "void",
    "signature": "public void withDefaultCodecConfig(Consumer<DefaultCodecConfig> codecsConfigConsumer)",
    "source_code": "\t\tpublic void withDefaultCodecConfig(Consumer<DefaultCodecConfig> codecsConfigConsumer) {\n\t\t\tthis.defaultConfigConsumers.add(codecsConfigConsumer);\n\t\t}"
  },
  "org.springframework.http.codec.support.DefaultCustomCodecs#writer(writer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "writer"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "void",
    "signature": "public void writer(HttpMessageWriter<?> writer)",
    "source_code": "\t\tpublic void writer(HttpMessageWriter<?> writer) {\n\t\t\taddCodec(writer, false);\n\t\t}"
  },
  "org.springframework.http.codec.support.customCodecs": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "signature": "protected DefaultCustomCodecs customCodecs",
    "source_code": "\tprotected final DefaultCustomCodecs customCodecs;",
    "type": "DefaultCustomCodecs"
  },
  "org.springframework.http.codec.support.defaultCodecs": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "signature": "protected BaseDefaultCodecs defaultCodecs",
    "source_code": "\tprotected final BaseDefaultCodecs defaultCodecs;",
    "type": "BaseDefaultCodecs"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A builder used to create {@link ObjectMapper} instances with a fluent API.\n *\n * <p>It customizes Jackson's default properties with the following ones:\n * <ul>\n * <li>{@link MapperFeature#DEFAULT_VIEW_INCLUSION} is disabled</li>\n * <li>{@link DeserializationFeature#FAIL_ON_UNKNOWN_PROPERTIES} is disabled</li>\n * </ul>\n *\n * <p>It also automatically registers the following well-known modules if they are\n * detected on the classpath:\n * <ul>\n * <li><a href=\"https://github.com/FasterXML/jackson-datatype-jdk8\">jackson-datatype-jdk8</a>:\n * support for other Java 8 types like {@link java.util.Optional}</li>\n * <li><a href=\"https://github.com/FasterXML/jackson-datatype-jsr310\">jackson-datatype-jsr310</a>:\n * support for Java 8 Date &amp; Time API types</li>\n * <li><a href=\"https://github.com/FasterXML/jackson-module-kotlin\">jackson-module-kotlin</a>:\n * support for Kotlin classes and data classes</li>\n * </ul>\n *\n * @author Sebastien Deleuze\n * @author Juergen Hoeller\n * @author Tadaya Tsuyukubo\n * @author Edd\u00fa Mel\u00e9ndez\n * @since 4.1.1\n * @see #build()\n * @see #configure(ObjectMapper)\n * @see Jackson2ObjectMapperFactoryBean\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "signature": "public class Jackson2ObjectMapperBuilder",
    "source_code": "public class Jackson2ObjectMapperBuilder {\n\n\tprivate final Map<Class<?>, Class<?>> mixIns = new LinkedHashMap<>();\n\n\tprivate final Map<Class<?>, JsonSerializer<?>> serializers = new LinkedHashMap<>();\n\n\tprivate final Map<Class<?>, JsonDeserializer<?>> deserializers = new LinkedHashMap<>();\n\n\tprivate final Map<PropertyAccessor, JsonAutoDetect.Visibility> visibilities = new LinkedHashMap<>();\n\n\tprivate final Map<Object, Boolean> features = new LinkedHashMap<>();\n\n\tprivate boolean createXmlMapper = false;\n\n\t@Nullable\n\tprivate JsonFactory factory;\n\n\t@Nullable\n\tprivate DateFormat dateFormat;\n\n\t@Nullable\n\tprivate Locale locale;\n\n\t@Nullable\n\tprivate TimeZone timeZone;\n\n\t@Nullable\n\tprivate AnnotationIntrospector annotationIntrospector;\n\n\t@Nullable\n\tprivate PropertyNamingStrategy propertyNamingStrategy;\n\n\t@Nullable\n\tprivate TypeResolverBuilder<?> defaultTyping;\n\n\t@Nullable\n\tprivate JsonInclude.Value serializationInclusion;\n\n\t@Nullable\n\tprivate FilterProvider filters;\n\n\t@Nullable\n\tprivate List<Module> modules;\n\n\t@Nullable\n\tprivate Class<? extends Module>[] moduleClasses;\n\n\tprivate boolean findModulesViaServiceLoader = false;\n\n\tprivate boolean findWellKnownModules = true;\n\n\tprivate ClassLoader moduleClassLoader = getClass().getClassLoader();\n\n\t@Nullable\n\tprivate HandlerInstantiator handlerInstantiator;\n\n\t@Nullable\n\tprivate ApplicationContext applicationContext;\n\n\t@Nullable\n\tprivate Boolean defaultUseWrapper;\n\n\t@Nullable\n\tprivate Consumer<ObjectMapper> configurer;\n\n\n\t/**\n\t * If set to {@code true}, an {@link XmlMapper} will be created using its\n\t * default constructor. This is only applicable to {@link #build()} calls,\n\t * not to {@link #configure} calls.\n\t */\n\tpublic Jackson2ObjectMapperBuilder createXmlMapper(boolean createXmlMapper) {\n\t\tthis.createXmlMapper = createXmlMapper;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Define the {@link JsonFactory} to be used to create the {@link ObjectMapper}\n\t * instance.\n\t * @since 5.0\n\t */\n\tpublic Jackson2ObjectMapperBuilder factory(JsonFactory factory) {\n\t\tthis.factory = factory;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Define the format for date/time with the given {@link DateFormat}.\n\t * <p>Note: Setting this property makes the exposed {@link ObjectMapper}\n\t * non-thread-safe, according to Jackson's thread safety rules.\n\t * @see #simpleDateFormat(String)\n\t */\n\tpublic Jackson2ObjectMapperBuilder dateFormat(DateFormat dateFormat) {\n\t\tthis.dateFormat = dateFormat;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Define the date/time format with a {@link SimpleDateFormat}.\n\t * <p>Note: Setting this property makes the exposed {@link ObjectMapper}\n\t * non-thread-safe, according to Jackson's thread safety rules.\n\t * @see #dateFormat(DateFormat)\n\t */\n\tpublic Jackson2ObjectMapperBuilder simpleDateFormat(String format) {\n\t\tthis.dateFormat = new SimpleDateFormat(format);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Override the default {@link Locale} to use for formatting.\n\t * Default value used is {@link Locale#getDefault()}.\n\t * @since 4.1.5\n\t */\n\tpublic Jackson2ObjectMapperBuilder locale(Locale locale) {\n\t\tthis.locale = locale;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Override the default {@link Locale} to use for formatting.\n\t * Default value used is {@link Locale#getDefault()}.\n\t * @param localeString the locale ID as a String representation\n\t * @since 4.1.5\n\t */\n\tpublic Jackson2ObjectMapperBuilder locale(String localeString) {\n\t\tthis.locale = StringUtils.parseLocale(localeString);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Override the default {@link TimeZone} to use for formatting.\n\t * Default value used is UTC (NOT local timezone).\n\t * @since 4.1.5\n\t */\n\tpublic Jackson2ObjectMapperBuilder timeZone(TimeZone timeZone) {\n\t\tthis.timeZone = timeZone;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Override the default {@link TimeZone} to use for formatting.\n\t * Default value used is UTC (NOT local timezone).\n\t * @param timeZoneString the zone ID as a String representation\n\t * @since 4.1.5\n\t */\n\tpublic Jackson2ObjectMapperBuilder timeZone(String timeZoneString) {\n\t\tthis.timeZone = StringUtils.parseTimeZoneString(timeZoneString);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set an {@link AnnotationIntrospector} for both serialization and deserialization.\n\t */\n\tpublic Jackson2ObjectMapperBuilder annotationIntrospector(AnnotationIntrospector annotationIntrospector) {\n\t\tthis.annotationIntrospector = annotationIntrospector;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Alternative to {@link #annotationIntrospector(AnnotationIntrospector)}\n\t * that allows combining with rather than replacing the currently set\n\t * introspector, e.g. via\n\t * {@link AnnotationIntrospectorPair#pair(AnnotationIntrospector, AnnotationIntrospector)}.\n\t * @param pairingFunction a function to apply to the currently set\n\t * introspector (possibly {@code null}); the result of the function becomes\n\t * the new introspector.\n\t * @since 5.2.4\n\t */\n\tpublic Jackson2ObjectMapperBuilder annotationIntrospector(\n\t\t\tFunction<AnnotationIntrospector, AnnotationIntrospector> pairingFunction) {\n\n\t\tthis.annotationIntrospector = pairingFunction.apply(this.annotationIntrospector);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Specify a {@link com.fasterxml.jackson.databind.PropertyNamingStrategy} to\n\t * configure the {@link ObjectMapper} with.\n\t */\n\tpublic Jackson2ObjectMapperBuilder propertyNamingStrategy(PropertyNamingStrategy propertyNamingStrategy) {\n\t\tthis.propertyNamingStrategy = propertyNamingStrategy;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Specify a {@link TypeResolverBuilder} to use for Jackson's default typing.\n\t * @since 4.2.2\n\t */\n\tpublic Jackson2ObjectMapperBuilder defaultTyping(TypeResolverBuilder<?> typeResolverBuilder) {\n\t\tthis.defaultTyping = typeResolverBuilder;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set a custom inclusion strategy for serialization.\n\t * @see com.fasterxml.jackson.annotation.JsonInclude.Include\n\t */\n\tpublic Jackson2ObjectMapperBuilder serializationInclusion(JsonInclude.Include inclusion) {\n\t\treturn serializationInclusion(JsonInclude.Value.construct(inclusion, inclusion));\n\t}\n\n\t/**\n\t * Set a custom inclusion strategy for serialization.\n\t * @since 5.3\n\t * @see com.fasterxml.jackson.annotation.JsonInclude.Value\n\t */\n\tpublic Jackson2ObjectMapperBuilder serializationInclusion(JsonInclude.Value serializationInclusion) {\n\t\tthis.serializationInclusion = serializationInclusion;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the global filters to use in order to support {@link JsonFilter @JsonFilter} annotated POJO.\n\t * @since 4.2\n\t * @see MappingJacksonValue#setFilters(FilterProvider)\n\t */\n\tpublic Jackson2ObjectMapperBuilder filters(FilterProvider filters) {\n\t\tthis.filters = filters;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add mix-in annotations to use for augmenting specified class or interface.\n\t * @param target class (or interface) whose annotations to effectively override\n\t * @param mixinSource class (or interface) whose annotations are to be \"added\"\n\t * to target's annotations as value\n\t * @since 4.1.2\n\t * @see com.fasterxml.jackson.databind.ObjectMapper#addMixIn(Class, Class)\n\t */\n\tpublic Jackson2ObjectMapperBuilder mixIn(Class<?> target, Class<?> mixinSource) {\n\t\tthis.mixIns.put(target, mixinSource);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add mix-in annotations to use for augmenting specified class or interface.\n\t * @param mixIns a Map of entries with target classes (or interface) whose annotations\n\t * to effectively override as key and mix-in classes (or interface) whose\n\t * annotations are to be \"added\" to target's annotations as value.\n\t * @since 4.1.2\n\t * @see com.fasterxml.jackson.databind.ObjectMapper#addMixIn(Class, Class)\n\t */\n\tpublic Jackson2ObjectMapperBuilder mixIns(Map<Class<?>, Class<?>> mixIns) {\n\t\tthis.mixIns.putAll(mixIns);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Configure custom serializers. Each serializer is registered for the type\n\t * returned by {@link JsonSerializer#handledType()}, which must not be {@code null}.\n\t * @see #serializersByType(Map)\n\t */\n\tpublic Jackson2ObjectMapperBuilder serializers(JsonSerializer<?>... serializers) {\n\t\tfor (JsonSerializer<?> serializer : serializers) {\n\t\t\tClass<?> handledType = serializer.handledType();\n\t\t\tif (handledType == null || handledType == Object.class) {\n\t\t\t\tthrow new IllegalArgumentException(\"Unknown handled type in \" + serializer.getClass().getName());\n\t\t\t}\n\t\t\tthis.serializers.put(serializer.handledType(), serializer);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Configure a custom serializer for the given type.\n\t * @since 4.1.2\n\t * @see #serializers(JsonSerializer...)\n\t */\n\tpublic Jackson2ObjectMapperBuilder serializerByType(Class<?> type, JsonSerializer<?> serializer) {\n\t\tthis.serializers.put(type, serializer);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Configure custom serializers for the given types.\n\t * @see #serializers(JsonSerializer...)\n\t */\n\tpublic Jackson2ObjectMapperBuilder serializersByType(Map<Class<?>, JsonSerializer<?>> serializers) {\n\t\tthis.serializers.putAll(serializers);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Configure custom deserializers. Each deserializer is registered for the type\n\t * returned by {@link JsonDeserializer#handledType()}, which must not be {@code null}.\n\t * @since 4.3\n\t * @see #deserializersByType(Map)\n\t */\n\tpublic Jackson2ObjectMapperBuilder deserializers(JsonDeserializer<?>... deserializers) {\n\t\tfor (JsonDeserializer<?> deserializer : deserializers) {\n\t\t\tClass<?> handledType = deserializer.handledType();\n\t\t\tif (handledType == null || handledType == Object.class) {\n\t\t\t\tthrow new IllegalArgumentException(\"Unknown handled type in \" + deserializer.getClass().getName());\n\t\t\t}\n\t\t\tthis.deserializers.put(deserializer.handledType(), deserializer);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Configure a custom deserializer for the given type.\n\t * @since 4.1.2\n\t */\n\tpublic Jackson2ObjectMapperBuilder deserializerByType(Class<?> type, JsonDeserializer<?> deserializer) {\n\t\tthis.deserializers.put(type, deserializer);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Configure custom deserializers for the given types.\n\t */\n\tpublic Jackson2ObjectMapperBuilder deserializersByType(Map<Class<?>, JsonDeserializer<?>> deserializers) {\n\t\tthis.deserializers.putAll(deserializers);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Shortcut for {@link MapperFeature#AUTO_DETECT_FIELDS} option.\n\t */\n\tpublic Jackson2ObjectMapperBuilder autoDetectFields(boolean autoDetectFields) {\n\t\tthis.features.put(MapperFeature.AUTO_DETECT_FIELDS, autoDetectFields);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Shortcut for {@link MapperFeature#AUTO_DETECT_SETTERS}/\n\t * {@link MapperFeature#AUTO_DETECT_GETTERS}/{@link MapperFeature#AUTO_DETECT_IS_GETTERS}\n\t * options.\n\t */\n\tpublic Jackson2ObjectMapperBuilder autoDetectGettersSetters(boolean autoDetectGettersSetters) {\n\t\tthis.features.put(MapperFeature.AUTO_DETECT_GETTERS, autoDetectGettersSetters);\n\t\tthis.features.put(MapperFeature.AUTO_DETECT_SETTERS, autoDetectGettersSetters);\n\t\tthis.features.put(MapperFeature.AUTO_DETECT_IS_GETTERS, autoDetectGettersSetters);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Shortcut for {@link MapperFeature#DEFAULT_VIEW_INCLUSION} option.\n\t */\n\tpublic Jackson2ObjectMapperBuilder defaultViewInclusion(boolean defaultViewInclusion) {\n\t\tthis.features.put(MapperFeature.DEFAULT_VIEW_INCLUSION, defaultViewInclusion);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Shortcut for {@link DeserializationFeature#FAIL_ON_UNKNOWN_PROPERTIES} option.\n\t */\n\tpublic Jackson2ObjectMapperBuilder failOnUnknownProperties(boolean failOnUnknownProperties) {\n\t\tthis.features.put(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, failOnUnknownProperties);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Shortcut for {@link SerializationFeature#FAIL_ON_EMPTY_BEANS} option.\n\t */\n\tpublic Jackson2ObjectMapperBuilder failOnEmptyBeans(boolean failOnEmptyBeans) {\n\t\tthis.features.put(SerializationFeature.FAIL_ON_EMPTY_BEANS, failOnEmptyBeans);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Shortcut for {@link SerializationFeature#INDENT_OUTPUT} option.\n\t */\n\tpublic Jackson2ObjectMapperBuilder indentOutput(boolean indentOutput) {\n\t\tthis.features.put(SerializationFeature.INDENT_OUTPUT, indentOutput);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Define if a wrapper will be used for indexed (List, array) properties or not by\n\t * default (only applies to {@link XmlMapper}).\n\t * @since 4.3\n\t */\n\tpublic Jackson2ObjectMapperBuilder defaultUseWrapper(boolean defaultUseWrapper) {\n\t\tthis.defaultUseWrapper = defaultUseWrapper;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Specify visibility to limit what kind of properties are auto-detected.\n\t * @since 5.1\n\t * @see com.fasterxml.jackson.annotation.PropertyAccessor\n\t * @see com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility\n\t */\n\tpublic Jackson2ObjectMapperBuilder visibility(PropertyAccessor accessor, JsonAutoDetect.Visibility visibility) {\n\t\tthis.visibilities.put(accessor, visibility);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Specify features to enable.\n\t * @see com.fasterxml.jackson.core.JsonParser.Feature\n\t * @see com.fasterxml.jackson.core.JsonGenerator.Feature\n\t * @see com.fasterxml.jackson.databind.SerializationFeature\n\t * @see com.fasterxml.jackson.databind.DeserializationFeature\n\t * @see com.fasterxml.jackson.databind.MapperFeature\n\t */\n\tpublic Jackson2ObjectMapperBuilder featuresToEnable(Object... featuresToEnable) {\n\t\tfor (Object feature : featuresToEnable) {\n\t\t\tthis.features.put(feature, Boolean.TRUE);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Specify features to disable.\n\t * @see com.fasterxml.jackson.core.JsonParser.Feature\n\t * @see com.fasterxml.jackson.core.JsonGenerator.Feature\n\t * @see com.fasterxml.jackson.databind.SerializationFeature\n\t * @see com.fasterxml.jackson.databind.DeserializationFeature\n\t * @see com.fasterxml.jackson.databind.MapperFeature\n\t */\n\tpublic Jackson2ObjectMapperBuilder featuresToDisable(Object... featuresToDisable) {\n\t\tfor (Object feature : featuresToDisable) {\n\t\t\tthis.features.put(feature, Boolean.FALSE);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Specify the modules to be registered with the {@link ObjectMapper}.\n\t * <p>Multiple invocations are not additive, the last one defines the modules to\n\t * register.\n\t * <p>Note: If this is set, no finding of modules is going to happen - not by\n\t * Jackson, and not by Spring either (see {@link #findModulesViaServiceLoader}).\n\t * As a consequence, specifying an empty list here will suppress any kind of\n\t * module detection.\n\t * <p>Specify either this or {@link #modulesToInstall}, not both.\n\t * @since 4.1.5\n\t * @see #modules(List)\n\t * @see com.fasterxml.jackson.databind.Module\n\t */\n\tpublic Jackson2ObjectMapperBuilder modules(Module... modules) {\n\t\treturn modules(Arrays.asList(modules));\n\t}\n\n\t/**\n\t * Variant of {@link #modules(Module...)} with a {@link List}.\n\t * @see #modules(Module...)\n\t * @see #modules(Consumer)\n\t * @see com.fasterxml.jackson.databind.Module\n\t */\n\tpublic Jackson2ObjectMapperBuilder modules(List<Module> modules) {\n\t\tthis.modules = new ArrayList<>(modules);\n\t\tthis.findModulesViaServiceLoader = false;\n\t\tthis.findWellKnownModules = false;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Variant of {@link #modules(Module...)} with a {@link Consumer} for full\n\t * control over the underlying list of modules.\n\t * @since 5.3.22\n\t * @see #modules(Module...)\n\t * @see #modules(List)\n\t * @see com.fasterxml.jackson.databind.Module\n\t */\n\tpublic Jackson2ObjectMapperBuilder modules(Consumer<List<Module>> consumer) {\n\t\tthis.modules = (this.modules != null ? this.modules : new ArrayList<>());\n\t\tthis.findModulesViaServiceLoader = false;\n\t\tthis.findWellKnownModules = false;\n\t\tconsumer.accept(this.modules);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Specify one or more modules to be registered with the {@link ObjectMapper}.\n\t * <p>Multiple invocations are not additive, the last one defines the modules\n\t * to register.\n\t * <p>Modules specified here will be registered after\n\t * Spring's autodetection of JSR-310 and Joda-Time, or Jackson's\n\t * finding of modules (see {@link #findModulesViaServiceLoader}),\n\t * allowing to eventually override their configuration.\n\t * <p>Specify either this or {@link #modules(Module...)}, not both.\n\t * @since 4.1.5\n\t * @see #modulesToInstall(Consumer)\n\t * @see #modulesToInstall(Class...)\n\t * @see com.fasterxml.jackson.databind.Module\n\t */\n\tpublic Jackson2ObjectMapperBuilder modulesToInstall(Module... modules) {\n\t\tthis.modules = Arrays.asList(modules);\n\t\tthis.findWellKnownModules = true;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Variant of {@link #modulesToInstall(Module...)} with a {@link Consumer}\n\t * for full control over the underlying list of modules.\n\t * @since 5.3.22\n\t * @see #modulesToInstall(Module...)\n\t * @see #modulesToInstall(Class...)\n\t * @see com.fasterxml.jackson.databind.Module\n\t */\n\tpublic Jackson2ObjectMapperBuilder modulesToInstall(Consumer<List<Module>> consumer) {\n\t\tthis.modules = (this.modules != null ? this.modules : new ArrayList<>());\n\t\tthis.findWellKnownModules = true;\n\t\tconsumer.accept(this.modules);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Specify one or more modules by class to be registered with\n\t * the {@link ObjectMapper}.\n\t * <p>Multiple invocations are not additive, the last one defines the modules\n\t * to register.\n\t * <p>Modules specified here will be registered after\n\t * Spring's autodetection of JSR-310 and Joda-Time, or Jackson's\n\t * finding of modules (see {@link #findModulesViaServiceLoader}),\n\t * allowing to eventually override their configuration.\n\t * <p>Specify either this or {@link #modules(Module...)}, not both.\n\t * @see #modulesToInstall(Module...)\n\t * @see #modulesToInstall(Consumer)\n\t * @see com.fasterxml.jackson.databind.Module\n\t */\n\t@SafeVarargs\n\t@SuppressWarnings(\"varargs\")\n\tpublic final Jackson2ObjectMapperBuilder modulesToInstall(Class<? extends Module>... modules) {\n\t\tthis.moduleClasses = modules;\n\t\tthis.findWellKnownModules = true;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set whether to let Jackson find available modules via the JDK ServiceLoader,\n\t * based on META-INF metadata in the classpath.\n\t * <p>If this mode is not set, Spring's Jackson2ObjectMapperBuilder itself\n\t * will try to find the JSR-310 and Joda-Time support modules on the classpath -\n\t * provided that Java 8 and Joda-Time themselves are available, respectively.\n\t * @see com.fasterxml.jackson.databind.ObjectMapper#findModules()\n\t */\n\tpublic Jackson2ObjectMapperBuilder findModulesViaServiceLoader(boolean findModules) {\n\t\tthis.findModulesViaServiceLoader = findModules;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the ClassLoader to use for loading Jackson extension modules.\n\t */\n\tpublic Jackson2ObjectMapperBuilder moduleClassLoader(ClassLoader moduleClassLoader) {\n\t\tthis.moduleClassLoader = moduleClassLoader;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Customize the construction of Jackson handlers ({@link JsonSerializer}, {@link JsonDeserializer},\n\t * {@link KeyDeserializer}, {@code TypeResolverBuilder} and {@code TypeIdResolver}).\n\t * @since 4.1.3\n\t * @see Jackson2ObjectMapperBuilder#applicationContext(ApplicationContext)\n\t */\n\tpublic Jackson2ObjectMapperBuilder handlerInstantiator(HandlerInstantiator handlerInstantiator) {\n\t\tthis.handlerInstantiator = handlerInstantiator;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the Spring {@link ApplicationContext} in order to autowire Jackson handlers ({@link JsonSerializer},\n\t * {@link JsonDeserializer}, {@link KeyDeserializer}, {@code TypeResolverBuilder} and {@code TypeIdResolver}).\n\t * @since 4.1.3\n\t * @see SpringHandlerInstantiator\n\t */\n\tpublic Jackson2ObjectMapperBuilder applicationContext(ApplicationContext applicationContext) {\n\t\tthis.applicationContext = applicationContext;\n\t\treturn this;\n\t}\n\n\t/**\n\t * An option to apply additional customizations directly to the\n\t * {@code ObjectMapper} instances at the end, after all other config\n\t * properties of the builder have been applied.\n\t * @param configurer a configurer to apply. If several configurers are\n\t * registered, they will get applied in their registration order.\n\t * @since 5.3\n\t */\n\tpublic Jackson2ObjectMapperBuilder postConfigurer(Consumer<ObjectMapper> configurer) {\n\t\tthis.configurer = (this.configurer != null ? this.configurer.andThen(configurer) : configurer);\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Build a new {@link ObjectMapper} instance.\n\t * <p>Each build operation produces an independent {@link ObjectMapper} instance.\n\t * The builder's settings can get modified, with a subsequent build operation\n\t * then producing a new {@link ObjectMapper} based on the most recent settings.\n\t * @return the newly built ObjectMapper\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T extends ObjectMapper> T build() {\n\t\tObjectMapper mapper;\n\t\tif (this.createXmlMapper) {\n\t\t\tmapper = (this.defaultUseWrapper != null ?\n\t\t\t\t\tnew XmlObjectMapperInitializer().create(this.defaultUseWrapper, this.factory) :\n\t\t\t\t\tnew XmlObjectMapperInitializer().create(this.factory));\n\t\t}\n\t\telse {\n\t\t\tmapper = (this.factory != null ? new ObjectMapper(this.factory) : new ObjectMapper());\n\t\t}\n\t\tconfigure(mapper);\n\t\treturn (T) mapper;\n\t}\n\n\t/**\n\t * Configure an existing {@link ObjectMapper} instance with this builder's\n\t * settings. This can be applied to any number of {@code ObjectMappers}.\n\t * @param objectMapper the ObjectMapper to configure\n\t */\n\tpublic void configure(ObjectMapper objectMapper) {\n\t\tAssert.notNull(objectMapper, \"ObjectMapper must not be null\");\n\n\t\tMultiValueMap<Object, Module> modulesToRegister = new LinkedMultiValueMap<>();\n\t\tif (this.findModulesViaServiceLoader) {\n\t\t\tObjectMapper.findModules(this.moduleClassLoader).forEach(module -> registerModule(module, modulesToRegister));\n\t\t}\n\t\telse if (this.findWellKnownModules) {\n\t\t\tregisterWellKnownModulesIfAvailable(modulesToRegister);\n\t\t}\n\n\t\tif (this.modules != null) {\n\t\t\tthis.modules.forEach(module -> registerModule(module, modulesToRegister));\n\t\t}\n\t\tif (this.moduleClasses != null) {\n\t\t\tfor (Class<? extends Module> moduleClass : this.moduleClasses) {\n\t\t\t\tregisterModule(BeanUtils.instantiateClass(moduleClass), modulesToRegister);\n\t\t\t}\n\t\t}\n\t\tList<Module> modules = new ArrayList<>();\n\t\tfor (List<Module> nestedModules : modulesToRegister.values()) {\n\t\t\tmodules.addAll(nestedModules);\n\t\t}\n\t\tobjectMapper.registerModules(modules);\n\n\t\tif (this.dateFormat != null) {\n\t\t\tobjectMapper.setDateFormat(this.dateFormat);\n\t\t}\n\t\tif (this.locale != null) {\n\t\t\tobjectMapper.setLocale(this.locale);\n\t\t}\n\t\tif (this.timeZone != null) {\n\t\t\tobjectMapper.setTimeZone(this.timeZone);\n\t\t}\n\n\t\tif (this.annotationIntrospector != null) {\n\t\t\tobjectMapper.setAnnotationIntrospector(this.annotationIntrospector);\n\t\t}\n\t\tif (this.propertyNamingStrategy != null) {\n\t\t\tobjectMapper.setPropertyNamingStrategy(this.propertyNamingStrategy);\n\t\t}\n\t\tif (this.defaultTyping != null) {\n\t\t\tobjectMapper.setDefaultTyping(this.defaultTyping);\n\t\t}\n\t\tif (this.serializationInclusion != null) {\n\t\t\tobjectMapper.setDefaultPropertyInclusion(this.serializationInclusion);\n\t\t}\n\n\t\tif (this.filters != null) {\n\t\t\tobjectMapper.setFilterProvider(this.filters);\n\t\t}\n\n\t\tobjectMapper.addMixIn(ProblemDetail.class, ProblemDetailJacksonMixin.class);\n\t\tthis.mixIns.forEach(objectMapper::addMixIn);\n\n\t\tif (!this.serializers.isEmpty() || !this.deserializers.isEmpty()) {\n\t\t\tSimpleModule module = new SimpleModule();\n\t\t\taddSerializers(module);\n\t\t\taddDeserializers(module);\n\t\t\tobjectMapper.registerModule(module);\n\t\t}\n\n\t\tthis.visibilities.forEach(objectMapper::setVisibility);\n\n\t\tcustomizeDefaultFeatures(objectMapper);\n\t\tthis.features.forEach((feature, enabled) -> configureFeature(objectMapper, feature, enabled));\n\n\t\tif (this.handlerInstantiator != null) {\n\t\t\tobjectMapper.setHandlerInstantiator(this.handlerInstantiator);\n\t\t}\n\t\telse if (this.applicationContext != null) {\n\t\t\tobjectMapper.setHandlerInstantiator(\n\t\t\t\t\tnew SpringHandlerInstantiator(this.applicationContext.getAutowireCapableBeanFactory()));\n\t\t}\n\n\t\tif (this.configurer != null) {\n\t\t\tthis.configurer.accept(objectMapper);\n\t\t}\n\t}\n\n\tprivate void registerModule(Module module, MultiValueMap<Object, Module> modulesToRegister) {\n\t\tif (module.getTypeId() == null) {\n\t\t\tmodulesToRegister.add(SimpleModule.class.getName(), module);\n\t\t}\n\t\telse {\n\t\t\tmodulesToRegister.set(module.getTypeId(), module);\n\t\t}\n\t}\n\n\n\t// Any change to this method should be also applied to spring-jms and spring-messaging\n\t// MappingJackson2MessageConverter default constructors\n\tprivate void customizeDefaultFeatures(ObjectMapper objectMapper) {\n\t\tif (!this.features.containsKey(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n\t\t\tconfigureFeature(objectMapper, MapperFeature.DEFAULT_VIEW_INCLUSION, false);\n\t\t}\n\t\tif (!this.features.containsKey(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {\n\t\t\tconfigureFeature(objectMapper, DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate <T> void addSerializers(SimpleModule module) {\n\t\tthis.serializers.forEach((type, serializer) ->\n\t\t\t\tmodule.addSerializer((Class<? extends T>) type, (JsonSerializer<T>) serializer));\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate <T> void addDeserializers(SimpleModule module) {\n\t\tthis.deserializers.forEach((type, deserializer) ->\n\t\t\t\tmodule.addDeserializer((Class<T>) type, (JsonDeserializer<? extends T>) deserializer));\n\t}\n\n\t@SuppressWarnings(\"deprecation\")  // on Jackson 2.13: configure(MapperFeature, boolean)\n\tprivate void configureFeature(ObjectMapper objectMapper, Object feature, boolean enabled) {\n\t\tif (feature instanceof JsonParser.Feature jsonParserFeature) {\n\t\t\tobjectMapper.configure(jsonParserFeature, enabled);\n\t\t}\n\t\telse if (feature instanceof JsonGenerator.Feature jsonGeneratorFeature) {\n\t\t\tobjectMapper.configure(jsonGeneratorFeature, enabled);\n\t\t}\n\t\telse if (feature instanceof SerializationFeature serializationFeature) {\n\t\t\tobjectMapper.configure(serializationFeature, enabled);\n\t\t}\n\t\telse if (feature instanceof DeserializationFeature deserializationFeature) {\n\t\t\tobjectMapper.configure(deserializationFeature, enabled);\n\t\t}\n\t\telse if (feature instanceof MapperFeature mapperFeature) {\n\t\t\tobjectMapper.configure(mapperFeature, enabled);\n\t\t}\n\t\telse {\n\t\t\tthrow new FatalBeanException(\"Unknown feature class: \" + feature.getClass().getName());\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate void registerWellKnownModulesIfAvailable(MultiValueMap<Object, Module> modulesToRegister) {\n\t\ttry {\n\t\t\tClass<? extends Module> jdk8ModuleClass = (Class<? extends Module>)\n\t\t\t\t\tClassUtils.forName(\"com.fasterxml.jackson.datatype.jdk8.Jdk8Module\", this.moduleClassLoader);\n\t\t\tModule jdk8Module = BeanUtils.instantiateClass(jdk8ModuleClass);\n\t\t\tmodulesToRegister.set(jdk8Module.getTypeId(), jdk8Module);\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\t// jackson-datatype-jdk8 not available\n\t\t}\n\n\t\ttry {\n\t\t\tClass<? extends Module> javaTimeModuleClass = (Class<? extends Module>)\n\t\t\t\t\tClassUtils.forName(\"com.fasterxml.jackson.datatype.jsr310.JavaTimeModule\", this.moduleClassLoader);\n\t\t\tModule javaTimeModule = BeanUtils.instantiateClass(javaTimeModuleClass);\n\t\t\tmodulesToRegister.set(javaTimeModule.getTypeId(), javaTimeModule);\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\t// jackson-datatype-jsr310 not available\n\t\t}\n\n\t\t// Kotlin present?\n\t\tif (KotlinDetector.isKotlinPresent()) {\n\t\t\ttry {\n\t\t\t\tClass<? extends Module> kotlinModuleClass = (Class<? extends Module>)\n\t\t\t\t\t\tClassUtils.forName(\"com.fasterxml.jackson.module.kotlin.KotlinModule\", this.moduleClassLoader);\n\t\t\t\tModule kotlinModule = BeanUtils.instantiateClass(kotlinModuleClass);\n\t\t\t\tmodulesToRegister.set(kotlinModule.getTypeId(), kotlinModule);\n\t\t\t}\n\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\t// jackson-module-kotlin not available\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// Convenience factory methods\n\n\t/**\n\t * Obtain a {@link Jackson2ObjectMapperBuilder} instance in order to\n\t * build a regular JSON {@link ObjectMapper} instance.\n\t */\n\tpublic static Jackson2ObjectMapperBuilder json() {\n\t\treturn new Jackson2ObjectMapperBuilder();\n\t}\n\n\t/**\n\t * Obtain a {@link Jackson2ObjectMapperBuilder} instance in order to\n\t * build an {@link XmlMapper} instance.\n\t */\n\tpublic static Jackson2ObjectMapperBuilder xml() {\n\t\treturn new Jackson2ObjectMapperBuilder().createXmlMapper(true);\n\t}\n\n\t/**\n\t * Obtain a {@link Jackson2ObjectMapperBuilder} instance in order to\n\t * build a Smile data format {@link ObjectMapper} instance.\n\t * @since 5.0\n\t */\n\tpublic static Jackson2ObjectMapperBuilder smile() {\n\t\treturn new Jackson2ObjectMapperBuilder().factory(new SmileFactoryInitializer().create());\n\t}\n\n\t/**\n\t * Obtain a {@link Jackson2ObjectMapperBuilder} instance in order to\n\t * build a CBOR data format {@link ObjectMapper} instance.\n\t * @since 5.0\n\t */\n\tpublic static Jackson2ObjectMapperBuilder cbor() {\n\t\treturn new Jackson2ObjectMapperBuilder().factory(new CborFactoryInitializer().create());\n\t}\n\n\n\tprivate static class XmlObjectMapperInitializer {\n\n\t\tpublic ObjectMapper create(@Nullable JsonFactory factory) {\n\t\t\tif (factory != null) {\n\t\t\t\treturn new XmlMapper((XmlFactory) factory);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new XmlMapper(StaxUtils.createDefensiveInputFactory());\n\t\t\t}\n\t\t}\n\n\t\tpublic ObjectMapper create(boolean defaultUseWrapper, @Nullable JsonFactory factory) {\n\t\t\tJacksonXmlModule module = new JacksonXmlModule();\n\t\t\tmodule.setDefaultUseWrapper(defaultUseWrapper);\n\t\t\tif (factory != null) {\n\t\t\t\treturn new XmlMapper((XmlFactory) factory, module);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new XmlMapper(new XmlFactory(StaxUtils.createDefensiveInputFactory()), module);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate static class SmileFactoryInitializer {\n\n\t\tpublic JsonFactory create() {\n\t\t\treturn new SmileFactory();\n\t\t}\n\t}\n\n\n\tprivate static class CborFactoryInitializer {\n\n\t\tpublic JsonFactory create() {\n\t\t\treturn new CBORFactory();\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#annotationIntrospector(Function<AnnotationIntrospector,pairingFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Alternative to {@link #annotationIntrospector(AnnotationIntrospector)}\n\t * that allows combining with rather than replacing the currently set\n\t * introspector, e.g. via\n\t * {@link AnnotationIntrospectorPair#pair(AnnotationIntrospector, AnnotationIntrospector)}.\n\t * @param pairingFunction a function to apply to the currently set\n\t * introspector (possibly {@code null}); the result of the function becomes\n\t * the new introspector.\n\t * @since 5.2.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<AnnotationIntrospector",
      "pairingFunction"
    ],
    "position": {
      "column": 1,
      "line": 269
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder annotationIntrospector(Function<AnnotationIntrospector, AnnotationIntrospector> pairingFunction)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder annotationIntrospector("
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#annotationIntrospector(annotationIntrospector)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set an {@link AnnotationIntrospector} for both serialization and deserialization.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationIntrospector"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder annotationIntrospector(AnnotationIntrospector annotationIntrospector)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder annotationIntrospector(AnnotationIntrospector annotationIntrospector) {\n\t\tthis.annotationIntrospector = annotationIntrospector;\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#applicationContext(applicationContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Spring {@link ApplicationContext} in order to autowire Jackson handlers ({@link JsonSerializer},\n\t * {@link JsonDeserializer}, {@link KeyDeserializer}, {@code TypeResolverBuilder} and {@code TypeIdResolver}).\n\t * @since 4.1.3\n\t * @see SpringHandlerInstantiator\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "applicationContext"
    ],
    "position": {
      "column": 1,
      "line": 661
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder applicationContext(ApplicationContext applicationContext)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder applicationContext(ApplicationContext applicationContext) {\n\t\tthis.applicationContext = applicationContext;\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#autoDetectFields(autoDetectFields)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Shortcut for {@link MapperFeature#AUTO_DETECT_FIELDS} option.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "autoDetectFields"
    ],
    "position": {
      "column": 1,
      "line": 420
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder autoDetectFields(boolean autoDetectFields)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder autoDetectFields(boolean autoDetectFields) {\n\t\tthis.features.put(MapperFeature.AUTO_DETECT_FIELDS, autoDetectFields);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#autoDetectGettersSetters(autoDetectGettersSetters)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Shortcut for {@link MapperFeature#AUTO_DETECT_SETTERS}/\n\t * {@link MapperFeature#AUTO_DETECT_GETTERS}/{@link MapperFeature#AUTO_DETECT_IS_GETTERS}\n\t * options.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "autoDetectGettersSetters"
    ],
    "position": {
      "column": 1,
      "line": 430
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder autoDetectGettersSetters(boolean autoDetectGettersSetters)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder autoDetectGettersSetters(boolean autoDetectGettersSetters) {\n\t\tthis.features.put(MapperFeature.AUTO_DETECT_GETTERS, autoDetectGettersSetters);\n\t\tthis.features.put(MapperFeature.AUTO_DETECT_SETTERS, autoDetectGettersSetters);\n\t\tthis.features.put(MapperFeature.AUTO_DETECT_IS_GETTERS, autoDetectGettersSetters);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#build()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a new {@link ObjectMapper} instance.\n\t * <p>Each build operation produces an independent {@link ObjectMapper} instance.\n\t * The builder's settings can get modified, with a subsequent build operation\n\t * then producing a new {@link ObjectMapper} based on the most recent settings.\n\t * @return the newly built ObjectMapper\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 688
    },
    "return": "T",
    "signature": "public T build()",
    "source_code": "\tpublic <T extends ObjectMapper> T build() {\n\t\tObjectMapper mapper;\n\t\tif (this.createXmlMapper) {\n\t\t\tmapper = (this.defaultUseWrapper != null ?\n\t\t\t\t\tnew XmlObjectMapperInitializer().create(this.defaultUseWrapper, this.factory) :\n\t\t\t\t\tnew XmlObjectMapperInitializer().create(this.factory));\n\t\t}\n\t\telse {\n\t\t\tmapper = (this.factory != null ? new ObjectMapper(this.factory) : new ObjectMapper());\n\t\t}\n\t\tconfigure(mapper);\n\t\treturn (T) mapper;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#cbor()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a {@link Jackson2ObjectMapperBuilder} instance in order to\n\t * build a CBOR data format {@link ObjectMapper} instance.\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 911
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder cbor()",
    "source_code": "\tpublic static Jackson2ObjectMapperBuilder cbor() {\n\t\treturn new Jackson2ObjectMapperBuilder().factory(new CborFactoryInitializer().create());\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#configure(objectMapper)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure an existing {@link ObjectMapper} instance with this builder's\n\t * settings. This can be applied to any number of {@code ObjectMappers}.\n\t * @param objectMapper the ObjectMapper to configure\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "objectMapper"
    ],
    "position": {
      "column": 1,
      "line": 707
    },
    "return": "void",
    "signature": "public void configure(ObjectMapper objectMapper)",
    "source_code": "\tpublic void configure(ObjectMapper objectMapper) {\n\t\tAssert.notNull(objectMapper, \"ObjectMapper must not be null\");\n\n\t\tMultiValueMap<Object, Module> modulesToRegister = new LinkedMultiValueMap<>();\n\t\tif (this.findModulesViaServiceLoader) {\n\t\t\tObjectMapper.findModules(this.moduleClassLoader).forEach(module -> registerModule(module, modulesToRegister));\n\t\t}\n\t\telse if (this.findWellKnownModules) {\n\t\t\tregisterWellKnownModulesIfAvailable(modulesToRegister);\n\t\t}\n\n\t\tif (this.modules != null) {\n\t\t\tthis.modules.forEach(module -> registerModule(module, modulesToRegister));\n\t\t}\n\t\tif (this.moduleClasses != null) {\n\t\t\tfor (Class<? extends Module> moduleClass : this.moduleClasses) {\n\t\t\t\tregisterModule(BeanUtils.instantiateClass(moduleClass), modulesToRegister);\n\t\t\t}\n\t\t}\n\t\tList<Module> modules = new ArrayList<>();\n\t\tfor (List<Module> nestedModules : modulesToRegister.values()) {\n\t\t\tmodules.addAll(nestedModules);\n\t\t}\n\t\tobjectMapper.registerModules(modules);\n\n\t\tif (this.dateFormat != null) {\n\t\t\tobjectMapper.setDateFormat(this.dateFormat);\n\t\t}\n\t\tif (this.locale != null) {\n\t\t\tobjectMapper.setLocale(this.locale);\n\t\t}\n\t\tif (this.timeZone != null) {\n\t\t\tobjectMapper.setTimeZone(this.timeZone);\n\t\t}\n\n\t\tif (this.annotationIntrospector != null) {\n\t\t\tobjectMapper.setAnnotationIntrospector(this.annotationIntrospector);\n\t\t}\n\t\tif (this.propertyNamingStrategy != null) {\n\t\t\tobjectMapper.setPropertyNamingStrategy(this.propertyNamingStrategy);\n\t\t}\n\t\tif (this.defaultTyping != null) {\n\t\t\tobjectMapper.setDefaultTyping(this.defaultTyping);\n\t\t}\n\t\tif (this.serializationInclusion != null) {\n\t\t\tobjectMapper.setDefaultPropertyInclusion(this.serializationInclusion);\n\t\t}\n\n\t\tif (this.filters != null) {\n\t\t\tobjectMapper.setFilterProvider(this.filters);\n\t\t}\n\n\t\tobjectMapper.addMixIn(ProblemDetail.class, ProblemDetailJacksonMixin.class);\n\t\tthis.mixIns.forEach(objectMapper::addMixIn);\n\n\t\tif (!this.serializers.isEmpty() || !this.deserializers.isEmpty()) {\n\t\t\tSimpleModule module = new SimpleModule();\n\t\t\taddSerializers(module);\n\t\t\taddDeserializers(module);\n\t\t\tobjectMapper.registerModule(module);\n\t\t}\n\n\t\tthis.visibilities.forEach(objectMapper::setVisibility);\n\n\t\tcustomizeDefaultFeatures(objectMapper);\n\t\tthis.features.forEach((feature, enabled) -> configureFeature(objectMapper, feature, enabled));\n\n\t\tif (this.handlerInstantiator != null) {\n\t\t\tobjectMapper.setHandlerInstantiator(this.handlerInstantiator);\n\t\t}\n\t\telse if (this.applicationContext != null) {\n\t\t\tobjectMapper.setHandlerInstantiator(\n\t\t\t\t\tnew SpringHandlerInstantiator(this.applicationContext.getAutowireCapableBeanFactory()));\n\t\t}\n\n\t\tif (this.configurer != null) {\n\t\t\tthis.configurer.accept(objectMapper);\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#create()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 950
    },
    "return": "JsonFactory",
    "signature": "public JsonFactory create()",
    "source_code": "\t\tpublic JsonFactory create() {\n\t\t\treturn new CBORFactory();\n\t\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#create(defaultUseWrapper,factory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultUseWrapper",
      "factory"
    ],
    "position": {
      "column": 1,
      "line": 927
    },
    "return": "ObjectMapper",
    "signature": "public ObjectMapper create(boolean defaultUseWrapper, @Nullable JsonFactory factory)",
    "source_code": "\t\tpublic ObjectMapper create(boolean defaultUseWrapper, @Nullable JsonFactory factory) {\n\t\t\tJacksonXmlModule module = new JacksonXmlModule();\n\t\t\tmodule.setDefaultUseWrapper(defaultUseWrapper);\n\t\t\tif (factory != null) {\n\t\t\t\treturn new XmlMapper((XmlFactory) factory, module);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new XmlMapper(new XmlFactory(StaxUtils.createDefensiveInputFactory()), module);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#create(factory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "factory"
    ],
    "position": {
      "column": 1,
      "line": 918
    },
    "return": "ObjectMapper",
    "signature": "public ObjectMapper create(@Nullable JsonFactory factory)",
    "source_code": "\t\tpublic ObjectMapper create(@Nullable JsonFactory factory) {\n\t\t\tif (factory != null) {\n\t\t\t\treturn new XmlMapper((XmlFactory) factory);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new XmlMapper(StaxUtils.createDefensiveInputFactory());\n\t\t\t}\n\t\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#createXmlMapper(createXmlMapper)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * If set to {@code true}, an {@link XmlMapper} will be created using its\n\t * default constructor. This is only applicable to {@link #build()} calls,\n\t * not to {@link #configure} calls.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "createXmlMapper"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder createXmlMapper(boolean createXmlMapper)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder createXmlMapper(boolean createXmlMapper) {\n\t\tthis.createXmlMapper = createXmlMapper;\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#dateFormat(dateFormat)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Define the format for date/time with the given {@link DateFormat}.\n\t * <p>Note: Setting this property makes the exposed {@link ObjectMapper}\n\t * non-thread-safe, according to Jackson's thread safety rules.\n\t * @see #simpleDateFormat(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dateFormat"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder dateFormat(DateFormat dateFormat)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder dateFormat(DateFormat dateFormat) {\n\t\tthis.dateFormat = dateFormat;\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#defaultTyping(typeResolverBuilder)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify a {@link TypeResolverBuilder} to use for Jackson's default typing.\n\t * @since 4.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "typeResolverBuilder"
    ],
    "position": {
      "column": 1,
      "line": 289
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder defaultTyping(TypeResolverBuilder<?> typeResolverBuilder)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder defaultTyping(TypeResolverBuilder<?> typeResolverBuilder) {\n\t\tthis.defaultTyping = typeResolverBuilder;\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#defaultUseWrapper(defaultUseWrapper)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Define if a wrapper will be used for indexed (List, array) properties or not by\n\t * default (only applies to {@link XmlMapper}).\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultUseWrapper"
    ],
    "position": {
      "column": 1,
      "line": 474
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder defaultUseWrapper(boolean defaultUseWrapper)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder defaultUseWrapper(boolean defaultUseWrapper) {\n\t\tthis.defaultUseWrapper = defaultUseWrapper;\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#defaultViewInclusion(defaultViewInclusion)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Shortcut for {@link MapperFeature#DEFAULT_VIEW_INCLUSION} option.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultViewInclusion"
    ],
    "position": {
      "column": 1,
      "line": 440
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder defaultViewInclusion(boolean defaultViewInclusion)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder defaultViewInclusion(boolean defaultViewInclusion) {\n\t\tthis.features.put(MapperFeature.DEFAULT_VIEW_INCLUSION, defaultViewInclusion);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#deserializerByType(type,deserializer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a custom deserializer for the given type.\n\t * @since 4.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "deserializer"
    ],
    "position": {
      "column": 1,
      "line": 404
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder deserializerByType(Class<?> type, JsonDeserializer<?> deserializer)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder deserializerByType(Class<?> type, JsonDeserializer<?> deserializer) {\n\t\tthis.deserializers.put(type, deserializer);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#deserializers(deserializers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure custom deserializers. Each deserializer is registered for the type\n\t * returned by {@link JsonDeserializer#handledType()}, which must not be {@code null}.\n\t * @since 4.3\n\t * @see #deserializersByType(Map)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "deserializers"
    ],
    "position": {
      "column": 1,
      "line": 389
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder deserializers(JsonDeserializer<?>... deserializers)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder deserializers(JsonDeserializer<?>... deserializers) {\n\t\tfor (JsonDeserializer<?> deserializer : deserializers) {\n\t\t\tClass<?> handledType = deserializer.handledType();\n\t\t\tif (handledType == null || handledType == Object.class) {\n\t\t\t\tthrow new IllegalArgumentException(\"Unknown handled type in \" + deserializer.getClass().getName());\n\t\t\t}\n\t\t\tthis.deserializers.put(deserializer.handledType(), deserializer);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#deserializersByType(Map<Class<?>,deserializers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure custom deserializers for the given types.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Class<?>",
      "deserializers"
    ],
    "position": {
      "column": 1,
      "line": 412
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder deserializersByType(Map<Class<?>, JsonDeserializer<?>> deserializers)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder deserializersByType(Map<Class<?>, JsonDeserializer<?>> deserializers) {\n\t\tthis.deserializers.putAll(deserializers);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#factory(factory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Define the {@link JsonFactory} to be used to create the {@link ObjectMapper}\n\t * instance.\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "factory"
    ],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder factory(JsonFactory factory)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder factory(JsonFactory factory) {\n\t\tthis.factory = factory;\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#failOnEmptyBeans(failOnEmptyBeans)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Shortcut for {@link SerializationFeature#FAIL_ON_EMPTY_BEANS} option.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "failOnEmptyBeans"
    ],
    "position": {
      "column": 1,
      "line": 456
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder failOnEmptyBeans(boolean failOnEmptyBeans)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder failOnEmptyBeans(boolean failOnEmptyBeans) {\n\t\tthis.features.put(SerializationFeature.FAIL_ON_EMPTY_BEANS, failOnEmptyBeans);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#failOnUnknownProperties(failOnUnknownProperties)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Shortcut for {@link DeserializationFeature#FAIL_ON_UNKNOWN_PROPERTIES} option.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "failOnUnknownProperties"
    ],
    "position": {
      "column": 1,
      "line": 448
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder failOnUnknownProperties(boolean failOnUnknownProperties)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder failOnUnknownProperties(boolean failOnUnknownProperties) {\n\t\tthis.features.put(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, failOnUnknownProperties);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#featuresToDisable(featuresToDisable)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify features to disable.\n\t * @see com.fasterxml.jackson.core.JsonParser.Feature\n\t * @see com.fasterxml.jackson.core.JsonGenerator.Feature\n\t * @see com.fasterxml.jackson.databind.SerializationFeature\n\t * @see com.fasterxml.jackson.databind.DeserializationFeature\n\t * @see com.fasterxml.jackson.databind.MapperFeature\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "featuresToDisable"
    ],
    "position": {
      "column": 1,
      "line": 513
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder featuresToDisable(Object... featuresToDisable)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder featuresToDisable(Object... featuresToDisable) {\n\t\tfor (Object feature : featuresToDisable) {\n\t\t\tthis.features.put(feature, Boolean.FALSE);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#featuresToEnable(featuresToEnable)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify features to enable.\n\t * @see com.fasterxml.jackson.core.JsonParser.Feature\n\t * @see com.fasterxml.jackson.core.JsonGenerator.Feature\n\t * @see com.fasterxml.jackson.databind.SerializationFeature\n\t * @see com.fasterxml.jackson.databind.DeserializationFeature\n\t * @see com.fasterxml.jackson.databind.MapperFeature\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "featuresToEnable"
    ],
    "position": {
      "column": 1,
      "line": 498
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder featuresToEnable(Object... featuresToEnable)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder featuresToEnable(Object... featuresToEnable) {\n\t\tfor (Object feature : featuresToEnable) {\n\t\t\tthis.features.put(feature, Boolean.TRUE);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#filters(filters)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the global filters to use in order to support {@link JsonFilter @JsonFilter} annotated POJO.\n\t * @since 4.2\n\t * @see MappingJacksonValue#setFilters(FilterProvider)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "filters"
    ],
    "position": {
      "column": 1,
      "line": 317
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder filters(FilterProvider filters)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder filters(FilterProvider filters) {\n\t\tthis.filters = filters;\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#findModulesViaServiceLoader(findModules)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to let Jackson find available modules via the JDK ServiceLoader,\n\t * based on META-INF metadata in the classpath.\n\t * <p>If this mode is not set, Spring's Jackson2ObjectMapperBuilder itself\n\t * will try to find the JSR-310 and Joda-Time support modules on the classpath -\n\t * provided that Java 8 and Joda-Time themselves are available, respectively.\n\t * @see com.fasterxml.jackson.databind.ObjectMapper#findModules()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "findModules"
    ],
    "position": {
      "column": 1,
      "line": 631
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder findModulesViaServiceLoader(boolean findModules)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder findModulesViaServiceLoader(boolean findModules) {\n\t\tthis.findModulesViaServiceLoader = findModules;\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#handlerInstantiator(handlerInstantiator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the construction of Jackson handlers ({@link JsonSerializer}, {@link JsonDeserializer},\n\t * {@link KeyDeserializer}, {@code TypeResolverBuilder} and {@code TypeIdResolver}).\n\t * @since 4.1.3\n\t * @see Jackson2ObjectMapperBuilder#applicationContext(ApplicationContext)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handlerInstantiator"
    ],
    "position": {
      "column": 1,
      "line": 650
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder handlerInstantiator(HandlerInstantiator handlerInstantiator)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder handlerInstantiator(HandlerInstantiator handlerInstantiator) {\n\t\tthis.handlerInstantiator = handlerInstantiator;\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#indentOutput(indentOutput)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Shortcut for {@link SerializationFeature#INDENT_OUTPUT} option.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "indentOutput"
    ],
    "position": {
      "column": 1,
      "line": 464
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder indentOutput(boolean indentOutput)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder indentOutput(boolean indentOutput) {\n\t\tthis.features.put(SerializationFeature.INDENT_OUTPUT, indentOutput);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#json()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a {@link Jackson2ObjectMapperBuilder} instance in order to\n\t * build a regular JSON {@link ObjectMapper} instance.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 885
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder json()",
    "source_code": "\tpublic static Jackson2ObjectMapperBuilder json() {\n\t\treturn new Jackson2ObjectMapperBuilder();\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#locale(locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Override the default {@link Locale} to use for formatting.\n\t * Default value used is {@link Locale#getDefault()}.\n\t * @since 4.1.5\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder locale(Locale locale)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder locale(Locale locale) {\n\t\tthis.locale = locale;\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#locale(localeString)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Override the default {@link Locale} to use for formatting.\n\t * Default value used is {@link Locale#getDefault()}.\n\t * @param localeString the locale ID as a String representation\n\t * @since 4.1.5\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "localeString"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder locale(String localeString)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder locale(String localeString) {\n\t\tthis.locale = StringUtils.parseLocale(localeString);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#mixIn(target,mixinSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add mix-in annotations to use for augmenting specified class or interface.\n\t * @param target class (or interface) whose annotations to effectively override\n\t * @param mixinSource class (or interface) whose annotations are to be \"added\"\n\t * to target's annotations as value\n\t * @since 4.1.2\n\t * @see com.fasterxml.jackson.databind.ObjectMapper#addMixIn(Class, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "mixinSource"
    ],
    "position": {
      "column": 1,
      "line": 330
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder mixIn(Class<?> target, Class<?> mixinSource)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder mixIn(Class<?> target, Class<?> mixinSource) {\n\t\tthis.mixIns.put(target, mixinSource);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#mixIns(Map<Class<?>,mixIns)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add mix-in annotations to use for augmenting specified class or interface.\n\t * @param mixIns a Map of entries with target classes (or interface) whose annotations\n\t * to effectively override as key and mix-in classes (or interface) whose\n\t * annotations are to be \"added\" to target's annotations as value.\n\t * @since 4.1.2\n\t * @see com.fasterxml.jackson.databind.ObjectMapper#addMixIn(Class, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Class<?>",
      "mixIns"
    ],
    "position": {
      "column": 1,
      "line": 343
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder mixIns(Map<Class<?>, Class<?>> mixIns)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder mixIns(Map<Class<?>, Class<?>> mixIns) {\n\t\tthis.mixIns.putAll(mixIns);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#moduleClassLoader(moduleClassLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the ClassLoader to use for loading Jackson extension modules.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "moduleClassLoader"
    ],
    "position": {
      "column": 1,
      "line": 639
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder moduleClassLoader(ClassLoader moduleClassLoader)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder moduleClassLoader(ClassLoader moduleClassLoader) {\n\t\tthis.moduleClassLoader = moduleClassLoader;\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#modules(consumer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #modules(Module...)} with a {@link Consumer} for full\n\t * control over the underlying list of modules.\n\t * @since 5.3.22\n\t * @see #modules(Module...)\n\t * @see #modules(List)\n\t * @see com.fasterxml.jackson.databind.Module\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "consumer"
    ],
    "position": {
      "column": 1,
      "line": 558
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder modules(Consumer<List<Module>> consumer)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder modules(Consumer<List<Module>> consumer) {\n\t\tthis.modules = (this.modules != null ? this.modules : new ArrayList<>());\n\t\tthis.findModulesViaServiceLoader = false;\n\t\tthis.findWellKnownModules = false;\n\t\tconsumer.accept(this.modules);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#modules(modules)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #modules(Module...)} with a {@link List}.\n\t * @see #modules(Module...)\n\t * @see #modules(Consumer)\n\t * @see com.fasterxml.jackson.databind.Module\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "modules"
    ],
    "position": {
      "column": 1,
      "line": 543
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder modules(List<Module> modules)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder modules(List<Module> modules) {\n\t\tthis.modules = new ArrayList<>(modules);\n\t\tthis.findModulesViaServiceLoader = false;\n\t\tthis.findWellKnownModules = false;\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#modulesToInstall(consumer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #modulesToInstall(Module...)} with a {@link Consumer}\n\t * for full control over the underlying list of modules.\n\t * @since 5.3.22\n\t * @see #modulesToInstall(Module...)\n\t * @see #modulesToInstall(Class...)\n\t * @see com.fasterxml.jackson.databind.Module\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "consumer"
    ],
    "position": {
      "column": 1,
      "line": 594
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder modulesToInstall(Consumer<List<Module>> consumer)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder modulesToInstall(Consumer<List<Module>> consumer) {\n\t\tthis.modules = (this.modules != null ? this.modules : new ArrayList<>());\n\t\tthis.findWellKnownModules = true;\n\t\tconsumer.accept(this.modules);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#modulesToInstall(modules)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify one or more modules by class to be registered with\n\t * the {@link ObjectMapper}.\n\t * <p>Multiple invocations are not additive, the last one defines the modules\n\t * to register.\n\t * <p>Modules specified here will be registered after\n\t * Spring's autodetection of JSR-310 and Joda-Time, or Jackson's\n\t * finding of modules (see {@link #findModulesViaServiceLoader}),\n\t * allowing to eventually override their configuration.\n\t * <p>Specify either this or {@link #modules(Module...)}, not both.\n\t * @see #modulesToInstall(Module...)\n\t * @see #modulesToInstall(Consumer)\n\t * @see com.fasterxml.jackson.databind.Module\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "modules"
    ],
    "position": {
      "column": 1,
      "line": 617
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder modulesToInstall(Class<? extends Module>... modules)",
    "source_code": "\tpublic final Jackson2ObjectMapperBuilder modulesToInstall(Class<? extends Module>... modules) {\n\t\tthis.moduleClasses = modules;\n\t\tthis.findWellKnownModules = true;\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#postConfigurer(configurer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An option to apply additional customizations directly to the\n\t * {@code ObjectMapper} instances at the end, after all other config\n\t * properties of the builder have been applied.\n\t * @param configurer a configurer to apply. If several configurers are\n\t * registered, they will get applied in their registration order.\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "configurer"
    ],
    "position": {
      "column": 1,
      "line": 674
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder postConfigurer(Consumer<ObjectMapper> configurer)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder postConfigurer(Consumer<ObjectMapper> configurer) {\n\t\tthis.configurer = (this.configurer != null ? this.configurer.andThen(configurer) : configurer);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#propertyNamingStrategy(propertyNamingStrategy)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify a {@link com.fasterxml.jackson.databind.PropertyNamingStrategy} to\n\t * configure the {@link ObjectMapper} with.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyNamingStrategy"
    ],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder propertyNamingStrategy(PropertyNamingStrategy propertyNamingStrategy)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder propertyNamingStrategy(PropertyNamingStrategy propertyNamingStrategy) {\n\t\tthis.propertyNamingStrategy = propertyNamingStrategy;\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#serializationInclusion(inclusion)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a custom inclusion strategy for serialization.\n\t * @see com.fasterxml.jackson.annotation.JsonInclude.Include\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inclusion"
    ],
    "position": {
      "column": 1,
      "line": 298
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder serializationInclusion(JsonInclude.Include inclusion)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder serializationInclusion(JsonInclude.Include inclusion) {\n\t\treturn serializationInclusion(JsonInclude.Value.construct(inclusion, inclusion));\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#serializationInclusion(serializationInclusion)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a custom inclusion strategy for serialization.\n\t * @since 5.3\n\t * @see com.fasterxml.jackson.annotation.JsonInclude.Value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "serializationInclusion"
    ],
    "position": {
      "column": 1,
      "line": 307
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder serializationInclusion(JsonInclude.Value serializationInclusion)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder serializationInclusion(JsonInclude.Value serializationInclusion) {\n\t\tthis.serializationInclusion = serializationInclusion;\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#serializerByType(type,serializer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a custom serializer for the given type.\n\t * @since 4.1.2\n\t * @see #serializers(JsonSerializer...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "serializer"
    ],
    "position": {
      "column": 1,
      "line": 369
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder serializerByType(Class<?> type, JsonSerializer<?> serializer)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder serializerByType(Class<?> type, JsonSerializer<?> serializer) {\n\t\tthis.serializers.put(type, serializer);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#serializers(serializers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure custom serializers. Each serializer is registered for the type\n\t * returned by {@link JsonSerializer#handledType()}, which must not be {@code null}.\n\t * @see #serializersByType(Map)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "serializers"
    ],
    "position": {
      "column": 1,
      "line": 353
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder serializers(JsonSerializer<?>... serializers)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder serializers(JsonSerializer<?>... serializers) {\n\t\tfor (JsonSerializer<?> serializer : serializers) {\n\t\t\tClass<?> handledType = serializer.handledType();\n\t\t\tif (handledType == null || handledType == Object.class) {\n\t\t\t\tthrow new IllegalArgumentException(\"Unknown handled type in \" + serializer.getClass().getName());\n\t\t\t}\n\t\t\tthis.serializers.put(serializer.handledType(), serializer);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#serializersByType(Map<Class<?>,serializers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure custom serializers for the given types.\n\t * @see #serializers(JsonSerializer...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Class<?>",
      "serializers"
    ],
    "position": {
      "column": 1,
      "line": 378
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder serializersByType(Map<Class<?>, JsonSerializer<?>> serializers)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder serializersByType(Map<Class<?>, JsonSerializer<?>> serializers) {\n\t\tthis.serializers.putAll(serializers);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#simpleDateFormat(format)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Define the date/time format with a {@link SimpleDateFormat}.\n\t * <p>Note: Setting this property makes the exposed {@link ObjectMapper}\n\t * non-thread-safe, according to Jackson's thread safety rules.\n\t * @see #dateFormat(DateFormat)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "format"
    ],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder simpleDateFormat(String format)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder simpleDateFormat(String format) {\n\t\tthis.dateFormat = new SimpleDateFormat(format);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#smile()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a {@link Jackson2ObjectMapperBuilder} instance in order to\n\t * build a Smile data format {@link ObjectMapper} instance.\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 902
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder smile()",
    "source_code": "\tpublic static Jackson2ObjectMapperBuilder smile() {\n\t\treturn new Jackson2ObjectMapperBuilder().factory(new SmileFactoryInitializer().create());\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#timeZone(timeZone)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Override the default {@link TimeZone} to use for formatting.\n\t * Default value used is UTC (NOT local timezone).\n\t * @since 4.1.5\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeZone"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder timeZone(TimeZone timeZone)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder timeZone(TimeZone timeZone) {\n\t\tthis.timeZone = timeZone;\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#timeZone(timeZoneString)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Override the default {@link TimeZone} to use for formatting.\n\t * Default value used is UTC (NOT local timezone).\n\t * @param timeZoneString the zone ID as a String representation\n\t * @since 4.1.5\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeZoneString"
    ],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder timeZone(String timeZoneString)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder timeZone(String timeZoneString) {\n\t\tthis.timeZone = StringUtils.parseTimeZoneString(timeZoneString);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#visibility(accessor,visibility)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify visibility to limit what kind of properties are auto-detected.\n\t * @since 5.1\n\t * @see com.fasterxml.jackson.annotation.PropertyAccessor\n\t * @see com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "accessor",
      "visibility"
    ],
    "position": {
      "column": 1,
      "line": 485
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder visibility(PropertyAccessor accessor, JsonAutoDetect.Visibility visibility)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder visibility(PropertyAccessor accessor, JsonAutoDetect.Visibility visibility) {\n\t\tthis.visibilities.put(accessor, visibility);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#xml()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a {@link Jackson2ObjectMapperBuilder} instance in order to\n\t * build an {@link XmlMapper} instance.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 893
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder xml()",
    "source_code": "\tpublic static Jackson2ObjectMapperBuilder xml() {\n\t\treturn new Jackson2ObjectMapperBuilder().createXmlMapper(true);\n\t}"
  },
  "org.springframework.http.converter.xml.MarshallingHttpMessageConverter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Implementation of {@link org.springframework.http.converter.HttpMessageConverter HttpMessageConverter}\n * that can read and write XML using Spring's {@link Marshaller} and {@link Unmarshaller} abstractions.\n *\n * <p>This converter requires a {@code Marshaller} and {@code Unmarshaller} before it can be used.\n * These can be injected by the {@linkplain #MarshallingHttpMessageConverter(Marshaller) constructor}\n * or {@linkplain #setMarshaller(Marshaller) bean properties}.\n *\n * <p>By default, this converter supports {@code text/xml} and {@code application/xml}. This can be\n * overridden by setting the {@link #setSupportedMediaTypes(java.util.List) supportedMediaTypes} property.\n *\n * @author Arjen Poutsma\n * @since 3.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "signature": "public class MarshallingHttpMessageConverter",
    "source_code": "public class MarshallingHttpMessageConverter extends AbstractXmlHttpMessageConverter<Object> {\n\n\t@Nullable\n\tprivate Marshaller marshaller;\n\n\t@Nullable\n\tprivate Unmarshaller unmarshaller;\n\n\n\t/**\n\t * Construct a new {@code MarshallingHttpMessageConverter} with no {@link Marshaller} or\n\t * {@link Unmarshaller} set. The Marshaller and Unmarshaller must be set after construction\n\t * by invoking {@link #setMarshaller(Marshaller)} and {@link #setUnmarshaller(Unmarshaller)}.\n\t */\n\tpublic MarshallingHttpMessageConverter() {\n\t}\n\n\t/**\n\t * Construct a new {@code MarshallingMessageConverter} with the given {@link Marshaller} set.\n\t * <p>If the given {@link Marshaller} also implements the {@link Unmarshaller} interface,\n\t * it is used for both marshalling and unmarshalling. Otherwise, an exception is thrown.\n\t * <p>Note that all {@code Marshaller} implementations in Spring also implement the\n\t * {@code Unmarshaller} interface, so that you can safely use this constructor.\n\t * @param marshaller object used as marshaller and unmarshaller\n\t */\n\tpublic MarshallingHttpMessageConverter(Marshaller marshaller) {\n\t\tAssert.notNull(marshaller, \"Marshaller must not be null\");\n\t\tthis.marshaller = marshaller;\n\t\t// The following pattern variable cannot be named \"unmarshaller\" due to lacking\n\t\t// support in Checkstyle: https://github.com/checkstyle/checkstyle/issues/10969\n\t\tif (marshaller instanceof Unmarshaller _unmarshaller) {\n\t\t\tthis.unmarshaller = _unmarshaller;\n\t\t}\n\t}\n\n\t/**\n\t * Construct a new {@code MarshallingMessageConverter} with the given\n\t * {@code Marshaller} and {@code Unmarshaller}.\n\t * @param marshaller the Marshaller to use\n\t * @param unmarshaller the Unmarshaller to use\n\t */\n\tpublic MarshallingHttpMessageConverter(Marshaller marshaller, Unmarshaller unmarshaller) {\n\t\tAssert.notNull(marshaller, \"Marshaller must not be null\");\n\t\tAssert.notNull(unmarshaller, \"Unmarshaller must not be null\");\n\t\tthis.marshaller = marshaller;\n\t\tthis.unmarshaller = unmarshaller;\n\t}\n\n\n\t/**\n\t * Set the {@link Marshaller} to be used by this message converter.\n\t */\n\tpublic void setMarshaller(Marshaller marshaller) {\n\t\tthis.marshaller = marshaller;\n\t}\n\n\t/**\n\t * Set the {@link Unmarshaller} to be used by this message converter.\n\t */\n\tpublic void setUnmarshaller(Unmarshaller unmarshaller) {\n\t\tthis.unmarshaller = unmarshaller;\n\t}\n\n\n\t@Override\n\tpublic boolean canRead(Class<?> clazz, @Nullable MediaType mediaType) {\n\t\treturn (canRead(mediaType) && this.unmarshaller != null && this.unmarshaller.supports(clazz));\n\t}\n\n\t@Override\n\tpublic boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType) {\n\t\treturn (canWrite(mediaType) && this.marshaller != null && this.marshaller.supports(clazz));\n\t}\n\n\t@Override\n\tprotected boolean supports(Class<?> clazz) {\n\t\t// should not be called, since we override canRead()/canWrite()\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tprotected Object readFromSource(Class<?> clazz, HttpHeaders headers, Source source) throws Exception {\n\t\tAssert.state(this.unmarshaller != null, \"Property 'unmarshaller' is required\");\n\t\tObject result = this.unmarshaller.unmarshal(source);\n\t\tif (!clazz.isInstance(result)) {\n\t\t\tthrow new TypeMismatchException(result, clazz);\n\t\t}\n\t\treturn result;\n\t}\n\n\t@Override\n\tprotected void writeToResult(Object o, HttpHeaders headers, Result result) throws Exception {\n\t\tAssert.state(this.marshaller != null, \"Property 'marshaller' is required\");\n\t\tthis.marshaller.marshal(o, result);\n\t}\n\n}"
  },
  "org.springframework.http.converter.xml.MarshallingHttpMessageConverter#canRead(clazz,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "boolean",
    "signature": "public boolean canRead(Class<?> clazz, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canRead(Class<?> clazz, @Nullable MediaType mediaType) {\n\t\treturn (canRead(mediaType) && this.unmarshaller != null && this.unmarshaller.supports(clazz));\n\t}"
  },
  "org.springframework.http.converter.xml.MarshallingHttpMessageConverter#canWrite(clazz,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "boolean",
    "signature": "public boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType) {\n\t\treturn (canWrite(mediaType) && this.marshaller != null && this.marshaller.supports(clazz));\n\t}"
  },
  "org.springframework.http.converter.xml.MarshallingHttpMessageConverter#readFromSource(clazz,headers,source)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz",
      "headers",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "Object",
    "signature": "protected Object readFromSource(Class<?> clazz, HttpHeaders headers, Source source)",
    "source_code": "\tprotected Object readFromSource(Class<?> clazz, HttpHeaders headers, Source source) throws Exception {\n\t\tAssert.state(this.unmarshaller != null, \"Property 'unmarshaller' is required\");\n\t\tObject result = this.unmarshaller.unmarshal(source);\n\t\tif (!clazz.isInstance(result)) {\n\t\t\tthrow new TypeMismatchException(result, clazz);\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.http.converter.xml.MarshallingHttpMessageConverter#setMarshaller(marshaller)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link Marshaller} to be used by this message converter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "marshaller"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "public void setMarshaller(Marshaller marshaller)",
    "source_code": "\tpublic void setMarshaller(Marshaller marshaller) {\n\t\tthis.marshaller = marshaller;\n\t}"
  },
  "org.springframework.http.converter.xml.MarshallingHttpMessageConverter#setUnmarshaller(unmarshaller)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link Unmarshaller} to be used by this message converter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "unmarshaller"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "void",
    "signature": "public void setUnmarshaller(Unmarshaller unmarshaller)",
    "source_code": "\tpublic void setUnmarshaller(Unmarshaller unmarshaller) {\n\t\tthis.unmarshaller = unmarshaller;\n\t}"
  },
  "org.springframework.http.converter.xml.MarshallingHttpMessageConverter#supports(clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "boolean",
    "signature": "protected boolean supports(Class<?> clazz)",
    "source_code": "\tprotected boolean supports(Class<?> clazz) {\n\t\t// should not be called, since we override canRead()/canWrite()\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.http.converter.xml.MarshallingHttpMessageConverter#writeToResult(o,headers,result)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "o",
      "headers",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "void",
    "signature": "protected void writeToResult(Object o, HttpHeaders headers, Result result)",
    "source_code": "\tprotected void writeToResult(Object o, HttpHeaders headers, Result result) throws Exception {\n\t\tAssert.state(this.marshaller != null, \"Property 'marshaller' is required\");\n\t\tthis.marshaller.marshal(o, result);\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#getPeerCertificates()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "X509Certificate[]",
    "signature": "public X509Certificate[] getPeerCertificates()",
    "source_code": "\tpublic X509Certificate[] getPeerCertificates() {\n\t\treturn this.peerCertificates;\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#getSessionId()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "String",
    "signature": "public String getSessionId()",
    "source_code": "\tpublic String getSessionId() {\n\t\treturn this.sessionId;\n\t}"
  },
  "org.springframework.http.server.reactive.ChannelSendOperator": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Given a write function that accepts a source {@code Publisher<T>} to write\n * with and returns {@code Publisher<Void>} for the result, this operator helps\n * to defer the invocation of the write function, until we know if the source\n * publisher will begin publishing without an error. If the first emission is\n * an error, the write function is bypassed, and the error is sent directly\n * through the result publisher. Otherwise the write function is invoked.\n *\n * @author Rossen Stoyanchev\n * @author Stephane Maldini\n * @since 5.0\n * @param <T> the type of element signaled\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "signature": "public class ChannelSendOperator",
    "source_code": "public class ChannelSendOperator<T> extends Mono<Void> implements Scannable {\n\n\tprivate final Function<Publisher<T>, Publisher<Void>> writeFunction;\n\n\tprivate final Flux<T> source;\n\n\n\tpublic ChannelSendOperator(Publisher<? extends T> source, Function<Publisher<T>, Publisher<Void>> writeFunction) {\n\t\tthis.source = Flux.from(source);\n\t\tthis.writeFunction = writeFunction;\n\t}\n\n\n\t@Override\n\t@Nullable\n\t@SuppressWarnings(\"rawtypes\")\n\tpublic Object scanUnsafe(Attr key) {\n\t\tif (key == Attr.PREFETCH) {\n\t\t\treturn Integer.MAX_VALUE;\n\t\t}\n\t\tif (key == Attr.PARENT) {\n\t\t\treturn this.source;\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void subscribe(CoreSubscriber<? super Void> actual) {\n\t\tthis.source.subscribe(new WriteBarrier(actual));\n\t}\n\n\n\tprivate enum State {\n\n\t\t/** No emissions from the upstream source yet. */\n\t\tNEW,\n\n\t\t/**\n\t\t * At least one signal of any kind has been received; we're ready to\n\t\t * call the write function and proceed with actual writing.\n\t\t */\n\t\tFIRST_SIGNAL_RECEIVED,\n\n\t\t/**\n\t\t * The write subscriber has subscribed and requested; we're going to\n\t\t * emit the cached signals.\n\t\t */\n\t\tEMITTING_CACHED_SIGNALS,\n\n\t\t/**\n\t\t * The write subscriber has subscribed, and cached signals have been\n\t\t * emitted to it; we're ready to switch to a simple pass-through mode\n\t\t * for all remaining signals.\n\t\t **/\n\t\tREADY_TO_WRITE\n\n\t}\n\n\n\t/**\n\t * A barrier inserted between the write source and the write subscriber\n\t * (i.e. the HTTP server adapter) that pre-fetches and waits for the first\n\t * signal before deciding whether to hook in to the write subscriber.\n\t *\n\t * <p>Acts as:\n\t * <ul>\n\t * <li>Subscriber to the write source.\n\t * <li>Subscription to the write subscriber.\n\t * <li>Publisher to the write subscriber.\n\t * </ul>\n\t *\n\t * <p>Also uses {@link WriteCompletionBarrier} to communicate completion\n\t * and detect cancel signals from the completion subscriber.\n\t */\n\tprivate class WriteBarrier implements CoreSubscriber<T>, Subscription, Publisher<T> {\n\n\t\t/* Bridges signals to and from the completionSubscriber */\n\t\tprivate final WriteCompletionBarrier writeCompletionBarrier;\n\n\t\t/* Upstream write source subscription */\n\t\t@Nullable\n\t\tprivate Subscription subscription;\n\n\t\t/** Cached data item before readyToWrite. */\n\t\t@Nullable\n\t\tprivate T item;\n\n\t\t/** Cached error signal before readyToWrite. */\n\t\t@Nullable\n\t\tprivate Throwable error;\n\n\t\t/** Cached onComplete signal before readyToWrite. */\n\t\tprivate boolean completed = false;\n\n\t\t/** Recursive demand while emitting cached signals. */\n\t\tprivate long demandBeforeReadyToWrite;\n\n\t\t/** Current state. */\n\t\tprivate State state = State.NEW;\n\n\t\t/** The actual writeSubscriber from the HTTP server adapter. */\n\t\t@Nullable\n\t\tprivate Subscriber<? super T> writeSubscriber;\n\n\n\t\tWriteBarrier(CoreSubscriber<? super Void> completionSubscriber) {\n\t\t\tthis.writeCompletionBarrier = new WriteCompletionBarrier(completionSubscriber, this);\n\t\t}\n\n\n\t\t// Subscriber<T> methods (we're the subscriber to the write source)..\n\n\t\t@Override\n\t\tpublic final void onSubscribe(Subscription s) {\n\t\t\tif (Operators.validate(this.subscription, s)) {\n\t\t\t\tthis.subscription = s;\n\t\t\t\tthis.writeCompletionBarrier.connect();\n\t\t\t\ts.request(1);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic final void onNext(T item) {\n\t\t\tif (this.state == State.READY_TO_WRITE) {\n\t\t\t\trequiredWriteSubscriber().onNext(item);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//FIXME revisit in case of reentrant sync deadlock\n\t\t\tsynchronized (this) {\n\t\t\t\tif (this.state == State.READY_TO_WRITE) {\n\t\t\t\t\trequiredWriteSubscriber().onNext(item);\n\t\t\t\t}\n\t\t\t\telse if (this.state == State.NEW) {\n\t\t\t\t\tthis.item = item;\n\t\t\t\t\tthis.state = State.FIRST_SIGNAL_RECEIVED;\n\t\t\t\t\tPublisher<Void> result;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresult = writeFunction.apply(this);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tthis.writeCompletionBarrier.onError(ex);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tresult.subscribe(this.writeCompletionBarrier);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (this.subscription != null) {\n\t\t\t\t\t\tthis.subscription.cancel();\n\t\t\t\t\t}\n\t\t\t\t\tthis.writeCompletionBarrier.onError(new IllegalStateException(\"Unexpected item.\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate Subscriber<? super T> requiredWriteSubscriber() {\n\t\t\tAssert.state(this.writeSubscriber != null, \"No write subscriber\");\n\t\t\treturn this.writeSubscriber;\n\t\t}\n\n\t\t@Override\n\t\tpublic final void onError(Throwable ex) {\n\t\t\tif (this.state == State.READY_TO_WRITE) {\n\t\t\t\trequiredWriteSubscriber().onError(ex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsynchronized (this) {\n\t\t\t\tif (this.state == State.READY_TO_WRITE) {\n\t\t\t\t\trequiredWriteSubscriber().onError(ex);\n\t\t\t\t}\n\t\t\t\telse if (this.state == State.NEW) {\n\t\t\t\t\tthis.state = State.FIRST_SIGNAL_RECEIVED;\n\t\t\t\t\tthis.writeCompletionBarrier.onError(ex);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.error = ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic final void onComplete() {\n\t\t\tif (this.state == State.READY_TO_WRITE) {\n\t\t\t\trequiredWriteSubscriber().onComplete();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsynchronized (this) {\n\t\t\t\tif (this.state == State.READY_TO_WRITE) {\n\t\t\t\t\trequiredWriteSubscriber().onComplete();\n\t\t\t\t}\n\t\t\t\telse if (this.state == State.NEW) {\n\t\t\t\t\tthis.completed = true;\n\t\t\t\t\tthis.state = State.FIRST_SIGNAL_RECEIVED;\n\t\t\t\t\tPublisher<Void> result;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresult = writeFunction.apply(this);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tthis.writeCompletionBarrier.onError(ex);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tresult.subscribe(this.writeCompletionBarrier);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.completed = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Context currentContext() {\n\t\t\treturn this.writeCompletionBarrier.currentContext();\n\t\t}\n\n\n\t\t// Subscription methods (we're the Subscription to the writeSubscriber)..\n\n\t\t@Override\n\t\tpublic void request(long n) {\n\t\t\tSubscription s = this.subscription;\n\t\t\tif (s == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this.state == State.READY_TO_WRITE) {\n\t\t\t\ts.request(n);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsynchronized (this) {\n\t\t\t\tif (this.writeSubscriber != null) {\n\t\t\t\t\tif (this.state == State.EMITTING_CACHED_SIGNALS) {\n\t\t\t\t\t\tthis.demandBeforeReadyToWrite = n;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.state = State.EMITTING_CACHED_SIGNALS;\n\t\t\t\t\t\tif (emitCachedSignals()) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn = n + this.demandBeforeReadyToWrite - 1;\n\t\t\t\t\t\tif (n == 0) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tthis.state = State.READY_TO_WRITE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ts.request(n);\n\t\t}\n\n\t\tprivate boolean emitCachedSignals() {\n\t\t\tif (this.error != null) {\n\t\t\t\ttry {\n\t\t\t\t\trequiredWriteSubscriber().onError(this.error);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\treleaseCachedItem();\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tT item = this.item;\n\t\t\tthis.item = null;\n\t\t\tif (item != null) {\n\t\t\t\trequiredWriteSubscriber().onNext(item);\n\t\t\t}\n\t\t\tif (this.completed) {\n\t\t\t\trequiredWriteSubscriber().onComplete();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic void cancel() {\n\t\t\tSubscription s = this.subscription;\n\t\t\tif (s != null) {\n\t\t\t\tthis.subscription = null;\n\t\t\t\ttry {\n\t\t\t\t\ts.cancel();\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\treleaseCachedItem();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void releaseCachedItem() {\n\t\t\tsynchronized (this) {\n\t\t\t\tObject item = this.item;\n\t\t\t\tif (item instanceof DataBuffer dataBuffer) {\n\t\t\t\t\tDataBufferUtils.release(dataBuffer);\n\t\t\t\t}\n\t\t\t\tthis.item = null;\n\t\t\t}\n\t\t}\n\n\n\t\t// Publisher<T> methods (we're the Publisher to the writeSubscriber)..\n\n\t\t@Override\n\t\tpublic void subscribe(Subscriber<? super T> writeSubscriber) {\n\t\t\tsynchronized (this) {\n\t\t\t\tAssert.state(this.writeSubscriber == null, \"Only one write subscriber supported\");\n\t\t\t\tthis.writeSubscriber = writeSubscriber;\n\t\t\t\tif (this.error != null || this.completed) {\n\t\t\t\t\tthis.writeSubscriber.onSubscribe(Operators.emptySubscription());\n\t\t\t\t\temitCachedSignals();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.writeSubscriber.onSubscribe(this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * We need an extra barrier between the WriteBarrier itself and the actual\n\t * completion subscriber.\n\t *\n\t * <p>The completionSubscriber is subscribed initially to the WriteBarrier.\n\t * Later after the first signal is received, we need one more subscriber\n\t * instance (per spec can only subscribe once) to subscribe to the write\n\t * function and switch to delegating completion signals from it.\n\t */\n\tprivate class WriteCompletionBarrier implements CoreSubscriber<Void>, Subscription {\n\n\t\t/* Downstream write completion subscriber */\n\t\tprivate final CoreSubscriber<? super Void> completionSubscriber;\n\n\t\tprivate final WriteBarrier writeBarrier;\n\n\t\t@Nullable\n\t\tprivate Subscription subscription;\n\n\n\t\tpublic WriteCompletionBarrier(CoreSubscriber<? super Void> subscriber, WriteBarrier writeBarrier) {\n\t\t\tthis.completionSubscriber = subscriber;\n\t\t\tthis.writeBarrier = writeBarrier;\n\t\t}\n\n\n\t\t/**\n\t\t * Connect the underlying completion subscriber to this barrier in order\n\t\t * to track cancel signals and pass them on to the write barrier.\n\t\t */\n\t\tpublic void connect() {\n\t\t\tthis.completionSubscriber.onSubscribe(this);\n\t\t}\n\n\t\t// Subscriber methods (we're the subscriber to the write function)..\n\n\t\t@Override\n\t\tpublic void onSubscribe(Subscription subscription) {\n\t\t\tthis.subscription = subscription;\n\t\t\tsubscription.request(Long.MAX_VALUE);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onNext(Void aVoid) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void onError(Throwable ex) {\n\t\t\ttry {\n\t\t\t\tthis.completionSubscriber.onError(ex);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.writeBarrier.releaseCachedItem();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void onComplete() {\n\t\t\tthis.completionSubscriber.onComplete();\n\t\t}\n\n\t\t@Override\n\t\tpublic Context currentContext() {\n\t\t\treturn this.completionSubscriber.currentContext();\n\t\t}\n\n\n\t\t@Override\n\t\tpublic void request(long n) {\n\t\t\t// Ignore: we don't produce data\n\t\t}\n\n\t\t@Override\n\t\tpublic void cancel() {\n\t\t\tthis.writeBarrier.cancel();\n\t\t\tSubscription subscription = this.subscription;\n\t\t\tif (subscription != null) {\n\t\t\t\tsubscription.cancel();\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.http.server.reactive.ChannelSendOperator#cancel()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 438
    },
    "return": "void",
    "signature": "public void cancel()",
    "source_code": "\t\tpublic void cancel() {\n\t\t\tthis.writeBarrier.cancel();\n\t\t\tSubscription subscription = this.subscription;\n\t\t\tif (subscription != null) {\n\t\t\t\tsubscription.cancel();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.http.server.reactive.ChannelSendOperator#connect()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Connect the underlying completion subscriber to this barrier in order\n\t\t * to track cancel signals and pass them on to the write barrier.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 395
    },
    "return": "void",
    "signature": "public void connect()",
    "source_code": "\t\tpublic void connect() {\n\t\t\tthis.completionSubscriber.onSubscribe(this);\n\t\t}"
  },
  "org.springframework.http.server.reactive.ChannelSendOperator#currentContext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 427
    },
    "return": "Context",
    "signature": "public Context currentContext()",
    "source_code": "\t\tpublic Context currentContext() {\n\t\t\treturn this.completionSubscriber.currentContext();\n\t\t}"
  },
  "org.springframework.http.server.reactive.ChannelSendOperator#onComplete()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 422
    },
    "return": "void",
    "signature": "public void onComplete()",
    "source_code": "\t\tpublic void onComplete() {\n\t\t\tthis.completionSubscriber.onComplete();\n\t\t}"
  },
  "org.springframework.http.server.reactive.ChannelSendOperator#onError(ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 412
    },
    "return": "void",
    "signature": "public void onError(Throwable ex)",
    "source_code": "\t\tpublic void onError(Throwable ex) {\n\t\t\ttry {\n\t\t\t\tthis.completionSubscriber.onError(ex);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.writeBarrier.releaseCachedItem();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.http.server.reactive.ChannelSendOperator#onNext(aVoid)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "aVoid"
    ],
    "position": {
      "column": 1,
      "line": 408
    },
    "return": "void",
    "signature": "public void onNext(Void aVoid)",
    "source_code": "\t\tpublic void onNext(Void aVoid) {\n\t\t}"
  },
  "org.springframework.http.server.reactive.ChannelSendOperator#onNext(item)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "item"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "void",
    "signature": "public void onNext(T item)",
    "source_code": "\t\tpublic final void onNext(T item) {\n\t\t\tif (this.state == State.READY_TO_WRITE) {\n\t\t\t\trequiredWriteSubscriber().onNext(item);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//FIXME revisit in case of reentrant sync deadlock\n\t\t\tsynchronized (this) {\n\t\t\t\tif (this.state == State.READY_TO_WRITE) {\n\t\t\t\t\trequiredWriteSubscriber().onNext(item);\n\t\t\t\t}\n\t\t\t\telse if (this.state == State.NEW) {\n\t\t\t\t\tthis.item = item;\n\t\t\t\t\tthis.state = State.FIRST_SIGNAL_RECEIVED;\n\t\t\t\t\tPublisher<Void> result;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresult = writeFunction.apply(this);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tthis.writeCompletionBarrier.onError(ex);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tresult.subscribe(this.writeCompletionBarrier);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (this.subscription != null) {\n\t\t\t\t\t\tthis.subscription.cancel();\n\t\t\t\t\t}\n\t\t\t\t\tthis.writeCompletionBarrier.onError(new IllegalStateException(\"Unexpected item.\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.http.server.reactive.ChannelSendOperator#onSubscribe(s)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "s"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "void",
    "signature": "public void onSubscribe(Subscription s)",
    "source_code": "\t\tpublic final void onSubscribe(Subscription s) {\n\t\t\tif (Operators.validate(this.subscription, s)) {\n\t\t\t\tthis.subscription = s;\n\t\t\t\tthis.writeCompletionBarrier.connect();\n\t\t\t\ts.request(1);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.http.server.reactive.ChannelSendOperator#onSubscribe(subscription)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "subscription"
    ],
    "position": {
      "column": 1,
      "line": 402
    },
    "return": "void",
    "signature": "public void onSubscribe(Subscription subscription)",
    "source_code": "\t\tpublic void onSubscribe(Subscription subscription) {\n\t\t\tthis.subscription = subscription;\n\t\t\tsubscription.request(Long.MAX_VALUE);\n\t\t}"
  },
  "org.springframework.http.server.reactive.ChannelSendOperator#request(n)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "n"
    ],
    "position": {
      "column": 1,
      "line": 433
    },
    "return": "void",
    "signature": "public void request(long n)",
    "source_code": "\t\tpublic void request(long n) {\n\t\t\t// Ignore: we don't produce data\n\t\t}"
  },
  "org.springframework.http.server.reactive.ChannelSendOperator#scanUnsafe(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "Object",
    "signature": "public Object scanUnsafe(Attr key)",
    "source_code": "\tpublic Object scanUnsafe(Attr key) {\n\t\tif (key == Attr.PREFETCH) {\n\t\t\treturn Integer.MAX_VALUE;\n\t\t}\n\t\tif (key == Attr.PARENT) {\n\t\t\treturn this.source;\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.server.reactive.ChannelSendOperator#subscribe(actual)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "actual"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "void",
    "signature": "public void subscribe(CoreSubscriber<? super Void> actual)",
    "source_code": "\tpublic void subscribe(CoreSubscriber<? super Void> actual) {\n\t\tthis.source.subscribe(new WriteBarrier(actual));\n\t}"
  },
  "org.springframework.http.server.reactive.ChannelSendOperator#subscribe(writeSubscriber)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "writeSubscriber"
    ],
    "position": {
      "column": 1,
      "line": 349
    },
    "return": "void",
    "signature": "public void subscribe(Subscriber<? super T> writeSubscriber)",
    "source_code": "\t\tpublic void subscribe(Subscriber<? super T> writeSubscriber) {\n\t\t\tsynchronized (this) {\n\t\t\t\tAssert.state(this.writeSubscriber == null, \"Only one write subscriber supported\");\n\t\t\t\tthis.writeSubscriber = writeSubscriber;\n\t\t\t\tif (this.error != null || this.completed) {\n\t\t\t\t\tthis.writeSubscriber.onSubscribe(Operators.emptySubscription());\n\t\t\t\t\temitCachedSignals();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.writeSubscriber.onSubscribe(this);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.http.server.reactive.ServerHttpRequestDecorator": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Wraps another {@link ServerHttpRequest} and delegates all methods to it.\n * Subclasses can override specific methods selectively.\n *\n * @author Rossen Stoyanchev\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 40
    },
    "signature": "public class ServerHttpRequestDecorator",
    "source_code": "public class ServerHttpRequestDecorator implements ServerHttpRequest {\n\n\tprivate final ServerHttpRequest delegate;\n\n\n\tpublic ServerHttpRequestDecorator(ServerHttpRequest delegate) {\n\t\tAssert.notNull(delegate, \"Delegate is required\");\n\t\tthis.delegate = delegate;\n\t}\n\n\n\tpublic ServerHttpRequest getDelegate() {\n\t\treturn this.delegate;\n\t}\n\n\n\t// ServerHttpRequest delegation methods...\n\n\t@Override\n\tpublic String getId() {\n\t\treturn getDelegate().getId();\n\t}\n\n\t@Override\n\tpublic HttpMethod getMethod() {\n\t\treturn getDelegate().getMethod();\n\t}\n\n\t@Override\n\tpublic URI getURI() {\n\t\treturn getDelegate().getURI();\n\t}\n\n\t@Override\n\tpublic RequestPath getPath() {\n\t\treturn getDelegate().getPath();\n\t}\n\n\t@Override\n\tpublic MultiValueMap<String, String> getQueryParams() {\n\t\treturn getDelegate().getQueryParams();\n\t}\n\n\t@Override\n\tpublic HttpHeaders getHeaders() {\n\t\treturn getDelegate().getHeaders();\n\t}\n\n\t@Override\n\tpublic MultiValueMap<String, HttpCookie> getCookies() {\n\t\treturn getDelegate().getCookies();\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic InetSocketAddress getLocalAddress() {\n\t\treturn getDelegate().getLocalAddress();\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic InetSocketAddress getRemoteAddress() {\n\t\treturn getDelegate().getRemoteAddress();\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic SslInfo getSslInfo() {\n\t\treturn getDelegate().getSslInfo();\n\t}\n\n\t@Override\n\tpublic Flux<DataBuffer> getBody() {\n\t\treturn getDelegate().getBody();\n\t}\n\n\n\t/**\n\t * Return the native request of the underlying server API, if possible,\n\t * also unwrapping {@link ServerHttpRequestDecorator} if necessary.\n\t * @param request the request to check\n\t * @param <T> the expected native request type\n\t * @throws IllegalArgumentException if the native request can't be obtained\n\t * @since 5.3.3\n\t */\n\tpublic static <T> T getNativeRequest(ServerHttpRequest request) {\n\t\tif (request instanceof AbstractServerHttpRequest abstractServerHttpRequest) {\n\t\t\treturn abstractServerHttpRequest.getNativeRequest();\n\t\t}\n\t\telse if (request instanceof ServerHttpRequestDecorator serverHttpRequestDecorator) {\n\t\t\treturn getNativeRequest(serverHttpRequestDecorator.getDelegate());\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Can't find native request in \" + request.getClass().getName());\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \" [delegate=\" + getDelegate() + \"]\";\n\t}\n\n}"
  },
  "org.springframework.http.server.reactive.ServerHttpRequestDecorator#getBody()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> getBody()",
    "source_code": "\tpublic Flux<DataBuffer> getBody() {\n\t\treturn getDelegate().getBody();\n\t}"
  },
  "org.springframework.http.server.reactive.ServerHttpRequestDecorator#getCookies()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "HttpCookie>",
    "signature": "public HttpCookie> getCookies()",
    "source_code": "\tpublic MultiValueMap<String, HttpCookie> getCookies() {\n\t\treturn getDelegate().getCookies();\n\t}"
  },
  "org.springframework.http.server.reactive.ServerHttpRequestDecorator#getDelegate()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 51
    },
    "return": "ServerHttpRequest",
    "signature": "public ServerHttpRequest getDelegate()",
    "source_code": "\tpublic ServerHttpRequest getDelegate() {\n\t\treturn this.delegate;\n\t}"
  },
  "org.springframework.http.server.reactive.ServerHttpRequestDecorator#getHeaders()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders getHeaders()",
    "source_code": "\tpublic HttpHeaders getHeaders() {\n\t\treturn getDelegate().getHeaders();\n\t}"
  },
  "org.springframework.http.server.reactive.ServerHttpRequestDecorator#getId()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "String",
    "signature": "public String getId()",
    "source_code": "\tpublic String getId() {\n\t\treturn getDelegate().getId();\n\t}"
  },
  "org.springframework.http.server.reactive.ServerHttpRequestDecorator#getLocalAddress()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "InetSocketAddress",
    "signature": "public InetSocketAddress getLocalAddress()",
    "source_code": "\tpublic InetSocketAddress getLocalAddress() {\n\t\treturn getDelegate().getLocalAddress();\n\t}"
  },
  "org.springframework.http.server.reactive.ServerHttpRequestDecorator#getMethod()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "HttpMethod",
    "signature": "public HttpMethod getMethod()",
    "source_code": "\tpublic HttpMethod getMethod() {\n\t\treturn getDelegate().getMethod();\n\t}"
  },
  "org.springframework.http.server.reactive.ServerHttpRequestDecorator#getNativeRequest(request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the native request of the underlying server API, if possible,\n\t * also unwrapping {@link ServerHttpRequestDecorator} if necessary.\n\t * @param request the request to check\n\t * @param <T> the expected native request type\n\t * @throws IllegalArgumentException if the native request can't be obtained\n\t * @since 5.3.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "T",
    "signature": "public T getNativeRequest(ServerHttpRequest request)",
    "source_code": "\tpublic static <T> T getNativeRequest(ServerHttpRequest request) {\n\t\tif (request instanceof AbstractServerHttpRequest abstractServerHttpRequest) {\n\t\t\treturn abstractServerHttpRequest.getNativeRequest();\n\t\t}\n\t\telse if (request instanceof ServerHttpRequestDecorator serverHttpRequestDecorator) {\n\t\t\treturn getNativeRequest(serverHttpRequestDecorator.getDelegate());\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Can't find native request in \" + request.getClass().getName());\n\t\t}\n\t}"
  },
  "org.springframework.http.server.reactive.ServerHttpRequestDecorator#getPath()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "RequestPath",
    "signature": "public RequestPath getPath()",
    "source_code": "\tpublic RequestPath getPath() {\n\t\treturn getDelegate().getPath();\n\t}"
  },
  "org.springframework.http.server.reactive.ServerHttpRequestDecorator#getQueryParams()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "String>",
    "signature": "public String> getQueryParams()",
    "source_code": "\tpublic MultiValueMap<String, String> getQueryParams() {\n\t\treturn getDelegate().getQueryParams();\n\t}"
  },
  "org.springframework.http.server.reactive.ServerHttpRequestDecorator#getRemoteAddress()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "InetSocketAddress",
    "signature": "public InetSocketAddress getRemoteAddress()",
    "source_code": "\tpublic InetSocketAddress getRemoteAddress() {\n\t\treturn getDelegate().getRemoteAddress();\n\t}"
  },
  "org.springframework.http.server.reactive.ServerHttpRequestDecorator#getSslInfo()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "SslInfo",
    "signature": "public SslInfo getSslInfo()",
    "source_code": "\tpublic SslInfo getSslInfo() {\n\t\treturn getDelegate().getSslInfo();\n\t}"
  },
  "org.springframework.http.server.reactive.ServerHttpRequestDecorator#getURI()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "URI",
    "signature": "public URI getURI()",
    "source_code": "\tpublic URI getURI() {\n\t\treturn getDelegate().getURI();\n\t}"
  },
  "org.springframework.http.server.reactive.ServerHttpRequestDecorator#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \" [delegate=\" + getDelegate() + \"]\";\n\t}"
  },
  "org.springframework.http.server.reactive.ServerHttpResponseDecorator": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Wraps another {@link ServerHttpResponse} and delegates all methods to it.\n * Subclasses can override specific methods selectively.\n *\n * @author Rossen Stoyanchev\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 40
    },
    "signature": "public class ServerHttpResponseDecorator",
    "source_code": "public class ServerHttpResponseDecorator implements ServerHttpResponse {\n\n\tprivate final ServerHttpResponse delegate;\n\n\n\tpublic ServerHttpResponseDecorator(ServerHttpResponse delegate) {\n\t\tAssert.notNull(delegate, \"Delegate is required\");\n\t\tthis.delegate = delegate;\n\t}\n\n\n\tpublic ServerHttpResponse getDelegate() {\n\t\treturn this.delegate;\n\t}\n\n\n\t// ServerHttpResponse delegation methods...\n\n\t@Override\n\tpublic boolean setStatusCode(@Nullable HttpStatusCode status) {\n\t\treturn getDelegate().setStatusCode(status);\n\t}\n\n\t@Override\n\tpublic HttpStatusCode getStatusCode() {\n\t\treturn getDelegate().getStatusCode();\n\t}\n\n\t@Override\n\tpublic boolean setRawStatusCode(@Nullable Integer value) {\n\t\treturn getDelegate().setRawStatusCode(value);\n\t}\n\n\t@Override\n\t@Deprecated\n\tpublic Integer getRawStatusCode() {\n\t\treturn getDelegate().getRawStatusCode();\n\t}\n\n\t@Override\n\tpublic HttpHeaders getHeaders() {\n\t\treturn getDelegate().getHeaders();\n\t}\n\n\t@Override\n\tpublic MultiValueMap<String, ResponseCookie> getCookies() {\n\t\treturn getDelegate().getCookies();\n\t}\n\n\t@Override\n\tpublic void addCookie(ResponseCookie cookie) {\n\t\tgetDelegate().addCookie(cookie);\n\t}\n\n\t@Override\n\tpublic DataBufferFactory bufferFactory() {\n\t\treturn getDelegate().bufferFactory();\n\t}\n\n\t@Override\n\tpublic void beforeCommit(Supplier<? extends Mono<Void>> action) {\n\t\tgetDelegate().beforeCommit(action);\n\t}\n\n\t@Override\n\tpublic boolean isCommitted() {\n\t\treturn getDelegate().isCommitted();\n\t}\n\n\t@Override\n\tpublic Mono<Void> writeWith(Publisher<? extends DataBuffer> body) {\n\t\treturn getDelegate().writeWith(body);\n\t}\n\n\t@Override\n\tpublic Mono<Void> writeAndFlushWith(Publisher<? extends Publisher<? extends DataBuffer>> body) {\n\t\treturn getDelegate().writeAndFlushWith(body);\n\t}\n\n\t@Override\n\tpublic Mono<Void> setComplete() {\n\t\treturn getDelegate().setComplete();\n\t}\n\n\n\t/**\n\t * Return the native response of the underlying server API, if possible,\n\t * also unwrapping {@link ServerHttpResponseDecorator} if necessary.\n\t * @param response the response to check\n\t * @param <T> the expected native response type\n\t * @throws IllegalArgumentException if the native response can't be obtained\n\t * @since 5.3.3\n\t */\n\tpublic static <T> T getNativeResponse(ServerHttpResponse response) {\n\t\tif (response instanceof AbstractServerHttpResponse abstractServerHttpResponse) {\n\t\t\treturn abstractServerHttpResponse.getNativeResponse();\n\t\t}\n\t\telse if (response instanceof ServerHttpResponseDecorator serverHttpResponseDecorator) {\n\t\t\treturn getNativeResponse(serverHttpResponseDecorator.getDelegate());\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Can't find native response in \" + response.getClass().getName());\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \" [delegate=\" + getDelegate() + \"]\";\n\t}\n\n}"
  },
  "org.springframework.http.server.reactive.ServerHttpResponseDecorator#addCookie(cookie)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cookie"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "void",
    "signature": "public void addCookie(ResponseCookie cookie)",
    "source_code": "\tpublic void addCookie(ResponseCookie cookie) {\n\t\tgetDelegate().addCookie(cookie);\n\t}"
  },
  "org.springframework.http.server.reactive.ServerHttpResponseDecorator#beforeCommit(action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "action"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "public void beforeCommit(Supplier<? extends Mono<Void>> action)",
    "source_code": "\tpublic void beforeCommit(Supplier<? extends Mono<Void>> action) {\n\t\tgetDelegate().beforeCommit(action);\n\t}"
  },
  "org.springframework.http.server.reactive.ServerHttpResponseDecorator#bufferFactory()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "DataBufferFactory",
    "signature": "public DataBufferFactory bufferFactory()",
    "source_code": "\tpublic DataBufferFactory bufferFactory() {\n\t\treturn getDelegate().bufferFactory();\n\t}"
  },
  "org.springframework.http.server.reactive.ServerHttpResponseDecorator#getCookies()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "ResponseCookie>",
    "signature": "public ResponseCookie> getCookies()",
    "source_code": "\tpublic MultiValueMap<String, ResponseCookie> getCookies() {\n\t\treturn getDelegate().getCookies();\n\t}"
  },
  "org.springframework.http.server.reactive.ServerHttpResponseDecorator#getDelegate()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 51
    },
    "return": "ServerHttpResponse",
    "signature": "public ServerHttpResponse getDelegate()",
    "source_code": "\tpublic ServerHttpResponse getDelegate() {\n\t\treturn this.delegate;\n\t}"
  },
  "org.springframework.http.server.reactive.ServerHttpResponseDecorator#getHeaders()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders getHeaders()",
    "source_code": "\tpublic HttpHeaders getHeaders() {\n\t\treturn getDelegate().getHeaders();\n\t}"
  },
  "org.springframework.http.server.reactive.ServerHttpResponseDecorator#getNativeResponse(response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the native response of the underlying server API, if possible,\n\t * also unwrapping {@link ServerHttpResponseDecorator} if necessary.\n\t * @param response the response to check\n\t * @param <T> the expected native response type\n\t * @throws IllegalArgumentException if the native response can't be obtained\n\t * @since 5.3.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "response"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "T",
    "signature": "public T getNativeResponse(ServerHttpResponse response)",
    "source_code": "\tpublic static <T> T getNativeResponse(ServerHttpResponse response) {\n\t\tif (response instanceof AbstractServerHttpResponse abstractServerHttpResponse) {\n\t\t\treturn abstractServerHttpResponse.getNativeResponse();\n\t\t}\n\t\telse if (response instanceof ServerHttpResponseDecorator serverHttpResponseDecorator) {\n\t\t\treturn getNativeResponse(serverHttpResponseDecorator.getDelegate());\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Can't find native response in \" + response.getClass().getName());\n\t\t}\n\t}"
  },
  "org.springframework.http.server.reactive.ServerHttpResponseDecorator#getRawStatusCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "Integer",
    "signature": "public Integer getRawStatusCode()",
    "source_code": "\tpublic Integer getRawStatusCode() {\n\t\treturn getDelegate().getRawStatusCode();\n\t}"
  },
  "org.springframework.http.server.reactive.ServerHttpResponseDecorator#getStatusCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "HttpStatusCode",
    "signature": "public HttpStatusCode getStatusCode()",
    "source_code": "\tpublic HttpStatusCode getStatusCode() {\n\t\treturn getDelegate().getStatusCode();\n\t}"
  },
  "org.springframework.http.server.reactive.ServerHttpResponseDecorator#isCommitted()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "boolean",
    "signature": "public boolean isCommitted()",
    "source_code": "\tpublic boolean isCommitted() {\n\t\treturn getDelegate().isCommitted();\n\t}"
  },
  "org.springframework.http.server.reactive.ServerHttpResponseDecorator#setComplete()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> setComplete()",
    "source_code": "\tpublic Mono<Void> setComplete() {\n\t\treturn getDelegate().setComplete();\n\t}"
  },
  "org.springframework.http.server.reactive.ServerHttpResponseDecorator#setRawStatusCode(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "boolean",
    "signature": "public boolean setRawStatusCode(@Nullable Integer value)",
    "source_code": "\tpublic boolean setRawStatusCode(@Nullable Integer value) {\n\t\treturn getDelegate().setRawStatusCode(value);\n\t}"
  },
  "org.springframework.http.server.reactive.ServerHttpResponseDecorator#setStatusCode(status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "boolean",
    "signature": "public boolean setStatusCode(@Nullable HttpStatusCode status)",
    "source_code": "\tpublic boolean setStatusCode(@Nullable HttpStatusCode status) {\n\t\treturn getDelegate().setStatusCode(status);\n\t}"
  },
  "org.springframework.http.server.reactive.ServerHttpResponseDecorator#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \" [delegate=\" + getDelegate() + \"]\";\n\t}"
  },
  "org.springframework.http.server.reactive.ServerHttpResponseDecorator#writeAndFlushWith(body)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> writeAndFlushWith(Publisher<? extends Publisher<? extends DataBuffer>> body)",
    "source_code": "\tpublic Mono<Void> writeAndFlushWith(Publisher<? extends Publisher<? extends DataBuffer>> body) {\n\t\treturn getDelegate().writeAndFlushWith(body);\n\t}"
  },
  "org.springframework.http.server.reactive.ServerHttpResponseDecorator#writeWith(body)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> writeWith(Publisher<? extends DataBuffer> body)",
    "source_code": "\tpublic Mono<Void> writeWith(Publisher<? extends DataBuffer> body) {\n\t\treturn getDelegate().writeWith(body);\n\t}"
  },
  "org.springframework.messaging.handler.invocation.HandlerMethodReturnValueHandlerComposite": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A HandlerMethodReturnValueHandler that wraps and delegates to others.\n *\n * @author Rossen Stoyanchev\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "signature": "public class HandlerMethodReturnValueHandlerComposite",
    "source_code": "public class HandlerMethodReturnValueHandlerComposite implements AsyncHandlerMethodReturnValueHandler {\n\n\t/** Public for wrapping with fallback logger. */\n\tpublic static final Log defaultLogger = LogFactory.getLog(HandlerMethodReturnValueHandlerComposite.class);\n\n\n\tprivate Log logger = defaultLogger;\n\n\tprivate final List<HandlerMethodReturnValueHandler> returnValueHandlers = new ArrayList<>();\n\n\n\t/**\n\t * Set an alternative logger to use than the one based on the class name.\n\t * @param logger the logger to use\n\t * @since 5.1\n\t */\n\tpublic void setLogger(Log logger) {\n\t\tthis.logger = logger;\n\t}\n\n\t/**\n\t * Return the currently configured Logger.\n\t * @since 5.1\n\t */\n\tpublic Log getLogger() {\n\t\treturn logger;\n\t}\n\n\t/**\n\t * Return a read-only list with the configured handlers.\n\t */\n\tpublic List<HandlerMethodReturnValueHandler> getReturnValueHandlers() {\n\t\treturn Collections.unmodifiableList(this.returnValueHandlers);\n\t}\n\n\t/**\n\t * Clear the list of configured handlers.\n\t */\n\tpublic void clear() {\n\t\tthis.returnValueHandlers.clear();\n\t}\n\n\t/**\n\t * Add the given {@link HandlerMethodReturnValueHandler}.\n\t */\n\tpublic HandlerMethodReturnValueHandlerComposite addHandler(HandlerMethodReturnValueHandler returnValueHandler) {\n\t\tthis.returnValueHandlers.add(returnValueHandler);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add the given {@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers}.\n\t */\n\tpublic HandlerMethodReturnValueHandlerComposite addHandlers(\n\t\t\t@Nullable List<? extends HandlerMethodReturnValueHandler> handlers) {\n\n\t\tif (handlers != null) {\n\t\t\tthis.returnValueHandlers.addAll(handlers);\n\t\t}\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic boolean supportsReturnType(MethodParameter returnType) {\n\t\treturn getReturnValueHandler(returnType) != null;\n\t}\n\n\t@SuppressWarnings(\"ForLoopReplaceableByForEach\")\n\t@Nullable\n\tprivate HandlerMethodReturnValueHandler getReturnValueHandler(MethodParameter returnType) {\n\t\tfor (HandlerMethodReturnValueHandler handler : this.returnValueHandlers) {\n\t\t\tif (handler.supportsReturnType(returnType)) {\n\t\t\t\treturn handler;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, Message<?> message)\n\t\t\tthrows Exception {\n\n\t\tHandlerMethodReturnValueHandler handler = getReturnValueHandler(returnType);\n\t\tif (handler == null) {\n\t\t\tthrow new IllegalStateException(\"No handler for return value type: \" + returnType.getParameterType());\n\t\t}\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Processing return value with \" + handler);\n\t\t}\n\t\thandler.handleReturnValue(returnValue, returnType, message);\n\t}\n\n\t@Override\n\tpublic boolean isAsyncReturnValue(Object returnValue, MethodParameter returnType) {\n\t\tHandlerMethodReturnValueHandler handler = getReturnValueHandler(returnType);\n\t\treturn (handler instanceof AsyncHandlerMethodReturnValueHandler asyncHandler &&\n\t\t\t\tasyncHandler.isAsyncReturnValue(returnValue, returnType));\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic CompletableFuture<?> toCompletableFuture(Object returnValue, MethodParameter returnType) {\n\t\tHandlerMethodReturnValueHandler handler = getReturnValueHandler(returnType);\n\t\tif (handler instanceof AsyncHandlerMethodReturnValueHandler asyncHandler) {\n\t\t\treturn asyncHandler.toCompletableFuture(returnValue, returnType);\n\t\t}\n\t\treturn null;\n\t}\n\n}"
  },
  "org.springframework.messaging.handler.invocation.HandlerMethodReturnValueHandlerComposite#addHandler(returnValueHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given {@link HandlerMethodReturnValueHandler}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValueHandler"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "HandlerMethodReturnValueHandlerComposite",
    "signature": "public HandlerMethodReturnValueHandlerComposite addHandler(HandlerMethodReturnValueHandler returnValueHandler)",
    "source_code": "\tpublic HandlerMethodReturnValueHandlerComposite addHandler(HandlerMethodReturnValueHandler returnValueHandler) {\n\t\tthis.returnValueHandlers.add(returnValueHandler);\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.HandlerMethodReturnValueHandlerComposite#addHandlers(handlers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given {@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handlers"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "HandlerMethodReturnValueHandlerComposite",
    "signature": "public HandlerMethodReturnValueHandlerComposite addHandlers(@Nullable List<? extends HandlerMethodReturnValueHandler> handlers)",
    "source_code": "\tpublic HandlerMethodReturnValueHandlerComposite addHandlers("
  },
  "org.springframework.messaging.handler.invocation.HandlerMethodReturnValueHandlerComposite#clear()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Clear the list of configured handlers.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\tpublic void clear() {\n\t\tthis.returnValueHandlers.clear();\n\t}"
  },
  "org.springframework.messaging.handler.invocation.HandlerMethodReturnValueHandlerComposite#getLogger()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the currently configured Logger.\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "Log",
    "signature": "public Log getLogger()",
    "source_code": "\tpublic Log getLogger() {\n\t\treturn logger;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.HandlerMethodReturnValueHandlerComposite#getReturnValueHandlers()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a read-only list with the configured handlers.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "List<HandlerMethodReturnValueHandler>",
    "signature": "public List<HandlerMethodReturnValueHandler> getReturnValueHandlers()",
    "source_code": "\tpublic List<HandlerMethodReturnValueHandler> getReturnValueHandlers() {\n\t\treturn Collections.unmodifiableList(this.returnValueHandlers);\n\t}"
  },
  "org.springframework.messaging.handler.invocation.HandlerMethodReturnValueHandlerComposite#handleReturnValue(returnValue,returnType,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "void",
    "signature": "public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, Message<?> message)",
    "source_code": "\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, Message<?> message)"
  },
  "org.springframework.messaging.handler.invocation.HandlerMethodReturnValueHandlerComposite#isAsyncReturnValue(returnValue,returnType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "boolean",
    "signature": "public boolean isAsyncReturnValue(Object returnValue, MethodParameter returnType)",
    "source_code": "\tpublic boolean isAsyncReturnValue(Object returnValue, MethodParameter returnType) {\n\t\tHandlerMethodReturnValueHandler handler = getReturnValueHandler(returnType);\n\t\treturn (handler instanceof AsyncHandlerMethodReturnValueHandler asyncHandler &&\n\t\t\t\tasyncHandler.isAsyncReturnValue(returnValue, returnType));\n\t}"
  },
  "org.springframework.messaging.handler.invocation.HandlerMethodReturnValueHandlerComposite#setLogger(logger)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set an alternative logger to use than the one based on the class name.\n\t * @param logger the logger to use\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "logger"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "return": "void",
    "signature": "public void setLogger(Log logger)",
    "source_code": "\tpublic void setLogger(Log logger) {\n\t\tthis.logger = logger;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.HandlerMethodReturnValueHandlerComposite#supportsReturnType(returnType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnType"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "boolean",
    "signature": "public boolean supportsReturnType(MethodParameter returnType)",
    "source_code": "\tpublic boolean supportsReturnType(MethodParameter returnType) {\n\t\treturn getReturnValueHandler(returnType) != null;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.defaultLogger": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Public for wrapping with fallback logger. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 40
    },
    "signature": "public Log defaultLogger",
    "source_code": "\tpublic static final Log defaultLogger = LogFactory.getLog(HandlerMethodReturnValueHandlerComposite.class);",
    "type": "Log"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#cancel()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 446
    },
    "return": "void",
    "signature": "public void cancel()",
    "source_code": "\t\tpublic void cancel() {\n\t\t\tthis.writeBarrier.cancel();\n\t\t\tSubscription subscription = this.subscription;\n\t\t\tif (subscription != null) {\n\t\t\t\tsubscription.cancel();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#connect()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Connect the underlying completion subscriber to this barrier in order\n\t\t * to track cancel signals and pass them on to the write barrier.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 403
    },
    "return": "void",
    "signature": "public void connect()",
    "source_code": "\t\tpublic void connect() {\n\t\t\tthis.completionSubscriber.onSubscribe(this);\n\t\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#currentContext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 435
    },
    "return": "Context",
    "signature": "public Context currentContext()",
    "source_code": "\t\tpublic Context currentContext() {\n\t\t\treturn this.completionSubscriber.currentContext();\n\t\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#onComplete()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 430
    },
    "return": "void",
    "signature": "public void onComplete()",
    "source_code": "\t\tpublic void onComplete() {\n\t\t\tthis.completionSubscriber.onComplete();\n\t\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#onError(ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 420
    },
    "return": "void",
    "signature": "public void onError(Throwable ex)",
    "source_code": "\t\tpublic void onError(Throwable ex) {\n\t\t\ttry {\n\t\t\t\tthis.completionSubscriber.onError(ex);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.writeBarrier.releaseCachedItem();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#onNext(aVoid)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "aVoid"
    ],
    "position": {
      "column": 1,
      "line": 416
    },
    "return": "void",
    "signature": "public void onNext(Void aVoid)",
    "source_code": "\t\tpublic void onNext(Void aVoid) {\n\t\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#onNext(item)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "item"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "void",
    "signature": "public void onNext(T item)",
    "source_code": "\t\tpublic final void onNext(T item) {\n\t\t\tif (this.state == State.READY_TO_WRITE) {\n\t\t\t\trequiredWriteSubscriber().onNext(item);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//FIXME revisit in case of reentrant sync deadlock\n\t\t\tsynchronized (this) {\n\t\t\t\tif (this.state == State.READY_TO_WRITE) {\n\t\t\t\t\trequiredWriteSubscriber().onNext(item);\n\t\t\t\t}\n\t\t\t\telse if (this.state == State.NEW) {\n\t\t\t\t\tthis.item = item;\n\t\t\t\t\tthis.state = State.FIRST_SIGNAL_RECEIVED;\n\t\t\t\t\tPublisher<Void> result;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresult = writeFunction.apply(this);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tthis.writeCompletionBarrier.onError(ex);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tresult.subscribe(this.writeCompletionBarrier);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (this.subscription != null) {\n\t\t\t\t\t\tthis.subscription.cancel();\n\t\t\t\t\t}\n\t\t\t\t\tthis.writeCompletionBarrier.onError(new IllegalStateException(\"Unexpected item.\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#onSubscribe(s)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "s"
    ],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "void",
    "signature": "public void onSubscribe(Subscription s)",
    "source_code": "\t\tpublic final void onSubscribe(Subscription s) {\n\t\t\tif (Operators.validate(this.subscription, s)) {\n\t\t\t\tthis.subscription = s;\n\t\t\t\tthis.writeCompletionBarrier.connect();\n\t\t\t\ts.request(1);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#onSubscribe(subscription)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "subscription"
    ],
    "position": {
      "column": 1,
      "line": 410
    },
    "return": "void",
    "signature": "public void onSubscribe(Subscription subscription)",
    "source_code": "\t\tpublic void onSubscribe(Subscription subscription) {\n\t\t\tthis.subscription = subscription;\n\t\t\tsubscription.request(Long.MAX_VALUE);\n\t\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#request(n)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "n"
    ],
    "position": {
      "column": 1,
      "line": 441
    },
    "return": "void",
    "signature": "public void request(long n)",
    "source_code": "\t\tpublic void request(long n) {\n\t\t\t// Ignore: we don't produce data\n\t\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#scanUnsafe(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "Object",
    "signature": "public Object scanUnsafe(Attr key)",
    "source_code": "\tpublic Object scanUnsafe(Attr key) {\n\t\tif (key == Attr.PREFETCH) {\n\t\t\treturn Integer.MAX_VALUE;\n\t\t}\n\t\tif (key == Attr.PARENT) {\n\t\t\treturn this.source;\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#subscribe(actual)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "actual"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "void",
    "signature": "public void subscribe(CoreSubscriber<? super Void> actual)",
    "source_code": "\tpublic void subscribe(CoreSubscriber<? super Void> actual) {\n\t\tthis.source.subscribe(new WriteBarrier(actual));\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#subscribe(writeSubscriber)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "writeSubscriber"
    ],
    "position": {
      "column": 1,
      "line": 357
    },
    "return": "void",
    "signature": "public void subscribe(Subscriber<? super T> writeSubscriber)",
    "source_code": "\t\tpublic void subscribe(Subscriber<? super T> writeSubscriber) {\n\t\t\tsynchronized (this) {\n\t\t\t\tAssert.state(this.writeSubscriber == null, \"Only one write subscriber supported\");\n\t\t\t\tthis.writeSubscriber = writeSubscriber;\n\t\t\t\tif (this.error != null || this.completed) {\n\t\t\t\t\tthis.writeSubscriber.onSubscribe(Operators.emptySubscription());\n\t\t\t\t\temitCachedSignals();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.writeSubscriber.onSubscribe(this);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.scheduling.quartz.DEFAULT_THREAD_COUNT": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The default thread count.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "signature": "public int DEFAULT_THREAD_COUNT",
    "source_code": "\tpublic static final int DEFAULT_THREAD_COUNT = 10;",
    "type": "int"
  },
  "org.springframework.scheduling.quartz.PROP_THREAD_COUNT": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The thread count property.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "signature": "public String PROP_THREAD_COUNT",
    "source_code": "\tpublic static final String PROP_THREAD_COUNT = \"org.quartz.threadPool.threadCount\";",
    "type": "String"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link FactoryBean} that creates and configures a Quartz {@link org.quartz.Scheduler},\n * manages its lifecycle as part of the Spring application context, and exposes the\n * Scheduler as bean reference for dependency injection.\n *\n * <p>Allows registration of JobDetails, Calendars and Triggers, automatically\n * starting the scheduler on initialization and shutting it down on destruction.\n * In scenarios that just require static registration of jobs at startup, there\n * is no need to access the Scheduler instance itself in application code.\n *\n * <p>For dynamic registration of jobs at runtime, use a bean reference to\n * this SchedulerFactoryBean to get direct access to the Quartz Scheduler\n * ({@code org.quartz.Scheduler}). This allows you to create new jobs\n * and triggers, and also to control and monitor the entire Scheduler.\n *\n * <p>Note that Quartz instantiates a new Job for each execution, in\n * contrast to Timer which uses a TimerTask instance that is shared\n * between repeated executions. Just JobDetail descriptors are shared.\n *\n * <p>When using persistent jobs, it is strongly recommended to perform all\n * operations on the Scheduler within Spring-managed (or plain JTA) transactions.\n * Else, database locking will not properly work and might even break.\n * (See {@link #setDataSource setDataSource} javadoc for details.)\n *\n * <p>The preferred way to achieve transactional execution is to demarcate\n * declarative transactions at the business facade level, which will\n * automatically apply to Scheduler operations performed within those scopes.\n * Alternatively, you may add transactional advice for the Scheduler itself.\n *\n * <p>Compatible with Quartz 2.1.4 and higher, as of Spring 4.1.\n *\n * @author Juergen Hoeller\n * @since 18.02.2004\n * @see #setDataSource\n * @see org.quartz.Scheduler\n * @see org.quartz.SchedulerFactory\n * @see org.quartz.impl.StdSchedulerFactory\n * @see org.springframework.transaction.interceptor.TransactionProxyFactoryBean\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "signature": "public class SchedulerFactoryBean",
    "source_code": "public class SchedulerFactoryBean extends SchedulerAccessor implements FactoryBean<Scheduler>,"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 494
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() throws Exception {\n\t\tif (this.dataSource == null && this.nonTransactionalDataSource != null) {\n\t\t\tthis.dataSource = this.nonTransactionalDataSource;\n\t\t}\n\n\t\tif (this.applicationContext != null && this.resourceLoader == null) {\n\t\t\tthis.resourceLoader = this.applicationContext;\n\t\t}\n\n\t\t// Initialize the Scheduler instance...\n\t\tthis.scheduler = prepareScheduler(prepareSchedulerFactory());\n\t\ttry {\n\t\t\tregisterListeners();\n\t\t\tregisterJobsAndTriggers();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\ttry {\n\t\t\t\tthis.scheduler.shutdown(true);\n\t\t\t}\n\t\t\tcatch (Exception ex2) {\n\t\t\t\tlogger.debug(\"Scheduler shutdown exception after registration failure\", ex2);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#createScheduler(schedulerFactory,schedulerName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the Scheduler instance for the given factory and scheduler name.\n\t * Called by {@link #afterPropertiesSet}.\n\t * <p>The default implementation invokes SchedulerFactory's {@code getScheduler}\n\t * method. Can be overridden for custom Scheduler creation.\n\t * @param schedulerFactory the factory to create the Scheduler with\n\t * @param schedulerName the name of the scheduler to create\n\t * @return the Scheduler instance\n\t * @throws SchedulerException if thrown by Quartz methods\n\t * @see #afterPropertiesSet\n\t * @see org.quartz.SchedulerFactory#getScheduler\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "schedulerFactory",
      "schedulerName"
    ],
    "position": {
      "column": 1,
      "line": 664
    },
    "return": "Scheduler",
    "signature": "protected Scheduler createScheduler(SchedulerFactory schedulerFactory, @Nullable String schedulerName)",
    "source_code": "\tprotected Scheduler createScheduler(SchedulerFactory schedulerFactory, @Nullable String schedulerName)"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#destroy()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Shut down the Quartz scheduler on bean factory shutdown,\n\t * stopping all scheduled jobs.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 845
    },
    "return": "void",
    "signature": "public void destroy()",
    "source_code": "\tpublic void destroy() throws SchedulerException {\n\t\tif (this.scheduler != null) {\n\t\t\tlogger.info(\"Shutting down Quartz Scheduler\");\n\t\t\tthis.scheduler.shutdown(this.waitForJobsToCompleteOnShutdown);\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#getConfigTimeDataSource()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link DataSource} for the currently configured Quartz Scheduler,\n\t * to be used by {@link LocalDataSourceJobStore}.\n\t * <p>This instance will be set before initialization of the corresponding Scheduler,\n\t * and reset immediately afterwards. It is thus only available during configuration.\n\t * @since 1.1\n\t * @see #setDataSource\n\t * @see LocalDataSourceJobStore\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "DataSource",
    "signature": "public DataSource getConfigTimeDataSource()",
    "source_code": "\tpublic static DataSource getConfigTimeDataSource() {\n\t\treturn configTimeDataSourceHolder.get();\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#getConfigTimeNonTransactionalDataSource()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the non-transactional {@link DataSource} for the currently configured\n\t * Quartz Scheduler, to be used by {@link LocalDataSourceJobStore}.\n\t * <p>This instance will be set before initialization of the corresponding Scheduler,\n\t * and reset immediately afterwards. It is thus only available during configuration.\n\t * @since 1.1\n\t * @see #setNonTransactionalDataSource\n\t * @see LocalDataSourceJobStore\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "DataSource",
    "signature": "public DataSource getConfigTimeNonTransactionalDataSource()",
    "source_code": "\tpublic static DataSource getConfigTimeNonTransactionalDataSource() {\n\t\treturn configTimeNonTransactionalDataSourceHolder.get();\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#getConfigTimeResourceLoader()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link ResourceLoader} for the currently configured Quartz Scheduler,\n\t * to be used by {@link ResourceLoaderClassLoadHelper}.\n\t * <p>This instance will be set before initialization of the corresponding Scheduler,\n\t * and reset immediately afterwards. It is thus only available during configuration.\n\t * @see #setApplicationContext\n\t * @see ResourceLoaderClassLoadHelper\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "ResourceLoader",
    "signature": "public ResourceLoader getConfigTimeResourceLoader()",
    "source_code": "\tpublic static ResourceLoader getConfigTimeResourceLoader() {\n\t\treturn configTimeResourceLoaderHolder.get();\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#getConfigTimeTaskExecutor()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link Executor} for the currently configured Quartz Scheduler,\n\t * to be used by {@link LocalTaskExecutorThreadPool}.\n\t * <p>This instance will be set before initialization of the corresponding Scheduler,\n\t * and reset immediately afterwards. It is thus only available during configuration.\n\t * @since 2.0\n\t * @see #setTaskExecutor\n\t * @see LocalTaskExecutorThreadPool\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "Executor",
    "signature": "public Executor getConfigTimeTaskExecutor()",
    "source_code": "\tpublic static Executor getConfigTimeTaskExecutor() {\n\t\treturn configTimeTaskExecutorHolder.get();\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#getObject()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 779
    },
    "return": "Scheduler",
    "signature": "public Scheduler getObject()",
    "source_code": "\tpublic Scheduler getObject() {\n\t\treturn this.scheduler;\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#getPhase()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the phase in which this scheduler will be started and stopped.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 440
    },
    "return": "int",
    "signature": "public int getPhase()",
    "source_code": "\tpublic int getPhase() {\n\t\treturn this.phase;\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#getScheduler()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 772
    },
    "return": "Scheduler",
    "signature": "public Scheduler getScheduler()",
    "source_code": "\tpublic Scheduler getScheduler() {\n\t\tAssert.state(this.scheduler != null, \"No Scheduler set\");\n\t\treturn this.scheduler;\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#isAutoStartup()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether this scheduler is configured for auto-startup. If \"true\",\n\t * the scheduler will start after the context is refreshed and after the\n\t * start delay, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 420
    },
    "return": "boolean",
    "signature": "public boolean isAutoStartup()",
    "source_code": "\tpublic boolean isAutoStartup() {\n\t\treturn this.autoStartup;\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#isRunning()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 823
    },
    "return": "boolean",
    "signature": "public boolean isRunning()",
    "source_code": "\tpublic boolean isRunning() throws SchedulingException {\n\t\tif (this.scheduler != null) {\n\t\t\ttry {\n\t\t\t\treturn !this.scheduler.isInStandbyMode();\n\t\t\t}\n\t\t\tcatch (SchedulerException ex) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#isSingleton()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 789
    },
    "return": "boolean",
    "signature": "public boolean isSingleton()",
    "source_code": "\tpublic boolean isSingleton() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#run()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 741
    },
    "return": "void",
    "signature": "public void run()",
    "source_code": "\t\t\t\tpublic void run() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tTimeUnit.SECONDS.sleep(startupDelay);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InterruptedException ex) {\n\t\t\t\t\t\tThread.currentThread().interrupt();\n\t\t\t\t\t\t// simply proceed\n\t\t\t\t\t}\n\t\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\t\tlogger.info(\"Starting Quartz Scheduler now, after delay of \" + startupDelay + \" seconds\");\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tscheduler.start();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SchedulerException ex) {\n\t\t\t\t\t\tthrow new SchedulingException(\"Could not start Quartz Scheduler after delay\", ex);\n\t\t\t\t\t}\n\t\t\t\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#setApplicationContext(applicationContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "applicationContext"
    ],
    "position": {
      "column": 1,
      "line": 484
    },
    "return": "void",
    "signature": "public void setApplicationContext(ApplicationContext applicationContext)",
    "source_code": "\tpublic void setApplicationContext(ApplicationContext applicationContext) {\n\t\tthis.applicationContext = applicationContext;\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#setApplicationContextSchedulerContextKey(applicationContextSchedulerContextKey)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the key of an {@link ApplicationContext} reference to expose in the\n\t * SchedulerContext, for example \"applicationContext\". Default is none.\n\t * Only applicable when running in a Spring ApplicationContext.\n\t * <p>Note: When using persistent Jobs whose JobDetail will be kept in the\n\t * database, do not put an ApplicationContext reference into the JobDataMap\n\t * but rather into the SchedulerContext.\n\t * <p>In case of a QuartzJobBean, the reference will be applied to the Job\n\t * instance as bean property. An \"applicationContext\" attribute will\n\t * correspond to a \"setApplicationContext\" method in that scenario.\n\t * <p>Note that BeanFactory callback interfaces like ApplicationContextAware\n\t * are not automatically applied to Quartz Job instances, because Quartz\n\t * itself is responsible for the lifecycle of its Jobs.\n\t * @see JobDetailFactoryBean#setApplicationContextJobDataKey\n\t * @see org.springframework.context.ApplicationContext\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "applicationContextSchedulerContextKey"
    ],
    "position": {
      "column": 1,
      "line": 383
    },
    "return": "void",
    "signature": "public void setApplicationContextSchedulerContextKey(String applicationContextSchedulerContextKey)",
    "source_code": "\tpublic void setApplicationContextSchedulerContextKey(String applicationContextSchedulerContextKey) {\n\t\tthis.applicationContextSchedulerContextKey = applicationContextSchedulerContextKey;\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#setAutoStartup(autoStartup)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to automatically start the scheduler after initialization.\n\t * <p>Default is \"true\"; set this to \"false\" to allow for manual startup.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "autoStartup"
    ],
    "position": {
      "column": 1,
      "line": 410
    },
    "return": "void",
    "signature": "public void setAutoStartup(boolean autoStartup)",
    "source_code": "\tpublic void setAutoStartup(boolean autoStartup) {\n\t\tthis.autoStartup = autoStartup;\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#setBeanName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 479
    },
    "return": "void",
    "signature": "public void setBeanName(String name)",
    "source_code": "\tpublic void setBeanName(String name) {\n\t\tthis.beanName = name;\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#setConfigLocation(configLocation)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the location of the Quartz properties config file, for example\n\t * as classpath resource \"classpath:quartz.properties\".\n\t * <p>Note: Can be omitted when all necessary properties are specified\n\t * locally via this bean, or when relying on Quartz' default configuration.\n\t * @see #setQuartzProperties\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "configLocation"
    ],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "void",
    "signature": "public void setConfigLocation(Resource configLocation)",
    "source_code": "\tpublic void setConfigLocation(Resource configLocation) {\n\t\tthis.configLocation = configLocation;\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#setDataSource(dataSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the default {@link DataSource} to be used by the Scheduler.\n\t * <p>Note: If this is set, the Quartz settings should not define\n\t * a job store \"dataSource\" to avoid meaningless double configuration.\n\t * Also, do not define a \"org.quartz.jobStore.class\" property at all.\n\t * (You may explicitly define Spring's {@link LocalDataSourceJobStore}\n\t * but that's the default when using this method anyway.)\n\t * <p>A Spring-specific subclass of Quartz' JobStoreCMT will be used.\n\t * It is therefore strongly recommended to perform all operations on\n\t * the Scheduler within Spring-managed (or plain JTA) transactions.\n\t * Else, database locking will not properly work and might even break\n\t * (e.g. if trying to obtain a lock on Oracle without a transaction).\n\t * <p>Supports both transactional and non-transactional DataSource access.\n\t * With a non-XA DataSource and local Spring transactions, a single DataSource\n\t * argument is sufficient. In case of an XA DataSource and global JTA transactions,\n\t * SchedulerFactoryBean's \"nonTransactionalDataSource\" property should be set,\n\t * passing in a non-XA DataSource that will not participate in global transactions.\n\t * @since 1.1\n\t * @see #setNonTransactionalDataSource\n\t * @see #setQuartzProperties\n\t * @see #setTransactionManager\n\t * @see LocalDataSourceJobStore\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataSource"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "void",
    "signature": "public void setDataSource(DataSource dataSource)",
    "source_code": "\tpublic void setDataSource(DataSource dataSource) {\n\t\tthis.dataSource = dataSource;\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#setExposeSchedulerInRepository(exposeSchedulerInRepository)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to expose the Spring-managed {@link Scheduler} instance in the\n\t * Quartz {@link SchedulerRepository}. Default is \"false\", since the Spring-managed\n\t * Scheduler is usually exclusively intended for access within the Spring context.\n\t * <p>Switch this flag to \"true\" in order to expose the Scheduler globally.\n\t * This is not recommended unless you have an existing Spring application that\n\t * relies on this behavior. Note that such global exposure was the accidental\n\t * default in earlier Spring versions; this has been fixed as of Spring 2.5.6.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exposeSchedulerInRepository"
    ],
    "position": {
      "column": 1,
      "line": 464
    },
    "return": "void",
    "signature": "public void setExposeSchedulerInRepository(boolean exposeSchedulerInRepository)",
    "source_code": "\tpublic void setExposeSchedulerInRepository(boolean exposeSchedulerInRepository) {\n\t\tthis.exposeSchedulerInRepository = exposeSchedulerInRepository;\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#setJobFactory(jobFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Quartz {@link JobFactory} to use for this Scheduler.\n\t * <p>Default is Spring's {@link AdaptableJobFactory}, which supports\n\t * {@link java.lang.Runnable} objects as well as standard Quartz\n\t * {@link org.quartz.Job} instances. Note that this default only applies\n\t * to a <i>local</i> Scheduler, not to a RemoteScheduler (where setting\n\t * a custom JobFactory is not supported by Quartz).\n\t * <p>Specify an instance of Spring's {@link SpringBeanJobFactory} here\n\t * (typically as an inner bean definition) to automatically populate a job's\n\t * bean properties from the specified job data map and scheduler context.\n\t * @since 2.0\n\t * @see AdaptableJobFactory\n\t * @see SpringBeanJobFactory\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "jobFactory"
    ],
    "position": {
      "column": 1,
      "line": 401
    },
    "return": "void",
    "signature": "public void setJobFactory(JobFactory jobFactory)",
    "source_code": "\tpublic void setJobFactory(JobFactory jobFactory) {\n\t\tthis.jobFactory = jobFactory;\n\t\tthis.jobFactorySet = true;\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#setNonTransactionalDataSource(nonTransactionalDataSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link DataSource} to be used <i>for non-transactional access</i>.\n\t * <p>This is only necessary if the default DataSource is an XA DataSource that will\n\t * always participate in transactions: A non-XA version of that DataSource should\n\t * be specified as \"nonTransactionalDataSource\" in such a scenario.\n\t * <p>This is not relevant with a local DataSource instance and Spring transactions.\n\t * Specifying a single default DataSource as \"dataSource\" is sufficient there.\n\t * @since 1.1\n\t * @see #setDataSource\n\t * @see LocalDataSourceJobStore\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nonTransactionalDataSource"
    ],
    "position": {
      "column": 1,
      "line": 349
    },
    "return": "void",
    "signature": "public void setNonTransactionalDataSource(DataSource nonTransactionalDataSource)",
    "source_code": "\tpublic void setNonTransactionalDataSource(DataSource nonTransactionalDataSource) {\n\t\tthis.nonTransactionalDataSource = nonTransactionalDataSource;\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#setPhase(phase)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the phase in which this scheduler should be started and stopped.\n\t * The startup order proceeds from lowest to highest, and the shutdown order\n\t * is the reverse of that. By default this value is {@code Integer.MAX_VALUE}\n\t * meaning that this scheduler starts as late as possible and stops as soon\n\t * as possible.\n\t * @since 3.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "phase"
    ],
    "position": {
      "column": 1,
      "line": 432
    },
    "return": "void",
    "signature": "public void setPhase(int phase)",
    "source_code": "\tpublic void setPhase(int phase) {\n\t\tthis.phase = phase;\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#setQuartzProperties(quartzProperties)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set Quartz properties, like \"org.quartz.threadPool.class\".\n\t * <p>Can be used to override values in a Quartz properties config file,\n\t * or to specify all necessary properties locally.\n\t * @see #setConfigLocation\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "quartzProperties"
    ],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "void",
    "signature": "public void setQuartzProperties(Properties quartzProperties)",
    "source_code": "\tpublic void setQuartzProperties(Properties quartzProperties) {\n\t\tthis.quartzProperties = quartzProperties;\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#setSchedulerContextAsMap(Map<String,schedulerContextAsMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register objects in the Scheduler context via a given Map.\n\t * These objects will be available to any Job that runs in this Scheduler.\n\t * <p>Note: When using persistent Jobs whose JobDetail will be kept in the\n\t * database, do not put Spring-managed beans or an ApplicationContext\n\t * reference into the JobDataMap but rather into the SchedulerContext.\n\t * @param schedulerContextAsMap a Map with String keys and any objects as\n\t * values (for example Spring-managed beans)\n\t * @see JobDetailFactoryBean#setJobDataAsMap\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "schedulerContextAsMap"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "void",
    "signature": "public void setSchedulerContextAsMap(Map<String, ?> schedulerContextAsMap)",
    "source_code": "\tpublic void setSchedulerContextAsMap(Map<String, ?> schedulerContextAsMap) {\n\t\tthis.schedulerContextMap = schedulerContextAsMap;\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#setSchedulerFactory(schedulerFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set an external Quartz {@link SchedulerFactory} instance to use.\n\t * <p>Default is an internal {@link StdSchedulerFactory} instance. If this method is\n\t * called, it overrides any class specified through {@link #setSchedulerFactoryClass}\n\t * as well as any settings specified through {@link #setConfigLocation},\n\t * {@link #setQuartzProperties}, {@link #setTaskExecutor} or {@link #setDataSource}.\n\t * <p><b>NOTE:</b> With an externally provided {@code SchedulerFactory} instance,\n\t * local settings such as {@link #setConfigLocation} or {@link #setQuartzProperties}\n\t * will be ignored here in {@code SchedulerFactoryBean}, expecting the external\n\t * {@code SchedulerFactory} instance to get initialized on its own.\n\t * @since 4.3.15\n\t * @see #setSchedulerFactoryClass\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "schedulerFactory"
    ],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "void",
    "signature": "public void setSchedulerFactory(SchedulerFactory schedulerFactory)",
    "source_code": "\tpublic void setSchedulerFactory(SchedulerFactory schedulerFactory) {\n\t\tthis.schedulerFactory = schedulerFactory;\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#setSchedulerFactoryClass(schedulerFactoryClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Quartz {@link SchedulerFactory} implementation to use.\n\t * <p>Default is the {@link StdSchedulerFactory} class, reading in the standard\n\t * {@code quartz.properties} from {@code quartz.jar}. For applying custom Quartz\n\t * properties, specify {@link #setConfigLocation \"configLocation\"} and/or\n\t * {@link #setQuartzProperties \"quartzProperties\"} etc on this local\n\t * {@code SchedulerFactoryBean} instance.\n\t * @see org.quartz.impl.StdSchedulerFactory\n\t * @see #setConfigLocation\n\t * @see #setQuartzProperties\n\t * @see #setTaskExecutor\n\t * @see #setDataSource\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "schedulerFactoryClass"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "void",
    "signature": "public void setSchedulerFactoryClass(Class<? extends SchedulerFactory> schedulerFactoryClass)",
    "source_code": "\tpublic void setSchedulerFactoryClass(Class<? extends SchedulerFactory> schedulerFactoryClass) {\n\t\tthis.schedulerFactoryClass = schedulerFactoryClass;\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#setSchedulerName(schedulerName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of the Scheduler to create via the SchedulerFactory, as an\n\t * alternative to the {@code org.quartz.scheduler.instanceName} property.\n\t * <p>If not specified, the name will be taken from Quartz properties\n\t * ({@code org.quartz.scheduler.instanceName}), or from the declared\n\t * {@code SchedulerFactoryBean} bean name as a fallback.\n\t * @see #setBeanName\n\t * @see StdSchedulerFactory#PROP_SCHED_INSTANCE_NAME\n\t * @see org.quartz.SchedulerFactory#getScheduler()\n\t * @see org.quartz.SchedulerFactory#getScheduler(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "schedulerName"
    ],
    "position": {
      "column": 1,
      "line": 269
    },
    "return": "void",
    "signature": "public void setSchedulerName(String schedulerName)",
    "source_code": "\tpublic void setSchedulerName(String schedulerName) {\n\t\tthis.schedulerName = schedulerName;\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#setStartupDelay(startupDelay)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the number of seconds to wait after initialization before\n\t * starting the scheduler asynchronously. Default is 0, meaning\n\t * immediate synchronous startup on initialization of this bean.\n\t * <p>Setting this to 10 or 20 seconds makes sense if no jobs\n\t * should be run before the entire application has started up.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "startupDelay"
    ],
    "position": {
      "column": 1,
      "line": 451
    },
    "return": "void",
    "signature": "public void setStartupDelay(int startupDelay)",
    "source_code": "\tpublic void setStartupDelay(int startupDelay) {\n\t\tthis.startupDelay = startupDelay;\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#setTaskExecutor(taskExecutor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a Spring-managed {@link Executor} to use as Quartz backend.\n\t * Exposed as thread pool through the Quartz SPI.\n\t * <p>Can be used to assign a local JDK ThreadPoolExecutor or a CommonJ\n\t * WorkManager as Quartz backend, to avoid Quartz's manual thread creation.\n\t * <p>By default, a Quartz SimpleThreadPool will be used, configured through\n\t * the corresponding Quartz properties.\n\t * @since 2.0\n\t * @see #setQuartzProperties\n\t * @see LocalTaskExecutorThreadPool\n\t * @see org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor\n\t * @see org.springframework.scheduling.concurrent.DefaultManagedTaskExecutor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "taskExecutor"
    ],
    "position": {
      "column": 1,
      "line": 307
    },
    "return": "void",
    "signature": "public void setTaskExecutor(Executor taskExecutor)",
    "source_code": "\tpublic void setTaskExecutor(Executor taskExecutor) {\n\t\tthis.taskExecutor = taskExecutor;\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#setWaitForJobsToCompleteOnShutdown(waitForJobsToCompleteOnShutdown)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to wait for running jobs to complete on shutdown.\n\t * <p>Default is \"false\". Switch this to \"true\" if you prefer\n\t * fully completed jobs at the expense of a longer shutdown phase.\n\t * @see org.quartz.Scheduler#shutdown(boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "waitForJobsToCompleteOnShutdown"
    ],
    "position": {
      "column": 1,
      "line": 474
    },
    "return": "void",
    "signature": "public void setWaitForJobsToCompleteOnShutdown(boolean waitForJobsToCompleteOnShutdown)",
    "source_code": "\tpublic void setWaitForJobsToCompleteOnShutdown(boolean waitForJobsToCompleteOnShutdown) {\n\t\tthis.waitForJobsToCompleteOnShutdown = waitForJobsToCompleteOnShutdown;\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#start()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 799
    },
    "return": "void",
    "signature": "public void start()",
    "source_code": "\tpublic void start() throws SchedulingException {\n\t\tif (this.scheduler != null) {\n\t\t\ttry {\n\t\t\t\tstartScheduler(this.scheduler, this.startupDelay);\n\t\t\t}\n\t\t\tcatch (SchedulerException ex) {\n\t\t\t\tthrow new SchedulingException(\"Could not start Quartz Scheduler\", ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#startScheduler(scheduler,startupDelay)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Start the Quartz Scheduler, respecting the \"startupDelay\" setting.\n\t * @param scheduler the Scheduler to start\n\t * @param startupDelay the number of seconds to wait before starting\n\t * the Scheduler asynchronously\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "scheduler",
      "startupDelay"
    ],
    "position": {
      "column": 1,
      "line": 727
    },
    "return": "void",
    "signature": "protected void startScheduler(final Scheduler scheduler, final int startupDelay)",
    "source_code": "\tprotected void startScheduler(final Scheduler scheduler, final int startupDelay) throws SchedulerException {\n\t\tif (startupDelay <= 0) {\n\t\t\tlogger.info(\"Starting Quartz Scheduler now\");\n\t\t\tscheduler.start();\n\t\t}\n\t\telse {\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(\"Will start Quartz Scheduler [\" + scheduler.getSchedulerName() +\n\t\t\t\t\t\t\"] in \" + startupDelay + \" seconds\");\n\t\t\t}\n\t\t\t// Not using the Quartz startDelayed method since we explicitly want a daemon\n\t\t\t// thread here, not keeping the JVM alive in case of all other threads ending.\n\t\t\tThread schedulerThread = new Thread() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tTimeUnit.SECONDS.sleep(startupDelay);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InterruptedException ex) {\n\t\t\t\t\t\tThread.currentThread().interrupt();\n\t\t\t\t\t\t// simply proceed\n\t\t\t\t\t}\n\t\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\t\tlogger.info(\"Starting Quartz Scheduler now, after delay of \" + startupDelay + \" seconds\");\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tscheduler.start();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SchedulerException ex) {\n\t\t\t\t\t\tthrow new SchedulingException(\"Could not start Quartz Scheduler after delay\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tschedulerThread.setName(\"Quartz Scheduler [\" + scheduler.getSchedulerName() + \"]\");\n\t\t\tschedulerThread.setDaemon(true);\n\t\t\tschedulerThread.start();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.quartz.SchedulerFactoryBean#stop()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 811
    },
    "return": "void",
    "signature": "public void stop()",
    "source_code": "\tpublic void stop() throws SchedulingException {\n\t\tif (this.scheduler != null) {\n\t\t\ttry {\n\t\t\t\tthis.scheduler.standby();\n\t\t\t}\n\t\t\tcatch (SchedulerException ex) {\n\t\t\t\tthrow new SchedulingException(\"Could not stop Quartz Scheduler\", ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#addBean(name,bean)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "void",
    "signature": "public void addBean(String name, Object bean)",
    "source_code": "\tpublic void addBean(String name, Object bean) {\n\t\tthis.beanFactory.addBean(name, bean);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#addBeans(beans)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beans"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "void",
    "signature": "public void addBeans(@Nullable List<?> beans)",
    "source_code": "\tpublic void addBeans(@Nullable List<?> beans) {\n\t\tif (beans != null) {\n\t\t\tfor (Object bean : beans) {\n\t\t\t\tString name = bean.getClass().getName() + \"#\" + ObjectUtils.getIdentityHexString(bean);\n\t\t\t\tthis.beanFactory.addBean(name, bean);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#applyBeanPostProcessorsAfterInitialization(existingBean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 480
    },
    "return": "Object",
    "signature": "public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)",
    "source_code": "\t\tpublic Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName) {\n\t\t\treturn existingBean;\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#applyBeanPostProcessorsBeforeInitialization(existingBean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 475
    },
    "return": "Object",
    "signature": "public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)",
    "source_code": "\t\tpublic Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) {\n\t\t\treturn existingBean;\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#applyBeanPropertyValues(existingBean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 471
    },
    "return": "void",
    "signature": "public void applyBeanPropertyValues(Object existingBean, String beanName)",
    "source_code": "\t\tpublic void applyBeanPropertyValues(Object existingBean, String beanName) throws BeansException {\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#autowire(beanClass,autowireMode,dependencyCheck)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "autowireMode",
      "dependencyCheck"
    ],
    "position": {
      "column": 1,
      "line": 430
    },
    "return": "Object",
    "signature": "public Object autowire(Class<?> beanClass, int autowireMode, boolean dependencyCheck)",
    "source_code": "\t\tpublic Object autowire(Class<?> beanClass, int autowireMode, boolean dependencyCheck) {\n\t\t\treturn BeanUtils.instantiateClass(beanClass);\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#autowireBean(existingBean)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean"
    ],
    "position": {
      "column": 1,
      "line": 435
    },
    "return": "void",
    "signature": "public void autowireBean(Object existingBean)",
    "source_code": "\t\tpublic void autowireBean(Object existingBean) throws BeansException {\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#autowireBeanProperties(existingBean,autowireMode,dependencyCheck)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "autowireMode",
      "dependencyCheck"
    ],
    "position": {
      "column": 1,
      "line": 439
    },
    "return": "void",
    "signature": "public void autowireBeanProperties(Object existingBean, int autowireMode, boolean dependencyCheck)",
    "source_code": "\t\tpublic void autowireBeanProperties(Object existingBean, int autowireMode, boolean dependencyCheck) {\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#configureBean(existingBean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 443
    },
    "return": "Object",
    "signature": "public Object configureBean(Object existingBean, String beanName)",
    "source_code": "\t\tpublic Object configureBean(Object existingBean, String beanName) {\n\t\t\treturn existingBean;\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#containsBean(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "boolean",
    "signature": "public boolean containsBean(String name)",
    "source_code": "\tpublic boolean containsBean(String name) {\n\t\treturn this.beanFactory.containsBean(name);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#containsBeanDefinition(beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "boolean",
    "signature": "public boolean containsBeanDefinition(String beanName)",
    "source_code": "\tpublic boolean containsBeanDefinition(String beanName) {\n\t\treturn this.beanFactory.containsBeanDefinition(beanName);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#containsLocalBean(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 345
    },
    "return": "boolean",
    "signature": "public boolean containsLocalBean(String name)",
    "source_code": "\tpublic boolean containsLocalBean(String name) {\n\t\treturn this.beanFactory.containsBean(name);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#createBean(beanClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass"
    ],
    "position": {
      "column": 1,
      "line": 420
    },
    "return": "T",
    "signature": "public T createBean(Class<T> beanClass)",
    "source_code": "\t\tpublic <T> T createBean(Class<T> beanClass) {\n\t\t\treturn BeanUtils.instantiateClass(beanClass);\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#createBean(beanClass,autowireMode,dependencyCheck)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "autowireMode",
      "dependencyCheck"
    ],
    "position": {
      "column": 1,
      "line": 425
    },
    "return": "Object",
    "signature": "public Object createBean(Class<?> beanClass, int autowireMode, boolean dependencyCheck)",
    "source_code": "\t\tpublic Object createBean(Class<?> beanClass, int autowireMode, boolean dependencyCheck) {\n\t\t\treturn BeanUtils.instantiateClass(beanClass);\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#destroyBean(existingBean)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean"
    ],
    "position": {
      "column": 1,
      "line": 485
    },
    "return": "void",
    "signature": "public void destroyBean(Object existingBean)",
    "source_code": "\t\tpublic void destroyBean(Object existingBean) {\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#findAllAnnotationsOnBean(beanName,annotationType,allowFactoryBeanInit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType",
      "allowFactoryBeanInit"
    ],
    "position": {
      "column": 1,
      "line": 327
    },
    "return": "Set<A>",
    "signature": "public Set<A> findAllAnnotationsOnBean(String beanName, Class<A> annotationType, boolean allowFactoryBeanInit)",
    "source_code": "\tpublic <A extends Annotation> Set<A> findAllAnnotationsOnBean("
  },
  "org.springframework.test.web.servlet.setup.<unknown>#findAnnotationOnBean(beanName,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 311
    },
    "return": "A",
    "signature": "public A findAnnotationOnBean(String beanName, Class<A> annotationType)",
    "source_code": "\tpublic <A extends Annotation> A findAnnotationOnBean(String beanName, Class<A> annotationType)"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#findAnnotationOnBean(beanName,annotationType,allowFactoryBeanInit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType",
      "allowFactoryBeanInit"
    ],
    "position": {
      "column": 1,
      "line": 319
    },
    "return": "A",
    "signature": "public A findAnnotationOnBean(String beanName, Class<A> annotationType, boolean allowFactoryBeanInit)",
    "source_code": "\tpublic <A extends Annotation> A findAnnotationOnBean("
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getAliases(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 231
    },
    "return": "String[]",
    "signature": "public String[] getAliases(String name)",
    "source_code": "\tpublic String[] getAliases(String name) {\n\t\treturn this.beanFactory.getAliases(name);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getApplicationName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "String",
    "signature": "public String getApplicationName()",
    "source_code": "\tpublic String getApplicationName() {\n\t\treturn \"\";\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getAutowireCapableBeanFactory()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns an instance that can initialize {@link ApplicationContextAware} beans.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "AutowireCapableBeanFactory",
    "signature": "public AutowireCapableBeanFactory getAutowireCapableBeanFactory()",
    "source_code": "\tpublic AutowireCapableBeanFactory getAutowireCapableBeanFactory() throws IllegalStateException {\n\t\treturn this.beanFactory;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBean(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "Object",
    "signature": "public Object getBean(String name)",
    "source_code": "\tpublic Object getBean(String name) throws BeansException {\n\t\treturn this.beanFactory.getBean(name);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBean(name,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "Object",
    "signature": "public Object getBean(String name, Object... args)",
    "source_code": "\tpublic Object getBean(String name, Object... args) throws BeansException {\n\t\treturn this.beanFactory.getBean(name, args);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBean(name,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "T",
    "signature": "public T getBean(String name, Class<T> requiredType)",
    "source_code": "\tpublic <T> T getBean(String name, Class<T> requiredType) throws BeansException {\n\t\treturn this.beanFactory.getBean(name, requiredType);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBean(requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "T",
    "signature": "public T getBean(Class<T> requiredType)",
    "source_code": "\tpublic <T> T getBean(Class<T> requiredType) throws BeansException {\n\t\treturn this.beanFactory.getBean(requiredType);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBean(requiredType,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "T",
    "signature": "public T getBean(Class<T> requiredType, Object... args)",
    "source_code": "\tpublic <T> T getBean(Class<T> requiredType, Object... args) throws BeansException {\n\t\treturn this.beanFactory.getBean(requiredType, args);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBeanDefinitionCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "int",
    "signature": "public int getBeanDefinitionCount()",
    "source_code": "\tpublic int getBeanDefinitionCount() {\n\t\treturn this.beanFactory.getBeanDefinitionCount();\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBeanDefinitionNames()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "String[]",
    "signature": "public String[] getBeanDefinitionNames()",
    "source_code": "\tpublic String[] getBeanDefinitionNames() {\n\t\treturn this.beanFactory.getBeanDefinitionNames();\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBeanNamesForAnnotation(annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 298
    },
    "return": "String[]",
    "signature": "public String[] getBeanNamesForAnnotation(Class<? extends Annotation> annotationType)",
    "source_code": "\tpublic String[] getBeanNamesForAnnotation(Class<? extends Annotation> annotationType) {\n\t\treturn this.beanFactory.getBeanNamesForAnnotation(annotationType);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBeanNamesForType(type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "String[]",
    "signature": "public String[] getBeanNamesForType(@Nullable Class<?> type)",
    "source_code": "\tpublic String[] getBeanNamesForType(@Nullable Class<?> type) {\n\t\treturn this.beanFactory.getBeanNamesForType(type);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBeanNamesForType(type,includeNonSingletons,allowEagerInit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "String[]",
    "signature": "public String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {\n\t\treturn this.beanFactory.getBeanNamesForType(type, includeNonSingletons, allowEagerInit);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBeanProvider(requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "ObjectProvider<T>",
    "signature": "public ObjectProvider<T> getBeanProvider(ResolvableType requiredType)",
    "source_code": "\tpublic <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType) {\n\t\treturn this.beanFactory.getBeanProvider(requiredType);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBeanProvider(requiredType,allowEagerInit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "ObjectProvider<T>",
    "signature": "public ObjectProvider<T> getBeanProvider(ResolvableType requiredType, boolean allowEagerInit)",
    "source_code": "\tpublic <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType, boolean allowEagerInit) {\n\t\treturn this.beanFactory.getBeanProvider(requiredType, allowEagerInit);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBeansOfType(type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "T>",
    "signature": "public T> getBeansOfType(@Nullable Class<T> type)",
    "source_code": "\tpublic <T> Map<String, T> getBeansOfType(@Nullable Class<T> type) throws BeansException {\n\t\treturn this.beanFactory.getBeansOfType(type);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBeansOfType(type,includeNonSingletons,allowEagerInit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "T>",
    "signature": "public T> getBeansOfType(@Nullable Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic <T> Map<String, T> getBeansOfType(@Nullable Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBeansWithAnnotation(annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 303
    },
    "return": "Object>",
    "signature": "public Object> getBeansWithAnnotation(Class<? extends Annotation> annotationType)",
    "source_code": "\tpublic Map<String, Object> getBeansWithAnnotation(Class<? extends Annotation> annotationType)"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getClassLoader()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 376
    },
    "return": "ClassLoader",
    "signature": "public ClassLoader getClassLoader()",
    "source_code": "\tpublic ClassLoader getClassLoader() {\n\t\treturn ClassUtils.getDefaultClassLoader();\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getDisplayName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "String",
    "signature": "public String getDisplayName()",
    "source_code": "\tpublic String getDisplayName() {\n\t\treturn this.displayName;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getEnvironment()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "Environment",
    "signature": "public Environment getEnvironment()",
    "source_code": "\tpublic Environment getEnvironment() {\n\t\treturn this.environment ;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getId()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "String",
    "signature": "public String getId()",
    "source_code": "\tpublic String getId() {\n\t\treturn this.id;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getMessage(code,args,defaultMessage,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "defaultMessage",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 355
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale)",
    "source_code": "\tpublic String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale) {\n\t\treturn this.messageSource.getMessage(code, args, defaultMessage, locale);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getMessage(code,args,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 360
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable Object[] args, Locale locale)",
    "source_code": "\tpublic String getMessage(String code, @Nullable Object[] args, Locale locale) throws NoSuchMessageException {\n\t\treturn this.messageSource.getMessage(code, args, locale);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getMessage(resolvable,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolvable",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 365
    },
    "return": "String",
    "signature": "public String getMessage(MessageSourceResolvable resolvable, Locale locale)",
    "source_code": "\tpublic String getMessage(MessageSourceResolvable resolvable, Locale locale) throws NoSuchMessageException {\n\t\treturn this.messageSource.getMessage(resolvable, locale);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getParent()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "ApplicationContext",
    "signature": "public ApplicationContext getParent()",
    "source_code": "\tpublic ApplicationContext getParent() {\n\t\treturn null;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getParentBeanFactory()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 340
    },
    "return": "BeanFactory",
    "signature": "public BeanFactory getParentBeanFactory()",
    "source_code": "\tpublic BeanFactory getParentBeanFactory() {\n\t\treturn null;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getResource(location)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location"
    ],
    "position": {
      "column": 1,
      "line": 381
    },
    "return": "Resource",
    "signature": "public Resource getResource(String location)",
    "source_code": "\tpublic Resource getResource(String location) {\n\t\treturn this.resourcePatternResolver.getResource(location);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getResources(locationPattern)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locationPattern"
    ],
    "position": {
      "column": 1,
      "line": 399
    },
    "return": "Resource[]",
    "signature": "public Resource[] getResources(String locationPattern)",
    "source_code": "\tpublic Resource[] getResources(String locationPattern) throws IOException {\n\t\treturn this.resourcePatternResolver.getResources(locationPattern);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getServletContext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "ServletContext",
    "signature": "public ServletContext getServletContext()",
    "source_code": "\tpublic ServletContext getServletContext() {\n\t\treturn this.servletContext;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getStartupDate()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "long",
    "signature": "public long getStartupDate()",
    "source_code": "\tpublic long getStartupDate() {\n\t\treturn this.startupDate;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#initializeBean(existingBean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 412
    },
    "return": "Object",
    "signature": "public Object initializeBean(Object existingBean, String beanName)",
    "source_code": "\t\tpublic Object initializeBean(Object existingBean, String beanName) throws BeansException {\n\t\t\tif (existingBean instanceof ApplicationContextAware applicationContextAware) {\n\t\t\t\tapplicationContextAware.setApplicationContext(StubWebApplicationContext.this);\n\t\t\t}\n\t\t\treturn existingBean;\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#isPrototype(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "boolean",
    "signature": "public boolean isPrototype(String name)",
    "source_code": "\tpublic boolean isPrototype(String name) throws NoSuchBeanDefinitionException {\n\t\treturn this.beanFactory.isPrototype(name);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#isSingleton(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "boolean",
    "signature": "public boolean isSingleton(String name)",
    "source_code": "\tpublic boolean isSingleton(String name) throws NoSuchBeanDefinitionException {\n\t\treturn this.beanFactory.isSingleton(name);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#isTypeMatch(name,typeToMatch)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "typeToMatch"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "boolean",
    "signature": "public boolean isTypeMatch(String name, Class<?> typeToMatch)",
    "source_code": "\tpublic boolean isTypeMatch(String name, Class<?> typeToMatch) throws NoSuchBeanDefinitionException {\n\t\treturn this.beanFactory.isTypeMatch(name, typeToMatch);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#publishEvent(event)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "event"
    ],
    "position": {
      "column": 1,
      "line": 395
    },
    "return": "void",
    "signature": "public void publishEvent(Object event)",
    "source_code": "\tpublic void publishEvent(Object event) {\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#resolveBeanByName(name,descriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 453
    },
    "return": "Object",
    "signature": "public Object resolveBeanByName(String name, DependencyDescriptor descriptor)",
    "source_code": "\t\tpublic Object resolveBeanByName(String name, DependencyDescriptor descriptor) throws BeansException {\n\t\t\tthrow new UnsupportedOperationException(\"Dependency resolution not supported\");\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#resolveDependency(descriptor,requestingBeanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "requestingBeanName"
    ],
    "position": {
      "column": 1,
      "line": 459
    },
    "return": "Object",
    "signature": "public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName)",
    "source_code": "\t\tpublic Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName) {\n\t\t\tthrow new UnsupportedOperationException(\"Dependency resolution not supported\");\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#resolveDependency(descriptor,requestingBeanName,autowiredBeanNames,typeConverter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "requestingBeanName",
      "autowiredBeanNames",
      "typeConverter"
    ],
    "position": {
      "column": 1,
      "line": 465
    },
    "return": "Object",
    "signature": "public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,\n\t\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter)",
    "source_code": "\t\tpublic Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#resolveNamedBean(requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 448
    },
    "return": "NamedBeanHolder<T>",
    "signature": "public NamedBeanHolder<T> resolveNamedBean(Class<T> requiredType)",
    "source_code": "\t\tpublic <T> NamedBeanHolder<T> resolveNamedBean(Class<T> requiredType) throws BeansException {\n\t\t\tthrow new UnsupportedOperationException(\"Dependency resolution not supported\");\n\t\t}"
  },
  "org.springframework.web.accept.ContentNegotiationManager": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Central class to determine requested {@linkplain MediaType media types}\n * for a request. This is done by delegating to a list of configured\n * {@code ContentNegotiationStrategy} instances.\n *\n * <p>Also provides methods to look up file extensions for a media type.\n * This is done by delegating to the list of configured\n * {@code MediaTypeFileExtensionResolver} instances.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 3.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "public class ContentNegotiationManager",
    "source_code": "public class ContentNegotiationManager implements ContentNegotiationStrategy, MediaTypeFileExtensionResolver {\n\n\tprivate final List<ContentNegotiationStrategy> strategies = new ArrayList<>();\n\n\tprivate final Set<MediaTypeFileExtensionResolver> resolvers = new LinkedHashSet<>();\n\n\n\t/**\n\t * Create an instance with the given list of\n\t * {@code ContentNegotiationStrategy} strategies each of which may also be\n\t * an instance of {@code MediaTypeFileExtensionResolver}.\n\t * @param strategies the strategies to use\n\t */\n\tpublic ContentNegotiationManager(ContentNegotiationStrategy... strategies) {\n\t\tthis(Arrays.asList(strategies));\n\t}\n\n\t/**\n\t * A collection-based alternative to\n\t * {@link #ContentNegotiationManager(ContentNegotiationStrategy...)}.\n\t * @param strategies the strategies to use\n\t * @since 3.2.2\n\t */\n\tpublic ContentNegotiationManager(Collection<ContentNegotiationStrategy> strategies) {\n\t\tAssert.notEmpty(strategies, \"At least one ContentNegotiationStrategy is expected\");\n\t\tthis.strategies.addAll(strategies);\n\t\tfor (ContentNegotiationStrategy strategy : this.strategies) {\n\t\t\tif (strategy instanceof MediaTypeFileExtensionResolver mediaTypeFileExtensionResolver) {\n\t\t\t\tthis.resolvers.add(mediaTypeFileExtensionResolver);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Create a default instance with a {@link HeaderContentNegotiationStrategy}.\n\t */\n\tpublic ContentNegotiationManager() {\n\t\tthis(new HeaderContentNegotiationStrategy());\n\t}\n\n\n\t/**\n\t * Return the configured content negotiation strategies.\n\t * @since 3.2.16\n\t */\n\tpublic List<ContentNegotiationStrategy> getStrategies() {\n\t\treturn this.strategies;\n\t}\n\n\t/**\n\t * Find a {@code ContentNegotiationStrategy} of the given type.\n\t * @param strategyType the strategy type\n\t * @return the first matching strategy, or {@code null} if none\n\t * @since 4.3\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\t@Nullable\n\tpublic <T extends ContentNegotiationStrategy> T getStrategy(Class<T> strategyType) {\n\t\tfor (ContentNegotiationStrategy strategy : getStrategies()) {\n\t\t\tif (strategyType.isInstance(strategy)) {\n\t\t\t\treturn (T) strategy;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Register more {@code MediaTypeFileExtensionResolver} instances in addition\n\t * to those detected at construction.\n\t * @param resolvers the resolvers to add\n\t */\n\tpublic void addFileExtensionResolvers(MediaTypeFileExtensionResolver... resolvers) {\n\t\tCollections.addAll(this.resolvers, resolvers);\n\t}\n\n\t@Override\n\tpublic List<MediaType> resolveMediaTypes(NativeWebRequest request) throws HttpMediaTypeNotAcceptableException {\n\t\tfor (ContentNegotiationStrategy strategy : this.strategies) {\n\t\t\tList<MediaType> mediaTypes = strategy.resolveMediaTypes(request);\n\t\t\tif (mediaTypes.equals(MEDIA_TYPE_ALL_LIST)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn mediaTypes;\n\t\t}\n\t\treturn MEDIA_TYPE_ALL_LIST;\n\t}\n\n\t@Override\n\tpublic List<String> resolveFileExtensions(MediaType mediaType) {\n\t\treturn doResolveExtensions(resolver -> resolver.resolveFileExtensions(mediaType));\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t * <p>At startup this method returns extensions explicitly registered with\n\t * either {@link PathExtensionContentNegotiationStrategy} or\n\t * {@link ParameterContentNegotiationStrategy}. At runtime if there is a\n\t * \"path extension\" strategy and its\n\t * {@link PathExtensionContentNegotiationStrategy#setUseRegisteredExtensionsOnly(boolean)\n\t * useRegisteredExtensionsOnly} property is set to \"false\", the list of extensions may\n\t * increase as file extensions are resolved via\n\t * {@link org.springframework.http.MediaTypeFactory} and cached.\n\t */\n\t@Override\n\tpublic List<String> getAllFileExtensions() {\n\t\treturn doResolveExtensions(MediaTypeFileExtensionResolver::getAllFileExtensions);\n\t}\n\n\tprivate List<String> doResolveExtensions(Function<MediaTypeFileExtensionResolver, List<String>> extractor) {\n\t\tList<String> result = null;\n\t\tfor (MediaTypeFileExtensionResolver resolver : this.resolvers) {\n\t\t\tList<String> extensions = extractor.apply(resolver);\n\t\t\tif (CollectionUtils.isEmpty(extensions)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tresult = (result != null ? result : new ArrayList<>(4));\n\t\t\tfor (String extension : extensions) {\n\t\t\t\tif (!result.contains(extension)) {\n\t\t\t\t\tresult.add(extension);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (result != null ? result : Collections.emptyList());\n\t}\n\n\t/**\n\t * Return all registered lookup key to media type mappings by iterating\n\t * {@link MediaTypeFileExtensionResolver}s.\n\t * @since 5.2.4\n\t */\n\tpublic Map<String, MediaType> getMediaTypeMappings() {\n\t\tMap<String, MediaType> result = null;\n\t\tfor (MediaTypeFileExtensionResolver resolver : this.resolvers) {\n\t\t\tif (resolver instanceof MappingMediaTypeFileExtensionResolver mappingResolver) {\n\t\t\t\tMap<String, MediaType> map = mappingResolver.getMediaTypes();\n\t\t\t\tif (CollectionUtils.isEmpty(map)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tresult = (result != null ? result : new HashMap<>(4));\n\t\t\t\tresult.putAll(map);\n\t\t\t}\n\t\t}\n\t\treturn (result != null ? result : Collections.emptyMap());\n\t}\n\n}"
  },
  "org.springframework.web.accept.ContentNegotiationManager#addFileExtensionResolvers(resolvers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register more {@code MediaTypeFileExtensionResolver} instances in addition\n\t * to those detected at construction.\n\t * @param resolvers the resolvers to add\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolvers"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "void",
    "signature": "public void addFileExtensionResolvers(MediaTypeFileExtensionResolver... resolvers)",
    "source_code": "\tpublic void addFileExtensionResolvers(MediaTypeFileExtensionResolver... resolvers) {\n\t\tCollections.addAll(this.resolvers, resolvers);\n\t}"
  },
  "org.springframework.web.accept.ContentNegotiationManager#getAllFileExtensions()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p>At startup this method returns extensions explicitly registered with\n\t * either {@link PathExtensionContentNegotiationStrategy} or\n\t * {@link ParameterContentNegotiationStrategy}. At runtime if there is a\n\t * \"path extension\" strategy and its\n\t * {@link PathExtensionContentNegotiationStrategy#setUseRegisteredExtensionsOnly(boolean)\n\t * useRegisteredExtensionsOnly} property is set to \"false\", the list of extensions may\n\t * increase as file extensions are resolved via\n\t * {@link org.springframework.http.MediaTypeFactory} and cached.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "List<String>",
    "signature": "public List<String> getAllFileExtensions()",
    "source_code": "\tpublic List<String> getAllFileExtensions() {\n\t\treturn doResolveExtensions(MediaTypeFileExtensionResolver::getAllFileExtensions);\n\t}"
  },
  "org.springframework.web.accept.ContentNegotiationManager#getMediaTypeMappings()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return all registered lookup key to media type mappings by iterating\n\t * {@link MediaTypeFileExtensionResolver}s.\n\t * @since 5.2.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "MediaType>",
    "signature": "public MediaType> getMediaTypeMappings()",
    "source_code": "\tpublic Map<String, MediaType> getMediaTypeMappings() {\n\t\tMap<String, MediaType> result = null;\n\t\tfor (MediaTypeFileExtensionResolver resolver : this.resolvers) {\n\t\t\tif (resolver instanceof MappingMediaTypeFileExtensionResolver mappingResolver) {\n\t\t\t\tMap<String, MediaType> map = mappingResolver.getMediaTypes();\n\t\t\t\tif (CollectionUtils.isEmpty(map)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tresult = (result != null ? result : new HashMap<>(4));\n\t\t\t\tresult.putAll(map);\n\t\t\t}\n\t\t}\n\t\treturn (result != null ? result : Collections.emptyMap());\n\t}"
  },
  "org.springframework.web.accept.ContentNegotiationManager#getStrategies()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured content negotiation strategies.\n\t * @since 3.2.16\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "List<ContentNegotiationStrategy>",
    "signature": "public List<ContentNegotiationStrategy> getStrategies()",
    "source_code": "\tpublic List<ContentNegotiationStrategy> getStrategies() {\n\t\treturn this.strategies;\n\t}"
  },
  "org.springframework.web.accept.ContentNegotiationManager#getStrategy(strategyType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a {@code ContentNegotiationStrategy} of the given type.\n\t * @param strategyType the strategy type\n\t * @return the first matching strategy, or {@code null} if none\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "strategyType"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "T",
    "signature": "public T getStrategy(Class<T> strategyType)",
    "source_code": "\tpublic <T extends ContentNegotiationStrategy> T getStrategy(Class<T> strategyType) {\n\t\tfor (ContentNegotiationStrategy strategy : getStrategies()) {\n\t\t\tif (strategyType.isInstance(strategy)) {\n\t\t\t\treturn (T) strategy;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.accept.ContentNegotiationManager#resolveFileExtensions(mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "List<String>",
    "signature": "public List<String> resolveFileExtensions(MediaType mediaType)",
    "source_code": "\tpublic List<String> resolveFileExtensions(MediaType mediaType) {\n\t\treturn doResolveExtensions(resolver -> resolver.resolveFileExtensions(mediaType));\n\t}"
  },
  "org.springframework.web.accept.ContentNegotiationManager#resolveMediaTypes(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "List<MediaType>",
    "signature": "public List<MediaType> resolveMediaTypes(NativeWebRequest request)",
    "source_code": "\tpublic List<MediaType> resolveMediaTypes(NativeWebRequest request) throws HttpMediaTypeNotAcceptableException {\n\t\tfor (ContentNegotiationStrategy strategy : this.strategies) {\n\t\t\tList<MediaType> mediaTypes = strategy.resolveMediaTypes(request);\n\t\t\tif (mediaTypes.equals(MEDIA_TYPE_ALL_LIST)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn mediaTypes;\n\t\t}\n\t\treturn MEDIA_TYPE_ALL_LIST;\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeDataBinder": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Specialized {@link org.springframework.validation.DataBinder} to perform data\n * binding from URL query parameters or form data in the request data to Java objects.\n *\n * <p><strong>WARNING</strong>: Data binding can lead to security issues by exposing\n * parts of the object graph that are not meant to be accessed or modified by\n * external clients. Therefore the design and use of data binding should be considered\n * carefully with regard to security. For more details, please refer to the dedicated\n * sections on data binding for\n * <a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-initbinder-model-design\">Spring Web MVC</a> and\n * <a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-initbinder-model-design\">Spring WebFlux</a>\n * in the reference manual.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "public class WebExchangeDataBinder",
    "source_code": "public class WebExchangeDataBinder extends WebDataBinder {\n\n\t/**\n\t * Create a new instance, with default object name.\n\t * @param target the target object to bind onto (or {@code null} if the\n\t * binder is just used to convert a plain parameter value)\n\t * @see #DEFAULT_OBJECT_NAME\n\t */\n\tpublic WebExchangeDataBinder(@Nullable Object target) {\n\t\tsuper(target);\n\t}\n\n\t/**\n\t * Create a new instance.\n\t * @param target the target object to bind onto (or {@code null} if the\n\t * binder is just used to convert a plain parameter value)\n\t * @param objectName the name of the target object\n\t */\n\tpublic WebExchangeDataBinder(@Nullable Object target, String objectName) {\n\t\tsuper(target, objectName);\n\t}\n\n\n\t/**\n\t * Bind query parameters, form data, or multipart form data to the binder target.\n\t * @param exchange the current exchange\n\t * @return a {@code Mono<Void>} when binding is complete\n\t */\n\tpublic Mono<Void> bind(ServerWebExchange exchange) {\n\t\treturn getValuesToBind(exchange)\n\t\t\t\t.doOnNext(values -> doBind(new MutablePropertyValues(values)))\n\t\t\t\t.then();\n\t}\n\n\t/**\n\t * Obtain the values for data binding. By default, this delegates to\n\t * {@link #extractValuesToBind(ServerWebExchange)}.\n\t * @param exchange the current exchange\n\t * @return a map of bind values\n\t * @since 5.3\n\t */\n\tpublic Mono<Map<String, Object>> getValuesToBind(ServerWebExchange exchange) {\n\t\treturn extractValuesToBind(exchange);\n\t}\n\n\n\t/**\n\t * Combine query params and form data for multipart form data from the body\n\t * of the request into a {@code Map<String, Object>} of values to use for\n\t * data binding purposes.\n\t * @param exchange the current exchange\n\t * @return a {@code Mono} with the values to bind\n\t * @see org.springframework.http.server.reactive.ServerHttpRequest#getQueryParams()\n\t * @see ServerWebExchange#getFormData()\n\t * @see ServerWebExchange#getMultipartData()\n\t */\n\tpublic static Mono<Map<String, Object>> extractValuesToBind(ServerWebExchange exchange) {\n\t\tMultiValueMap<String, String> queryParams = exchange.getRequest().getQueryParams();\n\t\tMono<MultiValueMap<String, String>> formData = exchange.getFormData();\n\t\tMono<MultiValueMap<String, Part>> multipartData = exchange.getMultipartData();\n\n\t\treturn Mono.zip(Mono.just(queryParams), formData, multipartData)\n\t\t\t\t.map(tuple -> {\n\t\t\t\t\tMap<String, Object> result = new TreeMap<>();\n\t\t\t\t\ttuple.getT1().forEach((key, values) -> addBindValue(result, key, values));\n\t\t\t\t\ttuple.getT2().forEach((key, values) -> addBindValue(result, key, values));\n\t\t\t\t\ttuple.getT3().forEach((key, values) -> addBindValue(result, key, values));\n\t\t\t\t\treturn result;\n\t\t\t\t});\n\t}\n\n\tprotected static void addBindValue(Map<String, Object> params, String key, List<?> values) {\n\t\tif (!CollectionUtils.isEmpty(values)) {\n\t\t\tvalues = values.stream()\n\t\t\t\t\t.map(value -> value instanceof FormFieldPart formFieldPart ? formFieldPart.value() : value)\n\t\t\t\t\t.toList();\n\t\t\tparams.put(key, values.size() == 1 ? values.get(0) : values);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.bind.support.WebExchangeDataBinder#addBindValue(Map<String,params,key,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "params",
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "void",
    "signature": "protected void addBindValue(Map<String, Object> params, String key, List<?> values)",
    "source_code": "\tprotected static void addBindValue(Map<String, Object> params, String key, List<?> values) {\n\t\tif (!CollectionUtils.isEmpty(values)) {\n\t\t\tvalues = values.stream()\n\t\t\t\t\t.map(value -> value instanceof FormFieldPart formFieldPart ? formFieldPart.value() : value)\n\t\t\t\t\t.toList();\n\t\t\tparams.put(key, values.size() == 1 ? values.get(0) : values);\n\t\t}\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeDataBinder#bind(exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Bind query parameters, form data, or multipart form data to the binder target.\n\t * @param exchange the current exchange\n\t * @return a {@code Mono<Void>} when binding is complete\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> bind(ServerWebExchange exchange)",
    "source_code": "\tpublic Mono<Void> bind(ServerWebExchange exchange) {\n\t\treturn getValuesToBind(exchange)\n\t\t\t\t.doOnNext(values -> doBind(new MutablePropertyValues(values)))\n\t\t\t\t.then();\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeDataBinder#extractValuesToBind(exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Combine query params and form data for multipart form data from the body\n\t * of the request into a {@code Map<String, Object>} of values to use for\n\t * data binding purposes.\n\t * @param exchange the current exchange\n\t * @return a {@code Mono} with the values to bind\n\t * @see org.springframework.http.server.reactive.ServerHttpRequest#getQueryParams()\n\t * @see ServerWebExchange#getFormData()\n\t * @see ServerWebExchange#getMultipartData()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "Object>>",
    "signature": "public Object>> extractValuesToBind(ServerWebExchange exchange)",
    "source_code": "\tpublic static Mono<Map<String, Object>> extractValuesToBind(ServerWebExchange exchange) {\n\t\tMultiValueMap<String, String> queryParams = exchange.getRequest().getQueryParams();\n\t\tMono<MultiValueMap<String, String>> formData = exchange.getFormData();\n\t\tMono<MultiValueMap<String, Part>> multipartData = exchange.getMultipartData();\n\n\t\treturn Mono.zip(Mono.just(queryParams), formData, multipartData)\n\t\t\t\t.map(tuple -> {\n\t\t\t\t\tMap<String, Object> result = new TreeMap<>();\n\t\t\t\t\ttuple.getT1().forEach((key, values) -> addBindValue(result, key, values));\n\t\t\t\t\ttuple.getT2().forEach((key, values) -> addBindValue(result, key, values));\n\t\t\t\t\ttuple.getT3().forEach((key, values) -> addBindValue(result, key, values));\n\t\t\t\t\treturn result;\n\t\t\t\t});\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeDataBinder#getValuesToBind(exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain the values for data binding. By default, this delegates to\n\t * {@link #extractValuesToBind(ServerWebExchange)}.\n\t * @param exchange the current exchange\n\t * @return a map of bind values\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "Object>>",
    "signature": "public Object>> getValuesToBind(ServerWebExchange exchange)",
    "source_code": "\tpublic Mono<Map<String, Object>> getValuesToBind(ServerWebExchange exchange) {\n\t\treturn extractValuesToBind(exchange);\n\t}"
  },
  "org.springframework.web.client.HttpMessageConverterExtractor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Response extractor that uses the given {@linkplain HttpMessageConverter entity converters}\n * to convert the response into a type {@code T}.\n *\n * @author Arjen Poutsma\n * @author Sam Brannen\n * @since 3.0\n * @param <T> the data type\n * @see RestTemplate\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "signature": "public class HttpMessageConverterExtractor",
    "source_code": "public class HttpMessageConverterExtractor<T> implements ResponseExtractor<T> {\n\n\tprivate final Type responseType;\n\n\t@Nullable\n\tprivate final Class<T> responseClass;\n\n\tprivate final List<HttpMessageConverter<?>> messageConverters;\n\n\tprivate final Log logger;\n\n\n\t/**\n\t * Create a new instance of the {@code HttpMessageConverterExtractor} with the given response\n\t * type and message converters. The given converters must support the response type.\n\t */\n\tpublic HttpMessageConverterExtractor(Class<T> responseType, List<HttpMessageConverter<?>> messageConverters) {\n\t\tthis((Type) responseType, messageConverters);\n\t}\n\n\t/**\n\t * Creates a new instance of the {@code HttpMessageConverterExtractor} with the given response\n\t * type and message converters. The given converters must support the response type.\n\t */\n\tpublic HttpMessageConverterExtractor(Type responseType, List<HttpMessageConverter<?>> messageConverters) {\n\t\tthis(responseType, messageConverters, LogFactory.getLog(HttpMessageConverterExtractor.class));\n\t}\n\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n\tHttpMessageConverterExtractor(Type responseType, List<HttpMessageConverter<?>> messageConverters, Log logger) {\n\t\tAssert.notNull(responseType, \"'responseType' must not be null\");\n\t\tAssert.notEmpty(messageConverters, \"'messageConverters' must not be empty\");\n\t\tAssert.noNullElements(messageConverters, \"'messageConverters' must not contain null elements\");\n\t\tthis.responseType = responseType;\n\t\tthis.responseClass = (responseType instanceof Class clazz ? clazz : null);\n\t\tthis.messageConverters = messageConverters;\n\t\tthis.logger = logger;\n\t}\n\n\n\t@Override\n\t@SuppressWarnings({\"unchecked\", \"rawtypes\", \"resource\"})\n\tpublic T extractData(ClientHttpResponse response) throws IOException {\n\t\tIntrospectingClientHttpResponse responseWrapper = new IntrospectingClientHttpResponse(response);\n\t\tif (!responseWrapper.hasMessageBody() || responseWrapper.hasEmptyMessageBody()) {\n\t\t\treturn null;\n\t\t}\n\t\tMediaType contentType = getContentType(responseWrapper);\n\n\t\ttry {\n\t\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n\t\t\t\tif (messageConverter instanceof GenericHttpMessageConverter genericMessageConverter) {\n\t\t\t\t\tif (genericMessageConverter.canRead(this.responseType, null, contentType)) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tResolvableType resolvableType = ResolvableType.forType(this.responseType);\n\t\t\t\t\t\t\tlogger.debug(\"Reading to [\" + resolvableType + \"]\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn (T) genericMessageConverter.read(this.responseType, null, responseWrapper);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this.responseClass != null) {\n\t\t\t\t\tif (messageConverter.canRead(this.responseClass, contentType)) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tString className = this.responseClass.getName();\n\t\t\t\t\t\t\tlogger.debug(\"Reading to [\" + className + \"] as \\\"\" + contentType + \"\\\"\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn (T) messageConverter.read((Class) this.responseClass, responseWrapper);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException | HttpMessageNotReadableException ex) {\n\t\t\tthrow new RestClientException(\"Error while extracting response for type [\" +\n\t\t\t\t\tthis.responseType + \"] and content type [\" + contentType + \"]\", ex);\n\t\t}\n\n\t\tthrow new UnknownContentTypeException(this.responseType, contentType,\n\t\t\t\tresponseWrapper.getStatusCode(), responseWrapper.getStatusText(),\n\t\t\t\tresponseWrapper.getHeaders(), getResponseBody(responseWrapper));\n\t}\n\n\t/**\n\t * Determine the Content-Type of the response based on the \"Content-Type\"\n\t * header or otherwise default to {@link MediaType#APPLICATION_OCTET_STREAM}.\n\t * @param response the response\n\t * @return the MediaType, or \"application/octet-stream\"\n\t */\n\tprotected MediaType getContentType(ClientHttpResponse response) {\n\t\tMediaType contentType = response.getHeaders().getContentType();\n\t\tif (contentType == null) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"No content-type, using 'application/octet-stream'\");\n\t\t\t}\n\t\t\tcontentType = MediaType.APPLICATION_OCTET_STREAM;\n\t\t}\n\t\treturn contentType;\n\t}\n\n\tprivate static byte[] getResponseBody(ClientHttpResponse response) {\n\t\ttry {\n\t\t\treturn FileCopyUtils.copyToByteArray(response.getBody());\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\t// ignore\n\t\t}\n\t\treturn new byte[0];\n\t}\n}"
  },
  "org.springframework.web.client.HttpMessageConverterExtractor#extractData(response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "response"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "T",
    "signature": "public T extractData(ClientHttpResponse response)",
    "source_code": "\tpublic T extractData(ClientHttpResponse response) throws IOException {\n\t\tIntrospectingClientHttpResponse responseWrapper = new IntrospectingClientHttpResponse(response);\n\t\tif (!responseWrapper.hasMessageBody() || responseWrapper.hasEmptyMessageBody()) {\n\t\t\treturn null;\n\t\t}\n\t\tMediaType contentType = getContentType(responseWrapper);\n\n\t\ttry {\n\t\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n\t\t\t\tif (messageConverter instanceof GenericHttpMessageConverter genericMessageConverter) {\n\t\t\t\t\tif (genericMessageConverter.canRead(this.responseType, null, contentType)) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tResolvableType resolvableType = ResolvableType.forType(this.responseType);\n\t\t\t\t\t\t\tlogger.debug(\"Reading to [\" + resolvableType + \"]\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn (T) genericMessageConverter.read(this.responseType, null, responseWrapper);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this.responseClass != null) {\n\t\t\t\t\tif (messageConverter.canRead(this.responseClass, contentType)) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tString className = this.responseClass.getName();\n\t\t\t\t\t\t\tlogger.debug(\"Reading to [\" + className + \"] as \\\"\" + contentType + \"\\\"\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn (T) messageConverter.read((Class) this.responseClass, responseWrapper);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException | HttpMessageNotReadableException ex) {\n\t\t\tthrow new RestClientException(\"Error while extracting response for type [\" +\n\t\t\t\t\tthis.responseType + \"] and content type [\" + contentType + \"]\", ex);\n\t\t}\n\n\t\tthrow new UnknownContentTypeException(this.responseType, contentType,\n\t\t\t\tresponseWrapper.getStatusCode(), responseWrapper.getStatusText(),\n\t\t\t\tresponseWrapper.getHeaders(), getResponseBody(responseWrapper));\n\t}"
  },
  "org.springframework.web.client.HttpMessageConverterExtractor#getContentType(response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the Content-Type of the response based on the \"Content-Type\"\n\t * header or otherwise default to {@link MediaType#APPLICATION_OCTET_STREAM}.\n\t * @param response the response\n\t * @return the MediaType, or \"application/octet-stream\"\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "response"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "MediaType",
    "signature": "protected MediaType getContentType(ClientHttpResponse response)",
    "source_code": "\tprotected MediaType getContentType(ClientHttpResponse response) {\n\t\tMediaType contentType = response.getHeaders().getContentType();\n\t\tif (contentType == null) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"No content-type, using 'application/octet-stream'\");\n\t\t\t}\n\t\t\tcontentType = MediaType.APPLICATION_OCTET_STREAM;\n\t\t}\n\t\treturn contentType;\n\t}"
  },
  "org.springframework.web.context.ContextCleanupListener": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Web application listener that cleans up remaining disposable attributes\n * in the ServletContext, i.e. attributes which implement {@link DisposableBean}\n * and haven't been removed before. This is typically used for destroying objects\n * in \"application\" scope, for which the lifecycle implies destruction at the\n * very end of the web application's shutdown phase.\n *\n * @author Juergen Hoeller\n * @since 3.0\n * @see org.springframework.web.context.support.ServletContextScope\n * @see ContextLoaderListener\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "signature": "public class ContextCleanupListener",
    "source_code": "public class ContextCleanupListener implements ServletContextListener {\n\n\tprivate static final Log logger = LogFactory.getLog(ContextCleanupListener.class);\n\n\n\t@Override\n\tpublic void contextInitialized(ServletContextEvent event) {\n\t}\n\n\t@Override\n\tpublic void contextDestroyed(ServletContextEvent event) {\n\t\tcleanupAttributes(event.getServletContext());\n\t}\n\n\n\t/**\n\t * Find all Spring-internal ServletContext attributes which implement\n\t * {@link DisposableBean} and invoke the destroy method on them.\n\t * @param servletContext the ServletContext to check\n\t * @see DisposableBean#destroy()\n\t */\n\tstatic void cleanupAttributes(ServletContext servletContext) {\n\t\tEnumeration<String> attrNames = servletContext.getAttributeNames();\n\t\twhile (attrNames.hasMoreElements()) {\n\t\t\tString attrName = attrNames.nextElement();\n\t\t\tif (attrName.startsWith(\"org.springframework.\")) {\n\t\t\t\tObject attrValue = servletContext.getAttribute(attrName);\n\t\t\t\tif (attrValue instanceof DisposableBean disposableBean) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdisposableBean.destroy();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\t\t\tlogger.warn(\"Invocation of destroy method failed on ServletContext \" +\n\t\t\t\t\t\t\t\t\t\"attribute with name '\" + attrName + \"'\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.context.ContextCleanupListener#contextDestroyed(event)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "event"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "return": "void",
    "signature": "public void contextDestroyed(ServletContextEvent event)",
    "source_code": "\tpublic void contextDestroyed(ServletContextEvent event) {\n\t\tcleanupAttributes(event.getServletContext());\n\t}"
  },
  "org.springframework.web.context.ContextCleanupListener#contextInitialized(event)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "event"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "return": "void",
    "signature": "public void contextInitialized(ServletContextEvent event)",
    "source_code": "\tpublic void contextInitialized(ServletContextEvent event) {\n\t}"
  },
  "org.springframework.web.context.request.RequestContextListener": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Servlet listener that exposes the request to the current thread,\n * through both {@link org.springframework.context.i18n.LocaleContextHolder} and\n * {@link RequestContextHolder}. To be registered as listener in {@code web.xml}.\n *\n * <p>Alternatively, Spring's {@link org.springframework.web.filter.RequestContextFilter}\n * and Spring's {@link org.springframework.web.servlet.DispatcherServlet} also expose\n * the same request context to the current thread. In contrast to this listener,\n * advanced options are available there (e.g. \"threadContextInheritable\").\n *\n * <p>This listener is mainly for use with third-party servlets, e.g. the JSF FacesServlet.\n * Within Spring's own web support, DispatcherServlet's processing is perfectly sufficient.\n *\n * @author Juergen Hoeller\n * @since 2.0\n * @see jakarta.servlet.ServletRequestListener\n * @see org.springframework.context.i18n.LocaleContextHolder\n * @see RequestContextHolder\n * @see org.springframework.web.filter.RequestContextFilter\n * @see org.springframework.web.servlet.DispatcherServlet\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "signature": "public class RequestContextListener",
    "source_code": "public class RequestContextListener implements ServletRequestListener {\n\n\tprivate static final String REQUEST_ATTRIBUTES_ATTRIBUTE =\n\t\t\tRequestContextListener.class.getName() + \".REQUEST_ATTRIBUTES\";\n\n\n\t@Override\n\tpublic void requestInitialized(ServletRequestEvent requestEvent) {\n\t\tif (!(requestEvent.getServletRequest() instanceof HttpServletRequest request)) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Request is not an HttpServletRequest: \" + requestEvent.getServletRequest());\n\t\t}\n\t\tServletRequestAttributes attributes = new ServletRequestAttributes(request);\n\t\trequest.setAttribute(REQUEST_ATTRIBUTES_ATTRIBUTE, attributes);\n\t\tLocaleContextHolder.setLocale(request.getLocale());\n\t\tRequestContextHolder.setRequestAttributes(attributes);\n\t}\n\n\t@Override\n\tpublic void requestDestroyed(ServletRequestEvent requestEvent) {\n\t\tServletRequestAttributes attributes = null;\n\t\tObject reqAttr = requestEvent.getServletRequest().getAttribute(REQUEST_ATTRIBUTES_ATTRIBUTE);\n\t\tif (reqAttr instanceof ServletRequestAttributes servletRequestAttributes) {\n\t\t\tattributes = servletRequestAttributes;\n\t\t}\n\t\tRequestAttributes threadAttributes = RequestContextHolder.getRequestAttributes();\n\t\tif (threadAttributes != null) {\n\t\t\t// We're assumably within the original request thread...\n\t\t\tLocaleContextHolder.resetLocaleContext();\n\t\t\tRequestContextHolder.resetRequestAttributes();\n\t\t\tif (attributes == null && threadAttributes instanceof ServletRequestAttributes servletRequestAttributes) {\n\t\t\t\tattributes = servletRequestAttributes;\n\t\t\t}\n\t\t}\n\t\tif (attributes != null) {\n\t\t\tattributes.requestCompleted();\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.context.request.RequestContextListener#requestDestroyed(requestEvent)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestEvent"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "void",
    "signature": "public void requestDestroyed(ServletRequestEvent requestEvent)",
    "source_code": "\tpublic void requestDestroyed(ServletRequestEvent requestEvent) {\n\t\tServletRequestAttributes attributes = null;\n\t\tObject reqAttr = requestEvent.getServletRequest().getAttribute(REQUEST_ATTRIBUTES_ATTRIBUTE);\n\t\tif (reqAttr instanceof ServletRequestAttributes servletRequestAttributes) {\n\t\t\tattributes = servletRequestAttributes;\n\t\t}\n\t\tRequestAttributes threadAttributes = RequestContextHolder.getRequestAttributes();\n\t\tif (threadAttributes != null) {\n\t\t\t// We're assumably within the original request thread...\n\t\t\tLocaleContextHolder.resetLocaleContext();\n\t\t\tRequestContextHolder.resetRequestAttributes();\n\t\t\tif (attributes == null && threadAttributes instanceof ServletRequestAttributes servletRequestAttributes) {\n\t\t\t\tattributes = servletRequestAttributes;\n\t\t\t}\n\t\t}\n\t\tif (attributes != null) {\n\t\t\tattributes.requestCompleted();\n\t\t}\n\t}"
  },
  "org.springframework.web.context.request.RequestContextListener#requestInitialized(requestEvent)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestEvent"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "return": "void",
    "signature": "public void requestInitialized(ServletRequestEvent requestEvent)",
    "source_code": "\tpublic void requestInitialized(ServletRequestEvent requestEvent) {\n\t\tif (!(requestEvent.getServletRequest() instanceof HttpServletRequest request)) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Request is not an HttpServletRequest: \" + requestEvent.getServletRequest());\n\t\t}\n\t\tServletRequestAttributes attributes = new ServletRequestAttributes(request);\n\t\trequest.setAttribute(REQUEST_ATTRIBUTES_ATTRIBUTE, attributes);\n\t\tLocaleContextHolder.setLocale(request.getLocale());\n\t\tRequestContextHolder.setRequestAttributes(attributes);\n\t}"
  },
  "org.springframework.web.context.support.AbstractRefreshableWebApplicationContext": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link org.springframework.context.support.AbstractRefreshableApplicationContext}\n * subclass which implements the\n * {@link org.springframework.web.context.ConfigurableWebApplicationContext}\n * interface for web environments. Provides a \"configLocations\" property,\n * to be populated through the ConfigurableWebApplicationContext interface\n * on web application startup.\n *\n * <p>This class is as easy to subclass as AbstractRefreshableApplicationContext:\n * All you need to implement is the {@link #loadBeanDefinitions} method;\n * see the superclass javadoc for details. Note that implementations are supposed\n * to load bean definitions from the files specified by the locations returned\n * by the {@link #getConfigLocations} method.\n *\n * <p>Interprets resource paths as servlet context resources, i.e. as paths beneath\n * the web application root. Absolute paths, e.g. for files outside the web app root,\n * can be accessed via \"file:\" URLs, as implemented by\n * {@link org.springframework.core.io.DefaultResourceLoader}.\n *\n * <p>In addition to the special beans detected by\n * {@link org.springframework.context.support.AbstractApplicationContext},\n * this class detects a bean of type {@link org.springframework.ui.context.ThemeSource}\n * in the context, under the special bean name \"themeSource\".\n * Theme support is deprecated as of 6.0 with no direct replacement.\n *\n * <p><b>This is the web context to be subclassed for a different bean definition format.</b>\n * Such a context implementation can be specified as \"contextClass\" context-param\n * for {@link org.springframework.web.context.ContextLoader} or as \"contextClass\"\n * init-param for {@link org.springframework.web.servlet.FrameworkServlet},\n * replacing the default {@link XmlWebApplicationContext}. It will then automatically\n * receive the \"contextConfigLocation\" context-param or init-param, respectively.\n *\n * <p>Note that WebApplicationContext implementations are generally supposed\n * to configure themselves based on the configuration received through the\n * {@link ConfigurableWebApplicationContext} interface. In contrast, a standalone\n * application context might allow for configuration in custom startup code\n * (for example, {@link org.springframework.context.support.GenericApplicationContext}).\n *\n * @author Juergen Hoeller\n * @since 1.1.3\n * @see #loadBeanDefinitions\n * @see org.springframework.web.context.ConfigurableWebApplicationContext#setConfigLocations\n * @see XmlWebApplicationContext\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "signature": "public class AbstractRefreshableWebApplicationContext",
    "source_code": "public abstract class AbstractRefreshableWebApplicationContext extends AbstractRefreshableConfigApplicationContext"
  },
  "org.springframework.web.context.support.AbstractRefreshableWebApplicationContext#createEnvironment()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create and return a new {@link StandardServletEnvironment}. Subclasses may override\n\t * in order to configure the environment or specialize the environment type returned.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "ConfigurableEnvironment",
    "signature": "protected ConfigurableEnvironment createEnvironment()",
    "source_code": "\tprotected ConfigurableEnvironment createEnvironment() {\n\t\treturn new StandardServletEnvironment();\n\t}"
  },
  "org.springframework.web.context.support.AbstractRefreshableWebApplicationContext#getApplicationName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "String",
    "signature": "public String getApplicationName()",
    "source_code": "\tpublic String getApplicationName() {\n\t\treturn (this.servletContext != null ? this.servletContext.getContextPath() : \"\");\n\t}"
  },
  "org.springframework.web.context.support.AbstractRefreshableWebApplicationContext#getConfigLocations()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "String[]",
    "signature": "public String[] getConfigLocations()",
    "source_code": "\tpublic String[] getConfigLocations() {\n\t\treturn super.getConfigLocations();\n\t}"
  },
  "org.springframework.web.context.support.AbstractRefreshableWebApplicationContext#getNamespace()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "String",
    "signature": "public String getNamespace()",
    "source_code": "\tpublic String getNamespace() {\n\t\treturn this.namespace;\n\t}"
  },
  "org.springframework.web.context.support.AbstractRefreshableWebApplicationContext#getResourceByPath(path)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation supports file paths beneath the root of the ServletContext.\n\t * @see ServletContextResource\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "path"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "Resource",
    "signature": "protected Resource getResourceByPath(String path)",
    "source_code": "\tprotected Resource getResourceByPath(String path) {\n\t\tAssert.state(this.servletContext != null, \"No ServletContext available\");\n\t\treturn new ServletContextResource(this.servletContext, path);\n\t}"
  },
  "org.springframework.web.context.support.AbstractRefreshableWebApplicationContext#getResourcePatternResolver()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation supports pattern matching in unexpanded WARs too.\n\t * @see ServletContextResourcePatternResolver\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "ResourcePatternResolver",
    "signature": "protected ResourcePatternResolver getResourcePatternResolver()",
    "source_code": "\tprotected ResourcePatternResolver getResourcePatternResolver() {\n\t\treturn new ServletContextResourcePatternResolver(this);\n\t}"
  },
  "org.springframework.web.context.support.AbstractRefreshableWebApplicationContext#getServletConfig()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "ServletConfig",
    "signature": "public ServletConfig getServletConfig()",
    "source_code": "\tpublic ServletConfig getServletConfig() {\n\t\treturn this.servletConfig;\n\t}"
  },
  "org.springframework.web.context.support.AbstractRefreshableWebApplicationContext#getServletContext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "ServletContext",
    "signature": "public ServletContext getServletContext()",
    "source_code": "\tpublic ServletContext getServletContext() {\n\t\treturn this.servletContext;\n\t}"
  },
  "org.springframework.web.context.support.AbstractRefreshableWebApplicationContext#getTheme(themeName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "themeName"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "Theme",
    "signature": "public Theme getTheme(String themeName)",
    "source_code": "\tpublic Theme getTheme(String themeName) {\n\t\tAssert.state(this.themeSource != null, \"No ThemeSource available\");\n\t\treturn this.themeSource.getTheme(themeName);\n\t}"
  },
  "org.springframework.web.context.support.AbstractRefreshableWebApplicationContext#initPropertySources()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p>Replace {@code Servlet}-related property sources.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "void",
    "signature": "protected void initPropertySources()",
    "source_code": "\tprotected void initPropertySources() {\n\t\tConfigurableEnvironment env = getEnvironment();\n\t\tif (env instanceof ConfigurableWebEnvironment configurableWebEnv) {\n\t\t\tconfigurableWebEnv.initPropertySources(this.servletContext, this.servletConfig);\n\t\t}\n\t}"
  },
  "org.springframework.web.context.support.AbstractRefreshableWebApplicationContext#onRefresh()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the theme capability.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "void",
    "signature": "protected void onRefresh()",
    "source_code": "\tprotected void onRefresh() {\n\t\tthis.themeSource = UiApplicationContextUtils.initThemeSource(this);\n\t}"
  },
  "org.springframework.web.context.support.AbstractRefreshableWebApplicationContext#postProcessBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register request/session scopes, a {@link ServletContextAwareProcessor}, etc.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "void",
    "signature": "protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)",
    "source_code": "\tprotected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n\t\tbeanFactory.addBeanPostProcessor(new ServletContextAwareProcessor(this.servletContext, this.servletConfig));\n\t\tbeanFactory.ignoreDependencyInterface(ServletContextAware.class);\n\t\tbeanFactory.ignoreDependencyInterface(ServletConfigAware.class);\n\n\t\tWebApplicationContextUtils.registerWebApplicationScopes(beanFactory, this.servletContext);\n\t\tWebApplicationContextUtils.registerEnvironmentBeans(beanFactory, this.servletContext, this.servletConfig);\n\t}"
  },
  "org.springframework.web.context.support.AbstractRefreshableWebApplicationContext#setNamespace(namespace)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "namespace"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "void",
    "signature": "public void setNamespace(@Nullable String namespace)",
    "source_code": "\tpublic void setNamespace(@Nullable String namespace) {\n\t\tthis.namespace = namespace;\n\t\tif (namespace != null) {\n\t\t\tsetDisplayName(\"WebApplicationContext for namespace '\" + namespace + \"'\");\n\t\t}\n\t}"
  },
  "org.springframework.web.context.support.AbstractRefreshableWebApplicationContext#setServletConfig(servletConfig)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletConfig"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "void",
    "signature": "public void setServletConfig(@Nullable ServletConfig servletConfig)",
    "source_code": "\tpublic void setServletConfig(@Nullable ServletConfig servletConfig) {\n\t\tthis.servletConfig = servletConfig;\n\t\tif (servletConfig != null && this.servletContext == null) {\n\t\t\tsetServletContext(servletConfig.getServletContext());\n\t\t}\n\t}"
  },
  "org.springframework.web.context.support.AbstractRefreshableWebApplicationContext#setServletContext(servletContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "void",
    "signature": "public void setServletContext(@Nullable ServletContext servletContext)",
    "source_code": "\tpublic void setServletContext(@Nullable ServletContext servletContext) {\n\t\tthis.servletContext = servletContext;\n\t}"
  },
  "org.springframework.web.context.support.GenericWebApplicationContext": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Subclass of {@link GenericApplicationContext}, suitable for web environments.\n *\n * <p>Implements {@link ConfigurableWebApplicationContext}, but is not intended for\n * declarative setup in {@code web.xml}. Instead, it is designed for programmatic setup,\n * for example for building nested contexts or for use within\n * {@link org.springframework.web.WebApplicationInitializer WebApplicationInitializers}.\n *\n * <p>Interprets resource paths as servlet context resources, i.e. as paths beneath\n * the web application root. Absolute paths &mdash; for example, for files outside\n * the web app root &mdash; can be accessed via {@code file:} URLs, as implemented\n * by {@code AbstractApplicationContext}.\n *\n * <p>In addition to the special beans detected by\n * {@link org.springframework.context.support.AbstractApplicationContext AbstractApplicationContext},\n * this class detects a {@link ThemeSource} bean in the context, with the name \"themeSource\".\n * Theme support is deprecated as of 6.0 with no direct replacement.\n *\n * <p>If you wish to register annotated <em>component classes</em> with a\n * {@code GenericWebApplicationContext}, you can use an\n * {@link org.springframework.context.annotation.AnnotatedBeanDefinitionReader\n * AnnotatedBeanDefinitionReader}, as demonstrated in the following example.\n * Component classes include in particular\n * {@link org.springframework.context.annotation.Configuration @Configuration}\n * classes but also plain {@link org.springframework.stereotype.Component @Component}\n * classes as well as JSR-330 compliant classes using {@code jakarta.inject} annotations.\n *\n * <pre class=\"code\">\n * GenericWebApplicationContext context = new GenericWebApplicationContext();\n * AnnotatedBeanDefinitionReader reader = new AnnotatedBeanDefinitionReader(context);\n * reader.register(AppConfig.class, UserController.class, UserRepository.class);</pre>\n *\n * <p>If you intend to implement a {@code WebApplicationContext} that reads bean definitions\n * from configuration files, consider deriving from {@link AbstractRefreshableWebApplicationContext},\n * reading the bean definitions in an implementation of the {@code loadBeanDefinitions}\n * method.\n *\n * @author Juergen Hoeller\n * @author Chris Beams\n * @author Sam Brannen\n * @since 1.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "signature": "public class GenericWebApplicationContext",
    "source_code": "public class GenericWebApplicationContext extends GenericApplicationContext"
  },
  "org.springframework.web.context.support.GenericWebApplicationContext#createEnvironment()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create and return a new {@link StandardServletEnvironment}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "ConfigurableEnvironment",
    "signature": "protected ConfigurableEnvironment createEnvironment()",
    "source_code": "\tprotected ConfigurableEnvironment createEnvironment() {\n\t\treturn new StandardServletEnvironment();\n\t}"
  },
  "org.springframework.web.context.support.GenericWebApplicationContext#getApplicationName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "String",
    "signature": "public String getApplicationName()",
    "source_code": "\tpublic String getApplicationName() {\n\t\treturn (this.servletContext != null ? this.servletContext.getContextPath() : \"\");\n\t}"
  },
  "org.springframework.web.context.support.GenericWebApplicationContext#getConfigLocations()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "String[]",
    "signature": "public String[] getConfigLocations()",
    "source_code": "\tpublic String[] getConfigLocations() {\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\"GenericWebApplicationContext does not support getConfigLocations()\");\n\t}"
  },
  "org.springframework.web.context.support.GenericWebApplicationContext#getNamespace()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "String",
    "signature": "public String getNamespace()",
    "source_code": "\tpublic String getNamespace() {\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\"GenericWebApplicationContext does not support getNamespace()\");\n\t}"
  },
  "org.springframework.web.context.support.GenericWebApplicationContext#getResourceByPath(path)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation supports file paths beneath the root of the {@link ServletContext}.\n\t * @see ServletContextResource\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "path"
    ],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "Resource",
    "signature": "protected Resource getResourceByPath(String path)",
    "source_code": "\tprotected Resource getResourceByPath(String path) {\n\t\tAssert.state(this.servletContext != null, \"No ServletContext available\");\n\t\treturn new ServletContextResource(this.servletContext, path);\n\t}"
  },
  "org.springframework.web.context.support.GenericWebApplicationContext#getResourcePatternResolver()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation supports pattern matching in unexpanded WARs too.\n\t * @see ServletContextResourcePatternResolver\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "ResourcePatternResolver",
    "signature": "protected ResourcePatternResolver getResourcePatternResolver()",
    "source_code": "\tprotected ResourcePatternResolver getResourcePatternResolver() {\n\t\treturn new ServletContextResourcePatternResolver(this);\n\t}"
  },
  "org.springframework.web.context.support.GenericWebApplicationContext#getServletConfig()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "ServletConfig",
    "signature": "public ServletConfig getServletConfig()",
    "source_code": "\tpublic ServletConfig getServletConfig() {\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\"GenericWebApplicationContext does not support getServletConfig()\");\n\t}"
  },
  "org.springframework.web.context.support.GenericWebApplicationContext#getServletContext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "ServletContext",
    "signature": "public ServletContext getServletContext()",
    "source_code": "\tpublic ServletContext getServletContext() {\n\t\treturn this.servletContext;\n\t}"
  },
  "org.springframework.web.context.support.GenericWebApplicationContext#getTheme(themeName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "themeName"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "Theme",
    "signature": "public Theme getTheme(String themeName)",
    "source_code": "\tpublic Theme getTheme(String themeName) {\n\t\tAssert.state(this.themeSource != null, \"No ThemeSource available\");\n\t\treturn this.themeSource.getTheme(themeName);\n\t}"
  },
  "org.springframework.web.context.support.GenericWebApplicationContext#initPropertySources()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p>Replace {@code Servlet}-related property sources.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "void",
    "signature": "protected void initPropertySources()",
    "source_code": "\tprotected void initPropertySources() {\n\t\tConfigurableEnvironment env = getEnvironment();\n\t\tif (env instanceof ConfigurableWebEnvironment configurableWebEnv) {\n\t\t\tconfigurableWebEnv.initPropertySources(this.servletContext, null);\n\t\t}\n\t}"
  },
  "org.springframework.web.context.support.GenericWebApplicationContext#onRefresh()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the theme capability.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "void",
    "signature": "protected void onRefresh()",
    "source_code": "\tprotected void onRefresh() {\n\t\tthis.themeSource = UiApplicationContextUtils.initThemeSource(this);\n\t}"
  },
  "org.springframework.web.context.support.GenericWebApplicationContext#postProcessBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register request/session scopes, environment beans, a {@link ServletContextAwareProcessor}, etc.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "void",
    "signature": "protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)",
    "source_code": "\tprotected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n\t\tif (this.servletContext != null) {\n\t\t\tbeanFactory.addBeanPostProcessor(new ServletContextAwareProcessor(this.servletContext));\n\t\t\tbeanFactory.ignoreDependencyInterface(ServletContextAware.class);\n\t\t}\n\t\tWebApplicationContextUtils.registerWebApplicationScopes(beanFactory, this.servletContext);\n\t\tWebApplicationContextUtils.registerEnvironmentBeans(beanFactory, this.servletContext);\n\t}"
  },
  "org.springframework.web.context.support.GenericWebApplicationContext#setConfigLocation(configLocation)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "configLocation"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "void",
    "signature": "public void setConfigLocation(String configLocation)",
    "source_code": "\tpublic void setConfigLocation(String configLocation) {\n\t\tif (StringUtils.hasText(configLocation)) {\n\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\"GenericWebApplicationContext does not support setConfigLocation(). \" +\n\t\t\t\t\t\"Do you still have a 'contextConfigLocation' init-param set?\");\n\t\t}\n\t}"
  },
  "org.springframework.web.context.support.GenericWebApplicationContext#setConfigLocations(configLocations)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "configLocations"
    ],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "void",
    "signature": "public void setConfigLocations(String... configLocations)",
    "source_code": "\tpublic void setConfigLocations(String... configLocations) {\n\t\tif (!ObjectUtils.isEmpty(configLocations)) {\n\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\"GenericWebApplicationContext does not support setConfigLocations(). \" +\n\t\t\t\t\t\"Do you still have a 'contextConfigLocations' init-param set?\");\n\t\t}\n\t}"
  },
  "org.springframework.web.context.support.GenericWebApplicationContext#setNamespace(namespace)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "namespace"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "void",
    "signature": "public void setNamespace(@Nullable String namespace)",
    "source_code": "\tpublic void setNamespace(@Nullable String namespace) {\n\t\t// no-op\n\t}"
  },
  "org.springframework.web.context.support.GenericWebApplicationContext#setServletConfig(servletConfig)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletConfig"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "void",
    "signature": "public void setServletConfig(@Nullable ServletConfig servletConfig)",
    "source_code": "\tpublic void setServletConfig(@Nullable ServletConfig servletConfig) {\n\t\t// no-op\n\t}"
  },
  "org.springframework.web.context.support.GenericWebApplicationContext#setServletContext(servletContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link ServletContext} that this {@code WebApplicationContext} runs in.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "void",
    "signature": "public void setServletContext(@Nullable ServletContext servletContext)",
    "source_code": "\tpublic void setServletContext(@Nullable ServletContext servletContext) {\n\t\tthis.servletContext = servletContext;\n\t}"
  },
  "org.springframework.web.context.support.ServletContextAwareProcessor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link org.springframework.beans.factory.config.BeanPostProcessor}\n * implementation that passes the ServletContext to beans that implement\n * the {@link ServletContextAware} interface.\n *\n * <p>Web application contexts will automatically register this with their\n * underlying bean factory. Applications do not use this directly.\n *\n * @author Juergen Hoeller\n * @author Phillip Webb\n * @since 12.03.2004\n * @see org.springframework.web.context.ServletContextAware\n * @see org.springframework.web.context.support.XmlWebApplicationContext#postProcessBeanFactory\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public class ServletContextAwareProcessor",
    "source_code": "public class ServletContextAwareProcessor implements BeanPostProcessor {\n\n\t@Nullable\n\tprivate ServletContext servletContext;\n\n\t@Nullable\n\tprivate ServletConfig servletConfig;\n\n\n\t/**\n\t * Create a new ServletContextAwareProcessor without an initial context or config.\n\t * When this constructor is used the {@link #getServletContext()} and/or\n\t * {@link #getServletConfig()} methods should be overridden.\n\t */\n\tprotected ServletContextAwareProcessor() {\n\t}\n\n\t/**\n\t * Create a new ServletContextAwareProcessor for the given context.\n\t */\n\tpublic ServletContextAwareProcessor(ServletContext servletContext) {\n\t\tthis(servletContext, null);\n\t}\n\n\t/**\n\t * Create a new ServletContextAwareProcessor for the given config.\n\t */\n\tpublic ServletContextAwareProcessor(ServletConfig servletConfig) {\n\t\tthis(null, servletConfig);\n\t}\n\n\t/**\n\t * Create a new ServletContextAwareProcessor for the given context and config.\n\t */\n\tpublic ServletContextAwareProcessor(@Nullable ServletContext servletContext, @Nullable ServletConfig servletConfig) {\n\t\tthis.servletContext = servletContext;\n\t\tthis.servletConfig = servletConfig;\n\t}\n\n\n\t/**\n\t * Returns the {@link ServletContext} to be injected or {@code null}. This method\n\t * can be overridden by subclasses when a context is obtained after the post-processor\n\t * has been registered.\n\t */\n\t@Nullable\n\tprotected ServletContext getServletContext() {\n\t\tif (this.servletContext == null && getServletConfig() != null) {\n\t\t\treturn getServletConfig().getServletContext();\n\t\t}\n\t\treturn this.servletContext;\n\t}\n\n\t/**\n\t * Returns the {@link ServletConfig} to be injected or {@code null}. This method\n\t * can be overridden by subclasses when a context is obtained after the post-processor\n\t * has been registered.\n\t */\n\t@Nullable\n\tprotected ServletConfig getServletConfig() {\n\t\treturn this.servletConfig;\n\t}\n\n\t@Override\n\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n\t\tif (getServletContext() != null && bean instanceof ServletContextAware servletContextAware) {\n\t\t\tservletContextAware.setServletContext(getServletContext());\n\t\t}\n\t\tif (getServletConfig() != null && bean instanceof ServletConfigAware servletConfigAware) {\n\t\t\tservletConfigAware.setServletConfig(getServletConfig());\n\t\t}\n\t\treturn bean;\n\t}\n\n\t@Override\n\tpublic Object postProcessAfterInitialization(Object bean, String beanName) {\n\t\treturn bean;\n\t}\n\n}"
  },
  "org.springframework.web.context.support.ServletContextAwareProcessor#getServletConfig()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns the {@link ServletConfig} to be injected or {@code null}. This method\n\t * can be overridden by subclasses when a context is obtained after the post-processor\n\t * has been registered.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "ServletConfig",
    "signature": "protected ServletConfig getServletConfig()",
    "source_code": "\tprotected ServletConfig getServletConfig() {\n\t\treturn this.servletConfig;\n\t}"
  },
  "org.springframework.web.context.support.ServletContextAwareProcessor#getServletContext()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns the {@link ServletContext} to be injected or {@code null}. This method\n\t * can be overridden by subclasses when a context is obtained after the post-processor\n\t * has been registered.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "ServletContext",
    "signature": "protected ServletContext getServletContext()",
    "source_code": "\tprotected ServletContext getServletContext() {\n\t\tif (this.servletContext == null && getServletConfig() != null) {\n\t\t\treturn getServletConfig().getServletContext();\n\t\t}\n\t\treturn this.servletContext;\n\t}"
  },
  "org.springframework.web.context.support.ServletContextAwareProcessor#postProcessAfterInitialization(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessAfterInitialization(Object bean, String beanName) {\n\t\treturn bean;\n\t}"
  },
  "org.springframework.web.context.support.ServletContextAwareProcessor#postProcessBeforeInitialization(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n\t\tif (getServletContext() != null && bean instanceof ServletContextAware servletContextAware) {\n\t\t\tservletContextAware.setServletContext(getServletContext());\n\t\t}\n\t\tif (getServletConfig() != null && bean instanceof ServletConfigAware servletConfigAware) {\n\t\t\tservletConfigAware.setServletConfig(getServletConfig());\n\t\t}\n\t\treturn bean;\n\t}"
  },
  "org.springframework.web.context.support.WebApplicationContextUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Convenience methods for retrieving the root {@link WebApplicationContext} for\n * a given {@link ServletContext}. This is useful for programmatically accessing\n * a Spring application context from within custom web views or MVC actions.\n *\n * <p>Note that there are more convenient ways of accessing the root context for\n * many web frameworks, either part of Spring or available as an external library.\n * This helper class is just the most generic way to access the root context.\n *\n * @author Juergen Hoeller\n * @see org.springframework.web.context.ContextLoader\n * @see org.springframework.web.servlet.FrameworkServlet\n * @see org.springframework.web.servlet.DispatcherServlet\n * @see org.springframework.web.jsf.FacesContextUtils\n * @see org.springframework.web.jsf.el.SpringBeanFacesELResolver\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "signature": "public class WebApplicationContextUtils",
    "source_code": "public abstract class WebApplicationContextUtils {\n\n\tprivate static final boolean jsfPresent =\n\t\t\tClassUtils.isPresent(\"jakarta.faces.context.FacesContext\", RequestContextHolder.class.getClassLoader());\n\n\n\t/**\n\t * Find the root {@code WebApplicationContext} for this web app, typically\n\t * loaded via {@link org.springframework.web.context.ContextLoaderListener}.\n\t * <p>Will rethrow an exception that happened on root context startup,\n\t * to differentiate between a failed context startup and no context at all.\n\t * @param sc the ServletContext to find the web application context for\n\t * @return the root WebApplicationContext for this web app\n\t * @throws IllegalStateException if the root WebApplicationContext could not be found\n\t * @see org.springframework.web.context.WebApplicationContext#ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE\n\t */\n\tpublic static WebApplicationContext getRequiredWebApplicationContext(ServletContext sc) throws IllegalStateException {\n\t\tWebApplicationContext wac = getWebApplicationContext(sc);\n\t\tif (wac == null) {\n\t\t\tthrow new IllegalStateException(\"No WebApplicationContext found: no ContextLoaderListener registered?\");\n\t\t}\n\t\treturn wac;\n\t}\n\n\t/**\n\t * Find the root {@code WebApplicationContext} for this web app, typically\n\t * loaded via {@link org.springframework.web.context.ContextLoaderListener}.\n\t * <p>Will rethrow an exception that happened on root context startup,\n\t * to differentiate between a failed context startup and no context at all.\n\t * @param sc the ServletContext to find the web application context for\n\t * @return the root WebApplicationContext for this web app, or {@code null} if none\n\t * @see org.springframework.web.context.WebApplicationContext#ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE\n\t */\n\t@Nullable\n\tpublic static WebApplicationContext getWebApplicationContext(ServletContext sc) {\n\t\treturn getWebApplicationContext(sc, WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);\n\t}\n\n\t/**\n\t * Find a custom {@code WebApplicationContext} for this web app.\n\t * @param sc the ServletContext to find the web application context for\n\t * @param attrName the name of the ServletContext attribute to look for\n\t * @return the desired WebApplicationContext for this web app, or {@code null} if none\n\t */\n\t@Nullable\n\tpublic static WebApplicationContext getWebApplicationContext(ServletContext sc, String attrName) {\n\t\tAssert.notNull(sc, \"ServletContext must not be null\");\n\t\tObject attr = sc.getAttribute(attrName);\n\t\tif (attr == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (attr instanceof RuntimeException runtimeException) {\n\t\t\tthrow runtimeException;\n\t\t}\n\t\tif (attr instanceof Error error) {\n\t\t\tthrow error;\n\t\t}\n\t\tif (attr instanceof Exception exception) {\n\t\t\tthrow new IllegalStateException(exception);\n\t\t}\n\t\tif (!(attr instanceof WebApplicationContext wac)) {\n\t\t\tthrow new IllegalStateException(\"Context attribute is not of type WebApplicationContext: \" + attr);\n\t\t}\n\t\treturn wac;\n\t}\n\n\t/**\n\t * Find a unique {@code WebApplicationContext} for this web app: either the\n\t * root web app context (preferred) or a unique {@code WebApplicationContext}\n\t * among the registered {@code ServletContext} attributes (typically coming\n\t * from a single {@code DispatcherServlet} in the current web application).\n\t * <p>Note that {@code DispatcherServlet}'s exposure of its context can be\n\t * controlled through its {@code publishContext} property, which is {@code true}\n\t * by default but can be selectively switched to only publish a single context\n\t * despite multiple {@code DispatcherServlet} registrations in the web app.\n\t * @param sc the ServletContext to find the web application context for\n\t * @return the desired WebApplicationContext for this web app, or {@code null} if none\n\t * @since 4.2\n\t * @see #getWebApplicationContext(ServletContext)\n\t * @see ServletContext#getAttributeNames()\n\t */\n\t@Nullable\n\tpublic static WebApplicationContext findWebApplicationContext(ServletContext sc) {\n\t\tWebApplicationContext wac = getWebApplicationContext(sc);\n\t\tif (wac == null) {\n\t\t\tEnumeration<String> attrNames = sc.getAttributeNames();\n\t\t\twhile (attrNames.hasMoreElements()) {\n\t\t\t\tString attrName = attrNames.nextElement();\n\t\t\t\tObject attrValue = sc.getAttribute(attrName);\n\t\t\t\tif (attrValue instanceof WebApplicationContext currentWac) {\n\t\t\t\t\tif (wac != null) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"No unique WebApplicationContext found: more than one \" +\n\t\t\t\t\t\t\t\t\"DispatcherServlet registered with publishContext=true?\");\n\t\t\t\t\t}\n\t\t\t\t\twac = currentWac;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn wac;\n\t}\n\n\n\t/**\n\t * Register web-specific scopes (\"request\", \"session\", \"globalSession\")\n\t * with the given BeanFactory, as used by the WebApplicationContext.\n\t * @param beanFactory the BeanFactory to configure\n\t */\n\tpublic static void registerWebApplicationScopes(ConfigurableListableBeanFactory beanFactory) {\n\t\tregisterWebApplicationScopes(beanFactory, null);\n\t}\n\n\t/**\n\t * Register web-specific scopes (\"request\", \"session\", \"globalSession\", \"application\")\n\t * with the given BeanFactory, as used by the WebApplicationContext.\n\t * @param beanFactory the BeanFactory to configure\n\t * @param sc the ServletContext that we're running within\n\t */\n\tpublic static void registerWebApplicationScopes(ConfigurableListableBeanFactory beanFactory,\n\t\t\t@Nullable ServletContext sc) {\n\n\t\tbeanFactory.registerScope(WebApplicationContext.SCOPE_REQUEST, new RequestScope());\n\t\tbeanFactory.registerScope(WebApplicationContext.SCOPE_SESSION, new SessionScope());\n\t\tif (sc != null) {\n\t\t\tServletContextScope appScope = new ServletContextScope(sc);\n\t\t\tbeanFactory.registerScope(WebApplicationContext.SCOPE_APPLICATION, appScope);\n\t\t\t// Register as ServletContext attribute, for ContextCleanupListener to detect it.\n\t\t\tsc.setAttribute(ServletContextScope.class.getName(), appScope);\n\t\t}\n\n\t\tbeanFactory.registerResolvableDependency(ServletRequest.class, new RequestObjectFactory());\n\t\tbeanFactory.registerResolvableDependency(ServletResponse.class, new ResponseObjectFactory());\n\t\tbeanFactory.registerResolvableDependency(HttpSession.class, new SessionObjectFactory());\n\t\tbeanFactory.registerResolvableDependency(WebRequest.class, new WebRequestObjectFactory());\n\t\tif (jsfPresent) {\n\t\t\tFacesDependencyRegistrar.registerFacesDependencies(beanFactory);\n\t\t}\n\t}\n\n\t/**\n\t * Register web-specific environment beans (\"contextParameters\", \"contextAttributes\")\n\t * with the given BeanFactory, as used by the WebApplicationContext.\n\t * @param bf the BeanFactory to configure\n\t * @param sc the ServletContext that we're running within\n\t */\n\tpublic static void registerEnvironmentBeans(ConfigurableListableBeanFactory bf, @Nullable ServletContext sc) {\n\t\tregisterEnvironmentBeans(bf, sc, null);\n\t}\n\n\t/**\n\t * Register web-specific environment beans (\"contextParameters\", \"contextAttributes\")\n\t * with the given BeanFactory, as used by the WebApplicationContext.\n\t * @param bf the BeanFactory to configure\n\t * @param servletContext the ServletContext that we're running within\n\t * @param servletConfig the ServletConfig\n\t */\n\tpublic static void registerEnvironmentBeans(ConfigurableListableBeanFactory bf,\n\t\t\t@Nullable ServletContext servletContext, @Nullable ServletConfig servletConfig) {\n\n\t\tif (servletContext != null && !bf.containsBean(WebApplicationContext.SERVLET_CONTEXT_BEAN_NAME)) {\n\t\t\tbf.registerSingleton(WebApplicationContext.SERVLET_CONTEXT_BEAN_NAME, servletContext);\n\t\t}\n\n\t\tif (servletConfig != null && !bf.containsBean(ConfigurableWebApplicationContext.SERVLET_CONFIG_BEAN_NAME)) {\n\t\t\tbf.registerSingleton(ConfigurableWebApplicationContext.SERVLET_CONFIG_BEAN_NAME, servletConfig);\n\t\t}\n\n\t\tif (!bf.containsBean(WebApplicationContext.CONTEXT_PARAMETERS_BEAN_NAME)) {\n\t\t\tMap<String, String> parameterMap = new HashMap<>();\n\t\t\tif (servletContext != null) {\n\t\t\t\tEnumeration<?> paramNameEnum = servletContext.getInitParameterNames();\n\t\t\t\twhile (paramNameEnum.hasMoreElements()) {\n\t\t\t\t\tString paramName = (String) paramNameEnum.nextElement();\n\t\t\t\t\tparameterMap.put(paramName, servletContext.getInitParameter(paramName));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (servletConfig != null) {\n\t\t\t\tEnumeration<?> paramNameEnum = servletConfig.getInitParameterNames();\n\t\t\t\twhile (paramNameEnum.hasMoreElements()) {\n\t\t\t\t\tString paramName = (String) paramNameEnum.nextElement();\n\t\t\t\t\tparameterMap.put(paramName, servletConfig.getInitParameter(paramName));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbf.registerSingleton(WebApplicationContext.CONTEXT_PARAMETERS_BEAN_NAME,\n\t\t\t\t\tCollections.unmodifiableMap(parameterMap));\n\t\t}\n\n\t\tif (!bf.containsBean(WebApplicationContext.CONTEXT_ATTRIBUTES_BEAN_NAME)) {\n\t\t\tMap<String, Object> attributeMap = new HashMap<>();\n\t\t\tif (servletContext != null) {\n\t\t\t\tEnumeration<?> attrNameEnum = servletContext.getAttributeNames();\n\t\t\t\twhile (attrNameEnum.hasMoreElements()) {\n\t\t\t\t\tString attrName = (String) attrNameEnum.nextElement();\n\t\t\t\t\tattributeMap.put(attrName, servletContext.getAttribute(attrName));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbf.registerSingleton(WebApplicationContext.CONTEXT_ATTRIBUTES_BEAN_NAME,\n\t\t\t\t\tCollections.unmodifiableMap(attributeMap));\n\t\t}\n\t}\n\n\t/**\n\t * Convenient variant of {@link #initServletPropertySources(MutablePropertySources,\n\t * ServletContext, ServletConfig)} that always provides {@code null} for the\n\t * {@link ServletConfig} parameter.\n\t * @see #initServletPropertySources(MutablePropertySources, ServletContext, ServletConfig)\n\t */\n\tpublic static void initServletPropertySources(MutablePropertySources propertySources, ServletContext servletContext) {\n\t\tinitServletPropertySources(propertySources, servletContext, null);\n\t}\n\n\t/**\n\t * Replace {@code Servlet}-based {@link StubPropertySource stub property sources} with\n\t * actual instances populated with the given {@code servletContext} and\n\t * {@code servletConfig} objects.\n\t * <p>This method is idempotent with respect to the fact it may be called any number\n\t * of times but will perform replacement of stub property sources with their\n\t * corresponding actual property sources once and only once.\n\t * @param sources the {@link MutablePropertySources} to initialize (must not\n\t * be {@code null})\n\t * @param servletContext the current {@link ServletContext} (ignored if {@code null}\n\t * or if the {@link StandardServletEnvironment#SERVLET_CONTEXT_PROPERTY_SOURCE_NAME\n\t * servlet context property source} has already been initialized)\n\t * @param servletConfig the current {@link ServletConfig} (ignored if {@code null}\n\t * or if the {@link StandardServletEnvironment#SERVLET_CONFIG_PROPERTY_SOURCE_NAME\n\t * servlet config property source} has already been initialized)\n\t * @see org.springframework.core.env.PropertySource.StubPropertySource\n\t * @see org.springframework.core.env.ConfigurableEnvironment#getPropertySources()\n\t */\n\tpublic static void initServletPropertySources(MutablePropertySources sources,\n\t\t\t@Nullable ServletContext servletContext, @Nullable ServletConfig servletConfig) {\n\n\t\tAssert.notNull(sources, \"'propertySources' must not be null\");\n\t\tString name = StandardServletEnvironment.SERVLET_CONTEXT_PROPERTY_SOURCE_NAME;\n\t\tif (servletContext != null && sources.get(name) instanceof StubPropertySource) {\n\t\t\tsources.replace(name, new ServletContextPropertySource(name, servletContext));\n\t\t}\n\t\tname = StandardServletEnvironment.SERVLET_CONFIG_PROPERTY_SOURCE_NAME;\n\t\tif (servletConfig != null && sources.get(name) instanceof StubPropertySource) {\n\t\t\tsources.replace(name, new ServletConfigPropertySource(name, servletConfig));\n\t\t}\n\t}\n\n\t/**\n\t * Return the current RequestAttributes instance as ServletRequestAttributes.\n\t * @see RequestContextHolder#currentRequestAttributes()\n\t */\n\tprivate static ServletRequestAttributes currentRequestAttributes() {\n\t\tRequestAttributes requestAttr = RequestContextHolder.currentRequestAttributes();\n\t\tif (!(requestAttr instanceof ServletRequestAttributes servletRequestAttributes)) {\n\t\t\tthrow new IllegalStateException(\"Current request is not a servlet request\");\n\t\t}\n\t\treturn servletRequestAttributes;\n\t}\n\n\n\t/**\n\t * Factory that exposes the current request object on demand.\n\t */\n\t@SuppressWarnings(\"serial\")\n\tprivate static class RequestObjectFactory implements ObjectFactory<ServletRequest>, Serializable {\n\n\t\t@Override\n\t\tpublic ServletRequest getObject() {\n\t\t\treturn currentRequestAttributes().getRequest();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Current HttpServletRequest\";\n\t\t}\n\t}\n\n\n\t/**\n\t * Factory that exposes the current response object on demand.\n\t */\n\t@SuppressWarnings(\"serial\")\n\tprivate static class ResponseObjectFactory implements ObjectFactory<ServletResponse>, Serializable {\n\n\t\t@Override\n\t\tpublic ServletResponse getObject() {\n\t\t\tServletResponse response = currentRequestAttributes().getResponse();\n\t\t\tif (response == null) {\n\t\t\t\tthrow new IllegalStateException(\"Current servlet response not available - \" +\n\t\t\t\t\t\t\"consider using RequestContextFilter instead of RequestContextListener\");\n\t\t\t}\n\t\t\treturn response;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Current HttpServletResponse\";\n\t\t}\n\t}\n\n\n\t/**\n\t * Factory that exposes the current session object on demand.\n\t */\n\t@SuppressWarnings(\"serial\")\n\tprivate static class SessionObjectFactory implements ObjectFactory<HttpSession>, Serializable {\n\n\t\t@Override\n\t\tpublic HttpSession getObject() {\n\t\t\treturn currentRequestAttributes().getRequest().getSession();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Current HttpSession\";\n\t\t}\n\t}\n\n\n\t/**\n\t * Factory that exposes the current WebRequest object on demand.\n\t */\n\t@SuppressWarnings(\"serial\")\n\tprivate static class WebRequestObjectFactory implements ObjectFactory<WebRequest>, Serializable {\n\n\t\t@Override\n\t\tpublic WebRequest getObject() {\n\t\t\tServletRequestAttributes requestAttr = currentRequestAttributes();\n\t\t\treturn new ServletWebRequest(requestAttr.getRequest(), requestAttr.getResponse());\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Current ServletWebRequest\";\n\t\t}\n\t}\n\n\n\t/**\n\t * Inner class to avoid hard-coded JSF dependency.\n \t */\n\tprivate static class FacesDependencyRegistrar {\n\n\t\tpublic static void registerFacesDependencies(ConfigurableListableBeanFactory beanFactory) {\n\t\t\tbeanFactory.registerResolvableDependency(FacesContext.class, new ObjectFactory<FacesContext>() {\n\t\t\t\t@Override\n\t\t\t\tpublic FacesContext getObject() {\n\t\t\t\t\treturn FacesContext.getCurrentInstance();\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic String toString() {\n\t\t\t\t\treturn \"Current JSF FacesContext\";\n\t\t\t\t}\n\t\t\t});\n\t\t\tbeanFactory.registerResolvableDependency(ExternalContext.class, new ObjectFactory<ExternalContext>() {\n\t\t\t\t@Override\n\t\t\t\tpublic ExternalContext getObject() {\n\t\t\t\t\treturn FacesContext.getCurrentInstance().getExternalContext();\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic String toString() {\n\t\t\t\t\treturn \"Current JSF ExternalContext\";\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.context.support.WebApplicationContextUtils#findWebApplicationContext(sc)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a unique {@code WebApplicationContext} for this web app: either the\n\t * root web app context (preferred) or a unique {@code WebApplicationContext}\n\t * among the registered {@code ServletContext} attributes (typically coming\n\t * from a single {@code DispatcherServlet} in the current web application).\n\t * <p>Note that {@code DispatcherServlet}'s exposure of its context can be\n\t * controlled through its {@code publishContext} property, which is {@code true}\n\t * by default but can be selectively switched to only publish a single context\n\t * despite multiple {@code DispatcherServlet} registrations in the web app.\n\t * @param sc the ServletContext to find the web application context for\n\t * @return the desired WebApplicationContext for this web app, or {@code null} if none\n\t * @since 4.2\n\t * @see #getWebApplicationContext(ServletContext)\n\t * @see ServletContext#getAttributeNames()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sc"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "WebApplicationContext",
    "signature": "public WebApplicationContext findWebApplicationContext(ServletContext sc)",
    "source_code": "\tpublic static WebApplicationContext findWebApplicationContext(ServletContext sc) {\n\t\tWebApplicationContext wac = getWebApplicationContext(sc);\n\t\tif (wac == null) {\n\t\t\tEnumeration<String> attrNames = sc.getAttributeNames();\n\t\t\twhile (attrNames.hasMoreElements()) {\n\t\t\t\tString attrName = attrNames.nextElement();\n\t\t\t\tObject attrValue = sc.getAttribute(attrName);\n\t\t\t\tif (attrValue instanceof WebApplicationContext currentWac) {\n\t\t\t\t\tif (wac != null) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"No unique WebApplicationContext found: more than one \" +\n\t\t\t\t\t\t\t\t\"DispatcherServlet registered with publishContext=true?\");\n\t\t\t\t\t}\n\t\t\t\t\twac = currentWac;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn wac;\n\t}"
  },
  "org.springframework.web.context.support.WebApplicationContextUtils#getObject()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 417
    },
    "return": "ExternalContext",
    "signature": "public ExternalContext getObject()",
    "source_code": "\t\t\t\tpublic ExternalContext getObject() {\n\t\t\t\t\treturn FacesContext.getCurrentInstance().getExternalContext();\n\t\t\t\t}"
  },
  "org.springframework.web.context.support.WebApplicationContextUtils#getRequiredWebApplicationContext(sc)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the root {@code WebApplicationContext} for this web app, typically\n\t * loaded via {@link org.springframework.web.context.ContextLoaderListener}.\n\t * <p>Will rethrow an exception that happened on root context startup,\n\t * to differentiate between a failed context startup and no context at all.\n\t * @param sc the ServletContext to find the web application context for\n\t * @return the root WebApplicationContext for this web app\n\t * @throws IllegalStateException if the root WebApplicationContext could not be found\n\t * @see org.springframework.web.context.WebApplicationContext#ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sc"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "WebApplicationContext",
    "signature": "public WebApplicationContext getRequiredWebApplicationContext(ServletContext sc)",
    "source_code": "\tpublic static WebApplicationContext getRequiredWebApplicationContext(ServletContext sc) throws IllegalStateException {\n\t\tWebApplicationContext wac = getWebApplicationContext(sc);\n\t\tif (wac == null) {\n\t\t\tthrow new IllegalStateException(\"No WebApplicationContext found: no ContextLoaderListener registered?\");\n\t\t}\n\t\treturn wac;\n\t}"
  },
  "org.springframework.web.context.support.WebApplicationContextUtils#getWebApplicationContext(sc)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the root {@code WebApplicationContext} for this web app, typically\n\t * loaded via {@link org.springframework.web.context.ContextLoaderListener}.\n\t * <p>Will rethrow an exception that happened on root context startup,\n\t * to differentiate between a failed context startup and no context at all.\n\t * @param sc the ServletContext to find the web application context for\n\t * @return the root WebApplicationContext for this web app, or {@code null} if none\n\t * @see org.springframework.web.context.WebApplicationContext#ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sc"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "WebApplicationContext",
    "signature": "public WebApplicationContext getWebApplicationContext(ServletContext sc)",
    "source_code": "\tpublic static WebApplicationContext getWebApplicationContext(ServletContext sc) {\n\t\treturn getWebApplicationContext(sc, WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);\n\t}"
  },
  "org.springframework.web.context.support.WebApplicationContextUtils#getWebApplicationContext(sc,attrName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a custom {@code WebApplicationContext} for this web app.\n\t * @param sc the ServletContext to find the web application context for\n\t * @param attrName the name of the ServletContext attribute to look for\n\t * @return the desired WebApplicationContext for this web app, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sc",
      "attrName"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "WebApplicationContext",
    "signature": "public WebApplicationContext getWebApplicationContext(ServletContext sc, String attrName)",
    "source_code": "\tpublic static WebApplicationContext getWebApplicationContext(ServletContext sc, String attrName) {\n\t\tAssert.notNull(sc, \"ServletContext must not be null\");\n\t\tObject attr = sc.getAttribute(attrName);\n\t\tif (attr == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (attr instanceof RuntimeException runtimeException) {\n\t\t\tthrow runtimeException;\n\t\t}\n\t\tif (attr instanceof Error error) {\n\t\t\tthrow error;\n\t\t}\n\t\tif (attr instanceof Exception exception) {\n\t\t\tthrow new IllegalStateException(exception);\n\t\t}\n\t\tif (!(attr instanceof WebApplicationContext wac)) {\n\t\t\tthrow new IllegalStateException(\"Context attribute is not of type WebApplicationContext: \" + attr);\n\t\t}\n\t\treturn wac;\n\t}"
  },
  "org.springframework.web.context.support.WebApplicationContextUtils#initServletPropertySources(propertySources,servletContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient variant of {@link #initServletPropertySources(MutablePropertySources,\n\t * ServletContext, ServletConfig)} that always provides {@code null} for the\n\t * {@link ServletConfig} parameter.\n\t * @see #initServletPropertySources(MutablePropertySources, ServletContext, ServletConfig)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertySources",
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "void",
    "signature": "public void initServletPropertySources(MutablePropertySources propertySources, ServletContext servletContext)",
    "source_code": "\tpublic static void initServletPropertySources(MutablePropertySources propertySources, ServletContext servletContext) {\n\t\tinitServletPropertySources(propertySources, servletContext, null);\n\t}"
  },
  "org.springframework.web.context.support.WebApplicationContextUtils#initServletPropertySources(sources,servletContext,servletConfig)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Replace {@code Servlet}-based {@link StubPropertySource stub property sources} with\n\t * actual instances populated with the given {@code servletContext} and\n\t * {@code servletConfig} objects.\n\t * <p>This method is idempotent with respect to the fact it may be called any number\n\t * of times but will perform replacement of stub property sources with their\n\t * corresponding actual property sources once and only once.\n\t * @param sources the {@link MutablePropertySources} to initialize (must not\n\t * be {@code null})\n\t * @param servletContext the current {@link ServletContext} (ignored if {@code null}\n\t * or if the {@link StandardServletEnvironment#SERVLET_CONTEXT_PROPERTY_SOURCE_NAME\n\t * servlet context property source} has already been initialized)\n\t * @param servletConfig the current {@link ServletConfig} (ignored if {@code null}\n\t * or if the {@link StandardServletEnvironment#SERVLET_CONFIG_PROPERTY_SOURCE_NAME\n\t * servlet config property source} has already been initialized)\n\t * @see org.springframework.core.env.PropertySource.StubPropertySource\n\t * @see org.springframework.core.env.ConfigurableEnvironment#getPropertySources()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sources",
      "servletContext",
      "servletConfig"
    ],
    "position": {
      "column": 1,
      "line": 294
    },
    "return": "void",
    "signature": "public void initServletPropertySources(MutablePropertySources sources,\n\t\t\t@Nullable ServletContext servletContext, @Nullable ServletConfig servletConfig)",
    "source_code": "\tpublic static void initServletPropertySources(MutablePropertySources sources,"
  },
  "org.springframework.web.context.support.WebApplicationContextUtils#registerEnvironmentBeans(bf,sc)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register web-specific environment beans (\"contextParameters\", \"contextAttributes\")\n\t * with the given BeanFactory, as used by the WebApplicationContext.\n\t * @param bf the BeanFactory to configure\n\t * @param sc the ServletContext that we're running within\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bf",
      "sc"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "void",
    "signature": "public void registerEnvironmentBeans(ConfigurableListableBeanFactory bf, @Nullable ServletContext sc)",
    "source_code": "\tpublic static void registerEnvironmentBeans(ConfigurableListableBeanFactory bf, @Nullable ServletContext sc) {\n\t\tregisterEnvironmentBeans(bf, sc, null);\n\t}"
  },
  "org.springframework.web.context.support.WebApplicationContextUtils#registerEnvironmentBeans(bf,servletContext,servletConfig)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register web-specific environment beans (\"contextParameters\", \"contextAttributes\")\n\t * with the given BeanFactory, as used by the WebApplicationContext.\n\t * @param bf the BeanFactory to configure\n\t * @param servletContext the ServletContext that we're running within\n\t * @param servletConfig the ServletConfig\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bf",
      "servletContext",
      "servletConfig"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "void",
    "signature": "public void registerEnvironmentBeans(ConfigurableListableBeanFactory bf,\n\t\t\t@Nullable ServletContext servletContext, @Nullable ServletConfig servletConfig)",
    "source_code": "\tpublic static void registerEnvironmentBeans(ConfigurableListableBeanFactory bf,"
  },
  "org.springframework.web.context.support.WebApplicationContextUtils#registerFacesDependencies(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 404
    },
    "return": "void",
    "signature": "public void registerFacesDependencies(ConfigurableListableBeanFactory beanFactory)",
    "source_code": "\t\tpublic static void registerFacesDependencies(ConfigurableListableBeanFactory beanFactory) {\n\t\t\tbeanFactory.registerResolvableDependency(FacesContext.class, new ObjectFactory<FacesContext>() {\n\t\t\t\t@Override\n\t\t\t\tpublic FacesContext getObject() {\n\t\t\t\t\treturn FacesContext.getCurrentInstance();\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic String toString() {\n\t\t\t\t\treturn \"Current JSF FacesContext\";\n\t\t\t\t}\n\t\t\t});\n\t\t\tbeanFactory.registerResolvableDependency(ExternalContext.class, new ObjectFactory<ExternalContext>() {\n\t\t\t\t@Override\n\t\t\t\tpublic ExternalContext getObject() {\n\t\t\t\t\treturn FacesContext.getCurrentInstance().getExternalContext();\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic String toString() {\n\t\t\t\t\treturn \"Current JSF ExternalContext\";\n\t\t\t\t}\n\t\t\t});\n\t\t}"
  },
  "org.springframework.web.context.support.WebApplicationContextUtils#registerWebApplicationScopes(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register web-specific scopes (\"request\", \"session\", \"globalSession\")\n\t * with the given BeanFactory, as used by the WebApplicationContext.\n\t * @param beanFactory the BeanFactory to configure\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "void",
    "signature": "public void registerWebApplicationScopes(ConfigurableListableBeanFactory beanFactory)",
    "source_code": "\tpublic static void registerWebApplicationScopes(ConfigurableListableBeanFactory beanFactory) {\n\t\tregisterWebApplicationScopes(beanFactory, null);\n\t}"
  },
  "org.springframework.web.context.support.WebApplicationContextUtils#registerWebApplicationScopes(beanFactory,sc)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register web-specific scopes (\"request\", \"session\", \"globalSession\", \"application\")\n\t * with the given BeanFactory, as used by the WebApplicationContext.\n\t * @param beanFactory the BeanFactory to configure\n\t * @param sc the ServletContext that we're running within\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory",
      "sc"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "void",
    "signature": "public void registerWebApplicationScopes(ConfigurableListableBeanFactory beanFactory,\n\t\t\t@Nullable ServletContext sc)",
    "source_code": "\tpublic static void registerWebApplicationScopes(ConfigurableListableBeanFactory beanFactory,"
  },
  "org.springframework.web.context.support.WebApplicationContextUtils#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 421
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\t\t\tpublic String toString() {\n\t\t\t\t\treturn \"Current JSF ExternalContext\";\n\t\t\t\t}"
  },
  "org.springframework.web.context.support.WebApplicationObjectSupport": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Convenient superclass for application objects running in a {@link WebApplicationContext}.\n * Provides {@code getWebApplicationContext()}, {@code getServletContext()}, and\n * {@code getTempDir()} accessors.\n *\n * <p>Note: It is generally recommended to use individual callback interfaces for the actual\n * callbacks needed. This broad base class is primarily intended for use within the framework,\n * in case of {@link ServletContext} access etc typically being needed.\n *\n * @author Juergen Hoeller\n * @since 28.08.2003\n * @see SpringBeanAutowiringSupport\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "signature": "public class WebApplicationObjectSupport",
    "source_code": "public abstract class WebApplicationObjectSupport extends ApplicationObjectSupport implements ServletContextAware {\n\n\t@Nullable\n\tprivate ServletContext servletContext;\n\n\n\t@Override\n\tpublic final void setServletContext(ServletContext servletContext) {\n\t\tif (servletContext != this.servletContext) {\n\t\t\tthis.servletContext = servletContext;\n\t\t\tinitServletContext(servletContext);\n\t\t}\n\t}\n\n\t/**\n\t * Overrides the base class behavior to enforce running in an ApplicationContext.\n\t * All accessors will throw IllegalStateException if not running in a context.\n\t * @see #getApplicationContext()\n\t * @see #getMessageSourceAccessor()\n\t * @see #getWebApplicationContext()\n\t * @see #getServletContext()\n\t * @see #getTempDir()\n\t */\n\t@Override\n\tprotected boolean isContextRequired() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Calls {@link #initServletContext(jakarta.servlet.ServletContext)} if the\n\t * given ApplicationContext is a {@link WebApplicationContext}.\n\t */\n\t@Override\n\tprotected void initApplicationContext(ApplicationContext context) {\n\t\tsuper.initApplicationContext(context);\n\t\tif (this.servletContext == null && context instanceof WebApplicationContext wac) {\n\t\t\tthis.servletContext = wac.getServletContext();\n\t\t\tif (this.servletContext != null) {\n\t\t\t\tinitServletContext(this.servletContext);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Subclasses may override this for custom initialization based\n\t * on the ServletContext that this application object runs in.\n\t * <p>The default implementation is empty. Called by\n\t * {@link #initApplicationContext(org.springframework.context.ApplicationContext)}\n\t * as well as {@link #setServletContext(jakarta.servlet.ServletContext)}.\n\t * @param servletContext the ServletContext that this application object runs in\n\t * (never {@code null})\n\t */\n\tprotected void initServletContext(ServletContext servletContext) {\n\t}\n\n\t/**\n\t * Return the current application context as WebApplicationContext.\n\t * <p><b>NOTE:</b> Only use this if you actually need to access\n\t * WebApplicationContext-specific functionality. Preferably use\n\t * {@code getApplicationContext()} or {@code getServletContext()}\n\t * else, to be able to run in non-WebApplicationContext environments as well.\n\t * @throws IllegalStateException if not running in a WebApplicationContext\n\t * @see #getApplicationContext()\n\t */\n\t@Nullable\n\tprotected final WebApplicationContext getWebApplicationContext() throws IllegalStateException {\n\t\tApplicationContext ctx = getApplicationContext();\n\t\tif (ctx instanceof WebApplicationContext wac) {\n\t\t\treturn wac;\n\t\t}\n\t\telse if (isContextRequired()) {\n\t\t\tthrow new IllegalStateException(\"WebApplicationObjectSupport instance [\" + this +\n\t\t\t\t\t\"] does not run in a WebApplicationContext but in: \" + ctx);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Return the current ServletContext.\n\t * @throws IllegalStateException if not running within a required ServletContext\n\t * @see #isContextRequired()\n\t */\n\t@Nullable\n\tprotected final ServletContext getServletContext() throws IllegalStateException {\n\t\tif (this.servletContext != null) {\n\t\t\treturn this.servletContext;\n\t\t}\n\t\tServletContext servletContext = null;\n\t\tWebApplicationContext wac = getWebApplicationContext();\n\t\tif (wac != null) {\n\t\t\tservletContext = wac.getServletContext();\n\t\t}\n\t\tif (servletContext == null && isContextRequired()) {\n\t\t\tthrow new IllegalStateException(\"WebApplicationObjectSupport instance [\" + this +\n\t\t\t\t\t\"] does not run within a ServletContext. Make sure the object is fully configured!\");\n\t\t}\n\t\treturn servletContext;\n\t}\n\n\t/**\n\t * Return the temporary directory for the current web application,\n\t * as provided by the servlet container.\n\t * @return the File representing the temporary directory\n\t * @throws IllegalStateException if not running within a ServletContext\n\t * @see org.springframework.web.util.WebUtils#getTempDir(jakarta.servlet.ServletContext)\n\t */\n\tprotected final File getTempDir() throws IllegalStateException {\n\t\tServletContext servletContext = getServletContext();\n\t\tAssert.state(servletContext != null, \"ServletContext is required\");\n\t\treturn WebUtils.getTempDir(servletContext);\n\t}\n\n}"
  },
  "org.springframework.web.context.support.WebApplicationObjectSupport#getServletContext()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the current ServletContext.\n\t * @throws IllegalStateException if not running within a required ServletContext\n\t * @see #isContextRequired()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "ServletContext",
    "signature": "protected ServletContext getServletContext()",
    "source_code": "\tprotected final ServletContext getServletContext() throws IllegalStateException {\n\t\tif (this.servletContext != null) {\n\t\t\treturn this.servletContext;\n\t\t}\n\t\tServletContext servletContext = null;\n\t\tWebApplicationContext wac = getWebApplicationContext();\n\t\tif (wac != null) {\n\t\t\tservletContext = wac.getServletContext();\n\t\t}\n\t\tif (servletContext == null && isContextRequired()) {\n\t\t\tthrow new IllegalStateException(\"WebApplicationObjectSupport instance [\" + this +\n\t\t\t\t\t\"] does not run within a ServletContext. Make sure the object is fully configured!\");\n\t\t}\n\t\treturn servletContext;\n\t}"
  },
  "org.springframework.web.context.support.WebApplicationObjectSupport#getTempDir()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the temporary directory for the current web application,\n\t * as provided by the servlet container.\n\t * @return the File representing the temporary directory\n\t * @throws IllegalStateException if not running within a ServletContext\n\t * @see org.springframework.web.util.WebUtils#getTempDir(jakarta.servlet.ServletContext)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "File",
    "signature": "protected File getTempDir()",
    "source_code": "\tprotected final File getTempDir() throws IllegalStateException {\n\t\tServletContext servletContext = getServletContext();\n\t\tAssert.state(servletContext != null, \"ServletContext is required\");\n\t\treturn WebUtils.getTempDir(servletContext);\n\t}"
  },
  "org.springframework.web.context.support.WebApplicationObjectSupport#getWebApplicationContext()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the current application context as WebApplicationContext.\n\t * <p><b>NOTE:</b> Only use this if you actually need to access\n\t * WebApplicationContext-specific functionality. Preferably use\n\t * {@code getApplicationContext()} or {@code getServletContext()}\n\t * else, to be able to run in non-WebApplicationContext environments as well.\n\t * @throws IllegalStateException if not running in a WebApplicationContext\n\t * @see #getApplicationContext()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "WebApplicationContext",
    "signature": "protected WebApplicationContext getWebApplicationContext()",
    "source_code": "\tprotected final WebApplicationContext getWebApplicationContext() throws IllegalStateException {\n\t\tApplicationContext ctx = getApplicationContext();\n\t\tif (ctx instanceof WebApplicationContext wac) {\n\t\t\treturn wac;\n\t\t}\n\t\telse if (isContextRequired()) {\n\t\t\tthrow new IllegalStateException(\"WebApplicationObjectSupport instance [\" + this +\n\t\t\t\t\t\"] does not run in a WebApplicationContext but in: \" + ctx);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.web.context.support.WebApplicationObjectSupport#initApplicationContext(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Calls {@link #initServletContext(jakarta.servlet.ServletContext)} if the\n\t * given ApplicationContext is a {@link WebApplicationContext}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "void",
    "signature": "protected void initApplicationContext(ApplicationContext context)",
    "source_code": "\tprotected void initApplicationContext(ApplicationContext context) {\n\t\tsuper.initApplicationContext(context);\n\t\tif (this.servletContext == null && context instanceof WebApplicationContext wac) {\n\t\t\tthis.servletContext = wac.getServletContext();\n\t\t\tif (this.servletContext != null) {\n\t\t\t\tinitServletContext(this.servletContext);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.context.support.WebApplicationObjectSupport#initServletContext(servletContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses may override this for custom initialization based\n\t * on the ServletContext that this application object runs in.\n\t * <p>The default implementation is empty. Called by\n\t * {@link #initApplicationContext(org.springframework.context.ApplicationContext)}\n\t * as well as {@link #setServletContext(jakarta.servlet.ServletContext)}.\n\t * @param servletContext the ServletContext that this application object runs in\n\t * (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "protected void initServletContext(ServletContext servletContext)",
    "source_code": "\tprotected void initServletContext(ServletContext servletContext) {\n\t}"
  },
  "org.springframework.web.context.support.WebApplicationObjectSupport#isContextRequired()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Overrides the base class behavior to enforce running in an ApplicationContext.\n\t * All accessors will throw IllegalStateException if not running in a context.\n\t * @see #getApplicationContext()\n\t * @see #getMessageSourceAccessor()\n\t * @see #getWebApplicationContext()\n\t * @see #getServletContext()\n\t * @see #getTempDir()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "boolean",
    "signature": "protected boolean isContextRequired()",
    "source_code": "\tprotected boolean isContextRequired() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.context.support.WebApplicationObjectSupport#setServletContext(servletContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "return": "void",
    "signature": "public void setServletContext(ServletContext servletContext)",
    "source_code": "\tpublic final void setServletContext(ServletContext servletContext) {\n\t\tif (servletContext != this.servletContext) {\n\t\t\tthis.servletContext = servletContext;\n\t\t\tinitServletContext(servletContext);\n\t\t}\n\t}"
  },
  "org.springframework.web.jsf.DEFAULT_TARGET_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Default name of the target bean in the Spring application context:\n\t * \"jsfNavigationHandler\".\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "signature": "public String DEFAULT_TARGET_BEAN_NAME",
    "source_code": "\tpublic static final String DEFAULT_TARGET_BEAN_NAME = \"jsfNavigationHandler\";",
    "type": "String"
  },
  "org.springframework.web.jsf.DelegatingNavigationHandlerProxy": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * JSF NavigationHandler implementation that delegates to a NavigationHandler\n * bean obtained from the Spring root WebApplicationContext.\n *\n * <p>Configure this handler proxy in your {@code faces-config.xml} file\n * as follows:\n *\n * <pre class=\"code\">\n * &lt;application&gt;\n *   ...\n *   &lt;navigation-handler&gt;\n * \t   org.springframework.web.jsf.DelegatingNavigationHandlerProxy\n *   &lt;/navigation-handler&gt;\n *   ...\n * &lt;/application&gt;</pre>\n *\n * By default, the Spring ApplicationContext will be searched for the NavigationHandler\n * under the bean name \"jsfNavigationHandler\". In the simplest case, this is a plain\n * Spring bean definition like the following. However, all of Spring's bean configuration\n * power can be applied to such a bean, in particular all flavors of dependency injection.\n *\n * <pre class=\"code\">\n * &lt;bean name=\"jsfNavigationHandler\" class=\"mypackage.MyNavigationHandler\"&gt;\n *   &lt;property name=\"myProperty\" ref=\"myOtherBean\"/&gt;\n * &lt;/bean&gt;</pre>\n *\n * The target NavigationHandler bean will typically extend the standard JSF\n * NavigationHandler class. However, note that decorating the original\n * NavigationHandler (the JSF provider's default handler) is <i>not</i> supported\n * in such a scenario, since we can't inject the original handler in standard\n * JSF style (that is, as constructor argument).\n *\n * <p>For <b>decorating the original NavigationHandler</b>, make sure that your\n * target bean extends Spring's <b>DecoratingNavigationHandler</b> class. This\n * allows to pass in the original handler as method argument, which this proxy\n * automatically detects. Note that a DecoratingNavigationHandler subclass\n * will still work as standard JSF NavigationHandler as well!\n *\n * <p>This proxy may be subclassed to change the bean name used to search for the\n * navigation handler, change the strategy used to obtain the target handler,\n * or change the strategy used to access the ApplicationContext (normally obtained\n * via {@link FacesContextUtils#getWebApplicationContext(FacesContext)}).\n *\n * @author Juergen Hoeller\n * @author Colin Sampaleanu\n * @since 1.2.7\n * @see DecoratingNavigationHandler\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "signature": "public class DelegatingNavigationHandlerProxy",
    "source_code": "public class DelegatingNavigationHandlerProxy extends NavigationHandler {\n\n\t/**\n\t * Default name of the target bean in the Spring application context:\n\t * \"jsfNavigationHandler\".\n\t */\n\tpublic static final String DEFAULT_TARGET_BEAN_NAME = \"jsfNavigationHandler\";\n\n\t@Nullable\n\tprivate NavigationHandler originalNavigationHandler;\n\n\n\t/**\n\t * Create a new DelegatingNavigationHandlerProxy.\n\t */\n\tpublic DelegatingNavigationHandlerProxy() {\n\t}\n\n\t/**\n\t * Create a new DelegatingNavigationHandlerProxy.\n\t * @param originalNavigationHandler the original NavigationHandler\n\t */\n\tpublic DelegatingNavigationHandlerProxy(NavigationHandler originalNavigationHandler) {\n\t\tthis.originalNavigationHandler = originalNavigationHandler;\n\t}\n\n\n\t/**\n\t * Handle the navigation request implied by the specified parameters,\n\t * through delegating to the target bean in the Spring application context.\n\t * <p>The target bean needs to extend the JSF NavigationHandler class.\n\t * If it extends Spring's DecoratingNavigationHandler, the overloaded\n\t * {@code handleNavigation} method with the original NavigationHandler\n\t * as argument will be used. Else, the standard {@code handleNavigation}\n\t * method will be called.\n\t */\n\t@Override\n\tpublic void handleNavigation(FacesContext facesContext, String fromAction, String outcome) {\n\t\tNavigationHandler handler = getDelegate(facesContext);\n\t\tif (handler instanceof DecoratingNavigationHandler decoratingNavigationHandler) {\n\t\t\tdecoratingNavigationHandler.handleNavigation(\n\t\t\t\t\tfacesContext, fromAction, outcome, this.originalNavigationHandler);\n\t\t}\n\t\telse {\n\t\t\thandler.handleNavigation(facesContext, fromAction, outcome);\n\t\t}\n\t}\n\n\t/**\n\t * Return the target NavigationHandler to delegate to.\n\t * <p>By default, a bean with the name \"jsfNavigationHandler\" is obtained\n\t * from the Spring root WebApplicationContext, for every invocation.\n\t * @param facesContext the current JSF context\n\t * @return the target NavigationHandler to delegate to\n\t * @see #getTargetBeanName\n\t * @see #getBeanFactory\n\t */\n\tprotected NavigationHandler getDelegate(FacesContext facesContext) {\n\t\tString targetBeanName = getTargetBeanName(facesContext);\n\t\treturn getBeanFactory(facesContext).getBean(targetBeanName, NavigationHandler.class);\n\t}\n\n\t/**\n\t * Return the name of the target NavigationHandler bean in the BeanFactory.\n\t * Default is \"jsfNavigationHandler\".\n\t * @param facesContext the current JSF context\n\t * @return the name of the target bean\n\t */\n\tprotected String getTargetBeanName(FacesContext facesContext) {\n\t\treturn DEFAULT_TARGET_BEAN_NAME;\n\t}\n\n\t/**\n\t * Retrieve the Spring BeanFactory to delegate bean name resolution to.\n\t * <p>Default implementation delegates to {@code getWebApplicationContext}.\n\t * Can be overridden to provide an arbitrary BeanFactory reference to resolve\n\t * against; usually, this will be a full Spring ApplicationContext.\n\t * @param facesContext the current JSF context\n\t * @return the Spring BeanFactory (never {@code null})\n\t * @see #getWebApplicationContext\n\t */\n\tprotected BeanFactory getBeanFactory(FacesContext facesContext) {\n\t\treturn getWebApplicationContext(facesContext);\n\t}\n\n\t/**\n\t * Retrieve the web application context to delegate bean name resolution to.\n\t * <p>Default implementation delegates to FacesContextUtils.\n\t * @param facesContext the current JSF context\n\t * @return the Spring web application context (never {@code null})\n\t * @see FacesContextUtils#getRequiredWebApplicationContext\n\t */\n\tprotected WebApplicationContext getWebApplicationContext(FacesContext facesContext) {\n\t\treturn FacesContextUtils.getRequiredWebApplicationContext(facesContext);\n\t}\n\n}"
  },
  "org.springframework.web.jsf.DelegatingNavigationHandlerProxy#getBeanFactory(facesContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the Spring BeanFactory to delegate bean name resolution to.\n\t * <p>Default implementation delegates to {@code getWebApplicationContext}.\n\t * Can be overridden to provide an arbitrary BeanFactory reference to resolve\n\t * against; usually, this will be a full Spring ApplicationContext.\n\t * @param facesContext the current JSF context\n\t * @return the Spring BeanFactory (never {@code null})\n\t * @see #getWebApplicationContext\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "facesContext"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "BeanFactory",
    "signature": "protected BeanFactory getBeanFactory(FacesContext facesContext)",
    "source_code": "\tprotected BeanFactory getBeanFactory(FacesContext facesContext) {\n\t\treturn getWebApplicationContext(facesContext);\n\t}"
  },
  "org.springframework.web.jsf.DelegatingNavigationHandlerProxy#getDelegate(facesContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the target NavigationHandler to delegate to.\n\t * <p>By default, a bean with the name \"jsfNavigationHandler\" is obtained\n\t * from the Spring root WebApplicationContext, for every invocation.\n\t * @param facesContext the current JSF context\n\t * @return the target NavigationHandler to delegate to\n\t * @see #getTargetBeanName\n\t * @see #getBeanFactory\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "facesContext"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "NavigationHandler",
    "signature": "protected NavigationHandler getDelegate(FacesContext facesContext)",
    "source_code": "\tprotected NavigationHandler getDelegate(FacesContext facesContext) {\n\t\tString targetBeanName = getTargetBeanName(facesContext);\n\t\treturn getBeanFactory(facesContext).getBean(targetBeanName, NavigationHandler.class);\n\t}"
  },
  "org.springframework.web.jsf.DelegatingNavigationHandlerProxy#getTargetBeanName(facesContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the name of the target NavigationHandler bean in the BeanFactory.\n\t * Default is \"jsfNavigationHandler\".\n\t * @param facesContext the current JSF context\n\t * @return the name of the target bean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "facesContext"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "String",
    "signature": "protected String getTargetBeanName(FacesContext facesContext)",
    "source_code": "\tprotected String getTargetBeanName(FacesContext facesContext) {\n\t\treturn DEFAULT_TARGET_BEAN_NAME;\n\t}"
  },
  "org.springframework.web.jsf.DelegatingNavigationHandlerProxy#getWebApplicationContext(facesContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the web application context to delegate bean name resolution to.\n\t * <p>Default implementation delegates to FacesContextUtils.\n\t * @param facesContext the current JSF context\n\t * @return the Spring web application context (never {@code null})\n\t * @see FacesContextUtils#getRequiredWebApplicationContext\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "facesContext"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "WebApplicationContext",
    "signature": "protected WebApplicationContext getWebApplicationContext(FacesContext facesContext)",
    "source_code": "\tprotected WebApplicationContext getWebApplicationContext(FacesContext facesContext) {\n\t\treturn FacesContextUtils.getRequiredWebApplicationContext(facesContext);\n\t}"
  },
  "org.springframework.web.jsf.DelegatingNavigationHandlerProxy#handleNavigation(facesContext,fromAction,outcome)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the navigation request implied by the specified parameters,\n\t * through delegating to the target bean in the Spring application context.\n\t * <p>The target bean needs to extend the JSF NavigationHandler class.\n\t * If it extends Spring's DecoratingNavigationHandler, the overloaded\n\t * {@code handleNavigation} method with the original NavigationHandler\n\t * as argument will be used. Else, the standard {@code handleNavigation}\n\t * method will be called.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "facesContext",
      "fromAction",
      "outcome"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void handleNavigation(FacesContext facesContext, String fromAction, String outcome)",
    "source_code": "\tpublic void handleNavigation(FacesContext facesContext, String fromAction, String outcome) {\n\t\tNavigationHandler handler = getDelegate(facesContext);\n\t\tif (handler instanceof DecoratingNavigationHandler decoratingNavigationHandler) {\n\t\t\tdecoratingNavigationHandler.handleNavigation(\n\t\t\t\t\tfacesContext, fromAction, outcome, this.originalNavigationHandler);\n\t\t}\n\t\telse {\n\t\t\thandler.handleNavigation(facesContext, fromAction, outcome);\n\t\t}\n\t}"
  },
  "org.springframework.web.jsf.FacesContextUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Convenience methods to retrieve Spring's root {@link WebApplicationContext}\n * for a given JSF {@link FacesContext}. This is useful for accessing a\n * Spring application context from custom JSF-based code.\n *\n * <p>Analogous to Spring's WebApplicationContextUtils for the ServletContext.\n *\n * @author Juergen Hoeller\n * @since 1.1\n * @see org.springframework.web.context.ContextLoader\n * @see org.springframework.web.context.support.WebApplicationContextUtils\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class FacesContextUtils",
    "source_code": "public abstract class FacesContextUtils {\n\n\t/**\n\t * Find the root {@link WebApplicationContext} for this web app, typically\n\t * loaded via {@link org.springframework.web.context.ContextLoaderListener}.\n\t * <p>Will rethrow an exception that happened on root context startup,\n\t * to differentiate between a failed context startup and no context at all.\n\t * @param fc the FacesContext to find the web application context for\n\t * @return the root WebApplicationContext for this web app, or {@code null} if none\n\t * @see org.springframework.web.context.WebApplicationContext#ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE\n\t */\n\t@Nullable\n\tpublic static WebApplicationContext getWebApplicationContext(FacesContext fc) {\n\t\tAssert.notNull(fc, \"FacesContext must not be null\");\n\t\tObject attr = fc.getExternalContext().getApplicationMap().get(\n\t\t\t\tWebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);\n\t\tif (attr == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (attr instanceof RuntimeException runtimeException) {\n\t\t\tthrow runtimeException;\n\t\t}\n\t\tif (attr instanceof Error error) {\n\t\t\tthrow error;\n\t\t}\n\t\tif (!(attr instanceof WebApplicationContext wac)) {\n\t\t\tthrow new IllegalStateException(\"Root context attribute is not of type WebApplicationContext: \" + attr);\n\t\t}\n\t\treturn wac;\n\t}\n\n\t/**\n\t * Find the root {@link WebApplicationContext} for this web app, typically\n\t * loaded via {@link org.springframework.web.context.ContextLoaderListener}.\n\t * <p>Will rethrow an exception that happened on root context startup,\n\t * to differentiate between a failed context startup and no context at all.\n\t * @param fc the FacesContext to find the web application context for\n\t * @return the root WebApplicationContext for this web app\n\t * @throws IllegalStateException if the root WebApplicationContext could not be found\n\t * @see org.springframework.web.context.WebApplicationContext#ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE\n\t */\n\tpublic static WebApplicationContext getRequiredWebApplicationContext(FacesContext fc) throws IllegalStateException {\n\t\tWebApplicationContext wac = getWebApplicationContext(fc);\n\t\tif (wac == null) {\n\t\t\tthrow new IllegalStateException(\"No WebApplicationContext found: no ContextLoaderListener registered?\");\n\t\t}\n\t\treturn wac;\n\t}\n\n\t/**\n\t * Return the best available mutex for the given session:\n\t * that is, an object to synchronize on for the given session.\n\t * <p>Returns the session mutex attribute if available; usually,\n\t * this means that the HttpSessionMutexListener needs to be defined\n\t * in {@code web.xml}. Falls back to the Session reference itself\n\t * if no mutex attribute found.\n\t * <p>The session mutex is guaranteed to be the same object during\n\t * the entire lifetime of the session, available under the key defined\n\t * by the {@code SESSION_MUTEX_ATTRIBUTE} constant. It serves as a\n\t * safe reference to synchronize on for locking on the current session.\n\t * <p>In many cases, the Session reference itself is a safe mutex\n\t * as well, since it will always be the same object reference for the\n\t * same active logical session. However, this is not guaranteed across\n\t * different servlet containers; the only 100% safe way is a session mutex.\n\t * @param fc the FacesContext to find the session mutex for\n\t * @return the mutex object (never {@code null})\n\t * @see org.springframework.web.util.WebUtils#SESSION_MUTEX_ATTRIBUTE\n\t * @see org.springframework.web.util.HttpSessionMutexListener\n\t */\n\t@Nullable\n\tpublic static Object getSessionMutex(FacesContext fc) {\n\t\tAssert.notNull(fc, \"FacesContext must not be null\");\n\t\tExternalContext ec = fc.getExternalContext();\n\t\tObject mutex = ec.getSessionMap().get(WebUtils.SESSION_MUTEX_ATTRIBUTE);\n\t\tif (mutex == null) {\n\t\t\tmutex = ec.getSession(true);\n\t\t}\n\t\treturn mutex;\n\t}\n\n}"
  },
  "org.springframework.web.jsf.FacesContextUtils#getRequiredWebApplicationContext(fc)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the root {@link WebApplicationContext} for this web app, typically\n\t * loaded via {@link org.springframework.web.context.ContextLoaderListener}.\n\t * <p>Will rethrow an exception that happened on root context startup,\n\t * to differentiate between a failed context startup and no context at all.\n\t * @param fc the FacesContext to find the web application context for\n\t * @return the root WebApplicationContext for this web app\n\t * @throws IllegalStateException if the root WebApplicationContext could not be found\n\t * @see org.springframework.web.context.WebApplicationContext#ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fc"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "WebApplicationContext",
    "signature": "public WebApplicationContext getRequiredWebApplicationContext(FacesContext fc)",
    "source_code": "\tpublic static WebApplicationContext getRequiredWebApplicationContext(FacesContext fc) throws IllegalStateException {\n\t\tWebApplicationContext wac = getWebApplicationContext(fc);\n\t\tif (wac == null) {\n\t\t\tthrow new IllegalStateException(\"No WebApplicationContext found: no ContextLoaderListener registered?\");\n\t\t}\n\t\treturn wac;\n\t}"
  },
  "org.springframework.web.jsf.FacesContextUtils#getSessionMutex(fc)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the best available mutex for the given session:\n\t * that is, an object to synchronize on for the given session.\n\t * <p>Returns the session mutex attribute if available; usually,\n\t * this means that the HttpSessionMutexListener needs to be defined\n\t * in {@code web.xml}. Falls back to the Session reference itself\n\t * if no mutex attribute found.\n\t * <p>The session mutex is guaranteed to be the same object during\n\t * the entire lifetime of the session, available under the key defined\n\t * by the {@code SESSION_MUTEX_ATTRIBUTE} constant. It serves as a\n\t * safe reference to synchronize on for locking on the current session.\n\t * <p>In many cases, the Session reference itself is a safe mutex\n\t * as well, since it will always be the same object reference for the\n\t * same active logical session. However, this is not guaranteed across\n\t * different servlet containers; the only 100% safe way is a session mutex.\n\t * @param fc the FacesContext to find the session mutex for\n\t * @return the mutex object (never {@code null})\n\t * @see org.springframework.web.util.WebUtils#SESSION_MUTEX_ATTRIBUTE\n\t * @see org.springframework.web.util.HttpSessionMutexListener\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fc"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "Object",
    "signature": "public Object getSessionMutex(FacesContext fc)",
    "source_code": "\tpublic static Object getSessionMutex(FacesContext fc) {\n\t\tAssert.notNull(fc, \"FacesContext must not be null\");\n\t\tExternalContext ec = fc.getExternalContext();\n\t\tObject mutex = ec.getSessionMap().get(WebUtils.SESSION_MUTEX_ATTRIBUTE);\n\t\tif (mutex == null) {\n\t\t\tmutex = ec.getSession(true);\n\t\t}\n\t\treturn mutex;\n\t}"
  },
  "org.springframework.web.jsf.FacesContextUtils#getWebApplicationContext(fc)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the root {@link WebApplicationContext} for this web app, typically\n\t * loaded via {@link org.springframework.web.context.ContextLoaderListener}.\n\t * <p>Will rethrow an exception that happened on root context startup,\n\t * to differentiate between a failed context startup and no context at all.\n\t * @param fc the FacesContext to find the web application context for\n\t * @return the root WebApplicationContext for this web app, or {@code null} if none\n\t * @see org.springframework.web.context.WebApplicationContext#ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fc"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "return": "WebApplicationContext",
    "signature": "public WebApplicationContext getWebApplicationContext(FacesContext fc)",
    "source_code": "\tpublic static WebApplicationContext getWebApplicationContext(FacesContext fc) {\n\t\tAssert.notNull(fc, \"FacesContext must not be null\");\n\t\tObject attr = fc.getExternalContext().getApplicationMap().get(\n\t\t\t\tWebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);\n\t\tif (attr == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (attr instanceof RuntimeException runtimeException) {\n\t\t\tthrow runtimeException;\n\t\t}\n\t\tif (attr instanceof Error error) {\n\t\t\tthrow error;\n\t\t}\n\t\tif (!(attr instanceof WebApplicationContext wac)) {\n\t\t\tthrow new IllegalStateException(\"Root context attribute is not of type WebApplicationContext: \" + attr);\n\t\t}\n\t\treturn wac;\n\t}"
  },
  "org.springframework.web.method.annotation.MapMethodProcessor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Resolves {@link Map} method arguments and handles {@link Map} return values.\n *\n * <p>A Map return value can be interpreted in more than one way depending\n * on the presence of annotations like {@code @ModelAttribute} or\n * {@code @ResponseBody}. As of 5.2 this resolver returns false if the\n * parameter is annotated.\n *\n * @author Rossen Stoyanchev\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "signature": "public class MapMethodProcessor",
    "source_code": "public class MapMethodProcessor implements HandlerMethodArgumentResolver, HandlerMethodReturnValueHandler {\n\n\t@Override\n\tpublic boolean supportsParameter(MethodParameter parameter) {\n\t\treturn (Map.class.isAssignableFrom(parameter.getParameterType()) &&\n\t\t\t\tparameter.getParameterAnnotations().length == 0);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {\n\n\t\tAssert.state(mavContainer != null, \"ModelAndViewContainer is required for model exposure\");\n\t\treturn mavContainer.getModel();\n\t}\n\n\t@Override\n\tpublic boolean supportsReturnType(MethodParameter returnType) {\n\t\treturn Map.class.isAssignableFrom(returnType.getParameterType());\n\t}\n\n\t@Override\n\t@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {\n\n\t\tif (returnValue instanceof Map map) {\n\t\t\tmavContainer.addAllAttributes(map);\n\t\t}\n\t\telse if (returnValue != null) {\n\t\t\t// should not happen\n\t\t\tthrow new UnsupportedOperationException(\"Unexpected return type [\" +\n\t\t\t\t\treturnType.getParameterType().getName() + \"] in method: \" + returnType.getMethod());\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.method.annotation.MapMethodProcessor#handleReturnValue(returnValue,returnType,mavContainer,webRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "mavContainer",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "void",
    "signature": "public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest)",
    "source_code": "\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,"
  },
  "org.springframework.web.method.annotation.MapMethodProcessor#resolveArgument(parameter,mavContainer,webRequest,binderFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "mavContainer",
      "webRequest",
      "binderFactory"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "return": "Object",
    "signature": "public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)",
    "source_code": "\tpublic Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,"
  },
  "org.springframework.web.method.annotation.MapMethodProcessor#supportsParameter(parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "return": "boolean",
    "signature": "public boolean supportsParameter(MethodParameter parameter)",
    "source_code": "\tpublic boolean supportsParameter(MethodParameter parameter) {\n\t\treturn (Map.class.isAssignableFrom(parameter.getParameterType()) &&\n\t\t\t\tparameter.getParameterAnnotations().length == 0);\n\t}"
  },
  "org.springframework.web.method.annotation.MapMethodProcessor#supportsReturnType(returnType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnType"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "boolean",
    "signature": "public boolean supportsReturnType(MethodParameter returnType)",
    "source_code": "\tpublic boolean supportsReturnType(MethodParameter returnType) {\n\t\treturn Map.class.isAssignableFrom(returnType.getParameterType());\n\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Resolve {@code @ModelAttribute} annotated method arguments and handle\n * return values from {@code @ModelAttribute} annotated methods.\n *\n * <p>Model attributes are obtained from the model or created with a default\n * constructor (and then added to the model). Once created the attribute is\n * populated via data binding to Servlet request parameters. Validation may be\n * applied if the argument is annotated with {@code @jakarta.validation.Valid}.\n * or Spring's own {@code @org.springframework.validation.annotation.Validated}.\n *\n * <p>When this handler is created with {@code annotationNotRequired=true}\n * any non-simple type argument and return value is regarded as a model\n * attribute with or without the presence of an {@code @ModelAttribute}.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Sebastien Deleuze\n * @author Vladislav Kisel\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "signature": "public class ModelAttributeMethodProcessor",
    "source_code": "public class ModelAttributeMethodProcessor implements HandlerMethodArgumentResolver, HandlerMethodReturnValueHandler {\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\tprivate final boolean annotationNotRequired;\n\n\n\t/**\n\t * Class constructor.\n\t * @param annotationNotRequired if \"true\", non-simple method arguments and\n\t * return values are considered model attributes with or without a\n\t * {@code @ModelAttribute} annotation\n\t */\n\tpublic ModelAttributeMethodProcessor(boolean annotationNotRequired) {\n\t\tthis.annotationNotRequired = annotationNotRequired;\n\t}\n\n\n\t/**\n\t * Returns {@code true} if the parameter is annotated with\n\t * {@link ModelAttribute} or, if in default resolution mode, for any\n\t * method parameter that is not a simple type.\n\t */\n\t@Override\n\tpublic boolean supportsParameter(MethodParameter parameter) {\n\t\treturn (parameter.hasParameterAnnotation(ModelAttribute.class) ||\n\t\t\t\t(this.annotationNotRequired && !BeanUtils.isSimpleProperty(parameter.getParameterType())));\n\t}\n\n\t/**\n\t * Resolve the argument from the model or if not found instantiate it with\n\t * its default if it is available. The model attribute is then populated\n\t * with request values via data binding and optionally validated\n\t * if {@code @java.validation.Valid} is present on the argument.\n\t * @throws BindException if data binding and validation result in an error\n\t * and the next method parameter is not of type {@link Errors}\n\t * @throws Exception if WebDataBinder initialization fails\n\t */\n\t@Override\n\t@Nullable\n\tpublic final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {\n\n\t\tAssert.state(mavContainer != null, \"ModelAttributeMethodProcessor requires ModelAndViewContainer\");\n\t\tAssert.state(binderFactory != null, \"ModelAttributeMethodProcessor requires WebDataBinderFactory\");\n\n\t\tString name = ModelFactory.getNameForParameter(parameter);\n\t\tModelAttribute ann = parameter.getParameterAnnotation(ModelAttribute.class);\n\t\tif (ann != null) {\n\t\t\tmavContainer.setBinding(name, ann.binding());\n\t\t}\n\n\t\tObject attribute = null;\n\t\tBindingResult bindingResult = null;\n\n\t\tif (mavContainer.containsAttribute(name)) {\n\t\t\tattribute = mavContainer.getModel().get(name);\n\t\t}\n\t\telse {\n\t\t\t// Create attribute instance\n\t\t\ttry {\n\t\t\t\tattribute = createAttribute(name, parameter, binderFactory, webRequest);\n\t\t\t}\n\t\t\tcatch (MethodArgumentNotValidException ex) {\n\t\t\t\tif (isBindExceptionRequired(parameter)) {\n\t\t\t\t\t// No BindingResult parameter -> fail with BindException\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\t// Otherwise, expose null/empty value and associated BindingResult\n\t\t\t\tif (parameter.getParameterType() == Optional.class) {\n\t\t\t\t\tattribute = Optional.empty();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tattribute = ex.getTarget();\n\t\t\t\t}\n\t\t\t\tbindingResult = ex.getBindingResult();\n\t\t\t}\n\t\t}\n\n\t\tif (bindingResult == null) {\n\t\t\t// Bean property binding and validation;\n\t\t\t// skipped in case of binding failure on construction.\n\t\t\tWebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);\n\t\t\tif (binder.getTarget() != null) {\n\t\t\t\tif (!mavContainer.isBindingDisabled(name)) {\n\t\t\t\t\tbindRequestParameters(binder, webRequest);\n\t\t\t\t}\n\t\t\t\tvalidateIfApplicable(binder, parameter);\n\t\t\t\tif (binder.getBindingResult().hasErrors() && isBindExceptionRequired(binder, parameter)) {\n\t\t\t\t\tthrow new BindException(binder.getBindingResult());\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Value type adaptation, also covering java.util.Optional\n\t\t\tif (!parameter.getParameterType().isInstance(attribute)) {\n\t\t\t\tattribute = binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);\n\t\t\t}\n\t\t\tbindingResult = binder.getBindingResult();\n\t\t}\n\n\t\t// Add resolved attribute and BindingResult at the end of the model\n\t\tMap<String, Object> bindingResultModel = bindingResult.getModel();\n\t\tmavContainer.removeAttributes(bindingResultModel);\n\t\tmavContainer.addAllAttributes(bindingResultModel);\n\n\t\treturn attribute;\n\t}\n\n\t/**\n\t * Extension point to create the model attribute if not found in the model,\n\t * with subsequent parameter binding through bean properties (unless suppressed).\n\t * <p>The default implementation typically uses the unique public no-arg constructor\n\t * if available but also handles a \"primary constructor\" approach for data classes:\n\t * It understands the JavaBeans {@code ConstructorProperties} annotation as well as\n\t * runtime-retained parameter names in the bytecode, associating request parameters\n\t * with constructor arguments by name. If no such constructor is found, the default\n\t * constructor will be used (even if not public), assuming subsequent bean property\n\t * bindings through setter methods.\n\t * @param attributeName the name of the attribute (never {@code null})\n\t * @param parameter the method parameter declaration\n\t * @param binderFactory for creating WebDataBinder instance\n\t * @param webRequest the current request\n\t * @return the created model attribute (never {@code null})\n\t * @throws BindException in case of constructor argument binding failure\n\t * @throws Exception in case of constructor invocation failure\n\t * @see #constructAttribute(Constructor, String, MethodParameter, WebDataBinderFactory, NativeWebRequest)\n\t * @see BeanUtils#findPrimaryConstructor(Class)\n\t */\n\tprotected Object createAttribute(String attributeName, MethodParameter parameter,\n\t\t\tWebDataBinderFactory binderFactory, NativeWebRequest webRequest) throws Exception {\n\n\t\tMethodParameter nestedParameter = parameter.nestedIfOptional();\n\t\tClass<?> clazz = nestedParameter.getNestedParameterType();\n\n\t\tConstructor<?> ctor = BeanUtils.getResolvableConstructor(clazz);\n\t\tObject attribute = constructAttribute(ctor, attributeName, parameter, binderFactory, webRequest);\n\t\tif (parameter != nestedParameter) {\n\t\t\tattribute = Optional.of(attribute);\n\t\t}\n\t\treturn attribute;\n\t}\n\n\t/**\n\t * Construct a new attribute instance with the given constructor.\n\t * <p>Called from\n\t * {@link #createAttribute(String, MethodParameter, WebDataBinderFactory, NativeWebRequest)}\n\t * after constructor resolution.\n\t * @param ctor the constructor to use\n\t * @param attributeName the name of the attribute (never {@code null})\n\t * @param binderFactory for creating WebDataBinder instance\n\t * @param webRequest the current request\n\t * @return the created model attribute (never {@code null})\n\t * @throws BindException in case of constructor argument binding failure\n\t * @throws Exception in case of constructor invocation failure\n\t * @since 5.1\n\t */\n\t@SuppressWarnings(\"serial\")\n\tprotected Object constructAttribute(Constructor<?> ctor, String attributeName, MethodParameter parameter,\n\t\t\tWebDataBinderFactory binderFactory, NativeWebRequest webRequest) throws Exception {\n\n\t\tif (ctor.getParameterCount() == 0) {\n\t\t\t// A single default constructor -> clearly a standard JavaBeans arrangement.\n\t\t\treturn BeanUtils.instantiateClass(ctor);\n\t\t}\n\n\t\t// A single data class constructor -> resolve constructor arguments from request parameters.\n\t\tString[] paramNames = BeanUtils.getParameterNames(ctor);\n\t\tClass<?>[] paramTypes = ctor.getParameterTypes();\n\t\tObject[] args = new Object[paramTypes.length];\n\t\tWebDataBinder binder = binderFactory.createBinder(webRequest, null, attributeName);\n\t\tString fieldDefaultPrefix = binder.getFieldDefaultPrefix();\n\t\tString fieldMarkerPrefix = binder.getFieldMarkerPrefix();\n\t\tboolean bindingFailure = false;\n\t\tSet<String> failedParams = new HashSet<>(4);\n\n\t\tfor (int i = 0; i < paramNames.length; i++) {\n\t\t\tString paramName = paramNames[i];\n\t\t\tClass<?> paramType = paramTypes[i];\n\t\t\tObject value = webRequest.getParameterValues(paramName);\n\n\t\t\t// Since WebRequest#getParameter exposes a single-value parameter as an array\n\t\t\t// with a single element, we unwrap the single value in such cases, analogous\n\t\t\t// to WebExchangeDataBinder.addBindValue(Map<String, Object>, String, List<?>).\n\t\t\tif (ObjectUtils.isArray(value) && Array.getLength(value) == 1) {\n\t\t\t\tvalue = Array.get(value, 0);\n\t\t\t}\n\n\t\t\tif (value == null) {\n\t\t\t\tif (fieldDefaultPrefix != null) {\n\t\t\t\t\tvalue = webRequest.getParameter(fieldDefaultPrefix + paramName);\n\t\t\t\t}\n\t\t\t\tif (value == null) {\n\t\t\t\t\tif (fieldMarkerPrefix != null && webRequest.getParameter(fieldMarkerPrefix + paramName) != null) {\n\t\t\t\t\t\tvalue = binder.getEmptyValue(paramType);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvalue = resolveConstructorArgument(paramName, paramType, webRequest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tMethodParameter methodParam = new FieldAwareConstructorParameter(ctor, i, paramName);\n\t\t\t\tif (value == null && methodParam.isOptional()) {\n\t\t\t\t\targs[i] = (methodParam.getParameterType() == Optional.class ? Optional.empty() : null);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\targs[i] = binder.convertIfNecessary(value, paramType, methodParam);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tex.initPropertyName(paramName);\n\t\t\t\targs[i] = null;\n\t\t\t\tfailedParams.add(paramName);\n\t\t\t\tbinder.getBindingResult().recordFieldValue(paramName, paramType, value);\n\t\t\t\tbinder.getBindingErrorProcessor().processPropertyAccessException(ex, binder.getBindingResult());\n\t\t\t\tbindingFailure = true;\n\t\t\t}\n\t\t}\n\n\t\tif (bindingFailure) {\n\t\t\tBindingResult result = binder.getBindingResult();\n\t\t\tfor (int i = 0; i < paramNames.length; i++) {\n\t\t\t\tString paramName = paramNames[i];\n\t\t\t\tif (!failedParams.contains(paramName)) {\n\t\t\t\t\tObject value = args[i];\n\t\t\t\t\tresult.recordFieldValue(paramName, paramTypes[i], value);\n\t\t\t\t\tvalidateValueIfApplicable(binder, parameter, ctor.getDeclaringClass(), paramName, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!parameter.isOptional()) {\n\t\t\t\ttry {\n\t\t\t\t\tObject target = BeanUtils.instantiateClass(ctor, args);\n\t\t\t\t\tthrow new MethodArgumentNotValidException(parameter, result) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic Object getTarget() {\n\t\t\t\t\t\t\treturn target;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcatch (BeanInstantiationException ex) {\n\t\t\t\t\t// swallow and proceed without target instance\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new MethodArgumentNotValidException(parameter, result);\n\t\t}\n\n\t\treturn BeanUtils.instantiateClass(ctor, args);\n\t}\n\n\t/**\n\t * Extension point to bind the request to the target object.\n\t * @param binder the data binder instance to use for the binding\n\t * @param request the current request\n\t */\n\tprotected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) {\n\t\t((WebRequestDataBinder) binder).bind(request);\n\t}\n\n\t@Nullable\n\tpublic Object resolveConstructorArgument(String paramName, Class<?> paramType, NativeWebRequest request)\n\t\t\tthrows Exception {\n\n\t\tMultipartRequest multipartRequest = request.getNativeRequest(MultipartRequest.class);\n\t\tif (multipartRequest != null) {\n\t\t\tList<MultipartFile> files = multipartRequest.getFiles(paramName);\n\t\t\tif (!files.isEmpty()) {\n\t\t\t\treturn (files.size() == 1 ? files.get(0) : files);\n\t\t\t}\n\t\t}\n\t\telse if (StringUtils.startsWithIgnoreCase(\n\t\t\t\trequest.getHeader(HttpHeaders.CONTENT_TYPE), MediaType.MULTIPART_FORM_DATA_VALUE)) {\n\t\t\tHttpServletRequest servletRequest = request.getNativeRequest(HttpServletRequest.class);\n\t\t\tif (servletRequest != null && HttpMethod.POST.matches(servletRequest.getMethod())) {\n\t\t\t\tList<Part> parts = StandardServletPartUtils.getParts(servletRequest, paramName);\n\t\t\t\tif (!parts.isEmpty()) {\n\t\t\t\t\treturn (parts.size() == 1 ? parts.get(0) : parts);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Validate the model attribute if applicable.\n\t * <p>The default implementation checks for {@code @jakarta.validation.Valid},\n\t * Spring's {@link org.springframework.validation.annotation.Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param binder the DataBinder to be used\n\t * @param parameter the method parameter declaration\n\t * @see WebDataBinder#validate(Object...)\n\t * @see SmartValidator#validate(Object, Errors, Object...)\n\t */\n\tprotected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter) {\n\t\tfor (Annotation ann : parameter.getParameterAnnotations()) {\n\t\t\tObject[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);\n\t\t\tif (validationHints != null) {\n\t\t\t\tbinder.validate(validationHints);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Validate the specified candidate value if applicable.\n\t * <p>The default implementation checks for {@code @jakarta.validation.Valid},\n\t * Spring's {@link org.springframework.validation.annotation.Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param binder the DataBinder to be used\n\t * @param parameter the method parameter declaration\n\t * @param targetType the target type\n\t * @param fieldName the name of the field\n\t * @param value the candidate value\n\t * @since 5.1\n\t * @see #validateIfApplicable(WebDataBinder, MethodParameter)\n\t * @see SmartValidator#validateValue(Class, String, Object, Errors, Object...)\n\t */\n\tprotected void validateValueIfApplicable(WebDataBinder binder, MethodParameter parameter,\n\t\t\tClass<?> targetType, String fieldName, @Nullable Object value) {\n\n\t\tfor (Annotation ann : parameter.getParameterAnnotations()) {\n\t\t\tObject[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);\n\t\t\tif (validationHints != null) {\n\t\t\t\tfor (Validator validator : binder.getValidators()) {\n\t\t\t\t\tif (validator instanceof SmartValidator smartValidator) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tsmartValidator.validateValue(targetType, fieldName, value,\n\t\t\t\t\t\t\t\t\tbinder.getBindingResult(), validationHints);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\t\t\t// No corresponding field on the target class...\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Whether to raise a fatal bind exception on validation errors.\n\t * <p>The default implementation delegates to {@link #isBindExceptionRequired(MethodParameter)}.\n\t * @param binder the data binder used to perform data binding\n\t * @param parameter the method parameter declaration\n\t * @return {@code true} if the next method parameter is not of type {@link Errors}\n\t * @see #isBindExceptionRequired(MethodParameter)\n\t */\n\tprotected boolean isBindExceptionRequired(WebDataBinder binder, MethodParameter parameter) {\n\t\treturn isBindExceptionRequired(parameter);\n\t}\n\n\t/**\n\t * Whether to raise a fatal bind exception on validation errors.\n\t * @param parameter the method parameter declaration\n\t * @return {@code true} if the next method parameter is not of type {@link Errors}\n\t * @since 5.0\n\t */\n\tprotected boolean isBindExceptionRequired(MethodParameter parameter) {\n\t\tint i = parameter.getParameterIndex();\n\t\tClass<?>[] paramTypes = parameter.getExecutable().getParameterTypes();\n\t\tboolean hasBindingResult = (paramTypes.length > (i + 1) && Errors.class.isAssignableFrom(paramTypes[i + 1]));\n\t\treturn !hasBindingResult;\n\t}\n\n\t/**\n\t * Return {@code true} if there is a method-level {@code @ModelAttribute}\n\t * or, in default resolution mode, for any return value type that is not\n\t * a simple type.\n\t */\n\t@Override\n\tpublic boolean supportsReturnType(MethodParameter returnType) {\n\t\treturn (returnType.hasMethodAnnotation(ModelAttribute.class) ||\n\t\t\t\t(this.annotationNotRequired && !BeanUtils.isSimpleProperty(returnType.getParameterType())));\n\t}\n\n\t/**\n\t * Add non-null return values to the {@link ModelAndViewContainer}.\n\t */\n\t@Override\n\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {\n\n\t\tif (returnValue != null) {\n\t\t\tString name = ModelFactory.getNameForReturnValue(returnValue, returnType);\n\t\t\tmavContainer.addAttribute(name, returnValue);\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link MethodParameter} subclass which detects field annotations as well.\n\t * @since 5.1\n\t */\n\tprivate static class FieldAwareConstructorParameter extends MethodParameter {\n\n\t\tprivate final String parameterName;\n\n\t\t@Nullable\n\t\tprivate volatile Annotation[] combinedAnnotations;\n\n\t\tpublic FieldAwareConstructorParameter(Constructor<?> constructor, int parameterIndex, String parameterName) {\n\t\t\tsuper(constructor, parameterIndex);\n\t\t\tthis.parameterName = parameterName;\n\t\t}\n\n\t\t@Override\n\t\tpublic Annotation[] getParameterAnnotations() {\n\t\t\tAnnotation[] anns = this.combinedAnnotations;\n\t\t\tif (anns == null) {\n\t\t\t\tanns = super.getParameterAnnotations();\n\t\t\t\ttry {\n\t\t\t\t\tField field = getDeclaringClass().getDeclaredField(this.parameterName);\n\t\t\t\t\tAnnotation[] fieldAnns = field.getAnnotations();\n\t\t\t\t\tif (fieldAnns.length > 0) {\n\t\t\t\t\t\tList<Annotation> merged = new ArrayList<>(anns.length + fieldAnns.length);\n\t\t\t\t\t\tmerged.addAll(Arrays.asList(anns));\n\t\t\t\t\t\tfor (Annotation fieldAnn : fieldAnns) {\n\t\t\t\t\t\t\tboolean existingType = false;\n\t\t\t\t\t\t\tfor (Annotation ann : anns) {\n\t\t\t\t\t\t\t\tif (ann.annotationType() == fieldAnn.annotationType()) {\n\t\t\t\t\t\t\t\t\texistingType = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!existingType) {\n\t\t\t\t\t\t\t\tmerged.add(fieldAnn);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tanns = merged.toArray(new Annotation[0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchFieldException | SecurityException ex) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t\tthis.combinedAnnotations = anns;\n\t\t\t}\n\t\t\treturn anns;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getParameterName() {\n\t\t\treturn this.parameterName;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#bindRequestParameters(binder,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extension point to bind the request to the target object.\n\t * @param binder the data binder instance to use for the binding\n\t * @param request the current request\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 340
    },
    "return": "void",
    "signature": "protected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request)",
    "source_code": "\tprotected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) {\n\t\t((WebRequestDataBinder) binder).bind(request);\n\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#constructAttribute(ctor,attributeName,parameter,binderFactory,webRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Construct a new attribute instance with the given constructor.\n\t * <p>Called from\n\t * {@link #createAttribute(String, MethodParameter, WebDataBinderFactory, NativeWebRequest)}\n\t * after constructor resolution.\n\t * @param ctor the constructor to use\n\t * @param attributeName the name of the attribute (never {@code null})\n\t * @param binderFactory for creating WebDataBinder instance\n\t * @param webRequest the current request\n\t * @return the created model attribute (never {@code null})\n\t * @throws BindException in case of constructor argument binding failure\n\t * @throws Exception in case of constructor invocation failure\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ctor",
      "attributeName",
      "parameter",
      "binderFactory",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "Object",
    "signature": "protected Object constructAttribute(Constructor<?> ctor, String attributeName, MethodParameter parameter,\n\t\t\tWebDataBinderFactory binderFactory, NativeWebRequest webRequest)",
    "source_code": "\tprotected Object constructAttribute(Constructor<?> ctor, String attributeName, MethodParameter parameter,"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#createAttribute(attributeName,parameter,binderFactory,webRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extension point to create the model attribute if not found in the model,\n\t * with subsequent parameter binding through bean properties (unless suppressed).\n\t * <p>The default implementation typically uses the unique public no-arg constructor\n\t * if available but also handles a \"primary constructor\" approach for data classes:\n\t * It understands the JavaBeans {@code ConstructorProperties} annotation as well as\n\t * runtime-retained parameter names in the bytecode, associating request parameters\n\t * with constructor arguments by name. If no such constructor is found, the default\n\t * constructor will be used (even if not public), assuming subsequent bean property\n\t * bindings through setter methods.\n\t * @param attributeName the name of the attribute (never {@code null})\n\t * @param parameter the method parameter declaration\n\t * @param binderFactory for creating WebDataBinder instance\n\t * @param webRequest the current request\n\t * @return the created model attribute (never {@code null})\n\t * @throws BindException in case of constructor argument binding failure\n\t * @throws Exception in case of constructor invocation failure\n\t * @see #constructAttribute(Constructor, String, MethodParameter, WebDataBinderFactory, NativeWebRequest)\n\t * @see BeanUtils#findPrimaryConstructor(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "attributeName",
      "parameter",
      "binderFactory",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "Object",
    "signature": "protected Object createAttribute(String attributeName, MethodParameter parameter,\n\t\t\tWebDataBinderFactory binderFactory, NativeWebRequest webRequest)",
    "source_code": "\tprotected Object createAttribute(String attributeName, MethodParameter parameter,"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#getParameterAnnotations()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 491
    },
    "return": "Annotation[]",
    "signature": "public Annotation[] getParameterAnnotations()",
    "source_code": "\t\tpublic Annotation[] getParameterAnnotations() {\n\t\t\tAnnotation[] anns = this.combinedAnnotations;\n\t\t\tif (anns == null) {\n\t\t\t\tanns = super.getParameterAnnotations();\n\t\t\t\ttry {\n\t\t\t\t\tField field = getDeclaringClass().getDeclaredField(this.parameterName);\n\t\t\t\t\tAnnotation[] fieldAnns = field.getAnnotations();\n\t\t\t\t\tif (fieldAnns.length > 0) {\n\t\t\t\t\t\tList<Annotation> merged = new ArrayList<>(anns.length + fieldAnns.length);\n\t\t\t\t\t\tmerged.addAll(Arrays.asList(anns));\n\t\t\t\t\t\tfor (Annotation fieldAnn : fieldAnns) {\n\t\t\t\t\t\t\tboolean existingType = false;\n\t\t\t\t\t\t\tfor (Annotation ann : anns) {\n\t\t\t\t\t\t\t\tif (ann.annotationType() == fieldAnn.annotationType()) {\n\t\t\t\t\t\t\t\t\texistingType = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!existingType) {\n\t\t\t\t\t\t\t\tmerged.add(fieldAnn);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tanns = merged.toArray(new Annotation[0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchFieldException | SecurityException ex) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t\tthis.combinedAnnotations = anns;\n\t\t\t}\n\t\t\treturn anns;\n\t\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#getParameterName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 525
    },
    "return": "String",
    "signature": "public String getParameterName()",
    "source_code": "\t\tpublic String getParameterName() {\n\t\t\treturn this.parameterName;\n\t\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#getTarget()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 320
    },
    "return": "Object",
    "signature": "public Object getTarget()",
    "source_code": "\t\t\t\t\t\tpublic Object getTarget() {\n\t\t\t\t\t\t\treturn target;\n\t\t\t\t\t\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#handleReturnValue(returnValue,returnType,mavContainer,webRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add non-null return values to the {@link ModelAndViewContainer}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "mavContainer",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 464
    },
    "return": "void",
    "signature": "public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest)",
    "source_code": "\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#isBindExceptionRequired(binder,parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to raise a fatal bind exception on validation errors.\n\t * <p>The default implementation delegates to {@link #isBindExceptionRequired(MethodParameter)}.\n\t * @param binder the data binder used to perform data binding\n\t * @param parameter the method parameter declaration\n\t * @return {@code true} if the next method parameter is not of type {@link Errors}\n\t * @see #isBindExceptionRequired(MethodParameter)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 432
    },
    "return": "boolean",
    "signature": "protected boolean isBindExceptionRequired(WebDataBinder binder, MethodParameter parameter)",
    "source_code": "\tprotected boolean isBindExceptionRequired(WebDataBinder binder, MethodParameter parameter) {\n\t\treturn isBindExceptionRequired(parameter);\n\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#isBindExceptionRequired(parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to raise a fatal bind exception on validation errors.\n\t * @param parameter the method parameter declaration\n\t * @return {@code true} if the next method parameter is not of type {@link Errors}\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 442
    },
    "return": "boolean",
    "signature": "protected boolean isBindExceptionRequired(MethodParameter parameter)",
    "source_code": "\tprotected boolean isBindExceptionRequired(MethodParameter parameter) {\n\t\tint i = parameter.getParameterIndex();\n\t\tClass<?>[] paramTypes = parameter.getExecutable().getParameterTypes();\n\t\tboolean hasBindingResult = (paramTypes.length > (i + 1) && Errors.class.isAssignableFrom(paramTypes[i + 1]));\n\t\treturn !hasBindingResult;\n\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#resolveArgument(parameter,mavContainer,webRequest,binderFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the argument from the model or if not found instantiate it with\n\t * its default if it is available. The model attribute is then populated\n\t * with request values via data binding and optionally validated\n\t * if {@code @java.validation.Valid} is present on the argument.\n\t * @throws BindException if data binding and validation result in an error\n\t * and the next method parameter is not of type {@link Errors}\n\t * @throws Exception if WebDataBinder initialization fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "mavContainer",
      "webRequest",
      "binderFactory"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "Object",
    "signature": "public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)",
    "source_code": "\tpublic final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#resolveConstructorArgument(paramName,paramType,request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName",
      "paramType",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 345
    },
    "return": "Object",
    "signature": "public Object resolveConstructorArgument(String paramName, Class<?> paramType, NativeWebRequest request)",
    "source_code": "\tpublic Object resolveConstructorArgument(String paramName, Class<?> paramType, NativeWebRequest request)"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#supportsParameter(parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns {@code true} if the parameter is annotated with\n\t * {@link ModelAttribute} or, if in default resolution mode, for any\n\t * method parameter that is not a simple type.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "boolean",
    "signature": "public boolean supportsParameter(MethodParameter parameter)",
    "source_code": "\tpublic boolean supportsParameter(MethodParameter parameter) {\n\t\treturn (parameter.hasParameterAnnotation(ModelAttribute.class) ||\n\t\t\t\t(this.annotationNotRequired && !BeanUtils.isSimpleProperty(parameter.getParameterType())));\n\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#supportsReturnType(returnType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return {@code true} if there is a method-level {@code @ModelAttribute}\n\t * or, in default resolution mode, for any return value type that is not\n\t * a simple type.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnType"
    ],
    "position": {
      "column": 1,
      "line": 455
    },
    "return": "boolean",
    "signature": "public boolean supportsReturnType(MethodParameter returnType)",
    "source_code": "\tpublic boolean supportsReturnType(MethodParameter returnType) {\n\t\treturn (returnType.hasMethodAnnotation(ModelAttribute.class) ||\n\t\t\t\t(this.annotationNotRequired && !BeanUtils.isSimpleProperty(returnType.getParameterType())));\n\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#validateIfApplicable(binder,parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Validate the model attribute if applicable.\n\t * <p>The default implementation checks for {@code @jakarta.validation.Valid},\n\t * Spring's {@link org.springframework.validation.annotation.Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param binder the DataBinder to be used\n\t * @param parameter the method parameter declaration\n\t * @see WebDataBinder#validate(Object...)\n\t * @see SmartValidator#validate(Object, Errors, Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 378
    },
    "return": "void",
    "signature": "protected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter)",
    "source_code": "\tprotected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter) {\n\t\tfor (Annotation ann : parameter.getParameterAnnotations()) {\n\t\t\tObject[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);\n\t\t\tif (validationHints != null) {\n\t\t\t\tbinder.validate(validationHints);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#validateValueIfApplicable(binder,parameter,targetType,fieldName,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Validate the specified candidate value if applicable.\n\t * <p>The default implementation checks for {@code @jakarta.validation.Valid},\n\t * Spring's {@link org.springframework.validation.annotation.Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param binder the DataBinder to be used\n\t * @param parameter the method parameter declaration\n\t * @param targetType the target type\n\t * @param fieldName the name of the field\n\t * @param value the candidate value\n\t * @since 5.1\n\t * @see #validateIfApplicable(WebDataBinder, MethodParameter)\n\t * @see SmartValidator#validateValue(Class, String, Object, Errors, Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "parameter",
      "targetType",
      "fieldName",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 402
    },
    "return": "void",
    "signature": "protected void validateValueIfApplicable(WebDataBinder binder, MethodParameter parameter,\n\t\t\tClass<?> targetType, String fieldName, @Nullable Object value)",
    "source_code": "\tprotected void validateValueIfApplicable(WebDataBinder binder, MethodParameter parameter,"
  },
  "org.springframework.web.method.annotation.ModelMethodProcessor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Resolves {@link Model} arguments and handles {@link Model} return values.\n *\n * <p>A {@link Model} return type has a set purpose. Therefore this handler\n * should be configured ahead of handlers that support any return value type\n * annotated with {@code @ModelAttribute} or {@code @ResponseBody} to ensure\n * they don't take over.\n *\n * @author Rossen Stoyanchev\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 40
    },
    "signature": "public class ModelMethodProcessor",
    "source_code": "public class ModelMethodProcessor implements HandlerMethodArgumentResolver, HandlerMethodReturnValueHandler {\n\n\t@Override\n\tpublic boolean supportsParameter(MethodParameter parameter) {\n\t\treturn Model.class.isAssignableFrom(parameter.getParameterType());\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {\n\n\t\tAssert.state(mavContainer != null, \"ModelAndViewContainer is required for model exposure\");\n\t\treturn mavContainer.getModel();\n\t}\n\n\t@Override\n\tpublic boolean supportsReturnType(MethodParameter returnType) {\n\t\treturn Model.class.isAssignableFrom(returnType.getParameterType());\n\t}\n\n\t@Override\n\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {\n\n\t\tif (returnValue == null) {\n\t\t\treturn;\n\t\t}\n\t\telse if (returnValue instanceof Model model) {\n\t\t\tmavContainer.addAllAttributes(model.asMap());\n\t\t}\n\t\telse {\n\t\t\t// should not happen\n\t\t\tthrow new UnsupportedOperationException(\"Unexpected return type [\" +\n\t\t\t\t\treturnType.getParameterType().getName() + \"] in method: \" + returnType.getMethod());\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.method.annotation.ModelMethodProcessor#handleReturnValue(returnValue,returnType,mavContainer,webRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "mavContainer",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "void",
    "signature": "public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest)",
    "source_code": "\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,"
  },
  "org.springframework.web.method.annotation.ModelMethodProcessor#resolveArgument(parameter,mavContainer,webRequest,binderFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "mavContainer",
      "webRequest",
      "binderFactory"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "return": "Object",
    "signature": "public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)",
    "source_code": "\tpublic Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,"
  },
  "org.springframework.web.method.annotation.ModelMethodProcessor#supportsParameter(parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "return": "boolean",
    "signature": "public boolean supportsParameter(MethodParameter parameter)",
    "source_code": "\tpublic boolean supportsParameter(MethodParameter parameter) {\n\t\treturn Model.class.isAssignableFrom(parameter.getParameterType());\n\t}"
  },
  "org.springframework.web.method.annotation.ModelMethodProcessor#supportsReturnType(returnType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnType"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "boolean",
    "signature": "public boolean supportsReturnType(MethodParameter returnType)",
    "source_code": "\tpublic boolean supportsReturnType(MethodParameter returnType) {\n\t\treturn Model.class.isAssignableFrom(returnType.getParameterType());\n\t}"
  },
  "org.springframework.web.method.annotation.RequestParamMethodArgumentResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Resolves method arguments annotated with @{@link RequestParam}, arguments of\n * type {@link MultipartFile} in conjunction with Spring's {@link MultipartResolver}\n * abstraction, and arguments of type {@code jakarta.servlet.http.Part} in conjunction\n * with Servlet multipart requests. This resolver can also be created in default\n * resolution mode in which simple types (int, long, etc.) not annotated with\n * {@link RequestParam @RequestParam} are also treated as request parameters with\n * the parameter name derived from the argument name.\n *\n * <p>If the method parameter type is {@link Map}, the name specified in the\n * annotation is used to resolve the request parameter String value. The value is\n * then converted to a {@link Map} via type conversion assuming a suitable\n * {@link Converter} or {@link PropertyEditor} has been registered.\n * Or if a request parameter name is not specified the\n * {@link RequestParamMapMethodArgumentResolver} is used instead to provide\n * access to all request parameters in the form of a map.\n *\n * <p>A {@link WebDataBinder} is invoked to apply type conversion to resolved request\n * header values that don't yet match the method parameter type.\n *\n * @author Arjen Poutsma\n * @author Rossen Stoyanchev\n * @author Brian Clozel\n * @since 3.1\n * @see RequestParamMapMethodArgumentResolver\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "signature": "public class RequestParamMethodArgumentResolver",
    "source_code": "public class RequestParamMethodArgumentResolver extends AbstractNamedValueMethodArgumentResolver"
  },
  "org.springframework.web.method.annotation.RequestParamMethodArgumentResolver#contributeMethodArgument(parameter,value,builder,Map<String,uriVariables,conversionService)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "value",
      "builder",
      "Map<String",
      "uriVariables",
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "void",
    "signature": "public void contributeMethodArgument(MethodParameter parameter, @Nullable Object value,\n\t\t\tUriComponentsBuilder builder, Map<String, Object> uriVariables, ConversionService conversionService)",
    "source_code": "\tpublic void contributeMethodArgument(MethodParameter parameter, @Nullable Object value,"
  },
  "org.springframework.web.method.annotation.RequestParamMethodArgumentResolver#createNamedValueInfo(parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "NamedValueInfo",
    "signature": "protected NamedValueInfo createNamedValueInfo(MethodParameter parameter)",
    "source_code": "\tprotected NamedValueInfo createNamedValueInfo(MethodParameter parameter) {\n\t\tRequestParam ann = parameter.getParameterAnnotation(RequestParam.class);\n\t\treturn (ann != null ? new RequestParamNamedValueInfo(ann) : new RequestParamNamedValueInfo());\n\t}"
  },
  "org.springframework.web.method.annotation.RequestParamMethodArgumentResolver#formatUriValue(cs,sourceType,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "cs",
      "sourceType",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "String",
    "signature": "protected String formatUriValue(@Nullable ConversionService cs, @Nullable TypeDescriptor sourceType, @Nullable Object value)",
    "source_code": "\tprotected String formatUriValue("
  },
  "org.springframework.web.method.annotation.RequestParamMethodArgumentResolver#handleMissingValue(name,parameter,request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "void",
    "signature": "protected void handleMissingValue(String name, MethodParameter parameter, NativeWebRequest request)",
    "source_code": "\tprotected void handleMissingValue(String name, MethodParameter parameter, NativeWebRequest request)"
  },
  "org.springframework.web.method.annotation.RequestParamMethodArgumentResolver#handleMissingValueAfterConversion(name,parameter,request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 197
    },
    "return": "void",
    "signature": "protected void handleMissingValueAfterConversion(String name, MethodParameter parameter, NativeWebRequest request)",
    "source_code": "\tprotected void handleMissingValueAfterConversion("
  },
  "org.springframework.web.method.annotation.RequestParamMethodArgumentResolver#handleMissingValueInternal(name,parameter,request,missingAfterConversion)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "request",
      "missingAfterConversion"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "void",
    "signature": "protected void handleMissingValueInternal(String name, MethodParameter parameter, NativeWebRequest request, boolean missingAfterConversion)",
    "source_code": "\tprotected void handleMissingValueInternal("
  },
  "org.springframework.web.method.annotation.RequestParamMethodArgumentResolver#resolveName(name,parameter,request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "Object",
    "signature": "protected Object resolveName(String name, MethodParameter parameter, NativeWebRequest request)",
    "source_code": "\tprotected Object resolveName(String name, MethodParameter parameter, NativeWebRequest request) throws Exception {\n\t\tHttpServletRequest servletRequest = request.getNativeRequest(HttpServletRequest.class);\n\n\t\tif (servletRequest != null) {\n\t\t\tObject mpArg = MultipartResolutionDelegate.resolveMultipartArgument(name, parameter, servletRequest);\n\t\t\tif (mpArg != MultipartResolutionDelegate.UNRESOLVABLE) {\n\t\t\t\treturn mpArg;\n\t\t\t}\n\t\t}\n\n\t\tObject arg = null;\n\t\tMultipartRequest multipartRequest = request.getNativeRequest(MultipartRequest.class);\n\t\tif (multipartRequest != null) {\n\t\t\tList<MultipartFile> files = multipartRequest.getFiles(name);\n\t\t\tif (!files.isEmpty()) {\n\t\t\t\targ = (files.size() == 1 ? files.get(0) : files);\n\t\t\t}\n\t\t}\n\t\tif (arg == null) {\n\t\t\tString[] paramValues = request.getParameterValues(name);\n\t\t\tif (paramValues != null) {\n\t\t\t\targ = (paramValues.length == 1 ? paramValues[0] : paramValues);\n\t\t\t}\n\t\t}\n\t\treturn arg;\n\t}"
  },
  "org.springframework.web.method.annotation.RequestParamMethodArgumentResolver#supportsParameter(parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Supports the following:\n\t * <ul>\n\t * <li>@RequestParam-annotated method arguments.\n\t * This excludes {@link Map} params where the annotation does not specify a name.\n\t * See {@link RequestParamMapMethodArgumentResolver} instead for such params.\n\t * <li>Arguments of type {@link MultipartFile} unless annotated with @{@link RequestPart}.\n\t * <li>Arguments of type {@code Part} unless annotated with @{@link RequestPart}.\n\t * <li>In default resolution mode, simple type arguments even if not with @{@link RequestParam}.\n\t * </ul>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "boolean",
    "signature": "public boolean supportsParameter(MethodParameter parameter)",
    "source_code": "\tpublic boolean supportsParameter(MethodParameter parameter) {\n\t\tif (parameter.hasParameterAnnotation(RequestParam.class)) {\n\t\t\tif (Map.class.isAssignableFrom(parameter.nestedIfOptional().getNestedParameterType())) {\n\t\t\t\tRequestParam requestParam = parameter.getParameterAnnotation(RequestParam.class);\n\t\t\t\treturn (requestParam != null && StringUtils.hasText(requestParam.name()));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (parameter.hasParameterAnnotation(RequestPart.class)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tparameter = parameter.nestedIfOptional();\n\t\t\tif (MultipartResolutionDelegate.isMultipartArgument(parameter)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (this.useDefaultResolution) {\n\t\t\t\treturn BeanUtils.isSimpleProperty(parameter.getNestedParameterType());\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.logger": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Handles method return values by delegating to a list of registered\n * {@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers}.\n * Previously resolved return types are cached for faster lookups.\n *\n * @author Rossen Stoyanchev\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 35
    },
    "signature": "public class HandlerMethodReturnValueHandlerComposite",
    "source_code": "public class HandlerMethodReturnValueHandlerComposite implements HandlerMethodReturnValueHandler {\n\n\tprivate final List<HandlerMethodReturnValueHandler> returnValueHandlers = new ArrayList<>();\n\n\n\t/**\n\t * Return a read-only list with the registered handlers, or an empty list.\n\t */\n\tpublic List<HandlerMethodReturnValueHandler> getHandlers() {\n\t\treturn Collections.unmodifiableList(this.returnValueHandlers);\n\t}\n\n\t/**\n\t * Whether the given {@linkplain MethodParameter method return type} is supported by any registered\n\t * {@link HandlerMethodReturnValueHandler}.\n\t */\n\t@Override\n\tpublic boolean supportsReturnType(MethodParameter returnType) {\n\t\treturn getReturnValueHandler(returnType) != null;\n\t}\n\n\t@Nullable\n\tprivate HandlerMethodReturnValueHandler getReturnValueHandler(MethodParameter returnType) {\n\t\tfor (HandlerMethodReturnValueHandler handler : this.returnValueHandlers) {\n\t\t\tif (handler.supportsReturnType(returnType)) {\n\t\t\t\treturn handler;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Iterate over registered {@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers} and invoke the one that supports it.\n\t * @throws IllegalStateException if no suitable {@link HandlerMethodReturnValueHandler} is found.\n\t */\n\t@Override\n\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {\n\n\t\tHandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);\n\t\tif (handler == null) {\n\t\t\tthrow new IllegalArgumentException(\"Unknown return value type: \" + returnType.getParameterType().getName());\n\t\t}\n\t\thandler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);\n\t}\n\n\t@Nullable\n\tprivate HandlerMethodReturnValueHandler selectHandler(@Nullable Object value, MethodParameter returnType) {\n\t\tboolean isAsyncValue = isAsyncReturnValue(value, returnType);\n\t\tfor (HandlerMethodReturnValueHandler handler : this.returnValueHandlers) {\n\t\t\tif (isAsyncValue && !(handler instanceof AsyncHandlerMethodReturnValueHandler)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (handler.supportsReturnType(returnType)) {\n\t\t\t\treturn handler;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate boolean isAsyncReturnValue(@Nullable Object value, MethodParameter returnType) {\n\t\tfor (HandlerMethodReturnValueHandler handler : this.returnValueHandlers) {\n\t\t\tif (handler instanceof AsyncHandlerMethodReturnValueHandler asyncHandler &&\n\t\t\t\t\tasyncHandler.isAsyncReturnValue(value, returnType)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Add the given {@link HandlerMethodReturnValueHandler}.\n\t */\n\tpublic HandlerMethodReturnValueHandlerComposite addHandler(HandlerMethodReturnValueHandler handler) {\n\t\tthis.returnValueHandlers.add(handler);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add the given {@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers}.\n\t */\n\tpublic HandlerMethodReturnValueHandlerComposite addHandlers(\n\t\t\t@Nullable List<? extends HandlerMethodReturnValueHandler> handlers) {\n\n\t\tif (handlers != null) {\n\t\t\tthis.returnValueHandlers.addAll(handlers);\n\t\t}\n\t\treturn this;\n\t}\n\n}"
  },
  "org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite#addHandler(handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given {@link HandlerMethodReturnValueHandler}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "HandlerMethodReturnValueHandlerComposite",
    "signature": "public HandlerMethodReturnValueHandlerComposite addHandler(HandlerMethodReturnValueHandler handler)",
    "source_code": "\tpublic HandlerMethodReturnValueHandlerComposite addHandler(HandlerMethodReturnValueHandler handler) {\n\t\tthis.returnValueHandlers.add(handler);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite#addHandlers(handlers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given {@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handlers"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "HandlerMethodReturnValueHandlerComposite",
    "signature": "public HandlerMethodReturnValueHandlerComposite addHandlers(@Nullable List<? extends HandlerMethodReturnValueHandler> handlers)",
    "source_code": "\tpublic HandlerMethodReturnValueHandlerComposite addHandlers("
  },
  "org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite#getHandlers()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a read-only list with the registered handlers, or an empty list.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 43
    },
    "return": "List<HandlerMethodReturnValueHandler>",
    "signature": "public List<HandlerMethodReturnValueHandler> getHandlers()",
    "source_code": "\tpublic List<HandlerMethodReturnValueHandler> getHandlers() {\n\t\treturn Collections.unmodifiableList(this.returnValueHandlers);\n\t}"
  },
  "org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite#handleReturnValue(returnValue,returnType,mavContainer,webRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Iterate over registered {@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers} and invoke the one that supports it.\n\t * @throws IllegalStateException if no suitable {@link HandlerMethodReturnValueHandler} is found.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "mavContainer",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "void",
    "signature": "public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest)",
    "source_code": "\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,"
  },
  "org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite#supportsReturnType(returnType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the given {@linkplain MethodParameter method return type} is supported by any registered\n\t * {@link HandlerMethodReturnValueHandler}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnType"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "boolean",
    "signature": "public boolean supportsReturnType(MethodParameter returnType)",
    "source_code": "\tpublic boolean supportsReturnType(MethodParameter returnType) {\n\t\treturn getReturnValueHandler(returnType) != null;\n\t}"
  },
  "org.springframework.web.method.support.InvocableHandlerMethod": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Extension of {@link HandlerMethod} that invokes the underlying method with\n * argument values resolved from the current HTTP request through a list of\n * {@link HandlerMethodArgumentResolver}.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Sebastien Deleuze\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "signature": "public class InvocableHandlerMethod",
    "source_code": "public class InvocableHandlerMethod extends HandlerMethod {\n\n\tprivate static final Object[] EMPTY_ARGS = new Object[0];\n\n\n\tprivate HandlerMethodArgumentResolverComposite resolvers = new HandlerMethodArgumentResolverComposite();\n\n\tprivate ParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer();\n\n\t@Nullable\n\tprivate WebDataBinderFactory dataBinderFactory;\n\n\n\t/**\n\t * Create an instance from a {@code HandlerMethod}.\n\t */\n\tpublic InvocableHandlerMethod(HandlerMethod handlerMethod) {\n\t\tsuper(handlerMethod);\n\t}\n\n\t/**\n\t * Create an instance from a bean instance and a method.\n\t */\n\tpublic InvocableHandlerMethod(Object bean, Method method) {\n\t\tsuper(bean, method);\n\t}\n\n\t/**\n\t * Variant of {@link #InvocableHandlerMethod(Object, Method)} that\n\t * also accepts a {@link MessageSource}, for use in subclasses.\n\t * @since 5.3.10\n\t */\n\tprotected InvocableHandlerMethod(Object bean, Method method, @Nullable MessageSource messageSource) {\n\t\tsuper(bean, method, messageSource);\n\t}\n\n\t/**\n\t * Construct a new handler method with the given bean instance, method name and parameters.\n\t * @param bean the object bean\n\t * @param methodName the method name\n\t * @param parameterTypes the method parameter types\n\t * @throws NoSuchMethodException when the method cannot be found\n\t */\n\tpublic InvocableHandlerMethod(Object bean, String methodName, Class<?>... parameterTypes)\n\t\t\tthrows NoSuchMethodException {\n\n\t\tsuper(bean, methodName, parameterTypes);\n\t}\n\n\n\t/**\n\t * Set {@link HandlerMethodArgumentResolver HandlerMethodArgumentResolvers}\n\t * to use for resolving method argument values.\n\t */\n\tpublic void setHandlerMethodArgumentResolvers(HandlerMethodArgumentResolverComposite argumentResolvers) {\n\t\tthis.resolvers = argumentResolvers;\n\t}\n\n\t/**\n\t * Set the ParameterNameDiscoverer for resolving parameter names when needed\n\t * (e.g. default request attribute name).\n\t * <p>Default is a {@link org.springframework.core.DefaultParameterNameDiscoverer}.\n\t */\n\tpublic void setParameterNameDiscoverer(ParameterNameDiscoverer parameterNameDiscoverer) {\n\t\tthis.parameterNameDiscoverer = parameterNameDiscoverer;\n\t}\n\n\t/**\n\t * Set the {@link WebDataBinderFactory} to be passed to argument resolvers allowing them\n\t * to create a {@link WebDataBinder} for data binding and type conversion purposes.\n\t */\n\tpublic void setDataBinderFactory(WebDataBinderFactory dataBinderFactory) {\n\t\tthis.dataBinderFactory = dataBinderFactory;\n\t}\n\n\n\t/**\n\t * Invoke the method after resolving its argument values in the context of the given request.\n\t * <p>Argument values are commonly resolved through\n\t * {@link HandlerMethodArgumentResolver HandlerMethodArgumentResolvers}.\n\t * The {@code providedArgs} parameter however may supply argument values to be used directly,\n\t * i.e. without argument resolution. Examples of provided argument values include a\n\t * {@link WebDataBinder}, a {@link SessionStatus}, or a thrown exception instance.\n\t * Provided argument values are checked before argument resolvers.\n\t * <p>Delegates to {@link #getMethodArgumentValues} and calls {@link #doInvoke} with the\n\t * resolved arguments.\n\t * @param request the current request\n\t * @param mavContainer the ModelAndViewContainer for this request\n\t * @param providedArgs \"given\" arguments matched by type, not resolved\n\t * @return the raw value returned by the invoked method\n\t * @throws Exception raised if no suitable argument resolver can be found,\n\t * or if the method raised an exception\n\t * @see #getMethodArgumentValues\n\t * @see #doInvoke\n\t */\n\t@Nullable\n\tpublic Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tObject... providedArgs) throws Exception {\n\n\t\tObject[] args = getMethodArgumentValues(request, mavContainer, providedArgs);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Arguments: \" + Arrays.toString(args));\n\t\t}\n\t\treturn doInvoke(args);\n\t}\n\n\t/**\n\t * Get the method argument values for the current request, checking the provided\n\t * argument values and falling back to the configured argument resolvers.\n\t * <p>The resulting array will be passed into {@link #doInvoke}.\n\t * @since 5.1.2\n\t */\n\tprotected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tObject... providedArgs) throws Exception {\n\n\t\tMethodParameter[] parameters = getMethodParameters();\n\t\tif (ObjectUtils.isEmpty(parameters)) {\n\t\t\treturn EMPTY_ARGS;\n\t\t}\n\n\t\tObject[] args = new Object[parameters.length];\n\t\tfor (int i = 0; i < parameters.length; i++) {\n\t\t\tMethodParameter parameter = parameters[i];\n\t\t\tparameter.initParameterNameDiscovery(this.parameterNameDiscoverer);\n\t\t\targs[i] = findProvidedArgument(parameter, providedArgs);\n\t\t\tif (args[i] != null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!this.resolvers.supportsParameter(parameter)) {\n\t\t\t\tthrow new IllegalStateException(formatArgumentError(parameter, \"No suitable resolver\"));\n\t\t\t}\n\t\t\ttry {\n\t\t\t\targs[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\t// Leave stack trace for later, exception may actually be resolved and handled...\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tString exMsg = ex.getMessage();\n\t\t\t\t\tif (exMsg != null && !exMsg.contains(parameter.getExecutable().toGenericString())) {\n\t\t\t\t\t\tlogger.debug(formatArgumentError(parameter, exMsg));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\t\treturn args;\n\t}\n\n\t/**\n\t * Invoke the handler method with the given argument values.\n\t */\n\t@Nullable\n\tprotected Object doInvoke(Object... args) throws Exception {\n\t\tMethod method = getBridgedMethod();\n\t\ttry {\n\t\t\tif (KotlinDetector.isSuspendingFunction(method)) {\n\t\t\t\treturn invokeSuspendingFunction(method, getBean(), args);\n\t\t\t}\n\t\t\treturn method.invoke(getBean(), args);\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\tassertTargetBean(method, getBean(), args);\n\t\t\tString text = (ex.getMessage() == null || ex.getCause() instanceof NullPointerException) ?\n\t\t\t\t\t\"Illegal argument\" : ex.getMessage();\n\t\t\tthrow new IllegalStateException(formatInvokeError(text, args), ex);\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\t// Unwrap for HandlerExceptionResolvers ...\n\t\t\tThrowable targetException = ex.getCause();\n\t\t\tif (targetException instanceof RuntimeException runtimeException) {\n\t\t\t\tthrow runtimeException;\n\t\t\t}\n\t\t\telse if (targetException instanceof Error error) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\telse if (targetException instanceof Exception exception) {\n\t\t\t\tthrow exception;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalStateException(formatInvokeError(\"Invocation failure\", args), targetException);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Invoke the given Kotlin coroutine suspended function.\n\t *\n\t * <p>The default implementation invokes\n\t * {@link CoroutinesUtils#invokeSuspendingFunction(Method, Object, Object...)},\n\t * but subclasses can override this method to use\n\t * {@link CoroutinesUtils#invokeSuspendingFunction(kotlin.coroutines.CoroutineContext, Method, Object, Object...)}\n\t * instead.\n\t * @since 6.0\n\t */\n\tprotected Publisher<?> invokeSuspendingFunction(Method method, Object target, Object[] args) {\n\t\treturn CoroutinesUtils.invokeSuspendingFunction(method, target, args);\n\t}\n\n}"
  },
  "org.springframework.web.method.support.InvocableHandlerMethod#doInvoke(args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the handler method with the given argument values.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "args"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "Object",
    "signature": "protected Object doInvoke(Object... args)",
    "source_code": "\tprotected Object doInvoke(Object... args) throws Exception {\n\t\tMethod method = getBridgedMethod();\n\t\ttry {\n\t\t\tif (KotlinDetector.isSuspendingFunction(method)) {\n\t\t\t\treturn invokeSuspendingFunction(method, getBean(), args);\n\t\t\t}\n\t\t\treturn method.invoke(getBean(), args);\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\tassertTargetBean(method, getBean(), args);\n\t\t\tString text = (ex.getMessage() == null || ex.getCause() instanceof NullPointerException) ?\n\t\t\t\t\t\"Illegal argument\" : ex.getMessage();\n\t\t\tthrow new IllegalStateException(formatInvokeError(text, args), ex);\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\t// Unwrap for HandlerExceptionResolvers ...\n\t\t\tThrowable targetException = ex.getCause();\n\t\t\tif (targetException instanceof RuntimeException runtimeException) {\n\t\t\t\tthrow runtimeException;\n\t\t\t}\n\t\t\telse if (targetException instanceof Error error) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\telse if (targetException instanceof Exception exception) {\n\t\t\t\tthrow exception;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalStateException(formatInvokeError(\"Invocation failure\", args), targetException);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.method.support.InvocableHandlerMethod#getMethodArgumentValues(request,mavContainer,providedArgs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the method argument values for the current request, checking the provided\n\t * argument values and falling back to the configured argument resolvers.\n\t * <p>The resulting array will be passed into {@link #doInvoke}.\n\t * @since 5.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "mavContainer",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "Object[]",
    "signature": "protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tObject... providedArgs)",
    "source_code": "\tprotected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,"
  },
  "org.springframework.web.method.support.InvocableHandlerMethod#invokeForRequest(request,mavContainer,providedArgs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the method after resolving its argument values in the context of the given request.\n\t * <p>Argument values are commonly resolved through\n\t * {@link HandlerMethodArgumentResolver HandlerMethodArgumentResolvers}.\n\t * The {@code providedArgs} parameter however may supply argument values to be used directly,\n\t * i.e. without argument resolution. Examples of provided argument values include a\n\t * {@link WebDataBinder}, a {@link SessionStatus}, or a thrown exception instance.\n\t * Provided argument values are checked before argument resolvers.\n\t * <p>Delegates to {@link #getMethodArgumentValues} and calls {@link #doInvoke} with the\n\t * resolved arguments.\n\t * @param request the current request\n\t * @param mavContainer the ModelAndViewContainer for this request\n\t * @param providedArgs \"given\" arguments matched by type, not resolved\n\t * @return the raw value returned by the invoked method\n\t * @throws Exception raised if no suitable argument resolver can be found,\n\t * or if the method raised an exception\n\t * @see #getMethodArgumentValues\n\t * @see #doInvoke\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "mavContainer",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "Object",
    "signature": "public Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tObject... providedArgs)",
    "source_code": "\tpublic Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,"
  },
  "org.springframework.web.method.support.InvocableHandlerMethod#setDataBinderFactory(dataBinderFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link WebDataBinderFactory} to be passed to argument resolvers allowing them\n\t * to create a {@link WebDataBinder} for data binding and type conversion purposes.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataBinderFactory"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "void",
    "signature": "public void setDataBinderFactory(WebDataBinderFactory dataBinderFactory)",
    "source_code": "\tpublic void setDataBinderFactory(WebDataBinderFactory dataBinderFactory) {\n\t\tthis.dataBinderFactory = dataBinderFactory;\n\t}"
  },
  "org.springframework.web.method.support.InvocableHandlerMethod#setHandlerMethodArgumentResolvers(argumentResolvers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set {@link HandlerMethodArgumentResolver HandlerMethodArgumentResolvers}\n\t * to use for resolving method argument values.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argumentResolvers"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "void",
    "signature": "public void setHandlerMethodArgumentResolvers(HandlerMethodArgumentResolverComposite argumentResolvers)",
    "source_code": "\tpublic void setHandlerMethodArgumentResolvers(HandlerMethodArgumentResolverComposite argumentResolvers) {\n\t\tthis.resolvers = argumentResolvers;\n\t}"
  },
  "org.springframework.web.method.support.InvocableHandlerMethod#setParameterNameDiscoverer(parameterNameDiscoverer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the ParameterNameDiscoverer for resolving parameter names when needed\n\t * (e.g. default request attribute name).\n\t * <p>Default is a {@link org.springframework.core.DefaultParameterNameDiscoverer}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterNameDiscoverer"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "public void setParameterNameDiscoverer(ParameterNameDiscoverer parameterNameDiscoverer)",
    "source_code": "\tpublic void setParameterNameDiscoverer(ParameterNameDiscoverer parameterNameDiscoverer) {\n\t\tthis.parameterNameDiscoverer = parameterNameDiscoverer;\n\t}"
  },
  "org.springframework.web.method.support.ModelAndViewContainer": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Records model and view related decisions made by\n * {@link HandlerMethodArgumentResolver HandlerMethodArgumentResolvers} and\n * {@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers} during the course of invocation of\n * a controller method.\n *\n * <p>The {@link #setRequestHandled} flag can be used to indicate the request\n * has been handled directly and view resolution is not required.\n *\n * <p>A default {@link Model} is automatically created at instantiation.\n * An alternate model instance may be provided via {@link #setRedirectModel}\n * for use in a redirect scenario. When {@link #setRedirectModelScenario} is set\n * to {@code true} signaling a redirect scenario, the {@link #getModel()}\n * returns the redirect model instead of the default model.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "public class ModelAndViewContainer",
    "source_code": "public class ModelAndViewContainer {\n\n\tprivate boolean ignoreDefaultModelOnRedirect = true;\n\n\t@Nullable\n\tprivate Object view;\n\n\tprivate final ModelMap defaultModel = new BindingAwareModelMap();\n\n\t@Nullable\n\tprivate ModelMap redirectModel;\n\n\tprivate boolean redirectModelScenario = false;\n\n\t@Nullable\n\tprivate HttpStatusCode status;\n\n\tprivate final Set<String> noBinding = new HashSet<>(4);\n\n\tprivate final Set<String> bindingDisabled = new HashSet<>(4);\n\n\tprivate final SessionStatus sessionStatus = new SimpleSessionStatus();\n\n\tprivate boolean requestHandled = false;\n\n\n\t/**\n\t * By default, the content of the \"default\" model is used both during\n\t * rendering and redirect scenarios. Alternatively controller methods\n\t * can declare an argument of type {@code RedirectAttributes} and use\n\t * it to provide attributes to prepare the redirect URL.\n\t * <p>Setting this flag to {@code true} guarantees the \"default\" model is\n\t * never used in a redirect scenario even if a RedirectAttributes argument\n\t * is not declared. Setting it to {@code false} means the \"default\" model\n\t * may be used in a redirect if the controller method doesn't declare a\n\t * RedirectAttributes argument.\n\t * <p>As of 6.0, this property is set to {@code true} by default.\n\t * @deprecated as of 6.0 without a replacement; once removed, the default\n\t * model will always be ignored on redirect\n\t */\n\t@Deprecated(since = \"6.0\")\n\tpublic void setIgnoreDefaultModelOnRedirect(boolean ignoreDefaultModelOnRedirect) {\n\t\tthis.ignoreDefaultModelOnRedirect = ignoreDefaultModelOnRedirect;\n\t}\n\n\t/**\n\t * Set a view name to be resolved by the DispatcherServlet via a ViewResolver.\n\t * Will override any pre-existing view name or View.\n\t */\n\tpublic void setViewName(@Nullable String viewName) {\n\t\tthis.view = viewName;\n\t}\n\n\t/**\n\t * Return the view name to be resolved by the DispatcherServlet via a\n\t * ViewResolver, or {@code null} if a View object is set.\n\t */\n\t@Nullable\n\tpublic String getViewName() {\n\t\treturn (this.view instanceof String viewName ? viewName : null);\n\t}\n\n\t/**\n\t * Set a View object to be used by the DispatcherServlet.\n\t * Will override any pre-existing view name or View.\n\t */\n\tpublic void setView(@Nullable Object view) {\n\t\tthis.view = view;\n\t}\n\n\t/**\n\t * Return the View object, or {@code null} if we are using a view name\n\t * to be resolved by the DispatcherServlet via a ViewResolver.\n\t */\n\t@Nullable\n\tpublic Object getView() {\n\t\treturn this.view;\n\t}\n\n\t/**\n\t * Whether the view is a view reference specified via a name to be\n\t * resolved by the DispatcherServlet via a ViewResolver.\n\t */\n\tpublic boolean isViewReference() {\n\t\treturn (this.view instanceof String);\n\t}\n\n\t/**\n\t * Return the model to use -- either the \"default\" or the \"redirect\" model.\n\t * The default model is used if {@code redirectModelScenario=false} or\n\t * there is no redirect model (i.e. RedirectAttributes was not declared as\n\t * a method argument) and {@code ignoreDefaultModelOnRedirect=false}.\n\t */\n\tpublic ModelMap getModel() {\n\t\tif (useDefaultModel()) {\n\t\t\treturn this.defaultModel;\n\t\t}\n\t\telse {\n\t\t\tif (this.redirectModel == null) {\n\t\t\t\tthis.redirectModel = new ModelMap();\n\t\t\t}\n\t\t\treturn this.redirectModel;\n\t\t}\n\t}\n\n\t/**\n\t * Whether to use the default model or the redirect model.\n\t */\n\tprivate boolean useDefaultModel() {\n\t\treturn (!this.redirectModelScenario || (this.redirectModel == null && !this.ignoreDefaultModelOnRedirect));\n\t}\n\n\t/**\n\t * Return the \"default\" model created at instantiation.\n\t * <p>In general it is recommended to use {@link #getModel()} instead which\n\t * returns either the \"default\" model (template rendering) or the \"redirect\"\n\t * model (redirect URL preparation). Use of this method may be needed for\n\t * advanced cases when access to the \"default\" model is needed regardless,\n\t * e.g. to save model attributes specified via {@code @SessionAttributes}.\n\t * @return the default model (never {@code null})\n\t * @since 4.1.4\n\t */\n\tpublic ModelMap getDefaultModel() {\n\t\treturn this.defaultModel;\n\t}\n\n\t/**\n\t * Provide a separate model instance to use in a redirect scenario.\n\t * <p>The provided additional model however is not used unless\n\t * {@link #setRedirectModelScenario} gets set to {@code true}\n\t * to signal an actual redirect scenario.\n\t */\n\tpublic void setRedirectModel(ModelMap redirectModel) {\n\t\tthis.redirectModel = redirectModel;\n\t}\n\n\t/**\n\t * Whether the controller has returned a redirect instruction, e.g. a\n\t * \"redirect:\" prefixed view name, a RedirectView instance, etc.\n\t */\n\tpublic void setRedirectModelScenario(boolean redirectModelScenario) {\n\t\tthis.redirectModelScenario = redirectModelScenario;\n\t}\n\n\t/**\n\t * Provide an HTTP status that will be passed on to with the\n\t * {@code ModelAndView} used for view rendering purposes.\n\t * @since 4.3\n\t */\n\tpublic void setStatus(@Nullable HttpStatusCode status) {\n\t\tthis.status = status;\n\t}\n\n\t/**\n\t * Return the configured HTTP status, if any.\n\t * @since 4.3\n\t */\n\t@Nullable\n\tpublic HttpStatusCode getStatus() {\n\t\treturn this.status;\n\t}\n\n\t/**\n\t * Programmatically register an attribute for which data binding should not occur,\n\t * not even for a subsequent {@code @ModelAttribute} declaration.\n\t * @param attributeName the name of the attribute\n\t * @since 4.3\n\t */\n\tpublic void setBindingDisabled(String attributeName) {\n\t\tthis.bindingDisabled.add(attributeName);\n\t}\n\n\t/**\n\t * Whether binding is disabled for the given model attribute.\n\t * @since 4.3\n\t */\n\tpublic boolean isBindingDisabled(String name) {\n\t\treturn (this.bindingDisabled.contains(name) || this.noBinding.contains(name));\n\t}\n\n\t/**\n\t * Register whether data binding should occur for a corresponding model attribute,\n\t * corresponding to an {@code @ModelAttribute(binding=true/false)} declaration.\n\t * <p>Note: While this flag will be taken into account by {@link #isBindingDisabled},\n\t * a hard {@link #setBindingDisabled} declaration will always override it.\n\t * @param attributeName the name of the attribute\n\t * @since 4.3.13\n\t */\n\tpublic void setBinding(String attributeName, boolean enabled) {\n\t\tif (!enabled) {\n\t\t\tthis.noBinding.add(attributeName);\n\t\t}\n\t\telse {\n\t\t\tthis.noBinding.remove(attributeName);\n\t\t}\n\t}\n\n\t/**\n\t * Return the {@link SessionStatus} instance to use that can be used to\n\t * signal that session processing is complete.\n\t */\n\tpublic SessionStatus getSessionStatus() {\n\t\treturn this.sessionStatus;\n\t}\n\n\t/**\n\t * Whether the request has been handled fully within the handler, e.g.\n\t * {@code @ResponseBody} method, and therefore view resolution is not\n\t * necessary. This flag can also be set when controller methods declare an\n\t * argument of type {@code ServletResponse} or {@code OutputStream}).\n\t * <p>The default value is {@code false}.\n\t */\n\tpublic void setRequestHandled(boolean requestHandled) {\n\t\tthis.requestHandled = requestHandled;\n\t}\n\n\t/**\n\t * Whether the request has been handled fully within the handler.\n\t */\n\tpublic boolean isRequestHandled() {\n\t\treturn this.requestHandled;\n\t}\n\n\t/**\n\t * Add the supplied attribute to the underlying model.\n\t * A shortcut for {@code getModel().addAttribute(String, Object)}.\n\t */\n\tpublic ModelAndViewContainer addAttribute(String name, @Nullable Object value) {\n\t\tgetModel().addAttribute(name, value);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add the supplied attribute to the underlying model.\n\t * A shortcut for {@code getModel().addAttribute(Object)}.\n\t */\n\tpublic ModelAndViewContainer addAttribute(Object value) {\n\t\tgetModel().addAttribute(value);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Copy all attributes to the underlying model.\n\t * A shortcut for {@code getModel().addAllAttributes(Map)}.\n\t */\n\tpublic ModelAndViewContainer addAllAttributes(@Nullable Map<String, ?> attributes) {\n\t\tgetModel().addAllAttributes(attributes);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Copy attributes in the supplied {@code Map} with existing objects of\n\t * the same name taking precedence (i.e. not getting replaced).\n\t * A shortcut for {@code getModel().mergeAttributes(Map<String, ?>)}.\n\t */\n\tpublic ModelAndViewContainer mergeAttributes(@Nullable Map<String, ?> attributes) {\n\t\tgetModel().mergeAttributes(attributes);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove the given attributes from the model.\n\t */\n\tpublic ModelAndViewContainer removeAttributes(@Nullable Map<String, ?> attributes) {\n\t\tif (attributes != null) {\n\t\t\tfor (String key : attributes.keySet()) {\n\t\t\t\tgetModel().remove(key);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Whether the underlying model contains the given attribute name.\n\t * A shortcut for {@code getModel().containsAttribute(String)}.\n\t */\n\tpublic boolean containsAttribute(String name) {\n\t\treturn getModel().containsAttribute(name);\n\t}\n\n\n\t/**\n\t * Return diagnostic information.\n\t */\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder(\"ModelAndViewContainer: \");\n\t\tif (!isRequestHandled()) {\n\t\t\tif (isViewReference()) {\n\t\t\t\tsb.append(\"reference to view with name '\").append(this.view).append('\\'');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb.append(\"View is [\").append(this.view).append(']');\n\t\t\t}\n\t\t\tif (useDefaultModel()) {\n\t\t\t\tsb.append(\"; default model \");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb.append(\"; redirect model \");\n\t\t\t}\n\t\t\tsb.append(getModel());\n\t\t}\n\t\telse {\n\t\t\tsb.append(\"Request handled directly\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n}"
  },
  "org.springframework.web.method.support.ModelAndViewContainer#addAllAttributes(Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy all attributes to the underlying model.\n\t * A shortcut for {@code getModel().addAllAttributes(Map)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 295
    },
    "return": "ModelAndViewContainer",
    "signature": "public ModelAndViewContainer addAllAttributes(@Nullable Map<String, ?> attributes)",
    "source_code": "\tpublic ModelAndViewContainer addAllAttributes(@Nullable Map<String, ?> attributes) {\n\t\tgetModel().addAllAttributes(attributes);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.method.support.ModelAndViewContainer#addAttribute(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the supplied attribute to the underlying model.\n\t * A shortcut for {@code getModel().addAttribute(String, Object)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 277
    },
    "return": "ModelAndViewContainer",
    "signature": "public ModelAndViewContainer addAttribute(String name, @Nullable Object value)",
    "source_code": "\tpublic ModelAndViewContainer addAttribute(String name, @Nullable Object value) {\n\t\tgetModel().addAttribute(name, value);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.method.support.ModelAndViewContainer#addAttribute(value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the supplied attribute to the underlying model.\n\t * A shortcut for {@code getModel().addAttribute(Object)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "ModelAndViewContainer",
    "signature": "public ModelAndViewContainer addAttribute(Object value)",
    "source_code": "\tpublic ModelAndViewContainer addAttribute(Object value) {\n\t\tgetModel().addAttribute(value);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.method.support.ModelAndViewContainer#containsAttribute(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the underlying model contains the given attribute name.\n\t * A shortcut for {@code getModel().containsAttribute(String)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 326
    },
    "return": "boolean",
    "signature": "public boolean containsAttribute(String name)",
    "source_code": "\tpublic boolean containsAttribute(String name) {\n\t\treturn getModel().containsAttribute(name);\n\t}"
  },
  "org.springframework.web.method.support.ModelAndViewContainer#getDefaultModel()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the \"default\" model created at instantiation.\n\t * <p>In general it is recommended to use {@link #getModel()} instead which\n\t * returns either the \"default\" model (template rendering) or the \"redirect\"\n\t * model (redirect URL preparation). Use of this method may be needed for\n\t * advanced cases when access to the \"default\" model is needed regardless,\n\t * e.g. to save model attributes specified via {@code @SessionAttributes}.\n\t * @return the default model (never {@code null})\n\t * @since 4.1.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "ModelMap",
    "signature": "public ModelMap getDefaultModel()",
    "source_code": "\tpublic ModelMap getDefaultModel() {\n\t\treturn this.defaultModel;\n\t}"
  },
  "org.springframework.web.method.support.ModelAndViewContainer#getModel()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the model to use -- either the \"default\" or the \"redirect\" model.\n\t * The default model is used if {@code redirectModelScenario=false} or\n\t * there is no redirect model (i.e. RedirectAttributes was not declared as\n\t * a method argument) and {@code ignoreDefaultModelOnRedirect=false}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "ModelMap",
    "signature": "public ModelMap getModel()",
    "source_code": "\tpublic ModelMap getModel() {\n\t\tif (useDefaultModel()) {\n\t\t\treturn this.defaultModel;\n\t\t}\n\t\telse {\n\t\t\tif (this.redirectModel == null) {\n\t\t\t\tthis.redirectModel = new ModelMap();\n\t\t\t}\n\t\t\treturn this.redirectModel;\n\t\t}\n\t}"
  },
  "org.springframework.web.method.support.ModelAndViewContainer#getSessionStatus()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link SessionStatus} instance to use that can be used to\n\t * signal that session processing is complete.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "SessionStatus",
    "signature": "public SessionStatus getSessionStatus()",
    "source_code": "\tpublic SessionStatus getSessionStatus() {\n\t\treturn this.sessionStatus;\n\t}"
  },
  "org.springframework.web.method.support.ModelAndViewContainer#getStatus()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured HTTP status, if any.\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "HttpStatusCode",
    "signature": "public HttpStatusCode getStatus()",
    "source_code": "\tpublic HttpStatusCode getStatus() {\n\t\treturn this.status;\n\t}"
  },
  "org.springframework.web.method.support.ModelAndViewContainer#getView()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the View object, or {@code null} if we are using a view name\n\t * to be resolved by the DispatcherServlet via a ViewResolver.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "Object",
    "signature": "public Object getView()",
    "source_code": "\tpublic Object getView() {\n\t\treturn this.view;\n\t}"
  },
  "org.springframework.web.method.support.ModelAndViewContainer#getViewName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the view name to be resolved by the DispatcherServlet via a\n\t * ViewResolver, or {@code null} if a View object is set.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "String",
    "signature": "public String getViewName()",
    "source_code": "\tpublic String getViewName() {\n\t\treturn (this.view instanceof String viewName ? viewName : null);\n\t}"
  },
  "org.springframework.web.method.support.ModelAndViewContainer#isBindingDisabled(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether binding is disabled for the given model attribute.\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 226
    },
    "return": "boolean",
    "signature": "public boolean isBindingDisabled(String name)",
    "source_code": "\tpublic boolean isBindingDisabled(String name) {\n\t\treturn (this.bindingDisabled.contains(name) || this.noBinding.contains(name));\n\t}"
  },
  "org.springframework.web.method.support.ModelAndViewContainer#isRequestHandled()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the request has been handled fully within the handler.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 269
    },
    "return": "boolean",
    "signature": "public boolean isRequestHandled()",
    "source_code": "\tpublic boolean isRequestHandled() {\n\t\treturn this.requestHandled;\n\t}"
  },
  "org.springframework.web.method.support.ModelAndViewContainer#isViewReference()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the view is a view reference specified via a name to be\n\t * resolved by the DispatcherServlet via a ViewResolver.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "boolean",
    "signature": "public boolean isViewReference()",
    "source_code": "\tpublic boolean isViewReference() {\n\t\treturn (this.view instanceof String);\n\t}"
  },
  "org.springframework.web.method.support.ModelAndViewContainer#mergeAttributes(Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy attributes in the supplied {@code Map} with existing objects of\n\t * the same name taking precedence (i.e. not getting replaced).\n\t * A shortcut for {@code getModel().mergeAttributes(Map<String, ?>)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 305
    },
    "return": "ModelAndViewContainer",
    "signature": "public ModelAndViewContainer mergeAttributes(@Nullable Map<String, ?> attributes)",
    "source_code": "\tpublic ModelAndViewContainer mergeAttributes(@Nullable Map<String, ?> attributes) {\n\t\tgetModel().mergeAttributes(attributes);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.method.support.ModelAndViewContainer#removeAttributes(Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Remove the given attributes from the model.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 313
    },
    "return": "ModelAndViewContainer",
    "signature": "public ModelAndViewContainer removeAttributes(@Nullable Map<String, ?> attributes)",
    "source_code": "\tpublic ModelAndViewContainer removeAttributes(@Nullable Map<String, ?> attributes) {\n\t\tif (attributes != null) {\n\t\t\tfor (String key : attributes.keySet()) {\n\t\t\t\tgetModel().remove(key);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.method.support.ModelAndViewContainer#setBinding(attributeName,enabled)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register whether data binding should occur for a corresponding model attribute,\n\t * corresponding to an {@code @ModelAttribute(binding=true/false)} declaration.\n\t * <p>Note: While this flag will be taken into account by {@link #isBindingDisabled},\n\t * a hard {@link #setBindingDisabled} declaration will always override it.\n\t * @param attributeName the name of the attribute\n\t * @since 4.3.13\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "enabled"
    ],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "void",
    "signature": "public void setBinding(String attributeName, boolean enabled)",
    "source_code": "\tpublic void setBinding(String attributeName, boolean enabled) {\n\t\tif (!enabled) {\n\t\t\tthis.noBinding.add(attributeName);\n\t\t}\n\t\telse {\n\t\t\tthis.noBinding.remove(attributeName);\n\t\t}\n\t}"
  },
  "org.springframework.web.method.support.ModelAndViewContainer#setBindingDisabled(attributeName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Programmatically register an attribute for which data binding should not occur,\n\t * not even for a subsequent {@code @ModelAttribute} declaration.\n\t * @param attributeName the name of the attribute\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "void",
    "signature": "public void setBindingDisabled(String attributeName)",
    "source_code": "\tpublic void setBindingDisabled(String attributeName) {\n\t\tthis.bindingDisabled.add(attributeName);\n\t}"
  },
  "org.springframework.web.method.support.ModelAndViewContainer#setIgnoreDefaultModelOnRedirect(ignoreDefaultModelOnRedirect)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * By default, the content of the \"default\" model is used both during\n\t * rendering and redirect scenarios. Alternatively controller methods\n\t * can declare an argument of type {@code RedirectAttributes} and use\n\t * it to provide attributes to prepare the redirect URL.\n\t * <p>Setting this flag to {@code true} guarantees the \"default\" model is\n\t * never used in a redirect scenario even if a RedirectAttributes argument\n\t * is not declared. Setting it to {@code false} means the \"default\" model\n\t * may be used in a redirect if the controller method doesn't declare a\n\t * RedirectAttributes argument.\n\t * <p>As of 6.0, this property is set to {@code true} by default.\n\t * @deprecated as of 6.0 without a replacement; once removed, the default\n\t * model will always be ignored on redirect\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ignoreDefaultModelOnRedirect"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "void",
    "signature": "public void setIgnoreDefaultModelOnRedirect(boolean ignoreDefaultModelOnRedirect)",
    "source_code": "\tpublic void setIgnoreDefaultModelOnRedirect(boolean ignoreDefaultModelOnRedirect) {\n\t\tthis.ignoreDefaultModelOnRedirect = ignoreDefaultModelOnRedirect;\n\t}"
  },
  "org.springframework.web.method.support.ModelAndViewContainer#setRedirectModel(redirectModel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide a separate model instance to use in a redirect scenario.\n\t * <p>The provided additional model however is not used unless\n\t * {@link #setRedirectModelScenario} gets set to {@code true}\n\t * to signal an actual redirect scenario.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "redirectModel"
    ],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "void",
    "signature": "public void setRedirectModel(ModelMap redirectModel)",
    "source_code": "\tpublic void setRedirectModel(ModelMap redirectModel) {\n\t\tthis.redirectModel = redirectModel;\n\t}"
  },
  "org.springframework.web.method.support.ModelAndViewContainer#setRedirectModelScenario(redirectModelScenario)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the controller has returned a redirect instruction, e.g. a\n\t * \"redirect:\" prefixed view name, a RedirectView instance, etc.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "redirectModelScenario"
    ],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "void",
    "signature": "public void setRedirectModelScenario(boolean redirectModelScenario)",
    "source_code": "\tpublic void setRedirectModelScenario(boolean redirectModelScenario) {\n\t\tthis.redirectModelScenario = redirectModelScenario;\n\t}"
  },
  "org.springframework.web.method.support.ModelAndViewContainer#setRequestHandled(requestHandled)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the request has been handled fully within the handler, e.g.\n\t * {@code @ResponseBody} method, and therefore view resolution is not\n\t * necessary. This flag can also be set when controller methods declare an\n\t * argument of type {@code ServletResponse} or {@code OutputStream}).\n\t * <p>The default value is {@code false}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestHandled"
    ],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "void",
    "signature": "public void setRequestHandled(boolean requestHandled)",
    "source_code": "\tpublic void setRequestHandled(boolean requestHandled) {\n\t\tthis.requestHandled = requestHandled;\n\t}"
  },
  "org.springframework.web.method.support.ModelAndViewContainer#setStatus(status)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide an HTTP status that will be passed on to with the\n\t * {@code ModelAndView} used for view rendering purposes.\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "void",
    "signature": "public void setStatus(@Nullable HttpStatusCode status)",
    "source_code": "\tpublic void setStatus(@Nullable HttpStatusCode status) {\n\t\tthis.status = status;\n\t}"
  },
  "org.springframework.web.method.support.ModelAndViewContainer#setView(view)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a View object to be used by the DispatcherServlet.\n\t * Will override any pre-existing view name or View.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "view"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "void",
    "signature": "public void setView(@Nullable Object view)",
    "source_code": "\tpublic void setView(@Nullable Object view) {\n\t\tthis.view = view;\n\t}"
  },
  "org.springframework.web.method.support.ModelAndViewContainer#setViewName(viewName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a view name to be resolved by the DispatcherServlet via a ViewResolver.\n\t * Will override any pre-existing view name or View.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "viewName"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "void",
    "signature": "public void setViewName(@Nullable String viewName)",
    "source_code": "\tpublic void setViewName(@Nullable String viewName) {\n\t\tthis.view = viewName;\n\t}"
  },
  "org.springframework.web.method.support.ModelAndViewContainer#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return diagnostic information.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 335
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder(\"ModelAndViewContainer: \");\n\t\tif (!isRequestHandled()) {\n\t\t\tif (isViewReference()) {\n\t\t\t\tsb.append(\"reference to view with name '\").append(this.view).append('\\'');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb.append(\"View is [\").append(this.view).append(']');\n\t\t\t}\n\t\t\tif (useDefaultModel()) {\n\t\t\t\tsb.append(\"; default model \");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb.append(\"; redirect model \");\n\t\t\t}\n\t\t\tsb.append(getModel());\n\t\t}\n\t\telse {\n\t\t\tsb.append(\"Request handled directly\");\n\t\t}\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.web.multipart.<unknown>#contentLength()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "long",
    "signature": "public long contentLength()",
    "source_code": "\tpublic long contentLength() {\n\t\treturn this.multipartFile.getSize();\n\t}"
  },
  "org.springframework.web.multipart.<unknown>#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof MultipartFileResource other &&\n\t\t\t\tthis.multipartFile.equals(other.multipartFile)));\n\t}"
  },
  "org.springframework.web.multipart.<unknown>#exists()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation always returns {@code true}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 50
    },
    "return": "boolean",
    "signature": "public boolean exists()",
    "source_code": "\tpublic boolean exists() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.multipart.<unknown>#getDescription()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns a description that has the Multipart name.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "String",
    "signature": "public String getDescription()",
    "source_code": "\tpublic String getDescription() {\n\t\treturn \"MultipartFile resource [\" + this.multipartFile.getName() + \"]\";\n\t}"
  },
  "org.springframework.web.multipart.<unknown>#getFilename()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "String",
    "signature": "public String getFilename()",
    "source_code": "\tpublic String getFilename() {\n\t\treturn this.multipartFile.getOriginalFilename();\n\t}"
  },
  "org.springframework.web.multipart.<unknown>#getInputStream()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation throws IllegalStateException if attempting to\n\t * read the underlying stream multiple times.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "InputStream",
    "signature": "public InputStream getInputStream()",
    "source_code": "\tpublic InputStream getInputStream() throws IOException, IllegalStateException {\n\t\treturn this.multipartFile.getInputStream();\n\t}"
  },
  "org.springframework.web.multipart.<unknown>#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.multipartFile.hashCode();\n\t}"
  },
  "org.springframework.web.multipart.<unknown>#isOpen()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation always returns {@code true}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "boolean",
    "signature": "public boolean isOpen()",
    "source_code": "\tpublic boolean isOpen() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.multipart.support.StandardServletMultipartResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Standard implementation of the {@link MultipartResolver} interface,\n * based on the Servlet {@link jakarta.servlet.http.Part} API.\n * To be added as \"multipartResolver\" bean to a Spring DispatcherServlet context,\n * without any extra configuration at the bean level (see below).\n *\n * <p>This resolver variant uses your Servlet container's multipart parser as-is,\n * potentially exposing the application to container implementation differences.\n * Also, see this resolver's configuration option for\n * {@linkplain #setStrictServletCompliance strict Servlet compliance}, narrowing the\n * applicability of Spring's {@link MultipartHttpServletRequest} to form data only.\n *\n * <p><b>Note:</b> In order to use Servlet container based multipart parsing,\n * you need to mark the affected servlet with a \"multipart-config\" section in\n * {@code web.xml}, or with a {@link jakarta.servlet.MultipartConfigElement}\n * in programmatic servlet registration, or (in case of a custom servlet class)\n * possibly with a {@link jakarta.servlet.annotation.MultipartConfig} annotation\n * on your servlet class. Configuration settings such as maximum sizes or storage\n * locations need to be applied at that servlet registration level; a Servlet\n * container does not allow for them to be set at the MultipartResolver level.\n *\n * <pre class=\"code\">\n * public class AppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n *   // ...\n *   &#064;Override\n *   protected void customizeRegistration(ServletRegistration.Dynamic registration) {\n *     // Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold\n *     registration.setMultipartConfig(new MultipartConfigElement(\"/tmp\"));\n *   }\n * }</pre>\n *\n * @author Juergen Hoeller\n * @since 3.1\n * @see #setResolveLazily\n * @see #setStrictServletCompliance\n * @see HttpServletRequest#getParts()\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "signature": "public class StandardServletMultipartResolver",
    "source_code": "public class StandardServletMultipartResolver implements MultipartResolver {\n\n\tprivate boolean resolveLazily = false;\n\n\tprivate boolean strictServletCompliance = false;\n\n\n\t/**\n\t * Set whether to resolve the multipart request lazily at the time of\n\t * file or parameter access.\n\t * <p>Default is \"false\", resolving the multipart elements immediately, throwing\n\t * corresponding exceptions at the time of the {@link #resolveMultipart} call.\n\t * Switch this to \"true\" for lazy multipart parsing, throwing parse exceptions\n\t * once the application attempts to obtain multipart files or parameters.\n\t * @since 3.2.9\n\t */\n\tpublic void setResolveLazily(boolean resolveLazily) {\n\t\tthis.resolveLazily = resolveLazily;\n\t}\n\n\t/**\n\t * Specify whether this resolver should strictly comply with the Servlet\n\t * specification, only kicking in for \"multipart/form-data\" requests.\n\t * <p>Default is \"false\", trying to process any request with a \"multipart/\"\n\t * content type as far as the underlying Servlet container supports it\n\t * (which works on e.g. Tomcat but not on Jetty). For consistent portability\n\t * and in particular for consistent custom handling of non-form multipart\n\t * request types outside of Spring's {@link MultipartResolver} mechanism,\n\t * switch this flag to \"true\": Only \"multipart/form-data\" requests will be\n\t * wrapped with a {@link MultipartHttpServletRequest} then; other kinds of\n\t * requests will be left as-is, allowing for custom processing in user code.\n\t * @since 5.3.9\n\t */\n\tpublic void setStrictServletCompliance(boolean strictServletCompliance) {\n\t\tthis.strictServletCompliance = strictServletCompliance;\n\t}\n\n\n\t@Override\n\tpublic boolean isMultipart(HttpServletRequest request) {\n\t\treturn StringUtils.startsWithIgnoreCase(request.getContentType(),\n\t\t\t\t(this.strictServletCompliance ? MediaType.MULTIPART_FORM_DATA_VALUE : \"multipart/\"));\n\t}\n\n\t@Override\n\tpublic MultipartHttpServletRequest resolveMultipart(HttpServletRequest request) throws MultipartException {\n\t\treturn new StandardMultipartHttpServletRequest(request, this.resolveLazily);\n\t}\n\n\t@Override\n\tpublic void cleanupMultipart(MultipartHttpServletRequest request) {\n\t\tif (!(request instanceof AbstractMultipartHttpServletRequest abstractMultipartHttpServletRequest) ||\n\t\t\t\tabstractMultipartHttpServletRequest.isResolved()) {\n\t\t\t// To be on the safe side: explicitly delete the parts,\n\t\t\t// but only actual file parts (for Resin compatibility)\n\t\t\ttry {\n\t\t\t\tfor (Part part : request.getParts()) {\n\t\t\t\t\tif (request.getFile(part.getName()) != null) {\n\t\t\t\t\t\tpart.delete();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tLogFactory.getLog(getClass()).warn(\"Failed to perform cleanup of multipart items\", ex);\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.multipart.support.StandardServletMultipartResolver#cleanupMultipart(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "void",
    "signature": "public void cleanupMultipart(MultipartHttpServletRequest request)",
    "source_code": "\tpublic void cleanupMultipart(MultipartHttpServletRequest request) {\n\t\tif (!(request instanceof AbstractMultipartHttpServletRequest abstractMultipartHttpServletRequest) ||\n\t\t\t\tabstractMultipartHttpServletRequest.isResolved()) {\n\t\t\t// To be on the safe side: explicitly delete the parts,\n\t\t\t// but only actual file parts (for Resin compatibility)\n\t\t\ttry {\n\t\t\t\tfor (Part part : request.getParts()) {\n\t\t\t\t\tif (request.getFile(part.getName()) != null) {\n\t\t\t\t\t\tpart.delete();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tLogFactory.getLog(getClass()).warn(\"Failed to perform cleanup of multipart items\", ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.multipart.support.StandardServletMultipartResolver#isMultipart(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "boolean",
    "signature": "public boolean isMultipart(HttpServletRequest request)",
    "source_code": "\tpublic boolean isMultipart(HttpServletRequest request) {\n\t\treturn StringUtils.startsWithIgnoreCase(request.getContentType(),\n\t\t\t\t(this.strictServletCompliance ? MediaType.MULTIPART_FORM_DATA_VALUE : \"multipart/\"));\n\t}"
  },
  "org.springframework.web.multipart.support.StandardServletMultipartResolver#resolveMultipart(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "MultipartHttpServletRequest",
    "signature": "public MultipartHttpServletRequest resolveMultipart(HttpServletRequest request)",
    "source_code": "\tpublic MultipartHttpServletRequest resolveMultipart(HttpServletRequest request) throws MultipartException {\n\t\treturn new StandardMultipartHttpServletRequest(request, this.resolveLazily);\n\t}"
  },
  "org.springframework.web.multipart.support.StandardServletMultipartResolver#setResolveLazily(resolveLazily)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to resolve the multipart request lazily at the time of\n\t * file or parameter access.\n\t * <p>Default is \"false\", resolving the multipart elements immediately, throwing\n\t * corresponding exceptions at the time of the {@link #resolveMultipart} call.\n\t * Switch this to \"true\" for lazy multipart parsing, throwing parse exceptions\n\t * once the application attempts to obtain multipart files or parameters.\n\t * @since 3.2.9\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolveLazily"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "void",
    "signature": "public void setResolveLazily(boolean resolveLazily)",
    "source_code": "\tpublic void setResolveLazily(boolean resolveLazily) {\n\t\tthis.resolveLazily = resolveLazily;\n\t}"
  },
  "org.springframework.web.multipart.support.StandardServletMultipartResolver#setStrictServletCompliance(strictServletCompliance)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether this resolver should strictly comply with the Servlet\n\t * specification, only kicking in for \"multipart/form-data\" requests.\n\t * <p>Default is \"false\", trying to process any request with a \"multipart/\"\n\t * content type as far as the underlying Servlet container supports it\n\t * (which works on e.g. Tomcat but not on Jetty). For consistent portability\n\t * and in particular for consistent custom handling of non-form multipart\n\t * request types outside of Spring's {@link MultipartResolver} mechanism,\n\t * switch this flag to \"true\": Only \"multipart/form-data\" requests will be\n\t * wrapped with a {@link MultipartHttpServletRequest} then; other kinds of\n\t * requests will be left as-is, allowing for custom processing in user code.\n\t * @since 5.3.9\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "strictServletCompliance"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "void",
    "signature": "public void setStrictServletCompliance(boolean strictServletCompliance)",
    "source_code": "\tpublic void setStrictServletCompliance(boolean strictServletCompliance) {\n\t\tthis.strictServletCompliance = strictServletCompliance;\n\t}"
  },
  "org.springframework.web.server.adapter.FORWARDED_HEADER_TRANSFORMER_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Well-known name for the ForwardedHeaderTransformer in the bean factory. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "signature": "public String FORWARDED_HEADER_TRANSFORMER_BEAN_NAME",
    "source_code": "\tpublic static final String FORWARDED_HEADER_TRANSFORMER_BEAN_NAME = \"forwardedHeaderTransformer\";",
    "type": "String"
  },
  "org.springframework.web.server.adapter.LOCALE_CONTEXT_RESOLVER_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Well-known name for the LocaleContextResolver in the bean factory. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "signature": "public String LOCALE_CONTEXT_RESOLVER_BEAN_NAME",
    "source_code": "\tpublic static final String LOCALE_CONTEXT_RESOLVER_BEAN_NAME = \"localeContextResolver\";",
    "type": "String"
  },
  "org.springframework.web.server.adapter.SERVER_CODEC_CONFIGURER_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Well-known name for the ServerCodecConfigurer in the bean factory. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "signature": "public String SERVER_CODEC_CONFIGURER_BEAN_NAME",
    "source_code": "\tpublic static final String SERVER_CODEC_CONFIGURER_BEAN_NAME = \"serverCodecConfigurer\";",
    "type": "String"
  },
  "org.springframework.web.server.adapter.SpringWebBlockHoundIntegration": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@code BlockHoundIntegration} for spring-web classes.\n\t * @since 5.3.6\n\t */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 429
    },
    "signature": "public class SpringWebBlockHoundIntegration",
    "source_code": "\tpublic static class SpringWebBlockHoundIntegration implements BlockHoundIntegration {\n\n\t\t@Override\n\t\tpublic void applyTo(BlockHound.Builder builder) {\n\n\t\t\t// Avoid hard references potentially anywhere in spring-web (no need for structural dependency)\n\n\t\t\tbuilder.allowBlockingCallsInside(\"org.springframework.http.MediaTypeFactory\", \"<clinit>\");\n\t\t\tbuilder.allowBlockingCallsInside(\"org.springframework.web.util.HtmlUtils\", \"<clinit>\");\n\t\t}\n\t}"
  },
  "org.springframework.web.server.adapter.WEB_HANDLER_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Well-known name for the target WebHandler in the bean factory. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "signature": "public String WEB_HANDLER_BEAN_NAME",
    "source_code": "\tpublic static final String WEB_HANDLER_BEAN_NAME = \"webHandler\";",
    "type": "String"
  },
  "org.springframework.web.server.adapter.WEB_SESSION_MANAGER_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Well-known name for the WebSessionManager in the bean factory. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "signature": "public String WEB_SESSION_MANAGER_BEAN_NAME",
    "source_code": "\tpublic static final String WEB_SESSION_MANAGER_BEAN_NAME = \"webSessionManager\";",
    "type": "String"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * This builder has two purposes:\n *\n * <p>One is to assemble a processing chain that consists of a target {@link WebHandler},\n * then decorated with a set of {@link WebFilter WebFilters}, then further decorated with\n * a set of {@link WebExceptionHandler WebExceptionHandlers}.\n *\n * <p>The second purpose is to adapt the resulting processing chain to an {@link HttpHandler}:\n * the lowest-level reactive HTTP handling abstraction which can then be used with any of the\n * supported runtimes. The adaptation is done with the help of {@link HttpWebHandlerAdapter}.\n *\n * <p>The processing chain can be assembled manually via builder methods, or detected from\n * a Spring {@link ApplicationContext} via {@link #applicationContext}, or a mix of both.\n *\n * @author Rossen Stoyanchev\n * @author Sebastien Deleuze\n * @since 5.0\n * @see HttpWebHandlerAdapter\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "signature": "public class WebHttpHandlerBuilder",
    "source_code": "public final class WebHttpHandlerBuilder {\n\n\t/** Well-known name for the target WebHandler in the bean factory. */\n\tpublic static final String WEB_HANDLER_BEAN_NAME = \"webHandler\";\n\n\t/** Well-known name for the WebSessionManager in the bean factory. */\n\tpublic static final String WEB_SESSION_MANAGER_BEAN_NAME = \"webSessionManager\";\n\n\t/** Well-known name for the ServerCodecConfigurer in the bean factory. */\n\tpublic static final String SERVER_CODEC_CONFIGURER_BEAN_NAME = \"serverCodecConfigurer\";\n\n\t/** Well-known name for the LocaleContextResolver in the bean factory. */\n\tpublic static final String LOCALE_CONTEXT_RESOLVER_BEAN_NAME = \"localeContextResolver\";\n\n\t/** Well-known name for the ForwardedHeaderTransformer in the bean factory. */\n\tpublic static final String FORWARDED_HEADER_TRANSFORMER_BEAN_NAME = \"forwardedHeaderTransformer\";\n\n\tprivate final WebHandler webHandler;\n\n\t@Nullable\n\tprivate final ApplicationContext applicationContext;\n\n\tprivate final List<WebFilter> filters = new ArrayList<>();\n\n\tprivate final List<WebExceptionHandler> exceptionHandlers = new ArrayList<>();\n\n\t@Nullable\n\tprivate Function<HttpHandler, HttpHandler> httpHandlerDecorator;\n\n\t@Nullable\n\tprivate WebSessionManager sessionManager;\n\n\t@Nullable\n\tprivate ServerCodecConfigurer codecConfigurer;\n\n\t@Nullable\n\tprivate LocaleContextResolver localeContextResolver;\n\n\t@Nullable\n\tprivate ForwardedHeaderTransformer forwardedHeaderTransformer;\n\n\n\t/**\n\t * Private constructor to use when initialized from an ApplicationContext.\n\t */\n\tprivate WebHttpHandlerBuilder(WebHandler webHandler, @Nullable ApplicationContext applicationContext) {\n\t\tAssert.notNull(webHandler, \"WebHandler must not be null\");\n\t\tthis.webHandler = webHandler;\n\t\tthis.applicationContext = applicationContext;\n\t}\n\n\t/**\n\t * Copy constructor.\n\t */\n\tprivate WebHttpHandlerBuilder(WebHttpHandlerBuilder other) {\n\t\tthis.webHandler = other.webHandler;\n\t\tthis.applicationContext = other.applicationContext;\n\t\tthis.filters.addAll(other.filters);\n\t\tthis.exceptionHandlers.addAll(other.exceptionHandlers);\n\t\tthis.sessionManager = other.sessionManager;\n\t\tthis.codecConfigurer = other.codecConfigurer;\n\t\tthis.localeContextResolver = other.localeContextResolver;\n\t\tthis.forwardedHeaderTransformer = other.forwardedHeaderTransformer;\n\t\tthis.httpHandlerDecorator = other.httpHandlerDecorator;\n\t}\n\n\n\t/**\n\t * Static factory method to create a new builder instance.\n\t * @param webHandler the target handler for the request\n\t * @return the prepared builder\n\t */\n\tpublic static WebHttpHandlerBuilder webHandler(WebHandler webHandler) {\n\t\treturn new WebHttpHandlerBuilder(webHandler, null);\n\t}\n\n\t/**\n\t * Static factory method to create a new builder instance by detecting beans\n\t * in an {@link ApplicationContext}. The following are detected:\n\t * <ul>\n\t * <li>{@link WebHandler} [1] -- looked up by the name\n\t * {@link #WEB_HANDLER_BEAN_NAME}.\n\t * <li>{@link WebFilter} [0..N] -- detected by type and ordered,\n\t * see {@link AnnotationAwareOrderComparator}.\n\t * <li>{@link WebExceptionHandler} [0..N] -- detected by type and\n\t * ordered.\n\t * <li>{@link HttpHandlerDecoratorFactory} [0..N] -- detected by type and\n\t * ordered.\n\t * <li>{@link WebSessionManager} [0..1] -- looked up by the name\n\t * {@link #WEB_SESSION_MANAGER_BEAN_NAME}.\n\t * <li>{@link ServerCodecConfigurer} [0..1] -- looked up by the name\n\t * {@link #SERVER_CODEC_CONFIGURER_BEAN_NAME}.\n\t * <li>{@link LocaleContextResolver} [0..1] -- looked up by the name\n\t * {@link #LOCALE_CONTEXT_RESOLVER_BEAN_NAME}.\n\t * </ul>\n\t * @param context the application context to use for the lookup\n\t * @return the prepared builder\n\t */\n\tpublic static WebHttpHandlerBuilder applicationContext(ApplicationContext context) {\n\n\t\tWebHttpHandlerBuilder builder = new WebHttpHandlerBuilder(\n\t\t\t\tcontext.getBean(WEB_HANDLER_BEAN_NAME, WebHandler.class), context);\n\n\t\tList<WebFilter> webFilters = context\n\t\t\t\t.getBeanProvider(WebFilter.class)\n\t\t\t\t.orderedStream()\n\t\t\t\t.toList();\n\t\tbuilder.filters(filters -> filters.addAll(webFilters));\n\n\t\tList<WebExceptionHandler> exceptionHandlers = context\n\t\t\t\t.getBeanProvider(WebExceptionHandler.class)\n\t\t\t\t.orderedStream()\n\t\t\t\t.toList();\n\t\tbuilder.exceptionHandlers(handlers -> handlers.addAll(exceptionHandlers));\n\n\t\tcontext.getBeanProvider(HttpHandlerDecoratorFactory.class)\n\t\t\t\t.orderedStream()\n\t\t\t\t.forEach(builder::httpHandlerDecorator);\n\n\t\ttry {\n\t\t\tbuilder.sessionManager(\n\t\t\t\t\tcontext.getBean(WEB_SESSION_MANAGER_BEAN_NAME, WebSessionManager.class));\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Fall back on default\n\t\t}\n\n\t\ttry {\n\t\t\tbuilder.codecConfigurer(\n\t\t\t\t\tcontext.getBean(SERVER_CODEC_CONFIGURER_BEAN_NAME, ServerCodecConfigurer.class));\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Fall back on default\n\t\t}\n\n\t\ttry {\n\t\t\tbuilder.localeContextResolver(\n\t\t\t\t\tcontext.getBean(LOCALE_CONTEXT_RESOLVER_BEAN_NAME, LocaleContextResolver.class));\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Fall back on default\n\t\t}\n\n\t\ttry {\n\t\t\tbuilder.forwardedHeaderTransformer(\n\t\t\t\t\tcontext.getBean(FORWARDED_HEADER_TRANSFORMER_BEAN_NAME, ForwardedHeaderTransformer.class));\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Fall back on default\n\t\t}\n\n\t\treturn builder;\n\t}\n\n\n\t/**\n\t * Add the given filter(s).\n\t * @param filters the filter(s) to add that's\n\t */\n\tpublic WebHttpHandlerBuilder filter(WebFilter... filters) {\n\t\tif (!ObjectUtils.isEmpty(filters)) {\n\t\t\tthis.filters.addAll(Arrays.asList(filters));\n\t\t\tupdateFilters();\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Manipulate the \"live\" list of currently configured filters.\n\t * @param consumer the consumer to use\n\t */\n\tpublic WebHttpHandlerBuilder filters(Consumer<List<WebFilter>> consumer) {\n\t\tconsumer.accept(this.filters);\n\t\tupdateFilters();\n\t\treturn this;\n\t}\n\n\tprivate void updateFilters() {\n\t\tif (this.filters.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\tList<WebFilter> filtersToUse = this.filters.stream()\n\t\t\t\t.peek(filter -> {\n\t\t\t\t\tif (filter instanceof ForwardedHeaderTransformer forwardedHeaderTransformerFilter\n\t\t\t\t\t\t\t&& this.forwardedHeaderTransformer == null) {\n\t\t\t\t\t\tthis.forwardedHeaderTransformer = forwardedHeaderTransformerFilter;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.filter(filter -> !(filter instanceof ForwardedHeaderTransformer))\n\t\t\t\t.toList();\n\n\t\tthis.filters.clear();\n\t\tthis.filters.addAll(filtersToUse);\n\t}\n\n\t/**\n\t * Add the given exception handler(s).\n\t * @param handlers the exception handler(s)\n\t */\n\tpublic WebHttpHandlerBuilder exceptionHandler(WebExceptionHandler... handlers) {\n\t\tif (!ObjectUtils.isEmpty(handlers)) {\n\t\t\tthis.exceptionHandlers.addAll(Arrays.asList(handlers));\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Manipulate the \"live\" list of currently configured exception handlers.\n\t * @param consumer the consumer to use\n\t */\n\tpublic WebHttpHandlerBuilder exceptionHandlers(Consumer<List<WebExceptionHandler>> consumer) {\n\t\tconsumer.accept(this.exceptionHandlers);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Configure the {@link WebSessionManager} to set on the\n\t * {@link ServerWebExchange WebServerExchange}.\n\t * <p>By default {@link DefaultWebSessionManager} is used.\n\t * @param manager the session manager\n\t * @see HttpWebHandlerAdapter#setSessionManager(WebSessionManager)\n\t */\n\tpublic WebHttpHandlerBuilder sessionManager(WebSessionManager manager) {\n\t\tthis.sessionManager = manager;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Whether a {@code WebSessionManager} is configured or not, either detected from an\n\t * {@code ApplicationContext} or explicitly configured via {@link #sessionManager}.\n\t * @since 5.0.9\n\t */\n\tpublic boolean hasSessionManager() {\n\t\treturn (this.sessionManager != null);\n\t}\n\n\t/**\n\t * Configure the {@link ServerCodecConfigurer} to set on the {@code WebServerExchange}.\n\t * @param codecConfigurer the codec configurer\n\t */\n\tpublic WebHttpHandlerBuilder codecConfigurer(ServerCodecConfigurer codecConfigurer) {\n\t\tthis.codecConfigurer = codecConfigurer;\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Whether a {@code ServerCodecConfigurer} is configured or not, either detected from an\n\t * {@code ApplicationContext} or explicitly configured via {@link #codecConfigurer}.\n\t * @since 5.0.9\n\t */\n\tpublic boolean hasCodecConfigurer() {\n\t\treturn (this.codecConfigurer != null);\n\t}\n\n\t/**\n\t * Configure the {@link LocaleContextResolver} to set on the\n\t * {@link ServerWebExchange WebServerExchange}.\n\t * @param localeContextResolver the locale context resolver\n\t */\n\tpublic WebHttpHandlerBuilder localeContextResolver(LocaleContextResolver localeContextResolver) {\n\t\tthis.localeContextResolver = localeContextResolver;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Whether a {@code LocaleContextResolver} is configured or not, either detected from an\n\t * {@code ApplicationContext} or explicitly configured via {@link #localeContextResolver}.\n\t * @since 5.0.9\n\t */\n\tpublic boolean hasLocaleContextResolver() {\n\t\treturn (this.localeContextResolver != null);\n\t}\n\n\t/**\n\t * Configure the {@link ForwardedHeaderTransformer} for extracting and/or\n\t * removing forwarded headers.\n\t * @param transformer the transformer\n\t * @since 5.1\n\t */\n\tpublic WebHttpHandlerBuilder forwardedHeaderTransformer(ForwardedHeaderTransformer transformer) {\n\t\tthis.forwardedHeaderTransformer = transformer;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Whether a {@code ForwardedHeaderTransformer} is configured or not, either\n\t * detected from an {@code ApplicationContext} or explicitly configured via\n\t * {@link #forwardedHeaderTransformer(ForwardedHeaderTransformer)}.\n\t * @since 5.1\n\t */\n\tpublic boolean hasForwardedHeaderTransformer() {\n\t\treturn (this.forwardedHeaderTransformer != null);\n\t}\n\n\t/**\n\t * Configure a {@link Function} to decorate the {@link HttpHandler} returned\n\t * by this builder which effectively wraps the entire\n\t * {@link WebExceptionHandler} - {@link WebFilter} - {@link WebHandler}\n\t * processing chain. This provides access to the request and response before\n\t * the entire chain and likewise the ability to observe the result of\n\t * the entire chain.\n\t * @param handlerDecorator the decorator to apply\n\t * @since 5.3\n\t */\n\tpublic WebHttpHandlerBuilder httpHandlerDecorator(Function<HttpHandler, HttpHandler> handlerDecorator) {\n\t\tthis.httpHandlerDecorator = (this.httpHandlerDecorator != null ?\n\t\t\t\thandlerDecorator.andThen(this.httpHandlerDecorator) : handlerDecorator);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Whether a decorator for {@link HttpHandler} is configured or not via\n\t * {@link #httpHandlerDecorator(Function)}.\n\t * @since 5.3\n\t */\n\tpublic boolean hasHttpHandlerDecorator() {\n\t\treturn (this.httpHandlerDecorator != null);\n\t}\n\n\t/**\n\t * Build the {@link HttpHandler}.\n\t */\n\tpublic HttpHandler build() {\n\t\tWebHandler decorated = new FilteringWebHandler(this.webHandler, this.filters);\n\t\tdecorated = new ExceptionHandlingWebHandler(decorated,  this.exceptionHandlers);\n\n\t\tHttpWebHandlerAdapter adapted = new HttpWebHandlerAdapter(decorated);\n\t\tif (this.sessionManager != null) {\n\t\t\tadapted.setSessionManager(this.sessionManager);\n\t\t}\n\t\tif (this.codecConfigurer != null) {\n\t\t\tadapted.setCodecConfigurer(this.codecConfigurer);\n\t\t}\n\t\tif (this.localeContextResolver != null) {\n\t\t\tadapted.setLocaleContextResolver(this.localeContextResolver);\n\t\t}\n\t\tif (this.forwardedHeaderTransformer != null) {\n\t\t\tadapted.setForwardedHeaderTransformer(this.forwardedHeaderTransformer);\n\t\t}\n\t\tif (this.applicationContext != null) {\n\t\t\tadapted.setApplicationContext(this.applicationContext);\n\t\t}\n\t\tadapted.afterPropertiesSet();\n\n\t\treturn (this.httpHandlerDecorator != null ? this.httpHandlerDecorator.apply(adapted) : adapted);\n\t}\n\n\t/**\n\t * Clone this {@link WebHttpHandlerBuilder}.\n\t * @return the cloned builder instance\n\t */\n\t@Override\n\tpublic WebHttpHandlerBuilder clone() {\n\t\treturn new WebHttpHandlerBuilder(this);\n\t}\n\n\n\t/**\n\t * {@code BlockHoundIntegration} for spring-web classes.\n\t * @since 5.3.6\n\t */\n\tpublic static class SpringWebBlockHoundIntegration implements BlockHoundIntegration {\n\n\t\t@Override\n\t\tpublic void applyTo(BlockHound.Builder builder) {\n\n\t\t\t// Avoid hard references potentially anywhere in spring-web (no need for structural dependency)\n\n\t\t\tbuilder.allowBlockingCallsInside(\"org.springframework.http.MediaTypeFactory\", \"<clinit>\");\n\t\t\tbuilder.allowBlockingCallsInside(\"org.springframework.web.util.HtmlUtils\", \"<clinit>\");\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#applicationContext(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create a new builder instance by detecting beans\n\t * in an {@link ApplicationContext}. The following are detected:\n\t * <ul>\n\t * <li>{@link WebHandler} [1] -- looked up by the name\n\t * {@link #WEB_HANDLER_BEAN_NAME}.\n\t * <li>{@link WebFilter} [0..N] -- detected by type and ordered,\n\t * see {@link AnnotationAwareOrderComparator}.\n\t * <li>{@link WebExceptionHandler} [0..N] -- detected by type and\n\t * ordered.\n\t * <li>{@link HttpHandlerDecoratorFactory} [0..N] -- detected by type and\n\t * ordered.\n\t * <li>{@link WebSessionManager} [0..1] -- looked up by the name\n\t * {@link #WEB_SESSION_MANAGER_BEAN_NAME}.\n\t * <li>{@link ServerCodecConfigurer} [0..1] -- looked up by the name\n\t * {@link #SERVER_CODEC_CONFIGURER_BEAN_NAME}.\n\t * <li>{@link LocaleContextResolver} [0..1] -- looked up by the name\n\t * {@link #LOCALE_CONTEXT_RESOLVER_BEAN_NAME}.\n\t * </ul>\n\t * @param context the application context to use for the lookup\n\t * @return the prepared builder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder applicationContext(ApplicationContext context)",
    "source_code": "\tpublic static WebHttpHandlerBuilder applicationContext(ApplicationContext context) {\n\n\t\tWebHttpHandlerBuilder builder = new WebHttpHandlerBuilder(\n\t\t\t\tcontext.getBean(WEB_HANDLER_BEAN_NAME, WebHandler.class), context);\n\n\t\tList<WebFilter> webFilters = context\n\t\t\t\t.getBeanProvider(WebFilter.class)\n\t\t\t\t.orderedStream()\n\t\t\t\t.toList();\n\t\tbuilder.filters(filters -> filters.addAll(webFilters));\n\n\t\tList<WebExceptionHandler> exceptionHandlers = context\n\t\t\t\t.getBeanProvider(WebExceptionHandler.class)\n\t\t\t\t.orderedStream()\n\t\t\t\t.toList();\n\t\tbuilder.exceptionHandlers(handlers -> handlers.addAll(exceptionHandlers));\n\n\t\tcontext.getBeanProvider(HttpHandlerDecoratorFactory.class)\n\t\t\t\t.orderedStream()\n\t\t\t\t.forEach(builder::httpHandlerDecorator);\n\n\t\ttry {\n\t\t\tbuilder.sessionManager(\n\t\t\t\t\tcontext.getBean(WEB_SESSION_MANAGER_BEAN_NAME, WebSessionManager.class));\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Fall back on default\n\t\t}\n\n\t\ttry {\n\t\t\tbuilder.codecConfigurer(\n\t\t\t\t\tcontext.getBean(SERVER_CODEC_CONFIGURER_BEAN_NAME, ServerCodecConfigurer.class));\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Fall back on default\n\t\t}\n\n\t\ttry {\n\t\t\tbuilder.localeContextResolver(\n\t\t\t\t\tcontext.getBean(LOCALE_CONTEXT_RESOLVER_BEAN_NAME, LocaleContextResolver.class));\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Fall back on default\n\t\t}\n\n\t\ttry {\n\t\t\tbuilder.forwardedHeaderTransformer(\n\t\t\t\t\tcontext.getBean(FORWARDED_HEADER_TRANSFORMER_BEAN_NAME, ForwardedHeaderTransformer.class));\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Fall back on default\n\t\t}\n\n\t\treturn builder;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#applyTo(builder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "builder"
    ],
    "position": {
      "column": 1,
      "line": 432
    },
    "return": "void",
    "signature": "public void applyTo(BlockHound.Builder builder)",
    "source_code": "\t\tpublic void applyTo(BlockHound.Builder builder) {\n\n\t\t\t// Avoid hard references potentially anywhere in spring-web (no need for structural dependency)\n\n\t\t\tbuilder.allowBlockingCallsInside(\"org.springframework.http.MediaTypeFactory\", \"<clinit>\");\n\t\t\tbuilder.allowBlockingCallsInside(\"org.springframework.web.util.HtmlUtils\", \"<clinit>\");\n\t\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#build()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build the {@link HttpHandler}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 390
    },
    "return": "HttpHandler",
    "signature": "public HttpHandler build()",
    "source_code": "\tpublic HttpHandler build() {\n\t\tWebHandler decorated = new FilteringWebHandler(this.webHandler, this.filters);\n\t\tdecorated = new ExceptionHandlingWebHandler(decorated,  this.exceptionHandlers);\n\n\t\tHttpWebHandlerAdapter adapted = new HttpWebHandlerAdapter(decorated);\n\t\tif (this.sessionManager != null) {\n\t\t\tadapted.setSessionManager(this.sessionManager);\n\t\t}\n\t\tif (this.codecConfigurer != null) {\n\t\t\tadapted.setCodecConfigurer(this.codecConfigurer);\n\t\t}\n\t\tif (this.localeContextResolver != null) {\n\t\t\tadapted.setLocaleContextResolver(this.localeContextResolver);\n\t\t}\n\t\tif (this.forwardedHeaderTransformer != null) {\n\t\t\tadapted.setForwardedHeaderTransformer(this.forwardedHeaderTransformer);\n\t\t}\n\t\tif (this.applicationContext != null) {\n\t\t\tadapted.setApplicationContext(this.applicationContext);\n\t\t}\n\t\tadapted.afterPropertiesSet();\n\n\t\treturn (this.httpHandlerDecorator != null ? this.httpHandlerDecorator.apply(adapted) : adapted);\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#clone()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Clone this {@link WebHttpHandlerBuilder}.\n\t * @return the cloned builder instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 420
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder clone()",
    "source_code": "\tpublic WebHttpHandlerBuilder clone() {\n\t\treturn new WebHttpHandlerBuilder(this);\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#codecConfigurer(codecConfigurer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@link ServerCodecConfigurer} to set on the {@code WebServerExchange}.\n\t * @param codecConfigurer the codec configurer\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "codecConfigurer"
    ],
    "position": {
      "column": 1,
      "line": 307
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder codecConfigurer(ServerCodecConfigurer codecConfigurer)",
    "source_code": "\tpublic WebHttpHandlerBuilder codecConfigurer(ServerCodecConfigurer codecConfigurer) {\n\t\tthis.codecConfigurer = codecConfigurer;\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#exceptionHandler(handlers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given exception handler(s).\n\t * @param handlers the exception handler(s)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handlers"
    ],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder exceptionHandler(WebExceptionHandler... handlers)",
    "source_code": "\tpublic WebHttpHandlerBuilder exceptionHandler(WebExceptionHandler... handlers) {\n\t\tif (!ObjectUtils.isEmpty(handlers)) {\n\t\t\tthis.exceptionHandlers.addAll(Arrays.asList(handlers));\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#exceptionHandlers(consumer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Manipulate the \"live\" list of currently configured exception handlers.\n\t * @param consumer the consumer to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "consumer"
    ],
    "position": {
      "column": 1,
      "line": 277
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder exceptionHandlers(Consumer<List<WebExceptionHandler>> consumer)",
    "source_code": "\tpublic WebHttpHandlerBuilder exceptionHandlers(Consumer<List<WebExceptionHandler>> consumer) {\n\t\tconsumer.accept(this.exceptionHandlers);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#filter(filters)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given filter(s).\n\t * @param filters the filter(s) to add that's\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "filters"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder filter(WebFilter... filters)",
    "source_code": "\tpublic WebHttpHandlerBuilder filter(WebFilter... filters) {\n\t\tif (!ObjectUtils.isEmpty(filters)) {\n\t\t\tthis.filters.addAll(Arrays.asList(filters));\n\t\t\tupdateFilters();\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#filters(consumer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Manipulate the \"live\" list of currently configured filters.\n\t * @param consumer the consumer to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "consumer"
    ],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder filters(Consumer<List<WebFilter>> consumer)",
    "source_code": "\tpublic WebHttpHandlerBuilder filters(Consumer<List<WebFilter>> consumer) {\n\t\tconsumer.accept(this.filters);\n\t\tupdateFilters();\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#forwardedHeaderTransformer(transformer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@link ForwardedHeaderTransformer} for extracting and/or\n\t * removing forwarded headers.\n\t * @param transformer the transformer\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "transformer"
    ],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder forwardedHeaderTransformer(ForwardedHeaderTransformer transformer)",
    "source_code": "\tpublic WebHttpHandlerBuilder forwardedHeaderTransformer(ForwardedHeaderTransformer transformer) {\n\t\tthis.forwardedHeaderTransformer = transformer;\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#hasCodecConfigurer()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether a {@code ServerCodecConfigurer} is configured or not, either detected from an\n\t * {@code ApplicationContext} or explicitly configured via {@link #codecConfigurer}.\n\t * @since 5.0.9\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 318
    },
    "return": "boolean",
    "signature": "public boolean hasCodecConfigurer()",
    "source_code": "\tpublic boolean hasCodecConfigurer() {\n\t\treturn (this.codecConfigurer != null);\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#hasForwardedHeaderTransformer()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether a {@code ForwardedHeaderTransformer} is configured or not, either\n\t * detected from an {@code ApplicationContext} or explicitly configured via\n\t * {@link #forwardedHeaderTransformer(ForwardedHeaderTransformer)}.\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 358
    },
    "return": "boolean",
    "signature": "public boolean hasForwardedHeaderTransformer()",
    "source_code": "\tpublic boolean hasForwardedHeaderTransformer() {\n\t\treturn (this.forwardedHeaderTransformer != null);\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#hasHttpHandlerDecorator()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether a decorator for {@link HttpHandler} is configured or not via\n\t * {@link #httpHandlerDecorator(Function)}.\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 383
    },
    "return": "boolean",
    "signature": "public boolean hasHttpHandlerDecorator()",
    "source_code": "\tpublic boolean hasHttpHandlerDecorator() {\n\t\treturn (this.httpHandlerDecorator != null);\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#hasLocaleContextResolver()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether a {@code LocaleContextResolver} is configured or not, either detected from an\n\t * {@code ApplicationContext} or explicitly configured via {@link #localeContextResolver}.\n\t * @since 5.0.9\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "boolean",
    "signature": "public boolean hasLocaleContextResolver()",
    "source_code": "\tpublic boolean hasLocaleContextResolver() {\n\t\treturn (this.localeContextResolver != null);\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#hasSessionManager()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether a {@code WebSessionManager} is configured or not, either detected from an\n\t * {@code ApplicationContext} or explicitly configured via {@link #sessionManager}.\n\t * @since 5.0.9\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 299
    },
    "return": "boolean",
    "signature": "public boolean hasSessionManager()",
    "source_code": "\tpublic boolean hasSessionManager() {\n\t\treturn (this.sessionManager != null);\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#httpHandlerDecorator(Function<HttpHandler,handlerDecorator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a {@link Function} to decorate the {@link HttpHandler} returned\n\t * by this builder which effectively wraps the entire\n\t * {@link WebExceptionHandler} - {@link WebFilter} - {@link WebHandler}\n\t * processing chain. This provides access to the request and response before\n\t * the entire chain and likewise the ability to observe the result of\n\t * the entire chain.\n\t * @param handlerDecorator the decorator to apply\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<HttpHandler",
      "handlerDecorator"
    ],
    "position": {
      "column": 1,
      "line": 372
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder httpHandlerDecorator(Function<HttpHandler, HttpHandler> handlerDecorator)",
    "source_code": "\tpublic WebHttpHandlerBuilder httpHandlerDecorator(Function<HttpHandler, HttpHandler> handlerDecorator) {\n\t\tthis.httpHandlerDecorator = (this.httpHandlerDecorator != null ?\n\t\t\t\thandlerDecorator.andThen(this.httpHandlerDecorator) : handlerDecorator);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#localeContextResolver(localeContextResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@link LocaleContextResolver} to set on the\n\t * {@link ServerWebExchange WebServerExchange}.\n\t * @param localeContextResolver the locale context resolver\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "localeContextResolver"
    ],
    "position": {
      "column": 1,
      "line": 327
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder localeContextResolver(LocaleContextResolver localeContextResolver)",
    "source_code": "\tpublic WebHttpHandlerBuilder localeContextResolver(LocaleContextResolver localeContextResolver) {\n\t\tthis.localeContextResolver = localeContextResolver;\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#sessionManager(manager)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@link WebSessionManager} to set on the\n\t * {@link ServerWebExchange WebServerExchange}.\n\t * <p>By default {@link DefaultWebSessionManager} is used.\n\t * @param manager the session manager\n\t * @see HttpWebHandlerAdapter#setSessionManager(WebSessionManager)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "manager"
    ],
    "position": {
      "column": 1,
      "line": 289
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder sessionManager(WebSessionManager manager)",
    "source_code": "\tpublic WebHttpHandlerBuilder sessionManager(WebSessionManager manager) {\n\t\tthis.sessionManager = manager;\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#webHandler(webHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create a new builder instance.\n\t * @param webHandler the target handler for the request\n\t * @return the prepared builder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webHandler"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder webHandler(WebHandler webHandler)",
    "source_code": "\tpublic static WebHttpHandlerBuilder webHandler(WebHandler webHandler) {\n\t\treturn new WebHttpHandlerBuilder(webHandler, null);\n\t}"
  },
  "org.springframework.web.util.PATH_ATTRIBUTE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Name of Servlet request attribute that holds the parsed {@link RequestPath}. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "signature": "public String PATH_ATTRIBUTE",
    "source_code": "\tpublic static final String PATH_ATTRIBUTE = ServletRequestPathUtils.class.getName() + \".PATH\";",
    "type": "String"
  },
  "org.springframework.web.util.ServletRequestPathUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Utility class to assist with preparation and access to the lookup path for\n * request mapping purposes. This can be the parsed {@link RequestPath}\n * representation of the path when use of\n * {@link org.springframework.web.util.pattern.PathPattern  parsed patterns}\n * is enabled or a String path for use with a\n * {@link org.springframework.util.PathMatcher} otherwise.\n *\n * @author Rossen Stoyanchev\n * @since 5.3\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "signature": "public class ServletRequestPathUtils",
    "source_code": "public abstract class ServletRequestPathUtils {\n\n\t/** Name of Servlet request attribute that holds the parsed {@link RequestPath}. */\n\tpublic static final String PATH_ATTRIBUTE = ServletRequestPathUtils.class.getName() + \".PATH\";\n\n\n\t/**\n\t * Parse the {@link HttpServletRequest#getRequestURI() requestURI} to a\n\t * {@link RequestPath} and save it in the request attribute\n\t * {@link #PATH_ATTRIBUTE} for subsequent use with\n\t * {@link org.springframework.web.util.pattern.PathPattern parsed patterns}.\n\t * <p>The returned {@code RequestPath} will have both the contextPath and any\n\t * servletPath prefix omitted from the {@link RequestPath#pathWithinApplication()\n\t * pathWithinApplication} it exposes.\n\t * <p>This method is typically called by the {@code DispatcherServlet} to determine\n\t * if any {@code HandlerMapping} indicates that it uses parsed patterns.\n\t * After that the pre-parsed and cached {@code RequestPath} can be accessed\n\t * through {@link #getParsedRequestPath(ServletRequest)}.\n\t */\n\tpublic static RequestPath parseAndCache(HttpServletRequest request) {\n\t\tRequestPath requestPath = ServletRequestPath.parse(request);\n\t\trequest.setAttribute(PATH_ATTRIBUTE, requestPath);\n\t\treturn requestPath;\n\t}\n\n\t/**\n\t * Return a {@link #parseAndCache  previously} parsed and cached {@code RequestPath}.\n\t * @throws IllegalArgumentException if not found\n\t */\n\tpublic static RequestPath getParsedRequestPath(ServletRequest request) {\n\t\tRequestPath path = (RequestPath) request.getAttribute(PATH_ATTRIBUTE);\n\t\tAssert.notNull(path, () -> \"Expected parsed RequestPath in request attribute \\\"\" + PATH_ATTRIBUTE + \"\\\".\");\n\t\treturn path;\n\t}\n\n\t/**\n\t * Set the cached, parsed {@code RequestPath} to the given value.\n\t * @param requestPath the value to set to, or if {@code null} the cache\n\t * value is cleared.\n\t * @param request the current request\n\t * @since 5.3.3\n\t */\n\tpublic static void setParsedRequestPath(@Nullable RequestPath requestPath, ServletRequest request) {\n\t\tif (requestPath != null) {\n\t\t\trequest.setAttribute(PATH_ATTRIBUTE, requestPath);\n\t\t}\n\t\telse {\n\t\t\trequest.removeAttribute(PATH_ATTRIBUTE);\n\t\t}\n\t}\n\n\t/**\n\t * Check for a {@link #parseAndCache  previously} parsed and cached {@code RequestPath}.\n\t */\n\tpublic static boolean hasParsedRequestPath(ServletRequest request) {\n\t\treturn (request.getAttribute(PATH_ATTRIBUTE) != null);\n\t}\n\n\t/**\n\t * Remove the request attribute {@link #PATH_ATTRIBUTE} that holds a\n\t * {@link #parseAndCache  previously} parsed and cached {@code RequestPath}.\n\t */\n\tpublic static void clearParsedRequestPath(ServletRequest request) {\n\t\trequest.removeAttribute(PATH_ATTRIBUTE);\n\t}\n\n\n\t// Methods to select either parsed RequestPath or resolved String lookupPath\n\n\t/**\n\t * Return the {@link UrlPathHelper#resolveAndCacheLookupPath pre-resolved}\n\t * String lookupPath or the {@link #parseAndCache(HttpServletRequest)\n\t * pre-parsed} {@code RequestPath}.\n\t * <p>In Spring MVC, when at least one {@code HandlerMapping} has parsed\n\t * {@code PathPatterns} enabled, the {@code DispatcherServlet} eagerly parses\n\t * and caches the {@code RequestPath} and the same can be also done earlier with\n\t * {@link org.springframework.web.filter.ServletRequestPathFilter\n\t * ServletRequestPathFilter}. In other cases where {@code HandlerMapping}s\n\t * use String pattern matching with {@code PathMatcher}, the String\n\t * lookupPath is resolved separately by each {@code HandlerMapping}.\n\t * @param request the current request\n\t * @return a String lookupPath or a {@code RequestPath}\n\t * @throws IllegalArgumentException if neither is available\n\t */\n\tpublic static Object getCachedPath(ServletRequest request) {\n\n\t\t// The RequestPath is pre-parsed if any HandlerMapping uses PathPatterns.\n\t\t// The lookupPath is re-resolved or cleared per HandlerMapping.\n\t\t// So check for lookupPath first.\n\n\t\tString lookupPath = (String) request.getAttribute(UrlPathHelper.PATH_ATTRIBUTE);\n\t\tif (lookupPath != null) {\n\t\t\treturn lookupPath;\n\t\t}\n\t\tRequestPath requestPath = (RequestPath) request.getAttribute(PATH_ATTRIBUTE);\n\t\tif (requestPath != null) {\n\t\t\treturn requestPath.pathWithinApplication();\n\t\t}\n\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"Neither a pre-parsed RequestPath nor a pre-resolved String lookupPath is available.\");\n\t}\n\n\t/**\n\t * Variant of {@link #getCachedPath(ServletRequest)} that returns the path\n\t * for request mapping as a String.\n\t * <p>If the cached path is a {@link #parseAndCache(HttpServletRequest)\n\t * pre-parsed} {@code RequestPath} then the returned String path value is\n\t * encoded and with path parameters removed.\n\t * <p>If the cached path is a {@link UrlPathHelper#resolveAndCacheLookupPath\n\t * pre-resolved} String lookupPath, then the returned String path value\n\t * depends on how {@link UrlPathHelper} that resolved is configured.\n\t * @param request the current request\n\t * @return the full request mapping path as a String\n\t */\n\tpublic static String getCachedPathValue(ServletRequest request) {\n\t\tObject path = getCachedPath(request);\n\t\tif (path instanceof PathContainer pathContainer) {\n\t\t\tString value = pathContainer.value();\n\t\t\tpath = UrlPathHelper.defaultInstance.removeSemicolonContent(value);\n\t\t}\n\t\treturn (String) path;\n\t}\n\n\t/**\n\t * Check for a previously {@link UrlPathHelper#resolveAndCacheLookupPath\n\t * resolved} String lookupPath or a previously {@link #parseAndCache parsed}\n\t * {@code RequestPath}.\n\t * @param request the current request\n\t * @return whether a pre-resolved or pre-parsed path is available\n\t */\n\tpublic static boolean hasCachedPath(ServletRequest request) {\n\t\treturn (request.getAttribute(PATH_ATTRIBUTE) != null ||\n\t\t\t\trequest.getAttribute(UrlPathHelper.PATH_ATTRIBUTE) != null);\n\t}\n\n\n\t/**\n\t * Simple wrapper around the default {@link RequestPath} implementation that\n\t * supports a servletPath as an additional prefix to be omitted from\n\t * {@link #pathWithinApplication()}.\n\t */\n\tprivate static final class ServletRequestPath implements RequestPath {\n\n\t\tprivate final RequestPath requestPath;\n\n\t\tprivate final PathContainer contextPath;\n\n\t\tprivate ServletRequestPath(String rawPath, @Nullable String contextPath, String servletPathPrefix) {\n\t\t\tAssert.notNull(servletPathPrefix, \"`servletPathPrefix` is required\");\n\t\t\tthis.requestPath = RequestPath.parse(rawPath, contextPath + servletPathPrefix);\n\t\t\tthis.contextPath = PathContainer.parsePath(StringUtils.hasText(contextPath) ? contextPath : \"\");\n\t\t}\n\n\t\t@Override\n\t\tpublic String value() {\n\t\t\treturn this.requestPath.value();\n\t\t}\n\n\t\t@Override\n\t\tpublic List<Element> elements() {\n\t\t\treturn this.requestPath.elements();\n\t\t}\n\n\t\t@Override\n\t\tpublic PathContainer contextPath() {\n\t\t\treturn this.contextPath;\n\t\t}\n\n\t\t@Override\n\t\tpublic PathContainer pathWithinApplication() {\n\t\t\treturn this.requestPath.pathWithinApplication();\n\t\t}\n\n\t\t@Override\n\t\tpublic RequestPath modifyContextPath(String contextPath) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\n\t\t@Override\n\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\tif (this == other) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (other == null || getClass() != other.getClass()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn (this.requestPath.equals(((ServletRequestPath) other).requestPath));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn this.requestPath.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn this.requestPath.toString();\n\t\t}\n\n\n\t\tpublic static RequestPath parse(HttpServletRequest request) {\n\t\t\tString requestUri = (String) request.getAttribute(WebUtils.INCLUDE_REQUEST_URI_ATTRIBUTE);\n\t\t\tif (requestUri == null) {\n\t\t\t\trequestUri = request.getRequestURI();\n\t\t\t}\n\n\t\t\tString servletPathPrefix = Servlet4Delegate.getServletPathPrefix(request);\n\t\t\tif (StringUtils.hasText(servletPathPrefix)) {\n\t\t\t\tif (servletPathPrefix.endsWith(\"/\")) {\n\t\t\t\t\tservletPathPrefix = servletPathPrefix.substring(0, servletPathPrefix.length() - 1);\n\t\t\t\t}\n\t\t\t\treturn new ServletRequestPath(requestUri, request.getContextPath(), servletPathPrefix);\n\t\t\t}\n\n\t\t\treturn RequestPath.parse(requestUri, request.getContextPath());\n\t\t}\n\t}\n\n\n\t/**\n\t * Inner class to avoid a hard dependency on Servlet 4 {@link HttpServletMapping}\n\t * and {@link MappingMatch} at runtime.\n\t */\n\tprivate static class Servlet4Delegate {\n\n\t\t@Nullable\n\t\tpublic static String getServletPathPrefix(HttpServletRequest request) {\n\t\t\tHttpServletMapping mapping = (HttpServletMapping) request.getAttribute(RequestDispatcher.INCLUDE_MAPPING);\n\t\t\tif (mapping == null) {\n\t\t\t\tmapping = request.getHttpServletMapping();\n\t\t\t}\n\t\t\tif (!ObjectUtils.nullSafeEquals(mapping.getMappingMatch(), MappingMatch.PATH)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tString servletPath = (String) request.getAttribute(WebUtils.INCLUDE_SERVLET_PATH_ATTRIBUTE);\n\t\t\tservletPath = (servletPath != null ? servletPath : request.getServletPath());\n\t\t\treturn UriUtils.encodePath(servletPath, StandardCharsets.UTF_8);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.util.ServletRequestPathUtils#clearParsedRequestPath(request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Remove the request attribute {@link #PATH_ATTRIBUTE} that holds a\n\t * {@link #parseAndCache  previously} parsed and cached {@code RequestPath}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "void",
    "signature": "public void clearParsedRequestPath(ServletRequest request)",
    "source_code": "\tpublic static void clearParsedRequestPath(ServletRequest request) {\n\t\trequest.removeAttribute(PATH_ATTRIBUTE);\n\t}"
  },
  "org.springframework.web.util.ServletRequestPathUtils#contextPath()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "PathContainer",
    "signature": "public PathContainer contextPath()",
    "source_code": "\t\tpublic PathContainer contextPath() {\n\t\t\treturn this.contextPath;\n\t\t}"
  },
  "org.springframework.web.util.ServletRequestPathUtils#elements()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "List<Element>",
    "signature": "public List<Element> elements()",
    "source_code": "\t\tpublic List<Element> elements() {\n\t\t\treturn this.requestPath.elements();\n\t\t}"
  },
  "org.springframework.web.util.ServletRequestPathUtils#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 226
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\tif (this == other) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (other == null || getClass() != other.getClass()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn (this.requestPath.equals(((ServletRequestPath) other).requestPath));\n\t\t}"
  },
  "org.springframework.web.util.ServletRequestPathUtils#getCachedPath(request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link UrlPathHelper#resolveAndCacheLookupPath pre-resolved}\n\t * String lookupPath or the {@link #parseAndCache(HttpServletRequest)\n\t * pre-parsed} {@code RequestPath}.\n\t * <p>In Spring MVC, when at least one {@code HandlerMapping} has parsed\n\t * {@code PathPatterns} enabled, the {@code DispatcherServlet} eagerly parses\n\t * and caches the {@code RequestPath} and the same can be also done earlier with\n\t * {@link org.springframework.web.filter.ServletRequestPathFilter\n\t * ServletRequestPathFilter}. In other cases where {@code HandlerMapping}s\n\t * use String pattern matching with {@code PathMatcher}, the String\n\t * lookupPath is resolved separately by each {@code HandlerMapping}.\n\t * @param request the current request\n\t * @return a String lookupPath or a {@code RequestPath}\n\t * @throws IllegalArgumentException if neither is available\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "Object",
    "signature": "public Object getCachedPath(ServletRequest request)",
    "source_code": "\tpublic static Object getCachedPath(ServletRequest request) {\n\n\t\t// The RequestPath is pre-parsed if any HandlerMapping uses PathPatterns.\n\t\t// The lookupPath is re-resolved or cleared per HandlerMapping.\n\t\t// So check for lookupPath first.\n\n\t\tString lookupPath = (String) request.getAttribute(UrlPathHelper.PATH_ATTRIBUTE);\n\t\tif (lookupPath != null) {\n\t\t\treturn lookupPath;\n\t\t}\n\t\tRequestPath requestPath = (RequestPath) request.getAttribute(PATH_ATTRIBUTE);\n\t\tif (requestPath != null) {\n\t\t\treturn requestPath.pathWithinApplication();\n\t\t}\n\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"Neither a pre-parsed RequestPath nor a pre-resolved String lookupPath is available.\");\n\t}"
  },
  "org.springframework.web.util.ServletRequestPathUtils#getCachedPathValue(request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #getCachedPath(ServletRequest)} that returns the path\n\t * for request mapping as a String.\n\t * <p>If the cached path is a {@link #parseAndCache(HttpServletRequest)\n\t * pre-parsed} {@code RequestPath} then the returned String path value is\n\t * encoded and with path parameters removed.\n\t * <p>If the cached path is a {@link UrlPathHelper#resolveAndCacheLookupPath\n\t * pre-resolved} String lookupPath, then the returned String path value\n\t * depends on how {@link UrlPathHelper} that resolved is configured.\n\t * @param request the current request\n\t * @return the full request mapping path as a String\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "String",
    "signature": "public String getCachedPathValue(ServletRequest request)",
    "source_code": "\tpublic static String getCachedPathValue(ServletRequest request) {\n\t\tObject path = getCachedPath(request);\n\t\tif (path instanceof PathContainer pathContainer) {\n\t\t\tString value = pathContainer.value();\n\t\t\tpath = UrlPathHelper.defaultInstance.removeSemicolonContent(value);\n\t\t}\n\t\treturn (String) path;\n\t}"
  },
  "org.springframework.web.util.ServletRequestPathUtils#getParsedRequestPath(request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link #parseAndCache  previously} parsed and cached {@code RequestPath}.\n\t * @throws IllegalArgumentException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "RequestPath",
    "signature": "public RequestPath getParsedRequestPath(ServletRequest request)",
    "source_code": "\tpublic static RequestPath getParsedRequestPath(ServletRequest request) {\n\t\tRequestPath path = (RequestPath) request.getAttribute(PATH_ATTRIBUTE);\n\t\tAssert.notNull(path, () -> \"Expected parsed RequestPath in request attribute \\\"\" + PATH_ATTRIBUTE + \"\\\".\");\n\t\treturn path;\n\t}"
  },
  "org.springframework.web.util.ServletRequestPathUtils#getServletPathPrefix(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "String",
    "signature": "public String getServletPathPrefix(HttpServletRequest request)",
    "source_code": "\t\tpublic static String getServletPathPrefix(HttpServletRequest request) {\n\t\t\tHttpServletMapping mapping = (HttpServletMapping) request.getAttribute(RequestDispatcher.INCLUDE_MAPPING);\n\t\t\tif (mapping == null) {\n\t\t\t\tmapping = request.getHttpServletMapping();\n\t\t\t}\n\t\t\tif (!ObjectUtils.nullSafeEquals(mapping.getMappingMatch(), MappingMatch.PATH)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tString servletPath = (String) request.getAttribute(WebUtils.INCLUDE_SERVLET_PATH_ATTRIBUTE);\n\t\t\tservletPath = (servletPath != null ? servletPath : request.getServletPath());\n\t\t\treturn UriUtils.encodePath(servletPath, StandardCharsets.UTF_8);\n\t\t}"
  },
  "org.springframework.web.util.ServletRequestPathUtils#hasCachedPath(request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check for a previously {@link UrlPathHelper#resolveAndCacheLookupPath\n\t * resolved} String lookupPath or a previously {@link #parseAndCache parsed}\n\t * {@code RequestPath}.\n\t * @param request the current request\n\t * @return whether a pre-resolved or pre-parsed path is available\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "boolean",
    "signature": "public boolean hasCachedPath(ServletRequest request)",
    "source_code": "\tpublic static boolean hasCachedPath(ServletRequest request) {\n\t\treturn (request.getAttribute(PATH_ATTRIBUTE) != null ||\n\t\t\t\trequest.getAttribute(UrlPathHelper.PATH_ATTRIBUTE) != null);\n\t}"
  },
  "org.springframework.web.util.ServletRequestPathUtils#hasParsedRequestPath(request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check for a {@link #parseAndCache  previously} parsed and cached {@code RequestPath}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "boolean",
    "signature": "public boolean hasParsedRequestPath(ServletRequest request)",
    "source_code": "\tpublic static boolean hasParsedRequestPath(ServletRequest request) {\n\t\treturn (request.getAttribute(PATH_ATTRIBUTE) != null);\n\t}"
  },
  "org.springframework.web.util.ServletRequestPathUtils#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\t\tpublic int hashCode() {\n\t\t\treturn this.requestPath.hashCode();\n\t\t}"
  },
  "org.springframework.web.util.ServletRequestPathUtils#modifyContextPath(contextPath)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contextPath"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "RequestPath",
    "signature": "public RequestPath modifyContextPath(String contextPath)",
    "source_code": "\t\tpublic RequestPath modifyContextPath(String contextPath) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.web.util.ServletRequestPathUtils#parse(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 247
    },
    "return": "RequestPath",
    "signature": "public RequestPath parse(HttpServletRequest request)",
    "source_code": "\t\tpublic static RequestPath parse(HttpServletRequest request) {\n\t\t\tString requestUri = (String) request.getAttribute(WebUtils.INCLUDE_REQUEST_URI_ATTRIBUTE);\n\t\t\tif (requestUri == null) {\n\t\t\t\trequestUri = request.getRequestURI();\n\t\t\t}\n\n\t\t\tString servletPathPrefix = Servlet4Delegate.getServletPathPrefix(request);\n\t\t\tif (StringUtils.hasText(servletPathPrefix)) {\n\t\t\t\tif (servletPathPrefix.endsWith(\"/\")) {\n\t\t\t\t\tservletPathPrefix = servletPathPrefix.substring(0, servletPathPrefix.length() - 1);\n\t\t\t\t}\n\t\t\t\treturn new ServletRequestPath(requestUri, request.getContextPath(), servletPathPrefix);\n\t\t\t}\n\n\t\t\treturn RequestPath.parse(requestUri, request.getContextPath());\n\t\t}"
  },
  "org.springframework.web.util.ServletRequestPathUtils#parseAndCache(request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the {@link HttpServletRequest#getRequestURI() requestURI} to a\n\t * {@link RequestPath} and save it in the request attribute\n\t * {@link #PATH_ATTRIBUTE} for subsequent use with\n\t * {@link org.springframework.web.util.pattern.PathPattern parsed patterns}.\n\t * <p>The returned {@code RequestPath} will have both the contextPath and any\n\t * servletPath prefix omitted from the {@link RequestPath#pathWithinApplication()\n\t * pathWithinApplication} it exposes.\n\t * <p>This method is typically called by the {@code DispatcherServlet} to determine\n\t * if any {@code HandlerMapping} indicates that it uses parsed patterns.\n\t * After that the pre-parsed and cached {@code RequestPath} can be accessed\n\t * through {@link #getParsedRequestPath(ServletRequest)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "RequestPath",
    "signature": "public RequestPath parseAndCache(HttpServletRequest request)",
    "source_code": "\tpublic static RequestPath parseAndCache(HttpServletRequest request) {\n\t\tRequestPath requestPath = ServletRequestPath.parse(request);\n\t\trequest.setAttribute(PATH_ATTRIBUTE, requestPath);\n\t\treturn requestPath;\n\t}"
  },
  "org.springframework.web.util.ServletRequestPathUtils#pathWithinApplication()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "PathContainer",
    "signature": "public PathContainer pathWithinApplication()",
    "source_code": "\t\tpublic PathContainer pathWithinApplication() {\n\t\t\treturn this.requestPath.pathWithinApplication();\n\t\t}"
  },
  "org.springframework.web.util.ServletRequestPathUtils#setParsedRequestPath(requestPath,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the cached, parsed {@code RequestPath} to the given value.\n\t * @param requestPath the value to set to, or if {@code null} the cache\n\t * value is cleared.\n\t * @param request the current request\n\t * @since 5.3.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestPath",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "void",
    "signature": "public void setParsedRequestPath(@Nullable RequestPath requestPath, ServletRequest request)",
    "source_code": "\tpublic static void setParsedRequestPath(@Nullable RequestPath requestPath, ServletRequest request) {\n\t\tif (requestPath != null) {\n\t\t\trequest.setAttribute(PATH_ATTRIBUTE, requestPath);\n\t\t}\n\t\telse {\n\t\t\trequest.removeAttribute(PATH_ATTRIBUTE);\n\t\t}\n\t}"
  },
  "org.springframework.web.util.ServletRequestPathUtils#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn this.requestPath.toString();\n\t\t}"
  },
  "org.springframework.web.util.ServletRequestPathUtils#value()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "String",
    "signature": "public String value()",
    "source_code": "\t\tpublic String value() {\n\t\t\treturn this.requestPath.value();\n\t\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Builder for {@link UriComponents}.\n *\n * <p>Typical usage involves:\n * <ol>\n * <li>Create a {@code UriComponentsBuilder} with one of the static factory methods\n * (such as {@link #fromPath(String)} or {@link #fromUri(URI)})</li>\n * <li>Set the various URI components through the respective methods ({@link #scheme(String)},\n * {@link #userInfo(String)}, {@link #host(String)}, {@link #port(int)}, {@link #path(String)},\n * {@link #pathSegment(String...)}, {@link #queryParam(String, Object...)}, and\n * {@link #fragment(String)}.</li>\n * <li>Build the {@link UriComponents} instance with the {@link #build()} method.</li>\n * </ol>\n *\n * @author Arjen Poutsma\n * @author Rossen Stoyanchev\n * @author Phillip Webb\n * @author Oliver Gierke\n * @author Brian Clozel\n * @author Sebastien Deleuze\n * @author Sam Brannen\n * @since 3.1\n * @see #newInstance()\n * @see #fromPath(String)\n * @see #fromUri(URI)\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "signature": "public class UriComponentsBuilder",
    "source_code": "public class UriComponentsBuilder implements UriBuilder, Cloneable {\n\n\tprivate static final Pattern QUERY_PARAM_PATTERN = Pattern.compile(\"([^&=]+)(=?)([^&]+)?\");\n\n\tprivate static final String SCHEME_PATTERN = \"([^:/?#]+):\";\n\n\tprivate static final String HTTP_PATTERN = \"(?i)(http|https):\";\n\n\tprivate static final String USERINFO_PATTERN = \"([^@\\\\[/?#]*)\";\n\n\tprivate static final String HOST_IPV4_PATTERN = \"[^\\\\[/?#:]*\";\n\n\tprivate static final String HOST_IPV6_PATTERN = \"\\\\[[\\\\p{XDigit}:.]*[%\\\\p{Alnum}]*]\";\n\n\tprivate static final String HOST_PATTERN = \"(\" + HOST_IPV6_PATTERN + \"|\" + HOST_IPV4_PATTERN + \")\";\n\n\tprivate static final String PORT_PATTERN = \"(\\\\{[^}]+\\\\}?|[^/?#]*)\";"
  },
  "org.springframework.web.util.UriComponentsBuilder#addPath(path)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path"
    ],
    "position": {
      "column": 1,
      "line": 975
    },
    "return": "void",
    "signature": "public void addPath(String path)",
    "source_code": "\t\tpublic void addPath(String path) {\n\t\t\tif (StringUtils.hasText(path)) {\n\t\t\t\tPathSegmentComponentBuilder psBuilder = getLastBuilder(PathSegmentComponentBuilder.class);\n\t\t\t\tFullPathComponentBuilder fpBuilder = getLastBuilder(FullPathComponentBuilder.class);\n\t\t\t\tif (psBuilder != null) {\n\t\t\t\t\tpath = (path.startsWith(\"/\") ? path : \"/\" + path);\n\t\t\t\t}\n\t\t\t\tif (fpBuilder == null) {\n\t\t\t\t\tfpBuilder = new FullPathComponentBuilder();\n\t\t\t\t\tthis.builders.add(fpBuilder);\n\t\t\t\t}\n\t\t\t\tfpBuilder.append(path);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#addPathSegments(pathSegments)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pathSegments"
    ],
    "position": {
      "column": 1,
      "line": 960
    },
    "return": "void",
    "signature": "public void addPathSegments(String... pathSegments)",
    "source_code": "\t\tpublic void addPathSegments(String... pathSegments) {\n\t\t\tif (!ObjectUtils.isEmpty(pathSegments)) {\n\t\t\t\tPathSegmentComponentBuilder psBuilder = getLastBuilder(PathSegmentComponentBuilder.class);\n\t\t\t\tFullPathComponentBuilder fpBuilder = getLastBuilder(FullPathComponentBuilder.class);\n\t\t\t\tif (psBuilder == null) {\n\t\t\t\t\tpsBuilder = new PathSegmentComponentBuilder();\n\t\t\t\t\tthis.builders.add(psBuilder);\n\t\t\t\t\tif (fpBuilder != null) {\n\t\t\t\t\t\tfpBuilder.removeTrailingSlash();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpsBuilder.append(pathSegments);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#append(path)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path"
    ],
    "position": {
      "column": 1,
      "line": 1036
    },
    "return": "void",
    "signature": "public void append(String path)",
    "source_code": "\t\tpublic void append(String path) {\n\t\t\tthis.path.append(path);\n\t\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#append(pathSegments)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pathSegments"
    ],
    "position": {
      "column": 1,
      "line": 1082
    },
    "return": "void",
    "signature": "public void append(String... pathSegments)",
    "source_code": "\t\tpublic void append(String... pathSegments) {\n\t\t\tfor (String pathSegment : pathSegments) {\n\t\t\t\tif (StringUtils.hasText(pathSegment)) {\n\t\t\t\t\tthis.pathSegments.add(pathSegment);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#build()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1091
    },
    "return": "PathComponent",
    "signature": "public PathComponent build()",
    "source_code": "\t\tpublic PathComponent build() {\n\t\t\treturn (this.pathSegments.isEmpty() ? null :\n\t\t\t\t\tnew HierarchicalUriComponents.PathSegmentComponent(this.pathSegments));\n\t\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#build(Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 522
    },
    "return": "URI",
    "signature": "public URI build(Map<String, ?> uriVariables)",
    "source_code": "\tpublic URI build(Map<String, ?> uriVariables) {\n\t\treturn buildInternal(EncodingHint.ENCODE_TEMPLATE).expand(uriVariables).toUri();\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#build(encoded)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #build()} to create a {@link UriComponents} instance\n\t * when components are already fully encoded. This is useful for example if\n\t * the builder was created via {@link UriComponentsBuilder#fromUri(URI)}.\n\t * @param encoded whether the components in this builder are already encoded\n\t * @return the URI components\n\t * @throws IllegalArgumentException if any of the components contain illegal\n\t * characters that should have been encoded.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encoded"
    ],
    "position": {
      "column": 1,
      "line": 471
    },
    "return": "UriComponents",
    "signature": "public UriComponents build(boolean encoded)",
    "source_code": "\tpublic UriComponents build(boolean encoded) {\n\t\treturn buildInternal(encoded ? EncodingHint.FULLY_ENCODED :\n\t\t\t\t(this.encodeTemplate ? EncodingHint.ENCODE_TEMPLATE : EncodingHint.NONE));\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#build(uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 517
    },
    "return": "URI",
    "signature": "public URI build(Object... uriVariables)",
    "source_code": "\tpublic URI build(Object... uriVariables) {\n\t\treturn buildInternal(EncodingHint.ENCODE_TEMPLATE).expand(uriVariables).toUri();\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#buildAndExpand(Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@code UriComponents} instance and replaces URI template variables\n\t * with the values from a map. This is a shortcut method which combines\n\t * calls to {@link #build()} and then {@link UriComponents#expand(Map)}.\n\t * @param uriVariables the map of URI variables\n\t * @return the URI components with expanded values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 501
    },
    "return": "UriComponents",
    "signature": "public UriComponents buildAndExpand(Map<String, ?> uriVariables)",
    "source_code": "\tpublic UriComponents buildAndExpand(Map<String, ?> uriVariables) {\n\t\treturn build().expand(uriVariables);\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#buildAndExpand(uriVariableValues)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@code UriComponents} instance and replaces URI template variables\n\t * with the values from an array. This is a shortcut method which combines\n\t * calls to {@link #build()} and then {@link UriComponents#expand(Object...)}.\n\t * @param uriVariableValues the URI variable values\n\t * @return the URI components with expanded values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriVariableValues"
    ],
    "position": {
      "column": 1,
      "line": 512
    },
    "return": "UriComponents",
    "signature": "public UriComponents buildAndExpand(Object... uriVariableValues)",
    "source_code": "\tpublic UriComponents buildAndExpand(Object... uriVariableValues) {\n\t\treturn build().expand(uriVariableValues);\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#clone()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Public declaration of Object's {@code clone()} method.\n\t * Delegates to {@link #cloneBuilder()}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 933
    },
    "return": "Object",
    "signature": "public Object clone()",
    "source_code": "\tpublic Object clone() {\n\t\treturn cloneBuilder();\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#cloneBuilder()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1097
    },
    "return": "PathSegmentComponentBuilder",
    "signature": "public PathSegmentComponentBuilder cloneBuilder()",
    "source_code": "\t\tpublic PathSegmentComponentBuilder cloneBuilder() {\n\t\t\tPathSegmentComponentBuilder builder = new PathSegmentComponentBuilder();\n\t\t\tbuilder.pathSegments.addAll(this.pathSegments);\n\t\t\treturn builder;\n\t\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#encode()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Request to have the URI template pre-encoded at build time, and\n\t * URI variables encoded separately when expanded.\n\t * <p>In comparison to {@link UriComponents#encode()}, this method has the\n\t * same effect on the URI template, i.e. each URI component is encoded by\n\t * replacing non-ASCII and illegal (within the URI component type) characters\n\t * with escaped octets. However URI variables are encoded more strictly, by\n\t * also escaping characters with reserved meaning.\n\t * <p>For most cases, this method is more likely to give the expected result\n\t * because in treats URI variables as opaque data to be fully encoded, while\n\t * {@link UriComponents#encode()} is useful when intentionally expanding URI\n\t * variables that contain reserved characters.\n\t * <p>For example ';' is legal in a path but has reserved meaning. This\n\t * method replaces \";\" with \"%3B\" in URI variables but not in the URI\n\t * template. By contrast, {@link UriComponents#encode()} never replaces \";\"\n\t * since it is a legal character in a path.\n\t * <p>When not expanding URI variables at all, prefer use of\n\t * {@link UriComponents#encode()} since that will also encode anything that\n\t * incidentally looks like a URI variable.\n\t * @since 5.0.8\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 436
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder encode()",
    "source_code": "\tpublic final UriComponentsBuilder encode() {\n\t\treturn encode(StandardCharsets.UTF_8);\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#encode(charset)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A variant of {@link #encode()} with a charset other than \"UTF-8\".\n\t * @param charset the charset to use for encoding\n\t * @since 5.0.8\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 445
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder encode(Charset charset)",
    "source_code": "\tpublic UriComponentsBuilder encode(Charset charset) {\n\t\tthis.encodeTemplate = true;\n\t\tthis.charset = charset;\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#fragment(fragment)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fragment"
    ],
    "position": {
      "column": 1,
      "line": 797
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder fragment(@Nullable String fragment)",
    "source_code": "\tpublic UriComponentsBuilder fragment(@Nullable String fragment) {\n\t\tif (fragment != null) {\n\t\t\tAssert.hasLength(fragment, \"Fragment must not be empty\");\n\t\t\tthis.fragment = fragment;\n\t\t}\n\t\telse {\n\t\t\tthis.fragment = null;\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#fromHttpRequest(request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@code UriComponents} object from the URI associated with\n\t * the given HttpRequest while also overlaying with values from the headers\n\t * \"Forwarded\" (<a href=\"https://tools.ietf.org/html/rfc7239\">RFC 7239</a>),\n\t * or \"X-Forwarded-Host\", \"X-Forwarded-Port\", and \"X-Forwarded-Proto\" if\n\t * \"Forwarded\" is not found.\n\t * @param request the source request\n\t * @return the URI components of the URI\n\t * @since 4.1.5\n\t * @see #parseForwardedFor(HttpRequest, InetSocketAddress)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 331
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder fromHttpRequest(HttpRequest request)",
    "source_code": "\tpublic static UriComponentsBuilder fromHttpRequest(HttpRequest request) {\n\t\treturn fromUri(request.getURI()).adaptFromForwardedHeaders(request.getHeaders());\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#fromHttpUrl(httpUrl)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a URI components builder from the given HTTP URL String.\n\t * <p><strong>Note:</strong> The presence of reserved characters can prevent\n\t * correct parsing of the URI string. For example if a query parameter\n\t * contains {@code '='} or {@code '&'} characters, the query string cannot\n\t * be parsed unambiguously. Such values should be substituted for URI\n\t * variables to enable correct parsing:\n\t * <pre class=\"code\">\n\t * String urlString = &quot;https://example.com/hotels/42?filter={value}&quot;;\n\t * UriComponentsBuilder.fromHttpUrl(urlString).buildAndExpand(&quot;hot&amp;cold&quot;);\n\t * </pre>\n\t * @param httpUrl the source URI\n\t * @return the URI components of the URI\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "httpUrl"
    ],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder fromHttpUrl(String httpUrl)",
    "source_code": "\tpublic static UriComponentsBuilder fromHttpUrl(String httpUrl) {\n\t\tAssert.notNull(httpUrl, \"HTTP URL must not be null\");\n\t\tMatcher matcher = HTTP_URL_PATTERN.matcher(httpUrl);\n\t\tif (matcher.matches()) {\n\t\t\tUriComponentsBuilder builder = new UriComponentsBuilder();\n\t\t\tString scheme = matcher.group(1);\n\t\t\tbuilder.scheme(scheme != null ? scheme.toLowerCase() : null);\n\t\t\tbuilder.userInfo(matcher.group(4));\n\t\t\tString host = matcher.group(5);\n\t\t\tif (StringUtils.hasLength(scheme) && !StringUtils.hasLength(host)) {\n\t\t\t\tthrow new IllegalArgumentException(\"[\" + httpUrl + \"] is not a valid HTTP URL\");\n\t\t\t}\n\t\t\tbuilder.host(host);\n\t\t\tString port = matcher.group(7);\n\t\t\tif (StringUtils.hasLength(port)) {\n\t\t\t\tbuilder.port(port);\n\t\t\t}\n\t\t\tbuilder.path(matcher.group(8));\n\t\t\tbuilder.query(matcher.group(10));\n\t\t\tString fragment = matcher.group(12);\n\t\t\tif (StringUtils.hasText(fragment)) {\n\t\t\t\tbuilder.fragment(fragment);\n\t\t\t}\n\t\t\treturn builder;\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"[\" + httpUrl + \"] is not a valid HTTP URL\");\n\t\t}\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#fromOriginHeader(origin)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an instance by parsing the \"Origin\" header of an HTTP request.\n\t * @see <a href=\"https://tools.ietf.org/html/rfc6454\">RFC 6454</a>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "origin"
    ],
    "position": {
      "column": 1,
      "line": 391
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder fromOriginHeader(String origin)",
    "source_code": "\tpublic static UriComponentsBuilder fromOriginHeader(String origin) {\n\t\tMatcher matcher = URI_PATTERN.matcher(origin);\n\t\tif (matcher.matches()) {\n\t\t\tUriComponentsBuilder builder = new UriComponentsBuilder();\n\t\t\tString scheme = matcher.group(2);\n\t\t\tString host = matcher.group(6);\n\t\t\tString port = matcher.group(8);\n\t\t\tif (StringUtils.hasLength(scheme)) {\n\t\t\t\tbuilder.scheme(scheme);\n\t\t\t}\n\t\t\tbuilder.host(host);\n\t\t\tif (StringUtils.hasLength(port)) {\n\t\t\t\tbuilder.port(port);\n\t\t\t}\n\t\t\treturn builder;\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"[\" + origin + \"] is not a valid \\\"Origin\\\" header value\");\n\t\t}\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#fromPath(path)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a builder that is initialized with the given path.\n\t * @param path the path to initialize with\n\t * @return the new {@code UriComponentsBuilder}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path"
    ],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder fromPath(String path)",
    "source_code": "\tpublic static UriComponentsBuilder fromPath(String path) {\n\t\tUriComponentsBuilder builder = new UriComponentsBuilder();\n\t\tbuilder.path(path);\n\t\treturn builder;\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#fromUri(uri)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a builder that is initialized from the given {@code URI}.\n\t * <p><strong>Note:</strong> the components in the resulting builder will be\n\t * in fully encoded (raw) form and further changes must also supply values\n\t * that are fully encoded, for example via methods in {@link UriUtils}.\n\t * In addition please use {@link #build(boolean)} with a value of \"true\" to\n\t * build the {@link UriComponents} instance in order to indicate that the\n\t * components are encoded.\n\t * @param uri the URI to initialize with\n\t * @return the new {@code UriComponentsBuilder}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uri"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder fromUri(URI uri)",
    "source_code": "\tpublic static UriComponentsBuilder fromUri(URI uri) {\n\t\tUriComponentsBuilder builder = new UriComponentsBuilder();\n\t\tbuilder.uri(uri);\n\t\treturn builder;\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#fromUriString(uri)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a builder that is initialized with the given URI string.\n\t * <p><strong>Note:</strong> The presence of reserved characters can prevent\n\t * correct parsing of the URI string. For example if a query parameter\n\t * contains {@code '='} or {@code '&'} characters, the query string cannot\n\t * be parsed unambiguously. Such values should be substituted for URI\n\t * variables to enable correct parsing:\n\t * <pre class=\"code\">\n\t * String uriString = &quot;/hotels/42?filter={value}&quot;;\n\t * UriComponentsBuilder.fromUriString(uriString).buildAndExpand(&quot;hot&amp;cold&quot;);\n\t * </pre>\n\t * @param uri the URI string to initialize with\n\t * @return the new {@code UriComponentsBuilder}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uri"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder fromUriString(String uri)",
    "source_code": "\tpublic static UriComponentsBuilder fromUriString(String uri) {\n\t\tAssert.notNull(uri, \"URI must not be null\");\n\t\tMatcher matcher = URI_PATTERN.matcher(uri);\n\t\tif (matcher.matches()) {\n\t\t\tUriComponentsBuilder builder = new UriComponentsBuilder();\n\t\t\tString scheme = matcher.group(2);\n\t\t\tString userInfo = matcher.group(5);\n\t\t\tString host = matcher.group(6);\n\t\t\tString port = matcher.group(8);\n\t\t\tString path = matcher.group(9);\n\t\t\tString query = matcher.group(11);\n\t\t\tString fragment = matcher.group(13);\n\t\t\tboolean opaque = false;\n\t\t\tif (StringUtils.hasLength(scheme)) {\n\t\t\t\tString rest = uri.substring(scheme.length());\n\t\t\t\tif (!rest.startsWith(\":/\")) {\n\t\t\t\t\topaque = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuilder.scheme(scheme);\n\t\t\tif (opaque) {\n\t\t\t\tString ssp = uri.substring(scheme.length() + 1);\n\t\t\t\tif (StringUtils.hasLength(fragment)) {\n\t\t\t\t\tssp = ssp.substring(0, ssp.length() - (fragment.length() + 1));\n\t\t\t\t}\n\t\t\t\tbuilder.schemeSpecificPart(ssp);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (StringUtils.hasLength(scheme) && scheme.startsWith(\"http\") && !StringUtils.hasLength(host)) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"[\" + uri + \"] is not a valid HTTP URL\");\n\t\t\t\t}\n\t\t\t\tbuilder.userInfo(userInfo);\n\t\t\t\tbuilder.host(host);\n\t\t\t\tif (StringUtils.hasLength(port)) {\n\t\t\t\t\tbuilder.port(port);\n\t\t\t\t}\n\t\t\t\tbuilder.path(path);\n\t\t\t\tbuilder.query(query);\n\t\t\t}\n\t\t\tif (StringUtils.hasText(fragment)) {\n\t\t\t\tbuilder.fragment(fragment);\n\t\t\t}\n\t\t\treturn builder;\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"[\" + uri + \"] is not a valid URI\");\n\t\t}\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#host(host)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "host"
    ],
    "position": {
      "column": 1,
      "line": 631
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder host(@Nullable String host)",
    "source_code": "\tpublic UriComponentsBuilder host(@Nullable String host) {\n\t\tthis.host = host;\n\t\tif (host != null) {\n\t\t\tresetSchemeSpecificPart();\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#newInstance()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new, empty builder.\n\t * @return the new {@code UriComponentsBuilder}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder newInstance()",
    "source_code": "\tpublic static UriComponentsBuilder newInstance() {\n\t\treturn new UriComponentsBuilder();\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#parseForwardedFor(request,remoteAddress)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the first \"Forwarded: for=...\" or \"X-Forwarded-For\" header value to\n\t * an {@code InetSocketAddress} representing the address of the client.\n\t * @param request a request with headers that may contain forwarded headers\n\t * @param remoteAddress the current remoteAddress\n\t * @return an {@code InetSocketAddress} with the extracted host and port, or\n\t * {@code null} if the headers are not present.\n\t * @since 5.3\n\t * @see <a href=\"https://tools.ietf.org/html/rfc7239#section-5.2\">RFC 7239, Section 5.2</a>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "remoteAddress"
    ],
    "position": {
      "column": 1,
      "line": 346
    },
    "return": "InetSocketAddress",
    "signature": "public InetSocketAddress parseForwardedFor(HttpRequest request, @Nullable InetSocketAddress remoteAddress)",
    "source_code": "\tpublic static InetSocketAddress parseForwardedFor("
  },
  "org.springframework.web.util.UriComponentsBuilder#path(path)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path"
    ],
    "position": {
      "column": 1,
      "line": 659
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder path(String path)",
    "source_code": "\tpublic UriComponentsBuilder path(String path) {\n\t\tthis.pathBuilder.addPath(path);\n\t\tresetSchemeSpecificPart();\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#pathSegment(pathSegments)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pathSegments"
    ],
    "position": {
      "column": 1,
      "line": 666
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder pathSegment(String... pathSegments)",
    "source_code": "\tpublic UriComponentsBuilder pathSegment(String... pathSegments) throws IllegalArgumentException {\n\t\tthis.pathBuilder.addPathSegments(pathSegments);\n\t\tresetSchemeSpecificPart();\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#port(port)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "port"
    ],
    "position": {
      "column": 1,
      "line": 650
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder port(@Nullable String port)",
    "source_code": "\tpublic UriComponentsBuilder port(@Nullable String port) {\n\t\tthis.port = port;\n\t\tif (port != null) {\n\t\t\tresetSchemeSpecificPart();\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#query(query)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "query"
    ],
    "position": {
      "column": 1,
      "line": 683
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder query(@Nullable String query)",
    "source_code": "\tpublic UriComponentsBuilder query(@Nullable String query) {\n\t\tif (query != null) {\n\t\t\tMatcher matcher = QUERY_PARAM_PATTERN.matcher(query);\n\t\t\twhile (matcher.find()) {\n\t\t\t\tString name = matcher.group(1);\n\t\t\t\tString eq = matcher.group(2);\n\t\t\t\tString value = matcher.group(3);\n\t\t\t\tqueryParam(name, (value != null ? value : (StringUtils.hasLength(eq) ? \"\" : null)));\n\t\t\t}\n\t\t\tresetSchemeSpecificPart();\n\t\t}\n\t\telse {\n\t\t\tthis.queryParams.clear();\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#queryParam(name,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 737
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder queryParam(String name, @Nullable Collection<?> values)",
    "source_code": "\tpublic UriComponentsBuilder queryParam(String name, @Nullable Collection<?> values) {\n\t\treturn queryParam(name, (CollectionUtils.isEmpty(values) ? EMPTY_VALUES : values.toArray()));\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#queryParamIfPresent(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 742
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder queryParamIfPresent(String name, Optional<?> value)",
    "source_code": "\tpublic UriComponentsBuilder queryParamIfPresent(String name, Optional<?> value) {\n\t\tvalue.ifPresent(v -> {\n\t\t\tif (v instanceof Collection<?> values) {\n\t\t\t\tqueryParam(name, values);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tqueryParam(name, v);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#queryParams(MultiValueMap<String,params)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * @since 4.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 759
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder queryParams(@Nullable MultiValueMap<String, String> params)",
    "source_code": "\tpublic UriComponentsBuilder queryParams(@Nullable MultiValueMap<String, String> params) {\n\t\tif (params != null) {\n\t\t\tthis.queryParams.addAll(params);\n\t\t\tresetSchemeSpecificPart();\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#removeTrailingSlash()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1062
    },
    "return": "void",
    "signature": "public void removeTrailingSlash()",
    "source_code": "\t\tpublic void removeTrailingSlash() {\n\t\t\tint index = this.path.length() - 1;\n\t\t\tif (this.path.charAt(index) == '/') {\n\t\t\t\tthis.path.deleteCharAt(index);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#replacePath(path)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path"
    ],
    "position": {
      "column": 1,
      "line": 673
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder replacePath(@Nullable String path)",
    "source_code": "\tpublic UriComponentsBuilder replacePath(@Nullable String path) {\n\t\tthis.pathBuilder = new CompositePathComponentBuilder();\n\t\tif (path != null) {\n\t\t\tthis.pathBuilder.addPath(path);\n\t\t}\n\t\tresetSchemeSpecificPart();\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#replaceQuery(query)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "query"
    ],
    "position": {
      "column": 1,
      "line": 701
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder replaceQuery(@Nullable String query)",
    "source_code": "\tpublic UriComponentsBuilder replaceQuery(@Nullable String query) {\n\t\tthis.queryParams.clear();\n\t\tif (query != null) {\n\t\t\tquery(query);\n\t\t\tresetSchemeSpecificPart();\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#replaceQueryParam(name,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 779
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder replaceQueryParam(String name, @Nullable Collection<?> values)",
    "source_code": "\tpublic UriComponentsBuilder replaceQueryParam(String name, @Nullable Collection<?> values) {\n\t\treturn replaceQueryParam(name, (CollectionUtils.isEmpty(values) ? EMPTY_VALUES : values.toArray()));\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#replaceQueryParams(MultiValueMap<String,params)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 788
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder replaceQueryParams(@Nullable MultiValueMap<String, String> params)",
    "source_code": "\tpublic UriComponentsBuilder replaceQueryParams(@Nullable MultiValueMap<String, String> params) {\n\t\tthis.queryParams.clear();\n\t\tif (params != null) {\n\t\t\tthis.queryParams.putAll(params);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#scheme(scheme)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scheme"
    ],
    "position": {
      "column": 1,
      "line": 604
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder scheme(@Nullable String scheme)",
    "source_code": "\tpublic UriComponentsBuilder scheme(@Nullable String scheme) {\n\t\tthis.scheme = scheme;\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#schemeSpecificPart(ssp)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the URI scheme-specific-part. When invoked, this method overwrites\n\t * {@linkplain #userInfo(String) user-info}, {@linkplain #host(String) host},\n\t * {@linkplain #port(int) port}, {@linkplain #path(String) path}, and\n\t * {@link #query(String) query}.\n\t * @param ssp the URI scheme-specific-part, may contain URI template parameters\n\t * @return this UriComponentsBuilder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ssp"
    ],
    "position": {
      "column": 1,
      "line": 617
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder schemeSpecificPart(String ssp)",
    "source_code": "\tpublic UriComponentsBuilder schemeSpecificPart(String ssp) {\n\t\tthis.ssp = ssp;\n\t\tresetHierarchicalComponents();\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#toUriString()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a URI String.\n\t * <p>Effectively, a shortcut for building, encoding, and returning the\n\t * String representation:\n\t * <pre class=\"code\">\n\t * String uri = builder.build().encode().toUriString()\n\t * </pre>\n\t * <p>However if {@link #uriVariables(Map) URI variables} have been provided\n\t * then the URI template is pre-encoded separately from URI variables (see\n\t * {@link #encode()} for details), i.e. equivalent to:\n\t * <pre>\n\t * String uri = builder.encode().build().toUriString()\n\t * </pre>\n\t * @since 4.1\n\t * @see UriComponents#toUriString()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 542
    },
    "return": "String",
    "signature": "public String toUriString()",
    "source_code": "\tpublic String toUriString() {\n\t\treturn (this.uriVariables.isEmpty() ? build().encode().toUriString() :\n\t\t\t\tbuildInternal(EncodingHint.ENCODE_TEMPLATE).toUriString());\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#uri(uri)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize components of this builder from components of the given URI.\n\t * @param uri the URI\n\t * @return this UriComponentsBuilder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uri"
    ],
    "position": {
      "column": 1,
      "line": 555
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder uri(URI uri)",
    "source_code": "\tpublic UriComponentsBuilder uri(URI uri) {\n\t\tAssert.notNull(uri, \"URI must not be null\");\n\t\tthis.scheme = uri.getScheme();\n\t\tif (uri.isOpaque()) {\n\t\t\tthis.ssp = uri.getRawSchemeSpecificPart();\n\t\t\tresetHierarchicalComponents();\n\t\t}\n\t\telse {\n\t\t\tif (uri.getRawUserInfo() != null) {\n\t\t\t\tthis.userInfo = uri.getRawUserInfo();\n\t\t\t}\n\t\t\tif (uri.getHost() != null) {\n\t\t\t\tthis.host = uri.getHost();\n\t\t\t}\n\t\t\tif (uri.getPort() != -1) {\n\t\t\t\tthis.port = String.valueOf(uri.getPort());\n\t\t\t}\n\t\t\tif (StringUtils.hasLength(uri.getRawPath())) {\n\t\t\t\tthis.pathBuilder = new CompositePathComponentBuilder();\n\t\t\t\tthis.pathBuilder.addPath(uri.getRawPath());\n\t\t\t}\n\t\t\tif (StringUtils.hasLength(uri.getRawQuery())) {\n\t\t\t\tthis.queryParams.clear();\n\t\t\t\tquery(uri.getRawQuery());\n\t\t\t}\n\t\t\tresetSchemeSpecificPart();\n\t\t}\n\t\tif (uri.getRawFragment() != null) {\n\t\t\tthis.fragment = uri.getRawFragment();\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#uriComponents(uriComponents)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set or append individual URI components of this builder from the values\n\t * of the given {@link UriComponents} instance.\n\t * <p>For the semantics of each component (i.e. set vs append) check the\n\t * builder methods on this class. For example {@link #host(String)} sets\n\t * while {@link #path(String)} appends.\n\t * @param uriComponents the UriComponents to copy from\n\t * @return this UriComponentsBuilder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriComponents"
    ],
    "position": {
      "column": 1,
      "line": 597
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder uriComponents(UriComponents uriComponents)",
    "source_code": "\tpublic UriComponentsBuilder uriComponents(UriComponents uriComponents) {\n\t\tAssert.notNull(uriComponents, \"UriComponents must not be null\");\n\t\turiComponents.copyToUriComponentsBuilder(this);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#uriVariables(Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure URI variables to be expanded at build time.\n\t * <p>The provided variables may be a subset of all required ones. At build\n\t * time, the available ones are expanded, while unresolved URI placeholders\n\t * are left in place and can still be expanded later.\n\t * <p>In contrast to {@link UriComponents#expand(Map)} or\n\t * {@link #buildAndExpand(Map)}, this method is useful when you need to\n\t * supply URI variables without building the {@link UriComponents} instance\n\t * just yet, or perhaps pre-expand some shared default values such as host\n\t * and port.\n\t * @param uriVariables the URI variables to use\n\t * @return this UriComponentsBuilder\n\t * @since 5.0.8\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 822
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder uriVariables(Map<String, Object> uriVariables)",
    "source_code": "\tpublic UriComponentsBuilder uriVariables(Map<String, Object> uriVariables) {\n\t\tthis.uriVariables.putAll(uriVariables);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#userInfo(userInfo)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "userInfo"
    ],
    "position": {
      "column": 1,
      "line": 624
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder userInfo(@Nullable String userInfo)",
    "source_code": "\tpublic UriComponentsBuilder userInfo(@Nullable String userInfo) {\n\t\tthis.userInfo = userInfo;\n\t\tresetSchemeSpecificPart();\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.pattern.<unknown>#getCaptureCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "int",
    "signature": "public int getCaptureCount()",
    "source_code": "\tpublic int getCaptureCount() {\n\t\treturn 1;\n\t}"
  },
  "org.springframework.web.util.pattern.<unknown>#getChars()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "char[]",
    "signature": "public char[] getChars()",
    "source_code": "\tpublic char[] getChars() {\n\t\treturn (\"/{*\" + this.variableName + \"}\").toCharArray();\n\t}"
  },
  "org.springframework.web.util.pattern.<unknown>#getNormalizedLength()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "int",
    "signature": "public int getNormalizedLength()",
    "source_code": "\tpublic int getNormalizedLength() {\n\t\treturn 1;\n\t}"
  },
  "org.springframework.web.util.pattern.<unknown>#getWildcardCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "int",
    "signature": "public int getWildcardCount()",
    "source_code": "\tpublic int getWildcardCount() {\n\t\treturn 0;\n\t}"
  },
  "org.springframework.web.util.pattern.<unknown>#matches(pathIndex,matchingContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pathIndex",
      "matchingContext"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "boolean",
    "signature": "public boolean matches(int pathIndex, MatchingContext matchingContext)",
    "source_code": "\tpublic boolean matches(int pathIndex, MatchingContext matchingContext) {\n\t\t// No need to handle 'match start' checking as this captures everything\n\t\t// anyway and cannot be followed by anything else\n\t\t// assert next == null\n\n\t\t// If there is more data, it must start with the separator\n\t\tif (pathIndex < matchingContext.pathLength && !matchingContext.isSeparator(pathIndex)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (matchingContext.determineRemainingPath) {\n\t\t\tmatchingContext.remainingPathIndex = matchingContext.pathLength;\n\t\t}\n\t\tif (matchingContext.extractingVariables) {\n\t\t\t// Collect the parameters from all the remaining segments\n\t\t\tMultiValueMap<String,String> parametersCollector = null;\n\t\t\tfor (int i = pathIndex; i < matchingContext.pathLength; i++) {\n\t\t\t\tElement element = matchingContext.pathElements.get(i);\n\t\t\t\tif (element instanceof PathSegment pathSegment) {\n\t\t\t\t\tMultiValueMap<String, String> parameters = pathSegment.parameters();\n\t\t\t\t\tif (!parameters.isEmpty()) {\n\t\t\t\t\t\tif (parametersCollector == null) {\n\t\t\t\t\t\t\tparametersCollector = new LinkedMultiValueMap<>();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparametersCollector.addAll(parameters);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmatchingContext.set(this.variableName, pathToString(pathIndex, matchingContext.pathElements),\n\t\t\t\t\tparametersCollector == null?NO_PARAMETERS:parametersCollector);\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.util.pattern.<unknown>#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn \"CaptureTheRest(/{*\" + this.variableName + \"})\";\n\t}"
  }
}