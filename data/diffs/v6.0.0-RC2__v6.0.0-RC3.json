{
  "org.springframework.core.style.DefaultValueStyler#styleArray(array)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate a styled version of the supplied array.\n\t * @return a styled version of the supplied array\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "array"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "String",
    "signature": "protected String styleArray(Object[] array)",
    "source_code": "\tprotected String styleArray(Object[] array) {\n\t\tif (array.length == 0) {\n\t\t\treturn ARRAY + '<' + ClassUtils.getShortName(array.getClass().getComponentType()) + '>' + EMPTY;\n\t\t}\n\n\t\tStringJoiner result = new StringJoiner(\", \", \"[\", \"]\");\n\t\tfor (Object element : array) {\n\t\t\tresult.add(style(element));\n\t\t}\n\t\treturn ARRAY + '<' + ClassUtils.getShortName(array.getClass().getComponentType()) + '>' + result;\n\t}"
  },
  "org.springframework.core.style.DefaultValueStyler#styleClass(clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate a styled version of the supplied {@link Class}.\n\t * <p>The default implementation delegates to {@link ClassUtils#getShortName(Class)}.\n\t * @return a styled version of the supplied class\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "String",
    "signature": "protected String styleClass(Class<?> clazz)",
    "source_code": "\tprotected String styleClass(Class<?> clazz) {\n\t\treturn ClassUtils.getShortName(clazz);\n\t}"
  },
  "org.springframework.core.style.DefaultValueStyler#styleCollection(collection)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate a styled version of the supplied {@link Collection}.\n\t * @return a styled version of the supplied collection\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "collection"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "String",
    "signature": "protected String styleCollection(Collection<?> collection)",
    "source_code": "\tprotected String styleCollection(Collection<?> collection) {\n\t\tString collectionType = getCollectionTypeString(collection);\n\n\t\tif (collection.isEmpty()) {\n\t\t\treturn collectionType + EMPTY;\n\t\t}\n\n\t\tStringJoiner result = new StringJoiner(\", \", \"[\", \"]\");\n\t\tfor (Object element : collection) {\n\t\t\tresult.add(style(element));\n\t\t}\n\t\treturn collectionType + result;\n\t}"
  },
  "org.springframework.core.style.DefaultValueStyler#styleMap(Map<K,map)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate a styled version of the supplied {@link Map}.\n\t * @return a styled version of the supplied map\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<K",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "String",
    "signature": "protected String styleMap(Map<K, V> map)",
    "source_code": "\tprotected <K, V> String styleMap(Map<K, V> map) {\n\t\tif (map.isEmpty()) {\n\t\t\treturn EMPTY_MAP;\n\t\t}\n\n\t\tStringJoiner result = new StringJoiner(\", \", \"[\", \"]\");\n\t\tfor (Map.Entry<K, V> entry : map.entrySet()) {\n\t\t\tresult.add(styleMapEntry(entry));\n\t\t}\n\t\treturn MAP + result;\n\t}"
  },
  "org.springframework.core.style.DefaultValueStyler#styleMapEntry(Map.Entry<?,entry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate a styled version of the supplied {@link Map.Entry}.\n\t * @return a styled version of the supplied map entry\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map.Entry<?",
      "entry"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "String",
    "signature": "protected String styleMapEntry(Map.Entry<?, ?> entry)",
    "source_code": "\tprotected String styleMapEntry(Map.Entry<?, ?> entry) {\n\t\treturn style(entry.getKey()) + \" -> \" + style(entry.getValue());\n\t}"
  },
  "org.springframework.core.style.DefaultValueStyler#styleMethod(method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate a styled version of the supplied {@link Method}.\n\t * <p>The default implementation returns the method's {@linkplain Method#getName()\n\t * name} and the {@linkplain ClassUtils#getShortName(Class) short name} of the\n\t * method's {@linkplain Method#getDeclaringClass() declaring class}, separated by\n\t * the {@code \"@\"} symbol.\n\t * @return a styled version of the supplied method\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "String",
    "signature": "protected String styleMethod(Method method)",
    "source_code": "\tprotected String styleMethod(Method method) {\n\t\treturn method.getName() + \"@\" + ClassUtils.getShortName(method.getDeclaringClass());\n\t}"
  },
  "org.springframework.core.style.DefaultValueStyler#styleNull()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate a styled version of {@code null}.\n\t * <p>The default implementation returns {@code \"[null]\"}.\n\t * @return a styled version of {@code null}\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "String",
    "signature": "protected String styleNull()",
    "source_code": "\tprotected String styleNull() {\n\t\treturn NULL;\n\t}"
  },
  "org.springframework.core.style.DefaultValueStyler#styleObject(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate a styled version of the supplied {@link Object}.\n\t * <p>This method is only invoked by {@link #style(Object)} as a fallback,\n\t * if none of the other {@code style*()} methods is suitable for the object's\n\t * type.\n\t * <p>The default implementation delegates to {@link String#valueOf(Object)}.\n\t * @return a styled version of the supplied object\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "String",
    "signature": "protected String styleObject(Object obj)",
    "source_code": "\tprotected String styleObject(Object obj) {\n\t\treturn String.valueOf(obj);\n\t}"
  },
  "org.springframework.core.style.DefaultValueStyler#styleString(str)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate a styled version of the supplied {@link String}.\n\t * <p>The default implementation returns the supplied string wrapped in\n\t * single quotes.\n\t * @return a styled version of the supplied string\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "str"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "String",
    "signature": "protected String styleString(String str)",
    "source_code": "\tprotected String styleString(String str) {\n\t\treturn \"\\'\" + str + \"\\'\";\n\t}"
  },
  "org.springframework.http.client.HttpComponentsClientHttpRequestFactory#close()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\tpublic void close() throws IOException {\n\t\tHttpClient httpClient = getHttpClient();\n\t\tif (httpClient instanceof Closeable) {\n\t\t\t((Closeable) httpClient).close();\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#setContextFailureProcessor(contextFailureProcessor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contextFailureProcessor"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "void",
    "signature": "public void setContextFailureProcessor(ApplicationContextFailureProcessor contextFailureProcessor)",
    "source_code": "\tpublic void setContextFailureProcessor(ApplicationContextFailureProcessor contextFailureProcessor) {\n\t\tthis.contextFailureProcessor = contextFailureProcessor;\n\t}"
  },
  "org.springframework.test.context.support.AbstractDirtiesContextTestExecutionListener": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract base class for {@code TestExecutionListener} implementations that\n * provide support for marking the {@code ApplicationContext} associated with\n * a test as <em>dirty</em> for both test classes and test methods annotated\n * with the {@link DirtiesContext @DirtiesContext} annotation.\n *\n * <p>The core functionality for this class was extracted from\n * {@link DirtiesContextTestExecutionListener} in Spring Framework 4.2.\n *\n * @author Sam Brannen\n * @author Juergen Hoeller\n * @since 4.2\n * @see DirtiesContext\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "signature": "public class AbstractDirtiesContextTestExecutionListener",
    "source_code": "public abstract class AbstractDirtiesContextTestExecutionListener extends AbstractTestExecutionListener {\n\n\tprivate static final Log logger = LogFactory.getLog(AbstractDirtiesContextTestExecutionListener.class);\n\n\n\t@Override\n\tpublic abstract int getOrder();\n\n\t/**\n\t * Mark the {@linkplain ApplicationContext application context} of the supplied\n\t * {@linkplain TestContext test context} as\n\t * {@linkplain TestContext#markApplicationContextDirty(DirtiesContext.HierarchyMode) dirty}\n\t * and set {@link DependencyInjectionTestExecutionListener#REINJECT_DEPENDENCIES_ATTRIBUTE\n\t * REINJECT_DEPENDENCIES_ATTRIBUTE} in the test context to {@code true}.\n\t * @param testContext the test context whose application context should\n\t * be marked as dirty\n\t * @param hierarchyMode the context cache clearing mode to be applied if the\n\t * context is part of a hierarchy; may be {@code null}\n\t * @since 3.2.2\n\t */\n\tprotected void dirtyContext(TestContext testContext, @Nullable HierarchyMode hierarchyMode) {\n\t\ttestContext.markApplicationContextDirty(hierarchyMode);\n\t\ttestContext.setAttribute(DependencyInjectionTestExecutionListener.REINJECT_DEPENDENCIES_ATTRIBUTE, Boolean.TRUE);\n\t}\n\n\t/**\n\t * Perform the actual work for {@link #beforeTestMethod} and {@link #afterTestMethod}\n\t * by dirtying the context if appropriate (i.e., according to the required modes).\n\t * @param testContext the test context whose application context should\n\t * potentially be marked as dirty; never {@code null}\n\t * @param requiredMethodMode the method mode required for a context to\n\t * be marked dirty in the current phase; never {@code null}\n\t * @param requiredClassMode the class mode required for a context to\n\t * be marked dirty in the current phase; never {@code null}\n\t * @throws Exception allows any exception to propagate\n\t * @since 4.2\n\t * @see #dirtyContext\n\t */\n\tprotected void beforeOrAfterTestMethod(TestContext testContext, MethodMode requiredMethodMode,\n\t\t\tClassMode requiredClassMode) throws Exception {\n\n\t\tAssert.notNull(testContext, \"TestContext must not be null\");\n\t\tAssert.notNull(requiredMethodMode, \"requiredMethodMode must not be null\");\n\t\tAssert.notNull(requiredClassMode, \"requiredClassMode must not be null\");\n\n\t\tClass<?> testClass = testContext.getTestClass();\n\t\tMethod testMethod = testContext.getTestMethod();\n\t\tAssert.notNull(testClass, \"The test class of the supplied TestContext must not be null\");\n\t\tAssert.notNull(testMethod, \"The test method of the supplied TestContext must not be null\");\n\n\t\tDirtiesContext methodAnn = AnnotatedElementUtils.findMergedAnnotation(testMethod, DirtiesContext.class);\n\t\tDirtiesContext classAnn = TestContextAnnotationUtils.findMergedAnnotation(testClass, DirtiesContext.class);\n\t\tboolean methodAnnotated = (methodAnn != null);\n\t\tboolean classAnnotated = (classAnn != null);\n\t\tMethodMode methodMode = (methodAnnotated ? methodAnn.methodMode() : null);\n\t\tClassMode classMode = (classAnnotated ? classAnn.classMode() : null);\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"\"\"\n\t\t\t\t\t%s test method: context %s, class annotated with @DirtiesContext [%s] \\\n\t\t\t\t\twith mode [%s], method annotated with @DirtiesContext [%s] with mode [%s]\"\"\"\n\t\t\t\t\t\t.formatted(getPhase(requiredMethodMode), testContext, classAnnotated, classMode,\n\t\t\t\t\t\t\tmethodAnnotated, methodMode));\n\t\t}\n\t\telse if (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"\"\"\n\t\t\t\t\t%s test method: class [%s], method [%s], class annotated with @DirtiesContext [%s] \\\n\t\t\t\t\twith mode [%s], method annotated with @DirtiesContext [%s] with mode [%s]\"\"\"\n\t\t\t\t\t\t.formatted(getPhase(requiredMethodMode), testClass.getSimpleName(),\n\t\t\t\t\t\t\ttestMethod.getName(), classAnnotated, classMode, methodAnnotated, methodMode));\n\t\t}\n\n\t\tif ((methodMode == requiredMethodMode) || (classMode == requiredClassMode)) {\n\t\t\tHierarchyMode hierarchyMode = (methodAnnotated ? methodAnn.hierarchyMode() : classAnn.hierarchyMode());\n\t\t\tdirtyContext(testContext, hierarchyMode);\n\t\t}\n\t}\n\n\t/**\n\t * Perform the actual work for {@link #beforeTestClass} and {@link #afterTestClass}\n\t * by dirtying the context if appropriate (i.e., according to the required mode).\n\t * @param testContext the test context whose application context should\n\t * potentially be marked as dirty; never {@code null}\n\t * @param requiredClassMode the class mode required for a context to\n\t * be marked dirty in the current phase; never {@code null}\n\t * @throws Exception allows any exception to propagate\n\t * @since 4.2\n\t * @see #dirtyContext\n\t */\n\tprotected void beforeOrAfterTestClass(TestContext testContext, ClassMode requiredClassMode) throws Exception {\n\t\tAssert.notNull(testContext, \"TestContext must not be null\");\n\t\tAssert.notNull(requiredClassMode, \"requiredClassMode must not be null\");\n\n\t\tClass<?> testClass = testContext.getTestClass();\n\t\tAssert.notNull(testClass, \"The test class of the supplied TestContext must not be null\");\n\n\t\tDirtiesContext dirtiesContext = TestContextAnnotationUtils.findMergedAnnotation(testClass, DirtiesContext.class);\n\t\tboolean classAnnotated = (dirtiesContext != null);\n\t\tClassMode classMode = (classAnnotated ? dirtiesContext.classMode() : null);\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"%s test class: context %s, class annotated with @DirtiesContext [%s] with mode [%s]\"\n\t\t\t\t\t.formatted(getPhase(requiredClassMode), testContext, classAnnotated, classMode));\n\t\t}\n\t\telse if (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"%s test class: class [%s], class annotated with @DirtiesContext [%s] with mode [%s]\"\n\t\t\t\t\t.formatted(getPhase(requiredClassMode), testClass.getSimpleName(), classAnnotated, classMode));\n\t\t}\n\n\t\tif (classMode == requiredClassMode) {\n\t\t\tdirtyContext(testContext, dirtiesContext.hierarchyMode());\n\t\t}\n\t}\n\n\tprivate static String getPhase(ClassMode classMode) {\n\t\treturn (classMode.name().startsWith(\"BEFORE\") ? \"Before\" : \"After\");\n\t}\n\n\tprivate static String getPhase(MethodMode methodMode) {\n\t\treturn (methodMode.name().startsWith(\"BEFORE\") ? \"Before\" : \"After\");\n\t}\n\n}"
  },
  "org.springframework.test.context.support.AbstractDirtiesContextTestExecutionListener#beforeOrAfterTestClass(testContext,requiredClassMode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform the actual work for {@link #beforeTestClass} and {@link #afterTestClass}\n\t * by dirtying the context if appropriate (i.e., according to the required mode).\n\t * @param testContext the test context whose application context should\n\t * potentially be marked as dirty; never {@code null}\n\t * @param requiredClassMode the class mode required for a context to\n\t * be marked dirty in the current phase; never {@code null}\n\t * @throws Exception allows any exception to propagate\n\t * @since 4.2\n\t * @see #dirtyContext\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "testContext",
      "requiredClassMode"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "void",
    "signature": "protected void beforeOrAfterTestClass(TestContext testContext, ClassMode requiredClassMode)",
    "source_code": "\tprotected void beforeOrAfterTestClass(TestContext testContext, ClassMode requiredClassMode) throws Exception {\n\t\tAssert.notNull(testContext, \"TestContext must not be null\");\n\t\tAssert.notNull(requiredClassMode, \"requiredClassMode must not be null\");\n\n\t\tClass<?> testClass = testContext.getTestClass();\n\t\tAssert.notNull(testClass, \"The test class of the supplied TestContext must not be null\");\n\n\t\tDirtiesContext dirtiesContext = TestContextAnnotationUtils.findMergedAnnotation(testClass, DirtiesContext.class);\n\t\tboolean classAnnotated = (dirtiesContext != null);\n\t\tClassMode classMode = (classAnnotated ? dirtiesContext.classMode() : null);\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"%s test class: context %s, class annotated with @DirtiesContext [%s] with mode [%s]\"\n\t\t\t\t\t.formatted(getPhase(requiredClassMode), testContext, classAnnotated, classMode));\n\t\t}\n\t\telse if (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"%s test class: class [%s], class annotated with @DirtiesContext [%s] with mode [%s]\"\n\t\t\t\t\t.formatted(getPhase(requiredClassMode), testClass.getSimpleName(), classAnnotated, classMode));\n\t\t}\n\n\t\tif (classMode == requiredClassMode) {\n\t\t\tdirtyContext(testContext, dirtiesContext.hierarchyMode());\n\t\t}\n\t}"
  },
  "org.springframework.test.context.support.AbstractDirtiesContextTestExecutionListener#beforeOrAfterTestMethod(testContext,requiredMethodMode,requiredClassMode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform the actual work for {@link #beforeTestMethod} and {@link #afterTestMethod}\n\t * by dirtying the context if appropriate (i.e., according to the required modes).\n\t * @param testContext the test context whose application context should\n\t * potentially be marked as dirty; never {@code null}\n\t * @param requiredMethodMode the method mode required for a context to\n\t * be marked dirty in the current phase; never {@code null}\n\t * @param requiredClassMode the class mode required for a context to\n\t * be marked dirty in the current phase; never {@code null}\n\t * @throws Exception allows any exception to propagate\n\t * @since 4.2\n\t * @see #dirtyContext\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "testContext",
      "requiredMethodMode",
      "requiredClassMode"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "void",
    "signature": "protected void beforeOrAfterTestMethod(TestContext testContext, MethodMode requiredMethodMode,\n\t\t\tClassMode requiredClassMode)",
    "source_code": "\tprotected void beforeOrAfterTestMethod(TestContext testContext, MethodMode requiredMethodMode,"
  },
  "org.springframework.test.context.support.AbstractDirtiesContextTestExecutionListener#dirtyContext(testContext,hierarchyMode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Mark the {@linkplain ApplicationContext application context} of the supplied\n\t * {@linkplain TestContext test context} as\n\t * {@linkplain TestContext#markApplicationContextDirty(DirtiesContext.HierarchyMode) dirty}\n\t * and set {@link DependencyInjectionTestExecutionListener#REINJECT_DEPENDENCIES_ATTRIBUTE\n\t * REINJECT_DEPENDENCIES_ATTRIBUTE} in the test context to {@code true}.\n\t * @param testContext the test context whose application context should\n\t * be marked as dirty\n\t * @param hierarchyMode the context cache clearing mode to be applied if the\n\t * context is part of a hierarchy; may be {@code null}\n\t * @since 3.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "testContext",
      "hierarchyMode"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "protected void dirtyContext(TestContext testContext, @Nullable HierarchyMode hierarchyMode)",
    "source_code": "\tprotected void dirtyContext(TestContext testContext, @Nullable HierarchyMode hierarchyMode) {\n\t\ttestContext.markApplicationContextDirty(hierarchyMode);\n\t\ttestContext.setAttribute(DependencyInjectionTestExecutionListener.REINJECT_DEPENDENCIES_ATTRIBUTE, Boolean.TRUE);\n\t}"
  },
  "org.springframework.test.context.support.AbstractDirtiesContextTestExecutionListener#getOrder()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 55
    },
    "return": "int",
    "signature": "public int getOrder()",
    "source_code": "\tpublic abstract int getOrder();"
  },
  "org.springframework.test.context.support.AbstractTestContextBootstrapper#getApplicationContextFailureProcessor()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the {@link ApplicationContextFailureProcessor} to use.\n\t * <p>The default implementation returns {@code null}.\n\t * <p>Concrete subclasses may choose to override this method to provide an\n\t * {@code ApplicationContextFailureProcessor} that will be supplied to the\n\t * configured {@code CacheAwareContextLoaderDelegate} in\n\t * {@link #getCacheAwareContextLoaderDelegate()}.\n\t * @return the context failure processor to use, or {@code null} if no processor\n\t * should be used\n\t * @since 6.0\n\t * @see #getCacheAwareContextLoaderDelegate()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 530
    },
    "return": "ApplicationContextFailureProcessor",
    "signature": "protected ApplicationContextFailureProcessor getApplicationContextFailureProcessor()",
    "source_code": "\tprotected ApplicationContextFailureProcessor getApplicationContextFailureProcessor() {\n\t\treturn null;\n\t}"
  },
  "org.springframework.test.context.util.<unknown>#handleFailure(factoryType,factoryImplementationName,failure)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "factoryType",
      "factoryImplementationName",
      "failure"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "return": "void",
    "signature": "public void handleFailure(Class<?> factoryType, String factoryImplementationName, Throwable failure)",
    "source_code": "\tpublic void handleFailure(Class<?> factoryType, String factoryImplementationName, Throwable failure) {\n\t\tThrowable ex = (failure instanceof InvocationTargetException ite ? ite.getTargetException() : failure);\n\t\tif (ex instanceof ClassNotFoundException || ex instanceof NoClassDefFoundError) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"\"\"\n\t\t\t\t\t\tSkipping candidate %1$s [%2$s] due to a missing dependency. \\\n\t\t\t\t\t\tSpecify custom %1$s classes or make the default %1$s classes \\\n\t\t\t\t\t\tand their required dependencies available. Offending class: [%3$s]\"\"\"\n\t\t\t\t\t\t\t.formatted(factoryType.getSimpleName(), factoryImplementationName, ex.getMessage()));\n\t\t\t}\n\t\t}\n\t\telse if (ex instanceof LinkageError) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"\"\"\n\t\t\t\t\t\tCould not load %1$s [%2$s]. Specify custom %1$s classes or make the default %1$s classes \\\n\t\t\t\t\t\tavailable.\"\"\".formatted(factoryType.getSimpleName(), factoryImplementationName), ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (ex instanceof RuntimeException runtimeException) {\n\t\t\t\tthrow runtimeException;\n\t\t\t}\n\t\t\tif (ex instanceof Error error) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\"Failed to load %s [%s]\".formatted(factoryType.getSimpleName(), factoryImplementationName), ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.ResponseEntityExceptionHandler#createProblemDetail(ex,status,defaultDetail,detailMessageCode,detailMessageArguments,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenience method to create a {@link ProblemDetail} for any exception\n\t * that doesn't implement {@link ErrorResponse}, also performing a\n\t * {@link MessageSource} lookup for the \"detail\" field.\n\t * @param ex the exception being handled\n\t * @param status the status to associate with the exception\n\t * @param defaultDetail default value for the \"detail\" field\n\t * @param detailMessageCode the code to use to look up the \"detail\" field\n\t * through a {@code MessageSource}, falling back on\n\t * {@link ErrorResponse#getDefaultDetailMessageCode(Class, String)}\n\t * @param detailMessageArguments the arguments to go with the detailMessageCode\n\t * @return the created {@code ProblemDetail} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "status",
      "defaultDetail",
      "detailMessageCode",
      "detailMessageArguments",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "ProblemDetail",
    "signature": "protected ProblemDetail createProblemDetail(Exception ex, HttpStatusCode status, String defaultDetail, @Nullable String detailMessageCode,\n\t\t\t@Nullable Object[] detailMessageArguments, ServerWebExchange exchange)",
    "source_code": "\tprotected ProblemDetail createProblemDetail("
  },
  "org.springframework.web.service.annotation.<unknown>#registerMethodHints(hints,method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "return": "void",
    "signature": "protected void registerMethodHints(ReflectionHints hints, Method method)",
    "source_code": "\tprotected void registerMethodHints(ReflectionHints hints, Method method) {\n\t\thints.registerMethod(method, ExecutableMode.INVOKE);\n\t\tfor (Parameter parameter : method.getParameters()) {\n\t\t\tregisterParameterTypeHints(hints, MethodParameter.forParameter(parameter));\n\t\t}\n\t\tregisterReturnTypeHints(hints, MethodParameter.forExecutable(method, -1));\n\t}"
  },
  "org.springframework.web.service.annotation.<unknown>#registerParameterTypeHints(hints,methodParameter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "methodParameter"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "void",
    "signature": "protected void registerParameterTypeHints(ReflectionHints hints, MethodParameter methodParameter)",
    "source_code": "\tprotected void registerParameterTypeHints(ReflectionHints hints, MethodParameter methodParameter) {\n\t\tif (methodParameter.hasParameterAnnotation(RequestBody.class)) {\n\t\t\tthis.bindingRegistrar.registerReflectionHints(hints, methodParameter.getGenericParameterType());\n\t\t}\n\t}"
  },
  "org.springframework.web.service.annotation.<unknown>#registerReflectionHints(hints,element)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hints",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "return": "void",
    "signature": "public void registerReflectionHints(ReflectionHints hints, AnnotatedElement element)",
    "source_code": "\tpublic void registerReflectionHints(ReflectionHints hints, AnnotatedElement element) {\n\t\tif (element instanceof Method method) {\n\t\t\tregisterMethodHints(hints, method);\n\t\t}\n\t}"
  },
  "org.springframework.web.service.annotation.<unknown>#registerReturnTypeHints(hints,returnTypeParameter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "returnTypeParameter"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "void",
    "signature": "protected void registerReturnTypeHints(ReflectionHints hints, MethodParameter returnTypeParameter)",
    "source_code": "\tprotected void registerReturnTypeHints(ReflectionHints hints, MethodParameter returnTypeParameter) {\n\t\tif (!void.class.equals(returnTypeParameter.getParameterType())) {\n\t\t\tthis.bindingRegistrar.registerReflectionHints(hints, returnTypeParameter.getGenericParameterType());\n\t\t}\n\t}"
  },
  "org.springframework.web.service.invoker.AbstractNamedValueArgumentResolver#addRequestValue(name,value,parameter,requestValues)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given, single request value. This may be called multiples times\n\t * if the request value is multivalued.\n\t * <p>If the resolver was created with a {@link ConversionService}, the value\n\t * will have been converted to a String and may be cast down.\n\t * @param name the request value name\n\t * @param value the value\n\t * @param parameter the method parameter type, nested if Map, List/array, or Optional\n\t * @param requestValues builder to add the request value to\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "value",
      "parameter",
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "void",
    "signature": "protected void addRequestValue(String name, Object value, MethodParameter parameter, HttpRequestValues.Builder requestValues)",
    "source_code": "\tprotected abstract void addRequestValue("
  },
  "org.springframework.web.service.invoker.AbstractNamedValueArgumentResolver#addRequestValue(name,value,requestValues)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given, single request value. This may be called multiples times\n\t * if the request value is multivalued.\n\t * <p>If the resolver was created with a {@link ConversionService}, the value\n\t * will have been converted to a String and may be cast down.\n\t * @param name the request value name\n\t * @param value the value\n\t * @param requestValues builder to add the request value to\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "value",
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "void",
    "signature": "protected void addRequestValue(String name, Object value, HttpRequestValues.Builder requestValues)",
    "source_code": "\tprotected abstract void addRequestValue(String name, Object value, HttpRequestValues.Builder requestValues);"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler#createProblemDetail(ex,status,defaultDetail,detailMessageCode,detailMessageArguments,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenience method to create a {@link ProblemDetail} for any exception\n\t * that doesn't implement {@link ErrorResponse}, also performing a\n\t * {@link MessageSource} lookup for the \"detail\" field.\n\t * @param ex the exception being handled\n\t * @param status the status to associate with the exception\n\t * @param defaultDetail default value for the \"detail\" field\n\t * @param detailMessageCode the code to use to look up the \"detail\" field\n\t * through a {@code MessageSource}, falling back on\n\t * {@link ErrorResponse#getDefaultDetailMessageCode(Class, String)}\n\t * @param detailMessageArguments the arguments to go with the detailMessageCode\n\t * @param request the current request\n\t * @return the created {@code ProblemDetail} instance\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "status",
      "defaultDetail",
      "detailMessageCode",
      "detailMessageArguments",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 507
    },
    "return": "ProblemDetail",
    "signature": "protected ProblemDetail createProblemDetail(Exception ex, HttpStatusCode status, String defaultDetail, @Nullable String detailMessageCode,\n\t\t\t@Nullable Object[] detailMessageArguments, WebRequest request)",
    "source_code": "\tprotected ProblemDetail createProblemDetail("
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * An abstract base class for {@link SockJsService} implementations that provides SockJS\n * path resolution and handling of static SockJS requests (e.g. \"/info\", \"/iframe.html\",\n * etc). Sub-classes must handle session URLs (i.e. transport-specific requests).\n *\n * By default, only same origin requests are allowed. Use {@link #setAllowedOrigins}\n * to specify a list of allowed origins (a list containing \"*\" will allow all origins).\n *\n * @author Rossen Stoyanchev\n * @author Sebastien Deleuze\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "signature": "public class AbstractSockJsService",
    "source_code": "public abstract class AbstractSockJsService implements SockJsService, CorsConfigurationSource {\n\n\tprivate static final String XFRAME_OPTIONS_HEADER = \"X-Frame-Options\";\n\n\tprivate static final long ONE_YEAR = TimeUnit.DAYS.toSeconds(365);\n\n\n\tprivate static final Random random = new Random();\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\tprivate final TaskScheduler taskScheduler;\n\n\tprivate String name = \"SockJSService@\" + ObjectUtils.getIdentityHexString(this);\n\n\tprivate String clientLibraryUrl = \"https://cdn.jsdelivr.net/sockjs/1.0.0/sockjs.min.js\";\n\n\tprivate int streamBytesLimit = 128 * 1024;\n\n\tprivate boolean sessionCookieNeeded = true;\n\n\tprivate long heartbeatTime = TimeUnit.SECONDS.toMillis(25);\n\n\tprivate long disconnectDelay = TimeUnit.SECONDS.toMillis(5);\n\n\tprivate int httpMessageCacheSize = 100;\n\n\tprivate boolean webSocketEnabled = true;\n\n\tprivate boolean suppressCors = false;\n\n\tprotected final CorsConfiguration corsConfiguration;\n\n\tprivate final SockJsRequestHandler infoHandler = new InfoHandler();\n\n\tprivate final SockJsRequestHandler iframeHandler = new IframeHandler();\n\n\n\tpublic AbstractSockJsService(TaskScheduler scheduler) {\n\t\tAssert.notNull(scheduler, \"TaskScheduler must not be null\");\n\t\tthis.taskScheduler = scheduler;\n\t\tthis.corsConfiguration = initCorsConfiguration();\n\t}\n\n\tprivate static CorsConfiguration initCorsConfiguration() {\n\t\tCorsConfiguration config = new CorsConfiguration();\n\t\tconfig.addAllowedMethod(\"*\");\n\t\tconfig.setAllowedOrigins(Collections.emptyList());\n\t\tconfig.setAllowedOriginPatterns(Collections.emptyList());\n\t\tconfig.setAllowCredentials(true);\n\t\tconfig.setMaxAge(ONE_YEAR);\n\t\tconfig.addAllowedHeader(\"*\");\n\t\treturn config;\n\t}\n\n\n\t/**\n\t * A scheduler instance to use for scheduling heart-beat messages.\n\t */\n\tpublic TaskScheduler getTaskScheduler() {\n\t\treturn this.taskScheduler;\n\t}\n\n\t/**\n\t * Set a unique name for this service (mainly for logging purposes).\n\t */\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\t/**\n\t * Return the unique name associated with this service.\n\t */\n\tpublic String getName() {\n\t\treturn this.name;\n\t}\n\n\t/**\n\t * Transports with no native cross-domain communication (e.g. \"eventsource\",\n\t * \"htmlfile\") must get a simple page from the \"foreign\" domain in an invisible\n\t * {@code iframe} so that code in the {@code iframe} can run from a domain\n\t * local to the SockJS server. Since the {@code iframe} needs to load the\n\t * SockJS JavaScript client library, this property allows specifying where to\n\t * load it from.\n\t * <p>By default this is set to point to\n\t * <a href=\"https://cdn.jsdelivr.net/sockjs/1.0.0/sockjs.min.js\">\"https://cdn.jsdelivr.net/sockjs/1.0.0/sockjs.min.js\"</a>.\n\t * However, it can also be set to point to a URL served by the application.\n\t * <p>Note that it's possible to specify a relative URL in which case the URL\n\t * must be relative to the {@code iframe} URL. For example assuming a SockJS endpoint\n\t * mapped to \"/sockjs\", and resulting {@code iframe} URL \"/sockjs/iframe.html\", then\n\t * the relative URL must start with \"../../\" to traverse up to the location\n\t * above the SockJS mapping. In case of a prefix-based Servlet mapping one more\n\t * traversals may be needed.\n\t */\n\tpublic void setSockJsClientLibraryUrl(String clientLibraryUrl) {\n\t\tthis.clientLibraryUrl = clientLibraryUrl;\n\t}\n\n\t/**\n\t * Return he URL to the SockJS JavaScript client library.\n\t */\n\tpublic String getSockJsClientLibraryUrl() {\n\t\treturn this.clientLibraryUrl;\n\t}\n\n\t/**\n\t * Streaming transports save responses on the client side and don't free\n\t * memory used by delivered messages. Such transports need to recycle the\n\t * connection once in a while. This property sets a minimum number of bytes\n\t * that can be sent over a single HTTP streaming request before it will be\n\t * closed. After that client will open a new request. Setting this value to\n\t * one effectively disables streaming and will make streaming transports to\n\t * behave like polling transports.\n\t * <p>The default value is 128K (i.e. 128 * 1024).\n\t */\n\tpublic void setStreamBytesLimit(int streamBytesLimit) {\n\t\tthis.streamBytesLimit = streamBytesLimit;\n\t}\n\n\t/**\n\t * Return the minimum number of bytes that can be sent over a single HTTP\n\t * streaming request before it will be closed.\n\t */\n\tpublic int getStreamBytesLimit() {\n\t\treturn this.streamBytesLimit;\n\t}\n\n\t/**\n\t * The SockJS protocol requires a server to respond to an initial \"/info\" request from\n\t * clients with a \"cookie_needed\" boolean property that indicates whether the use of a\n\t * JSESSIONID cookie is required for the application to function correctly, e.g. for\n\t * load balancing or in Java Servlet containers for the use of an HTTP session.\n\t * <p>This is especially important for IE 8,9 that support XDomainRequest -- a modified\n\t * AJAX/XHR -- that can do requests across domains but does not send any cookies. In\n\t * those cases, the SockJS client prefers the \"iframe-htmlfile\" transport over\n\t * \"xdr-streaming\" in order to be able to send cookies.\n\t * <p>The SockJS protocol also expects a SockJS service to echo back the JSESSIONID\n\t * cookie when this property is set to true. However, when running in a Servlet\n\t * container this is not necessary since the container takes care of it.\n\t * <p>The default value is \"true\" to maximize the chance for applications to work\n\t * correctly in IE 8,9 with support for cookies (and the JSESSIONID cookie in\n\t * particular). However, an application can choose to set this to \"false\" if\n\t * the use of cookies (and HTTP session) is not required.\n\t */\n\tpublic void setSessionCookieNeeded(boolean sessionCookieNeeded) {\n\t\tthis.sessionCookieNeeded = sessionCookieNeeded;\n\t}\n\n\t/**\n\t * Return whether the JSESSIONID cookie is required for the application to function.\n\t */\n\tpublic boolean isSessionCookieNeeded() {\n\t\treturn this.sessionCookieNeeded;\n\t}\n\n\t/**\n\t * Specify the amount of time in milliseconds when the server has not sent\n\t * any messages and after which the server should send a heartbeat frame\n\t * to the client in order to keep the connection from breaking.\n\t * <p>The default value is 25,000 (25 seconds).\n\t */\n\tpublic void setHeartbeatTime(long heartbeatTime) {\n\t\tthis.heartbeatTime = heartbeatTime;\n\t}\n\n\t/**\n\t * Return the amount of time in milliseconds when the server has not sent\n\t * any messages.\n\t */\n\tpublic long getHeartbeatTime() {\n\t\treturn this.heartbeatTime;\n\t}\n\n\t/**\n\t * The amount of time in milliseconds before a client is considered\n\t * disconnected after not having a receiving connection, i.e. an active\n\t * connection over which the server can send data to the client.\n\t * <p>The default value is 5000.\n\t */\n\tpublic void setDisconnectDelay(long disconnectDelay) {\n\t\tthis.disconnectDelay = disconnectDelay;\n\t}\n\n\t/**\n\t * Return the amount of time in milliseconds before a client is considered disconnected.\n\t */\n\tpublic long getDisconnectDelay() {\n\t\treturn this.disconnectDelay;\n\t}\n\n\t/**\n\t * The number of server-to-client messages that a session can cache while waiting\n\t * for the next HTTP polling request from the client. All HTTP transports use this\n\t * property since even streaming transports recycle HTTP requests periodically.\n\t * <p>The amount of time between HTTP requests should be relatively brief and will\n\t * not exceed the allows disconnect delay (see {@link #setDisconnectDelay(long)});\n\t * 5 seconds by default.\n\t * <p>The default size is 100.\n\t */\n\tpublic void setHttpMessageCacheSize(int httpMessageCacheSize) {\n\t\tthis.httpMessageCacheSize = httpMessageCacheSize;\n\t}\n\n\t/**\n\t * Return the size of the HTTP message cache.\n\t */\n\tpublic int getHttpMessageCacheSize() {\n\t\treturn this.httpMessageCacheSize;\n\t}\n\n\t/**\n\t * Some load balancers do not support WebSocket. This option can be used to\n\t * disable the WebSocket transport on the server side.\n\t * <p>The default value is \"true\".\n\t */\n\tpublic void setWebSocketEnabled(boolean webSocketEnabled) {\n\t\tthis.webSocketEnabled = webSocketEnabled;\n\t}\n\n\t/**\n\t * Return whether WebSocket transport is enabled.\n\t */\n\tpublic boolean isWebSocketEnabled() {\n\t\treturn this.webSocketEnabled;\n\t}\n\n\t/**\n\t * This option can be used to disable automatic addition of CORS headers for\n\t * SockJS requests.\n\t * <p>The default value is \"false\".\n\t * @since 4.1.2\n\t */\n\tpublic void setSuppressCors(boolean suppressCors) {\n\t\tthis.suppressCors = suppressCors;\n\t}\n\n\t/**\n\t * Return if automatic addition of CORS headers has been disabled.\n\t * @since 4.1.2\n\t * @see #setSuppressCors\n\t */\n\tpublic boolean shouldSuppressCors() {\n\t\treturn this.suppressCors;\n\t}\n\n\t/**\n\t * Set the origins for which cross-origin requests are allowed from a browser.\n\t * Please, refer to {@link CorsConfiguration#setAllowedOrigins(List)} for\n\t * format details and considerations, and keep in mind that the CORS spec\n\t * does not allow use of {@code \"*\"} with {@code allowCredentials=true}.\n\t * For more flexible origin patterns use {@link #setAllowedOriginPatterns}\n\t * instead.\n\t *\n\t * <p>By default, no origins are allowed. When\n\t * {@link #setAllowedOriginPatterns(Collection) allowedOriginPatterns} is also\n\t * set, then that takes precedence over this property.\n\t *\n\t * <p>Note when SockJS is enabled and origins are restricted, transport types\n\t * that do not allow to check request origin (Iframe based transports) are\n\t * disabled. As a consequence, IE 6 to 9 are not supported when origins are\n\t * restricted.\n\t * @since 4.1.2\n\t * @see #setAllowedOriginPatterns(Collection)\n\t * @see <a href=\"https://tools.ietf.org/html/rfc6454\">RFC 6454: The Web Origin Concept</a>\n\t * @see <a href=\"https://github.com/sockjs/sockjs-client#supported-transports-by-browser-html-served-from-http-or-https\">SockJS supported transports by browser</a>\n\t */\n\tpublic void setAllowedOrigins(Collection<String> allowedOrigins) {\n\t\tAssert.notNull(allowedOrigins, \"Allowed origins Collection must not be null\");\n\t\tthis.corsConfiguration.setAllowedOrigins(new ArrayList<>(allowedOrigins));\n\t}\n\n\t/**\n\t * Return the {@link #setAllowedOrigins(Collection) configured} allowed origins.\n\t * @since 4.1.2\n\t */\n\t@SuppressWarnings(\"ConstantConditions\")\n\tpublic Collection<String> getAllowedOrigins() {\n\t\treturn this.corsConfiguration.getAllowedOrigins();\n\t}\n\t/**\n\t * Alternative to {@link #setAllowedOrigins(Collection)} that supports more\n\t * flexible patterns for specifying the origins for which cross-origin\n\t * requests are allowed from a browser. Please, refer to\n\t * {@link CorsConfiguration#setAllowedOriginPatterns(List)} for format\n\t * details and other considerations.\n\t * <p>By default this is not set.\n\t * @since 5.2.3\n\t */\n\tpublic void setAllowedOriginPatterns(Collection<String> allowedOriginPatterns) {\n\t\tAssert.notNull(allowedOriginPatterns, \"Allowed origin patterns Collection must not be null\");\n\t\tthis.corsConfiguration.setAllowedOriginPatterns(new ArrayList<>(allowedOriginPatterns));\n\t}\n\n\t/**\n\t * Return {@link #setAllowedOriginPatterns(Collection) configured} origin patterns.\n\t * @since 5.3.2\n\t */\n\t@SuppressWarnings(\"ConstantConditions\")\n\tpublic Collection<String> getAllowedOriginPatterns() {\n\t\treturn this.corsConfiguration.getAllowedOriginPatterns();\n\t}\n\n\n\t/**\n\t * This method determines the SockJS path and handles SockJS static URLs.\n\t * Session URLs and raw WebSocket requests are delegated to abstract methods.\n\t */\n\t@Override\n\tpublic final void handleRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\t@Nullable String sockJsPath, WebSocketHandler wsHandler) throws SockJsException {\n\n\t\tif (sockJsPath == null) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\"Expected SockJS path. Failing request: \" + request.getURI(), -1, true));\n\t\t\t}\n\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\trequest.getHeaders();\n\t\t}\n\t\tcatch (InvalidMediaTypeException ex) {\n\t\t\t// As per SockJS protocol content-type can be ignored (it's always json)\n\t\t}\n\n\t\tString requestInfo = (logger.isDebugEnabled() ? request.getMethod() + \" \" + request.getURI() : null);\n\n\t\ttry {\n\t\t\tif (sockJsPath.isEmpty() || sockJsPath.equals(\"/\")) {\n\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\tlogger.debug(\"Processing transport request: \" + requestInfo);\n\t\t\t\t}\n\t\t\t\tif (\"websocket\".equalsIgnoreCase(request.getHeaders().getUpgrade())) {\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.BAD_REQUEST);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresponse.getHeaders().setContentType(new MediaType(\"text\", \"plain\", StandardCharsets.UTF_8));\n\t\t\t\tresponse.getBody().write(\"Welcome to SockJS!\\n\".getBytes(StandardCharsets.UTF_8));\n\t\t\t}\n\n\t\t\telse if (sockJsPath.equals(\"/info\")) {\n\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\tlogger.debug(\"Processing transport request: \" + requestInfo);\n\t\t\t\t}\n\t\t\t\tthis.infoHandler.handle(request, response);\n\t\t\t}\n\n\t\t\telse if (sockJsPath.matches(\"/iframe[0-9-.a-z_]*.html\")) {\n\t\t\t\tif (!getAllowedOrigins().isEmpty() && !getAllowedOrigins().contains(\"*\") ||\n\t\t\t\t\t\t!getAllowedOriginPatterns().isEmpty()) {\n\t\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\t\tlogger.debug(\"Iframe support is disabled when an origin check is required. \" +\n\t\t\t\t\t\t\t\t\"Ignoring transport request: \" + requestInfo);\n\t\t\t\t\t}\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (getAllowedOrigins().isEmpty()) {\n\t\t\t\t\tresponse.getHeaders().add(XFRAME_OPTIONS_HEADER, \"SAMEORIGIN\");\n\t\t\t\t}\n\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\tlogger.debug(\"Processing transport request: \" + requestInfo);\n\t\t\t\t}\n\t\t\t\tthis.iframeHandler.handle(request, response);\n\t\t\t}\n\n\t\t\telse if (sockJsPath.equals(\"/websocket\")) {\n\t\t\t\tif (isWebSocketEnabled()) {\n\t\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\t\tlogger.debug(\"Processing transport request: \" + requestInfo);\n\t\t\t\t\t}\n\t\t\t\t\thandleRawWebSocketRequest(request, response, wsHandler);\n\t\t\t\t}\n\t\t\t\telse if (requestInfo != null) {\n\t\t\t\t\tlogger.debug(\"WebSocket disabled. Ignoring transport request: \" + requestInfo);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tString[] pathSegments = StringUtils.tokenizeToStringArray(sockJsPath.substring(1), \"/\");\n\t\t\t\tif (pathSegments.length != 3) {\n\t\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\"Invalid SockJS path '\" + sockJsPath + \"' - \" +\n\t\t\t\t\t\t\t\t\"required to have 3 path segments\", -1, true));\n\t\t\t\t\t}\n\t\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring transport request: \" + requestInfo);\n\t\t\t\t\t}\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tString serverId = pathSegments[0];\n\t\t\t\tString sessionId = pathSegments[1];\n\t\t\t\tString transport = pathSegments[2];\n\n\t\t\t\tif (!isWebSocketEnabled() && transport.equals(\"websocket\")) {\n\t\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\t\tlogger.debug(\"WebSocket disabled. Ignoring transport request: \" + requestInfo);\n\t\t\t\t\t}\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse if (!validateRequest(serverId, sessionId, transport) || !validatePath(request)) {\n\t\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring transport request: \" + requestInfo);\n\t\t\t\t\t}\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\tlogger.debug(\"Processing transport request: \" + requestInfo);\n\t\t\t\t}\n\t\t\t\thandleTransportRequest(request, response, wsHandler, sessionId, transport);\n\t\t\t}\n\t\t\tresponse.close();\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new SockJsException(\"Failed to write to the response\", null, ex);\n\t\t}\n\t}\n\n\tprotected boolean validateRequest(String serverId, String sessionId, String transport) {\n\t\tif (!StringUtils.hasText(serverId) || !StringUtils.hasText(sessionId) || !StringUtils.hasText(transport)) {\n\t\t\tlogger.warn(\"No server, session, or transport path segment in SockJS request.\");\n\t\t\treturn false;\n\t\t}\n\n\t\t// Server and session id's must not contain \".\"\n\t\tif (serverId.contains(\".\") || sessionId.contains(\".\")) {\n\t\t\tlogger.warn(\"Either server or session contains a \\\".\\\" which is not allowed by SockJS protocol.\");\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Ensure the path does not contain a file extension, either in the filename\n\t * (e.g. \"/jsonp.bat\") or possibly after path parameters (\"/jsonp;Setup.bat\")\n\t * which could be used for RFD exploits.\n\t * <p>Since the last part of the path is expected to be a transport type, the\n\t * presence of an extension would not work. All we need to do is check if\n\t * there are any path parameters, which would have been removed from the\n\t * SockJS path during request mapping, and if found reject the request.\n\t */\n\tprivate boolean validatePath(ServerHttpRequest request) {\n\t\tString path = request.getURI().getPath();\n\t\tint index = path.lastIndexOf('/') + 1;\n\t\treturn (path.indexOf(';', index) == -1);\n\t}\n\n\tprotected boolean checkOrigin(ServerHttpRequest request, ServerHttpResponse response, HttpMethod... httpMethods)\n\t\t\tthrows IOException {\n\n\t\tif (WebUtils.isSameOrigin(request)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (this.corsConfiguration.checkOrigin(request.getHeaders().getOrigin()) == null) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Origin header value '\" + request.getHeaders().getOrigin() + \"' not allowed.\");\n\t\t\t}\n\t\t\tresponse.setStatusCode(HttpStatus.FORBIDDEN);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic CorsConfiguration getCorsConfiguration(HttpServletRequest request) {\n\t\tif (!this.suppressCors && (request.getHeader(HttpHeaders.ORIGIN) != null)) {\n\t\t\treturn this.corsConfiguration;\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected void addCacheHeaders(ServerHttpResponse response) {\n\t\tresponse.getHeaders().setCacheControl(\"public, max-age=\" + ONE_YEAR);\n\t\tresponse.getHeaders().setExpires(System.currentTimeMillis() + ONE_YEAR * 1000);\n\t}\n\n\tprotected void addNoCacheHeaders(ServerHttpResponse response) {\n\t\tresponse.getHeaders().setCacheControl(\"no-store, no-cache, must-revalidate, max-age=0\");\n\t}\n\n\tprotected void sendMethodNotAllowed(ServerHttpResponse response, HttpMethod... httpMethods) {\n\t\tlogger.warn(\"Sending Method Not Allowed (405)\");\n\t\tresponse.setStatusCode(HttpStatus.METHOD_NOT_ALLOWED);\n\t\tresponse.getHeaders().setAllow(new LinkedHashSet<>(Arrays.asList(httpMethods)));\n\t}\n\n\n\t/**\n\t * Handle request for raw WebSocket communication, i.e. without any SockJS message framing.\n\t */\n\tprotected abstract void handleRawWebSocketRequest(ServerHttpRequest request,\n\t\t\tServerHttpResponse response, WebSocketHandler webSocketHandler) throws IOException;\n\n\t/**\n\t * Handle a SockJS session URL (i.e. transport-specific request).\n\t */\n\tprotected abstract void handleTransportRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler webSocketHandler, String sessionId, String transport) throws SockJsException;\n\n\n\tprivate interface SockJsRequestHandler {\n\n\t\tvoid handle(ServerHttpRequest request, ServerHttpResponse response) throws IOException;\n\t}\n\n\n\tprivate class InfoHandler implements SockJsRequestHandler {\n\n\t\tprivate static final String INFO_CONTENT =\n\t\t\t\t\"{\\\"entropy\\\":%s,\\\"origins\\\":[\\\"*:*\\\"],\\\"cookie_needed\\\":%s,\\\"websocket\\\":%s}\";\n\n\t\t@Override\n\t\tpublic void handle(ServerHttpRequest request, ServerHttpResponse response) throws IOException {\n\t\t\tif (request.getMethod() == HttpMethod.GET) {\n\t\t\t\taddNoCacheHeaders(response);\n\t\t\t\tif (checkOrigin(request, response)) {\n\t\t\t\t\tresponse.getHeaders().setContentType(new MediaType(\"application\", \"json\", StandardCharsets.UTF_8));\n\t\t\t\t\tString content = String.format(\n\t\t\t\t\t\t\tINFO_CONTENT, random.nextInt(), isSessionCookieNeeded(), isWebSocketEnabled());\n\t\t\t\t\tresponse.getBody().write(content.getBytes());\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse if (request.getMethod() == HttpMethod.OPTIONS) {\n\t\t\t\tif (checkOrigin(request, response)) {\n\t\t\t\t\taddCacheHeaders(response);\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.NO_CONTENT);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsendMethodNotAllowed(response, HttpMethod.GET, HttpMethod.OPTIONS);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate class IframeHandler implements SockJsRequestHandler {\n\n\t\tprivate static final String IFRAME_CONTENT = \"\"\"\n\t\t\t\t<!DOCTYPE html>\n\t\t\t\t<html>\n\t\t\t\t<head>\n\t\t\t\t\t<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n\t\t\t\t\t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n\t\t\t\t\t<script>\n\t\t\t\t\t\tdocument.domain = document.domain;\n\t\t\t\t\t\t_sockjs_onload = function(){SockJS.bootstrap_iframe();};\n\t\t\t\t\t</script>\n\t\t\t\t\t<script src=\"%s\"></script>\n\t\t\t\t</head>\n\t\t\t\t<body>\n\t\t\t\t\t<h2>Don't panic!</h2>\n\t\t\t\t\t<p>This is a SockJS hidden iframe. It's used for cross domain magic.</p>\n\t\t\t\t</body>\n\t\t\t\t</html>\"\"\";\n\n\t\t@Override\n\t\tpublic void handle(ServerHttpRequest request, ServerHttpResponse response) throws IOException {\n\t\t\tif (request.getMethod() != HttpMethod.GET) {\n\t\t\t\tsendMethodNotAllowed(response, HttpMethod.GET);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tString content = String.format(IFRAME_CONTENT, getSockJsClientLibraryUrl());\n\t\t\tbyte[] contentBytes = content.getBytes(StandardCharsets.UTF_8);\n\t\t\tStringBuilder builder = new StringBuilder(\"\\\"0\");\n\t\t\tDigestUtils.appendMd5DigestAsHex(contentBytes, builder);\n\t\t\tbuilder.append('\"');\n\t\t\tString etagValue = builder.toString();\n\n\t\t\tList<String> ifNoneMatch = request.getHeaders().getIfNoneMatch();\n\t\t\tif (!CollectionUtils.isEmpty(ifNoneMatch) && ifNoneMatch.get(0).equals(etagValue)) {\n\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_MODIFIED);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresponse.getHeaders().setContentType(new MediaType(\"text\", \"html\", StandardCharsets.UTF_8));\n\t\t\tresponse.getHeaders().setContentLength(contentBytes.length);\n\n\t\t\t// No cache in order to check every time if IFrame are authorized\n\t\t\taddNoCacheHeaders(response);\n\t\t\tresponse.getHeaders().setETag(etagValue);\n\t\t\tresponse.getBody().write(contentBytes);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService#addCacheHeaders(response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "response"
    ],
    "position": {
      "column": 1,
      "line": 550
    },
    "return": "void",
    "signature": "protected void addCacheHeaders(ServerHttpResponse response)",
    "source_code": "\tprotected void addCacheHeaders(ServerHttpResponse response) {\n\t\tresponse.getHeaders().setCacheControl(\"public, max-age=\" + ONE_YEAR);\n\t\tresponse.getHeaders().setExpires(System.currentTimeMillis() + ONE_YEAR * 1000);\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService#addNoCacheHeaders(response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "response"
    ],
    "position": {
      "column": 1,
      "line": 555
    },
    "return": "void",
    "signature": "protected void addNoCacheHeaders(ServerHttpResponse response)",
    "source_code": "\tprotected void addNoCacheHeaders(ServerHttpResponse response) {\n\t\tresponse.getHeaders().setCacheControl(\"no-store, no-cache, must-revalidate, max-age=0\");\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService#checkOrigin(request,response,httpMethods)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "httpMethods"
    ],
    "position": {
      "column": 1,
      "line": 523
    },
    "return": "boolean",
    "signature": "protected boolean checkOrigin(ServerHttpRequest request, ServerHttpResponse response, HttpMethod... httpMethods)",
    "source_code": "\tprotected boolean checkOrigin(ServerHttpRequest request, ServerHttpResponse response, HttpMethod... httpMethods)"
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService#getAllowedOriginPatterns()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return {@link #setAllowedOriginPatterns(Collection) configured} origin patterns.\n\t * @since 5.3.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 366
    },
    "return": "Collection<String>",
    "signature": "public Collection<String> getAllowedOriginPatterns()",
    "source_code": "\tpublic Collection<String> getAllowedOriginPatterns() {\n\t\treturn this.corsConfiguration.getAllowedOriginPatterns();\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService#getAllowedOrigins()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link #setAllowedOrigins(Collection) configured} allowed origins.\n\t * @since 4.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 344
    },
    "return": "Collection<String>",
    "signature": "public Collection<String> getAllowedOrigins()",
    "source_code": "\tpublic Collection<String> getAllowedOrigins() {\n\t\treturn this.corsConfiguration.getAllowedOrigins();\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService#getCorsConfiguration(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 543
    },
    "return": "CorsConfiguration",
    "signature": "public CorsConfiguration getCorsConfiguration(HttpServletRequest request)",
    "source_code": "\tpublic CorsConfiguration getCorsConfiguration(HttpServletRequest request) {\n\t\tif (!this.suppressCors && (request.getHeader(HttpHeaders.ORIGIN) != null)) {\n\t\t\treturn this.corsConfiguration;\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService#getDisconnectDelay()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the amount of time in milliseconds before a client is considered disconnected.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "long",
    "signature": "public long getDisconnectDelay()",
    "source_code": "\tpublic long getDisconnectDelay() {\n\t\treturn this.disconnectDelay;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService#getHeartbeatTime()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the amount of time in milliseconds when the server has not sent\n\t * any messages.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "long",
    "signature": "public long getHeartbeatTime()",
    "source_code": "\tpublic long getHeartbeatTime() {\n\t\treturn this.heartbeatTime;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService#getHttpMessageCacheSize()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the size of the HTTP message cache.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "int",
    "signature": "public int getHttpMessageCacheSize()",
    "source_code": "\tpublic int getHttpMessageCacheSize() {\n\t\treturn this.httpMessageCacheSize;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService#getName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the unique name associated with this service.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "String",
    "signature": "public String getName()",
    "source_code": "\tpublic String getName() {\n\t\treturn this.name;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService#getSockJsClientLibraryUrl()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return he URL to the SockJS JavaScript client library.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "String",
    "signature": "public String getSockJsClientLibraryUrl()",
    "source_code": "\tpublic String getSockJsClientLibraryUrl() {\n\t\treturn this.clientLibraryUrl;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService#getStreamBytesLimit()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the minimum number of bytes that can be sent over a single HTTP\n\t * streaming request before it will be closed.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "int",
    "signature": "public int getStreamBytesLimit()",
    "source_code": "\tpublic int getStreamBytesLimit() {\n\t\treturn this.streamBytesLimit;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService#getTaskScheduler()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A scheduler instance to use for scheduling heart-beat messages.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "TaskScheduler",
    "signature": "public TaskScheduler getTaskScheduler()",
    "source_code": "\tpublic TaskScheduler getTaskScheduler() {\n\t\treturn this.taskScheduler;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService#handle(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 636
    },
    "return": "void",
    "signature": "public void handle(ServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\t\tpublic void handle(ServerHttpRequest request, ServerHttpResponse response) throws IOException {\n\t\t\tif (request.getMethod() != HttpMethod.GET) {\n\t\t\t\tsendMethodNotAllowed(response, HttpMethod.GET);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tString content = String.format(IFRAME_CONTENT, getSockJsClientLibraryUrl());\n\t\t\tbyte[] contentBytes = content.getBytes(StandardCharsets.UTF_8);\n\t\t\tStringBuilder builder = new StringBuilder(\"\\\"0\");\n\t\t\tDigestUtils.appendMd5DigestAsHex(contentBytes, builder);\n\t\t\tbuilder.append('\"');\n\t\t\tString etagValue = builder.toString();\n\n\t\t\tList<String> ifNoneMatch = request.getHeaders().getIfNoneMatch();\n\t\t\tif (!CollectionUtils.isEmpty(ifNoneMatch) && ifNoneMatch.get(0).equals(etagValue)) {\n\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_MODIFIED);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresponse.getHeaders().setContentType(new MediaType(\"text\", \"html\", StandardCharsets.UTF_8));\n\t\t\tresponse.getHeaders().setContentLength(contentBytes.length);\n\n\t\t\t// No cache in order to check every time if IFrame are authorized\n\t\t\taddNoCacheHeaders(response);\n\t\t\tresponse.getHeaders().setETag(etagValue);\n\t\t\tresponse.getBody().write(contentBytes);\n\t\t}"
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService#handleRawWebSocketRequest(request,response,webSocketHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle request for raw WebSocket communication, i.e. without any SockJS message framing.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "webSocketHandler"
    ],
    "position": {
      "column": 1,
      "line": 569
    },
    "return": "void",
    "signature": "protected void handleRawWebSocketRequest(ServerHttpRequest request,\n\t\t\tServerHttpResponse response, WebSocketHandler webSocketHandler)",
    "source_code": "\tprotected abstract void handleRawWebSocketRequest(ServerHttpRequest request,"
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService#handleRequest(request,response,sockJsPath,wsHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This method determines the SockJS path and handles SockJS static URLs.\n\t * Session URLs and raw WebSocket requests are delegated to abstract methods.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "sockJsPath",
      "wsHandler"
    ],
    "position": {
      "column": 1,
      "line": 376
    },
    "return": "void",
    "signature": "public void handleRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\t@Nullable String sockJsPath, WebSocketHandler wsHandler)",
    "source_code": "\tpublic final void handleRequest(ServerHttpRequest request, ServerHttpResponse response,"
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService#handleTransportRequest(request,response,webSocketHandler,sessionId,transport)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle a SockJS session URL (i.e. transport-specific request).\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "webSocketHandler",
      "sessionId",
      "transport"
    ],
    "position": {
      "column": 1,
      "line": 575
    },
    "return": "void",
    "signature": "protected void handleTransportRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler webSocketHandler, String sessionId, String transport)",
    "source_code": "\tprotected abstract void handleTransportRequest(ServerHttpRequest request, ServerHttpResponse response,"
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService#isSessionCookieNeeded()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether the JSESSIONID cookie is required for the application to function.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "boolean",
    "signature": "public boolean isSessionCookieNeeded()",
    "source_code": "\tpublic boolean isSessionCookieNeeded() {\n\t\treturn this.sessionCookieNeeded;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService#isWebSocketEnabled()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether WebSocket transport is enabled.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "boolean",
    "signature": "public boolean isWebSocketEnabled()",
    "source_code": "\tpublic boolean isWebSocketEnabled() {\n\t\treturn this.webSocketEnabled;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService#sendMethodNotAllowed(response,httpMethods)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "response",
      "httpMethods"
    ],
    "position": {
      "column": 1,
      "line": 559
    },
    "return": "void",
    "signature": "protected void sendMethodNotAllowed(ServerHttpResponse response, HttpMethod... httpMethods)",
    "source_code": "\tprotected void sendMethodNotAllowed(ServerHttpResponse response, HttpMethod... httpMethods) {\n\t\tlogger.warn(\"Sending Method Not Allowed (405)\");\n\t\tresponse.setStatusCode(HttpStatus.METHOD_NOT_ALLOWED);\n\t\tresponse.getHeaders().setAllow(new LinkedHashSet<>(Arrays.asList(httpMethods)));\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService#setAllowedOriginPatterns(allowedOriginPatterns)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Alternative to {@link #setAllowedOrigins(Collection)} that supports more\n\t * flexible patterns for specifying the origins for which cross-origin\n\t * requests are allowed from a browser. Please, refer to\n\t * {@link CorsConfiguration#setAllowedOriginPatterns(List)} for format\n\t * details and other considerations.\n\t * <p>By default this is not set.\n\t * @since 5.2.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "allowedOriginPatterns"
    ],
    "position": {
      "column": 1,
      "line": 356
    },
    "return": "void",
    "signature": "public void setAllowedOriginPatterns(Collection<String> allowedOriginPatterns)",
    "source_code": "\tpublic void setAllowedOriginPatterns(Collection<String> allowedOriginPatterns) {\n\t\tAssert.notNull(allowedOriginPatterns, \"Allowed origin patterns Collection must not be null\");\n\t\tthis.corsConfiguration.setAllowedOriginPatterns(new ArrayList<>(allowedOriginPatterns));\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService#setAllowedOrigins(allowedOrigins)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the origins for which cross-origin requests are allowed from a browser.\n\t * Please, refer to {@link CorsConfiguration#setAllowedOrigins(List)} for\n\t * format details and considerations, and keep in mind that the CORS spec\n\t * does not allow use of {@code \"*\"} with {@code allowCredentials=true}.\n\t * For more flexible origin patterns use {@link #setAllowedOriginPatterns}\n\t * instead.\n\t *\n\t * <p>By default, no origins are allowed. When\n\t * {@link #setAllowedOriginPatterns(Collection) allowedOriginPatterns} is also\n\t * set, then that takes precedence over this property.\n\t *\n\t * <p>Note when SockJS is enabled and origins are restricted, transport types\n\t * that do not allow to check request origin (Iframe based transports) are\n\t * disabled. As a consequence, IE 6 to 9 are not supported when origins are\n\t * restricted.\n\t * @since 4.1.2\n\t * @see #setAllowedOriginPatterns(Collection)\n\t * @see <a href=\"https://tools.ietf.org/html/rfc6454\">RFC 6454: The Web Origin Concept</a>\n\t * @see <a href=\"https://github.com/sockjs/sockjs-client#supported-transports-by-browser-html-served-from-http-or-https\">SockJS supported transports by browser</a>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "allowedOrigins"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "void",
    "signature": "public void setAllowedOrigins(Collection<String> allowedOrigins)",
    "source_code": "\tpublic void setAllowedOrigins(Collection<String> allowedOrigins) {\n\t\tAssert.notNull(allowedOrigins, \"Allowed origins Collection must not be null\");\n\t\tthis.corsConfiguration.setAllowedOrigins(new ArrayList<>(allowedOrigins));\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService#setDisconnectDelay(disconnectDelay)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The amount of time in milliseconds before a client is considered\n\t * disconnected after not having a receiving connection, i.e. an active\n\t * connection over which the server can send data to the client.\n\t * <p>The default value is 5000.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "disconnectDelay"
    ],
    "position": {
      "column": 1,
      "line": 247
    },
    "return": "void",
    "signature": "public void setDisconnectDelay(long disconnectDelay)",
    "source_code": "\tpublic void setDisconnectDelay(long disconnectDelay) {\n\t\tthis.disconnectDelay = disconnectDelay;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService#setHeartbeatTime(heartbeatTime)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the amount of time in milliseconds when the server has not sent\n\t * any messages and after which the server should send a heartbeat frame\n\t * to the client in order to keep the connection from breaking.\n\t * <p>The default value is 25,000 (25 seconds).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "heartbeatTime"
    ],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "void",
    "signature": "public void setHeartbeatTime(long heartbeatTime)",
    "source_code": "\tpublic void setHeartbeatTime(long heartbeatTime) {\n\t\tthis.heartbeatTime = heartbeatTime;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService#setHttpMessageCacheSize(httpMessageCacheSize)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The number of server-to-client messages that a session can cache while waiting\n\t * for the next HTTP polling request from the client. All HTTP transports use this\n\t * property since even streaming transports recycle HTTP requests periodically.\n\t * <p>The amount of time between HTTP requests should be relatively brief and will\n\t * not exceed the allows disconnect delay (see {@link #setDisconnectDelay(long)});\n\t * 5 seconds by default.\n\t * <p>The default size is 100.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "httpMessageCacheSize"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "void",
    "signature": "public void setHttpMessageCacheSize(int httpMessageCacheSize)",
    "source_code": "\tpublic void setHttpMessageCacheSize(int httpMessageCacheSize) {\n\t\tthis.httpMessageCacheSize = httpMessageCacheSize;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService#setName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a unique name for this service (mainly for logging purposes).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "void",
    "signature": "public void setName(String name)",
    "source_code": "\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService#setSessionCookieNeeded(sessionCookieNeeded)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The SockJS protocol requires a server to respond to an initial \"/info\" request from\n\t * clients with a \"cookie_needed\" boolean property that indicates whether the use of a\n\t * JSESSIONID cookie is required for the application to function correctly, e.g. for\n\t * load balancing or in Java Servlet containers for the use of an HTTP session.\n\t * <p>This is especially important for IE 8,9 that support XDomainRequest -- a modified\n\t * AJAX/XHR -- that can do requests across domains but does not send any cookies. In\n\t * those cases, the SockJS client prefers the \"iframe-htmlfile\" transport over\n\t * \"xdr-streaming\" in order to be able to send cookies.\n\t * <p>The SockJS protocol also expects a SockJS service to echo back the JSESSIONID\n\t * cookie when this property is set to true. However, when running in a Servlet\n\t * container this is not necessary since the container takes care of it.\n\t * <p>The default value is \"true\" to maximize the chance for applications to work\n\t * correctly in IE 8,9 with support for cookies (and the JSESSIONID cookie in\n\t * particular). However, an application can choose to set this to \"false\" if\n\t * the use of cookies (and HTTP session) is not required.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionCookieNeeded"
    ],
    "position": {
      "column": 1,
      "line": 212
    },
    "return": "void",
    "signature": "public void setSessionCookieNeeded(boolean sessionCookieNeeded)",
    "source_code": "\tpublic void setSessionCookieNeeded(boolean sessionCookieNeeded) {\n\t\tthis.sessionCookieNeeded = sessionCookieNeeded;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService#setSockJsClientLibraryUrl(clientLibraryUrl)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Transports with no native cross-domain communication (e.g. \"eventsource\",\n\t * \"htmlfile\") must get a simple page from the \"foreign\" domain in an invisible\n\t * {@code iframe} so that code in the {@code iframe} can run from a domain\n\t * local to the SockJS server. Since the {@code iframe} needs to load the\n\t * SockJS JavaScript client library, this property allows specifying where to\n\t * load it from.\n\t * <p>By default this is set to point to\n\t * <a href=\"https://cdn.jsdelivr.net/sockjs/1.0.0/sockjs.min.js\">\"https://cdn.jsdelivr.net/sockjs/1.0.0/sockjs.min.js\"</a>.\n\t * However, it can also be set to point to a URL served by the application.\n\t * <p>Note that it's possible to specify a relative URL in which case the URL\n\t * must be relative to the {@code iframe} URL. For example assuming a SockJS endpoint\n\t * mapped to \"/sockjs\", and resulting {@code iframe} URL \"/sockjs/iframe.html\", then\n\t * the relative URL must start with \"../../\" to traverse up to the location\n\t * above the SockJS mapping. In case of a prefix-based Servlet mapping one more\n\t * traversals may be needed.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clientLibraryUrl"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "void",
    "signature": "public void setSockJsClientLibraryUrl(String clientLibraryUrl)",
    "source_code": "\tpublic void setSockJsClientLibraryUrl(String clientLibraryUrl) {\n\t\tthis.clientLibraryUrl = clientLibraryUrl;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService#setStreamBytesLimit(streamBytesLimit)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Streaming transports save responses on the client side and don't free\n\t * memory used by delivered messages. Such transports need to recycle the\n\t * connection once in a while. This property sets a minimum number of bytes\n\t * that can be sent over a single HTTP streaming request before it will be\n\t * closed. After that client will open a new request. Setting this value to\n\t * one effectively disables streaming and will make streaming transports to\n\t * behave like polling transports.\n\t * <p>The default value is 128K (i.e. 128 * 1024).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "streamBytesLimit"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "void",
    "signature": "public void setStreamBytesLimit(int streamBytesLimit)",
    "source_code": "\tpublic void setStreamBytesLimit(int streamBytesLimit) {\n\t\tthis.streamBytesLimit = streamBytesLimit;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService#setSuppressCors(suppressCors)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This option can be used to disable automatic addition of CORS headers for\n\t * SockJS requests.\n\t * <p>The default value is \"false\".\n\t * @since 4.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "suppressCors"
    ],
    "position": {
      "column": 1,
      "line": 300
    },
    "return": "void",
    "signature": "public void setSuppressCors(boolean suppressCors)",
    "source_code": "\tpublic void setSuppressCors(boolean suppressCors) {\n\t\tthis.suppressCors = suppressCors;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService#setWebSocketEnabled(webSocketEnabled)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Some load balancers do not support WebSocket. This option can be used to\n\t * disable the WebSocket transport on the server side.\n\t * <p>The default value is \"true\".\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webSocketEnabled"
    ],
    "position": {
      "column": 1,
      "line": 283
    },
    "return": "void",
    "signature": "public void setWebSocketEnabled(boolean webSocketEnabled)",
    "source_code": "\tpublic void setWebSocketEnabled(boolean webSocketEnabled) {\n\t\tthis.webSocketEnabled = webSocketEnabled;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService#shouldSuppressCors()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return if automatic addition of CORS headers has been disabled.\n\t * @since 4.1.2\n\t * @see #setSuppressCors\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "boolean",
    "signature": "public boolean shouldSuppressCors()",
    "source_code": "\tpublic boolean shouldSuppressCors() {\n\t\treturn this.suppressCors;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.AbstractSockJsService#validateRequest(serverId,sessionId,transport)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "serverId",
      "sessionId",
      "transport"
    ],
    "position": {
      "column": 1,
      "line": 493
    },
    "return": "boolean",
    "signature": "protected boolean validateRequest(String serverId, String sessionId, String transport)",
    "source_code": "\tprotected boolean validateRequest(String serverId, String sessionId, String transport) {\n\t\tif (!StringUtils.hasText(serverId) || !StringUtils.hasText(sessionId) || !StringUtils.hasText(transport)) {\n\t\t\tlogger.warn(\"No server, session, or transport path segment in SockJS request.\");\n\t\t\treturn false;\n\t\t}\n\n\t\t// Server and session id's must not contain \".\"\n\t\tif (serverId.contains(\".\") || sessionId.contains(\".\")) {\n\t\t\tlogger.warn(\"Either server or session contains a \\\".\\\" which is not allowed by SockJS protocol.\");\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.corsConfiguration": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "signature": "protected CorsConfiguration corsConfiguration",
    "source_code": "\tprotected final CorsConfiguration corsConfiguration;",
    "type": "CorsConfiguration"
  },
  "org.springframework.web.socket.sockjs.support.logger": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.web.socket.sockjs.transport.handler.HtmlFileTransportHandler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * An HTTP {@link TransportHandler} that uses a famous browser\n * {@code document.domain technique}. See <a href=\n * \"https://stackoverflow.com/questions/1481251/what-does-document-domain-document-domain-do\">\n * stackoverflow.com/questions/1481251/what-does-document-domain-document-domain-do</a>\n * for details.\n *\n * @author Rossen Stoyanchev\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "signature": "public class HtmlFileTransportHandler",
    "source_code": "public class HtmlFileTransportHandler extends AbstractHttpSendingTransportHandler {\n\n\tprivate static final String PARTIAL_HTML_CONTENT;\n\n\t// Safari needs at least 1024 bytes to parse the website.\n\t// https://code.google.com/p/browsersec/wiki/Part2#Survey_of_content_sniffing_behaviors\n\tprivate static final int MINIMUM_PARTIAL_HTML_CONTENT_LENGTH = 1024;\n\n\n\tstatic {\n\t\tStringBuilder sb = new StringBuilder(\"\"\"\n\t\t\t\t<!DOCTYPE html>\n\t\t\t\t<html><head>\n\t\t\t\t\t<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n\t\t\t\t\t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n\t\t\t\t</head><body><h2>Don't panic!</h2>\n\t\t\t\t\t<script>\n\t\t\t\t\t\tdocument.domain = document.domain;\n\t\t\t\t\t\tvar c = parent.%s;\n\t\t\t\t\t\tc.start();\n\t\t\t\t\t\tfunction p(d) {c.message(d);};\n\t\t\t\t\t\twindow.onload = function() {c.stop();};\n\t\t\t\t\t</script>\"\"\");\n\n\t\tsb.append(\" \".repeat(MINIMUM_PARTIAL_HTML_CONTENT_LENGTH - sb.length()));\n\t\tPARTIAL_HTML_CONTENT = sb.append('\\n').toString();\n\t}\n\n\n\t@Override\n\tpublic TransportType getTransportType() {\n\t\treturn TransportType.HTML_FILE;\n\t}\n\n\t@Override\n\tprotected MediaType getContentType() {\n\t\treturn new MediaType(\"text\", \"html\", StandardCharsets.UTF_8);\n\t}\n\n\t@Override\n\tpublic boolean checkSessionType(SockJsSession session) {\n\t\treturn (session instanceof HtmlFileStreamingSockJsSession);\n\t}\n\n\t@Override\n\tpublic StreamingSockJsSession createSession(\n\t\t\tString sessionId, WebSocketHandler handler, Map<String, Object> attributes) {\n\n\t\treturn new HtmlFileStreamingSockJsSession(sessionId, getServiceConfig(), handler, attributes);\n\t}\n\n\t@Override\n\tpublic void handleRequestInternal(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tAbstractHttpSockJsSession sockJsSession) throws SockJsException {\n\n\t\tString callback = getCallbackParam(request);\n\t\tif (!StringUtils.hasText(callback)) {\n\t\t\tresponse.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR);\n\t\t\ttry {\n\t\t\t\tresponse.getBody().write(\"\\\"callback\\\" parameter required\".getBytes(StandardCharsets.UTF_8));\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tsockJsSession.tryCloseWithSockJsTransportError(ex, CloseStatus.SERVER_ERROR);\n\t\t\t\tthrow new SockJsTransportFailureException(\"Failed to write to response\", sockJsSession.getId(), ex);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tsuper.handleRequestInternal(request, response, sockJsSession);\n\t}\n\n\t@Override\n\tprotected SockJsFrameFormat getFrameFormat(ServerHttpRequest request) {\n\t\treturn new DefaultSockJsFrameFormat(\"<script>\\np(\\\"%s\\\");\\n</script>\\r\\n\") {\n\t\t\t@Override\n\t\t\tprotected String preProcessContent(String content) {\n\t\t\t\treturn JavaScriptUtils.javaScriptEscape(content);\n\t\t\t}\n\t\t};\n\t}\n\n\n\tprivate class HtmlFileStreamingSockJsSession extends StreamingSockJsSession {\n\n\t\tpublic HtmlFileStreamingSockJsSession(String sessionId, SockJsServiceConfig config,\n\t\t\t\tWebSocketHandler wsHandler, Map<String, Object> attributes) {\n\n\t\t\tsuper(sessionId, config, wsHandler, attributes);\n\t\t}\n\n\t\t@Override\n\t\tprotected byte[] getPrelude(ServerHttpRequest request) {\n\t\t\t// We already validated the parameter above...\n\t\t\tString callback = getCallbackParam(request);\n\t\t\tString html = String.format(PARTIAL_HTML_CONTENT, callback);\n\t\t\treturn html.getBytes(StandardCharsets.UTF_8);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.HtmlFileTransportHandler#checkSessionType(session)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "boolean",
    "signature": "public boolean checkSessionType(SockJsSession session)",
    "source_code": "\tpublic boolean checkSessionType(SockJsSession session) {\n\t\treturn (session instanceof HtmlFileStreamingSockJsSession);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.HtmlFileTransportHandler#createSession(sessionId,handler,Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionId",
      "handler",
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "StreamingSockJsSession",
    "signature": "public StreamingSockJsSession createSession(String sessionId, WebSocketHandler handler, Map<String, Object> attributes)",
    "source_code": "\tpublic StreamingSockJsSession createSession("
  },
  "org.springframework.web.socket.sockjs.transport.handler.HtmlFileTransportHandler#getContentType()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "MediaType",
    "signature": "protected MediaType getContentType()",
    "source_code": "\tprotected MediaType getContentType() {\n\t\treturn new MediaType(\"text\", \"html\", StandardCharsets.UTF_8);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.HtmlFileTransportHandler#getFrameFormat(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "SockJsFrameFormat",
    "signature": "protected SockJsFrameFormat getFrameFormat(ServerHttpRequest request)",
    "source_code": "\tprotected SockJsFrameFormat getFrameFormat(ServerHttpRequest request) {\n\t\treturn new DefaultSockJsFrameFormat(\"<script>\\np(\\\"%s\\\");\\n</script>\\r\\n\") {\n\t\t\t@Override\n\t\t\tprotected String preProcessContent(String content) {\n\t\t\t\treturn JavaScriptUtils.javaScriptEscape(content);\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.HtmlFileTransportHandler#getPrelude(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "byte[]",
    "signature": "protected byte[] getPrelude(ServerHttpRequest request)",
    "source_code": "\t\tprotected byte[] getPrelude(ServerHttpRequest request) {\n\t\t\t// We already validated the parameter above...\n\t\t\tString callback = getCallbackParam(request);\n\t\t\tString html = String.format(PARTIAL_HTML_CONTENT, callback);\n\t\t\treturn html.getBytes(StandardCharsets.UTF_8);\n\t\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.HtmlFileTransportHandler#getTransportType()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "TransportType",
    "signature": "public TransportType getTransportType()",
    "source_code": "\tpublic TransportType getTransportType() {\n\t\treturn TransportType.HTML_FILE;\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.HtmlFileTransportHandler#handleRequestInternal(request,response,sockJsSession)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "sockJsSession"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "void",
    "signature": "public void handleRequestInternal(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tAbstractHttpSockJsSession sockJsSession)",
    "source_code": "\tpublic void handleRequestInternal(ServerHttpRequest request, ServerHttpResponse response,"
  },
  "org.springframework.web.socket.sockjs.transport.handler.HtmlFileTransportHandler#preProcessContent(content)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "content"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "String",
    "signature": "protected String preProcessContent(String content)",
    "source_code": "\t\t\tprotected String preProcessContent(String content) {\n\t\t\t\treturn JavaScriptUtils.javaScriptEscape(content);\n\t\t\t}"
  }
}